{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## xmlsoft.org: libxml2 v2.10.4\n+## xmlsoft.org: libxml2 v2.12.6\n@@ -6,2 +6,2 @@\n-Except where otherwise noted in the source code (e.g. the files hash.c,\n-list.c and the trio files, which are covered by a similar licence but\n+Except where otherwise noted in the source code (e.g. the files dict.c,\n+list.c, triodef.h, trionan.h, trionan.c, which are covered by a similar licence but\n@@ -31,2 +31,2 @@\n-The below license applies to the following files:\n-libxml\/src\/timsort.h\n+The below license and copyrights applies to the following files:\n+timsort.h\n@@ -56,3 +56,4 @@\n-=== copyright notices for hash.c, list.c, and the trio files ===\n-hash.c:\n- * Copyright (C) 2000,2012 Bjorn Reese and Daniel Veillard.\n+\n+=== copyright notices for dict.c, list.c, triodef.h, trionan.h and trionan.c  ===\n+dict.c:\n+ * Copyright (C) 2003-2012 Daniel Veillard.\n@@ -61,3 +62,3 @@\n-the trio files:\n- * Copyright (C) 1998 Bjorn Reese and Daniel Stenberg.\n-=== license text for hash.c, list.c, and the trio files ===\n+triodef.h, trionan.h, trionan.c\n+ * Copyright (C) 2001 Bjorn Reese <breese@users.sourceforge.net>\n+=== license text for dict.c, list.c, triodef.h, trionan.h and trionan.c  ===\n@@ -76,0 +77,12 @@\n+\n+### AUTHORS Information\n+```\n+\n+Daniel Veillard\n+Bjorn Reese\n+William Brack\n+Igor Zlatkovic for the Windows port\n+Aleksey Sanin\n+Nick Wellnhofer\n+\n+```\n","filename":"modules\/javafx.web\/src\/main\/legal\/libxml2.md","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -7,3 +7,0 @@\n-\/* Type cast for the gethostbyname() argument *\/\n-#define GETHOSTBYNAME_ARG_CAST \/**\/\n-\n@@ -13,3 +10,0 @@\n-\/* Define to 1 if you have the <arpa\/nameser.h> header file. *\/\n-#define HAVE_ARPA_NAMESER_H 1\n-\n@@ -19,3 +13,0 @@\n-\/* Whether struct sockaddr::__ss_family exists *\/\n-\/* #undef HAVE_BROKEN_SS_FAMILY *\/\n-\n@@ -37,3 +28,0 @@\n-\/* Define if getaddrinfo is there *\/\n-#define HAVE_GETADDRINFO \/**\/\n-\n@@ -43,0 +31,3 @@\n+\/* Define to 1 if you have the <glob.h> header file. *\/\n+#define HAVE_GLOB_H 1\n+\n@@ -78,1 +69,1 @@\n-\/* Define if <pthread.h> is there *\/\n+\/* Define to 1 if you have the <pthread.h> header file. *\/\n@@ -81,9 +72,0 @@\n-\/* Define to 1 if you have the `putenv' function. *\/\n-#define HAVE_PUTENV 1\n-\n-\/* Define to 1 if you have the `rand_r' function. *\/\n-#define HAVE_RAND_R 1\n-\n-\/* Define to 1 if you have the <resolv.h> header file. *\/\n-#define HAVE_RESOLV_H 1\n-\n@@ -93,3 +75,0 @@\n-\/* Define to 1 if you have the `snprintf' function. *\/\n-#define HAVE_SNPRINTF 1\n-\n@@ -141,3 +120,0 @@\n-\/* Define to 1 if you have the `vsnprintf' function. *\/\n-#define HAVE_VSNPRINTF 1\n-\n@@ -163,1 +139,1 @@\n-#define PACKAGE_STRING \"libxml2 2.10.4\"\n+#define PACKAGE_STRING \"libxml2 2.12.6\"\n@@ -172,4 +148,1 @@\n-#define PACKAGE_VERSION \"2.10.4\"\n-\n-\/* Type cast for the send() function 2nd arg *\/\n-#define SEND_ARG2_CAST \/**\/\n+#define PACKAGE_VERSION \"2.12.6\"\n@@ -189,1 +162,1 @@\n-#define VERSION \"2.10.4\"\n+#define VERSION \"2.12.6\"\n@@ -194,0 +167,3 @@\n+\/* TLS specifier *\/\n+\/* #undef XML_THREAD_LOCAL *\/\n+\n@@ -199,3 +175,0 @@\n-\/* ss_family is not defined here, use __ss_family instead *\/\n-\/* #undef ss_family *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/config.h","additions":10,"deletions":37,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-XMLPUBFUN void XMLCALL xmlCheckVersion(int version);\n+XMLPUBFUN void xmlCheckVersion(int version);\n@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.10.4\"\n+#define LIBXML_DOTTED_VERSION \"2.12.6\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 21004\n+#define LIBXML_VERSION 21206\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"21004\"\n+#define LIBXML_VERSION_STRING \"21206\"\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(21004);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(21206);\n@@ -250,0 +250,9 @@\n+\/**\n+ * LIBXML_XPTR_LOCS_ENABLED:\n+ *\n+ * Whether support for XPointer locations is configured in\n+ *\/\n+#if 0\n+#define LIBXML_XPTR_LOCS_ENABLED\n+#endif\n+\n@@ -307,1 +316,1 @@\n- * Whether the runtime debugging is configured in\n+ * Removed\n@@ -403,6 +412,1 @@\n-\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * Macro used to signal to GCC unused function parameters\n- *\/\n+\/** DOC_DISABLE *\/\n@@ -418,6 +422,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n-\n@@ -434,6 +432,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n-\n@@ -451,1 +443,1 @@\n-#  ifdef IN_LIBXML\n+#  if defined (IN_LIBXML) || (__GNUC__ * 100 + __GNUC_MINOR__ < 301)\n@@ -453,1 +445,0 @@\n-#  else\n@@ -455,0 +446,1 @@\n+#  else\n@@ -459,0 +451,18 @@\n+#if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 406)\n+  #if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 800)\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wcast-function-type\\\"\")\n+  #else\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\")\n+  #endif\n+  #define XML_POP_WARNINGS \\\n+    _Pragma(\"GCC diagnostic pop\")\n+#else\n+  #define XML_IGNORE_FPTR_CAST_WARNINGS\n+  #define XML_POP_WARNINGS\n+#endif\n+\n@@ -460,5 +470,0 @@\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * Macro used to signal to GCC unused function parameters\n- *\/\n@@ -466,5 +471,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n@@ -472,5 +472,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n@@ -478,6 +473,0 @@\n-\/**\n- * XML_DEPRECATED:\n- *\n- * Macro used to indicate that a function, variable, type or struct member\n- * is deprecated.\n- *\/\n@@ -485,1 +474,18 @@\n-#define XML_DEPRECATED\n+#  if defined (IN_LIBXML) || !defined (_MSC_VER)\n+#    define XML_DEPRECATED\n+\/* Available since Visual Studio 2005 *\/\n+#  elif defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_DEPRECATED __declspec(deprecated)\n+#  endif\n+#endif\n+#if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS __pragma(warning(push))\n+#else\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS\n+#endif\n+#ifndef XML_POP_WARNINGS\n+#  if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_POP_WARNINGS __pragma(warning(pop))\n+#  else\n+#    define XML_POP_WARNINGS\n+#  endif\n@@ -489,0 +495,11 @@\n+#define XML_NO_ATTR\n+\n+#ifdef LIBXML_THREAD_ENABLED\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBFUN type *__##name(void);\n+  #define XML_GLOBAL_MACRO(name) (*__##name())\n+#else\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBVAR type name;\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/include\/libxml\/xmlversion.h","additions":65,"deletions":48,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -7,3 +7,0 @@\n-\/* Type cast for the gethostbyname() argument *\/\n-#define GETHOSTBYNAME_ARG_CAST \/**\/\n-\n@@ -13,3 +10,0 @@\n-\/* Define to 1 if you have the <arpa\/nameser.h> header file. *\/\n-#define HAVE_ARPA_NAMESER_H 1\n-\n@@ -19,3 +13,0 @@\n-\/* Whether struct sockaddr::__ss_family exists *\/\n-\/* #undef HAVE_BROKEN_SS_FAMILY *\/\n-\n@@ -37,3 +28,0 @@\n-\/* Define if getaddrinfo is there *\/\n-#define HAVE_GETADDRINFO \/**\/\n-\n@@ -43,0 +31,3 @@\n+\/* Define to 1 if you have the <glob.h> header file. *\/\n+#define HAVE_GLOB_H 1\n+\n@@ -78,1 +69,1 @@\n-\/* Define if <pthread.h> is there *\/\n+\/* Define to 1 if you have the <pthread.h> header file. *\/\n@@ -81,9 +72,0 @@\n-\/* Define to 1 if you have the `putenv' function. *\/\n-#define HAVE_PUTENV 1\n-\n-\/* Define to 1 if you have the `rand_r' function. *\/\n-#define HAVE_RAND_R 1\n-\n-\/* Define to 1 if you have the <resolv.h> header file. *\/\n-#define HAVE_RESOLV_H 1\n-\n@@ -93,3 +75,0 @@\n-\/* Define to 1 if you have the `snprintf' function. *\/\n-#define HAVE_SNPRINTF 1\n-\n@@ -141,3 +120,0 @@\n-\/* Define to 1 if you have the `vsnprintf' function. *\/\n-#define HAVE_VSNPRINTF 1\n-\n@@ -163,1 +139,1 @@\n-#define PACKAGE_STRING \"libxml2 2.10.4\"\n+#define PACKAGE_STRING \"libxml2 2.12.6\"\n@@ -172,4 +148,1 @@\n-#define PACKAGE_VERSION \"2.10.4\"\n-\n-\/* Type cast for the send() function 2nd arg *\/\n-#define SEND_ARG2_CAST \/**\/\n+#define PACKAGE_VERSION \"2.12.6\"\n@@ -189,1 +162,1 @@\n-#define VERSION \"2.10.4\"\n+#define VERSION \"2.12.6\"\n@@ -194,0 +167,3 @@\n+\/* TLS specifier *\/\n+\/* #undef XML_THREAD_LOCAL *\/\n+\n@@ -199,3 +175,0 @@\n-\/* ss_family is not defined here, use __ss_family instead *\/\n-\/* #undef ss_family *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/mac\/config.h","additions":10,"deletions":37,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-XMLPUBFUN void XMLCALL xmlCheckVersion(int version);\n+XMLPUBFUN void xmlCheckVersion(int version);\n@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.10.4\"\n+#define LIBXML_DOTTED_VERSION \"2.12.6\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 21004\n+#define LIBXML_VERSION 21206\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"21004\"\n+#define LIBXML_VERSION_STRING \"21206\"\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(21004);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(21206);\n@@ -232,9 +232,0 @@\n-\/**\n- * LIBXML_DOCB_ENABLED:\n- *\n- * Whether the SGML Docbook support is configured in\n- *\/\n-#if 0\n-#define LIBXML_DOCB_ENABLED\n-#endif\n-\n@@ -259,0 +250,9 @@\n+\/**\n+ * LIBXML_XINCLUDE_ENABLED:\n+ *\n+ * Whether XInclude is configured in\n+ *\/\n+#if 0\n+#define LIBXML_XPTR_LOCS_ENABLED\n+#endif\n+\n@@ -427,6 +427,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n-\n@@ -443,6 +437,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n-\n@@ -460,1 +448,1 @@\n-#  ifdef IN_LIBXML\n+#  if defined (IN_LIBXML) || (__GNUC__ * 100 + __GNUC_MINOR__ < 301)\n@@ -462,1 +450,0 @@\n-#  else\n@@ -464,0 +451,1 @@\n+#  else\n@@ -468,0 +456,18 @@\n+#if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 406)\n+  #if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 800)\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wcast-function-type\\\"\")\n+  #else\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\")\n+  #endif\n+  #define XML_POP_WARNINGS \\\n+    _Pragma(\"GCC diagnostic pop\")\n+#else\n+  #define XML_IGNORE_FPTR_CAST_WARNINGS\n+  #define XML_POP_WARNINGS\n+#endif\n+\n@@ -469,5 +475,0 @@\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * Macro used to signal to GCC unused function parameters\n- *\/\n@@ -475,5 +476,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n@@ -481,5 +477,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n@@ -487,6 +478,0 @@\n-\/**\n- * XML_DEPRECATED:\n- *\n- * Macro used to indicate that a function, variable, type or struct member\n- * is deprecated.\n- *\/\n@@ -494,1 +479,18 @@\n-#define XML_DEPRECATED\n+#  if defined (IN_LIBXML) || !defined (_MSC_VER)\n+#    define XML_DEPRECATED\n+\/* Available since Visual Studio 2005 *\/\n+#  elif defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_DEPRECATED __declspec(deprecated)\n+#  endif\n+#endif\n+#if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS __pragma(warning(push))\n+#else\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS\n+#endif\n+#ifndef XML_POP_WARNINGS\n+#  if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_POP_WARNINGS __pragma(warning(pop))\n+#  else\n+#    define XML_POP_WARNINGS\n+#  endif\n@@ -498,0 +500,11 @@\n+#define XML_NO_ATTR\n+\n+#ifdef LIBXML_THREAD_ENABLED\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBFUN type *__##name(void);\n+  #define XML_GLOBAL_MACRO(name) (*__##name())\n+#else\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBVAR type name;\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/mac\/include\/libxml\/xmlversion.h","additions":63,"deletions":50,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Except where otherwise noted in the source code (e.g. the files hash.c,\n+Except where otherwise noted in the source code (e.g. the files dict.c,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/Copyright","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+#include <libxml\/HTMLparser.h>\n@@ -22,1 +23,0 @@\n-#include <libxml\/HTMLparser.h>\n@@ -26,1 +26,0 @@\n-#include <libxml\/valid.h>\n@@ -28,1 +27,0 @@\n-#include <libxml\/globals.h>\n@@ -31,2 +29,7 @@\n-#include \"buf.h\"\n-#include \"enc.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/enc.h\"\n+#include \"private\/error.h\"\n+#include \"private\/html.h\"\n+#include \"private\/io.h\"\n+#include \"private\/parser.h\"\n+#include \"private\/tree.h\"\n@@ -38,3 +41,0 @@\n-\/* #define DEBUG *\/\n-\/* #define DEBUG_PUSH *\/\n-\n@@ -148,1 +148,1 @@\n- * Returns 0 in case of error, the index in the stack otherwise\n+ * Returns -1 in case of error, the index in the stack otherwise\n@@ -158,6 +158,6 @@\n-        ctxt->nameMax *= 2;\n-        ctxt->nameTab = (const xmlChar * *)\n-                         xmlRealloc((xmlChar * *)ctxt->nameTab,\n-                                    ctxt->nameMax *\n-                                    sizeof(ctxt->nameTab[0]));\n-        if (ctxt->nameTab == NULL) {\n+        size_t newSize = ctxt->nameMax * 2;\n+        const xmlChar **tmp;\n+\n+        tmp = xmlRealloc((xmlChar **) ctxt->nameTab,\n+                         newSize * sizeof(ctxt->nameTab[0]));\n+        if (tmp == NULL) {\n@@ -165,1 +165,1 @@\n-            return (0);\n+            return (-1);\n@@ -167,0 +167,2 @@\n+        ctxt->nameTab = tmp;\n+        ctxt->nameMax = newSize;\n@@ -273,2 +275,0 @@\n- *   CURRENT Returns the current char value, with the full decoding of\n- *           UTF-8 if we are using this mode. It returns an int.\n@@ -294,1 +294,1 @@\n-        xmlParserInputShrink(ctxt->input)\n+        xmlParserShrink(ctxt)\n@@ -298,3 +298,1 @@\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK)\n-\n-#define CURRENT ((int) (*ctxt->input->cur))\n+        xmlParserGrow(ctxt)\n@@ -306,2 +304,1 @@\n-\/* #define CUR (ctxt->token ? ctxt->token : (int) (*ctxt->input->cur)) *\/\n-#define CUR ((int) (*ctxt->input->cur))\n+#define CUR (*ctxt->input->cur)\n@@ -327,1 +324,0 @@\n-#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)\n@@ -330,1 +326,1 @@\n-    if (l == 1) b[i++] = (xmlChar) v;                                   \\\n+    if (l == 1) b[i++] = v;                                             \\\n@@ -352,2 +348,1 @@\n-        (ctxt->input->encoding != NULL) || (ctxt->input->buf == NULL) ||\n-        (ctxt->input->buf->encoder != NULL))\n+        (ctxt->input->flags & XML_INPUT_HAS_ENCODING))\n@@ -412,1 +407,8 @@\n-    if (ctxt->charset != XML_CHAR_ENCODING_UTF8) {\n+\n+    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK) {\n+        xmlParserGrow(ctxt);\n+        if (ctxt->instate == XML_PARSER_EOF)\n+            return(0);\n+    }\n+\n+    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n@@ -421,1 +423,1 @@\n-        if ((int) *ctxt->input->cur < 0x80) {\n+        if (*ctxt->input->cur < 0x80) {\n@@ -429,1 +431,1 @@\n-            return((int) *ctxt->input->cur);\n+            return(*ctxt->input->cur);\n@@ -439,3 +441,0 @@\n-            if (ctxt->input->encoding != NULL)\n-                xmlFree((xmlChar *) ctxt->input->encoding);\n-            ctxt->input->encoding = guess;\n@@ -454,0 +453,1 @@\n+            xmlFree(guess);\n@@ -455,1 +455,1 @@\n-        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;\n@@ -472,0 +472,2 @@\n+        size_t avail;\n+\n@@ -474,5 +476,4 @@\n-        if (cur[1] == 0) {\n-            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-            cur = ctxt->input->cur;\n-        }\n-        if ((cur[1] & 0xc0) != 0x80)\n+\n+        avail = ctxt->input->end - ctxt->input->cur;\n+\n+        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))\n@@ -481,6 +482,1 @@\n-\n-            if (cur[2] == 0) {\n-                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                cur = ctxt->input->cur;\n-            }\n-            if ((cur[2] & 0xc0) != 0x80)\n+            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))\n@@ -489,4 +485,0 @@\n-                if (cur[3] == 0) {\n-                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                    cur = ctxt->input->cur;\n-                }\n@@ -494,1 +486,1 @@\n-                    ((cur[3] & 0xc0) != 0x80))\n+                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))\n@@ -536,1 +528,1 @@\n-        return((int) *ctxt->input->cur);\n+        return(*ctxt->input->cur);\n@@ -540,7 +532,0 @@\n-    \/*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertised in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     *\/\n@@ -562,9 +547,1 @@\n-    \/*\n-     * Don't switch encodings twice. Note that if there's an encoder, we\n-     * shouldn't receive invalid UTF-8 anyway.\n-     *\n-     * Note that if ctxt->input->buf == NULL, switching encodings is\n-     * impossible, see Gitlab issue #34.\n-     *\/\n-    if ((ctxt->input->buf != NULL) &&\n-        (ctxt->input->buf->encoder == NULL))\n+    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)\n@@ -573,1 +550,1 @@\n-    return((int) *ctxt->input->cur);\n+    return(*ctxt->input->cur);\n@@ -590,11 +567,6 @@\n-        if ((*ctxt->input->cur == 0) &&\n-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {\n-                xmlPopInput(ctxt);\n-        } else {\n-            if (*(ctxt->input->cur) == '\\n') {\n-                ctxt->input->line++; ctxt->input->col = 1;\n-            } else ctxt->input->col++;\n-            ctxt->input->cur++;\n-            if (*ctxt->input->cur == 0)\n-                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-        }\n+        if (*(ctxt->input->cur) == '\\n') {\n+            ctxt->input->line++; ctxt->input->col = 1;\n+        } else ctxt->input->col++;\n+        ctxt->input->cur++;\n+        if (*ctxt->input->cur == 0)\n+            xmlParserGrow(ctxt);\n@@ -1226,1 +1198,0 @@\n-    { \"ol\", \"ul\" },\n@@ -1310,1 +1281,0 @@\n-    { \"ul\", \"ol\" },\n@@ -1398,4 +1368,1 @@\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n- * initialize the library.\n- *\n- * This is a no-op now.\n+ * DEPRECATED: This is a no-op.\n@@ -1568,8 +1535,1 @@\n-    while ((newtag != NULL) && (ctxt->name != NULL) &&\n-           (htmlCheckAutoClose(newtag, ctxt->name))) {\n-        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-            ctxt->sax->endElement(ctxt->userData, ctxt->name);\n-        htmlnamePop(ctxt);\n-    }\n-    if (newtag == NULL) {\n-        htmlAutoCloseOnEnd(ctxt);\n+    if (newtag == NULL)\n@@ -1577,5 +1537,3 @@\n-    }\n-    while ((newtag == NULL) && (ctxt->name != NULL) &&\n-           ((xmlStrEqual(ctxt->name, BAD_CAST \"head\")) ||\n-            (xmlStrEqual(ctxt->name, BAD_CAST \"body\")) ||\n-            (xmlStrEqual(ctxt->name, BAD_CAST \"html\")))) {\n+\n+    while ((ctxt->name != NULL) &&\n+           (htmlCheckAutoClose(newtag, ctxt->name))) {\n@@ -2078,2 +2036,2 @@\n-    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size * sizeof(xmlChar)); \\\n-    if (tmp == NULL) {                                          \\\n+    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size);                \\\n+    if (tmp == NULL) {                                                  \\\n@@ -2323,1 +2281,1 @@\n-            if (out + 2 + len > outend)\n+            if (outend - out < len + 2)\n@@ -2575,0 +2533,1 @@\n+    const xmlChar *ret;\n@@ -2592,1 +2551,5 @@\n-    return(xmlDictLookup(ctxt->dict, loc, i));\n+    ret = xmlDictLookup(ctxt->dict, loc, i);\n+    if (ret == NULL)\n+        htmlErrMemory(ctxt, NULL);\n+\n+    return(ret);\n@@ -2677,1 +2640,3 @@\n-    int count = 0;\n+    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+                    XML_MAX_TEXT_LENGTH :\n+                    XML_MAX_NAME_LENGTH;\n@@ -2683,1 +2648,0 @@\n-    GROW;\n@@ -2697,4 +2661,0 @@\n-        if (count++ > 100) {\n-            count = 0;\n-            GROW;\n-        }\n@@ -2702,0 +2662,4 @@\n+        if (len > maxLength) {\n+            htmlParseErr(ctxt, XML_ERR_NAME_TOO_LONG, \"name too long\", NULL, NULL);\n+            return(NULL);\n+        }\n@@ -2712,0 +2676,2 @@\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return(NULL);\n@@ -2739,0 +2705,3 @@\n+    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+                    XML_MAX_HUGE_LENGTH :\n+                    XML_MAX_TEXT_LENGTH;\n@@ -2748,1 +2717,1 @@\n-    buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));\n+    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);\n@@ -2844,0 +2813,4 @@\n+            if (ctxt->instate == XML_PARSER_EOF) {\n+                xmlFree(buffer);\n+                return(NULL);\n+            }\n@@ -2856,1 +2829,7 @@\n-            NEXT;\n+            NEXTL(l);\n+        }\n+        if (out - buffer > maxLength) {\n+            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                         \"attribute value too long\\n\", NULL, NULL);\n+            xmlFree(buffer);\n+            return(NULL);\n@@ -2868,0 +2847,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -3002,1 +2983,0 @@\n-        NEXT;\n@@ -3005,0 +2985,1 @@\n+        NEXT;\n@@ -3057,1 +3038,0 @@\n-        NEXT;\n@@ -3060,0 +3040,1 @@\n+        NEXT;\n@@ -3092,1 +3073,0 @@\n-    SHRINK;\n@@ -3131,0 +3111,1 @@\n+        NEXTL(l);\n@@ -3142,0 +3123,1 @@\n+            SHRINK;\n@@ -3143,2 +3125,0 @@\n-        GROW;\n-        NEXTL(l);\n@@ -3148,0 +3128,3 @@\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return;\n+\n@@ -3178,1 +3161,0 @@\n-    int chunk = 0;\n@@ -3183,1 +3165,0 @@\n-    SHRINK;\n@@ -3194,0 +3175,1 @@\n+        NEXTL(l);\n@@ -3217,5 +3199,0 @@\n-        }\n-        NEXTL(l);\n-        chunk++;\n-        if (chunk > HTML_PARSER_BUFFER_SIZE) {\n-            chunk = 0;\n@@ -3223,1 +3200,0 @@\n-            GROW;\n@@ -3226,5 +3202,0 @@\n-        if (cur == 0) {\n-            SHRINK;\n-            GROW;\n-            cur = CUR_CHAR(l);\n-        }\n@@ -3232,0 +3203,2 @@\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return;\n@@ -3254,6 +3227,0 @@\n-    } else {\n-        \/*\n-         * Loop detection\n-         *\/\n-        if (cur == 0)\n-            ctxt->instate = XML_PARSER_EOF;\n@@ -3350,0 +3317,3 @@\n+    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+                    XML_MAX_HUGE_LENGTH :\n+                    XML_MAX_TEXT_LENGTH;\n@@ -3352,1 +3322,0 @@\n-    int count = 0;\n@@ -3361,1 +3330,0 @@\n-        SHRINK;\n@@ -3382,1 +3350,1 @@\n-            buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+            buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -3400,1 +3368,1 @@\n-                    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+                    tmp = (xmlChar *) xmlRealloc(buf, size);\n@@ -3409,5 +3377,0 @@\n-                count++;\n-                if (count > 50) {\n-                    GROW;\n-                    count = 0;\n-                }\n@@ -3421,0 +3384,7 @@\n+                if (len > maxLength) {\n+                    htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,\n+                                 \"PI %s too long\", target, NULL);\n+                    xmlFree(buf);\n+                    ctxt->instate = state;\n+                    return;\n+                }\n@@ -3423,5 +3393,0 @@\n-                if (cur == 0) {\n-                    SHRINK;\n-                    GROW;\n-                    cur = CUR_CHAR(l);\n-                }\n@@ -3430,0 +3395,4 @@\n+            if (ctxt->instate == XML_PARSER_EOF) {\n+                xmlFree(buf);\n+                return;\n+            }\n@@ -3470,0 +3439,3 @@\n+    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+                    XML_MAX_HUGE_LENGTH :\n+                    XML_MAX_TEXT_LENGTH;\n@@ -3480,1 +3452,0 @@\n-    SHRINK;\n@@ -3482,1 +3453,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+    buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -3514,5 +3485,0 @@\n-        if (next == 0) {\n-            SHRINK;\n-            GROW;\n-            next = CUR_CHAR(nl);\n-        }\n@@ -3531,1 +3497,1 @@\n-            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            tmp = (xmlChar *) xmlRealloc(buf, size);\n@@ -3546,0 +3512,7 @@\n+        if (len > maxLength) {\n+            htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n+                         \"comment too long\", NULL, NULL);\n+            xmlFree(buf);\n+            ctxt->instate = state;\n+            return;\n+        }\n@@ -3556,0 +3529,4 @@\n+    if (ctxt->instate == XML_PARSER_EOF) {\n+        xmlFree(buf);\n+        return;\n+    }\n@@ -3576,0 +3553,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -3704,1 +3683,2 @@\n-        while ((CUR != 0) && (CUR != '>'))\n+        while ((CUR != 0) && (CUR != '>') &&\n+               (ctxt->instate != XML_PARSER_EOF))\n@@ -3772,87 +3752,0 @@\n-\/**\n- * htmlCheckEncodingDirect:\n- * @ctxt:  an HTML parser context\n- * @attvalue: the attribute value\n- *\n- * Checks an attribute value to detect\n- * the encoding\n- * If a new encoding is detected the parser is switched to decode\n- * it and pass UTF8\n- *\/\n-static void\n-htmlCheckEncodingDirect(htmlParserCtxtPtr ctxt, const xmlChar *encoding) {\n-\n-    if ((ctxt == NULL) || (encoding == NULL) ||\n-        (ctxt->options & HTML_PARSE_IGNORE_ENC))\n-        return;\n-\n-    \/* do not change encoding *\/\n-    if (ctxt->input->encoding != NULL)\n-        return;\n-\n-    if (encoding != NULL) {\n-        xmlCharEncoding enc;\n-        xmlCharEncodingHandlerPtr handler;\n-\n-        while ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n-\n-        if (ctxt->input->encoding != NULL)\n-            xmlFree((xmlChar *) ctxt->input->encoding);\n-        ctxt->input->encoding = xmlStrdup(encoding);\n-\n-        enc = xmlParseCharEncoding((const char *) encoding);\n-        \/*\n-         * registered set of known encodings\n-         *\/\n-        if (enc != XML_CHAR_ENCODING_ERROR) {\n-            if (((enc == XML_CHAR_ENCODING_UTF16LE) ||\n-                 (enc == XML_CHAR_ENCODING_UTF16BE) ||\n-                 (enc == XML_CHAR_ENCODING_UCS4LE) ||\n-                 (enc == XML_CHAR_ENCODING_UCS4BE)) &&\n-                (ctxt->input->buf != NULL) &&\n-                (ctxt->input->buf->encoder == NULL)) {\n-                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                             \"htmlCheckEncoding: wrong encoding meta\\n\",\n-                             NULL, NULL);\n-            } else {\n-                xmlSwitchEncoding(ctxt, enc);\n-            }\n-            ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-        } else {\n-            \/*\n-             * fallback for unknown encodings\n-             *\/\n-            handler = xmlFindCharEncodingHandler((const char *) encoding);\n-            if (handler != NULL) {\n-                xmlSwitchToEncoding(ctxt, handler);\n-                ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-            } else {\n-                htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                             \"htmlCheckEncoding: unknown encoding %s\\n\",\n-                             encoding, NULL);\n-            }\n-        }\n-\n-        if ((ctxt->input->buf != NULL) &&\n-            (ctxt->input->buf->encoder != NULL) &&\n-            (ctxt->input->buf->raw != NULL) &&\n-            (ctxt->input->buf->buffer != NULL)) {\n-            int nbchars;\n-            int processed;\n-\n-            \/*\n-             * convert as much as possible to the parser reading buffer.\n-             *\/\n-            processed = ctxt->input->cur - ctxt->input->base;\n-            xmlBufShrink(ctxt->input->buf->buffer, processed);\n-            nbchars = xmlCharEncInput(ctxt->input->buf, 1);\n-            xmlBufResetInput(ctxt->input->buf->buffer, ctxt->input);\n-            if (nbchars < 0) {\n-                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                             \"htmlCheckEncoding: encoder error\\n\",\n-                             NULL, NULL);\n-            }\n-        }\n-    }\n-}\n-\n@@ -3887,1 +3780,1 @@\n-        htmlCheckEncodingDirect(ctxt, encoding);\n+        xmlSetDeclaredEncoding(ctxt, xmlStrdup(encoding));\n@@ -3916,1 +3809,1 @@\n-            htmlCheckEncodingDirect(ctxt, value);\n+            xmlSetDeclaredEncoding(ctxt, xmlStrdup(value));\n@@ -4036,1 +3929,2 @@\n-           ((CUR != '\/') || (NXT(1) != '>'))) {\n+           ((CUR != '\/') || (NXT(1) != '>')) &&\n+           (ctxt->instate != XML_PARSER_EOF)) {\n@@ -4097,1 +3991,2 @@\n-                   ((CUR != '\/') || (NXT(1) != '>')))\n+                   ((CUR != '\/') || (NXT(1) != '>')) &&\n+                   (ctxt->instate != XML_PARSER_EOF))\n@@ -4464,0 +4359,2 @@\n+\n+        SHRINK;\n@@ -4473,0 +4370,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -4730,1 +4629,0 @@\n-    currentNode = xmlStrdup(ctxt->name);\n@@ -4732,0 +4630,9 @@\n+    if (depth <= 0) {\n+        currentNode = NULL;\n+    } else {\n+        currentNode = xmlStrdup(ctxt->name);\n+        if (currentNode == NULL) {\n+            htmlErrMemory(ctxt, NULL);\n+            return;\n+        }\n+    }\n@@ -4747,1 +4654,0 @@\n-                currentNode = xmlStrdup(ctxt->name);\n@@ -4749,0 +4655,9 @@\n+                if (depth <= 0) {\n+                    currentNode = NULL;\n+                } else {\n+                    currentNode = xmlStrdup(ctxt->name);\n+                    if (currentNode == NULL) {\n+                        htmlErrMemory(ctxt, NULL);\n+                        break;\n+                    }\n+                }\n@@ -4770,0 +4685,4 @@\n+                if (currentNode == NULL) {\n+                    htmlErrMemory(ctxt, NULL);\n+                    break;\n+                }\n@@ -4793,0 +4712,4 @@\n+            if (currentNode == NULL) {\n+                htmlErrMemory(ctxt, NULL);\n+                break;\n+            }\n@@ -4844,0 +4767,4 @@\n+            if (currentNode == NULL) {\n+                htmlErrMemory(ctxt, NULL);\n+                break;\n+            }\n@@ -4875,0 +4802,2 @@\n+\n+        SHRINK;\n@@ -4907,2 +4836,0 @@\n-    xmlChar start[4];\n-    xmlCharEncoding enc;\n@@ -4913,2 +4840,0 @@\n-    htmlDefaultSAXHandlerInit();\n-\n@@ -4920,3 +4845,1 @@\n-    ctxt->html = 1;\n-    ctxt->linenumbers = 1;\n-    GROW;\n+\n@@ -4929,16 +4852,9 @@\n-    if ((ctxt->encoding == (const xmlChar *)XML_CHAR_ENCODING_NONE) &&\n-        ((ctxt->input->end - ctxt->input->cur) >= 4)) {\n-        \/*\n-         * Get the 4 first bytes and decode the charset\n-         * if enc != XML_CHAR_ENCODING_NONE\n-         * plug some encoding conversion routines.\n-         *\/\n-        start[0] = RAW;\n-        start[1] = NXT(1);\n-        start[2] = NXT(2);\n-        start[3] = NXT(3);\n-        enc = xmlDetectCharEncoding(&start[0], 4);\n-        if (enc != XML_CHAR_ENCODING_NONE) {\n-            xmlSwitchEncoding(ctxt, enc);\n-        }\n-    }\n+    xmlDetectEncoding(ctxt);\n+\n+    \/*\n+     * This is wrong but matches long-standing behavior. In most cases,\n+     * a document starting with an XML declaration will specify UTF-8.\n+     *\/\n+    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&\n+        (xmlStrncmp(ctxt->input->cur, BAD_CAST \"<?xm\", 4) == 0))\n+        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_UTF8);\n@@ -5035,0 +4951,2 @@\n+ * @sax:  SAX handler\n+ * @userData:  user data\n@@ -5042,1 +4960,2 @@\n-htmlInitParserCtxt(htmlParserCtxtPtr ctxt)\n+htmlInitParserCtxt(htmlParserCtxtPtr ctxt, const htmlSAXHandler *sax,\n+                   void *userData)\n@@ -5044,2 +4963,0 @@\n-    htmlSAXHandler *sax;\n-\n@@ -5054,2 +4971,4 @@\n-    sax = (htmlSAXHandler *) xmlMalloc(sizeof(htmlSAXHandler));\n-    if (sax == NULL) {\n+\n+    if (ctxt->sax == NULL)\n+        ctxt->sax = (htmlSAXHandler *) xmlMalloc(sizeof(htmlSAXHandler));\n+    if (ctxt->sax == NULL) {\n@@ -5059,1 +4978,8 @@\n-    memset(sax, 0, sizeof(htmlSAXHandler));\n+    if (sax == NULL) {\n+        memset(ctxt->sax, 0, sizeof(htmlSAXHandler));\n+        xmlSAX2InitHtmlDefaultSAXHandler(ctxt->sax);\n+        ctxt->userData = ctxt;\n+    } else {\n+        memcpy(ctxt->sax, sax, sizeof(htmlSAXHandler));\n+        ctxt->userData = userData ? userData : ctxt;\n+    }\n@@ -5118,4 +5044,0 @@\n-    ctxt->sax = sax;\n-    xmlSAX2InitHtmlDefaultSAXHandler(sax);\n-\n-    ctxt->userData = ctxt;\n@@ -5164,0 +5086,17 @@\n+{\n+    return(htmlNewSAXParserCtxt(NULL, NULL));\n+}\n+\n+\/**\n+ * htmlNewSAXParserCtxt:\n+ * @sax:  SAX handler\n+ * @userData:  user data\n+ *\n+ * Allocate and initialize a new SAX parser context. If userData is NULL,\n+ * the parser context will be passed as user data.\n+ *\n+ * Returns the htmlParserCtxtPtr or NULL in case of allocation error\n+ *\/\n+\n+htmlParserCtxtPtr\n+htmlNewSAXParserCtxt(const htmlSAXHandler *sax, void *userData)\n@@ -5173,1 +5112,1 @@\n-    if (htmlInitParserCtxt(ctxt) < 0) {\n+    if (htmlInitParserCtxt(ctxt, sax, userData) < 0) {\n@@ -5205,1 +5144,4 @@\n-    if (buf == NULL) return(NULL);\n+    if (buf == NULL) {\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n@@ -5224,1 +5166,1 @@\n- * @cur:  a pointer to an array of xmlChar\n+ * @str:  a pointer to an array of xmlChar\n@@ -5234,3 +5176,4 @@\n-htmlCreateDocParserCtxt(const xmlChar *cur, const char *encoding) {\n-    int len;\n-    htmlParserCtxtPtr ctxt;\n+htmlCreateDocParserCtxt(const xmlChar *str, const char *encoding) {\n+    xmlParserCtxtPtr ctxt;\n+    xmlParserInputPtr input;\n+    xmlParserInputBufferPtr buf;\n@@ -5238,1 +5181,1 @@\n-    if (cur == NULL)\n+    if (str == NULL)\n@@ -5240,2 +5183,2 @@\n-    len = xmlStrlen(cur);\n-    ctxt = htmlCreateMemoryParserCtxt((char *)cur, len);\n+\n+    ctxt = htmlNewParserCtxt();\n@@ -5245,0 +5188,19 @@\n+    buf = xmlParserInputBufferCreateString(str);\n+    if (buf == NULL) {\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+\n+    input = xmlNewInputStream(ctxt);\n+    if (input == NULL) {\n+        xmlFreeParserInputBuffer(buf);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+\n+    input->filename = NULL;\n+    input->buf = buf;\n+    xmlBufResetInput(buf->buffer, input);\n+\n+    inputPush(ctxt, input);\n+\n@@ -5249,4 +5211,0 @@\n-        if (ctxt->input->encoding != NULL)\n-            xmlFree((xmlChar *) ctxt->input->encoding);\n-        ctxt->input->encoding = xmlStrdup((const xmlChar *) encoding);\n-\n@@ -5278,0 +5236,1 @@\n+\n@@ -5310,1 +5269,1 @@\n-    int base, len;\n+    size_t base, len;\n@@ -5313,2 +5272,1 @@\n-    int invalue = 0;\n-    char valdellim = 0x0;\n+    int quote;\n@@ -5320,3 +5278,2 @@\n-    base = in->cur - in->base;\n-    if (base < 0)\n-        return (-1);\n+    base = ctxt->checkIndex;\n+    quote = ctxt->endCheckState;\n@@ -5324,13 +5281,2 @@\n-    if (ctxt->checkIndex > base) {\n-        base = ctxt->checkIndex;\n-        \/* Abuse hasPErefs member to restore current state. *\/\n-        invalue = ctxt->hasPErefs & 1 ? 1 : 0;\n-    }\n-\n-    if (in->buf == NULL) {\n-        buf = in->base;\n-        len = in->length;\n-    } else {\n-        buf = xmlBufContent(in->buf->buffer);\n-        len = xmlBufUse(in->buf->buffer);\n-    }\n+    buf = in->cur;\n+    len = in->end - in->cur;\n@@ -5344,0 +5290,5 @@\n+        if (base >= INT_MAX \/ 2) {\n+            ctxt->checkIndex = 0;\n+            ctxt->endCheckState = 0;\n+            return (base - 2);\n+        }\n@@ -5345,0 +5296,5 @@\n+            if (quote) {\n+                if (buf[base] == quote)\n+                    quote = 0;\n+                continue;\n+            }\n@@ -5346,11 +5302,1 @@\n-                if (invalue) {\n-                    if (buf[base] == valdellim) {\n-                        invalue = 0;\n-                        continue;\n-                    }\n-                } else {\n-                    valdellim = buf[base];\n-                    invalue = 1;\n-                    continue;\n-                }\n-            } else if (invalue) {\n+                quote = buf[base];\n@@ -5369,15 +5315,2 @@\n-#ifdef DEBUG_PUSH\n-            if (next == 0)\n-                xmlGenericError(xmlGenericErrorContext,\n-                                \"HPP: lookup '%c' found at %d\\n\",\n-                                first, base);\n-            else if (third == 0)\n-                xmlGenericError(xmlGenericErrorContext,\n-                                \"HPP: lookup '%c%c' found at %d\\n\",\n-                                first, next, base);\n-            else\n-                xmlGenericError(xmlGenericErrorContext,\n-                                \"HPP: lookup '%c%c%c' found at %d\\n\",\n-                                first, next, third, base);\n-#endif\n-            return (base - (in->cur - in->base));\n+            ctxt->endCheckState = 0;\n+            return (base);\n@@ -5387,17 +5320,1 @@\n-    \/* Abuse hasPErefs member to track current state. *\/\n-    if (invalue)\n-        ctxt->hasPErefs |= 1;\n-    else\n-        ctxt->hasPErefs &= ~1;\n-#ifdef DEBUG_PUSH\n-    if (next == 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: lookup '%c' failed\\n\", first);\n-    else if (third == 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: lookup '%c%c' failed\\n\", first, next);\n-    else\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: lookup '%c%c%c' failed\\n\", first, next,\n-                        third);\n-#endif\n+    ctxt->endCheckState = quote;\n@@ -5425,1 +5342,1 @@\n-    int cur = CUR_PTR - BASE_PTR;\n+    int offset;\n@@ -5427,1 +5344,1 @@\n-    while (mark >= 0) {\n+    while (1) {\n@@ -5429,2 +5346,3 @@\n-        if ((mark < 0) ||\n-            (NXT(mark+2) == '>') ||\n+        if (mark < 0)\n+            break;\n+        if ((NXT(mark+2) == '>') ||\n@@ -5432,1 +5350,7 @@\n-            return mark;\n+            ctxt->checkIndex = 0;\n+            break;\n+        }\n+        offset = (NXT(mark+2) == '!') ? 3 : 2;\n+        if (mark + offset >= ctxt->input->end - ctxt->input->cur) {\n+            ctxt->checkIndex = mark;\n+            return(-1);\n@@ -5434,1 +5358,1 @@\n-        ctxt->checkIndex = cur + mark + 1;\n+        ctxt->checkIndex = mark + 1;\n@@ -5458,53 +5382,0 @@\n-#ifdef DEBUG_PUSH\n-    switch (ctxt->instate) {\n-        case XML_PARSER_EOF:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try EOF\\n\"); break;\n-        case XML_PARSER_START:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try START\\n\"); break;\n-        case XML_PARSER_MISC:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try MISC\\n\");break;\n-        case XML_PARSER_COMMENT:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try COMMENT\\n\");break;\n-        case XML_PARSER_PROLOG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try PROLOG\\n\");break;\n-        case XML_PARSER_START_TAG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try START_TAG\\n\");break;\n-        case XML_PARSER_CONTENT:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try CONTENT\\n\");break;\n-        case XML_PARSER_CDATA_SECTION:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try CDATA_SECTION\\n\");break;\n-        case XML_PARSER_END_TAG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try END_TAG\\n\");break;\n-        case XML_PARSER_ENTITY_DECL:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try ENTITY_DECL\\n\");break;\n-        case XML_PARSER_ENTITY_VALUE:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try ENTITY_VALUE\\n\");break;\n-        case XML_PARSER_ATTRIBUTE_VALUE:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try ATTRIBUTE_VALUE\\n\");break;\n-        case XML_PARSER_DTD:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try DTD\\n\");break;\n-        case XML_PARSER_EPILOG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try EPILOG\\n\");break;\n-        case XML_PARSER_PI:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try PI\\n\");break;\n-        case XML_PARSER_SYSTEM_LITERAL:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"HPP: try SYSTEM_LITERAL\\n\");break;\n-    }\n-#endif\n-\n@@ -5515,5 +5386,1 @@\n-        if (in->buf == NULL)\n-            avail = in->length - (in->cur - in->base);\n-        else\n-            avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n-                    (in->cur - in->base);\n+        avail = in->end - in->cur;\n@@ -5552,0 +5419,10 @@\n+                \/*\n+                 * This is wrong but matches long-standing behavior. In most\n+                 * cases, a document starting with an XML declaration will\n+                 * specify UTF-8.\n+                 *\/\n+                if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&\n+                    (xmlStrncmp(ctxt->input->cur, BAD_CAST \"<?xm\", 4) == 0)) {\n+                    xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_UTF8);\n+                }\n+\n@@ -5558,5 +5435,1 @@\n-                    if (in->buf == NULL)\n-                        avail = in->length - (in->cur - in->base);\n-                    else\n-                        avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n-                                (in->cur - in->base);\n+                    avail = in->end - in->cur;\n@@ -5570,0 +5443,2 @@\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n@@ -5581,4 +5456,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing internal subset\\n\");\n-#endif\n@@ -5586,0 +5457,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5587,4 +5460,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering PROLOG\\n\");\n-#endif\n@@ -5593,4 +5462,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering MISC\\n\");\n-#endif\n@@ -5601,5 +5466,1 @@\n-                if (in->buf == NULL)\n-                    avail = in->length - (in->cur - in->base);\n-                else\n-                    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n-                            (in->cur - in->base);\n+                avail = in->end - in->cur;\n@@ -5627,4 +5488,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing Comment\\n\");\n-#endif\n@@ -5632,0 +5489,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5637,4 +5496,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing PI\\n\");\n-#endif\n@@ -5642,0 +5497,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5651,4 +5508,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing internal subset\\n\");\n-#endif\n@@ -5656,0 +5509,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5657,4 +5512,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering PROLOG\\n\");\n-#endif\n@@ -5666,4 +5517,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering START_TAG\\n\");\n-#endif\n@@ -5674,5 +5521,1 @@\n-                if (in->buf == NULL)\n-                    avail = in->length - (in->cur - in->base);\n-                else\n-                    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n-                            (in->cur - in->base);\n+                avail = in->end - in->cur;\n@@ -5687,4 +5530,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing Comment\\n\");\n-#endif\n@@ -5692,0 +5531,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5697,4 +5538,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing PI\\n\");\n-#endif\n@@ -5702,0 +5539,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5708,4 +5547,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering START_TAG\\n\");\n-#endif\n@@ -5715,5 +5550,1 @@\n-                if (in->buf == NULL)\n-                    avail = in->length - (in->cur - in->base);\n-                else\n-                    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n-                            (in->cur - in->base);\n+                avail = in->end - in->cur;\n@@ -5734,4 +5565,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing Comment\\n\");\n-#endif\n@@ -5739,0 +5566,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5744,4 +5573,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing PI\\n\");\n-#endif\n@@ -5749,0 +5574,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5757,4 +5584,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering EOF\\n\");\n-#endif\n@@ -5790,4 +5613,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering CONTENT\\n\");\n-#endif\n@@ -5799,4 +5618,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering END_TAG\\n\");\n-#endif\n@@ -5843,0 +5658,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5844,4 +5661,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering CONTENT\\n\");\n-#endif\n@@ -5869,0 +5682,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5870,4 +5685,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering CONTENT\\n\");\n-#endif\n@@ -5889,0 +5700,2 @@\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n@@ -5890,4 +5703,0 @@\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n@@ -5903,1 +5712,1 @@\n-                    chr[0] = (xmlChar) ctxt->token;\n+                    chr[0] = ctxt->token;\n@@ -5955,1 +5764,6 @@\n-                        if (val == 0) \/* bad cut of input *\/\n+                        if (val == 0) { \/* bad cut of input *\/\n+                            \/*\n+                             * FIXME: htmlParseScript checks for additional\n+                             * characters after '<\/'.\n+                             *\/\n+                            ctxt->checkIndex = idx;\n@@ -5957,0 +5771,1 @@\n+                        }\n@@ -5959,0 +5774,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -5962,4 +5779,0 @@\n-#ifdef DEBUG_PUSH\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"HPP: entering END_TAG\\n\");\n-#endif\n@@ -5969,0 +5782,2 @@\n+                    if (avail < 4)\n+                        goto done;\n@@ -5987,4 +5802,0 @@\n-#ifdef DEBUG_PUSH\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"HPP: Parsing Comment\\n\");\n-#endif\n@@ -5992,0 +5803,2 @@\n+                        if (ctxt->instate == XML_PARSER_EOF)\n+                            goto done;\n@@ -6003,4 +5816,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing PI\\n\");\n-#endif\n@@ -6008,0 +5817,2 @@\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n@@ -6009,2 +5820,0 @@\n-                } else if ((cur == '<') && (next == '!') && (avail < 4)) {\n-                    goto done;\n@@ -6014,4 +5823,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering END_TAG\\n\");\n-#endif\n@@ -6024,4 +5829,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: entering START_TAG\\n\");\n-#endif\n@@ -6046,4 +5847,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"HPP: Parsing char data\\n\");\n-#endif\n@@ -6070,0 +5867,2 @@\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n@@ -6076,70 +5875,0 @@\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_CDATA_SECTION:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == CDATA\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_DTD:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == DTD\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_COMMENT:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == COMMENT\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_PI:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == PI\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_ENTITY_DECL:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == ENTITY_DECL\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_ENTITY_VALUE:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == ENTITY_VALUE\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering DTD\\n\");\n-#endif\n@@ -6147,1 +5876,1 @@\n-            case XML_PARSER_ATTRIBUTE_VALUE:\n+            default:\n@@ -6149,41 +5878,2 @@\n-                        \"HPP: internal error, state == ATTRIBUTE_VALUE\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_START_TAG;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering START_TAG\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_SYSTEM_LITERAL:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                    \"HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_IGNORE:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == XML_PARSER_IGNORE\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_PUBLIC_LITERAL:\n-                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"HPP: internal error, state == XML_PARSER_LITERAL\\n\",\n-                             NULL, NULL);\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"HPP: entering CONTENT\\n\");\n-#endif\n+                             \"HPP: internal error\\n\", NULL, NULL);\n+                ctxt->instate = XML_PARSER_EOF;\n@@ -6191,1 +5881,0 @@\n-\n@@ -6217,3 +5906,0 @@\n-#ifdef DEBUG_PUSH\n-    xmlGenericError(xmlGenericErrorContext, \"HPP: done %d\\n\", ret);\n-#endif\n@@ -6244,2 +5930,1 @@\n-        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-        size_t cur = ctxt->input->cur - ctxt->input->base;\n+        size_t pos = ctxt->input->cur - ctxt->input->base;\n@@ -6249,1 +5934,1 @@\n-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n+        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n@@ -6251,29 +5936,4 @@\n-            ctxt->errNo = XML_PARSER_EOF;\n-            ctxt->disableSAX = 1;\n-            return (XML_PARSER_EOF);\n-        }\n-#ifdef DEBUG_PUSH\n-        xmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n-#endif\n-\n-#if 0\n-        if ((terminate) || (ctxt->input->buf->buffer->use > 80))\n-            htmlParseTryOrFinish(ctxt, terminate);\n-#endif\n-    } else if (ctxt->instate != XML_PARSER_EOF) {\n-        if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n-            xmlParserInputBufferPtr in = ctxt->input->buf;\n-            if ((in->encoder != NULL) && (in->buffer != NULL) &&\n-                    (in->raw != NULL)) {\n-                int nbchars;\n-                size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n-                size_t current = ctxt->input->cur - ctxt->input->base;\n-\n-                nbchars = xmlCharEncInput(in, terminate);\n-                xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n-                if (nbchars < 0) {\n-                    htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                                 \"encoder error\\n\", NULL, NULL);\n-                    return(XML_ERR_INVALID_ENCODING);\n-                }\n-            }\n+            htmlParseErr(ctxt, ctxt->input->buf->error,\n+                         \"xmlParserInputBufferPush failed\", NULL, NULL);\n+            xmlHaltParser(ctxt);\n+            return (ctxt->errNo);\n@@ -6330,1 +5990,1 @@\n-    buf = xmlAllocParserInputBuffer(enc);\n+    buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n@@ -6333,1 +5993,1 @@\n-    ctxt = htmlNewParserCtxt();\n+    ctxt = htmlNewSAXParserCtxt(sax, user_data);\n@@ -6338,15 +5998,0 @@\n-    if(enc==XML_CHAR_ENCODING_UTF8 || buf->encoder)\n-        ctxt->charset=XML_CHAR_ENCODING_UTF8;\n-    if (sax != NULL) {\n-        if (ctxt->sax != (xmlSAXHandlerPtr) &htmlDefaultSAXHandler)\n-            xmlFree(ctxt->sax);\n-        ctxt->sax = (htmlSAXHandlerPtr) xmlMalloc(sizeof(htmlSAXHandler));\n-        if (ctxt->sax == NULL) {\n-            xmlFree(buf);\n-            xmlFree(ctxt);\n-            return(NULL);\n-        }\n-        memcpy(ctxt->sax, sax, sizeof(htmlSAXHandler));\n-        if (user_data != NULL)\n-            ctxt->userData = user_data;\n-    }\n@@ -6362,1 +6007,1 @@\n-        xmlFree(buf);\n+        xmlFreeParserInputBuffer(buf);\n@@ -6376,0 +6021,3 @@\n+    if (enc != XML_CHAR_ENCODING_NONE)\n+        xmlSwitchEncoding(ctxt, enc);\n+\n@@ -6378,4 +6026,2 @@\n-        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-        size_t cur = ctxt->input->cur - ctxt->input->base;\n-\n-        xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        size_t pos = ctxt->input->cur - ctxt->input->base;\n+        int res;\n@@ -6383,4 +6029,7 @@\n-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n-#ifdef DEBUG_PUSH\n-        xmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n-#endif\n+        res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n+        if (res < 0) {\n+            htmlParseErr(ctxt, ctxt->input->buf->error,\n+                         \"xmlParserInputBufferPush failed\\n\", NULL, NULL);\n+            xmlHaltParser(ctxt);\n+        }\n@@ -6401,0 +6050,2 @@\n+ * DEPRECATED: Use htmlNewSAXParserCtxt and htmlCtxtReadDoc.\n+ *\n@@ -6472,2 +6123,0 @@\n-    \/* htmlCharEncoding enc; *\/\n-    xmlChar *content, *content_line = (xmlChar *) \"charset=\";\n@@ -6484,5 +6133,0 @@\n-#ifdef LIBXML_SAX1_ENABLED\n-        if (xmlDefaultSAXHandler.error != NULL) {\n-            xmlDefaultSAXHandler.error(NULL, \"out of memory\\n\");\n-        }\n-#endif\n@@ -6504,10 +6148,5 @@\n-        size_t l = strlen(encoding);\n-\n-        if (l < 1000) {\n-            content = xmlMallocAtomic (xmlStrlen(content_line) + l + 1);\n-            if (content) {\n-                strcpy ((char *)content, (char *)content_line);\n-                strcat ((char *)content, (char *)encoding);\n-                htmlCheckEncoding (ctxt, content);\n-                xmlFree (content);\n-            }\n+        xmlCharEncodingHandlerPtr hdlr;\n+\n+        hdlr = xmlFindCharEncodingHandler(encoding);\n+        if (hdlr != NULL) {\n+            xmlSwitchToEncoding(ctxt, hdlr);\n@@ -6527,0 +6166,2 @@\n+ * DEPRECATED: Use htmlNewSAXParserCtxt and htmlCtxtReadFile.\n+ *\n@@ -6795,0 +6436,1 @@\n+    ctxt->vctxt.flags = XML_VCTXT_USE_PCTXT;\n@@ -6799,0 +6441,1 @@\n+    ctxt->endCheckState = 0;\n@@ -6802,1 +6445,0 @@\n-    ctxt->charset = XML_CHAR_ENCODING_NONE;\n@@ -6814,0 +6456,5 @@\n+\n+    ctxt->nbErrors = 0;\n+    ctxt->nbWarnings = 0;\n+    if (ctxt->lastError.code != XML_ERR_OK)\n+        xmlResetError(&ctxt->lastError);\n@@ -6884,0 +6531,1 @@\n+    ctxt->linenumbers = 1;\n@@ -6913,3 +6561,0 @@\n-            if (ctxt->input->encoding != NULL)\n-              xmlFree((xmlChar *) ctxt->input->encoding);\n-            ctxt->input->encoding = xmlStrdup((xmlChar *)encoding);\n@@ -7000,1 +6645,1 @@\n-    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n+    ctxt = htmlCreateMemoryParserCtxt(buffer, size);\n@@ -7003,3 +6648,0 @@\n-    htmlDefaultSAXHandlerInit();\n-    if (ctxt->sax != NULL)\n-        memcpy(ctxt->sax, &htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));\n@@ -7102,1 +6744,1 @@\n- * @cur:  a pointer to a zero terminated string\n+ * @str:  a pointer to a zero terminated string\n@@ -7113,1 +6755,1 @@\n-htmlCtxtReadDoc(htmlParserCtxtPtr ctxt, const xmlChar * cur,\n+htmlCtxtReadDoc(htmlParserCtxtPtr ctxt, const xmlChar *str,\n@@ -7116,1 +6758,6 @@\n-    if (cur == NULL)\n+    xmlParserInputBufferPtr input;\n+    xmlParserInputPtr stream;\n+\n+    if (ctxt == NULL)\n+        return (NULL);\n+    if (str == NULL)\n@@ -7118,2 +6765,17 @@\n-    return (htmlCtxtReadMemory(ctxt, (const char *) cur, xmlStrlen(cur), URL,\n-                               encoding, options));\n+    xmlInitParser();\n+\n+    htmlCtxtReset(ctxt);\n+\n+    input = xmlParserInputBufferCreateString(str);\n+    if (input == NULL) {\n+        return(NULL);\n+    }\n+\n+    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n+    if (stream == NULL) {\n+        xmlFreeParserInputBuffer(input);\n+        return(NULL);\n+    }\n+\n+    inputPush(ctxt, stream);\n+    return (htmlDoRead(ctxt, URL, encoding, options, 1));\n@@ -7185,1 +6847,2 @@\n-    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n+    input = xmlParserInputBufferCreateStatic(buffer, size,\n+                                             XML_CHAR_ENCODING_NONE);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/HTMLparser.c","additions":415,"deletions":752,"binary":false,"changes":1167,"status":"modified"},{"patch":"@@ -22,1 +22,0 @@\n-#include <libxml\/valid.h>\n@@ -25,1 +24,0 @@\n-#include <libxml\/globals.h>\n@@ -28,1 +26,4 @@\n-#include \"buf.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/error.h\"\n+#include \"private\/io.h\"\n+#include \"private\/save.h\"\n@@ -331,5 +332,0 @@\n-\/*\n- * private routine exported from xmlIO.c\n- *\/\n-xmlOutputBufferPtr\n-xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder);\n@@ -420,1 +416,1 @@\n-    memset(outbuf, 0, (size_t) sizeof(xmlOutputBuffer));\n+    memset(outbuf, 0, sizeof(xmlOutputBuffer));\n@@ -625,2 +621,0 @@\n-void xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur);\n-\n@@ -708,2 +702,6 @@\n-                 * the < and > have already been escaped at the entity level\n-                 * And doing so here breaks server side includes\n+                 * Angle brackets are technically illegal in URIs, but they're\n+                 * used in server side includes, for example. Curly brackets\n+                 * are illegal as well and often used in templates.\n+                 * Don't escape non-whitespace, printable ASCII chars for\n+                 * improved interoperability. Only escape space, control\n+                 * and non-ASCII chars.\n@@ -711,1 +709,2 @@\n-                escaped = xmlURIEscapeStr(tmp, BAD_CAST\"@\/:=?;#%&,+<>\");\n+                escaped = xmlURIEscapeStr(tmp,\n+                        BAD_CAST \"\\\"#$%&+,\/:;<=>?@[\\\\]^`{|}\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/HTMLtree.c","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-SUBDIRS = include . doc example fuzz xstc\n+SUBDIRS = include . doc example xstc\n@@ -9,0 +9,3 @@\n+if WITH_GLOB\n+SUBDIRS += fuzz\n+endif\n@@ -14,2 +17,0 @@\n-AM_CFLAGS = $(EXTRA_CFLAGS)\n-\n@@ -20,1 +21,0 @@\n-\ttestAutomata \\\n@@ -27,0 +27,1 @@\n+\ttestparser \\\n@@ -31,1 +32,1 @@\n-nodist_bin_SCRIPTS = xml2-config\n+bin_SCRIPTS = xml2-config\n@@ -34,1 +35,1 @@\n-libxml2_la_CFLAGS = $(EXTRA_CFLAGS) $(THREAD_CFLAGS) $(Z_CFLAGS) $(LZMA_CFLAGS)\n+libxml2_la_CFLAGS = $(AM_CFLAGS) $(XML_PRIVATE_CFLAGS)\n@@ -37,8 +38,1 @@\n-if USE_VERSION_SCRIPT\n-LIBXML2_VERSION_SCRIPT = $(VERSION_SCRIPT_FLAGS)$(srcdir)\/libxml2.syms\n-else\n-LIBXML2_VERSION_SCRIPT =\n-endif\n-\n-libxml2_la_LDFLAGS = $(CYGWIN_EXTRA_LDFLAGS) $(WIN32_EXTRA_LDFLAGS) \\\n-\t\t     $(LIBXML2_VERSION_SCRIPT) \\\n+libxml2_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined \\\n@@ -47,0 +41,3 @@\n+if USE_VERSION_SCRIPT\n+libxml2_la_LDFLAGS += $(VERSION_SCRIPT_FLAGS)$(srcdir)\/libxml2.syms\n+endif\n@@ -48,0 +45,55 @@\n+libxml2_la_SOURCES = buf.c chvalid.c dict.c entities.c encoding.c error.c \\\n+\t\t     globals.c hash.c list.c parser.c parserInternals.c \\\n+\t\t     SAX2.c threads.c tree.c uri.c valid.c xmlIO.c \\\n+\t\t     xmlmemory.c xmlstring.c\n+if WITH_C14N_SOURCES\n+libxml2_la_SOURCES += c14n.c\n+endif\n+if WITH_CATALOG_SOURCES\n+libxml2_la_SOURCES += catalog.c\n+endif\n+if WITH_DEBUG_SOURCES\n+libxml2_la_SOURCES += debugXML.c\n+endif\n+if WITH_FTP_SOURCES\n+libxml2_la_SOURCES += nanoftp.c\n+endif\n+if WITH_HTML_SOURCES\n+libxml2_la_SOURCES += HTMLparser.c HTMLtree.c\n+endif\n+if WITH_HTTP_SOURCES\n+libxml2_la_SOURCES += nanohttp.c\n+endif\n+if WITH_LEGACY_SOURCES\n+libxml2_la_SOURCES += legacy.c\n+if WITH_SAX1_SOURCES\n+libxml2_la_SOURCES += SAX.c\n+endif\n+endif\n+if WITH_LZMA_SOURCES\n+libxml2_la_SOURCES += xzlib.c\n+endif\n+if WITH_MODULES_SOURCES\n+libxml2_la_SOURCES += xmlmodule.c\n+endif\n+if WITH_OUTPUT_SOURCES\n+libxml2_la_SOURCES += xmlsave.c\n+endif\n+if WITH_PATTERN_SOURCES\n+libxml2_la_SOURCES += pattern.c\n+endif\n+if WITH_READER_SOURCES\n+libxml2_la_SOURCES += xmlreader.c\n+endif\n+if WITH_REGEXPS_SOURCES\n+libxml2_la_SOURCES += xmlregexp.c xmlunicode.c\n+endif\n+if WITH_SCHEMAS_SOURCES\n+libxml2_la_SOURCES += relaxng.c xmlschemas.c xmlschemastypes.c\n+if !WITH_XPATH_SOURCES\n+libxml2_la_SOURCES += xpath.c\n+endif\n+endif\n+if WITH_SCHEMATRON_SOURCES\n+libxml2_la_SOURCES += schematron.c\n+endif\n@@ -49,3 +101,13 @@\n-trio_sources = triostr.c trio.c\n-else\n-trio_sources =\n+libxml2_la_SOURCES += triostr.c trio.c\n+endif\n+if WITH_WRITER_SOURCES\n+libxml2_la_SOURCES += xmlwriter.c\n+endif\n+if WITH_XINCLUDE_SOURCES\n+libxml2_la_SOURCES += xinclude.c\n+endif\n+if WITH_XPATH_SOURCES\n+libxml2_la_SOURCES += xpath.c\n+endif\n+if WITH_XPTR_SOURCES\n+libxml2_la_SOURCES += xlink.c xpointer.c\n@@ -53,11 +115,0 @@\n-\n-libxml2_la_SOURCES = SAX.c entities.c encoding.c error.c parserInternals.c  \\\n-\t\tparser.c tree.c hash.c list.c xmlIO.c xmlmemory.c uri.c  \\\n-\t\tvalid.c xlink.c HTMLparser.c HTMLtree.c debugXML.c xpath.c  \\\n-\t\txpointer.c xinclude.c nanohttp.c nanoftp.c \\\n-\t\tcatalog.c globals.c threads.c c14n.c xmlstring.c buf.c \\\n-\t\txmlregexp.c xmlschemas.c xmlschemastypes.c xmlunicode.c \\\n-\t\t$(trio_sources) \\\n-\t\txmlreader.c relaxng.c dict.c SAX2.c \\\n-\t\txmlwriter.c legacy.c chvalid.c pattern.c xmlsave.c \\\n-\t\txmlmodule.c schematron.c xzlib.c\n@@ -70,1 +121,1 @@\n-m4data_DATA = libxml.m4\n+dist_m4data_DATA = libxml.m4\n@@ -73,2 +124,1 @@\n-runtest_CFLAGS = $(EXTRA_CFLAGS) $(THREAD_CFLAGS)\n-runtest_LDFLAGS = \n+runtest_CFLAGS = $(AM_CFLAGS) $(THREAD_CFLAGS)\n@@ -79,1 +129,0 @@\n-testrecurse_LDFLAGS = \n@@ -84,1 +133,0 @@\n-testlimits_LDFLAGS = \n@@ -89,1 +137,0 @@\n-testchar_LDFLAGS = \n@@ -94,1 +141,0 @@\n-testdict_LDFLAGS = \n@@ -98,0 +144,4 @@\n+testparser_SOURCES=testparser.c\n+testparser_DEPENDENCIES = $(DEPS)\n+testparser_LDADD= $(LDADDS)\n+\n@@ -99,1 +149,0 @@\n-runsuite_LDFLAGS = \n@@ -104,1 +153,1 @@\n-xmllint_LDFLAGS = \n+xmllint_CFLAGS = $(AM_CFLAGS) $(RDL_CFLAGS) $(ICONV_CFLAGS)\n@@ -109,1 +158,1 @@\n-xmlcatalog_LDFLAGS = \n+xmlcatalog_CFLAGS = $(AM_CFLAGS) $(RDL_CFLAGS) $(ICONV_CFLAGS)\n@@ -114,2 +163,1 @@\n-testThreads_CFLAGS = $(EXTRA_CFLAGS) $(THREAD_CFLAGS)\n-testThreads_LDFLAGS = \n+testThreads_CFLAGS = $(AM_CFLAGS) $(THREAD_CFLAGS)\n@@ -119,5 +167,0 @@\n-testAutomata_SOURCES=testAutomata.c\n-testAutomata_LDFLAGS = \n-testAutomata_DEPENDENCIES = $(DEPS)\n-testAutomata_LDADD= $(LDADDS)\n-\n@@ -125,1 +168,0 @@\n-testModule_LDFLAGS = \n@@ -131,1 +173,2 @@\n-testdso_la_LDFLAGS = -module -no-undefined -avoid-version -rpath $(libdir)\n+testdso_la_LDFLAGS = $(AM_LDFLAGS) \\\n+\t\t     -module -no-undefined -avoid-version -rpath $(libdir)\n@@ -139,1 +182,0 @@\n-testapi_LDFLAGS = \n@@ -144,1 +186,0 @@\n-runxmlconf_LDFLAGS = \n@@ -149,1 +190,0 @@\n-#testOOM_LDFLAGS = \n@@ -158,1 +198,1 @@\n-\tASAN_OPTIONS=\"$$ASAN_OPTIONS:detect_leaks=0\" $(CHECKER) .\/testapi$(EXEEXT)\n+\t$(CHECKER) .\/testapi$(EXEEXT)\n@@ -161,0 +201,1 @@\n+\t$(CHECKER) .\/testparser$(EXEEXT)\n@@ -164,0 +205,1 @@\n+\t$(CHECKER) .\/runsuite$(EXEEXT)\n@@ -178,1 +220,21 @@\n-tests: $(TEST_DEBUG) $(TEST_CATALOG) $(TEST_REGEXPS) $(TEST_SCHEMATRON) Timingtests $(TEST_VTIME) $(PYTHON_TESTS)\n+\n+OLD_TESTS = Timingtests\n+if WITH_CATALOG_SOURCES\n+OLD_TESTS += Catatests\n+endif\n+if WITH_DEBUG_SOURCES\n+OLD_TESTS += Scripttests\n+endif\n+if WITH_SCHEMAS_SOURCES\n+if WITH_PYTHON\n+OLD_TESTS += RelaxNGPythonTests SchemasPythonTests\n+endif\n+endif\n+if WITH_SCHEMATRON_SOURCES\n+OLD_TESTS += Schematrontests\n+endif\n+if WITH_VALID_SOURCES\n+OLD_TESTS += VTimingtests\n+endif\n+\n+tests: $(OLD_TESTS)\n@@ -181,1 +243,0 @@\n-\t@(echo > .memdump)\n@@ -191,1 +252,0 @@\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -194,1 +254,0 @@\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -202,1 +261,0 @@\n-\t@(echo > .memdump)\n@@ -211,1 +269,0 @@\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -214,1 +271,0 @@\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -226,1 +282,0 @@\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -229,1 +284,0 @@\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -236,1 +290,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -238,1 +291,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -240,1 +292,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -242,1 +293,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -244,1 +294,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -246,1 +295,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -248,1 +296,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -250,1 +297,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -252,1 +298,0 @@\n-\tgrep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\"; \\\n@@ -255,18 +300,0 @@\n-Automatatests: testAutomata$(EXEEXT)\n-\t@(echo > .memdump)\n-\t@echo \"## Automata regression tests\"\n-\t-@(for i in $(srcdir)\/test\/automata\/* ; do \\\n-\t  name=`basename $$i`; \\\n-\t  if [ ! -d $$i ] ; then \\\n-\t  if [ ! -f $(srcdir)\/result\/automata\/$$name ] ; then \\\n-\t      echo New test file $$name ; \\\n-\t      $(CHECKER) $(top_builddir)\/testAutomata $$i > $(srcdir)\/result\/automata\/$$name; \\\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n-\t  else \\\n-\t      log=`$(CHECKER) $(top_builddir)\/testAutomata $$i 2>&1 > result.$$name ; \\\n-\t      grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n-\t      diff $(srcdir)\/result\/automata\/$$name result.$$name` ; \\\n-\t      if [ -n \"$$log\" ] ; then echo $$name result ; echo \"$$log\" ; fi ; \\\n-\t      rm result.$$name ; \\\n-\t  fi ; fi ; done)\n-\n@@ -285,1 +312,0 @@\n-\t   MEM=`cat .memdump | grep \"MEMORY ALLOCATED\" | awk '{ print $$7}'`;\\\n@@ -287,1 +313,0 @@\n-\t   grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -290,1 +315,0 @@\n-\t   MEM=`cat .memdump | grep \"MEMORY ALLOCATED\" | awk '{ print $$7}'`;\\\n@@ -292,1 +316,0 @@\n-\t   grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -295,1 +318,0 @@\n-\t   MEM=`cat .memdump | grep \"MEMORY ALLOCATED\" | awk '{ print $$7}'`;\\\n@@ -297,1 +319,0 @@\n-\t   grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -302,1 +323,0 @@\n-\t   MEM=`cat .memdump | grep \"MEMORY ALLOCATED\" | awk '{ print $$7}'`;\\\n@@ -304,1 +324,0 @@\n-\t   grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -308,1 +327,0 @@\n-\t@(echo > .memdump)\n@@ -321,1 +339,0 @@\n-\t          grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -325,1 +342,0 @@\n-\t          grep \"MORY ALLO\" .memdump  | grep -v \"MEMORY ALLOCATED : 0\";\\\n@@ -368,16 +384,1 @@\n-dist-source: distdir\n-\t$(AMTAR) -chof - --exclude Tests --exclude test --exclude result $(distdir) | GZIP=$(GZIP_ENV) gzip -c >`echo \"$(distdir)\" | sed \"s+libxml2+libxml2-sources+\"`.tar.gz\n-\n-dist-test: distdir\n-\t(mkdir -p $(distdir))\n-\t(cd $(srcdir) ; tar -cf - --exclude .git xstc\/Tests) | (cd $(distdir); tar xf -)\n-\ttar -cf - $(distdir)\/test $(distdir)\/result $(distdir)\/xstc\/Tests  $(distdir)\/Makefile.tests $(distdir)\/README.md $(distdir)\/README.tests $(distdir)\/testapi.c $(distdir)\/runtest.c $(distdir)\/runsuite.c | GZIP=$(GZIP_ENV) gzip -c >`echo \"$(distdir)\" | sed \"s+libxml2+libxml2-tests+\"`.tar.gz\n-\t@(rm -rf $(distdir)\/xstc\/Test)\n-\n-cleantar:\n-\t@(rm -f libxml*.tar.gz COPYING.LIB)\n-\n-rpm: cleanup cleantar\n-\t@(unset CDPATH ; $(MAKE) dist-source dist && rpmbuild -ta $(distdir).tar.gz)\n-\n-CLEANFILES = runxmlconf.log test.out *.gcda *.gcno *.res\n+CLEANFILES = runsuite.log runxmlconf.log test.out *.gcda *.gcno *.res\n@@ -386,2 +387,1 @@\n-EXTRA_DIST = xml2-config.in libxml.spec.in \\\n-             libxml.m4 Copyright check-xml-test-suite.py gentest.py \\\n+EXTRA_DIST = Copyright check-xml-test-suite.py gentest.py \\\n@@ -391,1 +391,0 @@\n-\t     libxml-2.0.pc.in libxml-2.0-uninstalled.pc.in \\\n@@ -394,2 +393,2 @@\n-\t     triop.h triodef.h libxml.h xzlib.h buf.h \\\n-\t     enc.h save.h genUnicode.py TODO_SCHEMAS \\\n+\t     triop.h triodef.h libxml.h \\\n+\t     genUnicode.py \\\n@@ -397,1 +396,1 @@\n-\t     README.tests Makefile.tests libxml2.syms timsort.h \\\n+\t     libxml2.syms timsort.h \\\n@@ -403,1 +402,1 @@\n-nodist_pkgconfig_DATA = libxml-2.0.pc\n+pkgconfig_DATA = libxml-2.0.pc\n@@ -428,1 +427,1 @@\n-\tif [ \"`echo $(LDFLAGS) | grep coverage`\" = \"\" ] ; then \\\n+\tif [ \"`echo $(AM_LDFLAGS) | grep coverage`\" = \"\" ] ; then \\\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/Makefile.am","additions":121,"deletions":122,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -3,0 +3,689 @@\n+v2.12.6: Mar 15 2024\n+\n+### Regressions\n+\n+- parser: Fix detection of duplicate attributes in XML namespace\n+- xmlreader: Fix xmlTextReaderConstEncoding\n+- html: Fix htmlCreatePushParserCtxt with encoding\n+- xmllint: Return error code if XPath returns empty nodeset\n+\n+\n+v2.12.5: Feb 4 2024\n+\n+### Security\n+\n+- [CVE-2024-25062] xmlreader: Don't expand XIncludes when backtracking\n+\n+### Regressions\n+\n+- parser: Fix crash in xmlParseInNodeContext with HTML documents\n+\n+\n+v2.12.4: Jan 15 2024\n+\n+### Regressions\n+\n+- parser: Fix regression parsing standalone declarations\n+- autotools: Readd --with-xptr-locs configuration option\n+- parser: Fix build --without-output\n+- parser: Don't grow or shrink pull parser memory buffers\n+- io: Fix memory lifetime issue with input buffers\n+\n+\n+v2.12.3: Dec 12 2023\n+\n+### Regressions\n+\n+- parser: Fix namespaces redefined from default attributes\n+\n+### Build fixes\n+\n+- include: Rename XML_EMPTY helper macro\n+- include: Move declaration of xmlInitGlobals\n+- include: Add missing includes\n+- include: Move globals from xmlsave.h to parser.h\n+- include: Readd circular dependency between tree.h and parser.h\n+\n+\n+v2.12.2: Dec 5 2023\n+\n+### Regressions\n+\n+- parser: Fix invalid free in xmlParseBalancedChunkMemoryRecover\n+- globals: Disable TLS in static Windows builds\n+- html: Reenable buggy detection of XML declarations\n+- tree: Fix regression when copying DTDs\n+- parser: Make CRLF increment line number\n+\n+### Build fixes\n+\n+- build: Disable compiler TLS by default\n+- cmake: Update config.h.cmake.in\n+- tests: Fix tests --with-valid --without-xinclude\n+\n+\n+v2.12.1: Nov 23 2023\n+\n+### Regressions\n+\n+- hash: Fix deletion of entries during scan\n+- parser: Only enable SAX2 if there are SAX2 element handlers\n+\n+### Build fixes\n+\n+- autotools: Stop checking for snprintf\n+- dict: Fix '__thread' before 'static'\n+- fix: pthread weak references in globals.c (Mike Dalessio)\n+- tests: Fix build with older MSVC\n+\n+\n+v2.12.0: Nov 16 2023\n+\n+### Major changes\n+\n+Most of the known issues leading to quadratic behavior in the XML parser\n+were fixed. Internal hash tables were rewritten to reduce memory\n+consumption.\n+\n+Starting with this release, it should be enough to add the --with-legacy\n+configuration option to provide maximum ABI compatibility. For example,\n+if a code module was removed from the default configuration, the option\n+will add stubs for the removed symbols.\n+\n+libxml2 will now store global variables in thread-local storage if supported\n+by the compiler. This avoids allocating the data lazily which can result in\n+a fatal error condition. A new API function xmlCheckThreadLocalStorage\n+was added so the allocation can be checked earlier if compiler TLS is not\n+supported. To prepare for future improvements, some API functions now expect\n+or return a const xmlError struct.\n+\n+Several cyclic dependencies in public header files were fixed. As a result,\n+certain headers won't include other headers as before.\n+\n+Refactoring of the encoding code has been mostly completed. Calling\n+xmlSwitchEncoding from client code is now fully supported, for example to\n+override the encoding for the push parser.\n+\n+When parsing data from memory, libxml2 will now stream data chunk by chunk\n+instead of copying the whole buffer (possibly twice with encodings),\n+reducing peak memory consumption considerably.\n+\n+A new API function xmlCtxtSetMaxAmplification was added to allow parsing\n+of files that would otherwise trigger the billion laughs protection.\n+\n+Several bugs in the regex determinism checks were fixed. Invalid XML\n+Schemas which previous versions erroneously accepted will now be\n+rejected.\n+\n+### Deprecations\n+\n+- globals: Deprecate xmlLastError\n+- parser: Deprecate global parser options\n+- win32: Deprecate old Windows build system\n+\n+### Bug fixes\n+\n+- parser: Stop switching to ISO-8859-1 on encoding errors\n+- parser: Support encoded external PEs in entity values\n+- string: Fix UTF-8 validation in xmlGetUTF8Char\n+- SAX2: Allow multiple top-level elements\n+- parser: Update line number after coalescing text nodes\n+- parser: Check for truncated multi-byte sequences\n+\n+### Improvements\n+\n+- error: Make more xmlError structs constant\n+- parser: Remove redundant IS_CHAR check in xmlCurrentChar\n+- parser: Fix stack handling in xmlParseTryOrFinish\n+- parser: Protect against quadratic default attribute expansion\n+- parser: Missing checks for disableSAX\n+- entities: Make xmlFreeEntity public\n+- examples: Don't use sprintf\n+- encoding: Suppress -Wcast-align warnings\n+- parser: Use hash tables to avoid quadratic behavior\n+- parser: Don't skip CR in xmlCurrentChar\n+- dict: Rewrite dictionary hash table code\n+- hash: Rewrite hash table code\n+- malloc-fail: Report malloc failure in xmlFARegExec\n+- malloc-fail: Report malloc failure in xmlRegEpxFromParse\n+- parser: Simplify xmlStringCurrentChar\n+- regexp: Fix status codes and handle invalid UTF-8\n+- error: Make xmlGetLastError return a const error\n+- html: Fix logic in htmlAutoClose\n+- globals: Move globals back to correct header files\n+- globals: Use thread-local storage if available\n+- globals: Rework global state destruction on Windows\n+- globals: Define globals using macros\n+- globals: Introduce xmlCheckThreadLocalStorage\n+- globals: Make xmlGlobalState private\n+- threads: Move library initialization code to threads.c\n+- debug: Remove debugging code\n+- globals: Move code from threads.c to globals.c\n+- parser: Avoid undefined behavior in xmlParseStartTag2\n+- schemas: Fix memory leak of annotations in notations\n+- dict: Update hash function\n+- dict: Use thread-local storage for PRNG state\n+- dict: Use xoroshiro64** as PRNG\n+- xmllint: Fix error messages\n+- parser: Fix detection of null bytes\n+- parser: Improve error handling in push parser\n+- parser: Don't check inputNr in xmlParseTryOrFinish\n+- parser: Remove push parser debugging code\n+- tree: Fix copying of DTDs\n+- legacy: Add stubs for disabled modules\n+- parser: Allow to set maximum amplification factor\n+- entities: Don't change doc when encoding entities\n+- parser: Never use UTF-8 encoding handler\n+- encoding: Remove debugging code\n+- malloc-fail: Fix unsigned integer overflow in xmlTextReaderPushData\n+- html: Remove encoding hack in htmlCreateFileParserCtxt\n+- parser: Decode all data in xmlCharEncInput\n+- parser: Stream data when reading from memory\n+- parser: Optimize xmlLoadEntityContent\n+- parser: Don't overwrite EOF parser state\n+- parser: Simplify input pointer updates\n+- parser: Don't reinitialize parser input members\n+- encoding: Move rawconsumed accounting to xmlCharEncInput\n+- parser: Rework encoding detection\n+- parser: Always create UTF-8 in xmlParseReference\n+- html: Remove some debugging code in htmlParseTryOrFinish\n+- malloc-fail: Fix memory leak in xmlCompileAttributeTest\n+- parser: Recover more input from encoding errors\n+- malloc-fail: Handle malloc failures in xmlAddEncodingAlias\n+- malloc-fail: Fix null-deref with xmllint --copy\n+- xpath: Ignore entity ref nodes when computing node hash\n+- malloc-fail: Fix null deref after xmlXIncludeNewRef\n+- SAX: Always validate xml:ids\n+- Stop using sprintf\n+- Fix compiler warning on GCC < 8\n+- regexp: Fix determinism checks\n+- regexp: Fix checks for eliminated transitions\n+- regexp: Simplify xmlFAReduceEpsilonTransitions\n+- regexp: Fix cycle check in xmlFAReduceEpsilonTransitions\n+- schemas: Fix filename in xmlSchemaValidateFile\n+- schemas: Fix line numbers in streaming validation\n+- writer: Add error check in xmlTextWriterEndDocument\n+- encoding: Stop calling xmlEncodingErr\n+- xmlIO: Remove some calls to xmlIOErr\n+- parser: Improve handling of encoding and IO errors\n+- parser: Move xmlFatalErr to parserInternals.c\n+- encoding: Rework error codes\n+- .gitignore: Split up and rearrange .gitignore files\n+- .gitignore: Add runsuite.log\n+- Stop calling xmlMemoryDump\n+- examples: Don't call xmlCleanupParser and xmlMemoryDump\n+- xpath: Remove remaining references to valueFrame\n+\n+### Portability\n+\n+- python: Make it compatible with python3.12 (Daniel Garcia Moreno)\n+\n+### Build systems\n+\n+- cmake: Check whether static linking dependencies found in config files\n+  (James Le Cuirot)\n+- autotools: Make --with-minimum disable lzma support\n+- build: Remove some GCC warnings\n+- Handle NOCONFIG case when setting locations from CMake target properties\n+  (Markus Rickert)\n+- cmake: Generate better pkg-config file for SYSROOT builds under CMake\n+  (James Le Cuirot)\n+- autoconf: Include non-pkg-config dependency flags in the pkg-config file\n+  (James Le Cuirot)\n+- autoconf: Don't bake build time CFLAGS into pkg-config file (James Le Cuirot)\n+- build: Generate better pkg-config files for static-only builds (James\n+  Le Cuirot)\n+- build: Generate better pkg-config file for SYSROOT builds (James Le Cuirot)\n+- autoconf: Allow custom --with-icu configure option\n+\n+### Tests\n+\n+- tests: Also test xmlNextChar in testchar.c\n+- tests: Start with testparser.c for extra tests\n+- fuzz: Raise rss_limit_mb\n+- fuzz: Test xmlTextReaderRead after EOF or failure\n+- fuzz: Test XML_PARSE_XINCLUDE | XML_PARSE_VALID\n+- tests: Handle entities in SAX tests\n+- fuzz: Disable XML_PARSE_SAX1 option in xml fuzzer\n+- tests: Add more tests for redefined attributes\n+- hash: Add hash table tests\n+- tests: Add ATTRIBUTE_NO_SANITIZE_INTEGER macro\n+- fuzz: Allow to fuzz without push, reader or output modules\n+- gitlab-ci: Add a \"medium\" config build\n+- python: Fix tests on MinGW\n+- test: Add push parser test with overridden encoding\n+- testapi: test_xmlSAXDefaultVersion() leaves xmlSAX2DefaultVersionValue set\n+  to 1 with LIBXML_SAX1_ENABLED (David Kilzer)\n+- gitlab-ci: Lower _XOPEN_SOURCE value\n+- testapi: Don't set http_proxy environment variable\n+- test: Add push parser tests for split UTF-8 sequences\n+- xinclude: Lower initial table size when fuzzing\n+- tests: Test streaming schema validation\n+- runtest: Skip element name in schema error messages\n+\n+### Documentation\n+\n+- doc: Add notes about runtest to MAINTAINERS.md\n+- doc: Don't document internal macros in xmlversion.h\n+- doc: Allow 'unsigned' without 'int'\n+- doc: Improve documentation of configuration options\n+\n+\n+v2.11.6: Nov 16 2023\n+\n+### Regressions\n+\n+- threads: Fix --with-thread-alloc\n+- xinclude: Fix 'last' pointer in xmlXIncludeCopyNode\n+\n+### Bug fixes\n+\n+- parser: Fix potential use-after-free in xmlParseCharDataInternal\n+\n+\n+v2.11.5: Aug 9 2023\n+\n+### Regressions\n+\n+- parser: Make xmlSwitchEncoding always skip the BOM\n+- autotools: Improve iconv check\n+\n+### Bug fixes\n+\n+- valid: Fix c1->parent pointer in xmlCopyDocElementContent\n+- encoding: Always call ucnv_convertEx with flush set to false\n+\n+### Portability\n+\n+- autotools: fix Python module file ext for cygwin\/msys2 (Christoph Reiter)\n+\n+### Tests\n+\n+- runtest: Fix compilation without LIBXML_HTML_ENABLED\n+\n+\n+v2.11.4: May 18 2023\n+\n+Fixes a serious regression.\n+\n+- parser: Fix regression when push parsing UTF-8 sequences\n+\n+\n+v2.11.3: May 11 2023\n+\n+Fixes more regressions.\n+\n+- xinclude: Fix false positives in inclusion loop detection\n+- autotools: Fix ICU detection\n+- parser: Fix \"huge input lookup\" error with push parser\n+- xpath: Fix build without LIBXML_XPATH_ENABLED\n+- hash: Fix possible startup crash with old libxslt versions\n+- autoconf: fix iconv library paths (Mike Dalessio)\n+\n+\n+v2.11.2: May 5 2023\n+\n+Fix regressions.\n+\n+- threads: Fix startup crash with weak symbol hack\n+- win32: Don't depend on removed .def file\n+- schemas: Fix memory leak in xmlSchemaValidateStream\n+\n+\n+v2.11.1: Apr 30 2023\n+\n+Fixes build and ABI issues.\n+\n+- cmake: Fix va_copy detection (Luca Niccoli)\n+- libxml.m4: Fix quoting\n+- Link with --undefined-version\n+- libxml2.syms: Revert removal of version information\n+\n+\n+v2.11.0: Apr 28 2023\n+\n+### Major changes\n+\n+Protection against entity expansion attacks, also known as \"billion laughs\"\n+has been greatly improved. Malicious files should be detected reliably now\n+and false positives should be reduced. It is possible though that large\n+documents which make heavy use of entities are rejected now.\n+\n+This release finally fixes symbol visibility on UNIX systems. Internal\n+symbols will now be hidden. While these symbols were never declared in public\n+headers, it was still possible to declare them manually. Now this won't work.\n+\n+All symbol information has been removed from the ELF version script to fix\n+link errors with --no-undefined-version. The version nodes are kept so it\n+should still be possible to run binaries linked against older versions.\n+\n+About 90 memory errors in code paths handling malloc failures have been fixed.\n+While these issues shouldn't impact security, this improves robustness under\n+memory pressure.\n+\n+The XInclude engine has been reworked to properly support nested includes.\n+\n+Several cases of quadratic behavior in the XML push parser have been fixed.\n+\n+Refactoring has begun on some buffering and encoding code with the goal of\n+simplifying this part of the code base and improving error reporting.\n+\n+Other highlights:\n+\n+- Consolidated private header files.\n+- Major rework of the autoconf build.\n+- Deprecated several outdated and internal functions.\n+\n+Special thanks to Google's Open Source Security Subsidies program for\n+sponsoring much of the work on this release!\n+\n+Ongoing work on libxml2 relies on funding. For a list of important open\n+issues see <https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/issues\/507>\n+\n+### Security\n+\n+- Fix use-after-free in xmlParseContentInternal() (David Kilzer)\n+- xmllint: Fix use-after-free with --maxmem\n+- parser: Fix OOB read when formatting error message\n+- entities: Rework entity amplification checks\n+\n+### Regressions\n+\n+- parser: Fix regression in xmlParserNodeInfo accounting\n+\n+### Bug fixes\n+\n+- Fix memory errors in code handling malloc failures\n+- encoding: Fix error code in asciiToUTF8\n+- xpath: number('-') should return NaN\n+- xmlParseStartTag2() contains typo when checking for default definitions for\n+  an attribute in a namespace (David Kilzer)\n+- uri: Fix handling of port numbers\n+- error: Make sure that error messages are valid UTF-8\n+- xinclude: Fix nested includes\n+\n+### Improvements\n+\n+- xmllint: Validate --maxmem integer option\n+- xmlValidatePopElement() can return invalid value (-1) (David Kilzer)\n+- parser: Rework EBCDIC code page detection\n+- parser: Limit name length in xmlParseEncName\n+- parser: Rework shrinking of input buffers\n+- html: Rely on CUR_CHAR to grow the input buffer\n+- parser: Rely on CUR_CHAR\/NEXT to grow the input buffer\n+- valid: Make xmlValidateElement non-recursive\n+- html: Fix quadratic behavior in htmlParseTryOrFinish\n+- xmllint: Fix memory leak with --pattern --stream\n+- parser: Stop calling xmlParserInputShrink\n+- html: Impose some length limits\n+- valid: Allow xmlFreeValidCtxt(NULL)\n+- parser: Stop calling xmlParserInputGrow\n+- xinclude: Fix quadratic behavior in xmlXIncludeLoadTxt\n+- xinclude: Abort immediately if max depth was exceeded\n+- xpath: Only report the first error\n+- error: Don't move past current position\n+- error: Limit number of parser errors\n+- parser: Lower entity nesting limit with XML_PARSE_HUGE\n+- parser: Don't increase depth twice when parsing internal entities\n+- parser: Improve detection of entity loops\n+- parser: Only report a single entity error\n+- libxml.h: Remove dubious definition of LIBXML_STATIC\n+- html: Improve parsing of nested lists\n+- memory: Don't use locks in xmlMemUsed\n+- encoding: Remove unused variable xmlDefaultCharEncodingHandler\n+- Rework initialization code\n+- Add .editorconfig\n+- parser: Merge misc, prolog and epilog cases in push parser\n+- parser: Fix 'consumed' accounting when switching encodings\n+- html: Fix check for end of comment in push parser\n+- parser: Fix push parser with 1-3 byte initial chunk\n+- parser: Rewrite push parser boundary checks\n+- reader: Switch to xmlParserInputBufferCreateMem\n+- html: Don't escape ASCII chars in href attributes\n+- io: Don't shrink memory input buffers\n+- parser: Don't call xmlSHRINK from push parser\n+- parser: Ignore cdata argument in xmlParseCharData\n+- parser: Rework push parser parser progress checks\n+- io: Fix a few integer overflows in I\/O statistics\n+- io: Rework xmlParserInputBufferGrow with encodings\n+- io: Remove xmlInputReadCallbackNop\n+- io: Check for memory buffer early in xmlParserInputGrow\n+- parser: Fix error message in xmlParseCommentComplex\n+- Bypass proxy in nanoHTTP for hosts in \"no_proxy\" (Markus Jörg)\n+- schemas: Fix infinite loop in xmlSchemaCheckElemSubstGroup\n+- threads: Remove check for pthread_equal\n+- xinclude: Rework XInclude cache\n+- xinclude: Remove inefficient refcounting scheme\n+- xmllint: Improve handling of empty XPath node sets\n+- parser: Fix potential memory leak in xmlParseAttValueInternal\n+- error: Don't use initGenericErrorDefaultFunc\n+- xpath: Lower XPath recursion limit on Windows\n+- Stop including sys\/types.h\n+- Don't define WIN32 macro\n+- Make xmlNewSAXParserCtx take a const sax handler\n+- Consolidate private header files\n+- Remove internal macros from parserInternals.h\n+- Move some HTML functions to correct header file\n+- xmllint: Stop calling xmlSAXDefaultVersion\n+- Introduce xmlNewSAXParserCtxt and htmlNewSAXParserCtxt\n+- Don't mess with parser options in htmlParseDocument\n+- Remove useless call to htmlDefaultSAXHandlerInit\n+- Remove htmlDefaultSAXHandler from non-SAX1 build\n+- Don't initialize SAX handler in htmlReadMemory\n+- Fix htmlReadMemory mixing up XML and HTML functions\n+- Don't use default SAX handler to report unrelated errors\n+- Create stream with buffer in xmlNewStringInputStream\n+- xmlcatalog: Fix memory leaks\n+\n+### Code quality\n+\n+- xzlib: Fix implicit sign change in xz_open\n+- parser: Simplify calculation of available buffer space\n+- parser: Use size_t when subtracting input buffer pointers\n+- parser: Check for integer overflow when updating checkIndex\n+- xpath: Fix harmless integer overflow in xmlXPathTranslateFunction\n+- schematron: Use logical and\n+- relaxng: Remove useless if statement\n+- schemas: Remove useless if statement\n+- pattern: Merge identical branches\n+- regexp: Add sanity check in xmlRegCalloc2\n+- regexp: Simplify xmlRegAtomPush\n+- encoding: Cast toupper argument to unsigned char\n+- uri: Add explicit cast in xmlSaveUri\n+- buf: Fix return value of xmlBufGetInputBase\n+- parser: Fix integer overflow of input ID\n+- parser: Remove useless ent->etype test in xmlParseReference\n+- parser: Remove useless ent->children tests in xmlParseReference\n+- xmlmemory.c: Remove xmlMemContentShow\n+- libxml.h: Add comments and indentation\n+- libxml.h: Don't include stdio.h\n+- xmlexports.h: Disable docs for internal macro XMLPUBLIC\n+- parser: Simplify xmlParseConditionalSections\n+- io: Rearrange code in xmlSwitchInputEncodingInt\n+- warnings: Fix -Wstrict-prototypes warning\n+- warnings: Remove set-but-unused variables\n+- Fix compiler warnings in SAX2.c\n+- Fix unused variable warning in python\/types.c\n+- Fix compiler warning in examples\n+- Fix compiler warnings in fuzzing code\n+- Remove unused code in nanohttp.c\n+- Remove or annotate char casts\n+- Don't use sizeof(xmlChar) or sizeof(char)\n+- Remove explicit integer casts\n+\n+### Deprecations\n+\n+- parser: Deprecate more internal functions\n+- parser: Deprecate some parser input functions\n+- parser: Deprecate xmlString*DecodeEntities\n+- threads: Deprecate some internal functions\n+- buf: Deprecate static\/immutable buffers\n+- Deprecate internal parser functions\n+- Deprecate old HTML SAX API\n+- Generate deprecation warnings for old SAX API\n+- Mark more functions setting globals as deprecated\n+- Mark more parser functions as deprecated\n+- Mark most SAX1 functions as deprecated\n+- Deprecate some global variables\n+\n+### Portability\n+\n+- autoconf: Warn about outdated C compilers\n+- win32: Remove broken libxml2.def.src\n+- Remove symbols from version script\n+- catalog.c: Silence a cast warning on VS 2022 (Lukáš Tyrychtr)\n+- libxml.h: Remove ancient LynxOS setup\n+- Use python3 not python (Ross Burton)\n+- xstc\/fixup-tests.py: port to Python 3 (Ross Burton)\n+- xstc\/fixup-tests.py: unify whitespace (Ross Burton)\n+- Remove hacky heuristic from b2dc5675 (Alex Richardson)\n+- Avoid creating an out-of-bounds pointer by rewriting a check\n+  (Alex Richardson)\n+- Hide internal functions\n+- Correctly relocate internal pointers after realloc() (Alex Richardson)\n+- Visual Studio builds: Allow silencing deprecation warnings (Chun-wei Fan)\n+- Visual Studio: Define XML_DEPRECATED (Chun-wei Fan)\n+- xmllint: Include <io.h> on Windows\n+- warnings: Work around MSVC bug\n+- sources: Silence C4013 warnings on Visual Studio (Chun-wei Fan)\n+- python\/setup.py.in: Improve Windows import patching (Chun-wei Fan)\n+- python: Create .pyd on Windows\n+- Fix Python build on Windows\n+- Fix Windows compiler warnings in python\/types.c\n+- Fix libxml_PyFileGet\n+- Remove BeOS support\n+- Fix libxml_PyFileGet with stdout on macOS\n+- Migrate from PyEval_ to PyObject_\n+- Port build_glob.py to Python 3\n+- Port genChRanges.py to Python 3\n+- xmlexports.h: Remove LIBXML_FASTCALL optimization\n+- Remove XMLCALL and XMLCDECL macros from public headers\n+- Remove XMLDECL macro from .c files\n+\n+### Build systems\n+\n+- cmake: Link against `dl` and `dld` only when `LIBXML2_WITH_MODULES` is\n+  enabled (Alexander Kutelev)\n+- autotools: Fix make distcheck\n+- Remove RPM build, Makefile.tests, README.tests\n+- libxml.m4: deprecate AM_PATH_XML2, wrap PKG_CHECK_MODULES instead\n+  (Ross Burton)\n+- libxml.m4: fix -Wstrict-prototypes (Sam James)\n+- cmake: Build static library with -DLIBXML_STATIC\n+- autotools: Don't use version script on Windows\n+- autotools: Fix winsock detection\n+- autotools: Only add network libraries if HTTP\/FTP enabled\n+- autotools: Disable parallel Python build\n+- python: Don't output missing generators during build\n+- build: Remove check for broken ss_family\n+- http: Simplify IPv6 checks\n+- autotools: Fix network checks on Windows\n+- Fix detection of GNU libiconv\n+- cmake: Fix Python installation\n+- cmake: Don't check for Python 2\n+- configure.ac: Also check for MSYS host\n+- Improve network library detection\n+- Detect ws2_32 with AC_SEARCH_LIBS\n+- Rework network configure checks\n+- Remove arg cast configure checks\n+- Fix dlopen check\n+- Remove HAVE_WIN32_THREADS configuration flag\n+- Rework dlopen and pthread detection\n+- Fix test in configure.ac\n+- cmake: Enable GCC compiler warnings\n+- Always link with -no-undefined\n+- Use AM_CFLAGS and AM_LDFLAGS consistently\n+- Remove -Wredundant-decls\n+- Call AC_CHECK_* with multiple arguments\n+- configure.ac: Remove checks for unused programs\n+- Rework library detection in configure.ac\n+- Rearrange configure.ac\n+- Consolidate zlib and lzma detection\n+- Remove \"runtime debugging\"\n+- Consolidate simple API modules in configure.ac\n+- Fix dependency resolution in configure.ac\n+- Fix --with-valid --without-regexps build\n+- Fix --with-schemas --without-xpath build\n+- Don't build unneeded .c source files\n+- Move xmlIsXHTML to tree.c\n+- Cleanup distribution settings in Makefile.am\n+- Also clean *.pyc files for Python 2\n+- Don't distribute libxml2.spec\n+\n+### Tests\n+\n+- testchar: Add test for memory pull parser with encoding\n+- fuzz: Also test init function of URI fuzzer\n+- fuzz: Separate fuzzer for DTD validation\n+- gitlab-ci: Enable all \"integer\" sanitizers\n+- fuzz: Inject random malloc failures\n+- fuzz: Support variable integer sizes in fuzz data\n+- fuzz: Fix duplicate detection in fuzzEntityRecorder\n+- fuzz: Set filename in xmlFuzzEntityLoader\n+- fuzz: Allow xmlFuzzReadString(NULL)\n+- fuzz: Fix Makefile dependencies\n+- fuzz: Add test\/recurse to seed corpus\n+- fuzz: Add separate XInclude fuzzer\n+- runsuite: Some errors are expected\n+- testrecurse: Test entity expansion stats\n+- testapi.c: Initialize catalog early\n+- gentest.py: Fix memory leak in API tests\n+- tests: Enable \"runsuite\" test\n+- python\/tests\/reader2: use absolute paths everywhere (Ross Burton)\n+- python\/tests\/reader2: always exit(1) if a test fails (Ross Burton)\n+- testModule: exit if the module can't be opened (Ross Burton)\n+- CI: disable modules in gcc:static build (Ross Burton)\n+- CI: fix CI on MinGW builds (Ross Burton)\n+- python: Fix memory leak checks\n+- tests: Check that xmlInitParser doesn't allocate memory\n+- tests: Fix use-after-free in Python tests\n+- tests: Remove unneeded #includes\n+- gitlab-ci: Make Test-Msvc exit if ctest fails\n+- gitlab-ci: Treat compiler warnings as errors on MSVC\n+- test: Add test for push parser boundaries\n+- gitlab-ci: Upgrade image to Ubuntu 22.10, reenable MSan\n+- gitlab-ci: Reenable LeakSanitizer\n+- gitlab-ci: Fix llvm-symbolizer\n+- xinclude: Don't create result doc for test with errors\n+- xinclude: Also test error messages\n+- gitlab-ci: Allow cast-align warnings from clang\n+- gitlab-ci: Fix tar invocation\n+- gitlab-ci: Move MSVC test to separate script\n+- gitlab-ci: Fix SUFFIX, remove MINGW_PATH\n+- gitlab-ci: Consolidate CMake test scripts\n+- gitlab-ci: Only install MinGW autotools if needed\n+- gitlab-ci: Only install cmake MinGW package if needed\n+- gitlab-ci: Install 7-Zip using the .msi\n+- Use $MSYSTEM and 'bash -lc' in MinGW CI\n+- Add CI job for MinGW\/Autotools\n+- Consolidate CI scripts\n+- Allow empty MINGW_PACKAGE_PREFIX\n+- Move Dockerfile to .gitlab-ci directory\n+- testapi: Disable on Windows for now\n+- Disable fuzzer tests if glob.h wasn't found\n+- Move automata test to runtest.c\n+- Fix testapi when building --without-sax1\n+\n+# Documentation\n+\n+- doc: Remove ancient files\n+- Remove ancient TODOs\n+- html: Fix htmlInitAutoClose documentation\n+- doc: Mention new location of XML catalog as breaking change\n+- doc: Mention potentially breaking changes in NEWS\n+- doc: Remove xmlDllMain from documentation and version script\n+- doc: Mention ${sysconfdir} in man pages\n+- doc: Document xmlcatalog --convert\n+- doc: Document xmllint --nodict and --pedantic\n+- doc: Fix indentation in source XML files\n+- xmllint: Document --quiet option\n+- Improve cross-references in API docs\n+- Improve documentation of globals\n+- Fix documentation parser\n+- Support comments for global variables in documentation\n+- Fix update call in apibuild.py\n+- Don't index anything in DOC_DISABLE sections\n+- Fix warnings from apibuild.py\n+- Start with documentation for maintainers\n+\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/NEWS","additions":689,"deletions":0,"binary":false,"changes":689,"status":"modified"},{"patch":"@@ -6,2 +6,5 @@\n-Full documentation is available at\n-<https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/wikis>.\n+Official releases can be downloaded from\n+<https:\/\/download.gnome.org\/sources\/libxml2\/>\n+\n+The git repository is hosted on GNOME's GitLab server:\n+<https:\/\/gitlab.gnome.org\/GNOME\/libxml2>\n@@ -10,1 +13,1 @@\n-<https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/issues>.\n+<https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/issues>\n@@ -12,3 +15,2 @@\n-A mailing list xml@gnome.org is available. You can subscribe at\n-<https:\/\/mail.gnome.org\/mailman\/listinfo\/xml>. The list archive is at\n-<https:\/\/mail.gnome.org\/archives\/xml\/>.\n+Documentation is available at\n+<https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/wikis>\n@@ -30,1 +32,1 @@\n-    .\/autogen.sh\n+    .\/autogen.sh [configuration options]\n@@ -37,3 +39,1 @@\n-To see a list of build options:\n-\n-    .\/configure --help\n+Then you can configure and build the library:\n@@ -41,4 +41,1 @@\n-Also see the INSTALL file for additional instructions. Then you can\n-configure and build the library:\n-\n-    .\/configure [possible options]\n+    .\/configure [configuration options]\n@@ -47,0 +44,40 @@\n+The following options disable or enable code modules and relevant symbols:\n+\n+    --with-c14n             Canonical XML 1.0 support (on)\n+    --with-catalog          XML Catalogs support (on)\n+    --with-debug            debugging module and shell (on)\n+    --with-history          history support for shell (off)\n+    --with-readline[=DIR]   use readline in DIR (for shell history)\n+    --with-html             HTML parser (on)\n+    --with-http             HTTP support (on)\n+    --with-iconv[=DIR]      iconv support (on)\n+    --with-icu              ICU support (off)\n+    --with-iso8859x         ISO-8859-X support if no iconv (on)\n+    --with-lzma[=DIR]       use liblzma in DIR (on)\n+    --with-mem-debug        memory debugging module (off)\n+    --with-modules          dynamic modules support (on)\n+    --with-output           serialization support (on)\n+    --with-pattern          xmlPattern selection interface (on)\n+    --with-push             push parser interfaces (on)\n+    --with-python           Python bindings (on)\n+    --with-reader           xmlReader parsing interface (on)\n+    --with-regexps          regular expressions support (on)\n+    --with-run-debug        runtime debugging module (off)\n+    --with-sax1             older SAX1 interface (on)\n+    --with-schemas          XML Schemas 1.0 and RELAX NG support (on)\n+    --with-schematron       Schematron support (on)\n+    --with-threads          multithreading support (on)\n+    --with-thread-alloc     per-thread malloc hooks (off)\n+    --with-tree             DOM like tree manipulation APIs (on)\n+    --with-valid            DTD validation support (on)\n+    --with-writer           xmlWriter serialization interface (on)\n+    --with-xinclude         XInclude 1.0 support (on)\n+    --with-xpath            XPath 1.0 support (on)\n+    --with-xptr             XPointer support (on)\n+    --with-zlib[=DIR]       use libz in DIR (on)\n+\n+Other options:\n+\n+    --with-minimum          build a minimally sized library (off)\n+    --with-legacy           maximum ABI compatibility (off)\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/README.md","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+#include <libxml\/SAX2.h>\n@@ -25,1 +26,0 @@\n-#include <libxml\/SAX.h>\n@@ -29,1 +29,0 @@\n-#include <libxml\/globals.h>\n@@ -31,2 +30,3 @@\n-\/* #define DEBUG_SAX2 *\/\n-\/* #define DEBUG_SAX2_TREE *\/\n+#include \"private\/error.h\"\n+#include \"private\/parser.h\"\n+#include \"private\/tree.h\"\n@@ -330,5 +330,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2InternalSubset(%s, %s, %s)\\n\",\n-            name, ExternalID, SystemID);\n-#endif\n@@ -367,5 +362,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2ExternalSubset(%s, %s, %s)\\n\",\n-            name, ExternalID, SystemID);\n-#endif\n@@ -383,2 +373,0 @@\n-        xmlCharEncoding enc;\n-        int oldcharset;\n@@ -386,0 +374,3 @@\n+        int oldprogressive;\n+        unsigned long consumed;\n+        size_t buffered;\n@@ -406,1 +397,0 @@\n-        oldcharset = ctxt->charset;\n@@ -408,0 +398,1 @@\n+        oldprogressive = ctxt->progressive;\n@@ -409,0 +400,1 @@\n+        ctxt->progressive = 0;\n@@ -414,0 +406,1 @@\n+            xmlFreeInputStream(input);\n@@ -418,1 +411,0 @@\n-            ctxt->charset = oldcharset;\n@@ -420,0 +412,1 @@\n+            ctxt->progressive = oldprogressive;\n@@ -427,8 +420,0 @@\n-        \/*\n-         * On the fly encoding conversion if needed\n-         *\/\n-        if (ctxt->input->length >= 4) {\n-            enc = xmlDetectCharEncoding(ctxt->input->cur, 4);\n-            xmlSwitchEncoding(ctxt, enc);\n-        }\n-\n@@ -454,0 +439,12 @@\n+\n+        consumed = ctxt->input->consumed;\n+        buffered = ctxt->input->cur - ctxt->input->base;\n+        if (buffered > ULONG_MAX - consumed)\n+            consumed = ULONG_MAX;\n+        else\n+            consumed += buffered;\n+        if (consumed > ULONG_MAX - ctxt->sizeentities)\n+            ctxt->sizeentities = ULONG_MAX;\n+        else\n+            ctxt->sizeentities += consumed;\n+\n@@ -464,1 +461,0 @@\n-        ctxt->charset = oldcharset;\n@@ -470,0 +466,1 @@\n+        ctxt->progressive = oldprogressive;\n@@ -504,5 +501,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2ResolveEntity(%s, %s)\\n\", publicId, systemId);\n-#endif\n-\n@@ -532,4 +524,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2GetEntity(%s)\\n\", name);\n-#endif\n@@ -582,4 +570,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2GetParameterEntity(%s)\\n\", name);\n-#endif\n@@ -611,5 +595,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2EntityDecl(%s, %d, %s, %s, %s)\\n\",\n-            name, type, publicId, systemId, content);\n-#endif\n@@ -688,5 +667,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2AttributeDecl(%s, %s, %d, %d, %s, ...)\\n\",\n-            elem, fullname, type, def, defaultValue);\n-#endif\n@@ -758,5 +732,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-                    \"SAX.xmlSAX2ElementDecl(%s, %d, ...)\\n\", name, type);\n-#endif\n-\n@@ -807,5 +776,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2NotationDecl(%s, %s, %s)\\n\", name, publicId, systemId);\n-#endif\n-\n@@ -856,5 +820,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2UnparsedEntityDecl(%s, %s, %s, %s)\\n\",\n-            name, publicId, systemId, notationName);\n-#endif\n@@ -919,5 +878,0 @@\n-    \/* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; *\/\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2SetDocumentLocator()\\n\");\n-#endif\n@@ -940,4 +894,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2StartDocument()\\n\");\n-#endif\n@@ -969,4 +919,0 @@\n-            if (ctxt->encoding != NULL)\n-                doc->encoding = xmlStrdup(ctxt->encoding);\n-            else\n-                doc->encoding = NULL;\n@@ -1001,4 +947,2 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2EndDocument()\\n\");\n-#endif\n+    xmlDocPtr doc;\n+\n@@ -1012,17 +956,9 @@\n-    \/*\n-     * Grab the encoding if it was added on-the-fly\n-     *\/\n-    if ((ctxt->encoding != NULL) && (ctxt->myDoc != NULL) &&\n-        (ctxt->myDoc->encoding == NULL)) {\n-        ctxt->myDoc->encoding = ctxt->encoding;\n-        ctxt->encoding = NULL;\n-    }\n-    if ((ctxt->inputTab != NULL) &&\n-        (ctxt->inputNr > 0) && (ctxt->inputTab[0] != NULL) &&\n-        (ctxt->inputTab[0]->encoding != NULL) && (ctxt->myDoc != NULL) &&\n-        (ctxt->myDoc->encoding == NULL)) {\n-        ctxt->myDoc->encoding = xmlStrdup(ctxt->inputTab[0]->encoding);\n-    }\n-    if ((ctxt->charset != XML_CHAR_ENCODING_NONE) && (ctxt->myDoc != NULL) &&\n-        (ctxt->myDoc->charset == XML_CHAR_ENCODING_NONE)) {\n-        ctxt->myDoc->charset = ctxt->charset;\n+    doc = ctxt->myDoc;\n+    if ((doc != NULL) && (doc->encoding == NULL)) {\n+        const xmlChar *encoding = xmlGetActualEncoding(ctxt);\n+\n+        if (encoding != NULL) {\n+            doc->encoding = xmlStrdup(encoding);\n+            if (doc->encoding == NULL)\n+                xmlSAX2ErrMemory(ctxt, \"xmlSAX2EndDocument\");\n+        }\n@@ -1314,0 +1250,2 @@\n+    if (ret == NULL)\n+        goto error;\n@@ -1315,3 +1253,2 @@\n-    if (ret != NULL) {\n-        if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {\n-            xmlNodePtr tmp;\n+    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {\n+        xmlNodePtr tmp;\n@@ -1319,13 +1256,7 @@\n-            ret->children = xmlStringGetNodeList(ctxt->myDoc, value);\n-            tmp = ret->children;\n-            while (tmp != NULL) {\n-                tmp->parent = (xmlNodePtr) ret;\n-                if (tmp->next == NULL)\n-                    ret->last = tmp;\n-                tmp = tmp->next;\n-            }\n-        } else if (value != NULL) {\n-            ret->children = xmlNewDocText(ctxt->myDoc, value);\n-            ret->last = ret->children;\n-            if (ret->children != NULL)\n-                ret->children->parent = (xmlNodePtr) ret;\n+        ret->children = xmlStringGetNodeList(ctxt->myDoc, value);\n+        tmp = ret->children;\n+        while (tmp != NULL) {\n+            tmp->parent = (xmlNodePtr) ret;\n+            if (tmp->next == NULL)\n+                ret->last = tmp;\n+            tmp = tmp->next;\n@@ -1333,0 +1264,5 @@\n+    } else if (value != NULL) {\n+        ret->children = xmlNewDocText(ctxt->myDoc, value);\n+        ret->last = ret->children;\n+        if (ret->children != NULL)\n+            ret->children->parent = (xmlNodePtr) ret;\n@@ -1591,5 +1527,0 @@\n-    parent = ctxt->node;\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2StartElement(%s)\\n\", fullname);\n-#endif\n@@ -1633,8 +1564,0 @@\n-    if (ctxt->myDoc->children == NULL) {\n-#ifdef DEBUG_SAX_TREE\n-        xmlGenericError(xmlGenericErrorContext, \"Setting %s as root\\n\", name);\n-#endif\n-        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);\n-    } else if (parent == NULL) {\n-        parent = ctxt->myDoc->children;\n-    }\n@@ -1644,2 +1567,2 @@\n-            if (ctxt->input->line < USHRT_MAX)\n-                ret->line = (unsigned short) ctxt->input->line;\n+            if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)\n+                ret->line = ctxt->input->line;\n@@ -1651,0 +1574,5 @@\n+    \/* Initialize parent before pushing node *\/\n+    parent = ctxt->node;\n+    if (parent == NULL)\n+        parent = (xmlNodePtr) ctxt->myDoc;\n+\n@@ -1654,3 +1582,0 @@\n-#ifdef DEBUG_SAX_TREE\n-    xmlGenericError(xmlGenericErrorContext, \"pushing(%s)\\n\", name);\n-#endif\n@@ -1668,16 +1593,1 @@\n-    if (parent != NULL) {\n-        if (parent->type == XML_ELEMENT_NODE) {\n-#ifdef DEBUG_SAX_TREE\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"adding child %s to %s\\n\", name, parent->name);\n-#endif\n-            xmlAddChild(parent, ret);\n-        } else {\n-#ifdef DEBUG_SAX_TREE\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"adding sibling %s to \", name);\n-            xmlDebugDumpOneNode(stderr, parent, 0);\n-#endif\n-            xmlAddSibling(parent, ret);\n-        }\n-    }\n+    xmlAddChild(parent, ret);\n@@ -1798,1 +1708,0 @@\n-    xmlNodePtr cur;\n@@ -1801,7 +1710,0 @@\n-    cur = ctxt->node;\n-#ifdef DEBUG_SAX\n-    if (name == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"SAX.xmlSAX2EndElement(NULL)\\n\");\n-    else\n-        xmlGenericError(xmlGenericErrorContext, \"SAX.xmlSAX2EndElement(%s)\\n\", name);\n-#endif\n@@ -1809,7 +1711,0 @@\n-    \/* Capture end position and add node *\/\n-    if (cur != NULL && ctxt->record_info) {\n-      ctxt->nodeInfo->end_pos = ctxt->input->cur - ctxt->input->base;\n-      ctxt->nodeInfo->end_line = ctxt->input->line;\n-      ctxt->nodeInfo->node = cur;\n-      xmlParserAddNodeInfo(ctxt, ctxt->nodeInfo);\n-    }\n@@ -1822,1 +1717,1 @@\n-                                             cur);\n+                                             ctxt->node);\n@@ -1829,3 +1724,0 @@\n-#ifdef DEBUG_SAX_TREE\n-    xmlGenericError(xmlGenericErrorContext, \"popping(%s)\\n\", cur->name);\n-#endif\n@@ -1907,12 +1799,0 @@\n-    if (ctxt->linenumbers) {\n-        if (ctxt->input != NULL) {\n-            if (ctxt->input->line < USHRT_MAX)\n-                ret->line = (unsigned short) ctxt->input->line;\n-            else {\n-                ret->line = USHRT_MAX;\n-                if (ctxt->options & XML_PARSE_BIG_LINES)\n-                    ret->psvi = (void *) (ptrdiff_t) ctxt->input->line;\n-            }\n-        }\n-    }\n-\n@@ -1968,0 +1848,2 @@\n+ *\n+ * Returns the new attribute or NULL in case of error.\n@@ -1969,1 +1851,1 @@\n-static void\n+static xmlAttrPtr\n@@ -1983,2 +1865,6 @@\n-    if (prefix != NULL)\n-        namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);\n+    if (prefix != NULL) {\n+        namespace = xmlParserNsLookupSax(ctxt, prefix);\n+        if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n+            namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);\n+        }\n+    }\n@@ -1993,2 +1879,7 @@\n-        memset(ret, 0, sizeof(xmlAttr));\n-        ret->type = XML_ATTRIBUTE_NODE;\n+    } else {\n+        ret = xmlMalloc(sizeof(*ret));\n+        if (ret == NULL) {\n+            xmlSAX2ErrMemory(ctxt, NULL);\n+            return(NULL);\n+        }\n+    }\n@@ -1996,3 +1887,2 @@\n-        ret->parent = ctxt->node;\n-        ret->doc = ctxt->myDoc;\n-        ret->ns = namespace;\n+    memset(ret, 0, sizeof(xmlAttr));\n+    ret->type = XML_ATTRIBUTE_NODE;\n@@ -2000,4 +1890,6 @@\n-        if (ctxt->dictNames)\n-            ret->name = localname;\n-        else\n-            ret->name = xmlStrdup(localname);\n+    \/*\n+     * xmlParseBalancedChunkMemoryRecover had a bug that could result in\n+     * a mismatch between ctxt->node->doc and ctxt->myDoc. We use\n+     * ctxt->node->doc here, but we should somehow make sure that the\n+     * document pointers match.\n+     *\/\n@@ -2005,5 +1897,1 @@\n-        \/* link at the end to preserve order, TODO speed up with a last *\/\n-        if (ctxt->node->properties == NULL) {\n-            ctxt->node->properties = ret;\n-        } else {\n-            xmlAttrPtr prev = ctxt->node->properties;\n+    \/* assert(ctxt->node->doc == ctxt->myDoc); *\/\n@@ -2011,4 +1899,3 @@\n-            while (prev->next != NULL) prev = prev->next;\n-            prev->next = ret;\n-            ret->prev = prev;\n-        }\n+    ret->parent = ctxt->node;\n+    ret->doc = ctxt->node->doc;\n+    ret->ns = namespace;\n@@ -2016,13 +1903,7 @@\n-        if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-            xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n-    } else {\n-        if (ctxt->dictNames)\n-            ret = xmlNewNsPropEatName(ctxt->node, namespace,\n-                                      (xmlChar *) localname, NULL);\n-        else\n-            ret = xmlNewNsProp(ctxt->node, namespace, localname, NULL);\n-        if (ret == NULL) {\n-            xmlErrMemory(ctxt, \"xmlSAX2AttributeNs\");\n-            return;\n-        }\n-    }\n+    if (ctxt->dictNames)\n+        ret->name = localname;\n+    else\n+        ret->name = xmlStrdup(localname);\n+\n+    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n@@ -2160,2 +2041,0 @@\n-#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)\n-#ifdef LIBXML_VALID_ENABLED\n@@ -2167,2 +2046,0 @@\n-#endif\n-#endif\n@@ -2178,0 +2055,2 @@\n+\n+    return(ret);\n@@ -2217,1 +2096,0 @@\n-    parent = ctxt->node;\n@@ -2266,0 +2144,1 @@\n+                xmlFree(ret);\n@@ -2287,2 +2166,2 @@\n-            if (ctxt->input->line < USHRT_MAX)\n-                ret->line = (unsigned short) ctxt->input->line;\n+            if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)\n+                ret->line = ctxt->input->line;\n@@ -2294,3 +2173,0 @@\n-    if (parent == NULL) {\n-        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);\n-    }\n@@ -2321,0 +2197,3 @@\n+\n+        xmlParserNsUpdateSax(ctxt, pref, ns);\n+\n@@ -2331,0 +2210,5 @@\n+    \/* Initialize parent before pushing node *\/\n+    parent = ctxt->node;\n+    if (parent == NULL)\n+        parent = (xmlNodePtr) ctxt->myDoc;\n+\n@@ -2343,7 +2227,1 @@\n-    if (parent != NULL) {\n-        if (parent->type == XML_ELEMENT_NODE) {\n-            xmlAddChild(parent, ret);\n-        } else {\n-            xmlAddSibling(parent, ret);\n-        }\n-    }\n+    xmlAddChild(parent, ret);\n@@ -2363,1 +2241,1 @@\n-        ret->ns = xmlSearchNs(ctxt->myDoc, parent, prefix);\n+        ret->ns = xmlParserNsLookupSax(ctxt, prefix);\n@@ -2389,0 +2267,2 @@\n+        xmlAttrPtr prev = NULL;\n+\n@@ -2390,0 +2270,2 @@\n+            xmlAttrPtr attr = NULL;\n+\n@@ -2400,3 +2282,4 @@\n-                        xmlSAX2AttributeNs(ctxt, fullname, NULL,\n-                                           attributes[j+3], attributes[j+4]);\n-                        continue;\n+                        attr = xmlSAX2AttributeNs(ctxt, fullname, NULL,\n+                                                  attributes[j+3],\n+                                                  attributes[j+4]);\n+                        goto have_attr;\n@@ -2408,2 +2291,3 @@\n-                        xmlSAX2AttributeNs(ctxt, lname, NULL,\n-                                           attributes[j+3], attributes[j+4]);\n+                        attr = xmlSAX2AttributeNs(ctxt, lname, NULL,\n+                                                  attributes[j+3],\n+                                                  attributes[j+4]);\n@@ -2411,1 +2295,1 @@\n-                        continue;\n+                        goto have_attr;\n@@ -2415,2 +2299,15 @@\n-            xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],\n-                               attributes[j+3], attributes[j+4]);\n+            attr = xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],\n+                                      attributes[j+3], attributes[j+4]);\n+have_attr:\n+            if (attr == NULL)\n+                continue;\n+\n+            \/* link at the end to preserve order *\/\n+            if (prev == NULL) {\n+                ctxt->node->properties = attr;\n+            } else {\n+                prev->next = attr;\n+                attr->prev = prev;\n+            }\n+\n+            prev = attr;\n@@ -2457,2 +2354,0 @@\n-    xmlParserNodeInfo node_info;\n-    xmlNodePtr cur;\n@@ -2461,8 +2356,0 @@\n-    cur = ctxt->node;\n-    \/* Capture end position and add node *\/\n-    if ((ctxt->record_info) && (cur != NULL)) {\n-        node_info.end_pos = ctxt->input->cur - ctxt->input->base;\n-        node_info.end_line = ctxt->input->line;\n-        node_info.node = cur;\n-        xmlParserAddNodeInfo(ctxt, &node_info);\n-    }\n@@ -2474,1 +2361,2 @@\n-        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc, cur);\n+        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,\n+                                             ctxt->node);\n@@ -2497,12 +2385,1 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2Reference(%s)\\n\", name);\n-#endif\n-    if (name[0] == '#')\n-        ret = xmlNewCharRef(ctxt->myDoc, name);\n-    else\n-        ret = xmlNewReference(ctxt->myDoc, name);\n-#ifdef DEBUG_SAX_TREE\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"add xmlSAX2Reference %s to %s \\n\", name, ctxt->node->name);\n-#endif\n+    ret = xmlNewReference(ctxt->myDoc, name);\n@@ -2530,4 +2407,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2Characters(%.30s, %d)\\n\", ch, len);\n-#endif\n@@ -2541,4 +2414,0 @@\n-#ifdef DEBUG_SAX_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"add chars: ctxt->node == NULL !\\n\");\n-#endif\n@@ -2548,4 +2417,0 @@\n-#ifdef DEBUG_SAX_TREE\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"add chars to %s \\n\", ctxt->node->name);\n-#endif\n@@ -2637,1 +2502,2 @@\n-                lastChild->doc = ctxt->myDoc;\n+                if (lastChild != NULL)\n+                    lastChild->doc = ctxt->myDoc;\n@@ -2649,0 +2515,13 @@\n+\n+    if ((lastChild != NULL) &&\n+        (type == XML_TEXT_NODE) &&\n+        (ctxt->linenumbers) &&\n+        (ctxt->input != NULL)) {\n+        if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)\n+            lastChild->line = ctxt->input->line;\n+        else {\n+            lastChild->line = USHRT_MAX;\n+            if (ctxt->options & XML_PARSE_BIG_LINES)\n+                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;\n+        }\n+    }\n@@ -2677,5 +2556,0 @@\n-    \/* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; *\/\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2IgnorableWhitespace(%.30s, %d)\\n\", ch, len);\n-#endif\n@@ -2702,4 +2576,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"SAX.xmlSAX2ProcessingInstruction(%s, %s)\\n\", target, data);\n-#endif\n@@ -2712,2 +2582,2 @@\n-            if (ctxt->input->line < USHRT_MAX)\n-                ret->line = (unsigned short) ctxt->input->line;\n+            if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)\n+                ret->line = ctxt->input->line;\n@@ -2726,4 +2596,0 @@\n-#ifdef DEBUG_SAX_TREE\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Setting PI %s as root\\n\", target);\n-#endif\n@@ -2734,4 +2600,0 @@\n-#ifdef DEBUG_SAX_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"adding PI %s child to %s\\n\", target, parent->name);\n-#endif\n@@ -2740,5 +2602,0 @@\n-#ifdef DEBUG_SAX_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"adding PI %s sibling to \", target);\n-        xmlDebugDumpOneNode(stderr, parent, 0);\n-#endif\n@@ -2765,3 +2622,0 @@\n-#ifdef DEBUG_SAX\n-    xmlGenericError(xmlGenericErrorContext, \"SAX.xmlSAX2Comment(%s)\\n\", value);\n-#endif\n@@ -2772,2 +2626,2 @@\n-            if (ctxt->input->line < USHRT_MAX)\n-                ret->line = (unsigned short) ctxt->input->line;\n+            if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)\n+                ret->line = ctxt->input->line;\n@@ -2787,4 +2641,0 @@\n-#ifdef DEBUG_SAX_TREE\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Setting xmlSAX2Comment as root\\n\");\n-#endif\n@@ -2795,4 +2645,0 @@\n-#ifdef DEBUG_SAX_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"adding xmlSAX2Comment child to %s\\n\", parent->name);\n-#endif\n@@ -2801,5 +2647,0 @@\n-#ifdef DEBUG_SAX_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"adding xmlSAX2Comment sibling to \");\n-        xmlDebugDumpOneNode(stderr, parent, 0);\n-#endif\n@@ -2831,0 +2672,2 @@\n+ * DEPRECATED: Use parser option XML_PARSE_SAX1.\n+ *\n@@ -2865,2 +2708,0 @@\n-        hdlr->startElement = NULL;\n-        hdlr->endElement = NULL;\n@@ -2873,2 +2714,0 @@\n-        hdlr->startElement = xmlSAX2StartElement;\n-        hdlr->endElement = xmlSAX2EndElement;\n@@ -2879,0 +2718,7 @@\n+#ifdef LIBXML_SAX1_ENABLED\n+    hdlr->startElement = xmlSAX2StartElement;\n+    hdlr->endElement = xmlSAX2EndElement;\n+#else\n+    hdlr->startElement = NULL;\n+    hdlr->endElement = NULL;\n+#endif \/* LIBXML_SAX1_ENABLED *\/\n@@ -2931,1 +2777,1 @@\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n+ * DEPRECATED: This function is a no-op. Call xmlInitParser to\n@@ -2939,3 +2785,0 @@\n-#ifdef LIBXML_SAX1_ENABLED\n-    xmlSAXVersion((xmlSAXHandlerPtr) &xmlDefaultSAXHandler, 1);\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n@@ -2992,1 +2835,1 @@\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n+ * DEPRECATED: This function is a no-op. Call xmlInitParser to\n@@ -2994,2 +2837,0 @@\n- *\n- * Initialize the default SAX handler\n@@ -3000,1 +2841,0 @@\n-    xmlSAX2InitHtmlDefaultSAXHandler((xmlSAXHandlerPtr) &htmlDefaultSAXHandler);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/SAX2.c","additions":170,"deletions":330,"binary":false,"changes":500,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-#include <libxml\/tree.h>\n-#include <libxml\/globals.h>\n@@ -27,1 +25,3 @@\n-#include \"buf.h\"\n+\n+#include \"private\/buf.h\"\n+#include \"private\/error.h\"\n@@ -136,1 +136,1 @@\n-    ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));\n+    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n@@ -172,1 +172,1 @@\n-        ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));\n+        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n@@ -201,2 +201,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)\n-        return(NULL);\n@@ -217,34 +215,0 @@\n-\n-\/**\n- * xmlBufCreateStatic:\n- * @mem: the memory area\n- * @size:  the size in byte\n- *\n- * routine to create an XML buffer from an immutable memory area.\n- * The area won't be modified nor copied, and is expected to be\n- * present until the end of the buffer lifetime.\n- *\n- * returns the new structure.\n- *\/\n-xmlBufPtr\n-xmlBufCreateStatic(void *mem, size_t size) {\n-    xmlBufPtr ret;\n-\n-    if (mem == NULL)\n-        return(NULL);\n-\n-    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));\n-    if (ret == NULL) {\n-        xmlBufMemoryError(NULL, \"creating buffer\");\n-        return(NULL);\n-    }\n-    ret->use = size;\n-    ret->size = size;\n-    UPDATE_COMPAT(ret);\n-    ret->alloc = XML_BUFFER_ALLOC_IMMUTABLE;\n-    ret->content = (xmlChar *) mem;\n-    ret->error = 0;\n-    ret->buffer = NULL;\n-    return(ret);\n-}\n-\n@@ -262,4 +226,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufGetAllocationScheme: buf == NULL\\n\");\n-#endif\n@@ -284,4 +244,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufSetAllocationScheme: buf == NULL or in error\\n\");\n-#endif\n@@ -290,2 +246,1 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||\n-        (buf->alloc == XML_BUFFER_ALLOC_IO))\n+    if (buf->alloc == XML_BUFFER_ALLOC_IO)\n@@ -296,1 +251,0 @@\n-        (scheme == XML_BUFFER_ALLOC_IMMUTABLE) ||\n@@ -324,4 +278,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufFree: buf == NULL\\n\");\n-#endif\n@@ -334,2 +284,1 @@\n-    } else if ((buf->content != NULL) &&\n-        (buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)) {\n+    } else if (buf->content != NULL) {\n@@ -353,3 +302,1 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) {\n-        buf->content = BAD_CAST \"\";\n-    } else if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n@@ -388,2 +335,1 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||\n-        ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL))) {\n+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n@@ -437,1 +383,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);\n@@ -507,1 +452,1 @@\n-    return((int) ret);\n+    return(ret > INT_MAX ? INT_MAX : ret);\n@@ -523,4 +468,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufDump: buf == NULL or in error\\n\");\n-#endif\n@@ -530,4 +471,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufDump: buf->content == NULL\\n\");\n-#endif\n@@ -539,1 +476,1 @@\n-    ret = fwrite(buf->content, sizeof(xmlChar), buf->use, file);\n+    ret = fwrite(buf->content, 1, buf->use, file);\n@@ -702,1 +639,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);\n@@ -780,1 +716,2 @@\n-            rebuf[buf->use] = 0;\n+            if (rebuf != NULL)\n+                rebuf[buf->use] = 0;\n@@ -828,1 +765,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n@@ -830,4 +766,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufAdd: len < 0\\n\");\n-#endif\n@@ -866,1 +798,1 @@\n-    memmove(&buf->content[buf->use], str, len*sizeof(xmlChar));\n+    memmove(&buf->content[buf->use], str, len);\n@@ -888,1 +820,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n@@ -926,2 +857,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)\n-        return(-1);\n@@ -930,4 +859,0 @@\n-#ifdef DEBUG_BUFFER\n-            xmlGenericError(xmlGenericErrorContext,\n- \"xmlBufWriteQuotedString: string contains quote and double-quotes !\\n\");\n-#endif\n@@ -1045,1 +970,1 @@\n-        ret->use = (int) buf->use;\n+        ret->use = buf->use;\n@@ -1048,2 +973,2 @@\n-        ret->use = (int) buf->use;\n-        ret->size = (int) buf->size;\n+        ret->use = buf->use;\n+        ret->size = buf->size;\n@@ -1095,1 +1020,1 @@\n-    if ((input == NULL) || (buf == NULL) || (buf->error))\n+    if (input == NULL)\n@@ -1097,0 +1022,4 @@\n+    if ((buf == NULL) || (buf->error)) {\n+        input->base = input->cur = input->end = BAD_CAST \"\";\n+        return(-1);\n+    }\n@@ -1104,1 +1033,1 @@\n- * xmlBufGetInputBase:\n+ * xmlBufUpdateInput:\n@@ -1107,30 +1036,1 @@\n- *\n- * Get the base of the @input relative to the beginning of the buffer\n- *\n- * Returns the size_t corresponding to the displacement\n- *\/\n-size_t\n-xmlBufGetInputBase(xmlBufPtr buf, xmlParserInputPtr input) {\n-    size_t base;\n-\n-    if ((input == NULL) || (buf == NULL) || (buf->error))\n-        return(-1);\n-    CHECK_COMPAT(buf)\n-    base = input->base - buf->content;\n-    \/*\n-     * We could do some pointer arithmetic checks but that's probably\n-     * sufficient.\n-     *\/\n-    if (base > buf->size) {\n-        xmlBufOverflowError(buf, \"Input reference outside of the buffer\");\n-        base = 0;\n-    }\n-    return(base);\n-}\n-\n-\/**\n- * xmlBufSetInputBaseCur:\n- * @buf: an xmlBufPtr\n- * @input: an xmlParserInputPtr\n- * @base: the base value relative to the beginning of the buffer\n- * @cur: the cur value relative to the beginning of the buffer\n+ * @pos: the cur value relative to the beginning of the buffer\n@@ -1144,2 +1044,1 @@\n-xmlBufSetInputBaseCur(xmlBufPtr buf, xmlParserInputPtr input,\n-                      size_t base, size_t cur) {\n+xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {\n@@ -1148,0 +1047,4 @@\n+    \/*\n+     * TODO: It might be safer to keep using the buffer content if there\n+     * was an error.\n+     *\/\n@@ -1153,2 +1056,2 @@\n-    input->base = &buf->content[base];\n-    input->cur = input->base + cur;\n+    input->base = buf->content;\n+    input->cur = input->base + pos;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/buf.c","additions":31,"deletions":128,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -17,0 +17,2 @@\n+#include <stddef.h>\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/chvalid.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,3 +6,0 @@\n-\/* Type cast for the gethostbyname() argument *\/\n-#undef GETHOSTBYNAME_ARG_CAST\n-\n@@ -12,3 +9,0 @@\n-\/* Define to 1 if you have the <arpa\/nameser.h> header file. *\/\n-#undef HAVE_ARPA_NAMESER_H\n-\n@@ -18,3 +12,0 @@\n-\/* Whether struct sockaddr::__ss_family exists *\/\n-#undef HAVE_BROKEN_SS_FAMILY\n-\n@@ -36,3 +27,0 @@\n-\/* Define if getaddrinfo is there *\/\n-#undef HAVE_GETADDRINFO\n-\n@@ -42,0 +30,3 @@\n+\/* Define to 1 if you have the <glob.h> header file. *\/\n+#undef HAVE_GLOB_H\n+\n@@ -77,1 +68,1 @@\n-\/* Define if <pthread.h> is there *\/\n+\/* Define to 1 if you have the <pthread.h> header file. *\/\n@@ -80,9 +71,0 @@\n-\/* Define to 1 if you have the `putenv' function. *\/\n-#undef HAVE_PUTENV\n-\n-\/* Define to 1 if you have the `rand_r' function. *\/\n-#undef HAVE_RAND_R\n-\n-\/* Define to 1 if you have the <resolv.h> header file. *\/\n-#undef HAVE_RESOLV_H\n-\n@@ -92,3 +74,0 @@\n-\/* Define to 1 if you have the `snprintf' function. *\/\n-#undef HAVE_SNPRINTF\n-\n@@ -140,3 +119,0 @@\n-\/* Define to 1 if you have the `vsnprintf' function. *\/\n-#undef HAVE_VSNPRINTF\n-\n@@ -173,3 +149,0 @@\n-\/* Type cast for the send() function 2nd arg *\/\n-#undef SEND_ARG2_CAST\n-\n@@ -193,0 +166,3 @@\n+\/* TLS specifier *\/\n+#undef XML_THREAD_LOCAL\n+\n@@ -198,3 +174,0 @@\n-\/* ss_family is not defined here, use __ss_family instead *\/\n-#undef ss_family\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/config.h.in","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -5,2 +5,2 @@\n-m4_define([MINOR_VERSION], 10)\n-m4_define([MICRO_VERSION], 4)\n+m4_define([MINOR_VERSION], 12)\n+m4_define([MICRO_VERSION], 6)\n@@ -51,2 +51,0 @@\n-AC_PROG_CPP\n-AC_PATH_PROG(MV, mv, \/bin\/mv)\n@@ -56,1 +54,0 @@\n-AC_PATH_PROG(XMLLINT, xmllint, \/usr\/bin\/xmllint)\n@@ -63,16 +60,0 @@\n-dnl\n-dnl if the system support linker version scripts for symbol versioning\n-dnl then add it\n-dnl\n-VERSION_SCRIPT_FLAGS=\n-# lt_cv_prog_gnu_ld is from libtool 2.+\n-if test \"$lt_cv_prog_gnu_ld\" = yes; then\n-  VERSION_SCRIPT_FLAGS=-Wl,--version-script=\n-else\n-  case $host in\n-  *-*-sunos*) VERSION_SCRIPT_FLAGS=\"-Wl,-M -Wl,\";;\n-  esac\n-fi\n-AC_SUBST(VERSION_SCRIPT_FLAGS)\n-AM_CONDITIONAL([USE_VERSION_SCRIPT], [test -n \"$VERSION_SCRIPT_FLAGS\"])\n-\n@@ -85,6 +66,0 @@\n-dnl\n-dnl zlib option might change flags, so we save them initially\n-dnl\n-_cppflags=\"${CPPFLAGS}\"\n-_libs=\"${LIBS}\"\n-\n@@ -92,1 +67,1 @@\n-[  --with-c14n             add the Canonicalization support (on)])\n+[  --with-c14n             Canonical XML 1.0 support (on)])\n@@ -94,1 +69,1 @@\n-[  --with-catalog          add the Catalog support (on)])\n+[  --with-catalog          XML Catalogs support (on)])\n@@ -96,3 +71,1 @@\n-[  --with-debug            add the debugging module (on)])\n-AC_ARG_WITH(fexceptions,\n-[  --with-fexceptions      add GCC flag -fexceptions for C++ exceptions (off)])\n+[  --with-debug            debugging module and shell (on)])\n@@ -100,1 +73,1 @@\n-[  --with-ftp              add the FTP support (off)])\n+[  --with-ftp              FTP support (off)])\n@@ -102,1 +75,3 @@\n-[  --with-history          add history support to xmllint shell(off)])\n+[  --with-history          history support for shell (off)])\n+AC_ARG_WITH(readline,\n+[  --with-readline[[=DIR]]   use readline in DIR (for shell history)])\n@@ -104,1 +79,1 @@\n-[  --with-html             add the HTML support (on)])\n+[  --with-html             HTML parser (on)])\n@@ -106,1 +81,1 @@\n-[  --with-http             add the HTTP support (on)])\n+[  --with-http             HTTP support (on)])\n@@ -108,1 +83,1 @@\n-[  --with-iconv[[=DIR]]      add ICONV support (on)])\n+[  --with-iconv[[=DIR]]      iconv support (on)])\n@@ -110,1 +85,1 @@\n-[  --with-icu                add ICU support (off)])\n+[  --with-icu              ICU support (off)])\n@@ -112,3 +87,3 @@\n-[  --with-iso8859x         add ISO8859X support if no iconv (on)])\n-AC_ARG_WITH(legacy,\n-[  --with-legacy           add deprecated APIs for compatibility (off)])\n+[  --with-iso8859x         ISO-8859-X support if no iconv (on)])\n+AC_ARG_WITH(lzma,\n+[  --with-lzma[[=DIR]]       use liblzma in DIR (on)])\n@@ -116,3 +91,3 @@\n-[  --with-mem-debug        add the memory debugging module (off)])\n-AC_ARG_WITH(minimum,\n-[  --with-minimum          build a minimally sized library (off)])\n+[  --with-mem-debug        memory debugging module (off)])\n+AC_ARG_WITH(modules,\n+[  --with-modules          dynamic modules support (on)])\n@@ -120,1 +95,1 @@\n-[  --with-output           add the serialization support (on)])\n+[  --with-output           serialization support (on)])\n@@ -122,1 +97,1 @@\n-[  --with-pattern          add the xmlPattern selection interface (on)])\n+[  --with-pattern          xmlPattern selection interface (on)])\n@@ -124,1 +99,1 @@\n-[  --with-push             add the PUSH parser interfaces (on)])\n+[  --with-push             push parser interfaces (on)])\n@@ -126,1 +101,1 @@\n-[  --with-python           build Python bindings (on)])\n+[  --with-python           Python bindings (on)])\n@@ -128,9 +103,1 @@\n-[  --with-reader           add the xmlReader parsing interface (on)])\n-AC_ARG_WITH(readline,\n-[  --with-readline=DIR     use readline in DIR],[\n-  if test \"$withval\" != \"no\" && test \"$withval\" != \"yes\"; then\n-    RDL_DIR=$withval\n-    CPPFLAGS=\"${CPPFLAGS} -I$withval\/include\"\n-    LDFLAGS=\"${LDFLAGS} -L$withval\/lib\"\n-  fi\n-])\n+[  --with-reader           xmlReader parsing interface (on)])\n@@ -138,1 +105,1 @@\n-[  --with-regexps          add Regular Expressions support (on)])\n+[  --with-regexps          regular expressions support (on)])\n@@ -140,1 +107,1 @@\n-[  --with-run-debug        add the runtime debugging module (off)])\n+[  --with-run-debug        runtime debugging module (off)])\n@@ -142,1 +109,1 @@\n-[  --with-sax1             add the older SAX1 interface (on)])\n+[  --with-sax1             older SAX1 interface (on)])\n@@ -144,1 +111,1 @@\n-[  --with-schemas          add Relax-NG and Schemas support (on)])\n+[  --with-schemas          XML Schemas 1.0 and RELAX NG support (on)])\n@@ -146,1 +113,1 @@\n-[  --with-schematron       add Schematron support (on)])\n+[  --with-schematron       Schematron support (on)])\n@@ -148,1 +115,1 @@\n-[  --with-threads          add multithread support(on)])\n+[  --with-threads          multithreading support (on)])\n@@ -150,1 +117,1 @@\n-[  --with-thread-alloc     add per-thread memory(off)])\n+[  --with-thread-alloc     per-thread malloc hooks (off)])\n@@ -152,1 +119,1 @@\n-[  --with-tree             add the DOM like tree manipulation APIs (on)])\n+[  --with-tree             DOM like tree manipulation APIs (on)])\n@@ -154,1 +121,1 @@\n-[  --with-valid            add the DTD validation support (on)])\n+[  --with-valid            DTD validation support (on)])\n@@ -156,1 +123,1 @@\n-[  --with-writer           add the xmlWriter saving interface (on)])\n+[  --with-writer           xmlWriter serialization interface (on)])\n@@ -158,1 +125,1 @@\n-[  --with-xinclude         add the XInclude support (on)])\n+[  --with-xinclude         XInclude 1.0 support (on)])\n@@ -160,1 +127,1 @@\n-[  --with-xpath            add the XPATH support (on)])\n+[  --with-xpath            XPath 1.0 support (on)])\n@@ -162,1 +129,1 @@\n-[  --with-xptr             add the XPointer support (on)])\n+[  --with-xptr             XPointer support (on)])\n@@ -164,3 +131,1 @@\n-[  --with-xptr-locs        add support for XPointer locations (off)])\n-AC_ARG_WITH(modules,\n-[  --with-modules          add the dynamic modules support (on)])\n+[  --with-xptr-locs        XPointer ranges and points (off)])\n@@ -168,15 +133,11 @@\n-[  --with-zlib[[=DIR]]       use libz in DIR],[\n-  if test \"$withval\" != \"no\" && test \"$withval\" != \"yes\"; then\n-    Z_DIR=$withval\n-    CPPFLAGS=\"${CPPFLAGS} -I$withval\/include\"\n-    LDFLAGS=\"${LDFLAGS} -L$withval\/lib\"\n-  fi\n-])\n-AC_ARG_WITH(lzma,\n-[  --with-lzma[[=DIR]]       use liblzma in DIR],[\n-  if test \"$withval\" != \"no\" && test \"$withval\" != \"yes\"; then\n-    LZMA_DIR=$withval\n-    CPPFLAGS=\"${CPPFLAGS} -I$withval\/include\"\n-    LDFLAGS=\"${LDFLAGS} -L$withval\/lib\"\n-  fi\n-])\n+[  --with-zlib[[=DIR]]       use libz in DIR (on)])\n+\n+AC_ARG_WITH(minimum,\n+[  --with-minimum          build a minimally sized library (off)])\n+AC_ARG_WITH(legacy,\n+[  --with-legacy           maximum ABI compatibility (off)])\n+\n+AC_ARG_WITH(tls,\n+[  --with-tls              thread-local storage (on)])\n+AC_ARG_WITH(fexceptions,\n+[  --with-fexceptions      add GCC flag -fexceptions for C++ exceptions (off)])\n@@ -189,69 +150,3 @@\n-if test \"$with_schemas\" = \"yes\"\n-then\n-    with_pattern=yes\n-    with_regexps=yes\n-fi\n-if test \"$with_schematron\" = \"yes\"\n-then\n-    with_pattern=yes\n-    with_tree=yes\n-    with_xpath=yes\n-fi\n-if test \"$with_reader\" = \"yes\"\n-then\n-    with_push=yes\n-fi\n-if test \"$with_xptr_locs\" = \"yes\"\n-then\n-    with_xptr=yes\n-fi\n-if test \"$with_xptr\" = \"yes\"\n-then\n-    with_xpath=yes\n-fi\n-dnl\n-dnl option to build a minimal libxml2 library\n-dnl\n-if test \"$with_minimum\" = \"yes\"\n-then\n-    echo \"Configuring for a minimal library\"\n-    if test \"$with_c14n\" = \"\"\n-    then\n-      with_c14n=no\n-    fi\n-    if test \"$with_catalog\" = \"\"\n-    then\n-      with_catalog=no\n-    fi\n-    echo So far so good!\n-    if test \"$with_debug\" = \"\"\n-    then\n-      with_debug=no\n-    fi\n-    if test \"$with_fexceptions\" = \"\"\n-    then\n-      with_fexceptions=no\n-    fi\n-    if test \"$with_history\" = \"\"\n-    then\n-      with_history=no\n-    fi\n-    if test \"$with_html\" = \"\"\n-    then\n-      with_html=no\n-    fi\n-    if test \"$with_http\" = \"\"\n-    then\n-      with_http=no \n-    fi\n-    if test \"$with_iconv\" = \"\"\n-    then\n-      with_iconv=no\n-    fi\n-    if test \"$with_iso8859x\" = \"\"\n-    then\n-      with_iso8859x=no\n-    fi\n-    if test \"$with_mem_debug\" = \"\"\n-    then \n-      with_mem_debug=no\n+if test \"$with_c14n\" = \"yes\"; then\n+    if test \"$with_output\" = \"no\"; then\n+        echo WARNING: --with-c14n overrides --without-output\n@@ -259,31 +154,3 @@\n-    if test \"$with_output\" = \"\"\n-    then\n-      with_output=no\n-    fi\n-    if test \"$with_pattern\" = \"\"\n-    then\n-      with_pattern=no\n-    fi\n-    if test \"$with_push\" = \"\"\n-    then\n-      with_push=no\n-    fi\n-    if test \"$with_python\" = \"\"\n-    then\n-      with_python=no\n-    fi\n-    if test \"$with_reader\" = \"\"\n-    then\n-      with_reader=no\n-    fi\n-    if test \"$with_readline\" = \"\"\n-    then\n-      with_readline=no\n-    fi\n-    if test \"$with_regexps\" = \"\"\n-    then\n-      with_regexps=no\n-    fi\n-    if test \"$with_run_debug\" = \"\"\n-    then\n-      with_run_debug=no\n+    with_output=yes\n+    if test \"$with_xpath\" = \"no\"; then\n+        echo WARNING: --with-c14n overrides --without-xpath\n@@ -291,3 +158,5 @@\n-    if test \"$with_sax1\" = \"\"\n-    then\n-      with_sax1=no\n+    with_xpath=yes\n+fi\n+if test \"$with_schemas\" = \"yes\"; then\n+    if test \"$with_pattern\" = \"no\"; then\n+        echo WARNING: --with-schemas overrides --without-pattern\n@@ -295,3 +164,3 @@\n-    if test \"$with_schemas\" = \"\"\n-    then\n-      with_schemas=no\n+    with_pattern=yes\n+    if test \"$with_regexps\" = \"no\"; then\n+        echo WARNING: --with-schemas overrides --without-regexps\n@@ -299,3 +168,5 @@\n-    if test \"$with_schematron\" = \"\"\n-    then\n-      with_schematron=no\n+    with_regexps=yes\n+fi\n+if test \"$with_schematron\" = \"yes\"; then\n+    if test \"$with_pattern\" = \"no\"; then\n+        echo WARNING: --with-schematron overrides --without-pattern\n@@ -303,3 +174,3 @@\n-    if test \"$with_threads\" = \"\"\n-    then\n-      with_threads=no\n+    with_pattern=yes\n+    if test \"$with_tree\" = \"no\"; then\n+        echo WARNING: --with-schematron overrides --without-tree\n@@ -307,7 +178,3 @@\n-    if test \"$with_thread_alloc\" = \"\"\n-    then\n-      with_thread_alloc=no\n-   fi\n-    if test \"$with_tree\" = \"\"\n-    then\n-      with_tree=no\n+    with_tree=yes\n+    if test \"$with_xpath\" = \"no\"; then\n+        echo WARNING: --with-schematron overrides --without-xpath\n@@ -315,3 +182,5 @@\n-    if test \"$with_valid\" = \"\"\n-    then\n-      with_valid=no\n+    with_xpath=yes\n+fi\n+if test \"$with_reader\" = \"yes\"; then\n+    if test \"$with_push\" = \"no\"; then\n+        echo WARNING: --with-reader overrides --without-push\n@@ -319,3 +188,3 @@\n-    if test \"$with_writer\" = \"\"\n-    then\n-      with_writer=no\n+    with_push=yes\n+    if test \"$with_tree\" = \"no\"; then\n+        echo WARNING: --with-reader overrides --without-tree\n@@ -323,3 +192,5 @@\n-    if test \"$with_xinclude\" = \"\"\n-    then\n-      with_xinclude=no\n+    with_tree=yes\n+fi\n+if test \"$with_writer\" = \"yes\"; then\n+    if test \"$with_output\" = \"no\"; then\n+        echo WARNING: --with-writer overrides --without-output\n@@ -327,3 +198,3 @@\n-    if test \"$with_xpath\" = \"\"\n-    then\n-      with_xpath=no\n+    with_output=yes\n+    if test \"$with_push\" = \"no\"; then\n+        echo WARNING: --with-writer overrides --without-push\n@@ -331,3 +202,5 @@\n-    if test \"$with_xptr\" = \"\"\n-    then\n-      with_xptr=no\n+    with_push=yes\n+fi\n+if test \"$with_xinclude\" = \"yes\"; then\n+    if test \"$with_xpath\" = \"no\"; then\n+        echo WARNING: --with-xinclude overrides --without-xpath\n@@ -335,3 +208,5 @@\n-    if test \"$with_zlib\" = \"\"\n-    then\n-      with_zlib=no\n+    with_xpath=yes\n+fi\n+if test \"$with_xptr_locs\" = \"yes\"; then\n+    if test \"$with_xptr\" = \"no\"; then\n+        echo WARNING: --with-xptr-locs overrides --without-xptr\n@@ -339,3 +214,5 @@\n-    if test \"$with_modules\" = \"\"\n-    then\n-      with_modules=no\n+    with_xptr=yes\n+fi\n+if test \"$with_xptr\" = \"yes\"; then\n+    if test \"$with_xpath\" = \"no\"; then\n+        echo WARNING: --with-xptr overrides --without-xpath\n@@ -343,0 +220,1 @@\n+    with_xpath=yes\n@@ -345,7 +223,37 @@\n-echo Checking zlib\n-\n-dnl Checks for zlib library.\n-\n-WITH_ZLIB=0\n-if test \"$with_zlib\" = \"no\"; then\n-    echo \"Disabling zlib compression support\"\n+if test \"$with_minimum\" = \"yes\"; then\n+    dnl\n+    dnl option to build a minimal libxml2 library\n+    dnl\n+    echo \"Configuring for a minimal library\"\n+    test \"$with_c14n\" = \"\" && with_c14n=no\n+    test \"$with_catalog\" = \"\" && with_catalog=no\n+    test \"$with_debug\" = \"\" && with_debug=no\n+    test \"$with_fexceptions\" = \"\" && with_fexceptions=no\n+    test \"$with_history\" = \"\" && with_history=no\n+    test \"$with_html\" = \"\" && with_html=no\n+    test \"$with_http\" = \"\" && with_http=no\n+    test \"$with_iconv\" = \"\" && with_iconv=no\n+    test \"$with_iso8859x\" = \"\" && with_iso8859x=no\n+    test \"$with_lzma\" = \"\" && with_lzma=no\n+    test \"$with_mem_debug\" = \"\" && with_mem_debug=no\n+    test \"$with_output\" = \"\" && with_output=no\n+    test \"$with_pattern\" = \"\" && with_pattern=no\n+    test \"$with_push\" = \"\" && with_push=no\n+    test \"$with_python\" = \"\" && with_python=no\n+    test \"$with_reader\" = \"\" && with_reader=no\n+    test \"$with_readline\" = \"\" && with_readline=no\n+    test \"$with_regexps\" = \"\" && with_regexps=no\n+    test \"$with_run_debug\" = \"\" && with_run_debug=no\n+    test \"$with_sax1\" = \"\" && with_sax1=no\n+    test \"$with_schemas\" = \"\" && with_schemas=no\n+    test \"$with_schematron\" = \"\" && with_schematron=no\n+    test \"$with_threads\" = \"\" && with_threads=no\n+    test \"$with_thread_alloc\" = \"\" && with_thread_alloc=no\n+    test \"$with_tree\" = \"\" && with_tree=no\n+    test \"$with_valid\" = \"\" && with_valid=no\n+    test \"$with_writer\" = \"\" && with_writer=no\n+    test \"$with_xinclude\" = \"\" && with_xinclude=no\n+    test \"$with_xpath\" = \"\" && with_xpath=no\n+    test \"$with_xptr\" = \"\" && with_xptr=no\n+    test \"$with_zlib\" = \"\" && with_zlib=no\n+    test \"$with_modules\" = \"\" && with_modules=no\n@@ -353,6 +261,6 @@\n-    # Don't run pkg-config if with_zlib contains a path.\n-    if test \"x$Z_DIR\" = \"x\"; then\n-        # Try pkg-config first so that static linking works.\n-        PKG_CHECK_MODULES([Z],[zlib],\n-            [WITH_ZLIB=1],\n-            [:])\n+    dnl\n+    dnl Disable dependent modules\n+    dnl\n+    if test \"$with_output\" = \"no\"; then\n+        with_c14n=no\n+        with_writer=no\n@@ -360,17 +268,3 @@\n-\n-    if test \"$WITH_ZLIB\" = \"0\"; then\n-        AC_CHECK_HEADERS(zlib.h,\n-            AC_CHECK_LIB(z, gzread,[\n-                WITH_ZLIB=1\n-                if test \"x${Z_DIR}\" != \"x\"; then\n-                    Z_CFLAGS=\"-I${Z_DIR}\/include\"\n-                    Z_LIBS=\"-L${Z_DIR}\/lib -lz\"\n-                    [case ${host} in\n-                        *-*-solaris*)\n-                            Z_LIBS=\"-L${Z_DIR}\/lib -R${Z_DIR}\/lib -lz\"\n-                            ;;\n-                    esac]\n-                else\n-                    Z_LIBS=\"-lz\"\n-                fi])\n-            )\n+    if test \"$with_pattern\" = \"no\"; then\n+        with_schemas=no\n+        with_schematron=no\n@@ -378,20 +272,3 @@\n-fi\n-\n-AC_SUBST(Z_CFLAGS)\n-AC_SUBST(Z_LIBS)\n-AC_SUBST(WITH_ZLIB)\n-\n-echo Checking lzma\n-\n-dnl Checks for lzma library.\n-\n-WITH_LZMA=0\n-if test \"$with_lzma\" = \"no\"; then\n-    echo \"Disabling lzma compression support\"\n-else\n-    # Don't run pkg-config if with_lzma contains a path.\n-    if test \"x$LZMA_DIR\" = \"x\"; then\n-        # Try pkg-config first so that static linking works.\n-        PKG_CHECK_MODULES([LZMA],[liblzma],\n-            [WITH_LZMA=1],\n-            [:])\n+    if test \"$with_push\" = \"no\"; then\n+        with_reader=no\n+        with_writer=no\n@@ -399,15 +276,12 @@\n-\n-    # If pkg-config failed, fall back to AC_CHECK_LIB. This\n-    # will not pick up the necessary LIBS flags for liblzma's\n-    # private dependencies, though, so static linking may fail.\n-    if test \"$WITH_LZMA\" = \"0\"; then\n-        AC_CHECK_HEADERS(lzma.h,\n-            AC_CHECK_LIB(lzma, lzma_code,[\n-                WITH_LZMA=1\n-                if test \"x${LZMA_DIR}\" != \"x\"; then\n-                    LZMA_CFLAGS=\"-I${LZMA_DIR}\/include\"\n-                    LZMA_LIBS=\"-L${LZMA_DIR}\/lib -llzma\"\n-                else\n-                    LZMA_LIBS=\"-llzma\"\n-                fi])\n-            )\n+    if test \"$with_regexps\" = \"no\"; then\n+        with_schemas=no\n+    fi\n+    if test \"$with_tree\" = \"no\"; then\n+        with_reader=no\n+        with_schematron=no\n+    fi\n+    if test \"$with_xpath\" = \"no\"; then\n+        with_c14n=no\n+        with_schematron=no\n+        with_xinclude=no\n+        with_xptr=no\n@@ -417,8 +291,4 @@\n-AC_SUBST(LZMA_CFLAGS)\n-AC_SUBST(LZMA_LIBS)\n-AC_SUBST(WITH_LZMA)\n-\n-CPPFLAGS=${_cppflags}\n-LIBS=${_libs}\n-\n-echo Checking headers\n+XML_PRIVATE_LIBS=\n+XML_PRIVATE_CFLAGS=\n+XML_PC_LIBS=\n+XML_PC_REQUIRES=\n@@ -426,0 +296,1 @@\n+dnl\n@@ -427,28 +298,3 @@\n-AC_CHECK_HEADERS([fcntl.h])\n-AC_CHECK_HEADERS([unistd.h])\n-AC_CHECK_HEADERS([sys\/stat.h])\n-AC_CHECK_HEADERS([sys\/types.h])\n-AC_CHECK_HEADERS([stdint.h])\n-AC_CHECK_HEADERS([inttypes.h])\n-AC_CHECK_HEADERS([sys\/socket.h], [], [],\n-[#if HAVE_SYS_TYPES_H\n-# include <sys\/types.h>\n-# endif\n-])\n-AC_CHECK_HEADERS([netinet\/in.h], [], [],\n-[#if HAVE_SYS_TYPES_H\n-# include <sys\/types.h>\n-# endif\n-])\n-AC_CHECK_HEADERS([arpa\/inet.h], [], [],\n-[#if HAVE_SYS_TYPES_H\n-# include <sys\/types.h>\n-# endif\n-#if HAVE_ARPA_INET_H\n-# include <arpa\/inet.h>\n-# endif\n-])\n-AC_CHECK_HEADERS([netdb.h])\n-AC_CHECK_HEADERS([sys\/time.h])\n-AC_CHECK_HEADERS([sys\/select.h])\n-AC_CHECK_HEADERS([poll.h])\n+dnl\n+AC_CHECK_HEADERS([stdint.h inttypes.h])\n+AC_CHECK_HEADERS([fcntl.h unistd.h sys\/stat.h])\n@@ -456,22 +302,6 @@\n-AC_CHECK_HEADERS([sys\/timeb.h])\n-AC_CHECK_HEADERS([arpa\/nameser.h], [], [],\n-[#if HAVE_SYS_TYPES_H\n-# include <sys\/types.h>\n-# endif\n-])\n-AC_CHECK_HEADERS([resolv.h], [], [],\n-[#if HAVE_SYS_TYPES_H\n-# include <sys\/types.h>\n-# endif\n-#if HAVE_NETINET_IN_H\n-# include <netinet\/in.h>\n-# endif\n-#if HAVE_ARPA_NAMESER_H\n-# include <arpa\/nameser.h>\n-# endif\n-])\n-AC_CHECK_HEADERS([dl.h])\n-AC_CHECK_HEADERS([dlfcn.h])\n-\n-\n-echo Checking types\n+AC_CHECK_HEADERS([sys\/socket.h netinet\/in.h arpa\/inet.h netdb.h])\n+AC_CHECK_HEADERS([sys\/select.h poll.h])\n+AC_CHECK_HEADERS([sys\/time.h sys\/timeb.h])\n+AC_CHECK_HEADERS([dl.h dlfcn.h])\n+AC_CHECK_HEADERS([glob.h])\n+AM_CONDITIONAL(WITH_GLOB, test \"$ac_cv_header_glob_h\" = \"yes\")\n@@ -479,0 +309,3 @@\n+dnl\n+dnl Checking types\n+dnl\n@@ -481,3 +314,0 @@\n-\n-echo Checking libraries\n-\n@@ -485,4 +315,1 @@\n-AC_CHECK_FUNCS(gettimeofday ftime)\n-AC_CHECK_FUNCS(stat)\n-AC_CHECK_FUNCS(rand_r)\n-AC_CHECK_FUNCS(isascii mmap munmap putenv)\n+AC_CHECK_FUNCS([gettimeofday ftime stat isascii mmap munmap])\n@@ -526,4 +353,23 @@\n-dnl Checks for inet libraries:\n-AC_SEARCH_LIBS(gethostent, [nsl])\n-AC_SEARCH_LIBS(setsockopt, [socket net network])\n-AC_SEARCH_LIBS(connect, [inet])\n+dnl\n+dnl Checks for inet libraries\n+dnl\n+if test \"$with_http\" != \"no\" || test \"with_ftp\" = \"yes\"; then\n+    case \"$host\" in\n+        *-*-mingw*)\n+            dnl AC_SEARCH_LIBS doesn't work because of non-standard calling\n+            dnl conventions on 32-bit Windows.\n+            NET_LIBS=\"$NET_LIBS -lws2_32\"\n+            ;;\n+        *)\n+            _libs=$LIBS\n+            AC_SEARCH_LIBS(gethostbyname, [nsl], [\n+                if test \"$ac_cv_search_gethostbyname\" != \"none required\"; then\n+                    NET_LIBS=\"$NET_LIBS $ac_cv_search_gethostbyname\"\n+                fi], [:], [$NET_LIBS])\n+            AC_SEARCH_LIBS(connect, [bsd socket inet], [\n+                if test \"$ac_cv_search_connect\" != \"none required\"; then\n+                    NET_LIBS=\"$NET_LIBS $ac_cv_search_connect\"\n+                fi], [:], [$NET_LIBS])\n+            LIBS=$_libs\n+            ;;\n+    esac\n@@ -531,16 +377,2 @@\n-dnl Determine what socket length (socklen_t) data type is\n-AC_MSG_CHECKING([for type of socket length (socklen_t)])\n-AC_TRY_COMPILE2([\n-#include <stddef.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>],[\n-(void)getsockopt (1, 1, 1, NULL, (socklen_t *)NULL)],[\n-  AC_MSG_RESULT(socklen_t *)\n-  XML_SOCKLEN_T=socklen_t],[\n-  AC_TRY_COMPILE2([\n-#include <stddef.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>],[\n-(void)getsockopt (1, 1, 1, NULL, (size_t *)NULL)],[\n-    AC_MSG_RESULT(size_t *)\n-    XML_SOCKLEN_T=size_t],[\n+    dnl Determine what socket length (socklen_t) data type is\n+    AC_MSG_CHECKING([for type of socket length (socklen_t)])\n@@ -548,23 +380,54 @@\n-#include <stddef.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>],[\n-(void)getsockopt (1, 1, 1, NULL, (int *)NULL)],[\n-      AC_MSG_RESULT(int *)\n-      XML_SOCKLEN_T=int],[\n-      AC_MSG_WARN(could not determine)\n-      XML_SOCKLEN_T=\"int\"])])])\n-AC_DEFINE_UNQUOTED(XML_SOCKLEN_T, $XML_SOCKLEN_T, [Determine what socket length (socklen_t) data type is])\n-\n-dnl Checking if gethostbyname() argument is const.\n-AC_MSG_CHECKING([for const gethostbyname() argument])\n-AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <netdb.h>]],\n-    [[(void)gethostbyname((const char *)\"\");]])],\n-have_gethostbyname_const_arg=yes,\n-have_gethostbyname_const_arg=no)\n-AC_MSG_RESULT($have_gethostbyname_const_arg)\n-if test x\"$have_gethostbyname_const_arg\" = x\"yes\"; then\n-    AC_DEFINE([GETHOSTBYNAME_ARG_CAST], [],\n-      [Type cast for the gethostbyname() argument])\n-else\n-    AC_DEFINE([GETHOSTBYNAME_ARG_CAST], [(char *)],\n-      [Type cast for the gethostbyname() argument])\n+    #include <stddef.h>\n+    #ifdef _WIN32\n+      #include <ws2tcpip.h>\n+    #else\n+      #include <sys\/socket.h>\n+    #endif],[\n+    (void)getsockopt (1, 1, 1, NULL, (socklen_t *)NULL)],[\n+      AC_MSG_RESULT(socklen_t *)\n+      XML_SOCKLEN_T=socklen_t],[\n+      AC_TRY_COMPILE2([\n+    #include <stddef.h>\n+    #include <sys\/socket.h>],[\n+    (void)getsockopt (1, 1, 1, NULL, (size_t *)NULL)],[\n+        AC_MSG_RESULT(size_t *)\n+        XML_SOCKLEN_T=size_t],[\n+        AC_TRY_COMPILE2([\n+    #include <stddef.h>\n+    #include <sys\/socket.h>],[\n+    (void)getsockopt (1, 1, 1, NULL, (int *)NULL)],[\n+          AC_MSG_RESULT(int *)\n+          XML_SOCKLEN_T=int],[\n+          AC_MSG_WARN(could not determine)\n+          XML_SOCKLEN_T=\"int\"])])])\n+    AC_DEFINE_UNQUOTED(XML_SOCKLEN_T, $XML_SOCKLEN_T, [Determine what socket length (socklen_t) data type is])\n+\n+    dnl\n+    dnl Checking for availability of IPv6\n+    dnl\n+    AC_ARG_ENABLE(ipv6, [  --enable-ipv6[[=yes\/no]]  enables compilation of IPv6 code [[default=yes]]],, enable_ipv6=yes)\n+    if test \"$with_minimum\" = \"yes\"\n+    then\n+        enable_ipv6=no\n+    fi\n+    if test $enable_ipv6 = yes; then\n+        AC_MSG_CHECKING([whether to enable IPv6])\n+        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+            #ifdef _WIN32\n+              #include <winsock2.h>\n+            #else\n+              #include <sys\/socket.h>\n+              #ifdef HAVE_NETDB_H\n+                #include <netdb.h>\n+              #endif\n+            #endif\n+            ]], [[\n+            struct sockaddr_storage ss;\n+            socket(AF_INET6, SOCK_STREAM, 0);\n+            getaddrinfo(0, 0, 0, 0);\n+            ]])], [\n+            AC_DEFINE([SUPPORT_IP6], [], [Support for IPv6])\n+            AC_MSG_RESULT([yes])], [\n+            AC_MSG_RESULT([no])]\n+        )\n+    fi\n@@ -573,14 +436,19 @@\n-dnl Checking if send() second argument is const.\n-AC_MSG_CHECKING([for const send() second argument])\n-AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <sys\/types.h>\n-#include <sys\/socket.h>]],\n-    [[(void)send(1,(const char *)\"\",1,1);]])],\n-have_send_const_arg2=yes,\n-have_send_const_arg2=no)\n-AC_MSG_RESULT($have_send_const_arg2)\n-if test x\"$have_send_const_arg2\" = x\"yes\"; then\n-    AC_DEFINE([SEND_ARG2_CAST], [],\n-      [Type cast for the send() function 2nd arg])\n-else\n-    AC_DEFINE([SEND_ARG2_CAST], [(char *)],\n-      [Type cast for the send() function 2nd arg])\n+dnl\n+dnl Extra flags\n+dnl\n+XML_LIBDIR='-L${libdir}'\n+XML_INCLUDEDIR='-I${includedir}\/libxml2'\n+XML_CFLAGS=\"\"\n+\n+dnl Thread-local storage\n+if test \"$with_tls\" = \"yes\"; then\n+    AC_COMPILE_IFELSE([\n+        AC_LANG_SOURCE([_Thread_local int v;]) ], [\n+        AC_DEFINE([XML_THREAD_LOCAL], [_Thread_local], [TLS specifier]) ], [\n+    AC_COMPILE_IFELSE([\n+        AC_LANG_SOURCE([__thread int v;]) ], [\n+        AC_DEFINE([XML_THREAD_LOCAL], [__thread], [TLS specifier]) ], [\n+    AC_COMPILE_IFELSE([\n+        AC_LANG_SOURCE([__declspec(thread) int v;]) ], [\n+        AC_DEFINE([XML_THREAD_LOCAL], [__declspec(thread)], [TLS specifier]) ], [\n+    WARN_NO_TLS=1 ])])])\n@@ -599,88 +467,0 @@\n-\n-dnl ***********************Checking for availability of IPv6*******************\n-\n-AC_MSG_CHECKING([whether to enable IPv6])\n-AC_ARG_ENABLE(ipv6, [  --enable-ipv6[[=yes\/no]]  enables compilation of IPv6 code [[default=yes]]],, enable_ipv6=yes)\n-if test \"$with_minimum\" = \"yes\"\n-then\n-    enable_ipv6=no\n-fi\n-if test $enable_ipv6 = yes; then\n-  have_ipv6=no\n-  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-#   include <sys\/types.h>\n-#   include <sys\/socket.h>\n-    ]], [[\n-    struct sockaddr_storage ss;\n-    socket(AF_INET6, SOCK_STREAM, 0)\n-    ]])],\n-    have_ipv6=yes,\n-    have_ipv6=no\n-  )\n-  AC_MSG_RESULT($have_ipv6)\n-\n-  if test $have_ipv6 = yes; then\n-    AC_DEFINE([SUPPORT_IP6], [], [Support for IPv6])\n-    have_broken_ss_family=no\n-\n-    dnl *********************************************************************\n-    dnl on some platforms (like AIX 5L), the structure sockaddr doesn't have\n-    dnl a ss_family member, but rather __ss_family. Let's detect that\n-    dnl and define the HAVE_BROKEN_SS_FAMILY when we are on one of these\n-    dnl platforms.  However, we should only do this if ss_family is not\n-    dnl present.\n-    dnl ********************************************************************\n-    AC_MSG_CHECKING([struct sockaddr::ss_family])\n-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-#     include <sys\/types.h>\n-#     include <sys\/socket.h>\n-      ]], [[\n-      struct sockaddr_storage ss ;\n-      ss.ss_family = 0 ;\n-      ]])],\n-      have_ss_family=yes,\n-      have_ss_family=no\n-    )\n-    AC_MSG_RESULT($have_ss_family)\n-    if test x$have_ss_family = xno ; then\n-      AC_MSG_CHECKING([broken struct sockaddr::ss_family])\n-      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n-#       include <sys\/types.h>\n-#       include <sys\/socket.h>\n-        ]], [[\n-        struct sockaddr_storage ss ;\n-        ss.__ss_family = 0 ;\n-        ]])],\n-        have_broken_ss_family=yes,\n-        have_broken_ss_family=no\n-      )\n-      AC_MSG_RESULT($have_broken_ss_family)\n-      if test x$have_broken_ss_family = xyes ; then\n-        AC_DEFINE(HAVE_BROKEN_SS_FAMILY, [],\n-\t  [Whether struct sockaddr::__ss_family exists]) \n-        AC_DEFINE(ss_family, __ss_family,\n-\t  [ss_family is not defined here, use __ss_family instead])\n-      else\n-        AC_MSG_WARN(ss_family and __ss_family not found)\n-      fi\n-    fi\n-\n-    have_getaddrinfo=no\n-    AC_CHECK_FUNC(getaddrinfo, have_getaddrinfo=yes)\n-    if test $have_getaddrinfo != yes; then\n-      for lib in bsd socket inet; do\n-        AC_CHECK_LIB($lib, getaddrinfo, [LIBS=\"$LIBS -l$lib\";have_getaddrinfo=yes;break])\n-      done\n-    fi\n-\n-    if test $have_getaddrinfo = yes; then\n-      AC_DEFINE([HAVE_GETADDRINFO], [], [Define if getaddrinfo is there])\n-    fi\n-  fi\n-fi \n-\n-dnl ******************************End IPv6 checks******************************\n-\n-XML_LIBDIR='-L${libdir}'\n-XML_INCLUDEDIR='-I${includedir}\/libxml2'\n-\n@@ -688,1 +468,1 @@\n-dnl Extra flags\n+dnl Linker version scripts for symbol versioning\n@@ -690,2 +470,20 @@\n-XML_CFLAGS=\"\"\n-RDL_LIBS=\"\"\n+VERSION_SCRIPT_FLAGS=\n+# lt_cv_prog_gnu_ld is from libtool 2.+\n+if test \"$lt_cv_prog_gnu_ld\" = yes; then\n+  case $host in\n+    *-*-cygwin* | *-*-mingw* | *-*-msys* )\n+      ;;\n+    *)\n+      dnl lld 16 defaults to --no-undefined-version but the version script\n+      dnl can contain symbols disabled by configuration options.\n+      AX_APPEND_LINK_FLAGS([-Wl,--undefined-version], [VERSION_SCRIPT_FLAGS])\n+      AX_APPEND_FLAG([-Wl,--version-script=], [VERSION_SCRIPT_FLAGS])\n+      ;;\n+  esac\n+else\n+  case $host in\n+  *-*-sunos*) VERSION_SCRIPT_FLAGS=\"-Wl,-M -Wl,\";;\n+  esac\n+fi\n+AC_SUBST(VERSION_SCRIPT_FLAGS)\n+AM_CONDITIONAL([USE_VERSION_SCRIPT], [test -n \"$VERSION_SCRIPT_FLAGS\"])\n@@ -701,1 +499,1 @@\n-\t       EXTRA_CFLAGS=\"${EXTRA_CFLAGS} -Wp,-H30000\"\n+\t       AM_CFLAGS=\"${AM_CFLAGS} -Wp,-H30000\"\n@@ -704,1 +502,1 @@\n-               EXTRA_CFLAGS=\"${EXTRA_CFLAGS} -ieee\"\n+               AM_CFLAGS=\"${AM_CFLAGS} -ieee\"\n@@ -707,1 +505,1 @@\n-\t       EXTRA_CFLAGS=\"${EXTRA_CFLAGS} -ieee\"\n+\t       AM_CFLAGS=\"${AM_CFLAGS} -ieee\"\n@@ -717,1 +515,1 @@\n-\tEXTRA_CFLAGS=\"${EXTRA_CFLAGS} -fexceptions\"\n+\tAM_CFLAGS=\"${AM_CFLAGS} -fexceptions\"\n@@ -721,1 +519,1 @@\n-    EXTRA_CFLAGS=\"${EXTRA_CFLAGS} -pedantic -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wredundant-decls\"\n+    AM_CFLAGS=\"${AM_CFLAGS} -pedantic -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes\"\n@@ -723,1 +521,1 @@\n-    EXTRA_CFLAGS=\"${EXTRA_CFLAGS} -Wno-long-long -Wno-format-extra-args\"\n+    AM_CFLAGS=\"${AM_CFLAGS} -Wno-long-long -Wno-format-extra-args\"\n@@ -726,1 +524,1 @@\n-\t       EXTRA_CFLAGS=\"${EXTRA_CFLAGS} -mieee\"\n+\t       AM_CFLAGS=\"${AM_CFLAGS} -mieee\"\n@@ -729,1 +527,1 @@\n-\t       EXTRA_CFLAGS=\"${EXTRA_CFLAGS} -mieee\"\n+\t       AM_CFLAGS=\"${AM_CFLAGS} -mieee\"\n@@ -740,1 +538,1 @@\n-    *-*-mingw* | *-*-cygwin* | *-*-msvc* )\n+    *-*-cygwin* | *-*-mingw* | *-*-msys* )\n@@ -742,1 +540,1 @@\n-        # need to add -DLIBXML_STATIC to EXTRA_CFLAGS in order for linking to\n+        # need to add -DLIBXML_STATIC to AM_CFLAGS in order for linking to\n@@ -748,1 +546,1 @@\n-            EXTRA_CFLAGS=\"$EXTRA_CFLAGS -DLIBXML_STATIC\"\n+            AM_CFLAGS=\"$AM_CFLAGS -DLIBXML_STATIC\"\n@@ -755,1 +553,1 @@\n-dnl check for python\n+dnl Simple API modules\n@@ -758,189 +556,0 @@\n-PYTHON_TESTS=\n-AS_IF([test \"x$with_python\" != \"xno\"], [\n-    AM_PATH_PYTHON\n-    PKG_CHECK_MODULES([PYTHON], [python-${PYTHON_VERSION}])\n-])\n-AM_CONDITIONAL([WITH_PYTHON], [test \"x$with_python\" != \"xno\"])\n-\n-dnl check for dso support\n-WITH_MODULES=0\n-\n-if test \"$with_modules\" != \"no\" ; then\n- case \"$host\" in\n-  *-*-cygwin*)\n-  MODULE_EXTENSION=\".dll\"\n-  AC_CHECK_LIB(cygwin, dlopen, [\n-    WITH_MODULES=1\n-    MODULE_PLATFORM_LIBS=\n-    AC_DEFINE([HAVE_DLOPEN], [], [Have dlopen based dso])\n-  ])\n-  ;;\n-  *-*-mingw*)\n-  MODULE_EXTENSION=\".dll\"\n-  WITH_MODULES=1\n-  ;;\n-  *)\n-  AC_CHECK_FUNC(shl_load, libxml_have_shl_load=yes, [\n-    AC_CHECK_LIB(dld, shl_load, [\n-      MODULE_PLATFORM_LIBS=\"-ldld\"\n-      libxml_have_shl_load=yes], [\n-      AC_CHECK_FUNC(dlopen, libxml_have_dlopen=yes, [\n-        AC_CHECK_LIB(dl, dlopen, [\n-          MODULE_PLATFORM_LIBS=\"-ldl\"\n-          libxml_have_dlopen=yes])])])])\n-\n-  if test \"${libxml_have_shl_load}\" = \"yes\"; then\n-    MODULE_EXTENSION=\".sl\"\n-    WITH_MODULES=1\n-    AC_DEFINE([HAVE_SHLLOAD], [], [Have shl_load based dso])\n-  fi\n- \n-  if test \"${libxml_have_dlopen}\" = \"yes\"; then\n-    case \"${host}\" in\n-      *-*-hpux* )\n-\tMODULE_EXTENSION=\".sl\"\n-\t;;\n-      * )\n-\tMODULE_EXTENSION=\".so\"\n-\t;;\n-    esac\n-\n-    WITH_MODULES=1\n-    AC_DEFINE([HAVE_DLOPEN], [], [Have dlopen based dso])\n-  fi\n- ;;\n- esac\n-fi\n-\n-AC_SUBST(WITH_MODULES)\n-AC_SUBST(MODULE_PLATFORM_LIBS)\n-AC_SUBST(MODULE_EXTENSION)\n-\n-dnl\n-dnl Check for trio string functions\n-dnl\n-\n-if test \"${NEED_TRIO}\" = \"1\" ; then\n-    echo Adding trio library for string functions\n-    WITH_TRIO=1\n-else    \n-    WITH_TRIO=0\n-fi\n-AM_CONDITIONAL(WITH_TRIO_SOURCES, test \"${NEED_TRIO}\" = \"1\")\n-AC_SUBST(WITH_TRIO)\n-\n-dnl\n-dnl Allow to enable\/disable various pieces\n-dnl\n-echo Checking configuration requirements\n-\n-dnl\n-dnl Thread-related stuff\n-dnl\n-THREAD_LIBS=\"\"\n-BASE_THREAD_LIBS=\"\"\n-WITH_THREADS=0\n-THREAD_CFLAGS=\"\"\n-THREADS_W32=\"\"\n-WITH_THREAD_ALLOC=0\n-\n-if test \"$with_threads\" = \"no\" ; then\n-    echo Disabling multithreaded support\n-else\n-    echo Enabling multithreaded support\n-\n-    dnl Default to native threads on Windows\n-    case $host_os in\n-       *mingw*) if test \"$with_threads\" != \"pthread\" && test \"$with_threads\" != \"no\"; then\n-               WITH_THREADS=\"1\"\n-               THREADS_W32=\"1\"\n-               THREAD_CFLAGS=\"$THREAD_CFLAGS -DHAVE_WIN32_THREADS\"\n-           fi\n-       ;;\n-    esac\n-\n-    dnl Use pthread by default in other cases\n-    if test -z \"$THREADS_W32\"; then\n-        if test \"$with_threads\" = \"pthread\" || test \"$with_threads\" = \"\" || test \"$with_threads\" = \"yes\" ; then\n-            AC_CHECK_HEADER(pthread.h,\n-                AC_CHECK_LIB(pthread, pthread_join,[\n-                THREAD_LIBS=\"-lpthread\"\n-                AC_DEFINE([HAVE_PTHREAD_H], [], [Define if <pthread.h> is there])\n-                WITH_THREADS=\"1\"]))\n-        fi\n-    fi\n-\n-    case $host_os in\n-       *cygwin*) THREAD_LIBS=\"\"\n-       ;;\n-       *beos*) WITH_THREADS=\"1\"\n-\t   THREAD_CFLAGS=\"$THREAD_CFLAGS -DHAVE_BEOS_THREADS\"\n-       ;;\n-       *linux*)\n-           if test \"${GCC}\" = \"yes\" ; then\n-\t       GCC_VERSION=`${CC} --version | head -1 | awk '{print $3}'`\n-\t       GCC_MAJOR=`echo ${GCC_VERSION} | sed 's+\\..*++'`\n-\t       GCC_MEDIUM=`echo ${GCC_VERSION} | sed 's+[[0-9]]*\\.++' | sed 's+\\..*++'`\n-\t       if test \"${THREAD_LIBS}\" = \"-lpthread\" ; then\n-\t           if expr ${GCC_MEDIUM} \\> 2 \\& ${GCC_MAJOR} = 3 > \/dev\/null\n-\t\t   then\n-\t\t       THREAD_LIBS=\"\"\n-\t\t       BASE_THREAD_LIBS=\"-lpthread\"\n-\t\t   else\n-\t\t   if expr ${GCC_MAJOR} \\> 3 > \/dev\/null\n-\t\t   then\n-\t\t       THREAD_LIBS=\"\"\n-\t\t       BASE_THREAD_LIBS=\"-lpthread\"\n-\t\t   else\n-\t\t       echo old GCC disabling weak symbols for pthread\n-\t\t   fi\n-\t\t   fi\n-\t       fi\n-\t   fi\n-       ;;\n-    esac\n-    if test \"$WITH_THREADS\" = \"1\" ; then\n-\tTHREAD_CFLAGS=\"$THREAD_CFLAGS -D_REENTRANT\"\n-    fi\n-fi\n-if test \"$with_thread_alloc\" = \"yes\" && test \"$WITH_THREADS\" = \"1\" ; then\n-    WITH_THREAD_ALLOC=1\n-fi\n-\n-AC_SUBST(THREAD_LIBS)\n-AC_SUBST(BASE_THREAD_LIBS)\n-AC_SUBST(WITH_THREADS)\n-AC_SUBST(THREAD_CFLAGS)\n-AC_SUBST(WITH_THREAD_ALLOC)\n-AM_CONDITIONAL([THREADS_W32],[test -n \"$THREADS_W32\"])\n-\n-dnl\n-dnl xmllint shell history\n-dnl\n-if test \"$with_history\" = \"yes\" ; then\n-    echo Enabling xmllint shell history\n-    dnl check for terminal library. this is a very cool solution\n-    dnl from octave's configure.in\n-    unset tcap\n-    for termlib in ncurses curses termcap terminfo termlib; do\n-\tAC_CHECK_LIB(${termlib}, tputs, [tcap=\"-l$termlib\"])\n-\ttest -n \"$tcap\" && break\n-    done\n-\n-    AC_CHECK_HEADER(readline\/history.h,\n-\tAC_CHECK_LIB(history, append_history,[\n-\t   RDL_LIBS=\"-lhistory\"\n-\t   AC_DEFINE([HAVE_LIBHISTORY], [], [Define if history library is there (-lhistory)])]))\n-    AC_CHECK_HEADER(readline\/readline.h,\n-\tAC_CHECK_LIB(readline, readline,[\n-\t   RDL_LIBS=\"-lreadline $RDL_LIBS $tcap\"\n-\t   AC_DEFINE([HAVE_LIBREADLINE], [], [Define if readline library is there (-lreadline)])], , $tcap))\n-    if test -n \"$RDL_DIR\" && test -n \"$RDL_LIBS\"; then\n-\tCPPFLAGS=\"$CPPFLAGS -I${RDL_DIR}\/include\"\n-\tRDL_LIBS=\"-L${RDL_DIR}\/lib $RDL_LIBS\"\n-    fi\n-fi\n-\n-dnl\n-dnl Tree functions\n-dnl\n@@ -950,1 +559,1 @@\n-else    \n+else\n@@ -956,1 +565,0 @@\n-    echo Disabling FTP support\n@@ -958,2 +566,2 @@\n-    FTP_OBJ=\n-else    \n+else\n+    echo Enabling FTP support\n@@ -961,1 +569,0 @@\n-    FTP_OBJ=nanoftp.o\n@@ -964,1 +571,1 @@\n-AC_SUBST(FTP_OBJ)\n+AM_CONDITIONAL(WITH_FTP_SOURCES, test \"$WITH_FTP\" = \"1\")\n@@ -969,2 +576,1 @@\n-    HTTP_OBJ=\n-else    \n+else\n@@ -972,1 +578,0 @@\n-    HTTP_OBJ=nanohttp.o\n@@ -975,1 +580,1 @@\n-AC_SUBST(HTTP_OBJ)\n+AM_CONDITIONAL(WITH_HTTP_SOURCES, test \"$WITH_HTTP\" = \"1\")\n@@ -978,1 +583,0 @@\n-    echo Disabling deprecated APIs\n@@ -980,1 +584,2 @@\n-else    \n+else\n+    echo Enabling deprecated APIs\n@@ -984,0 +589,1 @@\n+AM_CONDITIONAL(WITH_LEGACY_SOURCES, test \"$WITH_LEGACY\" = \"1\")\n@@ -988,1 +594,1 @@\n-else    \n+else\n@@ -990,4 +596,0 @@\n-    if test \"$with_push\" = \"no\" ; then\n-        echo xmlReader requires Push interface - enabling it\n-\twith_push=yes\n-    fi\n@@ -996,0 +598,1 @@\n+AM_CONDITIONAL(WITH_READER_SOURCES, test \"$WITH_READER\" = \"1\")\n@@ -1000,2 +603,1 @@\n-#    WRITER_TEST=\n-else    \n+else\n@@ -1003,9 +605,0 @@\n-#    WRITER_TEST=Writertests\n-    if test \"$with_push\" = \"no\" ; then\n-        echo xmlWriter requires Push interface - enabling it\n-\twith_push=yes\n-    fi\n-    if test \"$with_output\" = \"no\" ; then\n-        echo xmlWriter requires Output interface - enabling it\n-\twith_output=yes\n-    fi\n@@ -1014,1 +607,1 @@\n-#AC_SUBST(WRITER_TEST)\n+AM_CONDITIONAL(WITH_WRITER_SOURCES, test \"$WITH_WRITER\" = \"1\")\n@@ -1019,1 +612,1 @@\n-else    \n+else\n@@ -1023,0 +616,1 @@\n+AM_CONDITIONAL(WITH_PATTERN_SOURCES, test \"$WITH_PATTERN\" = \"1\")\n@@ -1027,1 +621,1 @@\n-else    \n+else\n@@ -1031,0 +625,1 @@\n+AM_CONDITIONAL(WITH_SAX1_SOURCES, test \"$WITH_SAX1\" = \"1\")\n@@ -1035,1 +630,1 @@\n-else    \n+else\n@@ -1043,2 +638,1 @@\n-    HTML_OBJ=\n-else    \n+else\n@@ -1046,1 +640,0 @@\n-    HTML_OBJ=\"HTMLparser.o HTMLtree.o\"\n@@ -1049,1 +642,1 @@\n-AC_SUBST(HTML_OBJ)\n+AM_CONDITIONAL(WITH_HTML_SOURCES, test \"$WITH_HTML\" = \"1\")\n@@ -1054,2 +647,1 @@\n-    TEST_VTIME=\n-else    \n+else\n@@ -1057,1 +649,0 @@\n-    TEST_VTIME=VTimingtests\n@@ -1060,2 +651,1 @@\n-AC_SUBST(TEST_VALID)\n-AC_SUBST(TEST_VTIME)\n+AM_CONDITIONAL(WITH_VALID_SOURCES, test \"$WITH_VALID\" = \"1\")\n@@ -1066,3 +656,1 @@\n-    CATALOG_OBJ=\n-    TEST_CATALOG=\n-else    \n+else\n@@ -1070,2 +658,0 @@\n-    CATALOG_OBJ=\"catalog.o\"\n-    TEST_CATALOG=Catatests\n@@ -1074,2 +660,1 @@\n-AC_SUBST(CATALOG_OBJ)\n-AC_SUBST(TEST_CATALOG)\n+AM_CONDITIONAL(WITH_CATALOG_SOURCES, test \"$WITH_CATALOG\" = \"1\")\n@@ -1081,2 +666,1 @@\n-    XPTR_OBJ=\n-else    \n+else\n@@ -1084,10 +668,0 @@\n-    XPTR_OBJ=xpointer.o\n-    if test \"$with_xpath\" = \"no\" ; then\n-        echo XPointer requires XPath support - enabling it\n-\twith_xpath=yes\n-    fi\n-    if test \"$with_xptr_locs\" = \"yes\" ; then\n-        WITH_XPTR_LOCS=1\n-    else\n-        WITH_XPTR_LOCS=0\n-    fi\n@@ -1096,0 +670,8 @@\n+AM_CONDITIONAL(WITH_XPTR_SOURCES, test \"$WITH_XPTR\" = \"1\")\n+\n+if test \"$with_xptr_locs\" != \"yes\" ; then\n+    WITH_XPTR_LOCS=0\n+else\n+    echo Enabling Xpointer locations support\n+    WITH_XPTR_LOCS=1\n+fi\n@@ -1097,1 +679,0 @@\n-AC_SUBST(XPTR_OBJ)\n@@ -1102,2 +683,1 @@\n-    C14N_OBJ=\n-else    \n+else\n@@ -1105,5 +685,0 @@\n-    C14N_OBJ=\"c14n.c\"\n-    if test \"$with_xpath\" = \"no\" ; then\n-        echo C14N requires XPath support - enabling it\n-\twith_xpath=yes\n-    fi\n@@ -1112,1 +687,1 @@\n-AC_SUBST(C14N_OBJ)\n+AM_CONDITIONAL(WITH_C14N_SOURCES, test \"$WITH_C14N\" = \"1\")\n@@ -1117,3 +692,1 @@\n-    XINCLUDE_OBJ=\n-    with_xinclude=\"no\"\n-else    \n+else\n@@ -1121,5 +694,0 @@\n-    XINCLUDE_OBJ=xinclude.o\n-    if test \"$with_xpath\" = \"no\" ; then\n-        echo XInclude requires XPath support - enabling it\n-\twith_xpath=yes\n-    fi\n@@ -1128,9 +696,1 @@\n-AC_SUBST(XINCLUDE_OBJ)\n-\n-if test \"$with_xptr\" = \"\" && test \"$with_xpath\" = \"no\" ; then\n-    with_xptr=no\n-fi\n-\n-if test \"$with_schematron\" = \"\" && test \"$with_xpath\" = \"no\" ; then\n-    with_schematron=no\n-fi\n+AM_CONDITIONAL(WITH_XINCLUDE_SOURCES, test \"$WITH_XINCLUDE\" = \"1\")\n@@ -1141,3 +701,1 @@\n-    TEST_SCHEMATRON=\n-else \n-    echo \"Enabled Schematron support\"\n+else\n@@ -1145,4 +703,0 @@\n-    TEST_SCHEMATRON=\"Schematrontests\"\n-    with_xpath=yes\n-    with_pattern=yes\n-    with_schematron=yes\n@@ -1151,1 +705,1 @@\n-AC_SUBST(TEST_SCHEMATRON)\n+AM_CONDITIONAL(WITH_SCHEMATRON_SOURCES, test \"$WITH_SCHEMATRON\" = \"1\")\n@@ -1156,2 +710,1 @@\n-    XPATH_OBJ=\n-else    \n+else\n@@ -1159,1 +712,0 @@\n-    XPATH_OBJ=xpath.o\n@@ -1162,1 +714,1 @@\n-AC_SUBST(XPATH_OBJ)\n+AM_CONDITIONAL(WITH_XPATH_SOURCES, test \"$WITH_XPATH\" = \"1\")\n@@ -1164,3 +716,0 @@\n-dnl\n-dnl output functions\n-dnl\n@@ -1170,1 +719,1 @@\n-else    \n+else\n@@ -1174,0 +723,1 @@\n+AM_CONDITIONAL(WITH_OUTPUT_SOURCES, test \"$WITH_OUTPUT\" = \"1\")\n@@ -1175,115 +725,1 @@\n-WITH_ICONV=0\n-if test \"$with_iconv\" = \"no\" ; then\n-    echo Disabling ICONV support\n-else\n-    if test \"$with_iconv\" != \"yes\" && test \"$with_iconv\" != \"\" ; then\n-\tCPPFLAGS=\"${CPPFLAGS} -I$with_iconv\/include\"\n-\t# Export this since our headers include iconv.h\n-\tXML_INCLUDEDIR=\"${XML_INCLUDEDIR} -I$with_iconv\/include\"\n-\tICONV_LIBS=\"-L$with_iconv\/lib\"\n-    fi\n-\n-    AC_CHECK_HEADER(iconv.h,\n-\tAC_MSG_CHECKING(for iconv)\n-\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdlib.h>\n-#include <iconv.h>]],[[\n-iconv_t cd = iconv_open (\"\",\"\");\n-iconv (cd, NULL, NULL, NULL, NULL);]])],[\n-\t    AC_MSG_RESULT(yes)\n-\t    WITH_ICONV=1],[\n-\t    AC_MSG_RESULT(no)\n-\t    AC_MSG_CHECKING(for iconv in -liconv)\n-\n-\t    _ldflags=\"${LDFLAGS}\"\n-\t    _libs=\"${LIBS}\"\n-\t    LDFLAGS=\"${LDFLAGS} ${ICONV_LIBS}\"\n-\t    LIBS=\"${LIBS} -liconv\"\n-\n-\t    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdlib.h>\n-#include <iconv.h>]],[[\n-iconv_t cd = iconv_open (\"\",\"\");\n-iconv (cd, NULL, NULL, NULL, NULL);]])],[\n-\t\tAC_MSG_RESULT(yes)\n-\t\tWITH_ICONV=1\n-\t\tICONV_LIBS=\"${ICONV_LIBS} -liconv\"\n-\t\tLIBS=\"${_libs}\"\n-\t\tLDFLAGS=\"${_ldflags}\"],[\n-\t\tAC_MSG_RESULT(no)\n-\t\tLIBS=\"${_libs}\"\n-\t\tLDFLAGS=\"${_ldflags}\"])]))\n-fi\n-AC_SUBST(WITH_ICONV)\n-\n-WITH_ICU=0\n-ICU_LIBS=\"\"\n-if test \"$with_icu\" != \"yes\" ; then\n-    echo Disabling ICU support\n-else\n-    # Try pkg-config first so that static linking works.\n-    # If this succeeeds, we ignore the WITH_ICU directory.\n-    PKG_CHECK_MODULES([ICU],[icu-i18n],\n-        [have_libicu=yes],\n-        [have_libicu=no])\n-\n-    if test \"x$have_libicu\" = \"xyes\"; then\n-        m4_ifdef([PKG_CHECK_VAR],\n-            [PKG_CHECK_VAR([ICU_DEFS], [icu-i18n], [DEFS])])\n-        if test \"x$ICU_DEFS\" != \"x\"; then\n-            CPPFLAGS=\"$CPPFLAGS $ICU_DEFS\"\n-        fi\n-    fi\n-\n-    # If pkg-config failed, fall back to AC_CHECK_LIB. This\n-    # will not pick up the necessary LIBS flags for liblzma's\n-    # private dependencies, though, so static linking may fail.\n-    if test \"x$have_libicu\" = \"xno\"; then\n-        ICU_CONFIG=icu-config\n-        if ${ICU_CONFIG} --cflags >\/dev\/null 2>&1\n-        then\n-            ICU_LIBS=`${ICU_CONFIG} --ldflags`\n-            have_libicu=yes\n-            echo Enabling ICU support\n-        else\n-            if test \"$with_icu\" != \"yes\" && test \"$with_iconv\" != \"\" ; then\n-                CPPFLAGS=\"${CPPFLAGS} -I$with_icu\"\n-            fi\n-\n-            AC_CHECK_HEADER(unicode\/ucnv.h,\n-            AC_MSG_CHECKING(for icu)\n-            AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <unicode\/ucnv.h>]], [[\n-        UConverter *utf = ucnv_open(\"UTF-8\", NULL);]])],[\n-                AC_MSG_RESULT(yes)\n-                have_libicu=yes],[\n-                AC_MSG_RESULT(no)\n-                AC_MSG_CHECKING(for icu in -licucore)\n-\n-                _ldflags=\"${LDFLAGS}\"\n-                _libs=\"${LIBS}\"\n-                LDFLAGS=\"${LDFLAGS} ${ICU_LIBS}\"\n-                LIBS=\"${LIBS} -licucore\"\n-\n-                AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <unicode\/ucnv.h>]], [[\n-        UConverter *utf = ucnv_open(\"UTF-8\", NULL);]])],[\n-                    AC_MSG_RESULT(yes)\n-                    have_libicu=yes\n-                    ICU_LIBS=\"${ICU_LIBS} -licucore\"\n-                    LIBS=\"${_libs}\"\n-                    LDFLAGS=\"${_ldflags}\"],[\n-                    AC_MSG_RESULT(no)\n-                    LIBS=\"${_libs}\"\n-                LDFLAGS=\"${_ldflags}\"])]))\n-        fi\n-    fi\n-\n-    # Found the library via either method?\n-    if test \"x$have_libicu\" = \"xyes\"; then\n-        WITH_ICU=1\n-    fi\n-fi\n-XML_LIBS=\"-lxml2\"\n-XML_LIBTOOLLIBS=\"libxml2.la\"\n-AC_SUBST(WITH_ICU)\n-\n-WITH_ISO8859X=1\n-if test \"$WITH_ICONV\" != \"1\" ; then\n-if test \"$with_iso8859x\" = \"no\" ; then\n+if test \"$WITH_ICONV\" != \"1\" && test \"$with_iso8859x\" = \"no\" ; then\n@@ -1292,1 +728,2 @@\n-fi\n+else\n+    WITH_ISO8859X=1\n@@ -1299,2 +736,1 @@\n-else    \n-    echo \"Enabled Schemas\/Relax-NG support\"\n+else\n@@ -1302,4 +738,0 @@\n-    AS_IF([test \"x$with_python\" != \"xno\"], [\n-        PYTHON_TESTS=\"$PYTHON_TESTS RelaxNGPythonTests SchemasPythonTests\"\n-    ])\n-    with_regexps=yes\n@@ -1308,0 +740,1 @@\n+AM_CONDITIONAL(WITH_SCHEMAS_SOURCES, test \"$WITH_SCHEMAS\" = \"1\")\n@@ -1312,2 +745,1 @@\n-    TEST_REGEXPS=\n-else    \n+else\n@@ -1315,1 +747,0 @@\n-    TEST_REGEXPS=\"Automatatests\"\n@@ -1318,1 +749,1 @@\n-AC_SUBST(TEST_REGEXPS)\n+AM_CONDITIONAL(WITH_REGEXPS_SOURCES, test \"$WITH_REGEXPS\" = \"1\")\n@@ -1323,3 +754,1 @@\n-    DEBUG_OBJ=\n-    TEST_DEBUG=\n-else    \n+else\n@@ -1327,2 +756,0 @@\n-    DEBUG_OBJ=debugXML.o\n-    TEST_DEBUG=Scripttests\n@@ -1331,2 +758,1 @@\n-AC_SUBST(DEBUG_OBJ)\n-AC_SUBST(TEST_DEBUG)\n+AM_CONDITIONAL(WITH_DEBUG_SOURCES, test \"$WITH_DEBUG\" = \"1\")\n@@ -1342,1 +768,1 @@\n-else    \n+else\n@@ -1347,5 +773,23 @@\n-if test \"$with_run_debug\" = \"yes\" ; then\n-    echo Enabling runtime debug support\n-    WITH_RUN_DEBUG=1\n-else    \n-    WITH_RUN_DEBUG=0\n+dnl\n+dnl Check for Python\n+dnl\n+\n+AS_IF([test \"x$with_python\" != \"xno\"], [\n+    AM_PATH_PYTHON\n+    PKG_CHECK_MODULES([PYTHON], [python-${PYTHON_VERSION}])\n+])\n+AM_CONDITIONAL([WITH_PYTHON], [test \"x$with_python\" != \"xno\"])\n+\n+dnl\n+dnl Extra Python flags for Windows\n+dnl\n+PYTHON_LDFLAGS=\n+if test \"${PYTHON}\" != \"\"; then\n+    case \"$host\" in\n+        *-*-mingw* )\n+            PYTHON_LDFLAGS=\"-no-undefined -shrext .pyd\"\n+            ;;\n+        *-*-cygwin* |*-*-msys* )\n+            PYTHON_LDFLAGS=\"-no-undefined\"\n+            ;;\n+    esac\n@@ -1353,32 +797,23 @@\n-AC_SUBST(WITH_RUN_DEBUG)\n-\n-WIN32_EXTRA_LIBADD=\n-WIN32_EXTRA_LDFLAGS=\n-CYGWIN_EXTRA_LDFLAGS=\n-CYGWIN_EXTRA_PYTHON_LIBADD=\n-WIN32_EXTRA_PYTHON_LIBADD=\n-case \"$host\" in\n- *-*-mingw*)\n- CPPFLAGS=\"$CPPFLAGS -DWIN32\"\n- WIN32_EXTRA_LIBADD=\"-lws2_32\"\n- WIN32_EXTRA_LDFLAGS=\"-no-undefined\"\n- if test \"${PYTHON}\" != \"\"\n- then\n-   case \"$host\" in\n-     *-w64-mingw*)\n-       WIN32_EXTRA_PYTHON_LIBADD=\"-shrext .pyd -L${pythondir}\/..\/..\/lib -lpython${PYTHON_VERSION}\"\n-       ;;\n-     *)\n-       WIN32_EXTRA_PYTHON_LIBADD=\"-L${pythondir}\/..\/..\/libs -lpython$(echo ${PYTHON_VERSION} | tr -d .)\"\n-       ;;\n-   esac\n- fi\n- ;;\n- *-*-cygwin*)\n- CYGWIN_EXTRA_LDFLAGS=\"-no-undefined\"\n- if test \"${PYTHON}\" != \"\"\n- then\n-   CYGWIN_EXTRA_PYTHON_LIBADD=\"-L\/usr\/lib\/python${PYTHON_VERSION}\/config -lpython${PYTHON_VERSION}\"\n- fi\n- ;;\n-esac\n+AC_SUBST(PYTHON_LDFLAGS)\n+\n+dnl\n+dnl Check for DSO support\n+dnl\n+WITH_MODULES=0\n+\n+if test \"$with_modules\" != \"no\" ; then\n+    case \"$host\" in\n+        *-*-cygwin* | *-*-msys* )\n+            MODULE_EXTENSION=\".dll\"\n+            ;;\n+        *-*-mingw*)\n+            MODULE_EXTENSION=\".dll\"\n+            WITH_MODULES=1\n+            ;;\n+        *-*-hpux*)\n+\t    MODULE_EXTENSION=\".sl\"\n+\t    ;;\n+        *)\n+\t    MODULE_EXTENSION=\".so\"\n+\t    ;;\n+    esac\n@@ -1386,1 +821,17 @@\n-XML_PRIVATE_LIBS=\"$Z_LIBS $LZMA_LIBS $THREAD_LIBS $ICONV_LIBS $ICU_LIBS $LIBM $WIN32_EXTRA_LIBADD\"\n+    if test \"$WITH_MODULES\" = \"0\"; then\n+        _libs=$LIBS\n+        AC_SEARCH_LIBS([dlopen], [dl], [\n+            WITH_MODULES=1\n+            if test \"$ac_cv_search_dlopen\" != \"none required\"; then\n+                MODULE_PLATFORM_LIBS=$ac_cv_search_dlopen\n+            fi\n+            AC_DEFINE([HAVE_DLOPEN], [], [Have dlopen based dso])], [\n+            AC_SEARCH_LIBS([shl_load], [dld], [\n+                WITH_MODULES=1\n+                if test \"$ac_cv_search_shl_load\" != \"none required\"; then\n+                    MODULE_PLATFORM_LIBS=$ac_cv_search_shl_load\n+                fi\n+                AC_DEFINE([HAVE_SHLLOAD], [], [Have shl_load based dso])])])\n+        LIBS=$_libs\n+    fi\n+fi\n@@ -1388,5 +839,4 @@\n-AC_SUBST(WIN32_EXTRA_LIBADD)\n-AC_SUBST(WIN32_EXTRA_LDFLAGS)\n-AC_SUBST(WIN32_EXTRA_PYTHON_LIBADD)\n-AC_SUBST(CYGWIN_EXTRA_LDFLAGS)\n-AC_SUBST(CYGWIN_EXTRA_PYTHON_LIBADD)\n+AC_SUBST(WITH_MODULES)\n+AC_SUBST(MODULE_PLATFORM_LIBS)\n+AC_SUBST(MODULE_EXTENSION)\n+AM_CONDITIONAL(WITH_MODULES_SOURCES, test \"$WITH_MODULES\" = \"1\")\n@@ -1394,1 +844,0 @@\n-dnl Checking the standard string functions availability\n@@ -1396,5 +845,1 @@\n-dnl Note mingw* has C99 implementation that produce expected xml numbers\n-dnl if code use {v}snprintf functions.\n-dnl If you like to activate at run-time C99 compatible number output\n-dnl see release note for mingw runtime 3.15:\n-dnl  http:\/\/sourceforge.net\/project\/shownotes.php?release_id=24832\n+dnl Check for trio string functions\n@@ -1402,1 +847,9 @@\n-dnl Also *win32*config.h files redefine them for various MSC compilers.\n+if test \"${NEED_TRIO}\" = \"1\" ; then\n+    echo Adding trio library for string functions\n+    WITH_TRIO=1\n+else\n+    WITH_TRIO=0\n+fi\n+AM_CONDITIONAL(WITH_TRIO_SOURCES, test \"${NEED_TRIO}\" = \"1\")\n+AC_SUBST(WITH_TRIO)\n+\n@@ -1404,4 +857,1 @@\n-dnl So do not redefine {v}snprintf to _{v}snprintf like following:\n-dnl  AC_DEFINE([snprintf],[_snprintf],[Win32 Std C name mangling work-around])\n-dnl  AC_DEFINE([vsnprintf],[_vsnprintf],[Win32 Std C name mangling work-around])\n-dnl and do not redefine those functions is C-source files.\n+dnl Thread-related stuff\n@@ -1409,2 +859,295 @@\n-AC_CHECK_FUNCS(snprintf vsnprintf,,\n-\tNEED_TRIO=1)\n+THREAD_LIBS=\"\"\n+BASE_THREAD_LIBS=\"\"\n+WITH_THREADS=0\n+THREAD_CFLAGS=\"\"\n+WITH_THREAD_ALLOC=0\n+\n+if test \"$with_threads\" = \"no\" ; then\n+    echo Disabling multithreaded support\n+else\n+    case $host_os in\n+        *mingw*)\n+            dnl Default to native threads on Windows\n+            WITH_THREADS=\"1\"\n+            ;;\n+        *)\n+            dnl Use pthread by default in other cases\n+            _libs=$LIBS\n+            AC_CHECK_HEADERS(pthread.h,\n+                AC_SEARCH_LIBS([pthread_join], [pthread], [\n+                    WITH_THREADS=\"1\"\n+                    if test \"$ac_cv_search_pthread_join\" != \"none required\"; then\n+                        THREAD_LIBS=$ac_cv_search_pthread_join\n+                    fi\n+                    AC_DEFINE([HAVE_PTHREAD_H], [],\n+                              [Define if <pthread.h> is there])]))\n+            LIBS=$_libs\n+            ;;\n+    esac\n+\n+    case $host_os in\n+        *linux*)\n+            if test \"${GCC}\" = \"yes\" ; then\n+                BASE_THREAD_LIBS=\"$THREAD_LIBS\"\n+                THREAD_LIBS=\"\"\n+            fi\n+            ;;\n+    esac\n+\n+    if test \"$WITH_THREADS\" = \"1\" ; then\n+\tTHREAD_CFLAGS=\"$THREAD_CFLAGS -D_REENTRANT\"\n+    fi\n+fi\n+if test \"$with_thread_alloc\" = \"yes\" && test \"$WITH_THREADS\" = \"1\" ; then\n+    WITH_THREAD_ALLOC=1\n+fi\n+\n+AC_SUBST(THREAD_LIBS)\n+AC_SUBST(BASE_THREAD_LIBS)\n+AC_SUBST(WITH_THREADS)\n+AC_SUBST(THREAD_CFLAGS)\n+AC_SUBST(WITH_THREAD_ALLOC)\n+\n+dnl\n+dnl xmllint shell history\n+dnl\n+if test \"$with_history\" = \"yes\" && test \"$with_readline\" != \"no\"; then\n+    echo Enabling xmllint shell history\n+    dnl check for terminal library. this is a very cool solution\n+    dnl from octave's configure.in\n+    unset tcap\n+    for termlib in ncurses curses termcap terminfo termlib; do\n+\tAC_CHECK_LIB(${termlib}, tputs, [tcap=\"-l$termlib\"])\n+\ttest -n \"$tcap\" && break\n+    done\n+\n+    _cppflags=$CPPFLAGS\n+    _libs=$LIBS\n+    if test \"$with_readline\" != \"\" && test \"$with_readline\" != \"yes\"; then\n+        RDL_DIR=$with_readline\n+        CPPFLAGS=\"${CPPFLAGS} -I$RDL_DIR\/include\"\n+        LIBS=\"${LIBS} -L$RDL_DIR\/lib\"\n+    fi\n+    AC_CHECK_HEADER(readline\/history.h,\n+\tAC_CHECK_LIB(history, append_history,[\n+\t    RDL_LIBS=\"-lhistory\"\n+            if test \"x${RDL_DIR}\" != \"x\"; then\n+                RDL_CFLAGS=\"-I$RDL_DIR\/include\"\n+                RDL_LIBS=\"-L$RDL_DIR\/lib $RDL_LIBS\"\n+            fi\n+\t    AC_DEFINE([HAVE_LIBHISTORY], [], [Define if history library is there (-lhistory)])]))\n+    AC_CHECK_HEADER(readline\/readline.h,\n+\tAC_CHECK_LIB(readline, readline,[\n+\t    RDL_LIBS=\"-lreadline $RDL_LIBS $tcap\"\n+            if test \"x$RDL_DIR\" != \"x\"; then\n+                RDL_CFLAGS=\"-I$RDL_DIR\/include\"\n+                RDL_LIBS=\"-L$RDL_DIR\/lib $RDL_LIBS\"\n+            fi\n+\t    AC_DEFINE([HAVE_LIBREADLINE], [], [Define if readline library is there (-lreadline)])], , $tcap))\n+    CPPFLAGS=$_cppflags\n+    LIBS=$_libs\n+fi\n+AC_SUBST(RDL_CFLAGS)\n+AC_SUBST(RDL_LIBS)\n+\n+dnl\n+dnl Checks for zlib library.\n+dnl\n+WITH_ZLIB=0\n+\n+if test \"$with_zlib\" = \"no\"; then\n+    echo \"Disabling zlib compression support\"\n+else\n+    if test \"$with_zlib\" != \"yes\"; then\n+        Z_DIR=$with_zlib\n+    fi\n+\n+    # Don't run pkg-config if with_zlib contains a path.\n+    if test \"x$Z_DIR\" = \"x\"; then\n+        # Try pkg-config first so that static linking works.\n+        PKG_CHECK_MODULES([Z],[zlib],\n+            [WITH_ZLIB=1; XML_PC_REQUIRES=\"${XML_PC_REQUIRES} zlib\"],\n+            [:])\n+    fi\n+\n+    if test \"$WITH_ZLIB\" = \"0\"; then\n+        _cppflags=$CPPFLAGS\n+        _libs=$LIBS\n+        if test \"x$Z_DIR\" != \"x\"; then\n+            CPPFLAGS=\"${CPPFLAGS} -I$Z_DIR\/include\"\n+            LIBS=\"${LIBS} -L$Z_DIR\/lib\"\n+        fi\n+        AC_CHECK_HEADERS(zlib.h,\n+            AC_CHECK_LIB(z, gzread,[\n+                WITH_ZLIB=1\n+                if test \"x${Z_DIR}\" != \"x\"; then\n+                    Z_CFLAGS=\"-I${Z_DIR}\/include\"\n+                    Z_LIBS=\"-L${Z_DIR}\/lib -lz\"\n+                    [case ${host} in\n+                        *-*-solaris*)\n+                            Z_LIBS=\"-L${Z_DIR}\/lib -R${Z_DIR}\/lib -lz\"\n+                            ;;\n+                    esac]\n+                else\n+                    Z_LIBS=\"-lz\"\n+                fi])\n+                XML_PC_LIBS=\"${XML_PC_LIBS} ${Z_LIBS}\"\n+            )\n+        CPPFLAGS=$_cppflags\n+        LIBS=$_libs\n+    fi\n+\n+    XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${Z_CFLAGS}\"\n+    XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${Z_LIBS}\"\n+fi\n+AC_SUBST(WITH_ZLIB)\n+\n+dnl\n+dnl Checks for lzma library.\n+dnl\n+WITH_LZMA=0\n+\n+if test \"$with_lzma\" = \"no\"; then\n+    echo \"Disabling lzma compression support\"\n+else\n+    if test \"$with_lzma\" != \"yes\"; then\n+        LZMA_DIR=$with_lzma\n+    fi\n+\n+    # Don't run pkg-config if with_lzma contains a path.\n+    if test \"x$LZMA_DIR\" = \"x\"; then\n+        # Try pkg-config first so that static linking works.\n+        PKG_CHECK_MODULES([LZMA],[liblzma],\n+            [WITH_LZMA=1; XML_PC_REQUIRES=\"${XML_PC_REQUIRES} liblzma\"],\n+            [:])\n+    fi\n+\n+    # If pkg-config failed, fall back to AC_CHECK_LIB. This\n+    # will not pick up the necessary LIBS flags for liblzma's\n+    # private dependencies, though, so static linking may fail.\n+    if test \"$WITH_LZMA\" = \"0\"; then\n+        _cppflags=$CPPFLAGS\n+        _libs=$LIBS\n+        if test \"x$LZMA_DIR\" != \"x\"; then\n+            CPPFLAGS=\"${CPPFLAGS} -I$LZMA_DIR\/include\"\n+            LIBS=\"${LIBS} -L$LZMA_DIR\/lib\"\n+        fi\n+        AC_CHECK_HEADERS(lzma.h,\n+            AC_CHECK_LIB(lzma, lzma_code,[\n+                WITH_LZMA=1\n+                if test \"x${LZMA_DIR}\" != \"x\"; then\n+                    LZMA_CFLAGS=\"-I${LZMA_DIR}\/include\"\n+                    LZMA_LIBS=\"-L${LZMA_DIR}\/lib -llzma\"\n+                else\n+                    LZMA_LIBS=\"-llzma\"\n+                fi])\n+                XML_PC_LIBS=\"${XML_PC_LIBS} ${LZMA_LIBS}\"\n+            )\n+        CPPFLAGS=$_cppflags\n+        LIBS=$_libs\n+    fi\n+\n+    XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${LZMA_CFLAGS}\"\n+    XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${LZMA_LIBS}\"\n+fi\n+AC_SUBST(WITH_LZMA)\n+AM_CONDITIONAL(WITH_LZMA_SOURCES, test \"$WITH_LZMA\" = \"1\")\n+\n+dnl\n+dnl Checks for iconv library.\n+dnl\n+WITH_ICONV=0\n+\n+if test \"$with_iconv\" = \"no\" ; then\n+    echo Disabling ICONV support\n+else\n+    _cppflags=$CPPFLAGS\n+    _libs=$LIBS\n+    if test \"$with_iconv\" != \"yes\" && test \"$with_iconv\" != \"\" ; then\n+\tICONV_DIR=$with_iconv\n+\tCPPFLAGS=\"$CPPFLAGS -I$ICONV_DIR\/include\"\n+\tLIBS=\"$LIBS -L$ICONV_DIR\/lib\"\n+    fi\n+    AC_MSG_CHECKING([for libiconv])\n+    AC_LINK_IFELSE([\n+        AC_LANG_PROGRAM([#include <iconv.h>], [iconv_open(0,0);])\n+    ], [\n+        WITH_ICONV=1\n+        AC_MSG_RESULT([none required])\n+    ], [\n+        LIBS=\"$LIBS -liconv\"\n+        AC_LINK_IFELSE([\n+            AC_LANG_PROGRAM([#include <iconv.h>], [iconv_open(0,0);])\n+        ], [\n+            WITH_ICONV=1\n+            ICONV_LIBS=\"-liconv\"\n+            AC_MSG_RESULT([yes])\n+        ], [\n+            AC_MSG_RESULT([no])\n+        ])\n+    ])\n+    if test \"$WITH_ICONV\" = \"1\" && test \"$ICONV_DIR\" != \"\"; then\n+        ICONV_CFLAGS=\"-I$ICONV_DIR\/include\"\n+        ICONV_LIBS=\"-L$ICONV_DIR\/lib $ICONV_LIBS\"\n+\t# Export this since our headers include iconv.h\n+\tXML_INCLUDEDIR=\"$XML_INCLUDEDIR -I$ICONV_DIR\/include\"\n+    fi\n+    CPPFLAGS=$_cppflags\n+    LIBS=$_libs\n+fi\n+AC_SUBST(WITH_ICONV)\n+AC_SUBST(ICONV_CFLAGS)\n+\n+dnl\n+dnl Checks for ICU library.\n+dnl\n+WITH_ICU=0\n+\n+if test \"$with_icu\" = \"no\" || test \"$with_icu\" = \"\" ; then\n+    echo Disabling ICU support\n+else\n+    # Try pkg-config first so that static linking works.\n+    # If this succeeeds, we ignore the WITH_ICU directory.\n+    PKG_CHECK_MODULES([ICU], [icu-i18n], [\n+        WITH_ICU=1; XML_PC_REQUIRES=\"${XML_PC_REQUIRES} icu-i18n\"\n+        m4_ifdef([PKG_CHECK_VAR],\n+            [PKG_CHECK_VAR([ICU_DEFS], [icu-i18n], [DEFS])])\n+        if test \"x$ICU_DEFS\" != \"x\"; then\n+            ICU_CFLAGS=\"$ICU_CFLAGS $ICU_DEFS\"\n+        fi],[:])\n+\n+    if test \"$WITH_ICU\" = \"0\"; then\n+        ICU_CONFIG=icu-config\n+        if ${ICU_CONFIG} --cflags >\/dev\/null 2>&1\n+        then\n+            WITH_ICU=1\n+            ICU_CFLAGS=`${ICU_CONFIG} --cflags`\n+            ICU_LIBS=`${ICU_CONFIG} --ldflags`\n+            XML_PC_LIBS=\"${XML_PC_LIBS} ${ICU_LIBS}\"\n+        else\n+            _cppflags=\"${CPPFLAGS}\"\n+            _libs=\"${LIBS}\"\n+            if test \"$with_icu\" != \"yes\" ; then\n+                ICU_DIR=$with_icu\n+                CPPFLAGS=\"${CPPFLAGS} -I$ICU_DIR\/include\"\n+                LIBS=\"${LIBS} -L$ICU_DIR\/lib\"\n+            fi\n+\n+            AC_CHECK_HEADER(unicode\/ucnv.h, [\n+                AC_CHECK_LIB([icucore], [ucnv_open], [\n+                    WITH_ICU=1\n+                    ICU_LIBS=-licucore\n+                    if test \"$ICU_DIR\" != \"\"; then\n+                        ICU_CFLAGS=\"-I$ICU_DIR\/include\"\n+                        ICU_LIBS=\"-L$ICU_DIR\/lib $ICU_LIBS\"\n+                    fi])])\n+                    XML_PC_LIBS=\"${XML_PC_LIBS} ${ICU_LIBS}\"\n+            CPPFLAGS=$_cppflags\n+            LIBS=$_libs\n+        fi\n+    fi\n+\n+    XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${ICU_CFLAGS}\"\n+    XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${ICU_LIBS}\"\n+fi\n+AC_SUBST(WITH_ICU)\n@@ -1415,2 +1158,2 @@\n-    EXTRA_CFLAGS=\"$EXTRA_CFLAGS -fprofile-arcs -ftest-coverage\"\n-    LDFLAGS=\"$LDFLAGS -fprofile-arcs -ftest-coverage\"\n+    AM_CFLAGS=\"$AM_CFLAGS -fprofile-arcs -ftest-coverage\"\n+    AM_LDFLAGS=\"$AM_LDFLAGS -fprofile-arcs -ftest-coverage\"\n@@ -1421,1 +1164,34 @@\n-AC_SUBST(EXTRA_CFLAGS)\n+XML_LIBS=\"-lxml2\"\n+XML_LIBTOOLLIBS=\"libxml2.la\"\n+NON_PC_LIBS=\"${THREAD_LIBS} ${ICONV_LIBS} ${LIBM} ${NET_LIBS}\"\n+XML_PC_LIBS=\"${XML_PC_LIBS} ${NON_PC_LIBS}\"\n+XML_PRIVATE_LIBS=\"${XML_PRIVATE_LIBS} ${NON_PC_LIBS}\"\n+XML_PRIVATE_CFLAGS=\"${XML_PRIVATE_CFLAGS} ${THREAD_CFLAGS} ${ICONV_CFLAGS}\"\n+\n+dnl When static-only:\n+dnl * Duplicate xml-config static --libs into --dynamic.\n+dnl * Fold pkg-config private fields into main fields.\n+if test \"x$enable_shared\" = \"xno\"; then\n+  XML_PRIVATE_LIBS_NO_SHARED=\"${XML_PRIVATE_LIBS}\"\n+  XML_PC_PRIVATE=\n+  XML_PC_LIBS_PRIVATE=\n+else\n+  XML_PRIVATE_LIBS_NO_SHARED=\n+  XML_PC_PRIVATE=\".private\"\n+  XML_PC_LIBS_PRIVATE=\"\n+Libs.private:\"\n+fi\n+AC_SUBST(XML_PRIVATE_LIBS_NO_SHARED)\n+AC_SUBST(XML_PC_PRIVATE)\n+AC_SUBST(XML_PC_LIBS_PRIVATE)\n+AM_SUBST_NOTMAKE(XML_PRIVATE_LIBS_NO_SHARED)\n+AM_SUBST_NOTMAKE(XML_PC_PRIVATE)\n+AM_SUBST_NOTMAKE(XML_PC_LIBS_PRIVATE)\n+\n+AC_SUBST(XML_PC_LIBS)\n+AC_SUBST(XML_PC_REQUIRES)\n+AM_SUBST_NOTMAKE(XML_PC_LIBS)\n+AM_SUBST_NOTMAKE(XML_PC_REQUIRES)\n+\n+AC_SUBST(AM_CFLAGS)\n+AC_SUBST(AM_LDFLAGS)\n@@ -1427,0 +1203,1 @@\n+AC_SUBST(XML_PRIVATE_CFLAGS)\n@@ -1428,2 +1205,0 @@\n-AC_SUBST(ICONV_LIBS)\n-AC_SUBST(ICU_LIBS)\n@@ -1432,2 +1207,0 @@\n-AC_SUBST(RDL_LIBS)\n-\n@@ -1437,1 +1210,0 @@\n-AC_SUBST(PYTHON_TESTS)\n@@ -1440,1 +1212,1 @@\n-AC_CONFIG_FILES([libxml2.spec:libxml.spec.in Makefile include\/Makefile include\/libxml\/Makefile doc\/Makefile doc\/examples\/Makefile doc\/devhelp\/Makefile example\/Makefile fuzz\/Makefile python\/Makefile python\/tests\/Makefile xstc\/Makefile include\/libxml\/xmlversion.h libxml-2.0.pc libxml-2.0-uninstalled.pc libxml2-config.cmake])\n+AC_CONFIG_FILES([Makefile include\/Makefile include\/libxml\/Makefile include\/private\/Makefile doc\/Makefile doc\/examples\/Makefile doc\/devhelp\/Makefile example\/Makefile fuzz\/Makefile python\/Makefile python\/tests\/Makefile xstc\/Makefile include\/libxml\/xmlversion.h libxml-2.0.pc libxml-2.0-uninstalled.pc libxml2-config.cmake])\n@@ -1445,1 +1217,7 @@\n-echo Done configuring\n+if test \"$WARN_NO_TLS\" != \"\"; then\n+    echo \"================================================================\"\n+    echo \"WARNING: Your C compiler appears to not support thread-local\"\n+    echo \"storage. Future versions of libxml2 will require this feature\"\n+    echo \"for multi-threading.\"\n+    echo \"================================================================\"\n+fi\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/configure.ac","additions":787,"deletions":1009,"binary":false,"changes":1796,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-#include <stdlib.h>\n+#include <string.h>\n@@ -26,14 +26,2 @@\n-\/*\n- * Following http:\/\/www.ocert.org\/advisories\/ocert-2011-003.html\n- * it seems that having hash randomization might be a good idea\n- * when using XML with untrusted data\n- * Note1: that it works correctly only if compiled with WITH_BIG_KEY\n- *  which is the default.\n- * Note2: the fast function used for a small dict won't protect very\n- *  well but since the attack is based on growing a very big hash\n- *  list we will use the BigKey algo as soon as the hash size grows\n- *  over MIN_DICT_SIZE so this actually works\n- *\/\n-#if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)\n-#define DICT_RANDOMIZATION\n-#endif\n+#include \"private\/dict.h\"\n+#include \"private\/threads.h\"\n@@ -41,11 +29,1 @@\n-#include <string.h>\n-#ifdef HAVE_STDINT_H\n-#include <stdint.h>\n-#else\n-#ifdef HAVE_INTTYPES_H\n-#include <inttypes.h>\n-#elif defined(_WIN32)\n-typedef unsigned __int32 uint32_t;\n-#endif\n-#endif\n-#include <libxml\/tree.h>\n+#include <libxml\/parser.h>\n@@ -54,30 +32,1 @@\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/globals.h>\n-\n-\/* #define DEBUG_GROW *\/\n-\/* #define DICT_DEBUG_PATTERNS *\/\n-\n-#define MAX_HASH_LEN 3\n-#define MIN_DICT_SIZE 128\n-#define MAX_DICT_HASH 8 * 2048\n-#define WITH_BIG_KEY\n-\n-#ifdef WITH_BIG_KEY\n-#define xmlDictComputeKey(dict, name, len)                              \\\n-    (((dict)->size == MIN_DICT_SIZE) ?                                  \\\n-     xmlDictComputeFastKey(name, len, (dict)->seed) :                   \\\n-     xmlDictComputeBigKey(name, len, (dict)->seed))\n-\n-#define xmlDictComputeQKey(dict, prefix, plen, name, len)               \\\n-    (((prefix) == NULL) ?                                               \\\n-      (xmlDictComputeKey(dict, name, len)) :                             \\\n-      (((dict)->size == MIN_DICT_SIZE) ?                                \\\n-       xmlDictComputeFastQKey(prefix, plen, name, len, (dict)->seed) :  \\\n-       xmlDictComputeBigQKey(prefix, plen, name, len, (dict)->seed)))\n-\n-#else \/* !WITH_BIG_KEY *\/\n-#define xmlDictComputeKey(dict, name, len)                              \\\n-        xmlDictComputeFastKey(name, len, (dict)->seed)\n-#define xmlDictComputeQKey(dict, prefix, plen, name, len)               \\\n-        xmlDictComputeFastQKey(prefix, plen, name, len, (dict)->seed)\n-#endif \/* WITH_BIG_KEY *\/\n+#include <libxml\/xmlstring.h>\n@@ -85,12 +34,8 @@\n-\/*\n- * An entry in the dictionary\n- *\/\n-typedef struct _xmlDictEntry xmlDictEntry;\n-typedef xmlDictEntry *xmlDictEntryPtr;\n-struct _xmlDictEntry {\n-    struct _xmlDictEntry *next;\n-    const xmlChar *name;\n-    unsigned int len;\n-    int valid;\n-    unsigned long okey;\n-};\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n+\n+#define MAX_FILL_NUM 7\n+#define MAX_FILL_DENOM 8\n+#define MIN_HASH_SIZE 8\n+#define MAX_HASH_SIZE (1u << 31)\n@@ -108,0 +53,3 @@\n+\n+typedef xmlHashedString xmlDictEntry;\n+\n@@ -114,1 +62,1 @@\n-    struct _xmlDictEntry *dict;\n+    xmlDictEntry *table;\n@@ -121,1 +69,1 @@\n-    int seed;\n+    unsigned seed;\n@@ -130,15 +78,1 @@\n-static xmlMutexPtr xmlDictMutex = NULL;\n-\n-\/*\n- * Whether the dictionary mutex was initialized.\n- *\/\n-static int xmlDictInitialized = 0;\n-\n-#ifdef DICT_RANDOMIZATION\n-#ifdef HAVE_RAND_R\n-\/*\n- * Internal data for random function, protected by xmlDictMutex\n- *\/\n-static unsigned int rand_seed = 0;\n-#endif\n-#endif\n+static xmlMutex xmlDictMutex;\n@@ -149,4 +83,1 @@\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n- * initialize the library.\n- *\n- * Do the dictionary mutex initialization.\n+ * DEPRECATED: Alias for xmlInitParser.\n@@ -154,2 +85,1 @@\n- * Returns 0 if initialization was already done, and 1 if that\n- * call led to the initialization\n+ * Returns 0.\n@@ -157,1 +87,3 @@\n-int xmlInitializeDict(void) {\n+int\n+xmlInitializeDict(void) {\n+    xmlInitParser();\n@@ -162,7 +94,1 @@\n- * __xmlInitializeDict:\n- *\n- * This function is not public\n- * Do the dictionary mutex initialization.\n- * this function is not thread safe, initialization should\n- * normally be done once at setup when called from xmlOnceInit()\n- * we may also land in this code if thread support is not compiled in\n+ * xmlInitDictInternal:\n@@ -170,2 +96,1 @@\n- * Returns 0 if initialization was already done, and 1 if that\n- * call led to the initialization\n+ * Initialize mutex.\n@@ -173,36 +98,3 @@\n-int __xmlInitializeDict(void) {\n-    if (xmlDictInitialized)\n-        return(1);\n-\n-    if ((xmlDictMutex = xmlNewMutex()) == NULL)\n-        return(0);\n-    xmlMutexLock(xmlDictMutex);\n-\n-#ifdef DICT_RANDOMIZATION\n-#ifdef HAVE_RAND_R\n-    rand_seed = time(NULL);\n-    rand_r(& rand_seed);\n-#else\n-    srand(time(NULL));\n-#endif\n-#endif\n-    xmlDictInitialized = 1;\n-    xmlMutexUnlock(xmlDictMutex);\n-    return(1);\n-}\n-\n-#ifdef DICT_RANDOMIZATION\n-int __xmlRandom(void) {\n-    int ret;\n-\n-    if (xmlDictInitialized == 0)\n-        __xmlInitializeDict();\n-\n-    xmlMutexLock(xmlDictMutex);\n-#ifdef HAVE_RAND_R\n-    ret = rand_r(& rand_seed);\n-#else\n-    ret = rand();\n-#endif\n-    xmlMutexUnlock(xmlDictMutex);\n-    return(ret);\n+void\n+xmlInitDictInternal(void) {\n+    xmlInitMutex(&xmlDictMutex);\n@@ -210,1 +102,0 @@\n-#endif\n@@ -215,1 +106,1 @@\n- * DEPRECATED: This function will be made private. Call xmlCleanupParser\n+ * DEPRECATED: This function is a no-op. Call xmlCleanupParser\n@@ -219,3 +110,0 @@\n- *\n- * Free the dictionary mutex. Do not call unless sure the library\n- * is not in use anymore !\n@@ -225,4 +113,1 @@\n-    if (!xmlDictInitialized)\n-        return;\n-\n-    xmlFreeMutex(xmlDictMutex);\n+}\n@@ -230,1 +115,8 @@\n-    xmlDictInitialized = 0;\n+\/**\n+ * xmlCleanupDictInternal:\n+ *\n+ * Free the dictionary mutex.\n+ *\/\n+void\n+xmlCleanupDictInternal(void) {\n+    xmlCleanupMutex(&xmlDictMutex);\n@@ -250,3 +142,0 @@\n-#ifdef DICT_DEBUG_PATTERNS\n-    fprintf(stderr, \"-\");\n-#endif\n@@ -269,4 +158,14 @@\n-        if (size == 0) size = 1000;\n-        else size *= 4; \/* exponential growth *\/\n-        if (size < 4 * namelen)\n-            size = 4 * namelen; \/* just in case ! *\/\n+        if (size == 0) {\n+            size = 1000;\n+        } else {\n+            if (size < (SIZE_MAX - sizeof(xmlDictStrings)) \/ 4)\n+                size *= 4; \/* exponential growth *\/\n+            else\n+                size = SIZE_MAX - sizeof(xmlDictStrings);\n+        }\n+        if (size \/ 4 < namelen) {\n+            if ((size_t) namelen + 0 < (SIZE_MAX - sizeof(xmlDictStrings)) \/ 4)\n+                size = 4 * (size_t) namelen; \/* just in case ! *\/\n+            else\n+                return(NULL);\n+        }\n@@ -282,3 +181,0 @@\n-#ifdef DICT_DEBUG_PATTERNS\n-        fprintf(stderr, \"+\");\n-#endif\n@@ -316,5 +212,0 @@\n-    if (prefix == NULL) return(xmlDictAddString(dict, name, namelen));\n-\n-#ifdef DICT_DEBUG_PATTERNS\n-    fprintf(stderr, \"=\");\n-#endif\n@@ -350,3 +241,0 @@\n-#ifdef DICT_DEBUG_PATTERNS\n-        fprintf(stderr, \"+\");\n-#endif\n@@ -366,204 +254,0 @@\n-#ifdef WITH_BIG_KEY\n-\/*\n- * xmlDictComputeBigKey:\n- *\n- * Calculate a hash key using a good hash function that works well for\n- * larger hash table sizes.\n- *\n- * Hash function by \"One-at-a-Time Hash\" see\n- * http:\/\/burtleburtle.net\/bob\/hash\/doobs.html\n- *\/\n-\n-#ifdef __clang__\n-ATTRIBUTE_NO_SANITIZE(\"unsigned-integer-overflow\")\n-#endif\n-static uint32_t\n-xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {\n-    uint32_t hash;\n-    int i;\n-\n-    if (namelen <= 0 || data == NULL) return(0);\n-\n-    hash = seed;\n-\n-    for (i = 0;i < namelen; i++) {\n-        hash += data[i];\n-        hash += (hash << 10);\n-        hash ^= (hash >> 6);\n-    }\n-    hash += (hash << 3);\n-    hash ^= (hash >> 11);\n-    hash += (hash << 15);\n-\n-    return hash;\n-}\n-\n-\/*\n- * xmlDictComputeBigQKey:\n- *\n- * Calculate a hash key for two strings using a good hash function\n- * that works well for larger hash table sizes.\n- *\n- * Hash function by \"One-at-a-Time Hash\" see\n- * http:\/\/burtleburtle.net\/bob\/hash\/doobs.html\n- *\n- * Neither of the two strings must be NULL.\n- *\/\n-#ifdef __clang__\n-ATTRIBUTE_NO_SANITIZE(\"unsigned-integer-overflow\")\n-#endif\n-static unsigned long\n-xmlDictComputeBigQKey(const xmlChar *prefix, int plen,\n-                      const xmlChar *name, int len, int seed)\n-{\n-    uint32_t hash;\n-    int i;\n-\n-    hash = seed;\n-\n-    for (i = 0;i < plen; i++) {\n-        hash += prefix[i];\n-        hash += (hash << 10);\n-        hash ^= (hash >> 6);\n-    }\n-    hash += ':';\n-    hash += (hash << 10);\n-    hash ^= (hash >> 6);\n-\n-    for (i = 0;i < len; i++) {\n-        hash += name[i];\n-        hash += (hash << 10);\n-        hash ^= (hash >> 6);\n-    }\n-    hash += (hash << 3);\n-    hash ^= (hash >> 11);\n-    hash += (hash << 15);\n-\n-    return hash;\n-}\n-#endif \/* WITH_BIG_KEY *\/\n-\n-\/*\n- * xmlDictComputeFastKey:\n- *\n- * Calculate a hash key using a fast hash function that works well\n- * for low hash table fill.\n- *\/\n-static unsigned long\n-xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {\n-    unsigned long value = seed;\n-\n-    if ((name == NULL) || (namelen <= 0))\n-        return(value);\n-    value += *name;\n-    value <<= 5;\n-    if (namelen > 10) {\n-        value += name[namelen - 1];\n-        namelen = 10;\n-    }\n-    switch (namelen) {\n-        case 10: value += name[9];\n-        \/* Falls through. *\/\n-        case 9: value += name[8];\n-        \/* Falls through. *\/\n-        case 8: value += name[7];\n-        \/* Falls through. *\/\n-        case 7: value += name[6];\n-        \/* Falls through. *\/\n-        case 6: value += name[5];\n-        \/* Falls through. *\/\n-        case 5: value += name[4];\n-        \/* Falls through. *\/\n-        case 4: value += name[3];\n-        \/* Falls through. *\/\n-        case 3: value += name[2];\n-        \/* Falls through. *\/\n-        case 2: value += name[1];\n-        \/* Falls through. *\/\n-        default: break;\n-    }\n-    return(value);\n-}\n-\n-\/*\n- * xmlDictComputeFastQKey:\n- *\n- * Calculate a hash key for two strings using a fast hash function\n- * that works well for low hash table fill.\n- *\n- * Neither of the two strings must be NULL.\n- *\/\n-static unsigned long\n-xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n-                       const xmlChar *name, int len, int seed)\n-{\n-    unsigned long value = (unsigned long) seed;\n-\n-    if (plen == 0)\n-        value += 30 * (unsigned long) ':';\n-    else\n-        value += 30 * (*prefix);\n-\n-    if (len > 10) {\n-        int offset = len - (plen + 1 + 1);\n-        if (offset < 0)\n-            offset = len - (10 + 1);\n-        value += name[offset];\n-        len = 10;\n-        if (plen > 10)\n-            plen = 10;\n-    }\n-    switch (plen) {\n-        case 10: value += prefix[9];\n-        \/* Falls through. *\/\n-        case 9: value += prefix[8];\n-        \/* Falls through. *\/\n-        case 8: value += prefix[7];\n-        \/* Falls through. *\/\n-        case 7: value += prefix[6];\n-        \/* Falls through. *\/\n-        case 6: value += prefix[5];\n-        \/* Falls through. *\/\n-        case 5: value += prefix[4];\n-        \/* Falls through. *\/\n-        case 4: value += prefix[3];\n-        \/* Falls through. *\/\n-        case 3: value += prefix[2];\n-        \/* Falls through. *\/\n-        case 2: value += prefix[1];\n-        \/* Falls through. *\/\n-        case 1: value += prefix[0];\n-        \/* Falls through. *\/\n-        default: break;\n-    }\n-    len -= plen;\n-    if (len > 0) {\n-        value += (unsigned long) ':';\n-        len--;\n-    }\n-    switch (len) {\n-        case 10: value += name[9];\n-        \/* Falls through. *\/\n-        case 9: value += name[8];\n-        \/* Falls through. *\/\n-        case 8: value += name[7];\n-        \/* Falls through. *\/\n-        case 7: value += name[6];\n-        \/* Falls through. *\/\n-        case 6: value += name[5];\n-        \/* Falls through. *\/\n-        case 5: value += name[4];\n-        \/* Falls through. *\/\n-        case 4: value += name[3];\n-        \/* Falls through. *\/\n-        case 3: value += name[2];\n-        \/* Falls through. *\/\n-        case 2: value += name[1];\n-        \/* Falls through. *\/\n-        case 1: value += name[0];\n-        \/* Falls through. *\/\n-        default: break;\n-    }\n-    return(value);\n-}\n-\n@@ -581,7 +265,1 @@\n-    if (!xmlDictInitialized)\n-        if (!__xmlInitializeDict())\n-            return(NULL);\n-\n-#ifdef DICT_DEBUG_PATTERNS\n-    fprintf(stderr, \"C\");\n-#endif\n+    xmlInitParser();\n@@ -590,15 +268,13 @@\n-    if (dict) {\n-        dict->ref_counter = 1;\n-        dict->limit = 0;\n-\n-        dict->size = MIN_DICT_SIZE;\n-        dict->nbElems = 0;\n-        dict->dict = xmlMalloc(MIN_DICT_SIZE * sizeof(xmlDictEntry));\n-        dict->strings = NULL;\n-        dict->subdict = NULL;\n-        if (dict->dict) {\n-            memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));\n-#ifdef DICT_RANDOMIZATION\n-            dict->seed = __xmlRandom();\n-#else\n-            dict->seed = 0;\n+    if (dict == NULL)\n+        return(NULL);\n+    dict->ref_counter = 1;\n+    dict->limit = 0;\n+\n+    dict->size = 0;\n+    dict->nbElems = 0;\n+    dict->table = NULL;\n+    dict->strings = NULL;\n+    dict->subdict = NULL;\n+    dict->seed = xmlRandom();\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    dict->seed = 0;\n@@ -606,5 +282,1 @@\n-            return(dict);\n-        }\n-        xmlFree(dict);\n-    }\n-    return(NULL);\n+    return(dict);\n@@ -629,3 +301,0 @@\n-#ifdef DICT_DEBUG_PATTERNS\n-        fprintf(stderr, \"R\");\n-#endif\n@@ -649,4 +318,0 @@\n-    if (!xmlDictInitialized)\n-        if (!__xmlInitializeDict())\n-            return(-1);\n-\n@@ -654,1 +319,1 @@\n-    xmlMutexLock(xmlDictMutex);\n+    xmlMutexLock(&xmlDictMutex);\n@@ -656,1 +321,1 @@\n-    xmlMutexUnlock(xmlDictMutex);\n+    xmlMutexUnlock(&xmlDictMutex);\n@@ -660,135 +325,0 @@\n-\/**\n- * xmlDictGrow:\n- * @dict: the dictionary\n- * @size: the new size of the dictionary\n- *\n- * resize the dictionary\n- *\n- * Returns 0 in case of success, -1 in case of failure\n- *\/\n-static int\n-xmlDictGrow(xmlDictPtr dict, size_t size) {\n-    unsigned long key, okey;\n-    size_t oldsize, i;\n-    xmlDictEntryPtr iter, next;\n-    struct _xmlDictEntry *olddict;\n-#ifdef DEBUG_GROW\n-    unsigned long nbElem = 0;\n-#endif\n-    int ret = 0;\n-    int keep_keys = 1;\n-\n-    if (dict == NULL)\n-        return(-1);\n-    if (size < 8)\n-        return(-1);\n-    if (size > 8 * 2048)\n-        return(-1);\n-\n-#ifdef DICT_DEBUG_PATTERNS\n-    fprintf(stderr, \"*\");\n-#endif\n-\n-    oldsize = dict->size;\n-    olddict = dict->dict;\n-    if (olddict == NULL)\n-        return(-1);\n-    if (oldsize == MIN_DICT_SIZE)\n-        keep_keys = 0;\n-\n-    dict->dict = xmlMalloc(size * sizeof(xmlDictEntry));\n-    if (dict->dict == NULL) {\n-        dict->dict = olddict;\n-        return(-1);\n-    }\n-    memset(dict->dict, 0, size * sizeof(xmlDictEntry));\n-    dict->size = size;\n-\n-    \/*  If the two loops are merged, there would be situations where\n-        a new entry needs to allocated and data copied into it from\n-        the main dict. It is nicer to run through the array twice, first\n-        copying all the elements in the main array (less probability of\n-        allocate) and then the rest, so we only free in the second loop.\n-    *\/\n-    for (i = 0; i < oldsize; i++) {\n-        if (olddict[i].valid == 0)\n-            continue;\n-\n-        if (keep_keys)\n-            okey = olddict[i].okey;\n-        else\n-            okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);\n-        key = okey % dict->size;\n-\n-        if (dict->dict[key].valid == 0) {\n-            memcpy(&(dict->dict[key]), &(olddict[i]), sizeof(xmlDictEntry));\n-            dict->dict[key].next = NULL;\n-            dict->dict[key].okey = okey;\n-        } else {\n-            xmlDictEntryPtr entry;\n-\n-            entry = xmlMalloc(sizeof(xmlDictEntry));\n-            if (entry != NULL) {\n-                entry->name = olddict[i].name;\n-                entry->len = olddict[i].len;\n-                entry->okey = okey;\n-                entry->next = dict->dict[key].next;\n-                entry->valid = 1;\n-                dict->dict[key].next = entry;\n-            } else {\n-                \/*\n-                 * we don't have much ways to alert from here\n-                 * result is losing an entry and unicity guarantee\n-                 *\/\n-                ret = -1;\n-            }\n-        }\n-#ifdef DEBUG_GROW\n-        nbElem++;\n-#endif\n-    }\n-\n-    for (i = 0; i < oldsize; i++) {\n-        iter = olddict[i].next;\n-        while (iter) {\n-            next = iter->next;\n-\n-            \/*\n-             * put back the entry in the new dict\n-             *\/\n-\n-            if (keep_keys)\n-                okey = iter->okey;\n-            else\n-                okey = xmlDictComputeKey(dict, iter->name, iter->len);\n-            key = okey % dict->size;\n-            if (dict->dict[key].valid == 0) {\n-                memcpy(&(dict->dict[key]), iter, sizeof(xmlDictEntry));\n-                dict->dict[key].next = NULL;\n-                dict->dict[key].valid = 1;\n-                dict->dict[key].okey = okey;\n-                xmlFree(iter);\n-            } else {\n-                iter->next = dict->dict[key].next;\n-                iter->okey = okey;\n-                dict->dict[key].next = iter;\n-            }\n-\n-#ifdef DEBUG_GROW\n-            nbElem++;\n-#endif\n-\n-            iter = next;\n-        }\n-    }\n-\n-    xmlFree(olddict);\n-\n-#ifdef DEBUG_GROW\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"xmlDictGrow : from %lu to %lu, %u elems\\n\", oldsize, size, nbElem);\n-#endif\n-\n-    return(ret);\n-}\n-\n@@ -804,4 +334,0 @@\n-    size_t i;\n-    xmlDictEntryPtr iter;\n-    xmlDictEntryPtr next;\n-    int inside_dict = 0;\n@@ -813,4 +339,0 @@\n-    if (!xmlDictInitialized)\n-        if (!__xmlInitializeDict())\n-            return;\n-\n@@ -818,1 +340,1 @@\n-    xmlMutexLock(xmlDictMutex);\n+    xmlMutexLock(&xmlDictMutex);\n@@ -821,1 +343,1 @@\n-        xmlMutexUnlock(xmlDictMutex);\n+        xmlMutexUnlock(&xmlDictMutex);\n@@ -825,1 +347,1 @@\n-    xmlMutexUnlock(xmlDictMutex);\n+    xmlMutexUnlock(&xmlDictMutex);\n@@ -831,16 +353,2 @@\n-    if (dict->dict) {\n-        for(i = 0; ((i < dict->size) && (dict->nbElems > 0)); i++) {\n-            iter = &(dict->dict[i]);\n-            if (iter->valid == 0)\n-                continue;\n-            inside_dict = 1;\n-            while (iter) {\n-                next = iter->next;\n-                if (!inside_dict)\n-                    xmlFree(iter);\n-                dict->nbElems--;\n-                inside_dict = 0;\n-                iter = next;\n-            }\n-        }\n-        xmlFree(dict->dict);\n+    if (dict->table) {\n+        xmlFree(dict->table);\n@@ -858,1 +366,1 @@\n- * xmlDictLookup:\n+ * xmlDictOwns:\n@@ -860,2 +368,1 @@\n- * @name: the name of the userdata\n- * @len: the length of the name, if -1 it is recomputed\n+ * @str: the string\n@@ -863,1 +370,1 @@\n- * Add the @name to the dictionary @dict if not present.\n+ * check if a string is owned by the dictionary\n@@ -865,1 +372,2 @@\n- * Returns the internal copy of the name or NULL in case of internal error\n+ * Returns 1 if true, 0 if false and -1 in case of error\n+ * -1 in case of error\n@@ -867,119 +375,3 @@\n-const xmlChar *\n-xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {\n-    unsigned long key, okey, nbi = 0;\n-    xmlDictEntryPtr entry;\n-    xmlDictEntryPtr insert;\n-    const xmlChar *ret;\n-    unsigned int l;\n-\n-    if ((dict == NULL) || (name == NULL))\n-        return(NULL);\n-\n-    if (len < 0)\n-        l = strlen((const char *) name);\n-    else\n-        l = len;\n-\n-    if (((dict->limit > 0) && (l >= dict->limit)) ||\n-        (l > INT_MAX \/ 2))\n-        return(NULL);\n-\n-    \/*\n-     * Check for duplicate and insertion location.\n-     *\/\n-    okey = xmlDictComputeKey(dict, name, l);\n-    key = okey % dict->size;\n-    if (dict->dict[key].valid == 0) {\n-        insert = NULL;\n-    } else {\n-        for (insert = &(dict->dict[key]); insert->next != NULL;\n-             insert = insert->next) {\n-#ifdef __GNUC__\n-            if ((insert->okey == okey) && (insert->len == l)) {\n-                if (!memcmp(insert->name, name, l))\n-                    return(insert->name);\n-            }\n-#else\n-            if ((insert->okey == okey) && (insert->len == l) &&\n-                (!xmlStrncmp(insert->name, name, l)))\n-                return(insert->name);\n-#endif\n-            nbi++;\n-        }\n-#ifdef __GNUC__\n-        if ((insert->okey == okey) && (insert->len == l)) {\n-            if (!memcmp(insert->name, name, l))\n-                return(insert->name);\n-        }\n-#else\n-        if ((insert->okey == okey) && (insert->len == l) &&\n-            (!xmlStrncmp(insert->name, name, l)))\n-            return(insert->name);\n-#endif\n-    }\n-\n-    if (dict->subdict) {\n-        unsigned long skey;\n-\n-        \/* we cannot always reuse the same okey for the subdict *\/\n-        if (((dict->size == MIN_DICT_SIZE) &&\n-             (dict->subdict->size != MIN_DICT_SIZE)) ||\n-            ((dict->size != MIN_DICT_SIZE) &&\n-             (dict->subdict->size == MIN_DICT_SIZE)))\n-            skey = xmlDictComputeKey(dict->subdict, name, l);\n-        else\n-            skey = okey;\n-\n-        key = skey % dict->subdict->size;\n-        if (dict->subdict->dict[key].valid != 0) {\n-            xmlDictEntryPtr tmp;\n-\n-            for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n-                 tmp = tmp->next) {\n-#ifdef __GNUC__\n-                if ((tmp->okey == skey) && (tmp->len == l)) {\n-                    if (!memcmp(tmp->name, name, l))\n-                        return(tmp->name);\n-                }\n-#else\n-                if ((tmp->okey == skey) && (tmp->len == l) &&\n-                    (!xmlStrncmp(tmp->name, name, l)))\n-                    return(tmp->name);\n-#endif\n-                nbi++;\n-            }\n-#ifdef __GNUC__\n-            if ((tmp->okey == skey) && (tmp->len == l)) {\n-                if (!memcmp(tmp->name, name, l))\n-                    return(tmp->name);\n-            }\n-#else\n-            if ((tmp->okey == skey) && (tmp->len == l) &&\n-                (!xmlStrncmp(tmp->name, name, l)))\n-                return(tmp->name);\n-#endif\n-        }\n-        key = okey % dict->size;\n-    }\n-\n-    ret = xmlDictAddString(dict, name, l);\n-    if (ret == NULL)\n-        return(NULL);\n-    if (insert == NULL) {\n-        entry = &(dict->dict[key]);\n-    } else {\n-        entry = xmlMalloc(sizeof(xmlDictEntry));\n-        if (entry == NULL)\n-             return(NULL);\n-    }\n-    entry->name = ret;\n-    entry->len = l;\n-    entry->next = NULL;\n-    entry->valid = 1;\n-    entry->okey = okey;\n-\n-\n-    if (insert != NULL)\n-        insert->next = entry;\n-\n-    dict->nbElems++;\n+int\n+xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {\n+    xmlDictStringsPtr pool;\n@@ -987,4 +379,7 @@\n-    if ((nbi > MAX_HASH_LEN) &&\n-        (dict->size <= ((MAX_DICT_HASH \/ 2) \/ MAX_HASH_LEN))) {\n-        if (xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size) != 0)\n-            return(NULL);\n+    if ((dict == NULL) || (str == NULL))\n+        return(-1);\n+    pool = dict->strings;\n+    while (pool != NULL) {\n+        if ((str >= &pool->array[0]) && (str <= pool->free))\n+            return(1);\n+        pool = pool->next;\n@@ -992,3 +387,3 @@\n-    \/* Note that entry may have been freed at this point by xmlDictGrow *\/\n-\n-    return(ret);\n+    if (dict->subdict)\n+        return(xmlDictOwns(dict->subdict, str));\n+    return(0);\n@@ -998,1 +393,1 @@\n- * xmlDictExists:\n+ * xmlDictSize:\n@@ -1000,2 +395,0 @@\n- * @name: the name of the userdata\n- * @len: the length of the name, if -1 it is recomputed\n@@ -1003,1 +396,1 @@\n- * Check if the @name exists in the dictionary @dict.\n+ * Query the number of elements installed in the hash @dict.\n@@ -1005,1 +398,2 @@\n- * Returns the internal copy of the name or NULL if not found.\n+ * Returns the number of elements in the dictionary or\n+ * -1 in case of error\n@@ -1007,8 +401,8 @@\n-const xmlChar *\n-xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len) {\n-    unsigned long key, okey, nbi = 0;\n-    xmlDictEntryPtr insert;\n-    unsigned int l;\n-\n-    if ((dict == NULL) || (name == NULL))\n-        return(NULL);\n+int\n+xmlDictSize(xmlDictPtr dict) {\n+    if (dict == NULL)\n+        return(-1);\n+    if (dict->subdict)\n+        return(dict->nbElems + dict->subdict->nbElems);\n+    return(dict->nbElems);\n+}\n@@ -1016,7 +410,93 @@\n-    if (len < 0)\n-        l = strlen((const char *) name);\n-    else\n-        l = len;\n-    if (((dict->limit > 0) && (l >= dict->limit)) ||\n-        (l > INT_MAX \/ 2))\n-        return(NULL);\n+\/**\n+ * xmlDictSetLimit:\n+ * @dict: the dictionary\n+ * @limit: the limit in bytes\n+ *\n+ * Set a size limit for the dictionary\n+ * Added in 2.9.0\n+ *\n+ * Returns the previous limit of the dictionary or 0\n+ *\/\n+size_t\n+xmlDictSetLimit(xmlDictPtr dict, size_t limit) {\n+    size_t ret;\n+\n+    if (dict == NULL)\n+        return(0);\n+    ret = dict->limit;\n+    dict->limit = limit;\n+    return(ret);\n+}\n+\n+\/**\n+ * xmlDictGetUsage:\n+ * @dict: the dictionary\n+ *\n+ * Get how much memory is used by a dictionary for strings\n+ * Added in 2.9.0\n+ *\n+ * Returns the amount of strings allocated\n+ *\/\n+size_t\n+xmlDictGetUsage(xmlDictPtr dict) {\n+    xmlDictStringsPtr pool;\n+    size_t limit = 0;\n+\n+    if (dict == NULL)\n+        return(0);\n+    pool = dict->strings;\n+    while (pool != NULL) {\n+        limit += pool->size;\n+        pool = pool->next;\n+    }\n+    return(limit);\n+}\n+\n+\/*****************************************************************\n+ *\n+ * The code below was rewritten and is additionally licensed under\n+ * the main license in file 'Copyright'.\n+ *\n+ *****************************************************************\/\n+\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static unsigned\n+xmlDictHashName(unsigned seed, const xmlChar* data, size_t maxLen,\n+                size_t *plen) {\n+    unsigned h1, h2;\n+    size_t i;\n+\n+    HASH_INIT(h1, h2, seed);\n+\n+    for (i = 0; i < maxLen && data[i]; i++) {\n+        HASH_UPDATE(h1, h2, data[i]);\n+    }\n+\n+    HASH_FINISH(h1, h2);\n+\n+    *plen = i;\n+    return(h2 | MAX_HASH_SIZE);\n+}\n+\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static unsigned\n+xmlDictHashQName(unsigned seed, const xmlChar *prefix, const xmlChar *name,\n+                 size_t *pplen, size_t *plen) {\n+    unsigned h1, h2;\n+    size_t i;\n+\n+    HASH_INIT(h1, h2, seed);\n+\n+    for (i = 0; prefix[i] != 0; i++) {\n+        HASH_UPDATE(h1, h2, prefix[i]);\n+    }\n+    *pplen = i;\n+\n+    HASH_UPDATE(h1, h2, ':');\n+\n+    for (i = 0; name[i] != 0; i++) {\n+        HASH_UPDATE(h1, h2, name[i]);\n+    }\n+    *plen = i;\n+\n+    HASH_FINISH(h1, h2);\n@@ -1025,1 +505,2 @@\n-     * Check for duplicate and insertion location.\n+     * Always set the upper bit of hash values since 0 means an unoccupied\n+     * bucket.\n@@ -1027,30 +508,2 @@\n-    okey = xmlDictComputeKey(dict, name, l);\n-    key = okey % dict->size;\n-    if (dict->dict[key].valid == 0) {\n-        insert = NULL;\n-    } else {\n-        for (insert = &(dict->dict[key]); insert->next != NULL;\n-             insert = insert->next) {\n-#ifdef __GNUC__\n-            if ((insert->okey == okey) && (insert->len == l)) {\n-                if (!memcmp(insert->name, name, l))\n-                    return(insert->name);\n-            }\n-#else\n-            if ((insert->okey == okey) && (insert->len == l) &&\n-                (!xmlStrncmp(insert->name, name, l)))\n-                return(insert->name);\n-#endif\n-            nbi++;\n-        }\n-#ifdef __GNUC__\n-        if ((insert->okey == okey) && (insert->len == l)) {\n-            if (!memcmp(insert->name, name, l))\n-                return(insert->name);\n-        }\n-#else\n-        if ((insert->okey == okey) && (insert->len == l) &&\n-            (!xmlStrncmp(insert->name, name, l)))\n-            return(insert->name);\n-#endif\n-    }\n+    return(h2 | MAX_HASH_SIZE);\n+}\n@@ -1058,2 +511,5 @@\n-    if (dict->subdict) {\n-        unsigned long skey;\n+unsigned\n+xmlDictComputeHash(const xmlDict *dict, const xmlChar *string) {\n+    size_t len;\n+    return(xmlDictHashName(dict->seed, string, SIZE_MAX, &len));\n+}\n@@ -1061,19 +517,66 @@\n-        \/* we cannot always reuse the same okey for the subdict *\/\n-        if (((dict->size == MIN_DICT_SIZE) &&\n-             (dict->subdict->size != MIN_DICT_SIZE)) ||\n-            ((dict->size != MIN_DICT_SIZE) &&\n-             (dict->subdict->size == MIN_DICT_SIZE)))\n-            skey = xmlDictComputeKey(dict->subdict, name, l);\n-        else\n-            skey = okey;\n-\n-        key = skey % dict->subdict->size;\n-        if (dict->subdict->dict[key].valid != 0) {\n-            xmlDictEntryPtr tmp;\n-\n-            for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n-                 tmp = tmp->next) {\n-#ifdef __GNUC__\n-                if ((tmp->okey == skey) && (tmp->len == l)) {\n-                    if (!memcmp(tmp->name, name, l))\n-                        return(tmp->name);\n+#define HASH_ROL31(x,n) ((x) << (n) | ((x) & 0x7FFFFFFF) >> (31 - (n)))\n+\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+unsigned\n+xmlDictCombineHash(unsigned v1, unsigned v2) {\n+    \/*\n+     * The upper bit of hash values is always set, so we have to operate on\n+     * 31-bit hashes here.\n+     *\/\n+    v1 ^= v2;\n+    v1 += HASH_ROL31(v2, 5);\n+\n+    return((v1 & 0xFFFFFFFF) | 0x80000000);\n+}\n+\n+\/**\n+ * xmlDictFindEntry:\n+ * @dict: dict\n+ * @prefix: optional QName prefix\n+ * @name: string\n+ * @len: length of string\n+ * @hashValue: valid hash value of string\n+ * @pfound: result of search\n+ *\n+ * Try to find a matching hash table entry. If an entry was found, set\n+ * @found to 1 and return the entry. Otherwise, set @found to 0 and return\n+ * the location where a new entry should be inserted.\n+ *\/\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static xmlDictEntry *\n+xmlDictFindEntry(const xmlDict *dict, const xmlChar *prefix,\n+                 const xmlChar *name, int len, unsigned hashValue,\n+                 int *pfound) {\n+    xmlDictEntry *entry;\n+    unsigned mask, pos, displ;\n+    int found = 0;\n+\n+    mask = dict->size - 1;\n+    pos = hashValue & mask;\n+    entry = &dict->table[pos];\n+\n+    if (entry->hashValue != 0) {\n+        \/*\n+         * Robin hood hashing: abort if the displacement of the entry\n+         * is smaller than the displacement of the key we look for.\n+         * This also stops at the correct position when inserting.\n+         *\/\n+        displ = 0;\n+\n+        do {\n+            if (entry->hashValue == hashValue) {\n+                if (prefix == NULL) {\n+                    \/*\n+                     * name is not necessarily null-terminated.\n+                     *\/\n+                    if ((strncmp((const char *) entry->name,\n+                                 (const char *) name, len) == 0) &&\n+                        (entry->name[len] == 0)) {\n+                        found = 1;\n+                        break;\n+                    }\n+                } else {\n+                    if (xmlStrQEqual(prefix, name, entry->name)) {\n+                        found = 1;\n+                        break;\n+                    }\n@@ -1081,11 +584,0 @@\n-#else\n-                if ((tmp->okey == skey) && (tmp->len == l) &&\n-                    (!xmlStrncmp(tmp->name, name, l)))\n-                    return(tmp->name);\n-#endif\n-                nbi++;\n-            }\n-#ifdef __GNUC__\n-            if ((tmp->okey == skey) && (tmp->len == l)) {\n-                if (!memcmp(tmp->name, name, l))\n-                    return(tmp->name);\n@@ -1093,6 +585,8 @@\n-#else\n-            if ((tmp->okey == skey) && (tmp->len == l) &&\n-                (!xmlStrncmp(tmp->name, name, l)))\n-                return(tmp->name);\n-#endif\n-        }\n+\n+            displ++;\n+            pos++;\n+            entry++;\n+            if ((pos & mask) == 0)\n+                entry = dict->table;\n+        } while ((entry->hashValue != 0) &&\n+                 (((pos - entry->hashValue) & mask) >= displ));\n@@ -1101,2 +595,2 @@\n-    \/* not found *\/\n-    return(NULL);\n+    *pfound = found;\n+    return(entry);\n@@ -1106,4 +600,3 @@\n- * xmlDictQLookup:\n- * @dict: the dictionary\n- * @prefix: the prefix\n- * @name: the name\n+ * xmlDictGrow:\n+ * @dict: dictionary\n+ * @size: new size of the dictionary\n@@ -1111,1 +604,1 @@\n- * Add the QName @prefix:@name to the hash @dict if not present.\n+ * Resize the dictionary hash table.\n@@ -1113,1 +606,1 @@\n- * Returns the internal copy of the QName or NULL in case of internal error\n+ * Returns 0 in case of success, -1 if a memory allocation failed.\n@@ -1115,5 +608,73 @@\n-const xmlChar *\n-xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {\n-    unsigned long okey, key, nbi = 0;\n-    xmlDictEntryPtr entry;\n-    xmlDictEntryPtr insert;\n+static int\n+xmlDictGrow(xmlDictPtr dict, unsigned size) {\n+    const xmlDictEntry *oldentry, *oldend, *end;\n+    xmlDictEntry *table;\n+    unsigned oldsize, i;\n+\n+    \/* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC *\/\n+    if ((size_t) size + 0 > SIZE_MAX \/ sizeof(table[0]))\n+        return(-1);\n+    table = xmlMalloc(size * sizeof(table[0]));\n+    if (table == NULL)\n+        return(-1);\n+    memset(table, 0, size * sizeof(table[0]));\n+\n+    oldsize = dict->size;\n+    if (oldsize == 0)\n+        goto done;\n+\n+    oldend = &dict->table[oldsize];\n+    end = &table[size];\n+\n+    \/*\n+     * Robin Hood sorting order is maintained if we\n+     *\n+     * - compute dict indices with modulo\n+     * - resize by an integer factor\n+     * - start to copy from the beginning of a probe sequence\n+     *\/\n+    oldentry = dict->table;\n+    while (oldentry->hashValue != 0) {\n+        if (++oldentry >= oldend)\n+            oldentry = dict->table;\n+    }\n+\n+    for (i = 0; i < oldsize; i++) {\n+        if (oldentry->hashValue != 0) {\n+            xmlDictEntry *entry = &table[oldentry->hashValue & (size - 1)];\n+\n+            while (entry->hashValue != 0) {\n+                if (++entry >= end)\n+                    entry = table;\n+            }\n+            *entry = *oldentry;\n+        }\n+\n+        if (++oldentry >= oldend)\n+            oldentry = dict->table;\n+    }\n+\n+    xmlFree(dict->table);\n+\n+done:\n+    dict->table = table;\n+    dict->size = size;\n+\n+    return(0);\n+}\n+\n+\/**\n+ * xmlDictLookupInternal:\n+ * @dict: dict\n+ * @prefix: optional QName prefix\n+ * @name: string\n+ * @maybeLen: length of string or -1 if unknown\n+ * @update: whether the string should be added\n+ *\n+ * Internal lookup and update function.\n+ *\/\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static const xmlDictEntry *\n+xmlDictLookupInternal(xmlDictPtr dict, const xmlChar *prefix,\n+                      const xmlChar *name, int maybeLen, int update) {\n+    xmlDictEntry *entry = NULL;\n@@ -1121,1 +682,3 @@\n-    unsigned int len, plen, l;\n+    unsigned hashValue;\n+    size_t maxLen, len, plen, klen;\n+    int found = 0;\n@@ -1125,2 +688,0 @@\n-    if (prefix == NULL)\n-        return(xmlDictLookup(dict, name, -1));\n@@ -1128,3 +689,1 @@\n-    l = len = strlen((const char *) name);\n-    plen = strlen((const char *) prefix);\n-    len += 1 + plen;\n+    maxLen = (maybeLen < 0) ? SIZE_MAX : (size_t) maybeLen;\n@@ -1132,7 +691,5 @@\n-    \/*\n-     * Check for duplicate and insertion location.\n-     *\/\n-    okey = xmlDictComputeQKey(dict, prefix, plen, name, l);\n-    key = okey % dict->size;\n-    if (dict->dict[key].valid == 0) {\n-        insert = NULL;\n+    if (prefix == NULL) {\n+        hashValue = xmlDictHashName(dict->seed, name, maxLen, &len);\n+        if (len > INT_MAX \/ 2)\n+            return(NULL);\n+        klen = len;\n@@ -1140,10 +697,4 @@\n-        for (insert = &(dict->dict[key]); insert->next != NULL;\n-             insert = insert->next) {\n-            if ((insert->okey == okey) && (insert->len == len) &&\n-                (xmlStrQEqual(prefix, name, insert->name)))\n-                return(insert->name);\n-            nbi++;\n-        }\n-        if ((insert->okey == okey) && (insert->len == len) &&\n-            (xmlStrQEqual(prefix, name, insert->name)))\n-            return(insert->name);\n+        hashValue = xmlDictHashQName(dict->seed, prefix, name, &plen, &len);\n+        if ((len > INT_MAX \/ 2) || (plen >= INT_MAX \/ 2 - len))\n+            return(NULL);\n+        klen = plen + 1 + len;\n@@ -1152,2 +703,2 @@\n-    if (dict->subdict) {\n-        unsigned long skey;\n+    if ((dict->limit > 0) && (klen >= dict->limit))\n+        return(NULL);\n@@ -1155,6 +706,15 @@\n-        \/* we cannot always reuse the same okey for the subdict *\/\n-        if (((dict->size == MIN_DICT_SIZE) &&\n-             (dict->subdict->size != MIN_DICT_SIZE)) ||\n-            ((dict->size != MIN_DICT_SIZE) &&\n-             (dict->subdict->size == MIN_DICT_SIZE)))\n-            skey = xmlDictComputeQKey(dict->subdict, prefix, plen, name, l);\n+    \/*\n+     * Check for an existing entry\n+     *\/\n+    if (dict->size > 0)\n+        entry = xmlDictFindEntry(dict, prefix, name, klen, hashValue, &found);\n+    if (found)\n+        return(entry);\n+\n+    if ((dict->subdict != NULL) && (dict->subdict->size > 0)) {\n+        xmlDictEntry *subEntry;\n+        unsigned subHashValue;\n+\n+        if (prefix == NULL)\n+            subHashValue = xmlDictHashName(dict->subdict->seed, name, len,\n+                                           &len);\n@@ -1162,15 +722,42 @@\n-            skey = okey;\n-\n-        key = skey % dict->subdict->size;\n-        if (dict->subdict->dict[key].valid != 0) {\n-            xmlDictEntryPtr tmp;\n-            for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n-                 tmp = tmp->next) {\n-                if ((tmp->okey == skey) && (tmp->len == len) &&\n-                    (xmlStrQEqual(prefix, name, tmp->name)))\n-                    return(tmp->name);\n-                nbi++;\n-            }\n-            if ((tmp->okey == skey) && (tmp->len == len) &&\n-                (xmlStrQEqual(prefix, name, tmp->name)))\n-                return(tmp->name);\n+            subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,\n+                                            &plen, &len);\n+        subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,\n+                                    subHashValue, &found);\n+        if (found)\n+            return(subEntry);\n+    }\n+\n+    if (!update)\n+        return(NULL);\n+\n+    \/*\n+     * Grow the hash table if needed\n+     *\/\n+    if (dict->nbElems + 1 > dict->size \/ MAX_FILL_DENOM * MAX_FILL_NUM) {\n+        unsigned newSize, mask, displ, pos;\n+\n+        if (dict->size == 0) {\n+            newSize = MIN_HASH_SIZE;\n+        } else {\n+            if (dict->size >= MAX_HASH_SIZE)\n+                return(NULL);\n+            newSize = dict->size * 2;\n+        }\n+        if (xmlDictGrow(dict, newSize) != 0)\n+            return(NULL);\n+\n+        \/*\n+         * Find new entry\n+         *\/\n+        mask = dict->size - 1;\n+        displ = 0;\n+        pos = hashValue & mask;\n+        entry = &dict->table[pos];\n+\n+        while ((entry->hashValue != 0) &&\n+               ((pos - entry->hashValue) & mask) >= displ) {\n+            displ++;\n+            pos++;\n+            entry++;\n+            if ((pos & mask) == 0)\n+                entry = dict->table;\n@@ -1178,1 +765,0 @@\n-        key = okey % dict->size;\n@@ -1181,1 +767,4 @@\n-    ret = xmlDictAddQString(dict, prefix, plen, name, l);\n+    if (prefix == NULL)\n+        ret = xmlDictAddString(dict, name, len);\n+    else\n+        ret = xmlDictAddQString(dict, prefix, plen, name, len);\n@@ -1184,6 +773,26 @@\n-    if (insert == NULL) {\n-        entry = &(dict->dict[key]);\n-    } else {\n-        entry = xmlMalloc(sizeof(xmlDictEntry));\n-        if (entry == NULL)\n-             return(NULL);\n+\n+    \/*\n+     * Shift the remainder of the probe sequence to the right\n+     *\/\n+    if (entry->hashValue != 0) {\n+        const xmlDictEntry *end = &dict->table[dict->size];\n+        const xmlDictEntry *cur = entry;\n+\n+        do {\n+            cur++;\n+            if (cur >= end)\n+                cur = dict->table;\n+        } while (cur->hashValue != 0);\n+\n+        if (cur < entry) {\n+            \/*\n+             * If we traversed the end of the buffer, handle the part\n+             * at the start of the buffer.\n+             *\/\n+            memmove(&dict->table[1], dict->table,\n+                    (char *) cur - (char *) dict->table);\n+            cur = end - 1;\n+            dict->table[0] = *cur;\n+        }\n+\n+        memmove(&entry[1], entry, (char *) cur - (char *) entry);\n@@ -1191,5 +800,0 @@\n-    entry->name = ret;\n-    entry->len = len;\n-    entry->next = NULL;\n-    entry->valid = 1;\n-    entry->okey = okey;\n@@ -1197,2 +801,5 @@\n-    if (insert != NULL)\n-        insert->next = entry;\n+    \/*\n+     * Populate entry\n+     *\/\n+    entry->hashValue = hashValue;\n+    entry->name = ret;\n@@ -1202,6 +809,1 @@\n-    if ((nbi > MAX_HASH_LEN) &&\n-        (dict->size <= ((MAX_DICT_HASH \/ 2) \/ MAX_HASH_LEN)))\n-        xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size);\n-    \/* Note that entry may have been freed at this point by xmlDictGrow *\/\n-\n-    return(ret);\n+    return(entry);\n@@ -1211,3 +813,4 @@\n- * xmlDictOwns:\n- * @dict: the dictionary\n- * @str: the string\n+ * xmlDictLookup:\n+ * @dict: dictionary\n+ * @name: string key\n+ * @len: length of the key, if -1 it is recomputed\n@@ -1215,1 +818,1 @@\n- * check if a string is owned by the dictionary\n+ * Lookup a string and add it to the dictionary if it wasn't found.\n@@ -1217,2 +820,2 @@\n- * Returns 1 if true, 0 if false and -1 in case of error\n- * -1 in case of error\n+ * Returns the interned copy of the string or NULL if a memory allocation\n+ * failed.\n@@ -1220,3 +823,3 @@\n-int\n-xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {\n-    xmlDictStringsPtr pool;\n+const xmlChar *\n+xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {\n+    const xmlDictEntry *entry;\n@@ -1224,11 +827,4 @@\n-    if ((dict == NULL) || (str == NULL))\n-        return(-1);\n-    pool = dict->strings;\n-    while (pool != NULL) {\n-        if ((str >= &pool->array[0]) && (str <= pool->free))\n-            return(1);\n-        pool = pool->next;\n-    }\n-    if (dict->subdict)\n-        return(xmlDictOwns(dict->subdict, str));\n-    return(0);\n+    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);\n+    if (entry == NULL)\n+        return(NULL);\n+    return(entry->name);\n@@ -1238,2 +834,4 @@\n- * xmlDictSize:\n- * @dict: the dictionary\n+ * xmlDictLookupHashed:\n+ * @dict: dictionary\n+ * @name: string key\n+ * @len: length of the key, if -1 it is recomputed\n@@ -1241,1 +839,2 @@\n- * Query the number of elements installed in the hash @dict.\n+ * Lookup a dictionary entry and add the string to the dictionary if\n+ * it wasn't found.\n@@ -1243,2 +842,1 @@\n- * Returns the number of elements in the dictionary or\n- * -1 in case of error\n+ * Returns the dictionary entry.\n@@ -1246,7 +844,15 @@\n-int\n-xmlDictSize(xmlDictPtr dict) {\n-    if (dict == NULL)\n-        return(-1);\n-    if (dict->subdict)\n-        return(dict->nbElems + dict->subdict->nbElems);\n-    return(dict->nbElems);\n+xmlHashedString\n+xmlDictLookupHashed(xmlDictPtr dict, const xmlChar *name, int len) {\n+    const xmlDictEntry *entry;\n+    xmlHashedString ret;\n+\n+    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);\n+\n+    if (entry == NULL) {\n+        ret.name = NULL;\n+        ret.hashValue = 0;\n+    } else {\n+        ret = *entry;\n+    }\n+\n+    return(ret);\n@@ -1256,1 +862,1 @@\n- * xmlDictSetLimit:\n+ * xmlDictExists:\n@@ -1258,1 +864,2 @@\n- * @limit: the limit in bytes\n+ * @name: the name of the userdata\n+ * @len: the length of the name, if -1 it is recomputed\n@@ -1260,2 +867,1 @@\n- * Set a size limit for the dictionary\n- * Added in 2.9.0\n+ * Check if a string exists in the dictionary.\n@@ -1263,1 +869,1 @@\n- * Returns the previous limit of the dictionary or 0\n+ * Returns the internal copy of the name or NULL if not found.\n@@ -1265,3 +871,3 @@\n-size_t\n-xmlDictSetLimit(xmlDictPtr dict, size_t limit) {\n-    size_t ret;\n+const xmlChar *\n+xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len) {\n+    const xmlDictEntry *entry;\n@@ -1269,5 +875,4 @@\n-    if (dict == NULL)\n-        return(0);\n-    ret = dict->limit;\n-    dict->limit = limit;\n-    return(ret);\n+    entry = xmlDictLookupInternal(dict, NULL, name, len, 0);\n+    if (entry == NULL)\n+        return(NULL);\n+    return(entry->name);\n@@ -1277,1 +882,1 @@\n- * xmlDictGetUsage:\n+ * xmlDictQLookup:\n@@ -1279,0 +884,2 @@\n+ * @prefix: the prefix\n+ * @name: the name\n@@ -1280,2 +887,2 @@\n- * Get how much memory is used by a dictionary for strings\n- * Added in 2.9.0\n+ * Lookup the QName @prefix:@name and add it to the dictionary if\n+ * it wasn't found.\n@@ -1283,1 +890,2 @@\n- * Returns the amount of strings allocated\n+ * Returns the interned copy of the string or NULL if a memory allocation\n+ * failed.\n@@ -1285,4 +893,3 @@\n-size_t\n-xmlDictGetUsage(xmlDictPtr dict) {\n-    xmlDictStringsPtr pool;\n-    size_t limit = 0;\n+const xmlChar *\n+xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {\n+    const xmlDictEntry *entry;\n@@ -1290,6 +897,62 @@\n-    if (dict == NULL)\n-        return(0);\n-    pool = dict->strings;\n-    while (pool != NULL) {\n-        limit += pool->size;\n-        pool = pool->next;\n+    entry = xmlDictLookupInternal(dict, prefix, name, -1, 1);\n+    if (entry == NULL)\n+        return(NULL);\n+    return(entry->name);\n+}\n+\n+\/*\n+ * Pseudo-random generator\n+ *\/\n+\n+static xmlMutex xmlRngMutex;\n+\n+static unsigned globalRngState[2];\n+\n+#ifdef XML_THREAD_LOCAL\n+static XML_THREAD_LOCAL int localRngInitialized = 0;\n+static XML_THREAD_LOCAL unsigned localRngState[2];\n+#endif\n+\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+void\n+xmlInitRandom(void) {\n+    int var;\n+\n+    xmlInitMutex(&xmlRngMutex);\n+\n+    \/* TODO: Get seed values from system PRNG *\/\n+\n+    globalRngState[0] = (unsigned) time(NULL) ^\n+                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);\n+    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^\n+                        HASH_ROL((unsigned) (size_t) &var, 24);\n+}\n+\n+void\n+xmlCleanupRandom(void) {\n+    xmlCleanupMutex(&xmlRngMutex);\n+}\n+\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static unsigned\n+xoroshiro64ss(unsigned *s) {\n+    unsigned s0 = s[0];\n+    unsigned s1 = s[1];\n+    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;\n+\n+    s1 ^= s0;\n+    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);\n+    s[1] = HASH_ROL(s1, 13);\n+\n+    return(result & 0xFFFFFFFF);\n+}\n+\n+unsigned\n+xmlRandom(void) {\n+#ifdef XML_THREAD_LOCAL\n+    if (!localRngInitialized) {\n+        xmlMutexLock(&xmlRngMutex);\n+        localRngState[0] = xoroshiro64ss(globalRngState);\n+        localRngState[1] = xoroshiro64ss(globalRngState);\n+        localRngInitialized = 1;\n+        xmlMutexUnlock(&xmlRngMutex);\n@@ -1297,1 +960,11 @@\n-    return(limit);\n+\n+    return(xoroshiro64ss(localRngState));\n+#else\n+    unsigned ret;\n+\n+    xmlMutexLock(&xmlRngMutex);\n+    ret = xoroshiro64ss(globalRngState);\n+    xmlMutexUnlock(&xmlRngMutex);\n+\n+    return(ret);\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/dict.c","additions":600,"deletions":927,"binary":false,"changes":1527,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include <libxml\/parser.h>\n@@ -40,1 +41,0 @@\n-#include <libxml\/globals.h>\n@@ -43,2 +43,3 @@\n-#include \"buf.h\"\n-#include \"enc.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/enc.h\"\n+#include \"private\/error.h\"\n@@ -60,3 +61,0 @@\n-static xmlCharEncodingHandlerPtr xmlUTF16LEHandler = NULL;\n-static xmlCharEncodingHandlerPtr xmlUTF16BEHandler = NULL;\n-\n@@ -74,10 +72,0 @@\n-#if defined(LIBXML_ICONV_ENABLED) || defined(LIBXML_ICU_ENABLED)\n-#if 0\n-#define DEBUG_ENCODING  \/* Define this to get encoding traces *\/\n-#endif\n-#else\n-#ifdef LIBXML_ISO8859X_ENABLED\n-static void xmlRegisterCharEncodingHandlersISO8859x (void);\n-#endif\n-#endif\n-\n@@ -86,27 +74,0 @@\n-\/**\n- * xmlEncodingErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlEncodingErrMemory(const char *extra)\n-{\n-    __xmlSimpleError(XML_FROM_I18N, XML_ERR_NO_MEMORY, NULL, NULL, extra);\n-}\n-\n-\/**\n- * xmlErrEncoding:\n- * @error:  the error number\n- * @msg:  the error message\n- *\n- * n encoding error\n- *\/\n-static void LIBXML_ATTR_FORMAT(2,0)\n-xmlEncodingErr(xmlParserErrors error, const char *msg, const char *val)\n-{\n-    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL,\n-                    XML_FROM_I18N, error, XML_ERR_FATAL,\n-                    NULL, 0, val, NULL, NULL, 0, 0, msg, val);\n-}\n-\n@@ -179,1 +140,3 @@\n- * Returns 0 if success, or -1 otherwise\n+ *\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -205,1 +168,1 @@\n-            return(-1);\n+            return(XML_ENC_ERR_INPUT);\n@@ -226,1 +189,2 @@\n- * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -242,1 +206,2 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);\n+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -260,1 +225,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -268,1 +233,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -291,1 +256,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -310,1 +275,3 @@\n- * Returns the number of bytes written if success, or -1 otherwise\n+ *\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -325,1 +292,1 @@\n-        return(-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -359,1 +326,2 @@\n- * Returns the number of bytes written, or -1 if lack of space.\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -370,1 +338,1 @@\n-        return(-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -383,1 +351,1 @@\n-        return(-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -409,2 +377,2 @@\n- * Returns the number of bytes written if success, -2 if the transcoding fails,\n-           or -1 otherwise\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -426,1 +394,2 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);\n+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -444,1 +413,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -452,1 +421,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -465,1 +434,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -480,1 +449,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -502,4 +471,4 @@\n- * Returns the number of bytes written, or -1 if lack of space, or -2\n- *     if the transcoding fails (if *in is not a valid utf16 string)\n- *     The value of *inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n+ * The value of *inlen after return is the number of octets consumed\n+ * if the return value is positive, else unpredictable.\n@@ -514,1 +483,1 @@\n-    unsigned short* in = (unsigned short*) inb;\n+    unsigned short* in = (unsigned short *) (void *) inb;\n@@ -535,1 +504,1 @@\n-            c = c | (((unsigned int)*tmp) << 8);\n+            c = c | (*tmp << 8);\n@@ -547,1 +516,1 @@\n-                d = d | (((unsigned int)*tmp) << 8);\n+                d = d | (*tmp << 8);\n@@ -559,1 +528,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -594,2 +563,1 @@\n- * Returns the number of bytes written, or -1 if lack of space, or -2\n- *     if the transcoding failed.\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -601,1 +569,1 @@\n-    unsigned short* out = (unsigned short*) outb;\n+    unsigned short* out = (unsigned short *) (void *) outb;\n@@ -613,1 +581,2 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);\n+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -628,1 +597,1 @@\n-          return(-2);\n+          return(XML_ENC_ERR_INPUT);\n@@ -636,1 +605,1 @@\n-        return(-2);\n+        return(XML_ENC_ERR_INPUT);\n@@ -658,1 +627,1 @@\n-                *tmp = c ;\n+                *tmp = (unsigned char) c; \/* Explicit truncation *\/\n@@ -673,1 +642,1 @@\n-                *tmp = (unsigned char) tmp1;\n+                *tmp = (unsigned char) tmp1; \/* Explicit truncation *\/\n@@ -679,1 +648,1 @@\n-                *tmp  = (unsigned char) tmp2;\n+                *tmp  = (unsigned char) tmp2; \/* Explicit truncation *\/\n@@ -703,2 +672,1 @@\n- * Returns the number of bytes written, or -1 if lack of space, or -2\n- *     if the transcoding failed.\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -719,4 +687,0 @@\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Added FFFE Byte Order Mark\\n\");\n-#endif\n@@ -745,2 +709,2 @@\n- * Returns the number of bytes written, or -1 if lack of space, or -2\n- *     if the transcoding fails (if *in is not a valid utf16 string)\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -748,1 +712,1 @@\n- *     if the return value is positive, else unpredictable.\n+ * if the return value is positive, else unpredictable.\n@@ -757,1 +721,1 @@\n-    unsigned short* in = (unsigned short*) inb;\n+    unsigned short* in = (unsigned short *) (void *) inb;\n@@ -776,1 +740,1 @@\n-            c = (c << 8) | (unsigned int) *tmp;\n+            c = (c << 8) | *tmp;\n@@ -788,1 +752,1 @@\n-                d = (d << 8) | (unsigned int) *tmp;\n+                d = (d << 8) | *tmp;\n@@ -802,1 +766,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -837,2 +801,1 @@\n- * Returns the number of byte written, or -1 by lack of space, or -2\n- *     if the transcoding failed.\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -844,1 +807,1 @@\n-    unsigned short* out = (unsigned short*) outb;\n+    unsigned short* out = (unsigned short *) (void *) outb;\n@@ -856,1 +819,2 @@\n-    if ((outb == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);\n+    if ((outb == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -871,1 +835,1 @@\n-          return(-2);\n+          return(XML_ENC_ERR_INPUT);\n@@ -879,1 +843,1 @@\n-          return(-2);\n+          return(XML_ENC_ERR_INPUT);\n@@ -898,1 +862,1 @@\n-                *(tmp + 1) = c;\n+                *(tmp + 1) = (unsigned char) c; \/* Explicit truncation *\/\n@@ -911,1 +875,1 @@\n-                *(tmp + 1) = (unsigned char) tmp1;\n+                *(tmp + 1) = (unsigned char) tmp1; \/* Explicit truncation *\/\n@@ -917,1 +881,1 @@\n-                *(tmp + 1) = (unsigned char) tmp2;\n+                *(tmp + 1) = (unsigned char) tmp2; \/* Explicit truncation *\/\n@@ -1050,1 +1014,1 @@\n-        upper[i] = toupper(alias[i]);\n+        upper[i] = (char) toupper((unsigned char) alias[i]);\n@@ -1080,0 +1044,1 @@\n+    char *nameCopy, *aliasCopy;\n@@ -1085,1 +1050,1 @@\n-        upper[i] = toupper(alias[i]);\n+        upper[i] = (char) toupper((unsigned char) alias[i]);\n@@ -1090,10 +1055,7 @@\n-    if (xmlCharEncodingAliases == NULL) {\n-        xmlCharEncodingAliasesNb = 0;\n-        xmlCharEncodingAliasesMax = 20;\n-        xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)\n-              xmlMalloc(xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));\n-        if (xmlCharEncodingAliases == NULL)\n-            return(-1);\n-    } else if (xmlCharEncodingAliasesNb >= xmlCharEncodingAliasesMax) {\n-        xmlCharEncodingAliasesMax *= 2;\n-        xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)\n+    if (xmlCharEncodingAliasesNb >= xmlCharEncodingAliasesMax) {\n+        xmlCharEncodingAliasPtr tmp;\n+        size_t newSize = xmlCharEncodingAliasesMax ?\n+                         xmlCharEncodingAliasesMax * 2 :\n+                         20;\n+\n+        tmp = (xmlCharEncodingAliasPtr)\n@@ -1101,1 +1063,5 @@\n-                         xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));\n+                         newSize * sizeof(xmlCharEncodingAlias));\n+        if (tmp == NULL)\n+            return(-1);\n+        xmlCharEncodingAliases = tmp;\n+        xmlCharEncodingAliasesMax = newSize;\n@@ -1103,0 +1069,1 @@\n+\n@@ -1111,0 +1078,3 @@\n+            nameCopy = xmlMemStrdup(name);\n+            if (nameCopy == NULL)\n+                return(-1);\n@@ -1112,1 +1082,1 @@\n-            xmlCharEncodingAliases[i].name = xmlMemStrdup(name);\n+            xmlCharEncodingAliases[i].name = nameCopy;\n@@ -1119,2 +1089,10 @@\n-    xmlCharEncodingAliases[xmlCharEncodingAliasesNb].name = xmlMemStrdup(name);\n-    xmlCharEncodingAliases[xmlCharEncodingAliasesNb].alias = xmlMemStrdup(upper);\n+    nameCopy = xmlMemStrdup(name);\n+    if (nameCopy == NULL)\n+        return(-1);\n+    aliasCopy = xmlMemStrdup(upper);\n+    if (aliasCopy == NULL) {\n+        xmlFree(nameCopy);\n+        return(-1);\n+    }\n+    xmlCharEncodingAliases[xmlCharEncodingAliasesNb].name = nameCopy;\n+    xmlCharEncodingAliases[xmlCharEncodingAliasesNb].alias = aliasCopy;\n@@ -1187,1 +1165,1 @@\n-        upper[i] = toupper(name[i]);\n+        upper[i] = (char) toupper((unsigned char) name[i]);\n@@ -1236,3 +1214,0 @@\n-#ifdef DEBUG_ENCODING\n-    xmlGenericError(xmlGenericErrorContext, \"Unknown encoding %s\\n\", name);\n-#endif\n@@ -1314,0 +1289,88 @@\n+#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \\\n+    defined(LIBXML_ISO8859X_ENABLED)\n+\n+#define DECLARE_ISO_FUNCS(n) \\\n+    static int ISO8859_##n##ToUTF8(unsigned char* out, int *outlen, \\\n+                                   const unsigned char* in, int *inlen); \\\n+    static int UTF8ToISO8859_##n(unsigned char* out, int *outlen, \\\n+                                 const unsigned char* in, int *inlen);\n+\n+\/** DOC_DISABLE *\/\n+DECLARE_ISO_FUNCS(2)\n+DECLARE_ISO_FUNCS(3)\n+DECLARE_ISO_FUNCS(4)\n+DECLARE_ISO_FUNCS(5)\n+DECLARE_ISO_FUNCS(6)\n+DECLARE_ISO_FUNCS(7)\n+DECLARE_ISO_FUNCS(8)\n+DECLARE_ISO_FUNCS(9)\n+DECLARE_ISO_FUNCS(10)\n+DECLARE_ISO_FUNCS(11)\n+DECLARE_ISO_FUNCS(13)\n+DECLARE_ISO_FUNCS(14)\n+DECLARE_ISO_FUNCS(15)\n+DECLARE_ISO_FUNCS(16)\n+\/** DOC_ENABLE *\/\n+\n+#endif \/* LIBXML_ISO8859X_ENABLED *\/\n+\n+#ifdef LIBXML_ICONV_ENABLED\n+  #define EMPTY_ICONV , (iconv_t) 0, (iconv_t) 0\n+#else\n+  #define EMPTY_ICONV\n+#endif\n+\n+#ifdef LIBXML_ICU_ENABLED\n+  #define EMPTY_UCONV , NULL, NULL\n+#else\n+  #define EMPTY_UCONV\n+#endif\n+\n+#define MAKE_HANDLER(name, in, out) \\\n+    { (char *) name, in, out EMPTY_ICONV EMPTY_UCONV }\n+\n+static const xmlCharEncodingHandler defaultHandlers[] = {\n+    MAKE_HANDLER(\"UTF-8\", UTF8ToUTF8, UTF8ToUTF8)\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    ,MAKE_HANDLER(\"UTF-16LE\", UTF16LEToUTF8, UTF8ToUTF16LE)\n+    ,MAKE_HANDLER(\"UTF-16BE\", UTF16BEToUTF8, UTF8ToUTF16BE)\n+    ,MAKE_HANDLER(\"UTF-16\", UTF16LEToUTF8, UTF8ToUTF16)\n+    ,MAKE_HANDLER(\"ISO-8859-1\", isolat1ToUTF8, UTF8Toisolat1)\n+    ,MAKE_HANDLER(\"ASCII\", asciiToUTF8, UTF8Toascii)\n+    ,MAKE_HANDLER(\"US-ASCII\", asciiToUTF8, UTF8Toascii)\n+#ifdef LIBXML_HTML_ENABLED\n+    ,MAKE_HANDLER(\"HTML\", NULL, UTF8ToHtml)\n+#endif\n+#else\n+    ,MAKE_HANDLER(\"UTF-16LE\", UTF16LEToUTF8, NULL)\n+    ,MAKE_HANDLER(\"UTF-16BE\", UTF16BEToUTF8, NULL)\n+    ,MAKE_HANDLER(\"UTF-16\", UTF16LEToUTF8, NULL)\n+    ,MAKE_HANDLER(\"ISO-8859-1\", isolat1ToUTF8, NULL)\n+    ,MAKE_HANDLER(\"ASCII\", asciiToUTF8, NULL)\n+    ,MAKE_HANDLER(\"US-ASCII\", asciiToUTF8, NULL)\n+#endif \/* LIBXML_OUTPUT_ENABLED *\/\n+\n+#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \\\n+    defined(LIBXML_ISO8859X_ENABLED)\n+    ,MAKE_HANDLER(\"ISO-8859-2\", ISO8859_2ToUTF8, UTF8ToISO8859_2)\n+    ,MAKE_HANDLER(\"ISO-8859-3\", ISO8859_3ToUTF8, UTF8ToISO8859_3)\n+    ,MAKE_HANDLER(\"ISO-8859-4\", ISO8859_4ToUTF8, UTF8ToISO8859_4)\n+    ,MAKE_HANDLER(\"ISO-8859-5\", ISO8859_5ToUTF8, UTF8ToISO8859_5)\n+    ,MAKE_HANDLER(\"ISO-8859-6\", ISO8859_6ToUTF8, UTF8ToISO8859_6)\n+    ,MAKE_HANDLER(\"ISO-8859-7\", ISO8859_7ToUTF8, UTF8ToISO8859_7)\n+    ,MAKE_HANDLER(\"ISO-8859-8\", ISO8859_8ToUTF8, UTF8ToISO8859_8)\n+    ,MAKE_HANDLER(\"ISO-8859-9\", ISO8859_9ToUTF8, UTF8ToISO8859_9)\n+    ,MAKE_HANDLER(\"ISO-8859-10\", ISO8859_10ToUTF8, UTF8ToISO8859_10)\n+    ,MAKE_HANDLER(\"ISO-8859-11\", ISO8859_11ToUTF8, UTF8ToISO8859_11)\n+    ,MAKE_HANDLER(\"ISO-8859-13\", ISO8859_13ToUTF8, UTF8ToISO8859_13)\n+    ,MAKE_HANDLER(\"ISO-8859-14\", ISO8859_14ToUTF8, UTF8ToISO8859_14)\n+    ,MAKE_HANDLER(\"ISO-8859-15\", ISO8859_15ToUTF8, UTF8ToISO8859_15)\n+    ,MAKE_HANDLER(\"ISO-8859-16\", ISO8859_16ToUTF8, UTF8ToISO8859_16)\n+#endif\n+};\n+\n+#define NUM_DEFAULT_HANDLERS \\\n+    (sizeof(defaultHandlers) \/ sizeof(defaultHandlers[0]))\n+\n+static const xmlCharEncodingHandler *xmlUTF16LEHandler = &defaultHandlers[1];\n+static const xmlCharEncodingHandler *xmlUTF16BEHandler = &defaultHandlers[2];\n@@ -1320,7 +1383,0 @@\n-\/*\n- * The default is UTF-8 for XML, that's also the default used for the\n- * parser internals, so the default encoding handler is NULL\n- *\/\n-\n-static xmlCharEncodingHandlerPtr xmlDefaultCharEncodingHandler = NULL;\n-\n@@ -1357,3 +1413,1 @@\n-    if (name == NULL) {\n-        xmlEncodingErr(XML_I18N_NO_NAME,\n-                       \"xmlNewCharEncodingHandler : no name !\\n\", NULL);\n+    if (name == NULL)\n@@ -1361,1 +1415,0 @@\n-    }\n@@ -1363,1 +1416,1 @@\n-        upper[i] = toupper(name[i]);\n+        upper[i] = (char) toupper((unsigned char) name[i]);\n@@ -1368,2 +1421,1 @@\n-    if (up == NULL) {\n-        xmlEncodingErrMemory(\"xmlNewCharEncodingHandler : out of memory !\\n\");\n+    if (up == NULL)\n@@ -1371,1 +1423,0 @@\n-    }\n@@ -1380,1 +1431,0 @@\n-        xmlEncodingErrMemory(\"xmlNewCharEncodingHandler : out of memory !\\n\");\n@@ -1401,4 +1451,0 @@\n-#ifdef DEBUG_ENCODING\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Registered encoding handler for %s\\n\", name);\n-#endif\n@@ -1411,7 +1457,1 @@\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n- * initialize the library.\n- *\n- * Initialize the char encoding support, it registers the default\n- * encoding supported.\n- * NOTE: while public, this function usually doesn't need to be called\n- *       in normal processing.\n+ * DEPRECATED: Alias for xmlInitParser.\n@@ -1421,0 +1461,10 @@\n+    xmlInitParser();\n+}\n+\n+\/**\n+ * xmlInitEncodingInternal:\n+ *\n+ * Initialize the char encoding support.\n+ *\/\n+void\n+xmlInitEncodingInternal(void) {\n@@ -1424,5 +1474,0 @@\n-    if (handlers != NULL) return;\n-\n-    handlers = (xmlCharEncodingHandlerPtr *)\n-        xmlMalloc(MAX_ENCODING_HANDLERS * sizeof(xmlCharEncodingHandlerPtr));\n-\n@@ -1430,39 +1475,1 @@\n-    else if (*ptr == 0x34) xmlLittleEndian = 1;\n-    else {\n-        xmlEncodingErr(XML_ERR_INTERNAL_ERROR,\n-                       \"Odd problem at endianness detection\\n\", NULL);\n-    }\n-\n-    if (handlers == NULL) {\n-        xmlEncodingErrMemory(\"xmlInitCharEncodingHandlers : out of memory !\\n\");\n-        return;\n-    }\n-    xmlNewCharEncodingHandler(\"UTF-8\", UTF8ToUTF8, UTF8ToUTF8);\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    xmlUTF16LEHandler =\n-          xmlNewCharEncodingHandler(\"UTF-16LE\", UTF16LEToUTF8, UTF8ToUTF16LE);\n-    xmlUTF16BEHandler =\n-          xmlNewCharEncodingHandler(\"UTF-16BE\", UTF16BEToUTF8, UTF8ToUTF16BE);\n-    xmlNewCharEncodingHandler(\"UTF-16\", UTF16LEToUTF8, UTF8ToUTF16);\n-    xmlNewCharEncodingHandler(\"ISO-8859-1\", isolat1ToUTF8, UTF8Toisolat1);\n-    xmlNewCharEncodingHandler(\"ASCII\", asciiToUTF8, UTF8Toascii);\n-    xmlNewCharEncodingHandler(\"US-ASCII\", asciiToUTF8, UTF8Toascii);\n-#ifdef LIBXML_HTML_ENABLED\n-    xmlNewCharEncodingHandler(\"HTML\", NULL, UTF8ToHtml);\n-#endif\n-#else\n-    xmlUTF16LEHandler =\n-          xmlNewCharEncodingHandler(\"UTF-16LE\", UTF16LEToUTF8, NULL);\n-    xmlUTF16BEHandler =\n-          xmlNewCharEncodingHandler(\"UTF-16BE\", UTF16BEToUTF8, NULL);\n-    xmlNewCharEncodingHandler(\"UTF-16\", UTF16LEToUTF8, NULL);\n-    xmlNewCharEncodingHandler(\"ISO-8859-1\", isolat1ToUTF8, NULL);\n-    xmlNewCharEncodingHandler(\"ASCII\", asciiToUTF8, NULL);\n-    xmlNewCharEncodingHandler(\"US-ASCII\", asciiToUTF8, NULL);\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED)\n-#ifdef LIBXML_ISO8859X_ENABLED\n-    xmlRegisterCharEncodingHandlersISO8859x ();\n-#endif\n-#endif\n-\n+    else xmlLittleEndian = 1;\n@@ -1499,1 +1506,0 @@\n-    xmlDefaultCharEncodingHandler = NULL;\n@@ -1510,5 +1516,6 @@\n-    if (handlers == NULL) xmlInitCharEncodingHandlers();\n-    if ((handler == NULL) || (handlers == NULL)) {\n-        xmlEncodingErr(XML_I18N_NO_HANDLER,\n-                \"xmlRegisterCharEncodingHandler: NULL handler !\\n\", NULL);\n-        goto free_handler;\n+    if (handler == NULL)\n+        return;\n+    if (handlers == NULL) {\n+        handlers = xmlMalloc(MAX_ENCODING_HANDLERS * sizeof(handlers[0]));\n+        if (handlers == NULL)\n+            goto free_handler;\n@@ -1517,4 +1524,1 @@\n-    if (nbCharEncodingHandler >= MAX_ENCODING_HANDLERS) {\n-        xmlEncodingErr(XML_I18N_EXCESS_HANDLER,\n-        \"xmlRegisterCharEncodingHandler: Too many handler registered, see %s\\n\",\n-                       \"MAX_ENCODING_HANDLERS\");\n+    if (nbCharEncodingHandler >= MAX_ENCODING_HANDLERS)\n@@ -1522,1 +1526,0 @@\n-    }\n@@ -1547,1 +1550,0 @@\n-    if (handlers == NULL) xmlInitCharEncodingHandlers();\n@@ -1556,1 +1558,1 @@\n-            return(xmlUTF16LEHandler);\n+            return((xmlCharEncodingHandlerPtr) xmlUTF16LEHandler);\n@@ -1558,1 +1560,1 @@\n-            return(xmlUTF16BEHandler);\n+            return((xmlCharEncodingHandlerPtr) xmlUTF16BEHandler);\n@@ -1662,4 +1664,0 @@\n-#ifdef DEBUG_ENCODING\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"No handler found for encoding %d\\n\", enc);\n-#endif\n@@ -1673,1 +1671,2 @@\n- * Search in the registered set the handler able to read\/write that encoding.\n+ * Search in the registered set the handler able to read\/write that encoding\n+ * or create a new one.\n@@ -1693,3 +1692,2 @@\n-    if (handlers == NULL) xmlInitCharEncodingHandlers();\n-    if (name == NULL) return(xmlDefaultCharEncodingHandler);\n-    if (name[0] == 0) return(xmlDefaultCharEncodingHandler);\n+    if (name == NULL) return(NULL);\n+    if (name[0] == 0) return(NULL);\n@@ -1709,1 +1707,1 @@\n-        upper[i] = toupper(name[i]);\n+        upper[i] = (char) toupper((unsigned char) name[i]);\n@@ -1714,0 +1712,5 @@\n+    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {\n+        if (strcmp(upper, defaultHandlers[i].name) == 0)\n+            return((xmlCharEncodingHandlerPtr) &defaultHandlers[i]);\n+    }\n+\n@@ -1717,4 +1720,0 @@\n-#ifdef DEBUG_ENCODING\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"Found registered handler for encoding %s\\n\", name);\n-#endif\n@@ -1746,0 +1745,6 @@\n+            if (enc->name == NULL) {\n+                xmlFree(enc);\n+                iconv_close(icv_in);\n+                iconv_close(icv_out);\n+                return(NULL);\n+            }\n@@ -1750,4 +1755,0 @@\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Found iconv handler for encoding %s\\n\", name);\n-#endif\n@@ -1756,2 +1757,0 @@\n-            xmlEncodingErr(XML_ERR_INTERNAL_ERROR,\n-                    \"iconv : problems with filters for '%s'\\n\", name);\n@@ -1778,0 +1777,6 @@\n+            if (encu->name == NULL) {\n+                xmlFree(encu);\n+                closeIcuConverter(ucv_in);\n+                closeIcuConverter(ucv_out);\n+                return(NULL);\n+            }\n@@ -1782,4 +1787,0 @@\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Found ICU converter handler for encoding %s\\n\", name);\n-#endif\n@@ -1790,2 +1791,0 @@\n-            xmlEncodingErr(XML_ERR_INTERNAL_ERROR,\n-                    \"ICU converter : problems with filters for '%s'\\n\", name);\n@@ -1795,5 +1794,0 @@\n-#ifdef DEBUG_ENCODING\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"No handler found for encoding %s\\n\", name);\n-#endif\n-\n@@ -1831,5 +1825,1 @@\n- * Returns 0 if success, or\n- *     -1 by lack of space, or\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n- *     -3 if there the last byte can't form a single output char.\n+ * Returns an XML_ENC_ERR code.\n@@ -1851,1 +1841,1 @@\n-        return(-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -1861,19 +1851,8 @@\n-    if ((icv_inlen != 0) || (ret == (size_t) -1)) {\n-#ifdef EILSEQ\n-        if (errno == EILSEQ) {\n-            return -2;\n-        } else\n-#endif\n-#ifdef E2BIG\n-        if (errno == E2BIG) {\n-            return -1;\n-        } else\n-#endif\n-#ifdef EINVAL\n-        if (errno == EINVAL) {\n-            return -3;\n-        } else\n-#endif\n-        {\n-            return -3;\n-        }\n+    if (ret == (size_t) -1) {\n+        if (errno == EILSEQ)\n+            return(XML_ENC_ERR_INPUT);\n+        if (errno == E2BIG)\n+            return(XML_ENC_ERR_SPACE);\n+        if (errno == EINVAL)\n+            return(XML_ENC_ERR_PARTIAL);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -1881,1 +1860,1 @@\n-    return 0;\n+    return(XML_ENC_ERR_SUCCESS);\n@@ -1900,1 +1879,0 @@\n- * @flush: if true, indicates end of input\n@@ -1902,5 +1880,1 @@\n- * Returns 0 if success, or\n- *     -1 by lack of space, or\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n- *     -3 if there the last byte can't form a single output char.\n+ * Returns an XML_ENC_ERR code.\n@@ -1914,1 +1888,1 @@\n-                const unsigned char *in, int *inlen, int flush) {\n+                const unsigned char *in, int *inlen) {\n@@ -1921,1 +1895,1 @@\n-        return(-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -1924,0 +1898,14 @@\n+    \/*\n+     * Note that the ICU API is stateful. It can always consume a certain\n+     * amount of input even if the output buffer would overflow. The\n+     * remaining input must be processed by calling ucnv_convertEx with a\n+     * possibly empty input buffer.\n+     *\n+     * ucnv_convertEx is always called with reset and flush set to 0,\n+     * so we don't mess up the state. This should never generate\n+     * U_TRUNCATED_CHAR_FOUND errors.\n+     *\n+     * This also means that ICU xmlCharEncodingHandlers should never be\n+     * reused. It would be a lot nicer if there was a way to emulate the\n+     * stateless iconv API.\n+     *\/\n@@ -1929,1 +1917,1 @@\n-                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, flush, &err);\n+                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, 0, &err);\n@@ -1935,1 +1923,1 @@\n-                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, flush, &err);\n+                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, 0, &err);\n@@ -1940,4 +1928,1 @@\n-        \/* reset pivot buf if this is the last call for input (flush==TRUE) *\/\n-        if (flush)\n-            cd->pivot_source = cd->pivot_target = cd->pivot_buf;\n-        return 0;\n+        return(XML_ENC_ERR_SUCCESS);\n@@ -1946,1 +1931,1 @@\n-        return -1;\n+        return(XML_ENC_ERR_SPACE);\n@@ -1948,2 +1933,2 @@\n-        return -2;\n-    return -3;\n+        return(XML_ENC_ERR_INPUT);\n+    return(XML_ENC_ERR_PARTIAL);\n@@ -1959,0 +1944,28 @@\n+\/**\n+ * xmlEncConvertError:\n+ * @code:  XML_ENC_ERR code\n+ *\n+ * Convert XML_ENC_ERR to libxml2 error codes.\n+ *\/\n+static int\n+xmlEncConvertError(int code) {\n+    int ret;\n+\n+    switch (code) {\n+        case XML_ENC_ERR_SUCCESS:\n+            ret = XML_ERR_OK;\n+            break;\n+        case XML_ENC_ERR_INPUT:\n+            ret = XML_ERR_INVALID_ENCODING;\n+            break;\n+        case XML_ENC_ERR_MEMORY:\n+            ret = XML_ERR_NO_MEMORY;\n+            break;\n+        default:\n+            ret = XML_ERR_INTERNAL_ERROR;\n+            break;\n+    }\n+\n+    return(ret);\n+}\n+\n@@ -1966,7 +1979,0 @@\n- * @flush:  flush (ICU-related)\n- *\n- * Returns 0 if success, or\n- *     -1 by lack of space, or\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n- *     -3 if there the last byte can't form a single output char.\n@@ -1977,0 +1983,2 @@\n+ *\n+ * Returns an XML_ENC_ERR code.\n@@ -1978,1 +1986,1 @@\n-static int\n+int\n@@ -1980,1 +1988,1 @@\n-                 int *outlen, const unsigned char *in, int *inlen, int flush) {\n+                 int *outlen, const unsigned char *in, int *inlen) {\n@@ -1982,1 +1990,0 @@\n-    (void)flush;\n@@ -1985,0 +1992,2 @@\n+        int oldinlen = *inlen;\n+\n@@ -1986,2 +1995,13 @@\n-        if (ret > 0)\n-           ret = 0;\n+        if (ret >= 0) {\n+            \/*\n+             * The built-in converters don't signal XML_ENC_ERR_SPACE.\n+             *\/\n+            if (*inlen < oldinlen) {\n+                if (*outlen > 0)\n+                    ret = XML_ENC_ERR_SPACE;\n+                else\n+                    ret = XML_ENC_ERR_PARTIAL;\n+            } else {\n+                ret = XML_ENC_ERR_SUCCESS;\n+            }\n+        }\n@@ -1996,2 +2016,1 @@\n-        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen,\n-                              flush);\n+        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);\n@@ -2003,1 +2022,1 @@\n-        ret = -2;\n+        ret = XML_ENC_ERR_INTERNAL;\n@@ -2006,0 +2025,4 @@\n+    \/* Ignore partial errors when reading. *\/\n+    if (ret == XML_ENC_ERR_PARTIAL)\n+        ret = XML_ENC_ERR_SUCCESS;\n+\n@@ -2017,6 +2040,1 @@\n- * Returns 0 if success, or\n- *     -1 by lack of space, or\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n- *     -3 if there the last byte can't form a single output char.\n- *     -4 if no output function was found.\n+ * Returns an XML_ENC_ERR code.\n@@ -2034,0 +2052,2 @@\n+        int oldinlen = *inlen;\n+\n@@ -2035,2 +2055,13 @@\n-        if (ret > 0)\n-           ret = 0;\n+        if (ret >= 0) {\n+            \/*\n+             * The built-in converters don't signal XML_ENC_ERR_SPACE.\n+             *\/\n+            if (*inlen < oldinlen) {\n+                if (*outlen > 0)\n+                    ret = XML_ENC_ERR_SPACE;\n+                else\n+                    ret = XML_ENC_ERR_PARTIAL;\n+            } else {\n+                ret = XML_ENC_ERR_SUCCESS;\n+            }\n+        }\n@@ -2045,2 +2076,1 @@\n-        ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen,\n-                              1);\n+        ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen);\n@@ -2052,1 +2082,1 @@\n-        ret = -4;\n+        ret = XML_ENC_ERR_INTERNAL;\n@@ -2055,51 +2085,3 @@\n-    return(ret);\n-}\n-\n-\/**\n- * xmlCharEncFirstLineInt:\n- * @handler:    char encoding transformation data structure\n- * @out:  an xmlBuffer for the output.\n- * @in:  an xmlBuffer for the input\n- * @len:  number of bytes to convert for the first line, or -1\n- *\n- * Front-end for the encoding handler input function, but handle only\n- * the very first line, i.e. limit itself to 45 chars.\n- *\n- * Returns the number of byte written if success, or\n- *     -1 general error\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n- *\/\n-int\n-xmlCharEncFirstLineInt(xmlCharEncodingHandler *handler, xmlBufferPtr out,\n-                       xmlBufferPtr in, int len) {\n-    int ret;\n-    int written;\n-    int toconv;\n-\n-    if (handler == NULL) return(-1);\n-    if (out == NULL) return(-1);\n-    if (in == NULL) return(-1);\n-\n-    \/* calculate space available *\/\n-    written = out->size - out->use - 1; \/* count '\\0' *\/\n-    toconv = in->use;\n-    \/*\n-     * echo '<?xml version=\"1.0\" encoding=\"UCS4\"?>' | wc -c => 38\n-     * 45 chars should be sufficient to reach the end of the encoding\n-     * declaration without going too far inside the document content.\n-     * on UTF-16 this means 90bytes, on UCS4 this means 180\n-     * The actual value depending on guessed encoding is passed as @len\n-     * if provided\n-     *\/\n-    if (len >= 0) {\n-        if (toconv > len)\n-            toconv = len;\n-    } else {\n-        if (toconv > 180)\n-            toconv = 180;\n-    }\n-    if (toconv * 2 >= written) {\n-        xmlBufferGrow(out, toconv * 2);\n-        written = out->size - out->use - 1;\n-    }\n+    \/* We shouldn't generate partial sequences when writing. *\/\n+    if (ret == XML_ENC_ERR_PARTIAL)\n+        ret = XML_ENC_ERR_INTERNAL;\n@@ -2107,36 +2089,1 @@\n-    ret = xmlEncInputChunk(handler, &out->content[out->use], &written,\n-                           in->content, &toconv, 0);\n-    xmlBufferShrink(in, toconv);\n-    out->use += written;\n-    out->content[out->use] = 0;\n-    if (ret == -1) ret = -3;\n-\n-#ifdef DEBUG_ENCODING\n-    switch (ret) {\n-        case 0:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"converted %d bytes to %d bytes of input\\n\",\n-                    toconv, written);\n-            break;\n-        case -1:\n-            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n-                    toconv, written, in->use);\n-            break;\n-        case -2:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"input conversion failed due to input error\\n\");\n-            break;\n-        case -3:\n-            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n-                    toconv, written, in->use);\n-            break;\n-        default:\n-            xmlGenericError(xmlGenericErrorContext,\"Unknown input conversion failed %d\\n\", ret);\n-    }\n-#endif \/* DEBUG_ENCODING *\/\n-    \/*\n-     * Ignore when input buffer is not on a boundary\n-     *\/\n-    if (ret == -3) ret = 0;\n-    if (ret == -1) ret = 0;\n-    return(written ? written : ret);\n+    return(ret);\n@@ -2147,1 +2094,1 @@\n- * @handler:    char encoding transformation data structure\n+ * @handler:   char encoding transformation data structure\n@@ -2151,2 +2098,1 @@\n- * Front-end for the encoding handler input function, but handle only\n- * the very first line, i.e. limit itself to 45 chars.\n+ * DEPERECATED: Don't use.\n@@ -2154,4 +2100,1 @@\n- * Returns the number of byte written if success, or\n- *     -1 general error\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -2161,2 +2104,2 @@\n-                 xmlBufferPtr in) {\n-    return(xmlCharEncFirstLineInt(handler, out, in, -1));\n+                    xmlBufferPtr in) {\n+    return(xmlCharEncInFunc(handler, out, in));\n@@ -2166,1 +2109,1 @@\n- * xmlCharEncFirstLineInput:\n+ * xmlCharEncInput:\n@@ -2168,1 +2111,0 @@\n- * @len:  number of bytes to convert for the first line, or -1\n@@ -2170,4 +2112,1 @@\n- * Front-end for the encoding handler input function, but handle only\n- * the very first line. Point is that this is based on autodetection\n- * of the encoding and once that first line is converted we may find\n- * out that a different decoder is needed to process the input.\n+ * Generic front-end for the encoding handler on parser input\n@@ -2175,4 +2114,1 @@\n- * Returns the number of byte written if success, or\n- *     -1 general error\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -2181,1 +2117,1 @@\n-xmlCharEncFirstLineInput(xmlParserInputBufferPtr input, int len)\n+xmlCharEncInput(xmlParserInputBufferPtr input)\n@@ -2184,1 +2120,1 @@\n-    size_t written;\n+    size_t avail;\n@@ -2190,0 +2126,2 @@\n+    const xmlChar *inData;\n+    size_t inTotal = 0;\n@@ -2193,1 +2131,1 @@\n-        return (-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2200,65 +2138,15 @@\n-    written = xmlBufAvail(out);\n-    \/*\n-     * echo '<?xml version=\"1.0\" encoding=\"UCS4\"?>' | wc -c => 38\n-     * 45 chars should be sufficient to reach the end of the encoding\n-     * declaration without going too far inside the document content.\n-     * on UTF-16 this means 90bytes, on UCS4 this means 180\n-     * The actual value depending on guessed encoding is passed as @len\n-     * if provided\n-     *\/\n-    if (len >= 0) {\n-        if (toconv > (unsigned int) len)\n-            toconv = len;\n-    } else {\n-        if (toconv > 180)\n-            toconv = 180;\n-    }\n-    if (toconv * 2 >= written) {\n-        xmlBufGrow(out, toconv * 2);\n-        written = xmlBufAvail(out);\n-    }\n-    if (written > 360)\n-        written = 360;\n-\n-    c_in = toconv;\n-    c_out = written;\n-    ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,\n-                           xmlBufContent(in), &c_in, 0);\n-    xmlBufShrink(in, c_in);\n-    xmlBufAddLen(out, c_out);\n-    if (ret == -1)\n-        ret = -3;\n-\n-    switch (ret) {\n-        case 0:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"converted %d bytes to %d bytes of input\\n\",\n-                            c_in, c_out);\n-#endif\n-            break;\n-        case -1:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                         \"converted %d bytes to %d bytes of input, %d left\\n\",\n-                            c_in, c_out, (int)xmlBufUse(in));\n-#endif\n-            break;\n-        case -3:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                        \"converted %d bytes to %d bytes of input, %d left\\n\",\n-                            c_in, c_out, (int)xmlBufUse(in));\n-#endif\n-            break;\n-        case -2: {\n-            char buf[50];\n-            const xmlChar *content = xmlBufContent(in);\n-\n-            snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-                     content[0], content[1],\n-                     content[2], content[3]);\n-            buf[49] = 0;\n-            xmlEncodingErr(XML_I18N_CONV_FAILED,\n-                    \"input conversion failed due to input error, bytes %s\\n\",\n-                           buf);\n+    inData = xmlBufContent(in);\n+    inTotal = 0;\n+\n+    do {\n+        c_in = toconv > INT_MAX \/ 2 ? INT_MAX \/ 2 : toconv;\n+\n+        avail = xmlBufAvail(out);\n+        if (avail > INT_MAX)\n+            avail = INT_MAX;\n+        if (avail < 4096) {\n+            if (xmlBufGrow(out, 4096) < 0) {\n+                input->error = XML_ERR_NO_MEMORY;\n+                return(XML_ENC_ERR_MEMORY);\n+            }\n+            avail = xmlBufAvail(out);\n@@ -2266,8 +2154,0 @@\n-    }\n-    \/*\n-     * Ignore when input buffer is not on a boundary\n-     *\/\n-    if (ret == -3) ret = 0;\n-    if (ret == -1) ret = 0;\n-    return(c_out ? c_out : ret);\n-}\n@@ -2275,22 +2155,9 @@\n-\/**\n- * xmlCharEncInput:\n- * @input: a parser input buffer\n- * @flush: try to flush all the raw buffer\n- *\n- * Generic front-end for the encoding handler on parser input\n- *\n- * Returns the number of byte written if success, or\n- *     -1 general error\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n- *\/\n-int\n-xmlCharEncInput(xmlParserInputBufferPtr input, int flush)\n-{\n-    int ret;\n-    size_t written;\n-    size_t toconv;\n-    int c_in;\n-    int c_out;\n-    xmlBufPtr in;\n-    xmlBufPtr out;\n+        c_in = toconv;\n+        c_out = avail;\n+        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,\n+                               inData, &c_in);\n+        inTotal += c_in;\n+        inData += c_in;\n+        toconv -= c_in;\n+        xmlBufAddLen(out, c_out);\n+    } while (ret == XML_ENC_ERR_SPACE);\n@@ -2298,5 +2165,1 @@\n-    if ((input == NULL) || (input->encoder == NULL) ||\n-        (input->buffer == NULL) || (input->raw == NULL))\n-        return (-1);\n-    out = input->buffer;\n-    in = input->raw;\n+    xmlBufShrink(in, inTotal);\n@@ -2304,12 +2167,4 @@\n-    toconv = xmlBufUse(in);\n-    if (toconv == 0)\n-        return (0);\n-    if ((toconv > 64 * 1024) && (flush == 0))\n-        toconv = 64 * 1024;\n-    written = xmlBufAvail(out);\n-    if (toconv * 2 >= written) {\n-        xmlBufGrow(out, toconv * 2);\n-        written = xmlBufAvail(out);\n-    }\n-    if ((written > 128 * 1024) && (flush == 0))\n-        written = 128 * 1024;\n+    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)\n+        input->rawconsumed = ULONG_MAX;\n+    else\n+        input->rawconsumed += c_in;\n@@ -2317,43 +2172,4 @@\n-    c_in = toconv;\n-    c_out = written;\n-    ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,\n-                           xmlBufContent(in), &c_in, flush);\n-    xmlBufShrink(in, c_in);\n-    xmlBufAddLen(out, c_out);\n-    if (ret == -1)\n-        ret = -3;\n-\n-    switch (ret) {\n-        case 0:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"converted %d bytes to %d bytes of input\\n\",\n-                            c_in, c_out);\n-#endif\n-            break;\n-        case -1:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                         \"converted %d bytes to %d bytes of input, %d left\\n\",\n-                            c_in, c_out, (int)xmlBufUse(in));\n-#endif\n-            break;\n-        case -3:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                        \"converted %d bytes to %d bytes of input, %d left\\n\",\n-                            c_in, c_out, (int)xmlBufUse(in));\n-#endif\n-            break;\n-        case -2: {\n-            char buf[50];\n-            const xmlChar *content = xmlBufContent(in);\n-\n-            snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-                     content[0], content[1],\n-                     content[2], content[3]);\n-            buf[49] = 0;\n-            xmlEncodingErr(XML_I18N_CONV_FAILED,\n-                    \"input conversion failed due to input error, bytes %s\\n\",\n-                           buf);\n-        }\n+    if ((c_out == 0) && (ret != 0)) {\n+        if (input->error == 0)\n+            input->error = xmlEncConvertError(ret);\n+        return(ret);\n@@ -2361,6 +2177,2 @@\n-    \/*\n-     * Ignore when input buffer is not on a boundary\n-     *\/\n-    if (ret == -3)\n-        ret = 0;\n-    return (c_out? c_out : ret);\n+\n+    return (c_out);\n@@ -2377,4 +2189,1 @@\n- * Returns the number of byte written if success, or\n- *     -1 general error\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -2391,1 +2200,1 @@\n-        return (-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2393,1 +2202,1 @@\n-        return (-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2395,1 +2204,1 @@\n-        return (-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2406,1 +2215,1 @@\n-                           in->content, &toconv, 1);\n+                           in->content, &toconv);\n@@ -2410,42 +2219,1 @@\n-    if (ret == -1)\n-        ret = -3;\n-\n-    switch (ret) {\n-        case 0:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"converted %d bytes to %d bytes of input\\n\",\n-                            toconv, written);\n-#endif\n-            break;\n-        case -1:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                         \"converted %d bytes to %d bytes of input, %d left\\n\",\n-                            toconv, written, in->use);\n-#endif\n-            break;\n-        case -3:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                        \"converted %d bytes to %d bytes of input, %d left\\n\",\n-                            toconv, written, in->use);\n-#endif\n-            break;\n-        case -2: {\n-            char buf[50];\n-\n-            snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-                     in->content[0], in->content[1],\n-                     in->content[2], in->content[3]);\n-            buf[49] = 0;\n-            xmlEncodingErr(XML_I18N_CONV_FAILED,\n-                    \"input conversion failed due to input error, bytes %s\\n\",\n-                           buf);\n-        }\n-    }\n-    \/*\n-     * Ignore when input buffer is not on a boundary\n-     *\/\n-    if (ret == -3)\n-        ret = 0;\n+\n@@ -2468,4 +2236,1 @@\n- * Returns the number of byte written if success, or\n- *     -1 general error\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -2487,1 +2252,1 @@\n-        return (-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2505,4 +2270,0 @@\n-#ifdef DEBUG_ENCODING\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"initialized encoder\\n\");\n-#endif\n@@ -2516,2 +2277,0 @@\n-    if (toconv == 0)\n-        return (writtentot);\n@@ -2534,7 +2293,3 @@\n-    if (ret == -1) {\n-        if (c_out > 0) {\n-            \/* Can be a limitation of iconv or uconv *\/\n-            goto retry;\n-        }\n-        ret = -3;\n-    }\n+\n+    if (ret == XML_ENC_ERR_SPACE)\n+        goto retry;\n@@ -2545,34 +2300,5 @@\n-    switch (ret) {\n-        case 0:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"converted %d bytes to %d bytes of output\\n\",\n-                    c_in, c_out);\n-#endif\n-            break;\n-        case -1:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"output conversion failed by lack of space\\n\");\n-#endif\n-            break;\n-        case -3:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of output %d left\\n\",\n-                    c_in, c_out, (int) xmlBufUse(in));\n-#endif\n-            break;\n-        case -4:\n-            xmlEncodingErr(XML_I18N_NO_OUTPUT,\n-                           \"xmlCharEncOutFunc: no output function !\\n\", NULL);\n-            ret = -1;\n-            break;\n-        case -2: {\n-            xmlChar charref[20];\n-            int len = (int) xmlBufUse(in);\n-            xmlChar *content = xmlBufContent(in);\n-            int cur, charrefLen;\n-\n-            cur = xmlGetUTF8Char(content, &len);\n-            if (cur <= 0)\n-                break;\n+    if (ret == XML_ENC_ERR_INPUT) {\n+        xmlChar charref[20];\n+        int len = xmlBufUse(in);\n+        xmlChar *content = xmlBufContent(in);\n+        int cur, charrefLen;\n@@ -2580,36 +2306,3 @@\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"handling output conversion error\\n\");\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-                    content[0], content[1],\n-                    content[2], content[3]);\n-#endif\n-            \/*\n-             * Removes the UTF8 sequence, and replace it by a charref\n-             * and continue the transcoding phase, hoping the error\n-             * did not mangle the encoder state.\n-             *\/\n-            charrefLen = snprintf((char *) &charref[0], sizeof(charref),\n-                             \"&#%d;\", cur);\n-            xmlBufShrink(in, len);\n-            xmlBufGrow(out, charrefLen * 4);\n-            c_out = xmlBufAvail(out);\n-            c_in = charrefLen;\n-            ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,\n-                                    charref, &c_in);\n-\n-            if ((ret < 0) || (c_in != charrefLen)) {\n-                char buf[50];\n-\n-                snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-                         content[0], content[1],\n-                         content[2], content[3]);\n-                buf[49] = 0;\n-                xmlEncodingErr(XML_I18N_CONV_FAILED,\n-                    \"output conversion failed due to conv error, bytes %s\\n\",\n-                               buf);\n-                if (xmlBufGetAllocationScheme(in) != XML_BUFFER_ALLOC_IMMUTABLE)\n-                    content[0] = ' ';\n-                break;\n-            }\n+        cur = xmlGetUTF8Char(content, &len);\n+        if (cur <= 0)\n+            goto error;\n@@ -2617,3 +2310,16 @@\n-            xmlBufAddLen(out, c_out);\n-            writtentot += c_out;\n-            goto retry;\n+        \/*\n+         * Removes the UTF8 sequence, and replace it by a charref\n+         * and continue the transcoding phase, hoping the error\n+         * did not mangle the encoder state.\n+         *\/\n+        charrefLen = snprintf((char *) &charref[0], sizeof(charref),\n+                         \"&#%d;\", cur);\n+        xmlBufShrink(in, len);\n+        xmlBufGrow(out, charrefLen * 4);\n+        c_out = xmlBufAvail(out);\n+        c_in = charrefLen;\n+        ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,\n+                                charref, &c_in);\n+        if ((ret < 0) || (c_in != charrefLen)) {\n+            ret = XML_ENC_ERR_INTERNAL;\n+            goto error;\n@@ -2621,0 +2327,4 @@\n+\n+        xmlBufAddLen(out, c_out);\n+        writtentot += c_out;\n+        goto retry;\n@@ -2622,1 +2332,9 @@\n-    return(writtentot ? writtentot : ret);\n+\n+error:\n+    if ((writtentot <= 0) && (ret != 0)) {\n+        if (output->error == 0)\n+            output->error = xmlEncConvertError(ret);\n+        return(ret);\n+    }\n+\n+    return(writtentot);\n@@ -2639,4 +2357,1 @@\n- * Returns the number of byte written if success, or\n- *     -1 general error\n- *     -2 if the transcoding fails (for *in is not valid utf8 string or\n- *        the result of transformation can't fit into the encoding we want), or\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -2652,2 +2367,2 @@\n-    if (handler == NULL) return(-1);\n-    if (out == NULL) return(-1);\n+    if (handler == NULL) return(XML_ENC_ERR_INTERNAL);\n+    if (out == NULL) return(XML_ENC_ERR_INTERNAL);\n@@ -2672,4 +2387,0 @@\n-#ifdef DEBUG_ENCODING\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"initialized encoder\\n\");\n-#endif\n@@ -2683,2 +2394,0 @@\n-    if (toconv == 0)\n-        return(0);\n@@ -2695,7 +2404,3 @@\n-    if (ret == -1) {\n-        if (written > 0) {\n-            \/* Can be a limitation of iconv or uconv *\/\n-            goto retry;\n-        }\n-        ret = -3;\n-    }\n+\n+    if (ret == XML_ENC_ERR_SPACE)\n+        goto retry;\n@@ -2706,34 +2411,5 @@\n-    switch (ret) {\n-        case 0:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"converted %d bytes to %d bytes of output\\n\",\n-                    toconv, written);\n-#endif\n-            break;\n-        case -1:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"output conversion failed by lack of space\\n\");\n-#endif\n-            break;\n-        case -3:\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of output %d left\\n\",\n-                    toconv, written, in->use);\n-#endif\n-            break;\n-        case -4:\n-            xmlEncodingErr(XML_I18N_NO_OUTPUT,\n-                           \"xmlCharEncOutFunc: no output function !\\n\", NULL);\n-            ret = -1;\n-            break;\n-        case -2: {\n-            xmlChar charref[20];\n-            int len = in->use;\n-            const xmlChar *utf = (const xmlChar *) in->content;\n-            int cur, charrefLen;\n-\n-            cur = xmlGetUTF8Char(utf, &len);\n-            if (cur <= 0)\n-                break;\n+    if (ret == XML_ENC_ERR_INPUT) {\n+        xmlChar charref[20];\n+        int len = in->use;\n+        const xmlChar *utf = (const xmlChar *) in->content;\n+        int cur, charrefLen;\n@@ -2741,36 +2417,3 @@\n-#ifdef DEBUG_ENCODING\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"handling output conversion error\\n\");\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-                    in->content[0], in->content[1],\n-                    in->content[2], in->content[3]);\n-#endif\n-            \/*\n-             * Removes the UTF8 sequence, and replace it by a charref\n-             * and continue the transcoding phase, hoping the error\n-             * did not mangle the encoder state.\n-             *\/\n-            charrefLen = snprintf((char *) &charref[0], sizeof(charref),\n-                             \"&#%d;\", cur);\n-            xmlBufferShrink(in, len);\n-            xmlBufferGrow(out, charrefLen * 4);\n-            written = out->size - out->use - 1;\n-            toconv = charrefLen;\n-            ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,\n-                                    charref, &toconv);\n-\n-            if ((ret < 0) || (toconv != charrefLen)) {\n-                char buf[50];\n-\n-                snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-                         in->content[0], in->content[1],\n-                         in->content[2], in->content[3]);\n-                buf[49] = 0;\n-                xmlEncodingErr(XML_I18N_CONV_FAILED,\n-                    \"output conversion failed due to conv error, bytes %s\\n\",\n-                               buf);\n-                if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE)\n-                    in->content[0] = ' ';\n-                break;\n-            }\n+        cur = xmlGetUTF8Char(utf, &len);\n+        if (cur <= 0)\n+            return(ret);\n@@ -2778,5 +2421,20 @@\n-            out->use += written;\n-            writtentot += written;\n-            out->content[out->use] = 0;\n-            goto retry;\n-        }\n+        \/*\n+         * Removes the UTF8 sequence, and replace it by a charref\n+         * and continue the transcoding phase, hoping the error\n+         * did not mangle the encoder state.\n+         *\/\n+        charrefLen = snprintf((char *) &charref[0], sizeof(charref),\n+                         \"&#%d;\", cur);\n+        xmlBufferShrink(in, len);\n+        xmlBufferGrow(out, charrefLen * 4);\n+        written = out->size - out->use - 1;\n+        toconv = charrefLen;\n+        ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,\n+                                charref, &toconv);\n+        if ((ret < 0) || (toconv != charrefLen))\n+            return(XML_ENC_ERR_INTERNAL);\n+\n+        out->use += written;\n+        writtentot += written;\n+        out->content[out->use] = 0;\n+        goto retry;\n@@ -2799,4 +2457,1 @@\n-    int i, handler_in_list = 0;\n-\n-    \/* Avoid unused variable warning if features are disabled. *\/\n-    (void) handler_in_list;\n+    int i = 0;\n@@ -2805,1 +2460,6 @@\n-    if (handler->name == NULL) return(-1);\n+\n+    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {\n+        if (handler == &defaultHandlers[i])\n+            return(0);\n+    }\n+\n@@ -2808,4 +2468,2 @@\n-            if (handler == handlers[i]) {\n-                handler_in_list = 1;\n-                break;\n-            }\n+            if (handler == handlers[i])\n+                return(0);\n@@ -2819,2 +2477,1 @@\n-    if ((handler_in_list == 0) &&\n-        ((handler->iconv_out != NULL) || (handler->iconv_in != NULL))) {\n+    if ((handler->iconv_out != NULL) || (handler->iconv_in != NULL)) {\n@@ -2835,2 +2492,1 @@\n-    if ((handler_in_list == 0) &&\n-        ((handler->uconv_out != NULL) || (handler->uconv_in != NULL))) {\n+    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {\n@@ -2855,8 +2511,0 @@\n-#ifdef DEBUG_ENCODING\n-    if (ret)\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"failed to close the encoding handler\\n\");\n-    else\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"closed the encoding handler\\n\");\n-#endif\n@@ -2908,6 +2556,2 @@\n-                if (ret < 0) {\n-                    if (written > 0)\n-                        ret = -2;\n-                    else\n-                        return(-1);\n-                }\n+                if ((ret != XML_ENC_ERR_SUCCESS) && (ret != XML_ENC_ERR_SPACE))\n+                    return(-1);\n@@ -2916,1 +2560,1 @@\n-            } while (ret == -2);\n+            } while (ret == XML_ENC_ERR_SPACE);\n@@ -2939,1 +2583,2 @@\n- * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -2941,1 +2586,1 @@\n- *     as the return value is positive, else unpredictable.\n+ * as the return value is positive, else unpredictable.\n@@ -2955,1 +2600,1 @@\n-        return(-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2973,1 +2618,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -2980,1 +2625,1 @@\n-                return(-3);\n+                return(XML_ENC_ERR_PARTIAL);\n@@ -2987,1 +2632,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -2996,1 +2641,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -3006,1 +2651,1 @@\n-                return(-3);\n+                return(XML_ENC_ERR_PARTIAL);\n@@ -3013,1 +2658,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -3020,1 +2665,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -3031,1 +2676,1 @@\n-                return(-2);\n+                return(XML_ENC_ERR_INPUT);\n@@ -3038,1 +2683,1 @@\n-            return(-2);\n+            return(XML_ENC_ERR_INPUT);\n@@ -3056,1 +2701,3 @@\n- * Returns 0 if success, or -1 otherwise\n+ *\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\n@@ -3073,1 +2720,1 @@\n-        return(-1);\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -3085,1 +2732,1 @@\n-                return (-1);\n+                return(XML_ENC_ERR_INPUT);\n@@ -3975,18 +3622,0 @@\n-static void\n-xmlRegisterCharEncodingHandlersISO8859x (void) {\n-    xmlNewCharEncodingHandler (\"ISO-8859-2\", ISO8859_2ToUTF8, UTF8ToISO8859_2);\n-    xmlNewCharEncodingHandler (\"ISO-8859-3\", ISO8859_3ToUTF8, UTF8ToISO8859_3);\n-    xmlNewCharEncodingHandler (\"ISO-8859-4\", ISO8859_4ToUTF8, UTF8ToISO8859_4);\n-    xmlNewCharEncodingHandler (\"ISO-8859-5\", ISO8859_5ToUTF8, UTF8ToISO8859_5);\n-    xmlNewCharEncodingHandler (\"ISO-8859-6\", ISO8859_6ToUTF8, UTF8ToISO8859_6);\n-    xmlNewCharEncodingHandler (\"ISO-8859-7\", ISO8859_7ToUTF8, UTF8ToISO8859_7);\n-    xmlNewCharEncodingHandler (\"ISO-8859-8\", ISO8859_8ToUTF8, UTF8ToISO8859_8);\n-    xmlNewCharEncodingHandler (\"ISO-8859-9\", ISO8859_9ToUTF8, UTF8ToISO8859_9);\n-    xmlNewCharEncodingHandler (\"ISO-8859-10\", ISO8859_10ToUTF8, UTF8ToISO8859_10);\n-    xmlNewCharEncodingHandler (\"ISO-8859-11\", ISO8859_11ToUTF8, UTF8ToISO8859_11);\n-    xmlNewCharEncodingHandler (\"ISO-8859-13\", ISO8859_13ToUTF8, UTF8ToISO8859_13);\n-    xmlNewCharEncodingHandler (\"ISO-8859-14\", ISO8859_14ToUTF8, UTF8ToISO8859_14);\n-    xmlNewCharEncodingHandler (\"ISO-8859-15\", ISO8859_15ToUTF8, UTF8ToISO8859_15);\n-    xmlNewCharEncodingHandler (\"ISO-8859-16\", ISO8859_16ToUTF8, UTF8ToISO8859_16);\n-}\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/encoding.c","additions":501,"deletions":872,"binary":false,"changes":1373,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include <libxml\/globals.h>\n@@ -29,1 +28,2 @@\n-#include \"save.h\"\n+#include \"private\/entities.h\"\n+#include \"private\/error.h\"\n@@ -40,1 +40,1 @@\n-    NULL, NULL, NULL, NULL, 0, 1\n+    NULL, NULL, NULL, NULL, 0, 0, 0\n@@ -47,1 +47,1 @@\n-    NULL, NULL, NULL, NULL, 0, 1\n+    NULL, NULL, NULL, NULL, 0, 0, 0\n@@ -54,1 +54,1 @@\n-    NULL, NULL, NULL, NULL, 0, 1\n+    NULL, NULL, NULL, NULL, 0, 0, 0\n@@ -61,1 +61,1 @@\n-    NULL, NULL, NULL, NULL, 0, 1\n+    NULL, NULL, NULL, NULL, 0, 0, 0\n@@ -68,1 +68,1 @@\n-    NULL, NULL, NULL, NULL, 0, 1\n+    NULL, NULL, NULL, NULL, 0, 0, 0\n@@ -116,1 +116,1 @@\n-static void\n+void\n@@ -165,1 +165,0 @@\n-    ret->checked = 0;\n@@ -607,1 +606,1 @@\n-    buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));\n+    buffer = (xmlChar *) xmlMalloc(buffer_size);\n@@ -721,2 +720,0 @@\n-                    if (doc != NULL)\n-                        doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n@@ -754,2 +751,0 @@\n-                    if (doc != NULL)\n-                        doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n@@ -847,1 +842,1 @@\n-    buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));\n+    buffer = (xmlChar *) xmlMalloc(buffer_size);\n@@ -1013,1 +1008,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/entities.c","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -17,1 +17,0 @@\n-#include <libxml\/globals.h>\n@@ -19,3 +18,3 @@\n-void XMLCDECL xmlGenericErrorDefaultFunc        (void *ctx ATTRIBUTE_UNUSED,\n-                                 const char *msg,\n-                                 ...) LIBXML_ATTR_FORMAT(2,3);\n+#include \"private\/error.h\"\n+\n+#define XML_MAX_ERRORS 100\n@@ -70,1 +69,1 @@\n-void XMLCDECL\n+void\n@@ -86,0 +85,2 @@\n+ * DEPRECATED: Use xmlSetGenericErrorFunc.\n+ *\n@@ -166,1 +167,1 @@\n- * xmlParserPrintFileContext:\n+ * xmlParserPrintFileContextInternal:\n@@ -175,1 +176,1 @@\n-    const xmlChar *cur, *base;\n+    const xmlChar *cur, *base, *start;\n@@ -191,2 +192,2 @@\n-    while ((n++ < (sizeof(content)-1)) && (cur > base) &&\n-           (*(cur) != '\\n') && (*(cur) != '\\r'))\n+    while ((n < sizeof(content) - 1) && (cur > base) &&\n+           (*cur != '\\n') && (*cur != '\\r')) {\n@@ -194,1 +195,9 @@\n-    if ((*(cur) == '\\n') || (*(cur) == '\\r')) cur++;\n+        n++;\n+    }\n+    if ((n > 0) && ((*cur == '\\n') || (*cur == '\\r'))) {\n+        cur++;\n+    } else {\n+        \/* skip over continuation bytes *\/\n+        while ((cur < input->cur) && ((*cur & 0xC0) == 0x80))\n+            cur++;\n+    }\n@@ -199,1 +208,1 @@\n-    ctnt = content;\n+    start = cur;\n@@ -201,4 +210,8 @@\n-    while ((*cur != 0) && (*(cur) != '\\n') &&\n-           (*(cur) != '\\r') && (n < sizeof(content)-1)) {\n-                *ctnt++ = *cur++;\n-        n++;\n+    while ((*cur != 0) && (*(cur) != '\\n') && (*(cur) != '\\r')) {\n+        int len = input->end - cur;\n+        int c = xmlGetUTF8Char(cur, &len);\n+\n+        if ((c < 0) || (n + len > sizeof(content)-1))\n+            break;\n+        cur += len;\n+        n += len;\n@@ -206,1 +219,2 @@\n-    *ctnt = 0;\n+    memcpy(content, start, n);\n+    content[n] = 0;\n@@ -454,1 +468,1 @@\n-void XMLCDECL\n+void\n@@ -477,5 +491,18 @@\n-        if ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&\n-            (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n-            (ctxt->sax->serror != NULL)) {\n-            schannel = ctxt->sax->serror;\n-            data = ctxt->userData;\n+\n+        if (ctxt != NULL) {\n+            if (level == XML_ERR_WARNING) {\n+                if (ctxt->nbWarnings >= XML_MAX_ERRORS)\n+                    return;\n+                ctxt->nbWarnings += 1;\n+            } else {\n+                if (ctxt->nbErrors >= XML_MAX_ERRORS)\n+                    return;\n+                ctxt->nbErrors += 1;\n+            }\n+\n+            if ((schannel == NULL) && (ctxt->sax != NULL) &&\n+                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n+                (ctxt->sax->serror != NULL)) {\n+                schannel = ctxt->sax->serror;\n+                data = ctxt->userData;\n+            }\n@@ -680,1 +707,1 @@\n-void XMLCDECL\n+void\n@@ -723,1 +750,1 @@\n-void XMLCDECL\n+void\n@@ -772,1 +799,1 @@\n-void XMLCDECL\n+void\n@@ -816,1 +843,1 @@\n-void XMLCDECL\n+void\n@@ -856,1 +883,1 @@\n- * Returns NULL if no error occurred or a pointer to the error\n+ * Returns a pointer to the error\n@@ -858,1 +885,1 @@\n-xmlErrorPtr\n+const xmlError *\n@@ -915,1 +942,1 @@\n-xmlErrorPtr\n+const xmlError *\n@@ -957,1 +984,1 @@\n-xmlCopyError(xmlErrorPtr from, xmlErrorPtr to) {\n+xmlCopyError(const xmlError *from, xmlErrorPtr to) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/error.c","additions":57,"deletions":30,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -5,3 +5,0 @@\n- * The bottom of this file is automatically generated by build_glob.py\n- * based on the description file global.data\n- *\n@@ -17,0 +14,1 @@\n+#include <stdio.h>\n@@ -20,0 +18,1 @@\n+#define XML_GLOBALS_NO_REDEFINITION\n@@ -21,0 +20,1 @@\n+#include <libxml\/xmlerror.h>\n@@ -22,0 +22,3 @@\n+#include <libxml\/xmlIO.h>\n+#include <libxml\/HTMLparser.h>\n+#include <libxml\/parser.h>\n@@ -23,0 +26,3 @@\n+#include <libxml\/tree.h>\n+#include <libxml\/SAX.h>\n+#include <libxml\/SAX2.h>\n@@ -24,1 +30,27 @@\n-\/* #define DEBUG_GLOBALS *\/\n+#include \"private\/error.h\"\n+#include \"private\/globals.h\"\n+#include \"private\/threads.h\"\n+#include \"private\/tree.h\"\n+\n+\/*\n+ * Thread-local storage emulation.\n+ *\n+ * This works by replacing a global variable\n+ *\n+ *     extern xmlError xmlLastError;\n+ *\n+ * with a macro that calls a function returning a pointer to the global in\n+ * thread-local storage:\n+ *\n+ *     xmlError *__xmlLastError(void);\n+ *     #define xmlError (*__xmlLastError());\n+ *\n+ * The code can operate in a multitude of ways depending on the environment.\n+ * First we support POSIX and Windows threads. Then we support both thread-local\n+ * storage provided by the compiler and older methods like thread-specific data\n+ * (pthreads) or TlsAlloc (Windows).\n+ *\n+ * To clean up thread-local storage, we use thread-specific data on POSIX.\n+ * On Windows, we either use DllMain when compiling a DLL or a registered wait\n+ * function for static builds.\n+ *\/\n@@ -30,1 +62,1 @@\n-#define IS_MAIN_THREAD (xmlIsMainThread())\n+#define IS_MAIN_THREAD (xmlIsMainThreadInternal())\n@@ -35,0 +67,24 @@\n+#define XML_DECLARE_MEMBER(name, type, attrs) \\\n+  type gs_##name;\n+\n+struct _xmlGlobalState {\n+    int initialized;\n+\n+#if defined(HAVE_WIN32_THREADS) && \\\n+    defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n+    void *threadHandle;\n+    void *waitHandle;\n+#endif\n+\n+#define XML_OP XML_DECLARE_MEMBER\n+XML_GLOBALS_ALLOC\n+XML_GLOBALS_ERROR\n+XML_GLOBALS_HTML\n+XML_GLOBALS_IO\n+XML_GLOBALS_PARSER\n+XML_GLOBALS_TREE\n+#undef XML_OP\n+};\n+\n+static int parserInitialized;\n+\n@@ -38,1 +94,1 @@\n-static xmlMutexPtr xmlThrDefMutex = NULL;\n+static xmlMutex xmlThrDefMutex;\n@@ -40,5 +96,6 @@\n-\/**\n- * xmlInitGlobals:\n- *\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n- * initialize the library.\n+#ifdef LIBXML_THREAD_ENABLED\n+\n+\/*\n+ * On Darwin, thread-local storage destructors seem to be run before\n+ * pthread thread-specific data destructors. This causes ASan to\n+ * report a use-after-free.\n@@ -46,1 +103,2 @@\n- * Additional initialisation for multi-threading\n+ * On Windows, we can't use TLS in static builds. The RegisterWait\n+ * callback would run after TLS was deallocated.\n@@ -48,5 +106,54 @@\n-void xmlInitGlobals(void)\n-{\n-    if (xmlThrDefMutex == NULL)\n-        xmlThrDefMutex = xmlNewMutex();\n-}\n+#if defined(XML_THREAD_LOCAL) && \\\n+    !defined(__APPLE__) && \\\n+    (!defined(HAVE_WIN32_THREADS) || \\\n+     !defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n+#define USE_TLS\n+#endif\n+\n+#ifdef USE_TLS\n+static XML_THREAD_LOCAL xmlGlobalState globalState;\n+#endif\n+\n+#ifdef HAVE_POSIX_THREADS\n+\n+\/*\n+ * Weak symbol hack, see threads.c\n+ *\/\n+#if defined(__GNUC__) && \\\n+    defined(__GLIBC__) && \\\n+    __GLIBC__ * 100 + __GLIBC_MINOR__ < 234\n+\n+#pragma weak pthread_getspecific\n+#pragma weak pthread_setspecific\n+#pragma weak pthread_key_create\n+#pragma weak pthread_key_delete\n+#pragma weak pthread_equal\n+#pragma weak pthread_self\n+\n+#define XML_PTHREAD_WEAK\n+\n+static int libxml_is_threaded = -1;\n+\n+#endif\n+\n+\/*\n+ * On POSIX, we need thread-specific data even with thread-local storage\n+ * to destroy indirect references from global state (xmlLastError) at\n+ * thread exit.\n+ *\/\n+static pthread_key_t globalkey;\n+static pthread_t mainthread;\n+\n+#elif defined HAVE_WIN32_THREADS\n+\n+#ifndef USE_TLS\n+static DWORD globalkey = TLS_OUT_OF_INDEXES;\n+#endif\n+static DWORD mainthread;\n+\n+#endif \/* HAVE_WIN32_THREADS *\/\n+\n+static void\n+xmlFreeGlobalState(void *state);\n+\n+#endif \/* LIBXML_THREAD_ENABLED *\/\n@@ -63,5 +170,0 @@\n-#undef  xmlFree\n-#undef  xmlMalloc\n-#undef  xmlMallocAtomic\n-#undef  xmlMemStrdup\n-#undef  xmlRealloc\n@@ -69,1 +171,1 @@\n-#if defined(DEBUG_MEMORY_LOCATION) || defined(DEBUG_MEMORY)\n+#if defined(DEBUG_MEMORY_LOCATION)\n@@ -134,40 +236,1 @@\n-#endif \/* DEBUG_MEMORY_LOCATION || DEBUG_MEMORY *\/\n-\n-#include <libxml\/threads.h>\n-#include <libxml\/globals.h>\n-#include <libxml\/SAX.h>\n-\n-#undef  htmlDefaultSAXHandler\n-#undef  oldXMLWDcompatibility\n-#undef  xmlBufferAllocScheme\n-#undef  xmlDefaultBufferSize\n-#undef  xmlDefaultSAXHandler\n-#undef  xmlDefaultSAXLocator\n-#undef  xmlDoValidityCheckingDefaultValue\n-#undef  xmlGenericError\n-#undef  xmlStructuredError\n-#undef  xmlGenericErrorContext\n-#undef  xmlStructuredErrorContext\n-#undef  xmlGetWarningsDefaultValue\n-#undef  xmlIndentTreeOutput\n-#undef  xmlTreeIndentString\n-#undef  xmlKeepBlanksDefaultValue\n-#undef  xmlLineNumbersDefaultValue\n-#undef  xmlLoadExtDtdDefaultValue\n-#undef  xmlParserDebugEntities\n-#undef  xmlParserVersion\n-#undef  xmlPedanticParserDefaultValue\n-#undef  xmlSaveNoEmptyTags\n-#undef  xmlSubstituteEntitiesDefaultValue\n-#undef  xmlRegisterNodeDefaultValue\n-#undef  xmlDeregisterNodeDefaultValue\n-#undef  xmlLastError\n-\n-#undef  xmlParserInputBufferCreateFilenameValue\n-#undef  xmlOutputBufferCreateFilenameValue\n-\/**\n- * xmlParserVersion:\n- *\n- * Constant string describing the internal version of the library\n- *\/\n-const char *xmlParserVersion = LIBXML_VERSION_STRING LIBXML_VERSION_EXTRA;\n+#endif \/* DEBUG_MEMORY_LOCATION *\/\n@@ -178,0 +241,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -186,0 +251,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -204,0 +271,2 @@\n+ * DEPRECATED: Don't use\n+ *\n@@ -213,0 +282,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_DTDVALID.\n+ *\n@@ -221,1 +292,3 @@\n- * Global setting, indicate that the parser should provide warnings.\n+ * DEPRECATED: Don't use\n+ *\n+ * Global setting, indicate that the DTD validation should provide warnings.\n@@ -229,0 +302,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_DTDLOAD.\n+ *\n@@ -238,0 +313,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_PEDANTIC.\n+ *\n@@ -246,0 +323,2 @@\n+ * DEPRECATED: The modern options API always enables line numbers.\n+ *\n@@ -256,0 +335,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_NOBLANKS.\n+ *\n@@ -267,0 +348,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_NOENT.\n+ *\n@@ -276,0 +359,5 @@\n+\/**\n+ * xmlRegisterNodeDefaultValue:\n+ *\n+ * DEPRECATED: Don't use\n+ *\/\n@@ -278,0 +366,6 @@\n+\n+\/**\n+ * xmlDeregisterNodeDefaultValue:\n+ *\n+ * DEPRECATED: Don't use\n+ *\/\n@@ -281,0 +375,5 @@\n+\/**\n+ * xmlParserInputBufferCreateFilenameValue:\n+ *\n+ * DEPRECATED: Don't use\n+ *\/\n@@ -284,0 +383,5 @@\n+\/**\n+ * xmlOutputBufferCreateFilenameValue:\n+ *\n+ * DEPRECATED: Don't use\n+ *\/\n@@ -287,9 +391,0 @@\n-\/*\n- * Error handling\n- *\/\n-\n-\/* xmlGenericErrorFunc xmlGenericError = xmlGenericErrorDefaultFunc; *\/\n-\/* Must initialize xmlGenericError in xmlInitParser *\/\n-void XMLCDECL xmlGenericErrorDefaultFunc        (void *ctx ATTRIBUTE_UNUSED,\n-                                 const char *msg,\n-                                 ...);\n@@ -326,0 +421,1 @@\n+#ifdef LIBXML_OUTPUT_ENABLED\n@@ -356,0 +452,1 @@\n+#endif \/* LIBXML_OUTPUT_ENABLED *\/\n@@ -361,0 +458,3 @@\n+ * DEPRECATED: This handler is unused and will be removed from future\n+ * versions.\n+ *\n@@ -391,1 +491,1 @@\n-    0,\n+    1,\n@@ -398,0 +498,2 @@\n+ * DEPRECATED: Don't use\n+ *\n@@ -408,1 +510,1 @@\n-#ifdef LIBXML_HTML_ENABLED\n+#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_SAX1_ENABLED)\n@@ -412,0 +514,3 @@\n+ * DEPRECATED: This handler is unused and will be removed from future\n+ * versions.\n+ *\n@@ -439,1 +544,1 @@\n-    xmlSAX2GetParameterEntity,\n+    NULL,\n@@ -442,1 +547,1 @@\n-    0,\n+    1,\n@@ -446,0 +551,6 @@\n+\/************************************************************************\n+ *                                                                      *\n+ *                      Per thread global state handling                *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n@@ -447,2 +558,1 @@\n- * xmlInitializeGlobalState:\n- * @gs: a pointer to a newly allocated global state\n+ * xmlInitGlobals:\n@@ -450,2 +560,1 @@\n- * xmlInitializeGlobalState() initialize a global state with all the\n- * default values of the library.\n+ * DEPRECATED: Alias for xmlInitParser.\n@@ -453,15 +562,3 @@\n-void\n-xmlInitializeGlobalState(xmlGlobalStatePtr gs)\n-{\n-#ifdef DEBUG_GLOBALS\n-    fprintf(stderr, \"Initializing globals at %lu for thread %d\\n\",\n-            (unsigned long) gs, xmlGetThreadId());\n-#endif\n-\n-    \/*\n-     * Perform initialization as required by libxml\n-     *\/\n-    if (xmlThrDefMutex == NULL)\n-        xmlInitGlobals();\n-\n-    xmlMutexLock(xmlThrDefMutex);\n+void xmlInitGlobals(void) {\n+    xmlInitParser();\n+}\n@@ -469,2 +566,30 @@\n-#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_LEGACY_ENABLED) && defined(LIBXML_SAX1_ENABLED)\n-    inithtmlDefaultSAXHandler(&gs->htmlDefaultSAXHandler);\n+\/**\n+ * xmlInitGlobalsInternal:\n+ *\n+ * Additional initialisation for multi-threading\n+ *\/\n+void xmlInitGlobalsInternal(void) {\n+    xmlInitMutex(&xmlThrDefMutex);\n+\n+#ifdef HAVE_POSIX_THREADS\n+#ifdef XML_PTHREAD_WEAK\n+    if (libxml_is_threaded == -1)\n+        libxml_is_threaded =\n+            (pthread_getspecific != NULL) &&\n+            (pthread_setspecific != NULL) &&\n+            (pthread_key_create != NULL) &&\n+            (pthread_key_delete != NULL) &&\n+            \/*\n+             * pthread_equal can be inline, resuting in -Waddress warnings.\n+             * Let's assume it's available if all the other functions are.\n+             *\/\n+            \/* (pthread_equal != NULL) && *\/\n+            (pthread_self != NULL);\n+    if (libxml_is_threaded == 0)\n+        return;\n+#endif \/* XML_PTHREAD_WEAK *\/\n+    pthread_key_create(&globalkey, xmlFreeGlobalState);\n+    mainthread = pthread_self();\n+#elif defined(HAVE_WIN32_THREADS)\n+#ifndef USE_TLS\n+    globalkey = TlsAlloc();\n@@ -472,25 +597,1 @@\n-\n-    gs->oldXMLWDcompatibility = 0;\n-    gs->xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef;\n-    gs->xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef;\n-#if defined(LIBXML_SAX1_ENABLED) && defined(LIBXML_LEGACY_ENABLED)\n-    initxmlDefaultSAXHandler(&gs->xmlDefaultSAXHandler, 1);\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n-    gs->xmlDefaultSAXLocator.getPublicId = xmlSAX2GetPublicId;\n-    gs->xmlDefaultSAXLocator.getSystemId = xmlSAX2GetSystemId;\n-    gs->xmlDefaultSAXLocator.getLineNumber = xmlSAX2GetLineNumber;\n-    gs->xmlDefaultSAXLocator.getColumnNumber = xmlSAX2GetColumnNumber;\n-    gs->xmlDoValidityCheckingDefaultValue =\n-         xmlDoValidityCheckingDefaultValueThrDef;\n-#if defined(DEBUG_MEMORY_LOCATION) | defined(DEBUG_MEMORY)\n-    gs->xmlFree = (xmlFreeFunc) xmlMemFree;\n-    gs->xmlMalloc = (xmlMallocFunc) xmlMemMalloc;\n-    gs->xmlMallocAtomic = (xmlMallocFunc) xmlMemMalloc;\n-    gs->xmlRealloc = (xmlReallocFunc) xmlMemRealloc;\n-    gs->xmlMemStrdup = (xmlStrdupFunc) xmlMemoryStrdup;\n-#else\n-    gs->xmlFree = (xmlFreeFunc) free;\n-    gs->xmlMalloc = (xmlMallocFunc) malloc;\n-    gs->xmlMallocAtomic = (xmlMallocFunc) malloc;\n-    gs->xmlRealloc = (xmlReallocFunc) realloc;\n-    gs->xmlMemStrdup = (xmlStrdupFunc) xmlStrdup;\n+    mainthread = GetCurrentThreadId();\n@@ -498,25 +599,0 @@\n-    gs->xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;\n-    gs->xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;\n-    gs->xmlTreeIndentString = xmlTreeIndentStringThrDef;\n-    gs->xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;\n-    gs->xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;\n-    gs->xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;\n-    gs->xmlParserDebugEntities = xmlParserDebugEntitiesThrDef;\n-    gs->xmlParserVersion = LIBXML_VERSION_STRING;\n-    gs->xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;\n-    gs->xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;\n-    gs->xmlSubstituteEntitiesDefaultValue =\n-        xmlSubstituteEntitiesDefaultValueThrDef;\n-\n-    gs->xmlGenericError = xmlGenericErrorThrDef;\n-    gs->xmlStructuredError = xmlStructuredErrorThrDef;\n-    gs->xmlGenericErrorContext = xmlGenericErrorContextThrDef;\n-    gs->xmlStructuredErrorContext = xmlStructuredErrorContextThrDef;\n-    gs->xmlRegisterNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef;\n-    gs->xmlDeregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef;\n-\n-        gs->xmlParserInputBufferCreateFilenameValue = xmlParserInputBufferCreateFilenameValueThrDef;\n-        gs->xmlOutputBufferCreateFilenameValue = xmlOutputBufferCreateFilenameValueThrDef;\n-    memset(&gs->xmlLastError, 0, sizeof(xmlError));\n-\n-    xmlMutexUnlock(xmlThrDefMutex);\n@@ -528,1 +604,1 @@\n- * DEPRECATED: This function will be made private. Call xmlCleanupParser\n+ * DEPRECATED: This function is a no-op. Call xmlCleanupParser\n@@ -532,0 +608,6 @@\n+ *\/\n+void xmlCleanupGlobals(void) {\n+}\n+\n+\/**\n+ * xmlCleanupGlobalsInternal:\n@@ -535,2 +617,1 @@\n-void xmlCleanupGlobals(void)\n-{\n+void xmlCleanupGlobalsInternal(void) {\n@@ -539,3 +620,13 @@\n-    if (xmlThrDefMutex != NULL) {\n-        xmlFreeMutex(xmlThrDefMutex);\n-        xmlThrDefMutex = NULL;\n+    xmlCleanupMutex(&xmlThrDefMutex);\n+\n+#ifdef HAVE_POSIX_THREADS\n+#ifdef XML_PTHREAD_WEAK\n+    if (libxml_is_threaded == 0)\n+        return;\n+#endif \/* XML_PTHREAD_WEAK *\/\n+    pthread_key_delete(globalkey);\n+#elif defined(HAVE_WIN32_THREADS)\n+#ifndef USE_TLS\n+    if (globalkey != TLS_OUT_OF_INDEXES) {\n+        TlsFree(globalkey);\n+        globalkey = TLS_OUT_OF_INDEXES;\n@@ -543,1 +634,4 @@\n-    __xmlGlobalInitMutexDestroy();\n+#endif\n+#endif\n+\n+    parserInitialized = 0;\n@@ -547,2 +641,4 @@\n- * DOC_DISABLE : we ignore missing doc for the xmlThrDef functions,\n- *               those are really internal work\n+ * xmlInitializeGlobalState:\n+ * @gs: a pointer to a newly allocated global state\n+ *\n+ * DEPRECATED: No-op.\n@@ -551,16 +647,2 @@\n-xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {\n-    xmlMutexLock(xmlThrDefMutex);\n-    xmlGenericErrorContextThrDef = ctx;\n-    if (handler != NULL)\n-        xmlGenericErrorThrDef = handler;\n-    else\n-        xmlGenericErrorThrDef = xmlGenericErrorDefaultFunc;\n-    xmlMutexUnlock(xmlThrDefMutex);\n-}\n-\n-void\n-xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler) {\n-    xmlMutexLock(xmlThrDefMutex);\n-    xmlStructuredErrorContextThrDef = ctx;\n-    xmlStructuredErrorThrDef = handler;\n-    xmlMutexUnlock(xmlThrDefMutex);\n+xmlInitializeGlobalState(xmlGlobalStatePtr gs ATTRIBUTE_UNUSED)\n+{\n@@ -570,2 +652,1 @@\n- * xmlRegisterNodeDefault:\n- * @func: function pointer to the new RegisterNodeFunc\n+ * xmlGetGlobalState:\n@@ -573,1 +654,1 @@\n- * Registers a callback for node creation\n+ * DEPRECATED\n@@ -575,1 +656,1 @@\n- * Returns the old value of the registration function\n+ * Returns NULL.\n@@ -577,2 +658,2 @@\n-xmlRegisterNodeFunc\n-xmlRegisterNodeDefault(xmlRegisterNodeFunc func)\n+xmlGlobalStatePtr\n+xmlGetGlobalState(void)\n@@ -580,5 +661,1 @@\n-    xmlRegisterNodeFunc old = xmlRegisterNodeDefaultValue;\n-\n-    __xmlRegisterCallbacks = 1;\n-    xmlRegisterNodeDefaultValue = func;\n-    return(old);\n+    return(NULL);\n@@ -587,11 +664,6 @@\n-xmlRegisterNodeFunc\n-xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func)\n-{\n-    xmlRegisterNodeFunc old;\n-\n-    xmlMutexLock(xmlThrDefMutex);\n-    old = xmlRegisterNodeDefaultValueThrDef;\n-\n-    __xmlRegisterCallbacks = 1;\n-    xmlRegisterNodeDefaultValueThrDef = func;\n-    xmlMutexUnlock(xmlThrDefMutex);\n+static int\n+xmlIsMainThreadInternal(void) {\n+    if (parserInitialized == 0) {\n+        xmlInitParser();\n+        parserInitialized = 1;\n+    }\n@@ -599,1 +671,11 @@\n-    return(old);\n+#ifdef HAVE_POSIX_THREADS\n+#ifdef XML_PTHREAD_WEAK\n+    if (libxml_is_threaded == 0)\n+        return (1);\n+#endif\n+    return (pthread_equal(mainthread, pthread_self()));\n+#elif defined HAVE_WIN32_THREADS\n+    return (mainthread == GetCurrentThreadId());\n+#else\n+    return (1);\n+#endif\n@@ -603,2 +685,3 @@\n- * xmlDeregisterNodeDefault:\n- * @func: function pointer to the new DeregisterNodeFunc\n+ * xmlIsMainThread:\n+ *\n+ * DEPRECATED: Internal function, do not use.\n@@ -606,1 +689,1 @@\n- * Registers a callback for node destruction\n+ * Check whether the current thread is the main thread.\n@@ -608,1 +691,1 @@\n- * Returns the previous value of the deregistration function\n+ * Returns 1 if the current thread is the main thread, 0 otherwise\n@@ -610,8 +693,3 @@\n-xmlDeregisterNodeFunc\n-xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func)\n-{\n-    xmlDeregisterNodeFunc old = xmlDeregisterNodeDefaultValue;\n-\n-    __xmlRegisterCallbacks = 1;\n-    xmlDeregisterNodeDefaultValue = func;\n-    return(old);\n+int\n+xmlIsMainThread(void) {\n+    return(xmlIsMainThreadInternal());\n@@ -620,2 +698,4 @@\n-xmlDeregisterNodeFunc\n-xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func)\n+#ifdef LIBXML_THREAD_ENABLED\n+\n+static void\n+xmlFreeGlobalState(void *state)\n@@ -623,1 +703,1 @@\n-    xmlDeregisterNodeFunc old;\n+    xmlGlobalState *gs = (xmlGlobalState *) state;\n@@ -625,2 +705,15 @@\n-    xmlMutexLock(xmlThrDefMutex);\n-    old = xmlDeregisterNodeDefaultValueThrDef;\n+    \/*\n+     * Free any memory allocated in the thread's xmlLastError. If it\n+     * weren't for this indirect allocation, we wouldn't need\n+     * a destructor with thread-local storage at all!\n+     *\n+     * It would be nice if we could make xmlLastError a special error\n+     * type which uses statically allocated, fixed-size buffers.\n+     * But the xmlError struct is fully public and widely used,\n+     * so changes are dangerous.\n+     *\/\n+    xmlResetError(&(gs->gs_xmlLastError));\n+#ifndef USE_TLS\n+    free(state);\n+#endif\n+}\n@@ -628,3 +721,5 @@\n-    __xmlRegisterCallbacks = 1;\n-    xmlDeregisterNodeDefaultValueThrDef = func;\n-    xmlMutexUnlock(xmlThrDefMutex);\n+#if defined(HAVE_WIN32_THREADS) && \\\n+    defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n+static void WINAPI\n+xmlGlobalStateDtor(void *ctxt, unsigned char timedOut ATTRIBUTE_UNUSED) {\n+    xmlGlobalStatePtr gs = ctxt;\n@@ -632,1 +727,3 @@\n-    return(old);\n+    UnregisterWait(gs->waitHandle);\n+    CloseHandle(gs->threadHandle);\n+    xmlFreeGlobalState(gs);\n@@ -635,4 +732,5 @@\n-xmlParserInputBufferCreateFilenameFunc\n-xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func)\n-{\n-    xmlParserInputBufferCreateFilenameFunc old;\n+static int\n+xmlRegisterGlobalStateDtor(xmlGlobalState *gs) {\n+    void *processHandle = GetCurrentProcess();\n+    void *threadHandle;\n+    void *waitHandle;\n@@ -640,5 +738,4 @@\n-    xmlMutexLock(xmlThrDefMutex);\n-    old = xmlParserInputBufferCreateFilenameValueThrDef;\n-    if (old == NULL) {\n-                old = __xmlParserInputBufferCreateFilename;\n-        }\n+    if (DuplicateHandle(processHandle, GetCurrentThread(), processHandle,\n+                &threadHandle, 0, FALSE, DUPLICATE_SAME_ACCESS) == 0) {\n+        return(-1);\n+    }\n@@ -646,2 +743,5 @@\n-    xmlParserInputBufferCreateFilenameValueThrDef = func;\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    if (RegisterWaitForSingleObject(&waitHandle, threadHandle,\n+                xmlGlobalStateDtor, gs, INFINITE, WT_EXECUTEONLYONCE) == 0) {\n+        CloseHandle(threadHandle);\n+        return(-1);\n+    }\n@@ -649,1 +749,3 @@\n-    return(old);\n+    gs->threadHandle = threadHandle;\n+    gs->waitHandle = waitHandle;\n+    return(0);\n@@ -651,0 +753,1 @@\n+#endif \/* LIBXML_STATIC *\/\n@@ -652,4 +755,3 @@\n-xmlOutputBufferCreateFilenameFunc\n-xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func)\n-{\n-    xmlOutputBufferCreateFilenameFunc old;\n+static void\n+xmlInitGlobalState(xmlGlobalStatePtr gs) {\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -657,6 +759,2 @@\n-    xmlMutexLock(xmlThrDefMutex);\n-    old = xmlOutputBufferCreateFilenameValueThrDef;\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    if (old == NULL) {\n-                old = __xmlOutputBufferCreateFilename;\n-        }\n+#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_LEGACY_ENABLED) && defined(LIBXML_SAX1_ENABLED)\n+    inithtmlDefaultSAXHandler(&gs->gs_htmlDefaultSAXHandler);\n@@ -664,2 +762,0 @@\n-    xmlOutputBufferCreateFilenameValueThrDef = func;\n-    xmlMutexUnlock(xmlThrDefMutex);\n@@ -667,2 +763,40 @@\n-    return(old);\n-}\n+    gs->gs_oldXMLWDcompatibility = 0;\n+    gs->gs_xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef;\n+    gs->gs_xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef;\n+#if defined(LIBXML_SAX1_ENABLED) && defined(LIBXML_LEGACY_ENABLED)\n+    initxmlDefaultSAXHandler(&gs->gs_xmlDefaultSAXHandler, 1);\n+#endif \/* LIBXML_SAX1_ENABLED *\/\n+    gs->gs_xmlDefaultSAXLocator.getPublicId = xmlSAX2GetPublicId;\n+    gs->gs_xmlDefaultSAXLocator.getSystemId = xmlSAX2GetSystemId;\n+    gs->gs_xmlDefaultSAXLocator.getLineNumber = xmlSAX2GetLineNumber;\n+    gs->gs_xmlDefaultSAXLocator.getColumnNumber = xmlSAX2GetColumnNumber;\n+    gs->gs_xmlDoValidityCheckingDefaultValue =\n+         xmlDoValidityCheckingDefaultValueThrDef;\n+#ifdef LIBXML_THREAD_ALLOC_ENABLED\n+#ifdef DEBUG_MEMORY_LOCATION\n+    gs->gs_xmlFree = xmlMemFree;\n+    gs->gs_xmlMalloc = xmlMemMalloc;\n+    gs->gs_xmlMallocAtomic = xmlMemMalloc;\n+    gs->gs_xmlRealloc = xmlMemRealloc;\n+    gs->gs_xmlMemStrdup = xmlMemoryStrdup;\n+#else\n+    gs->gs_xmlFree = free;\n+    gs->gs_xmlMalloc = malloc;\n+    gs->gs_xmlMallocAtomic = malloc;\n+    gs->gs_xmlRealloc = realloc;\n+    gs->gs_xmlMemStrdup = xmlPosixStrdup;\n+#endif\n+#endif\n+    gs->gs_xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    gs->gs_xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;\n+    gs->gs_xmlTreeIndentString = xmlTreeIndentStringThrDef;\n+    gs->gs_xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;\n+#endif\n+    gs->gs_xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;\n+    gs->gs_xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;\n+    gs->gs_xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;\n+    gs->gs_xmlParserDebugEntities = xmlParserDebugEntitiesThrDef;\n+    gs->gs_xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;\n+    gs->gs_xmlSubstituteEntitiesDefaultValue =\n+        xmlSubstituteEntitiesDefaultValueThrDef;\n@@ -670,9 +804,24 @@\n-#ifdef LIBXML_HTML_ENABLED\n-#undef  htmlDefaultSAXHandler\n-xmlSAXHandlerV1 *\n-__htmlDefaultSAXHandler(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&htmlDefaultSAXHandler);\n-    else\n-        return (&xmlGetGlobalState()->htmlDefaultSAXHandler);\n-}\n+    gs->gs_xmlGenericError = xmlGenericErrorThrDef;\n+    gs->gs_xmlStructuredError = xmlStructuredErrorThrDef;\n+    gs->gs_xmlGenericErrorContext = xmlGenericErrorContextThrDef;\n+    gs->gs_xmlStructuredErrorContext = xmlStructuredErrorContextThrDef;\n+    gs->gs_xmlRegisterNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef;\n+    gs->gs_xmlDeregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef;\n+\n+    gs->gs_xmlParserInputBufferCreateFilenameValue =\n+        xmlParserInputBufferCreateFilenameValueThrDef;\n+    gs->gs_xmlOutputBufferCreateFilenameValue =\n+        xmlOutputBufferCreateFilenameValueThrDef;\n+    memset(&gs->gs_xmlLastError, 0, sizeof(xmlError));\n+\n+    xmlMutexUnlock(&xmlThrDefMutex);\n+\n+#ifdef HAVE_POSIX_THREADS\n+    pthread_setspecific(globalkey, gs);\n+#elif defined HAVE_WIN32_THREADS\n+#ifndef USE_TLS\n+    TlsSetValue(globalkey, gs);\n+#endif\n+#if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n+    xmlRegisterGlobalStateDtor(gs);\n+#endif\n@@ -681,7 +830,1 @@\n-#undef xmlLastError\n-xmlError *\n-__xmlLastError(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlLastError);\n-    else\n-        return (&xmlGetGlobalState()->xmlLastError);\n+    gs->initialized = 1;\n@@ -690,4 +833,9 @@\n-\/*\n- * The following memory routines were apparently lost at some point,\n- * and were re-inserted at this point on June 10, 2004.  Hope it's\n- * the right place for them :-)\n+#ifndef USE_TLS\n+\/**\n+ * xmlNewGlobalState:\n+ *\n+ * xmlNewGlobalState() allocates a global state. This structure is used to\n+ * hold all data for use by a thread when supporting backwards compatibility\n+ * of libxml2 to pre-thread-safe behaviour.\n+ *\n+ * Returns the newly allocated xmlGlobalStatePtr or NULL in case of error\n@@ -695,9 +843,19 @@\n-#if defined(LIBXML_THREAD_ALLOC_ENABLED) && defined(LIBXML_THREAD_ENABLED)\n-#undef xmlMalloc\n-xmlMallocFunc *\n-__xmlMalloc(void){\n-    if (IS_MAIN_THREAD)\n-        return (&xmlMalloc);\n-    else\n-        return (&xmlGetGlobalState()->xmlMalloc);\n-}\n+static xmlGlobalStatePtr\n+xmlNewGlobalState(int allowFailure)\n+{\n+    xmlGlobalState *gs;\n+\n+    gs = malloc(sizeof(xmlGlobalState));\n+    if (gs == NULL) {\n+        if (allowFailure)\n+            return(NULL);\n+\n+        \/*\n+         * If an application didn't call xmlCheckThreadLocalStorage to make\n+         * sure that global state could be allocated, it's too late to\n+         * handle the error.\n+         *\/\n+        fprintf(stderr, \"libxml2: Failed to allocate globals for thread\\n\"\n+                        \"libxml2: See xmlCheckThreadLocalStorage\\n\");\n+        abort();\n+    }\n@@ -705,7 +863,3 @@\n-#undef xmlMallocAtomic\n-xmlMallocFunc *\n-__xmlMallocAtomic(void){\n-    if (IS_MAIN_THREAD)\n-        return (&xmlMallocAtomic);\n-    else\n-        return (&xmlGetGlobalState()->xmlMallocAtomic);\n+    memset(gs, 0, sizeof(xmlGlobalState));\n+    xmlInitGlobalState(gs);\n+    return (gs);\n@@ -713,0 +867,1 @@\n+#endif\n@@ -714,8 +869,21 @@\n-#undef xmlRealloc\n-xmlReallocFunc *\n-__xmlRealloc(void){\n-    if (IS_MAIN_THREAD)\n-        return (&xmlRealloc);\n-    else\n-        return (&xmlGetGlobalState()->xmlRealloc);\n-}\n+static xmlGlobalStatePtr\n+xmlGetThreadLocalStorage(int allowFailure) {\n+    xmlGlobalState *gs;\n+\n+    (void) allowFailure;\n+\n+#ifdef USE_TLS\n+    gs = &globalState;\n+    if (gs->initialized == 0)\n+        xmlInitGlobalState(gs);\n+#elif defined(HAVE_POSIX_THREADS)\n+    gs = (xmlGlobalState *) pthread_getspecific(globalkey);\n+    if (gs == NULL)\n+        gs = xmlNewGlobalState(allowFailure);\n+#elif defined(HAVE_WIN32_THREADS)\n+    gs = (xmlGlobalState *) TlsGetValue(globalkey);\n+    if (gs == NULL)\n+        gs = xmlNewGlobalState(allowFailure);\n+#else\n+    gs = NULL;\n+#endif\n@@ -723,7 +891,1 @@\n-#undef xmlFree\n-xmlFreeFunc *\n-__xmlFree(void){\n-    if (IS_MAIN_THREAD)\n-        return (&xmlFree);\n-    else\n-        return (&xmlGetGlobalState()->xmlFree);\n+    return(gs);\n@@ -732,6 +894,24 @@\n-xmlStrdupFunc *\n-__xmlMemStrdup(void){\n-    if (IS_MAIN_THREAD)\n-        return (&xmlMemStrdup);\n-    else\n-        return (&xmlGetGlobalState()->xmlMemStrdup);\n+\/* Define thread-local storage accessors with macro magic *\/\n+\n+#define XML_DEFINE_GLOBAL_WRAPPER(name, type, attrs) \\\n+    type *__##name(void) { \\\n+        if (IS_MAIN_THREAD) \\\n+            return (&name); \\\n+        else \\\n+            return (&xmlGetThreadLocalStorage(0)->gs_##name); \\\n+    }\n+\n+#define XML_OP XML_DEFINE_GLOBAL_WRAPPER\n+XML_GLOBALS_ALLOC\n+XML_GLOBALS_ERROR\n+XML_GLOBALS_HTML\n+XML_GLOBALS_IO\n+XML_GLOBALS_PARSER\n+XML_GLOBALS_TREE\n+#undef XML_OP\n+\n+\/* For backward compatibility *\/\n+\n+const char *const *\n+__xmlParserVersion(void) {\n+    return &xmlParserVersion;\n@@ -740,1 +920,1 @@\n-#endif\n+#endif \/* LIBXML_THREAD_ENABLED *\/\n@@ -742,4 +922,21 @@\n-\/*\n- * Everything starting from the line below is\n- * Automatically generated by build_glob.py.\n- * Do not modify the previous line.\n+\/**\n+ * xmlCheckThreadLocalStorage:\n+ *\n+ * Check whether thread-local storage could be allocated.\n+ *\n+ * In cross-platform code running in multithreaded environments, this\n+ * function should be called once in each thread before calling other\n+ * library functions to make sure that thread-local storage was\n+ * allocated properly.\n+ *\n+ * Returns 0 on success or -1 if a memory allocation failed. A failed\n+ * allocation signals a typically fatal and irrecoverable out-of-memory\n+ * situation. Don't call any library functions in this case.\n+ *\n+ * This function never fails if the library is compiled with support\n+ * for thread-local storage.\n+ *\n+ * This function never fails for the \"main\" thread which is the first\n+ * thread calling xmlInitParser.\n+ *\n+ * Available since v2.12.0.\n@@ -747,0 +944,8 @@\n+int\n+xmlCheckThreadLocalStorage(void) {\n+#if defined(LIBXML_THREAD_ENABLED) && !defined(USE_TLS)\n+    if ((!xmlIsMainThreadInternal()) && (xmlGetThreadLocalStorage(1) == NULL))\n+        return(-1);\n+#endif\n+    return(0);\n+}\n@@ -748,0 +953,53 @@\n+\/**\n+ * DllMain:\n+ * @hinstDLL: handle to DLL instance\n+ * @fdwReason: Reason code for entry\n+ * @lpvReserved: generic pointer (depends upon reason code)\n+ *\n+ * Entry point for Windows library. It is being used to free thread-specific\n+ * storage.\n+ *\n+ * Returns TRUE always\n+ *\/\n+#if defined(HAVE_WIN32_THREADS) && \\\n+    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n+#if defined(LIBXML_STATIC_FOR_DLL)\n+int\n+xmlDllMain(ATTRIBUTE_UNUSED void *hinstDLL, unsigned long fdwReason,\n+           ATTRIBUTE_UNUSED void *lpvReserved)\n+#else\n+\/* declare to avoid \"no previous prototype for 'DllMain'\" warning *\/\n+\/* Note that we do NOT want to include this function declaration in\n+   a public header because it's meant to be called by Windows itself,\n+   not a program that uses this library.  This also has to be exported. *\/\n+\n+XMLPUBFUN BOOL WINAPI\n+DllMain (HINSTANCE hinstDLL,\n+         DWORD     fdwReason,\n+         LPVOID    lpvReserved);\n+\n+BOOL WINAPI\n+DllMain(ATTRIBUTE_UNUSED HINSTANCE hinstDLL, DWORD fdwReason,\n+        ATTRIBUTE_UNUSED LPVOID lpvReserved)\n+#endif\n+{\n+    switch (fdwReason) {\n+        case DLL_THREAD_DETACH:\n+#ifdef USE_TLS\n+            xmlFreeGlobalState(&globalState);\n+#else\n+            if (globalkey != TLS_OUT_OF_INDEXES) {\n+                xmlGlobalState *globalval;\n+\n+                globalval = (xmlGlobalState *) TlsGetValue(globalkey);\n+                if (globalval) {\n+                    xmlFreeGlobalState(globalval);\n+                    TlsSetValue(globalkey, NULL);\n+                }\n+            }\n+#endif\n+            break;\n+    }\n+    return TRUE;\n+}\n+#endif\n@@ -749,5 +1007,6 @@\n-#undef  oldXMLWDcompatibility\n-int *\n-__oldXMLWDcompatibility(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&oldXMLWDcompatibility);\n+void\n+xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {\n+    xmlMutexLock(&xmlThrDefMutex);\n+    xmlGenericErrorContextThrDef = ctx;\n+    if (handler != NULL)\n+        xmlGenericErrorThrDef = handler;\n@@ -755,1 +1014,2 @@\n-        return (&xmlGetGlobalState()->oldXMLWDcompatibility);\n+        xmlGenericErrorThrDef = xmlGenericErrorDefaultFunc;\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -758,7 +1018,6 @@\n-#undef  xmlBufferAllocScheme\n-xmlBufferAllocationScheme *\n-__xmlBufferAllocScheme(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlBufferAllocScheme);\n-    else\n-        return (&xmlGetGlobalState()->xmlBufferAllocScheme);\n+void\n+xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler) {\n+    xmlMutexLock(&xmlThrDefMutex);\n+    xmlStructuredErrorContextThrDef = ctx;\n+    xmlStructuredErrorThrDef = handler;\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -766,0 +1025,1 @@\n+\n@@ -768,1 +1028,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -771,1 +1031,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -775,8 +1035,0 @@\n-#undef  xmlDefaultBufferSize\n-int *\n-__xmlDefaultBufferSize(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlDefaultBufferSize);\n-    else\n-        return (&xmlGetGlobalState()->xmlDefaultBufferSize);\n-}\n@@ -785,1 +1037,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -788,1 +1040,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -792,28 +1044,0 @@\n-#ifdef LIBXML_SAX1_ENABLED\n-#undef  xmlDefaultSAXHandler\n-xmlSAXHandlerV1 *\n-__xmlDefaultSAXHandler(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlDefaultSAXHandler);\n-    else\n-        return (&xmlGetGlobalState()->xmlDefaultSAXHandler);\n-}\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n-\n-#undef  xmlDefaultSAXLocator\n-xmlSAXLocator *\n-__xmlDefaultSAXLocator(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlDefaultSAXLocator);\n-    else\n-        return (&xmlGetGlobalState()->xmlDefaultSAXLocator);\n-}\n-\n-#undef  xmlDoValidityCheckingDefaultValue\n-int *\n-__xmlDoValidityCheckingDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlDoValidityCheckingDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlDoValidityCheckingDefaultValue);\n-}\n@@ -822,1 +1046,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -825,1 +1049,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -829,44 +1053,0 @@\n-#undef  xmlGenericError\n-xmlGenericErrorFunc *\n-__xmlGenericError(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlGenericError);\n-    else\n-        return (&xmlGetGlobalState()->xmlGenericError);\n-}\n-\n-#undef  xmlStructuredError\n-xmlStructuredErrorFunc *\n-__xmlStructuredError(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlStructuredError);\n-    else\n-        return (&xmlGetGlobalState()->xmlStructuredError);\n-}\n-\n-#undef  xmlGenericErrorContext\n-void * *\n-__xmlGenericErrorContext(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlGenericErrorContext);\n-    else\n-        return (&xmlGetGlobalState()->xmlGenericErrorContext);\n-}\n-\n-#undef  xmlStructuredErrorContext\n-void * *\n-__xmlStructuredErrorContext(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlStructuredErrorContext);\n-    else\n-        return (&xmlGetGlobalState()->xmlStructuredErrorContext);\n-}\n-\n-#undef  xmlGetWarningsDefaultValue\n-int *\n-__xmlGetWarningsDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlGetWarningsDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlGetWarningsDefaultValue);\n-}\n@@ -875,1 +1055,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -878,1 +1058,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -882,8 +1062,1 @@\n-#undef  xmlIndentTreeOutput\n-int *\n-__xmlIndentTreeOutput(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlIndentTreeOutput);\n-    else\n-        return (&xmlGetGlobalState()->xmlIndentTreeOutput);\n-}\n+#ifdef LIBXML_OUTPUT_ENABLED\n@@ -892,1 +1065,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -895,1 +1068,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -899,8 +1072,0 @@\n-#undef  xmlTreeIndentString\n-const char * *\n-__xmlTreeIndentString(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlTreeIndentString);\n-    else\n-        return (&xmlGetGlobalState()->xmlTreeIndentString);\n-}\n@@ -909,1 +1074,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -912,1 +1077,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -916,7 +1081,7 @@\n-#undef  xmlKeepBlanksDefaultValue\n-int *\n-__xmlKeepBlanksDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlKeepBlanksDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlKeepBlanksDefaultValue);\n+int xmlThrDefSaveNoEmptyTags(int v) {\n+    int ret;\n+    xmlMutexLock(&xmlThrDefMutex);\n+    ret = xmlSaveNoEmptyTagsThrDef;\n+    xmlSaveNoEmptyTagsThrDef = v;\n+    xmlMutexUnlock(&xmlThrDefMutex);\n+    return ret;\n@@ -924,0 +1089,2 @@\n+#endif\n+\n@@ -926,1 +1093,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -929,1 +1096,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -933,8 +1100,0 @@\n-#undef  xmlLineNumbersDefaultValue\n-int *\n-__xmlLineNumbersDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlLineNumbersDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlLineNumbersDefaultValue);\n-}\n@@ -943,1 +1102,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -946,1 +1105,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -950,8 +1109,0 @@\n-#undef  xmlLoadExtDtdDefaultValue\n-int *\n-__xmlLoadExtDtdDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlLoadExtDtdDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlLoadExtDtdDefaultValue);\n-}\n@@ -960,1 +1111,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -963,1 +1114,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -967,8 +1118,0 @@\n-#undef  xmlParserDebugEntities\n-int *\n-__xmlParserDebugEntities(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlParserDebugEntities);\n-    else\n-        return (&xmlGetGlobalState()->xmlParserDebugEntities);\n-}\n@@ -977,1 +1120,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -980,1 +1123,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -984,17 +1127,0 @@\n-#undef  xmlParserVersion\n-const char * *\n-__xmlParserVersion(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlParserVersion);\n-    else\n-        return (&xmlGetGlobalState()->xmlParserVersion);\n-}\n-\n-#undef  xmlPedanticParserDefaultValue\n-int *\n-__xmlPedanticParserDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlPedanticParserDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlPedanticParserDefaultValue);\n-}\n@@ -1003,1 +1129,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -1006,18 +1132,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n-    return ret;\n-}\n-\n-#undef  xmlSaveNoEmptyTags\n-int *\n-__xmlSaveNoEmptyTags(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlSaveNoEmptyTags);\n-    else\n-        return (&xmlGetGlobalState()->xmlSaveNoEmptyTags);\n-}\n-int xmlThrDefSaveNoEmptyTags(int v) {\n-    int ret;\n-    xmlMutexLock(xmlThrDefMutex);\n-    ret = xmlSaveNoEmptyTagsThrDef;\n-    xmlSaveNoEmptyTagsThrDef = v;\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -1027,8 +1136,0 @@\n-#undef  xmlSubstituteEntitiesDefaultValue\n-int *\n-__xmlSubstituteEntitiesDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlSubstituteEntitiesDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlSubstituteEntitiesDefaultValue);\n-}\n@@ -1037,1 +1138,1 @@\n-    xmlMutexLock(xmlThrDefMutex);\n+    xmlMutexLock(&xmlThrDefMutex);\n@@ -1040,1 +1141,1 @@\n-    xmlMutexUnlock(xmlThrDefMutex);\n+    xmlMutexUnlock(&xmlThrDefMutex);\n@@ -1044,7 +1145,13 @@\n-#undef  xmlRegisterNodeDefaultValue\n-xmlRegisterNodeFunc *\n-__xmlRegisterNodeDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlRegisterNodeDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlRegisterNodeDefaultValue);\n+xmlRegisterNodeFunc\n+xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func)\n+{\n+    xmlRegisterNodeFunc old;\n+\n+    xmlMutexLock(&xmlThrDefMutex);\n+    old = xmlRegisterNodeDefaultValueThrDef;\n+\n+    __xmlRegisterCallbacks = 1;\n+    xmlRegisterNodeDefaultValueThrDef = func;\n+    xmlMutexUnlock(&xmlThrDefMutex);\n+\n+    return(old);\n@@ -1053,7 +1160,13 @@\n-#undef  xmlDeregisterNodeDefaultValue\n-xmlDeregisterNodeFunc *\n-__xmlDeregisterNodeDefaultValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlDeregisterNodeDefaultValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlDeregisterNodeDefaultValue);\n+xmlDeregisterNodeFunc\n+xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func)\n+{\n+    xmlDeregisterNodeFunc old;\n+\n+    xmlMutexLock(&xmlThrDefMutex);\n+    old = xmlDeregisterNodeDefaultValueThrDef;\n+\n+    __xmlRegisterCallbacks = 1;\n+    xmlDeregisterNodeDefaultValueThrDef = func;\n+    xmlMutexUnlock(&xmlThrDefMutex);\n+\n+    return(old);\n@@ -1062,7 +1175,15 @@\n-#undef  xmlParserInputBufferCreateFilenameValue\n-xmlParserInputBufferCreateFilenameFunc *\n-__xmlParserInputBufferCreateFilenameValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlParserInputBufferCreateFilenameValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlParserInputBufferCreateFilenameValue);\n+xmlParserInputBufferCreateFilenameFunc\n+xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func)\n+{\n+    xmlParserInputBufferCreateFilenameFunc old;\n+\n+    xmlMutexLock(&xmlThrDefMutex);\n+    old = xmlParserInputBufferCreateFilenameValueThrDef;\n+    if (old == NULL) {\n+                old = __xmlParserInputBufferCreateFilename;\n+        }\n+\n+    xmlParserInputBufferCreateFilenameValueThrDef = func;\n+    xmlMutexUnlock(&xmlThrDefMutex);\n+\n+    return(old);\n@@ -1071,7 +1192,16 @@\n-#undef  xmlOutputBufferCreateFilenameValue\n-xmlOutputBufferCreateFilenameFunc *\n-__xmlOutputBufferCreateFilenameValue(void) {\n-    if (IS_MAIN_THREAD)\n-        return (&xmlOutputBufferCreateFilenameValue);\n-    else\n-        return (&xmlGetGlobalState()->xmlOutputBufferCreateFilenameValue);\n+xmlOutputBufferCreateFilenameFunc\n+xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func)\n+{\n+    xmlOutputBufferCreateFilenameFunc old;\n+\n+    xmlMutexLock(&xmlThrDefMutex);\n+    old = xmlOutputBufferCreateFilenameValueThrDef;\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    if (old == NULL) {\n+                old = __xmlOutputBufferCreateFilename;\n+        }\n+#endif\n+    xmlOutputBufferCreateFilenameValueThrDef = func;\n+    xmlMutexUnlock(&xmlThrDefMutex);\n+\n+    return(old);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/globals.c","additions":669,"deletions":539,"binary":false,"changes":1208,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * hash.c: chained hash tables\n+ * hash.c: hash tables\n@@ -4,1 +4,2 @@\n- * Reference: Your favorite introductory book on algorithms\n+ * Hash table with open addressing, linear probing and\n+ * Robin Hood reordering.\n@@ -6,12 +7,1 @@\n- * Copyright (C) 2000,2012 Bjorn Reese and Daniel Veillard.\n- *\n- * Permission to use, copy, modify, and distribute this software for any\n- * purpose with or without fee is hereby granted, provided that the above\n- * copyright notice and this permission notice appear in all copies.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n- * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND\n- * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.\n- *\n- * Author: breese@users.sourceforge.net\n+ * See Copyright for the status of this software.\n@@ -24,11 +14,1 @@\n-#include <stdlib.h>\n-#include <time.h>\n-\n-\/*\n- * Following http:\/\/www.ocert.org\/advisories\/ocert-2011-003.html\n- * it seems that having hash randomization might be a good idea\n- * when using XML with untrusted data\n- *\/\n-#if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)\n-#define HASH_RANDOMIZATION\n-#endif\n+#include <limits.h>\n@@ -38,0 +18,1 @@\n+#include <libxml\/dict.h>\n@@ -39,2 +20,3 @@\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/globals.h>\n+#include <libxml\/xmlstring.h>\n+\n+#include \"private\/dict.h\"\n@@ -42,1 +24,3 @@\n-#define MAX_HASH_LEN 8\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n@@ -44,1 +28,4 @@\n-\/* #define DEBUG_GROW *\/\n+#define MAX_FILL_NUM 7\n+#define MAX_FILL_DENOM 8\n+#define MIN_HASH_SIZE 8\n+#define MAX_HASH_SIZE (1u << 31)\n@@ -49,7 +36,6 @@\n-typedef struct _xmlHashEntry xmlHashEntry;\n-typedef xmlHashEntry *xmlHashEntryPtr;\n-struct _xmlHashEntry {\n-    struct _xmlHashEntry *next;\n-    xmlChar *name;\n-    xmlChar *name2;\n-    xmlChar *name3;\n+typedef struct {\n+    unsigned hashValue; \/* 0 means unoccupied, occupied entries have the\n+                         * MAX_HASH_SIZE bit set to 1 *\/\n+    xmlChar *key;\n+    xmlChar *key2; \/* TODO: Don't allocate possibly empty keys *\/\n+    xmlChar *key3;\n@@ -57,2 +43,1 @@\n-    int valid;\n-};\n+} xmlHashEntry;\n@@ -64,3 +49,3 @@\n-    struct _xmlHashEntry *table;\n-    int size;\n-    int nbElems;\n+    xmlHashEntry *table;\n+    unsigned size; \/* power of two *\/\n+    unsigned nbElems;\n@@ -68,3 +53,1 @@\n-#ifdef HASH_RANDOMIZATION\n-    int random_seed;\n-#endif\n+    unsigned randomSeed;\n@@ -73,21 +56,14 @@\n-\/*\n- * xmlHashComputeKey:\n- * Calculate the hash key\n- *\/\n-#ifdef __clang__\n-ATTRIBUTE_NO_SANITIZE(\"unsigned-integer-overflow\")\n-#endif\n-static unsigned long\n-xmlHashComputeKey(xmlHashTablePtr table, const xmlChar *name,\n-                  const xmlChar *name2, const xmlChar *name3) {\n-    unsigned long value = 0L;\n-    unsigned long ch;\n-\n-#ifdef HASH_RANDOMIZATION\n-    value = table->random_seed;\n-#endif\n-    if (name != NULL) {\n-        value += 30 * (*name);\n-        while ((ch = *name++) != 0) {\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n-        }\n+static int\n+xmlHashGrow(xmlHashTablePtr hash, unsigned size);\n+\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static unsigned\n+xmlHashValue(unsigned seed, const xmlChar *key, const xmlChar *key2,\n+             const xmlChar *key3, size_t *lengths) {\n+    unsigned h1, h2;\n+    size_t i;\n+\n+    HASH_INIT(h1, h2, seed);\n+\n+    for (i = 0; key[i] != 0; i++) {\n+        HASH_UPDATE(h1, h2, key[i]);\n@@ -95,4 +71,8 @@\n-    value = value ^ ((value << 5) + (value >> 3));\n-    if (name2 != NULL) {\n-        while ((ch = *name2++) != 0) {\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+    if (lengths)\n+        lengths[0] = i;\n+\n+    HASH_UPDATE(h1, h2, 0);\n+\n+    if (key2 != NULL) {\n+        for (i = 0; key2[i] != 0; i++) {\n+            HASH_UPDATE(h1, h2, key2[i]);\n@@ -100,0 +80,2 @@\n+        if (lengths)\n+            lengths[1] = i;\n@@ -101,4 +83,6 @@\n-    value = value ^ ((value << 5) + (value >> 3));\n-    if (name3 != NULL) {\n-        while ((ch = *name3++) != 0) {\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+\n+    HASH_UPDATE(h1, h2, 0);\n+\n+    if (key3 != NULL) {\n+        for (i = 0; key3[i] != 0; i++) {\n+            HASH_UPDATE(h1, h2, key3[i]);\n@@ -106,0 +90,2 @@\n+        if (lengths)\n+            lengths[2] = i;\n@@ -107,1 +93,4 @@\n-    return (value % table->size);\n+\n+    HASH_FINISH(h1, h2);\n+\n+    return(h2);\n@@ -110,18 +99,9 @@\n-#ifdef __clang__\n-ATTRIBUTE_NO_SANITIZE(\"unsigned-integer-overflow\")\n-#endif\n-static unsigned long\n-xmlHashComputeQKey(xmlHashTablePtr table,\n-                   const xmlChar *prefix, const xmlChar *name,\n-                   const xmlChar *prefix2, const xmlChar *name2,\n-                   const xmlChar *prefix3, const xmlChar *name3) {\n-    unsigned long value = 0L;\n-    unsigned long ch;\n-\n-#ifdef HASH_RANDOMIZATION\n-    value = table->random_seed;\n-#endif\n-    if (prefix != NULL)\n-        value += 30 * (*prefix);\n-    else\n-        value += 30 * (*name);\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static unsigned\n+xmlHashQNameValue(unsigned seed,\n+                  const xmlChar *prefix, const xmlChar *name,\n+                  const xmlChar *prefix2, const xmlChar *name2,\n+                  const xmlChar *prefix3, const xmlChar *name3) {\n+    unsigned h1, h2, ch;\n+\n+    HASH_INIT(h1, h2, seed);\n@@ -131,1 +111,1 @@\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+            HASH_UPDATE(h1, h2, ch);\n@@ -133,1 +113,1 @@\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n+        HASH_UPDATE(h1, h2, ':');\n@@ -137,1 +117,1 @@\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+            HASH_UPDATE(h1, h2, ch);\n@@ -140,1 +120,1 @@\n-    value = value ^ ((value << 5) + (value >> 3));\n+    HASH_UPDATE(h1, h2, 0);\n@@ -143,1 +123,1 @@\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+            HASH_UPDATE(h1, h2, ch);\n@@ -145,1 +125,1 @@\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n+        HASH_UPDATE(h1, h2, ':');\n@@ -149,1 +129,1 @@\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+            HASH_UPDATE(h1, h2, ch);\n@@ -152,1 +132,1 @@\n-    value = value ^ ((value << 5) + (value >> 3));\n+    HASH_UPDATE(h1, h2, 0);\n@@ -155,1 +135,1 @@\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+            HASH_UPDATE(h1, h2, ch);\n@@ -157,1 +137,1 @@\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n+        HASH_UPDATE(h1, h2, ':');\n@@ -161,1 +141,1 @@\n-            value = value ^ ((value << 5) + (value >> 3) + ch);\n+            HASH_UPDATE(h1, h2, ch);\n@@ -164,1 +144,4 @@\n-    return (value % table->size);\n+\n+    HASH_FINISH(h1, h2);\n+\n+    return(h2);\n@@ -169,1 +152,1 @@\n- * @size: the size of the hash table\n+ * @size: initial size of the hash table\n@@ -171,1 +154,2 @@\n- * Create a new xmlHashTablePtr.\n+ * Create a new hash table. Set size to zero if the number of entries\n+ * can't be estimated.\n@@ -173,1 +157,1 @@\n- * Returns the newly created object, or NULL if an error occurred.\n+ * Returns the newly created object, or NULL if a memory allocation failed.\n@@ -177,15 +161,14 @@\n-    xmlHashTablePtr table;\n-\n-    if (size <= 0)\n-        size = 256;\n-\n-    table = xmlMalloc(sizeof(xmlHashTable));\n-    if (table) {\n-        table->dict = NULL;\n-        table->size = size;\n-        table->nbElems = 0;\n-        table->table = xmlMalloc(size * sizeof(xmlHashEntry));\n-        if (table->table) {\n-            memset(table->table, 0, size * sizeof(xmlHashEntry));\n-#ifdef HASH_RANDOMIZATION\n-            table->random_seed = __xmlRandom();\n+    xmlHashTablePtr hash;\n+\n+    xmlInitParser();\n+\n+    hash = xmlMalloc(sizeof(*hash));\n+    if (hash == NULL)\n+        return(NULL);\n+    hash->dict = NULL;\n+    hash->size = 0;\n+    hash->table = NULL;\n+    hash->nbElems = 0;\n+    hash->randomSeed = xmlRandom();\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    hash->randomSeed = 0;\n@@ -193,1 +176,15 @@\n-            return(table);\n+\n+    \/*\n+     * Unless a larger size is passed, the backing table is created\n+     * lazily with MIN_HASH_SIZE capacity. In practice, there are many\n+     * hash tables which are never filled.\n+     *\/\n+    if (size > MIN_HASH_SIZE) {\n+        unsigned newSize = MIN_HASH_SIZE * 2;\n+\n+        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))\n+            newSize *= 2;\n+\n+        if (xmlHashGrow(hash, newSize) != 0) {\n+            xmlFree(hash);\n+            return(NULL);\n@@ -195,1 +192,0 @@\n-        xmlFree(table);\n@@ -197,1 +193,2 @@\n-    return(NULL);\n+\n+    return(hash);\n@@ -205,1 +202,3 @@\n- * Create a new xmlHashTablePtr which will use @dict as the internal dictionary\n+ * Create a new hash table backed by a dictionary. This can reduce\n+ * resource usage considerably if most keys passed to API functions\n+ * originate from this dictionary.\n@@ -207,1 +206,1 @@\n- * Returns the newly created object, or NULL if an error occurred.\n+ * Returns the newly created object, or NULL if a memory allocation failed.\n@@ -211,1 +210,1 @@\n-    xmlHashTablePtr table;\n+    xmlHashTablePtr hash;\n@@ -213,3 +212,3 @@\n-    table = xmlHashCreate(size);\n-    if (table != NULL) {\n-        table->dict = dict;\n+    hash = xmlHashCreate(size);\n+    if (hash != NULL) {\n+        hash->dict = dict;\n@@ -218,1 +217,125 @@\n-    return(table);\n+    return(hash);\n+}\n+\n+\/**\n+ * xmlHashFree:\n+ * @hash: hash table\n+ * @dealloc: deallocator function or NULL\n+ *\n+ * Free the hash and its contents. The payload is deallocated with\n+ * @dealloc if provided.\n+ *\/\n+void\n+xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {\n+    if (hash == NULL)\n+        return;\n+\n+    if (hash->table) {\n+        const xmlHashEntry *end = &hash->table[hash->size];\n+        const xmlHashEntry *entry;\n+\n+        for (entry = hash->table; entry < end; entry++) {\n+            if (entry->hashValue == 0)\n+                continue;\n+            if ((dealloc != NULL) && (entry->payload != NULL))\n+                dealloc(entry->payload, entry->key);\n+            if (hash->dict == NULL) {\n+                if (entry->key)\n+                    xmlFree(entry->key);\n+                if (entry->key2)\n+                    xmlFree(entry->key2);\n+                if (entry->key3)\n+                    xmlFree(entry->key3);\n+            }\n+        }\n+\n+        xmlFree(hash->table);\n+    }\n+\n+    if (hash->dict)\n+        xmlDictFree(hash->dict);\n+\n+    xmlFree(hash);\n+}\n+\n+\/**\n+ * xmlFastStrEqual:\n+ * @s1: string\n+ * @s2: string\n+ *\n+ * Compare two strings for equality, allowing NULL values.\n+ *\/\n+static int\n+xmlFastStrEqual(const xmlChar *s1, const xmlChar *s2) {\n+    if (s1 == NULL)\n+        return(s2 == NULL);\n+    else\n+        return((s2 != NULL) &&\n+               (strcmp((const char *) s1, (const char *) s2) == 0));\n+}\n+\n+\/**\n+ * xmlHashFindEntry:\n+ * @hash: hash table, non-NULL, size > 0\n+ * @key: first string key, non-NULL\n+ * @key2: second string key\n+ * @key3: third string key\n+ * @hashValue: valid hash value of keys\n+ * @pfound: result of search\n+ *\n+ * Try to find a matching hash table entry. If an entry was found, set\n+ * @found to 1 and return the entry. Otherwise, set @found to 0 and return\n+ * the location where a new entry should be inserted.\n+ *\/\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static xmlHashEntry *\n+xmlHashFindEntry(const xmlHashTable *hash, const xmlChar *key,\n+                 const xmlChar *key2, const xmlChar *key3,\n+                 unsigned hashValue, int *pfound) {\n+    xmlHashEntry *entry;\n+    unsigned mask, pos, displ;\n+    int found = 0;\n+\n+    mask = hash->size - 1;\n+    pos = hashValue & mask;\n+    entry = &hash->table[pos];\n+\n+    if (entry->hashValue != 0) {\n+        \/*\n+         * Robin hood hashing: abort if the displacement of the entry\n+         * is smaller than the displacement of the key we look for.\n+         * This also stops at the correct position when inserting.\n+         *\/\n+        displ = 0;\n+        hashValue |= MAX_HASH_SIZE;\n+\n+        do {\n+            if (entry->hashValue == hashValue) {\n+                if (hash->dict) {\n+                    if ((entry->key == key) &&\n+                        (entry->key2 == key2) &&\n+                        (entry->key3 == key3)) {\n+                        found = 1;\n+                        break;\n+                    }\n+                }\n+                if ((strcmp((const char *) entry->key,\n+                            (const char *) key) == 0) &&\n+                    (xmlFastStrEqual(entry->key2, key2)) &&\n+                    (xmlFastStrEqual(entry->key3, key3))) {\n+                    found = 1;\n+                    break;\n+                }\n+            }\n+\n+            displ++;\n+            pos++;\n+            entry++;\n+            if ((pos & mask) == 0)\n+                entry = hash->table;\n+        } while ((entry->hashValue != 0) &&\n+                 (((pos - entry->hashValue) & mask) >= displ));\n+    }\n+\n+    *pfound = found;\n+    return(entry);\n@@ -223,2 +346,2 @@\n- * @table: the hash table\n- * @size: the new size of the hash table\n+ * @hash: hash table\n+ * @size: new size of the hash table\n@@ -226,1 +349,1 @@\n- * resize the hash table\n+ * Resize the hash table.\n@@ -228,1 +351,1 @@\n- * Returns 0 in case of success, -1 in case of failure\n+ * Returns 0 in case of success, -1 if a memory allocation failed.\n@@ -231,8 +354,4 @@\n-xmlHashGrow(xmlHashTablePtr table, int size) {\n-    unsigned long key;\n-    int oldsize, i;\n-    xmlHashEntryPtr iter, next;\n-    struct _xmlHashEntry *oldtable;\n-#ifdef DEBUG_GROW\n-    unsigned long nbElem = 0;\n-#endif\n+xmlHashGrow(xmlHashTablePtr hash, unsigned size) {\n+    const xmlHashEntry *oldentry, *oldend, *end;\n+    xmlHashEntry *table;\n+    unsigned oldsize, i;\n@@ -240,3 +359,2 @@\n-    if (table == NULL)\n-        return(-1);\n-    if (size < 8)\n+    \/* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC *\/\n+    if ((size_t) size + 0 > SIZE_MAX \/ sizeof(table[0]))\n@@ -244,1 +362,2 @@\n-    if (size > 8 * 2048)\n+    table = xmlMalloc(size * sizeof(table[0]));\n+    if (table == NULL)\n@@ -246,0 +365,1 @@\n+    memset(table, 0, size * sizeof(table[0]));\n@@ -247,4 +367,3 @@\n-    oldsize = table->size;\n-    oldtable = table->table;\n-    if (oldtable == NULL)\n-        return(-1);\n+    oldsize = hash->size;\n+    if (oldsize == 0)\n+        goto done;\n@@ -252,21 +371,14 @@\n-    table->table = xmlMalloc(size * sizeof(xmlHashEntry));\n-    if (table->table == NULL) {\n-        table->table = oldtable;\n-        return(-1);\n-    }\n-    memset(table->table, 0, size * sizeof(xmlHashEntry));\n-    table->size = size;\n-\n-    \/*  If the two loops are merged, there would be situations where\n-        a new entry needs to allocated and data copied into it from\n-        the main table. So instead, we run through the array twice, first\n-        copying all the elements in the main array (where we can't get\n-        conflicts) and then the rest, so we only free (and don't allocate)\n-    *\/\n-    for (i = 0; i < oldsize; i++) {\n-        if (oldtable[i].valid == 0)\n-            continue;\n-        key = xmlHashComputeKey(table, oldtable[i].name, oldtable[i].name2,\n-                                oldtable[i].name3);\n-        memcpy(&(table->table[key]), &(oldtable[i]), sizeof(xmlHashEntry));\n-        table->table[key].next = NULL;\n+    oldend = &hash->table[oldsize];\n+    end = &table[size];\n+\n+    \/*\n+     * Robin Hood sorting order is maintained if we\n+     *\n+     * - compute hash indices with modulo\n+     * - resize by an integer factor\n+     * - start to copy from the beginning of a probe sequence\n+     *\/\n+    oldentry = hash->table;\n+    while (oldentry->hashValue != 0) {\n+        if (++oldentry >= oldend)\n+            oldentry = hash->table;\n@@ -276,3 +388,2 @@\n-        iter = oldtable[i].next;\n-        while (iter) {\n-            next = iter->next;\n+        if (oldentry->hashValue != 0) {\n+            xmlHashEntry *entry = &table[oldentry->hashValue & (size - 1)];\n@@ -280,13 +391,3 @@\n-            \/*\n-             * put back the entry in the new table\n-             *\/\n-\n-            key = xmlHashComputeKey(table, iter->name, iter->name2,\n-                                    iter->name3);\n-            if (table->table[key].valid == 0) {\n-                memcpy(&(table->table[key]), iter, sizeof(xmlHashEntry));\n-                table->table[key].next = NULL;\n-                xmlFree(iter);\n-            } else {\n-                iter->next = table->table[key].next;\n-                table->table[key].next = iter;\n+            while (entry->hashValue != 0) {\n+                if (++entry >= end)\n+                    entry = table;\n@@ -294,6 +395,1 @@\n-\n-#ifdef DEBUG_GROW\n-            nbElem++;\n-#endif\n-\n-            iter = next;\n+            *entry = *oldentry;\n@@ -301,0 +397,3 @@\n+\n+        if (++oldentry >= oldend)\n+            oldentry = hash->table;\n@@ -303,1 +402,1 @@\n-    xmlFree(oldtable);\n+    xmlFree(hash->table);\n@@ -305,4 +404,3 @@\n-#ifdef DEBUG_GROW\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"xmlHashGrow : from %d to %d, %d elems\\n\", oldsize, size, nbElem);\n-#endif\n+done:\n+    hash->table = table;\n+    hash->size = size;\n@@ -314,3 +412,8 @@\n- * xmlHashFree:\n- * @table: the hash table\n- * @f:  the deallocator function for items in the hash\n+ * xmlHashUpdateInternal:\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @key3: third string key\n+ * @payload: pointer to the payload\n+ * @dealloc: deallocator function for replaced item or NULL\n+ * @update: whether existing entries should be updated\n@@ -318,2 +421,1 @@\n- * Free the hash @table and its contents. The userdata is\n- * deallocated with @f if provided.\n+ * Internal function to add or update hash entries.\n@@ -321,7 +423,13 @@\n-void\n-xmlHashFree(xmlHashTablePtr table, xmlHashDeallocator f) {\n-    int i;\n-    xmlHashEntryPtr iter;\n-    xmlHashEntryPtr next;\n-    int inside_table = 0;\n-    int nbElems;\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static int\n+xmlHashUpdateInternal(xmlHashTablePtr hash, const xmlChar *key,\n+                      const xmlChar *key2, const xmlChar *key3,\n+                      void *payload, xmlHashDeallocator dealloc, int update) {\n+    xmlChar *copy, *copy2, *copy3;\n+    xmlHashEntry *entry = NULL;\n+    size_t lengths[3];\n+    unsigned hashValue;\n+    int found = 0;\n+\n+    if ((hash == NULL) || (key == NULL))\n+        return(-1);\n@@ -329,27 +437,109 @@\n-    if (table == NULL)\n-        return;\n-    if (table->table) {\n-        nbElems = table->nbElems;\n-        for(i = 0; (i < table->size) && (nbElems > 0); i++) {\n-            iter = &(table->table[i]);\n-            if (iter->valid == 0)\n-                continue;\n-            inside_table = 1;\n-            while (iter) {\n-                next = iter->next;\n-                if ((f != NULL) && (iter->payload != NULL))\n-                    f(iter->payload, iter->name);\n-                if (table->dict == NULL) {\n-                    if (iter->name)\n-                        xmlFree(iter->name);\n-                    if (iter->name2)\n-                        xmlFree(iter->name2);\n-                    if (iter->name3)\n-                        xmlFree(iter->name3);\n-                }\n-                iter->payload = NULL;\n-                if (!inside_table)\n-                    xmlFree(iter);\n-                nbElems--;\n-                inside_table = 0;\n-                iter = next;\n+    \/*\n+     * Check for an existing entry\n+     *\/\n+    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);\n+    if (hash->size > 0)\n+        entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);\n+    if (found) {\n+        if (update) {\n+            if (dealloc)\n+                dealloc(entry->payload, entry->key);\n+            entry->payload = payload;\n+            return(0);\n+        } else {\n+            \/*\n+             * xmlHashAddEntry found an existing entry.\n+             *\n+             * TODO: We should return a different error code here to\n+             * distinguish from malloc failures.\n+             *\/\n+            return(-1);\n+        }\n+    }\n+\n+    \/*\n+     * Grow the hash table if needed\n+     *\/\n+    if (hash->nbElems + 1 > hash->size \/ MAX_FILL_DENOM * MAX_FILL_NUM) {\n+        unsigned newSize, mask, displ, pos;\n+\n+        if (hash->size == 0) {\n+            newSize = MIN_HASH_SIZE;\n+        } else {\n+            \/* This guarantees that nbElems < INT_MAX *\/\n+            if (hash->size >= MAX_HASH_SIZE)\n+                return(-1);\n+            newSize = hash->size * 2;\n+        }\n+        if (xmlHashGrow(hash, newSize) != 0)\n+            return(-1);\n+\n+        \/*\n+         * Find new entry\n+         *\/\n+        mask = hash->size - 1;\n+        displ = 0;\n+        pos = hashValue & mask;\n+        entry = &hash->table[pos];\n+\n+        if (entry->hashValue != 0) {\n+            do {\n+                displ++;\n+                pos++;\n+                entry++;\n+                if ((pos & mask) == 0)\n+                    entry = hash->table;\n+            } while ((entry->hashValue != 0) &&\n+                     ((pos - entry->hashValue) & mask) >= displ);\n+        }\n+    }\n+\n+    \/*\n+     * Copy keys\n+     *\/\n+    if (hash->dict != NULL) {\n+        if (xmlDictOwns(hash->dict, key)) {\n+            copy = (xmlChar *) key;\n+        } else {\n+            copy = (xmlChar *) xmlDictLookup(hash->dict, key, -1);\n+            if (copy == NULL)\n+                return(-1);\n+        }\n+\n+        if ((key2 == NULL) || (xmlDictOwns(hash->dict, key2))) {\n+            copy2 = (xmlChar *) key2;\n+        } else {\n+            copy2 = (xmlChar *) xmlDictLookup(hash->dict, key2, -1);\n+            if (copy2 == NULL)\n+                return(-1);\n+        }\n+        if ((key3 == NULL) || (xmlDictOwns(hash->dict, key3))) {\n+            copy3 = (xmlChar *) key3;\n+        } else {\n+            copy3 = (xmlChar *) xmlDictLookup(hash->dict, key3, -1);\n+            if (copy3 == NULL)\n+                return(-1);\n+        }\n+    } else {\n+        copy = xmlMalloc(lengths[0] + 1);\n+        if (copy == NULL)\n+            return(-1);\n+        memcpy(copy, key, lengths[0] + 1);\n+\n+        if (key2 != NULL) {\n+            copy2 = xmlMalloc(lengths[1] + 1);\n+            if (copy2 == NULL) {\n+                xmlFree(copy);\n+                return(-1);\n+            }\n+            memcpy(copy2, key2, lengths[1] + 1);\n+        } else {\n+            copy2 = NULL;\n+        }\n+\n+        if (key3 != NULL) {\n+            copy3 = xmlMalloc(lengths[2] + 1);\n+            if (copy3 == NULL) {\n+                xmlFree(copy);\n+                xmlFree(copy2);\n+                return(-1);\n@@ -357,0 +547,3 @@\n+            memcpy(copy3, key3, lengths[2] + 1);\n+        } else {\n+            copy3 = NULL;\n@@ -358,1 +551,0 @@\n-        xmlFree(table->table);\n@@ -360,3 +552,41 @@\n-    if (table->dict)\n-        xmlDictFree(table->dict);\n-    xmlFree(table);\n+\n+    \/*\n+     * Shift the remainder of the probe sequence to the right\n+     *\/\n+    if (entry->hashValue != 0) {\n+        const xmlHashEntry *end = &hash->table[hash->size];\n+        const xmlHashEntry *cur = entry;\n+\n+        do {\n+            cur++;\n+            if (cur >= end)\n+                cur = hash->table;\n+        } while (cur->hashValue != 0);\n+\n+        if (cur < entry) {\n+            \/*\n+             * If we traversed the end of the buffer, handle the part\n+             * at the start of the buffer.\n+             *\/\n+            memmove(&hash->table[1], hash->table,\n+                    (char *) cur - (char *) hash->table);\n+            cur = end - 1;\n+            hash->table[0] = *cur;\n+        }\n+\n+        memmove(&entry[1], entry, (char *) cur - (char *) entry);\n+    }\n+\n+    \/*\n+     * Populate entry\n+     *\/\n+    entry->key = copy;\n+    entry->key2 = copy2;\n+    entry->key3 = copy3;\n+    entry->payload = payload;\n+    \/* OR with MAX_HASH_SIZE to make sure that the value is non-zero *\/\n+    entry->hashValue = hashValue | MAX_HASH_SIZE;\n+\n+    hash->nbElems++;\n+\n+    return(0);\n@@ -367,2 +597,2 @@\n- * @entry: the hash table entry\n- * @name: the entry's name\n+ * @entry: hash table entry\n+ * @key: the entry's string key\n@@ -373,1 +603,1 @@\n-xmlHashDefaultDeallocator(void *entry, const xmlChar *name ATTRIBUTE_UNUSED) {\n+xmlHashDefaultDeallocator(void *entry, const xmlChar *key ATTRIBUTE_UNUSED) {\n@@ -379,3 +609,3 @@\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @userdata: a pointer to the userdata\n+ * @hash: hash table\n+ * @key: string key\n+ * @payload: pointer to the payload\n@@ -383,2 +613,4 @@\n- * Add the @userdata to the hash @table. This can later be retrieved\n- * by using the @name. Duplicate names generate errors.\n+ * Add a hash table entry. If an entry with this key already exists,\n+ * payload will not be updated and -1 is returned. This return value\n+ * can't be distinguished from out-of-memory errors, so this function\n+ * should be used with care.\n@@ -386,1 +618,1 @@\n- * Returns 0 the addition succeeded and -1 in case of error.\n+ * Returns 0 on success and -1 in case of error.\n@@ -389,2 +621,2 @@\n-xmlHashAddEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata) {\n-    return(xmlHashAddEntry3(table, name, NULL, NULL, userdata));\n+xmlHashAddEntry(xmlHashTablePtr hash, const xmlChar *key, void *payload) {\n+    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload, NULL, 0));\n@@ -395,4 +627,4 @@\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n- * @userdata: a pointer to the userdata\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @payload: pointer to the payload\n@@ -400,2 +632,1 @@\n- * Add the @userdata to the hash @table. This can later be retrieved\n- * by using the (@name, @name2) tuple. Duplicate tuples generate errors.\n+ * Add a hash table entry with two strings as key.\n@@ -403,1 +634,3 @@\n- * Returns 0 the addition succeeded and -1 in case of error.\n+ * See xmlHashAddEntry.\n+ *\n+ * Returns 0 on success and -1 in case of error.\n@@ -406,3 +639,3 @@\n-xmlHashAddEntry2(xmlHashTablePtr table, const xmlChar *name,\n-                const xmlChar *name2, void *userdata) {\n-    return(xmlHashAddEntry3(table, name, name2, NULL, userdata));\n+xmlHashAddEntry2(xmlHashTablePtr hash, const xmlChar *key,\n+                 const xmlChar *key2, void *payload) {\n+    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload, NULL, 0));\n@@ -412,5 +645,6 @@\n- * xmlHashUpdateEntry:\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @userdata: a pointer to the userdata\n- * @f: the deallocator function for replaced item (if any)\n+ * xmlHashAddEntry3:\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @key3: third string key\n+ * @payload: pointer to the payload\n@@ -418,3 +652,1 @@\n- * Add the @userdata to the hash @table. This can later be retrieved\n- * by using the @name. Existing entry for this @name will be removed\n- * and freed with @f if found.\n+ * Add a hash table entry with three strings as key.\n@@ -422,1 +654,3 @@\n- * Returns 0 the addition succeeded and -1 in case of error.\n+ * See xmlHashAddEntry.\n+ *\n+ * Returns 0 on success and -1 in case of error.\n@@ -425,3 +659,4 @@\n-xmlHashUpdateEntry(xmlHashTablePtr table, const xmlChar *name,\n-                   void *userdata, xmlHashDeallocator f) {\n-    return(xmlHashUpdateEntry3(table, name, NULL, NULL, userdata, f));\n+xmlHashAddEntry3(xmlHashTablePtr hash, const xmlChar *key,\n+                 const xmlChar *key2, const xmlChar *key3,\n+                 void *payload) {\n+    return(xmlHashUpdateInternal(hash, key, key2, key3, payload, NULL, 0));\n@@ -431,6 +666,5 @@\n- * xmlHashUpdateEntry2:\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n- * @userdata: a pointer to the userdata\n- * @f: the deallocator function for replaced item (if any)\n+ * xmlHashUpdateEntry:\n+ * @hash: hash table\n+ * @key: string key\n+ * @payload: pointer to the payload\n+ * @dealloc: deallocator function for replaced item or NULL\n@@ -438,3 +672,2 @@\n- * Add the @userdata to the hash @table. This can later be retrieved\n- * by using the (@name, @name2) tuple. Existing entry for this tuple will\n- * be removed and freed with @f if found.\n+ * Add a hash table entry. If an entry with this key already exists,\n+ * the old payload will be freed and updated with the new value.\n@@ -442,1 +675,1 @@\n- * Returns 0 the addition succeeded and -1 in case of error.\n+ * Returns 0 in case of success, -1 if a memory allocation failed.\n@@ -445,4 +678,4 @@\n-xmlHashUpdateEntry2(xmlHashTablePtr table, const xmlChar *name,\n-                   const xmlChar *name2, void *userdata,\n-                   xmlHashDeallocator f) {\n-    return(xmlHashUpdateEntry3(table, name, name2, NULL, userdata, f));\n+xmlHashUpdateEntry(xmlHashTablePtr hash, const xmlChar *key,\n+                   void *payload, xmlHashDeallocator dealloc) {\n+    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload,\n+                                 dealloc, 1));\n@@ -452,3 +685,6 @@\n- * xmlHashLookup:\n- * @table: the hash table\n- * @name: the name of the userdata\n+ * xmlHashUpdateEntry2:\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @payload: pointer to the payload\n+ * @dealloc: deallocator function for replaced item or NULL\n@@ -456,1 +692,1 @@\n- * Find the userdata specified by the @name.\n+ * Add a hash table entry with two strings as key.\n@@ -458,1 +694,3 @@\n- * Returns the pointer to the userdata\n+ * See xmlHashUpdateEntry.\n+ *\n+ * Returns 0 on success and -1 in case of error.\n@@ -460,3 +698,6 @@\n-void *\n-xmlHashLookup(xmlHashTablePtr table, const xmlChar *name) {\n-    return(xmlHashLookup3(table, name, NULL, NULL));\n+int\n+xmlHashUpdateEntry2(xmlHashTablePtr hash, const xmlChar *key,\n+                   const xmlChar *key2, void *payload,\n+                   xmlHashDeallocator dealloc) {\n+    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload,\n+                                 dealloc, 1));\n@@ -466,4 +707,9 @@\n- * xmlHashLookup2:\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n+ * xmlHashUpdateEntry3:\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @key3: third string key\n+ * @payload: pointer to the payload\n+ * @dealloc: deallocator function for replaced item or NULL\n+ *\n+ * Add a hash table entry with three strings as key.\n@@ -471,1 +717,1 @@\n- * Find the userdata specified by the (@name, @name2) tuple.\n+ * See xmlHashUpdateEntry.\n@@ -473,1 +719,1 @@\n- * Returns the pointer to the userdata\n+ * Returns 0 on success and -1 in case of error.\n@@ -475,4 +721,6 @@\n-void *\n-xmlHashLookup2(xmlHashTablePtr table, const xmlChar *name,\n-              const xmlChar *name2) {\n-    return(xmlHashLookup3(table, name, name2, NULL));\n+int\n+xmlHashUpdateEntry3(xmlHashTablePtr hash, const xmlChar *key,\n+                   const xmlChar *key2, const xmlChar *key3,\n+                   void *payload, xmlHashDeallocator dealloc) {\n+    return(xmlHashUpdateInternal(hash, key, key2, key3, payload,\n+                                 dealloc, 1));\n@@ -482,4 +730,3 @@\n- * xmlHashQLookup:\n- * @table: the hash table\n- * @prefix: the prefix of the userdata\n- * @name: the name of the userdata\n+ * xmlHashLookup:\n+ * @hash: hash table\n+ * @key: string key\n@@ -487,1 +734,1 @@\n- * Find the userdata specified by the QName @prefix:@name\/@name.\n+ * Find the entry specified by @key.\n@@ -489,1 +736,1 @@\n- * Returns the pointer to the userdata\n+ * Returns a pointer to the payload or NULL if no entry was found.\n@@ -492,3 +739,2 @@\n-xmlHashQLookup(xmlHashTablePtr table, const xmlChar *prefix,\n-               const xmlChar *name) {\n-    return(xmlHashQLookup3(table, prefix, name, NULL, NULL, NULL, NULL));\n+xmlHashLookup(xmlHashTablePtr hash, const xmlChar *key) {\n+    return(xmlHashLookup3(hash, key, NULL, NULL));\n@@ -498,6 +744,4 @@\n- * xmlHashQLookup2:\n- * @table: the hash table\n- * @prefix: the prefix of the userdata\n- * @name: the name of the userdata\n- * @prefix2: the second prefix of the userdata\n- * @name2: a second name of the userdata\n+ * xmlHashLookup2:\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n@@ -505,1 +749,1 @@\n- * Find the userdata specified by the QNames tuple\n+ * Find the payload specified by the (@key, @key2) tuple.\n@@ -507,1 +751,1 @@\n- * Returns the pointer to the userdata\n+ * Returns a pointer to the payload or NULL if no entry was found.\n@@ -510,4 +754,3 @@\n-xmlHashQLookup2(xmlHashTablePtr table, const xmlChar *prefix,\n-                const xmlChar *name, const xmlChar *prefix2,\n-                const xmlChar *name2) {\n-    return(xmlHashQLookup3(table, prefix, name, prefix2, name2, NULL, NULL));\n+xmlHashLookup2(xmlHashTablePtr hash, const xmlChar *key,\n+              const xmlChar *key2) {\n+    return(xmlHashLookup3(hash, key, key2, NULL));\n@@ -517,6 +760,4 @@\n- * xmlHashAddEntry3:\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n- * @name3: a third name of the userdata\n- * @userdata: a pointer to the userdata\n+ * xmlHashQLookup:\n+ * @hash: hash table\n+ * @prefix: prefix of the string key\n+ * @name: local name of the string key\n@@ -524,3 +765,1 @@\n- * Add the @userdata to the hash @table. This can later be retrieved\n- * by using the tuple (@name, @name2, @name3). Duplicate entries generate\n- * errors.\n+ * Find the payload specified by the QName @prefix:@name or @name.\n@@ -528,1 +767,1 @@\n- * Returns 0 the addition succeeded and -1 in case of error.\n+ * Returns a pointer to the payload or NULL if no entry was found.\n@@ -530,99 +769,4 @@\n-int\n-xmlHashAddEntry3(xmlHashTablePtr table, const xmlChar *name,\n-                 const xmlChar *name2, const xmlChar *name3,\n-                 void *userdata) {\n-    unsigned long key, len = 0;\n-    xmlHashEntryPtr entry;\n-    xmlHashEntryPtr insert;\n-\n-    if ((table == NULL) || (name == NULL))\n-        return(-1);\n-\n-    \/*\n-     * If using a dict internalize if needed\n-     *\/\n-    if (table->dict) {\n-        if (!xmlDictOwns(table->dict, name)) {\n-            name = xmlDictLookup(table->dict, name, -1);\n-            if (name == NULL)\n-                return(-1);\n-        }\n-        if ((name2 != NULL) && (!xmlDictOwns(table->dict, name2))) {\n-            name2 = xmlDictLookup(table->dict, name2, -1);\n-            if (name2 == NULL)\n-                return(-1);\n-        }\n-        if ((name3 != NULL) && (!xmlDictOwns(table->dict, name3))) {\n-            name3 = xmlDictLookup(table->dict, name3, -1);\n-            if (name3 == NULL)\n-                return(-1);\n-        }\n-    }\n-\n-    \/*\n-     * Check for duplicate and insertion location.\n-     *\/\n-    key = xmlHashComputeKey(table, name, name2, name3);\n-    if (table->table[key].valid == 0) {\n-        insert = NULL;\n-    } else {\n-        if (table->dict) {\n-            for (insert = &(table->table[key]); insert->next != NULL;\n-                 insert = insert->next) {\n-                if ((insert->name == name) &&\n-                    (insert->name2 == name2) &&\n-                    (insert->name3 == name3))\n-                    return(-1);\n-                len++;\n-            }\n-            if ((insert->name == name) &&\n-                (insert->name2 == name2) &&\n-                (insert->name3 == name3))\n-                return(-1);\n-        } else {\n-            for (insert = &(table->table[key]); insert->next != NULL;\n-                 insert = insert->next) {\n-                if ((xmlStrEqual(insert->name, name)) &&\n-                    (xmlStrEqual(insert->name2, name2)) &&\n-                    (xmlStrEqual(insert->name3, name3)))\n-                    return(-1);\n-                len++;\n-            }\n-            if ((xmlStrEqual(insert->name, name)) &&\n-                (xmlStrEqual(insert->name2, name2)) &&\n-                (xmlStrEqual(insert->name3, name3)))\n-                return(-1);\n-        }\n-    }\n-\n-    if (insert == NULL) {\n-        entry = &(table->table[key]);\n-    } else {\n-        entry = xmlMalloc(sizeof(xmlHashEntry));\n-        if (entry == NULL)\n-             return(-1);\n-    }\n-\n-    if (table->dict != NULL) {\n-        entry->name = (xmlChar *) name;\n-        entry->name2 = (xmlChar *) name2;\n-        entry->name3 = (xmlChar *) name3;\n-    } else {\n-        entry->name = xmlStrdup(name);\n-        entry->name2 = xmlStrdup(name2);\n-        entry->name3 = xmlStrdup(name3);\n-    }\n-    entry->payload = userdata;\n-    entry->next = NULL;\n-    entry->valid = 1;\n-\n-\n-    if (insert != NULL)\n-        insert->next = entry;\n-\n-    table->nbElems++;\n-\n-    if (len > MAX_HASH_LEN)\n-        xmlHashGrow(table, MAX_HASH_LEN * table->size);\n-\n-    return(0);\n+void *\n+xmlHashQLookup(xmlHashTablePtr hash, const xmlChar *prefix,\n+               const xmlChar *name) {\n+    return(xmlHashQLookup3(hash, prefix, name, NULL, NULL, NULL, NULL));\n@@ -632,7 +776,6 @@\n- * xmlHashUpdateEntry3:\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n- * @name3: a third name of the userdata\n- * @userdata: a pointer to the userdata\n- * @f: the deallocator function for replaced item (if any)\n+ * xmlHashQLookup2:\n+ * @hash: hash table\n+ * @prefix: first prefix\n+ * @name: first local name\n+ * @prefix2: second prefix\n+ * @name2: second local name\n@@ -640,3 +783,1 @@\n- * Add the @userdata to the hash @table. This can later be retrieved\n- * by using the tuple (@name, @name2, @name3). Existing entry for this tuple\n- * will be removed and freed with @f if found.\n+ * Find the payload specified by the QNames tuple.\n@@ -644,1 +785,1 @@\n- * Returns 0 the addition succeeded and -1 in case of error.\n+ * Returns a pointer to the payload or NULL if no entry was found.\n@@ -646,109 +787,5 @@\n-int\n-xmlHashUpdateEntry3(xmlHashTablePtr table, const xmlChar *name,\n-                   const xmlChar *name2, const xmlChar *name3,\n-                   void *userdata, xmlHashDeallocator f) {\n-    unsigned long key;\n-    xmlHashEntryPtr entry;\n-    xmlHashEntryPtr insert;\n-\n-    if ((table == NULL) || name == NULL)\n-        return(-1);\n-\n-    \/*\n-     * If using a dict internalize if needed\n-     *\/\n-    if (table->dict) {\n-        if (!xmlDictOwns(table->dict, name)) {\n-            name = xmlDictLookup(table->dict, name, -1);\n-            if (name == NULL)\n-                return(-1);\n-        }\n-        if ((name2 != NULL) && (!xmlDictOwns(table->dict, name2))) {\n-            name2 = xmlDictLookup(table->dict, name2, -1);\n-            if (name2 == NULL)\n-                return(-1);\n-        }\n-        if ((name3 != NULL) && (!xmlDictOwns(table->dict, name3))) {\n-            name3 = xmlDictLookup(table->dict, name3, -1);\n-            if (name3 == NULL)\n-                return(-1);\n-        }\n-    }\n-\n-    \/*\n-     * Check for duplicate and insertion location.\n-     *\/\n-    key = xmlHashComputeKey(table, name, name2, name3);\n-    if (table->table[key].valid == 0) {\n-        insert = NULL;\n-    } else {\n-        if (table ->dict) {\n-            for (insert = &(table->table[key]); insert->next != NULL;\n-                 insert = insert->next) {\n-                if ((insert->name == name) &&\n-                    (insert->name2 == name2) &&\n-                    (insert->name3 == name3)) {\n-                    if (f)\n-                        f(insert->payload, insert->name);\n-                    insert->payload = userdata;\n-                    return(0);\n-                }\n-            }\n-            if ((insert->name == name) &&\n-                (insert->name2 == name2) &&\n-                (insert->name3 == name3)) {\n-                if (f)\n-                    f(insert->payload, insert->name);\n-                insert->payload = userdata;\n-                return(0);\n-            }\n-        } else {\n-            for (insert = &(table->table[key]); insert->next != NULL;\n-                 insert = insert->next) {\n-                if ((xmlStrEqual(insert->name, name)) &&\n-                    (xmlStrEqual(insert->name2, name2)) &&\n-                    (xmlStrEqual(insert->name3, name3))) {\n-                    if (f)\n-                        f(insert->payload, insert->name);\n-                    insert->payload = userdata;\n-                    return(0);\n-                }\n-            }\n-            if ((xmlStrEqual(insert->name, name)) &&\n-                (xmlStrEqual(insert->name2, name2)) &&\n-                (xmlStrEqual(insert->name3, name3))) {\n-                if (f)\n-                    f(insert->payload, insert->name);\n-                insert->payload = userdata;\n-                return(0);\n-            }\n-        }\n-    }\n-\n-    if (insert == NULL) {\n-        entry =  &(table->table[key]);\n-    } else {\n-        entry = xmlMalloc(sizeof(xmlHashEntry));\n-        if (entry == NULL)\n-             return(-1);\n-    }\n-\n-    if (table->dict != NULL) {\n-        entry->name = (xmlChar *) name;\n-        entry->name2 = (xmlChar *) name2;\n-        entry->name3 = (xmlChar *) name3;\n-    } else {\n-        entry->name = xmlStrdup(name);\n-        entry->name2 = xmlStrdup(name2);\n-        entry->name3 = xmlStrdup(name3);\n-    }\n-    entry->payload = userdata;\n-    entry->next = NULL;\n-    entry->valid = 1;\n-    table->nbElems++;\n-\n-\n-    if (insert != NULL) {\n-        insert->next = entry;\n-    }\n-    return(0);\n+void *\n+xmlHashQLookup2(xmlHashTablePtr hash, const xmlChar *prefix,\n+                const xmlChar *name, const xmlChar *prefix2,\n+                const xmlChar *name2) {\n+    return(xmlHashQLookup3(hash, prefix, name, prefix2, name2, NULL, NULL));\n@@ -759,4 +796,4 @@\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n- * @name3: a third name of the userdata\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @key3: third string key\n@@ -764,1 +801,1 @@\n- * Find the userdata specified by the (@name, @name2, @name3) tuple.\n+ * Find the payload specified by the (@key, @key2, @key3) tuple.\n@@ -766,1 +803,1 @@\n- * Returns the a pointer to the userdata\n+ * Returns a pointer to the payload or NULL if no entry was found.\n@@ -769,4 +806,5 @@\n-xmlHashLookup3(xmlHashTablePtr table, const xmlChar *name,\n-               const xmlChar *name2, const xmlChar *name3) {\n-    unsigned long key;\n-    xmlHashEntryPtr entry;\n+xmlHashLookup3(xmlHashTablePtr hash, const xmlChar *key,\n+               const xmlChar *key2, const xmlChar *key3) {\n+    const xmlHashEntry *entry;\n+    unsigned hashValue;\n+    int found;\n@@ -774,3 +812,1 @@\n-    if (table == NULL)\n-        return(NULL);\n-    if (name == NULL)\n+    if ((hash == NULL) || (hash->size == 0) || (key == NULL))\n@@ -778,17 +814,4 @@\n-    key = xmlHashComputeKey(table, name, name2, name3);\n-    if (table->table[key].valid == 0)\n-        return(NULL);\n-    if (table->dict) {\n-        for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {\n-            if ((entry->name == name) &&\n-                (entry->name2 == name2) &&\n-                (entry->name3 == name3))\n-                return(entry->payload);\n-        }\n-    }\n-    for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {\n-        if ((xmlStrEqual(entry->name, name)) &&\n-            (xmlStrEqual(entry->name2, name2)) &&\n-            (xmlStrEqual(entry->name3, name3)))\n-            return(entry->payload);\n-    }\n+    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);\n+    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);\n+    if (found)\n+        return(entry->payload);\n@@ -800,7 +823,7 @@\n- * @table: the hash table\n- * @prefix: the prefix of the userdata\n- * @name: the name of the userdata\n- * @prefix2: the second prefix of the userdata\n- * @name2: a second name of the userdata\n- * @prefix3: the third prefix of the userdata\n- * @name3: a third name of the userdata\n+ * @hash: hash table\n+ * @prefix: first prefix\n+ * @name: first local name\n+ * @prefix2: second prefix\n+ * @name2: second local name\n+ * @prefix3: third prefix\n+ * @name3: third local name\n@@ -808,1 +831,1 @@\n- * Find the userdata specified by the (@name, @name2, @name3) tuple.\n+ * Find the payload specified by the QNames tuple.\n@@ -810,1 +833,1 @@\n- * Returns the a pointer to the userdata\n+ * Returns a pointer to the payload or NULL if no entry was found.\n@@ -812,0 +835,1 @@\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n@@ -813,1 +837,1 @@\n-xmlHashQLookup3(xmlHashTablePtr table,\n+xmlHashQLookup3(xmlHashTablePtr hash,\n@@ -817,2 +841,2 @@\n-    unsigned long key;\n-    xmlHashEntryPtr entry;\n+    const xmlHashEntry *entry;\n+    unsigned hashValue, mask, pos, displ;\n@@ -820,7 +844,1 @@\n-    if (table == NULL)\n-        return(NULL);\n-    if (name == NULL)\n-        return(NULL);\n-    key = xmlHashComputeQKey(table, prefix, name, prefix2,\n-                             name2, prefix3, name3);\n-    if (table->table[key].valid == 0)\n+    if ((hash == NULL) || (hash->size == 0) || (name == NULL))\n@@ -828,5 +846,25 @@\n-    for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {\n-        if ((xmlStrQEqual(prefix, name, entry->name)) &&\n-            (xmlStrQEqual(prefix2, name2, entry->name2)) &&\n-            (xmlStrQEqual(prefix3, name3, entry->name3)))\n-            return(entry->payload);\n+\n+    hashValue = xmlHashQNameValue(hash->randomSeed, prefix, name, prefix2,\n+                                  name2, prefix3, name3);\n+    mask = hash->size - 1;\n+    pos = hashValue & mask;\n+    entry = &hash->table[pos];\n+\n+    if (entry->hashValue != 0) {\n+        displ = 0;\n+        hashValue |= MAX_HASH_SIZE;\n+\n+        do {\n+            if ((hashValue == entry->hashValue) &&\n+                (xmlStrQEqual(prefix, name, entry->key)) &&\n+                (xmlStrQEqual(prefix2, name2, entry->key2)) &&\n+                (xmlStrQEqual(prefix3, name3, entry->key3)))\n+                return(entry->payload);\n+\n+            displ++;\n+            pos++;\n+            entry++;\n+            if ((pos & mask) == 0)\n+                entry = hash->table;\n+        } while ((entry->hashValue != 0) &&\n+                 (((pos - entry->hashValue) & mask) >= displ));\n@@ -834,0 +872,1 @@\n+\n@@ -838,1 +877,1 @@\n-    xmlHashScanner hashscanner;\n+    xmlHashScanner scan;\n@@ -843,5 +882,5 @@\n-stubHashScannerFull (void *payload, void *data, const xmlChar *name,\n-                     const xmlChar *name2 ATTRIBUTE_UNUSED,\n-                     const xmlChar *name3 ATTRIBUTE_UNUSED) {\n-    stubData *stubdata = (stubData *) data;\n-    stubdata->hashscanner (payload, stubdata->data, (xmlChar *) name);\n+stubHashScannerFull(void *payload, void *data, const xmlChar *key,\n+                    const xmlChar *key2 ATTRIBUTE_UNUSED,\n+                    const xmlChar *key3 ATTRIBUTE_UNUSED) {\n+    stubData *sdata = (stubData *) data;\n+    sdata->scan(payload, sdata->data, key);\n@@ -852,3 +891,3 @@\n- * @table: the hash table\n- * @f:  the scanner function for items in the hash\n- * @data:  extra data passed to f\n+ * @hash: hash table\n+ * @scan: scanner function for items in the hash\n+ * @data: extra data passed to @scan\n@@ -856,1 +895,1 @@\n- * Scan the hash @table and applied @f to each value.\n+ * Scan the hash @table and apply @scan to each value.\n@@ -859,5 +898,5 @@\n-xmlHashScan(xmlHashTablePtr table, xmlHashScanner f, void *data) {\n-    stubData stubdata;\n-    stubdata.data = data;\n-    stubdata.hashscanner = f;\n-    xmlHashScanFull (table, stubHashScannerFull, &stubdata);\n+xmlHashScan(xmlHashTablePtr hash, xmlHashScanner scan, void *data) {\n+    stubData sdata;\n+    sdata.data = data;\n+    sdata.scan = scan;\n+    xmlHashScanFull(hash, stubHashScannerFull, &sdata);\n@@ -868,3 +907,3 @@\n- * @table: the hash table\n- * @f:  the scanner function for items in the hash\n- * @data:  extra data passed to f\n+ * @hash: hash table\n+ * @scan: scanner function for items in the hash\n+ * @data: extra data passed to @scan\n@@ -872,1 +911,1 @@\n- * Scan the hash @table and applied @f to each value.\n+ * Scan the hash @table and apply @scan to each value.\n@@ -875,4 +914,4 @@\n-xmlHashScanFull(xmlHashTablePtr table, xmlHashScannerFull f, void *data) {\n-    int i, nb;\n-    xmlHashEntryPtr iter;\n-    xmlHashEntryPtr next;\n+xmlHashScanFull(xmlHashTablePtr hash, xmlHashScannerFull scan, void *data) {\n+    const xmlHashEntry *entry, *end;\n+    xmlHashEntry old;\n+    unsigned i;\n@@ -880,3 +919,1 @@\n-    if (table == NULL)\n-        return;\n-    if (f == NULL)\n+    if ((hash == NULL) || (hash->size == 0) || (scan == NULL))\n@@ -885,23 +922,27 @@\n-    if (table->table) {\n-        for(i = 0; i < table->size; i++) {\n-            if (table->table[i].valid == 0)\n-                continue;\n-            iter = &(table->table[i]);\n-            while (iter) {\n-                next = iter->next;\n-                nb = table->nbElems;\n-                if ((f != NULL) && (iter->payload != NULL))\n-                    f(iter->payload, data, iter->name,\n-                      iter->name2, iter->name3);\n-                if (nb != table->nbElems) {\n-                    \/* table was modified by the callback, be careful *\/\n-                    if (iter == &(table->table[i])) {\n-                        if (table->table[i].valid == 0)\n-                            iter = NULL;\n-                        if (table->table[i].next != next)\n-                            iter = &(table->table[i]);\n-                    } else\n-                        iter = next;\n-                } else\n-                    iter = next;\n-            }\n+    \/*\n+     * We must handle the case that a scanned entry is removed when executing\n+     * the callback (xmlCleanSpecialAttr and possibly other places).\n+     *\n+     * Find the start of a probe sequence to avoid scanning entries twice if\n+     * a deletion happens.\n+     *\/\n+    entry = hash->table;\n+    end = &hash->table[hash->size];\n+    while (entry->hashValue != 0) {\n+        if (++entry >= end)\n+            entry = hash->table;\n+    }\n+\n+    for (i = 0; i < hash->size; i++) {\n+        if ((entry->hashValue != 0) && (entry->payload != NULL)) {\n+            \/*\n+             * Make sure to rescan after a possible deletion.\n+             *\/\n+            do {\n+                old = *entry;\n+                scan(entry->payload, data, entry->key, entry->key2, entry->key3);\n+            } while ((entry->hashValue != 0) &&\n+                     (entry->payload != NULL) &&\n+                     ((entry->key != old.key) ||\n+                      (entry->key2 != old.key2) ||\n+                      (entry->key3 != old.key3)));\n@@ -909,0 +950,2 @@\n+        if (++entry >= end)\n+            entry = hash->table;\n@@ -914,6 +957,6 @@\n- * @table: the hash table\n- * @name: the name of the userdata or NULL\n- * @name2: a second name of the userdata or NULL\n- * @name3: a third name of the userdata or NULL\n- * @f:  the scanner function for items in the hash\n- * @data:  extra data passed to f\n+ * @hash: hash table\n+ * @key: first string key or NULL\n+ * @key2: second string key or NULL\n+ * @key3: third string key or NULL\n+ * @scan: scanner function for items in the hash\n+ * @data: extra data passed to @scan\n@@ -921,2 +964,2 @@\n- * Scan the hash @table and applied @f to each value matching\n- * (@name, @name2, @name3) tuple. If one of the names is null,\n+ * Scan the hash @table and apply @scan to each value matching\n+ * (@key, @key2, @key3) tuple. If one of the keys is null,\n@@ -926,8 +969,7 @@\n-xmlHashScan3(xmlHashTablePtr table, const xmlChar *name,\n-             const xmlChar *name2, const xmlChar *name3,\n-             xmlHashScanner f, void *data) {\n-    stubData stubdata;\n-    stubdata.data = data;\n-    stubdata.hashscanner = f;\n-    xmlHashScanFull3(table, name, name2, name3, stubHashScannerFull,\n-                     &stubdata);\n+xmlHashScan3(xmlHashTablePtr hash, const xmlChar *key,\n+             const xmlChar *key2, const xmlChar *key3,\n+             xmlHashScanner scan, void *data) {\n+    stubData sdata;\n+    sdata.data = data;\n+    sdata.scan = scan;\n+    xmlHashScanFull3(hash, key, key2, key3, stubHashScannerFull, &sdata);\n@@ -938,6 +980,6 @@\n- * @table: the hash table\n- * @name: the name of the userdata or NULL\n- * @name2: a second name of the userdata or NULL\n- * @name3: a third name of the userdata or NULL\n- * @f:  the scanner function for items in the hash\n- * @data:  extra data passed to f\n+ * @hash: hash table\n+ * @key: first string key or NULL\n+ * @key2: second string key or NULL\n+ * @key3: third string key or NULL\n+ * @scan: scanner function for items in the hash\n+ * @data: extra data passed to @scan\n@@ -945,2 +987,2 @@\n- * Scan the hash @table and applied @f to each value matching\n- * (@name, @name2, @name3) tuple. If one of the names is null,\n+ * Scan the hash @table and apply @scan to each value matching\n+ * (@key, @key2, @key3) tuple. If one of the keys is null,\n@@ -950,10 +992,8 @@\n-xmlHashScanFull3(xmlHashTablePtr table, const xmlChar *name,\n-                 const xmlChar *name2, const xmlChar *name3,\n-                 xmlHashScannerFull f, void *data) {\n-    int i;\n-    xmlHashEntryPtr iter;\n-    xmlHashEntryPtr next;\n-\n-    if (table == NULL)\n-        return;\n-    if (f == NULL)\n+xmlHashScanFull3(xmlHashTablePtr hash, const xmlChar *key,\n+                 const xmlChar *key2, const xmlChar *key3,\n+                 xmlHashScannerFull scan, void *data) {\n+    const xmlHashEntry *entry, *end;\n+    xmlHashEntry old;\n+    unsigned i;\n+\n+    if ((hash == NULL) || (hash->size == 0) || (scan == NULL))\n@@ -962,16 +1002,32 @@\n-    if (table->table) {\n-        for(i = 0; i < table->size; i++) {\n-            if (table->table[i].valid == 0)\n-                continue;\n-            iter = &(table->table[i]);\n-            while (iter) {\n-                next = iter->next;\n-                if (((name == NULL) || (xmlStrEqual(name, iter->name))) &&\n-                    ((name2 == NULL) || (xmlStrEqual(name2, iter->name2))) &&\n-                    ((name3 == NULL) || (xmlStrEqual(name3, iter->name3))) &&\n-                    (iter->payload != NULL)) {\n-                    f(iter->payload, data, iter->name,\n-                      iter->name2, iter->name3);\n-                }\n-                iter = next;\n-            }\n+    \/*\n+     * We must handle the case that a scanned entry is removed when executing\n+     * the callback (xmlCleanSpecialAttr and possibly other places).\n+     *\n+     * Find the start of a probe sequence to avoid scanning entries twice if\n+     * a deletion happens.\n+     *\/\n+    entry = hash->table;\n+    end = &hash->table[hash->size];\n+    while (entry->hashValue != 0) {\n+        if (++entry >= end)\n+            entry = hash->table;\n+    }\n+\n+    for (i = 0; i < hash->size; i++) {\n+        if ((entry->hashValue != 0) && (entry->payload != NULL)) {\n+            \/*\n+             * Make sure to rescan after a possible deletion.\n+             *\/\n+            do {\n+                if (((key != NULL) && (strcmp((const char *) key,\n+                                              (const char *) entry->key) != 0)) ||\n+                    ((key2 != NULL) && (!xmlFastStrEqual(key2, entry->key2))) ||\n+                    ((key3 != NULL) && (!xmlFastStrEqual(key3, entry->key3))))\n+                    break;\n+                old = *entry;\n+                scan(entry->payload, data, entry->key, entry->key2, entry->key3);\n+            } while ((entry->hashValue != 0) &&\n+                     (entry->payload != NULL) &&\n+                     ((entry->key != old.key) ||\n+                      (entry->key2 != old.key2) ||\n+                      (entry->key3 != old.key3)));\n@@ -979,0 +1035,2 @@\n+        if (++entry >= end)\n+            entry = hash->table;\n@@ -984,2 +1042,2 @@\n- * @table: the hash table\n- * @f:  the copier function for items in the hash\n+ * @hash: hash table\n+ * @copy: copier function for items in the hash\n@@ -987,1 +1045,1 @@\n- * Scan the hash @table and applied @f to each value.\n+ * Copy the hash @table using @copy to copy payloads.\n@@ -989,1 +1047,1 @@\n- * Returns the new table or NULL in case of error.\n+ * Returns the new table or NULL if a memory allocation failed.\n@@ -992,4 +1050,2 @@\n-xmlHashCopy(xmlHashTablePtr table, xmlHashCopier f) {\n-    int i;\n-    xmlHashEntryPtr iter;\n-    xmlHashEntryPtr next;\n+xmlHashCopy(xmlHashTablePtr hash, xmlHashCopier copy) {\n+    const xmlHashEntry *entry, *end;\n@@ -998,3 +1054,1 @@\n-    if (table == NULL)\n-        return(NULL);\n-    if (f == NULL)\n+    if ((hash == NULL) || (copy == NULL))\n@@ -1003,1 +1057,1 @@\n-    ret = xmlHashCreate(table->size);\n+    ret = xmlHashCreate(hash->size);\n@@ -1007,12 +1061,9 @@\n-    if (table->table) {\n-        for(i = 0; i < table->size; i++) {\n-            if (table->table[i].valid == 0)\n-                continue;\n-            iter = &(table->table[i]);\n-            while (iter) {\n-                next = iter->next;\n-                xmlHashAddEntry3(ret, iter->name, iter->name2,\n-                                 iter->name3, f(iter->payload, iter->name));\n-                iter = next;\n-            }\n-        }\n+    if (hash->size == 0)\n+        return(ret);\n+\n+    end = &hash->table[hash->size];\n+\n+    for (entry = hash->table; entry < end; entry++) {\n+        if (entry->hashValue != 0)\n+            xmlHashAddEntry3(ret, entry->key, entry->key2, entry->key3,\n+                             copy(entry->payload, entry->key));\n@@ -1020,1 +1071,1 @@\n-    ret->nbElems = table->nbElems;\n+\n@@ -1026,1 +1077,1 @@\n- * @table: the hash table\n+ * @hash: hash table\n@@ -1028,1 +1079,1 @@\n- * Query the number of elements installed in the hash @table.\n+ * Query the number of elements in the hash table.\n@@ -1031,1 +1082,1 @@\n- * -1 in case of error\n+ * -1 in case of error.\n@@ -1034,2 +1085,2 @@\n-xmlHashSize(xmlHashTablePtr table) {\n-    if (table == NULL)\n+xmlHashSize(xmlHashTablePtr hash) {\n+    if (hash == NULL)\n@@ -1037,1 +1088,1 @@\n-    return(table->nbElems);\n+    return(hash->nbElems);\n@@ -1042,3 +1093,3 @@\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @f: the deallocator function for removed item (if any)\n+ * @hash: hash table\n+ * @key: string key\n+ * @dealloc: deallocator function for removed item or NULL\n@@ -1046,3 +1097,2 @@\n- * Find the userdata specified by the @name and remove\n- * it from the hash @table. Existing userdata for this tuple will be removed\n- * and freed with @f.\n+ * Find the entry specified by the @key and remove it from the hash table.\n+ * Payload will be freed with @dealloc.\n@@ -1050,1 +1100,1 @@\n- * Returns 0 if the removal succeeded and -1 in case of error or not found.\n+ * Returns 0 on success and -1 if no entry was found.\n@@ -1052,3 +1102,3 @@\n-int xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,\n-                       xmlHashDeallocator f) {\n-    return(xmlHashRemoveEntry3(table, name, NULL, NULL, f));\n+int xmlHashRemoveEntry(xmlHashTablePtr hash, const xmlChar *key,\n+                       xmlHashDeallocator dealloc) {\n+    return(xmlHashRemoveEntry3(hash, key, NULL, NULL, dealloc));\n@@ -1059,4 +1109,4 @@\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n- * @f: the deallocator function for removed item (if any)\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @dealloc: deallocator function for removed item or NULL\n@@ -1064,3 +1114,1 @@\n- * Find the userdata specified by the (@name, @name2) tuple and remove\n- * it from the hash @table. Existing userdata for this tuple will be removed\n- * and freed with @f.\n+ * Remove an entry with two strings as key.\n@@ -1068,1 +1116,3 @@\n- * Returns 0 if the removal succeeded and -1 in case of error or not found.\n+ * See xmlHashRemoveEntry.\n+ *\n+ * Returns 0 on success and -1 in case of error.\n@@ -1071,3 +1121,3 @@\n-xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,\n-                        const xmlChar *name2, xmlHashDeallocator f) {\n-    return(xmlHashRemoveEntry3(table, name, name2, NULL, f));\n+xmlHashRemoveEntry2(xmlHashTablePtr hash, const xmlChar *key,\n+                    const xmlChar *key2, xmlHashDeallocator dealloc) {\n+    return(xmlHashRemoveEntry3(hash, key, key2, NULL, dealloc));\n@@ -1078,5 +1128,7 @@\n- * @table: the hash table\n- * @name: the name of the userdata\n- * @name2: a second name of the userdata\n- * @name3: a third name of the userdata\n- * @f: the deallocator function for removed item (if any)\n+ * @hash: hash table\n+ * @key: first string key\n+ * @key2: second string key\n+ * @key3: third string key\n+ * @dealloc: deallocator function for removed item or NULL\n+ *\n+ * Remove an entry with three strings as key.\n@@ -1084,3 +1136,1 @@\n- * Find the userdata specified by the (@name, @name2, @name3) tuple and remove\n- * it from the hash @table. Existing userdata for this tuple will be removed\n- * and freed with @f.\n+ * See xmlHashRemoveEntry.\n@@ -1088,1 +1138,1 @@\n- * Returns 0 if the removal succeeded and -1 in case of error or not found.\n+ * Returns 0 on success and -1 in case of error.\n@@ -1090,0 +1140,1 @@\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n@@ -1091,7 +1142,8 @@\n-xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,\n-    const xmlChar *name2, const xmlChar *name3, xmlHashDeallocator f) {\n-    unsigned long key;\n-    xmlHashEntryPtr entry;\n-    xmlHashEntryPtr prev = NULL;\n-\n-    if (table == NULL || name == NULL)\n+xmlHashRemoveEntry3(xmlHashTablePtr hash, const xmlChar *key,\n+                    const xmlChar *key2, const xmlChar *key3,\n+                    xmlHashDeallocator dealloc) {\n+    xmlHashEntry *entry, *cur, *next;\n+    unsigned hashValue, mask, pos, nextpos;\n+    int found;\n+\n+    if ((hash == NULL) || (hash->size == 0) || (key == NULL))\n@@ -1100,36 +1152,3 @@\n-    key = xmlHashComputeKey(table, name, name2, name3);\n-    if (table->table[key].valid == 0) {\n-        return(-1);\n-    } else {\n-        for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {\n-            if (xmlStrEqual(entry->name, name) &&\n-                    xmlStrEqual(entry->name2, name2) &&\n-                    xmlStrEqual(entry->name3, name3)) {\n-                if ((f != NULL) && (entry->payload != NULL))\n-                    f(entry->payload, entry->name);\n-                entry->payload = NULL;\n-                if (table->dict == NULL) {\n-                    if(entry->name)\n-                        xmlFree(entry->name);\n-                    if(entry->name2)\n-                        xmlFree(entry->name2);\n-                    if(entry->name3)\n-                        xmlFree(entry->name3);\n-                }\n-                if(prev) {\n-                    prev->next = entry->next;\n-                    xmlFree(entry);\n-                } else {\n-                    if (entry->next == NULL) {\n-                        entry->valid = 0;\n-                    } else {\n-                        entry = entry->next;\n-                        memcpy(&(table->table[key]), entry, sizeof(xmlHashEntry));\n-                        xmlFree(entry);\n-                    }\n-                }\n-                table->nbElems--;\n-                return(0);\n-            }\n-            prev = entry;\n-        }\n+    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);\n+    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);\n+    if (!found)\n@@ -1137,0 +1156,10 @@\n+\n+    if ((dealloc != NULL) && (entry->payload != NULL))\n+        dealloc(entry->payload, entry->key);\n+    if (hash->dict == NULL) {\n+        if (entry->key)\n+            xmlFree(entry->key);\n+        if (entry->key2)\n+            xmlFree(entry->key2);\n+        if (entry->key3)\n+            xmlFree(entry->key3);\n@@ -1138,0 +1167,47 @@\n+\n+    \/*\n+     * Find end of probe sequence. Entries at their initial probe\n+     * position start a new sequence.\n+     *\/\n+    mask = hash->size - 1;\n+    pos = entry - hash->table;\n+    cur = entry;\n+\n+    while (1) {\n+        nextpos = pos + 1;\n+        next = cur + 1;\n+        if ((nextpos & mask) == 0)\n+            next = hash->table;\n+\n+        if ((next->hashValue == 0) ||\n+            (((next->hashValue - nextpos) & mask) == 0))\n+            break;\n+\n+        cur = next;\n+        pos = nextpos;\n+    }\n+\n+    \/*\n+     * Backward shift\n+     *\/\n+    next = entry + 1;\n+\n+    if (cur < entry) {\n+        xmlHashEntry *end = &hash->table[hash->size];\n+\n+        memmove(entry, next, (char *) end - (char *) next);\n+        entry = hash->table;\n+        end[-1] = *entry;\n+        next = entry + 1;\n+    }\n+\n+    memmove(entry, next, (char *) cur - (char *) entry);\n+\n+    \/*\n+     * Update entry\n+     *\/\n+    cur->hashValue = 0;\n+\n+    hash->nbElems--;\n+\n+    return(0);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/hash.c","additions":891,"deletions":815,"binary":false,"changes":1706,"status":"modified"},{"patch":"@@ -83,0 +83,17 @@\n+\/** DOC_DISABLE *\/\n+#ifdef LIBXML_SAX1_ENABLED\n+  #define XML_GLOBALS_HTML \\\n+    XML_OP(htmlDefaultSAXHandler, xmlSAXHandlerV1, XML_DEPRECATED)\n+#else\n+  #define XML_GLOBALS_HTML\n+#endif\n+\n+#define XML_OP XML_DECLARE_GLOBAL\n+XML_GLOBALS_HTML\n+#undef XML_OP\n+\n+#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+  #define htmlDefaultSAXHandler XML_GLOBAL_MACRO(htmlDefaultSAXHandler)\n+#endif\n+\/** DOC_ENABLE *\/\n+\n@@ -86,1 +103,4 @@\n-XMLPUBFUN const htmlElemDesc * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n+                        htmlInitAutoClose       (void);\n+XMLPUBFUN const htmlElemDesc *\n@@ -88,1 +108,1 @@\n-XMLPUBFUN const htmlEntityDesc * XMLCALL\n+XMLPUBFUN const htmlEntityDesc *\n@@ -90,1 +110,1 @@\n-XMLPUBFUN const htmlEntityDesc * XMLCALL\n+XMLPUBFUN const htmlEntityDesc *\n@@ -93,1 +113,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -96,1 +116,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -100,1 +120,2 @@\n-XMLPUBFUN const htmlEntityDesc * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN const htmlEntityDesc *\n@@ -103,1 +124,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -105,1 +127,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -108,1 +131,1 @@\n-XMLPUBFUN htmlParserCtxtPtr XMLCALL\n+XMLPUBFUN htmlParserCtxtPtr\n@@ -110,0 +133,3 @@\n+XMLPUBFUN htmlParserCtxtPtr\n+                        htmlNewSAXParserCtxt(const htmlSAXHandler *sax,\n+                                             void *userData);\n@@ -111,1 +137,1 @@\n-XMLPUBFUN htmlParserCtxtPtr XMLCALL\n+XMLPUBFUN htmlParserCtxtPtr\n@@ -115,1 +141,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -117,1 +143,2 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN htmlDocPtr\n@@ -122,1 +149,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -125,1 +152,5 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlParserCtxtPtr\n+                        htmlCreateFileParserCtxt(const char *filename,\n+                                                 const char *encoding);\n+XML_DEPRECATED\n+XMLPUBFUN htmlDocPtr\n@@ -130,1 +161,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -133,1 +164,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -138,1 +169,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -143,1 +174,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -145,1 +176,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -152,1 +183,1 @@\n-XMLPUBFUN htmlParserCtxtPtr XMLCALL\n+XMLPUBFUN htmlParserCtxtPtr\n@@ -159,1 +190,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -166,1 +197,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -191,1 +222,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -193,1 +224,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -196,1 +227,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -201,1 +232,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -205,1 +236,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -211,1 +242,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -216,1 +247,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -223,1 +254,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -229,1 +260,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -234,1 +265,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -241,1 +272,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -247,1 +278,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -269,4 +300,4 @@\n-XMLPUBFUN htmlStatus XMLCALL htmlAttrAllowed(const htmlElemDesc*, const xmlChar*, int) ;\n-XMLPUBFUN int XMLCALL htmlElementAllowedHere(const htmlElemDesc*, const xmlChar*) ;\n-XMLPUBFUN htmlStatus XMLCALL htmlElementStatusHere(const htmlElemDesc*, const htmlElemDesc*) ;\n-XMLPUBFUN htmlStatus XMLCALL htmlNodeStatus(const htmlNodePtr, int) ;\n+XMLPUBFUN htmlStatus htmlAttrAllowed(const htmlElemDesc*, const xmlChar*, int) ;\n+XMLPUBFUN int htmlElementAllowedHere(const htmlElemDesc*, const xmlChar*) ;\n+XMLPUBFUN htmlStatus htmlElementStatusHere(const htmlElemDesc*, const htmlElemDesc*) ;\n+XMLPUBFUN htmlStatus htmlNodeStatus(const htmlNodePtr, int) ;\n@@ -305,0 +336,6 @@\n+#else \/* LIBXML_HTML_ENABLED *\/\n+\n+\/** DOC_DISABLE *\/\n+#define XML_GLOBALS_HTML\n+\/** DOC_ENABLE *\/\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/HTMLparser.h","additions":75,"deletions":38,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -65,1 +65,1 @@\n-XMLPUBFUN htmlDocPtr XMLCALL\n+XMLPUBFUN htmlDocPtr\n@@ -68,1 +68,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -70,1 +70,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -74,1 +74,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -78,1 +78,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -83,1 +83,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -86,1 +86,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -89,1 +89,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -93,1 +93,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -97,1 +97,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -103,1 +103,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -107,1 +107,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -113,1 +113,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -119,1 +119,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -123,1 +123,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -128,1 +128,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -136,1 +136,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/HTMLtree.h","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -15,2 +15,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n@@ -26,1 +24,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -29,1 +27,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -32,1 +30,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -37,1 +35,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -40,1 +38,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -44,1 +42,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -47,1 +45,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -50,1 +48,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -54,1 +52,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -60,1 +58,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -66,1 +64,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -70,1 +68,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -74,1 +72,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -80,1 +78,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -88,1 +86,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -97,1 +95,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -103,1 +101,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -109,1 +107,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -117,1 +115,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -120,1 +118,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -123,1 +121,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -128,1 +126,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -133,1 +131,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -137,1 +135,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -141,1 +139,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -146,1 +144,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -151,1 +149,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -156,1 +154,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -161,1 +159,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -165,1 +163,1 @@\n-XMLPUBFUN xmlNsPtr XMLCALL\n+XMLPUBFUN xmlNsPtr\n@@ -168,1 +166,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -172,1 +170,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -177,1 +175,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -181,1 +179,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -188,1 +186,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -193,1 +191,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/SAX.h","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -15,2 +15,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n@@ -23,1 +21,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -25,1 +23,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -27,1 +25,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -31,1 +29,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -33,1 +31,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -36,1 +34,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -38,1 +36,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -40,1 +38,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -43,1 +41,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -48,1 +46,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -53,1 +51,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -56,1 +54,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -59,1 +57,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -64,1 +62,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -71,1 +69,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -79,1 +77,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -84,1 +82,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -89,1 +87,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -96,1 +94,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -98,1 +96,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -102,1 +100,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -106,1 +104,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -110,1 +108,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -120,1 +118,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -125,1 +123,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -128,1 +126,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -132,1 +130,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -136,1 +134,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -140,1 +138,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -143,1 +141,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -149,1 +147,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -153,1 +152,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -156,1 +155,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -160,1 +159,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -163,1 +162,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -167,1 +166,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/SAX2.h","additions":37,"deletions":38,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-#ifdef LIBXML_OUTPUT_ENABLED\n@@ -69,1 +68,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -77,1 +76,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -85,1 +84,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -112,1 +111,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -125,1 +124,0 @@\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/c14n.h","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-XMLPUBFUN xmlCatalogPtr XMLCALL\n+XMLPUBFUN xmlCatalogPtr\n@@ -71,1 +71,1 @@\n-XMLPUBFUN xmlCatalogPtr XMLCALL\n+XMLPUBFUN xmlCatalogPtr\n@@ -73,1 +73,1 @@\n-XMLPUBFUN xmlCatalogPtr XMLCALL\n+XMLPUBFUN xmlCatalogPtr\n@@ -75,1 +75,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -77,1 +77,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -82,1 +82,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -85,1 +85,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -89,1 +89,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -92,1 +92,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -95,1 +95,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -99,1 +99,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -103,1 +103,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -105,1 +105,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -111,1 +111,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -113,1 +113,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -115,1 +115,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -117,1 +117,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -120,1 +120,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -123,1 +123,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -126,1 +126,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -128,1 +128,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -130,1 +130,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -132,1 +132,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -136,1 +136,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -138,1 +138,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -140,1 +140,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -147,1 +147,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -149,1 +149,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -152,1 +152,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -156,1 +156,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -162,1 +162,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -164,1 +164,1 @@\n-XMLPUBFUN xmlCatalogPrefer XMLCALL\n+XMLPUBFUN xmlCatalogPrefer\n@@ -166,1 +166,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -168,1 +168,1 @@\n-XMLPUBFUN xmlCatalogAllow XMLCALL\n+XMLPUBFUN xmlCatalogAllow\n@@ -173,1 +173,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -175,1 +175,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/catalog.h","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -210,1 +210,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -212,1 +212,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -214,1 +214,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -216,1 +216,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -218,1 +218,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -220,1 +220,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -222,1 +222,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -224,1 +224,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/chvalid.h","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -31,1 +31,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -35,1 +35,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -39,1 +39,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -43,1 +43,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -47,1 +47,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -51,1 +51,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -54,1 +54,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -57,1 +57,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -60,1 +60,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -70,1 +70,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -80,1 +80,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -82,1 +82,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -85,1 +85,1 @@\n-XMLPUBFUN const char * XMLCALL\n+XMLPUBFUN const char *\n@@ -139,1 +139,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -142,1 +142,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -144,1 +144,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -149,1 +149,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -154,1 +154,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -159,1 +159,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -165,1 +165,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -167,1 +167,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -172,1 +172,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -177,1 +177,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -184,1 +184,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -190,1 +190,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -195,1 +195,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -204,1 +204,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/debugXML.h","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+#include <libxml\/xmlstring.h>\n@@ -31,1 +32,1 @@\n-XMLPUBFUN int XMLCALL  xmlInitializeDict(void);\n+XMLPUBFUN int  xmlInitializeDict(void);\n@@ -36,1 +37,1 @@\n-XMLPUBFUN xmlDictPtr XMLCALL\n+XMLPUBFUN xmlDictPtr\n@@ -38,1 +39,1 @@\n-XMLPUBFUN size_t XMLCALL\n+XMLPUBFUN size_t\n@@ -41,1 +42,1 @@\n-XMLPUBFUN size_t XMLCALL\n+XMLPUBFUN size_t\n@@ -43,1 +44,1 @@\n-XMLPUBFUN xmlDictPtr XMLCALL\n+XMLPUBFUN xmlDictPtr\n@@ -45,1 +46,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -47,1 +48,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -53,1 +54,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -57,1 +58,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -61,1 +62,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -65,1 +66,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -68,1 +69,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -75,1 +76,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/dict.h","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,0 +35,9 @@\n+typedef enum {\n+    XML_ENC_ERR_SUCCESS     =  0,\n+    XML_ENC_ERR_SPACE       = -1,\n+    XML_ENC_ERR_INPUT       = -2,\n+    XML_ENC_ERR_PARTIAL     = -3,\n+    XML_ENC_ERR_INTERNAL    = -4,\n+    XML_ENC_ERR_MEMORY      = -5\n+} xmlCharEncError;\n+\n@@ -145,8 +154,0 @@\n-#ifdef __cplusplus\n-}\n-#endif\n-#include <libxml\/tree.h>\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n@@ -157,1 +158,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -160,1 +161,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -162,1 +163,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -164,1 +165,1 @@\n-XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL\n+XMLPUBFUN xmlCharEncodingHandlerPtr\n@@ -166,1 +167,1 @@\n-XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL\n+XMLPUBFUN xmlCharEncodingHandlerPtr\n@@ -168,1 +169,1 @@\n-XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL\n+XMLPUBFUN xmlCharEncodingHandlerPtr\n@@ -176,1 +177,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -179,1 +180,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -181,1 +182,1 @@\n-XMLPUBFUN const char * XMLCALL\n+XMLPUBFUN const char *\n@@ -183,1 +184,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -185,1 +186,1 @@\n-XMLPUBFUN xmlCharEncoding XMLCALL\n+XMLPUBFUN xmlCharEncoding\n@@ -187,1 +188,1 @@\n-XMLPUBFUN const char * XMLCALL\n+XMLPUBFUN const char *\n@@ -193,1 +194,1 @@\n-XMLPUBFUN xmlCharEncoding XMLCALL\n+XMLPUBFUN xmlCharEncoding\n@@ -197,1 +198,2 @@\n-XMLPUBFUN int XMLCALL\n+struct _xmlBuffer;\n+XMLPUBFUN int\n@@ -199,2 +201,2 @@\n-                                         xmlBufferPtr out,\n-                                         xmlBufferPtr in);\n+                                         struct _xmlBuffer *out,\n+                                         struct _xmlBuffer *in);\n@@ -202,1 +204,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -204,3 +206,4 @@\n-                                         xmlBufferPtr out,\n-                                         xmlBufferPtr in);\n-XMLPUBFUN int XMLCALL\n+                                         struct _xmlBuffer *out,\n+                                         struct _xmlBuffer *in);\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -208,3 +211,3 @@\n-                                         xmlBufferPtr out,\n-                                         xmlBufferPtr in);\n-XMLPUBFUN int XMLCALL\n+                                         struct _xmlBuffer *out,\n+                                         struct _xmlBuffer *in);\n+XMLPUBFUN int\n@@ -217,1 +220,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -223,1 +226,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/encoding.h","additions":36,"deletions":33,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+#define XML_TREE_INTERNALS\n@@ -16,0 +17,1 @@\n+#undef XML_TREE_INTERNALS\n@@ -59,4 +61,2 @@\n-    int                  checked;       \/* was the entity content checked *\/\n-                                        \/* this is also used to count entities\n-                                         * references done from that entity\n-                                         * and if it contains '<' *\/\n+    int                    flags;       \/* various flags *\/\n+    unsigned long   expandedSize;       \/* expanded size *\/\n@@ -79,1 +79,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -83,1 +83,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -90,1 +90,3 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN void\n+                        xmlFreeEntity           (xmlEntityPtr entity);\n+XMLPUBFUN xmlEntityPtr\n@@ -97,1 +99,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -104,1 +106,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -106,1 +108,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -109,1 +111,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -112,1 +114,1 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XMLPUBFUN xmlEntityPtr\n@@ -117,1 +119,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -121,1 +123,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -124,1 +126,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -127,1 +129,1 @@\n-XMLPUBFUN xmlEntitiesTablePtr XMLCALL\n+XMLPUBFUN xmlEntitiesTablePtr\n@@ -130,1 +132,1 @@\n-XMLPUBFUN xmlEntitiesTablePtr XMLCALL\n+XMLPUBFUN xmlEntitiesTablePtr\n@@ -133,1 +135,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -136,1 +138,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -139,1 +141,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -144,1 +146,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/entities.h","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3,5 +3,1 @@\n- * Description: all the global variables and thread handling for\n- *              those variables is handled by this module.\n- *\n- * The bottom of this file is automatically generated by build_glob.py\n- * based on the description file global.data\n+ * Description: Deprecated, don't use\n@@ -10,2 +6,0 @@\n- *\n- * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard\n@@ -18,48 +12,0 @@\n-#include <libxml\/parser.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/SAX2.h>\n-#include <libxml\/xmlmemory.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-XML_DEPRECATED\n-XMLPUBFUN void XMLCALL xmlInitGlobals(void);\n-XML_DEPRECATED\n-XMLPUBFUN void XMLCALL xmlCleanupGlobals(void);\n-\n-\/**\n- * xmlParserInputBufferCreateFilenameFunc:\n- * @URI: the URI to read from\n- * @enc: the requested source encoding\n- *\n- * Signature for the function doing the lookup for a suitable input method\n- * corresponding to an URI.\n- *\n- * Returns the new xmlParserInputBufferPtr in case of success or NULL if no\n- *         method was found.\n- *\/\n-typedef xmlParserInputBufferPtr (*xmlParserInputBufferCreateFilenameFunc) (const char *URI,\n-                                                                           xmlCharEncoding enc);\n-\n-\n-\/**\n- * xmlOutputBufferCreateFilenameFunc:\n- * @URI: the URI to write to\n- * @enc: the requested target encoding\n- *\n- * Signature for the function doing the lookup for a suitable output method\n- * corresponding to an URI.\n- *\n- * Returns the new xmlOutputBufferPtr in case of success or NULL if no\n- *         method was found.\n- *\/\n-typedef xmlOutputBufferPtr (*xmlOutputBufferCreateFilenameFunc) (const char *URI,\n-                                                                 xmlCharEncodingHandlerPtr encoder,\n-                                                                 int compression);\n-\n-XMLPUBFUN xmlParserInputBufferCreateFilenameFunc\n-XMLCALL xmlParserInputBufferCreateFilenameDefault (xmlParserInputBufferCreateFilenameFunc func);\n-XMLPUBFUN xmlOutputBufferCreateFilenameFunc\n-XMLCALL xmlOutputBufferCreateFilenameDefault (xmlOutputBufferCreateFilenameFunc func);\n@@ -68,47 +14,1 @@\n- * Externally global symbols which need to be protected for backwards\n- * compatibility support.\n- *\/\n-\n-#undef  htmlDefaultSAXHandler\n-#undef  oldXMLWDcompatibility\n-#undef  xmlBufferAllocScheme\n-#undef  xmlDefaultBufferSize\n-#undef  xmlDefaultSAXHandler\n-#undef  xmlDefaultSAXLocator\n-#undef  xmlDoValidityCheckingDefaultValue\n-#undef  xmlFree\n-#undef  xmlGenericError\n-#undef  xmlStructuredError\n-#undef  xmlGenericErrorContext\n-#undef  xmlStructuredErrorContext\n-#undef  xmlGetWarningsDefaultValue\n-#undef  xmlIndentTreeOutput\n-#undef  xmlTreeIndentString\n-#undef  xmlKeepBlanksDefaultValue\n-#undef  xmlLineNumbersDefaultValue\n-#undef  xmlLoadExtDtdDefaultValue\n-#undef  xmlMalloc\n-#undef  xmlMallocAtomic\n-#undef  xmlMemStrdup\n-#undef  xmlParserDebugEntities\n-#undef  xmlParserVersion\n-#undef  xmlPedanticParserDefaultValue\n-#undef  xmlRealloc\n-#undef  xmlSaveNoEmptyTags\n-#undef  xmlSubstituteEntitiesDefaultValue\n-#undef  xmlRegisterNodeDefaultValue\n-#undef  xmlDeregisterNodeDefaultValue\n-#undef  xmlLastError\n-#undef  xmlParserInputBufferCreateFilenameValue\n-#undef  xmlOutputBufferCreateFilenameValue\n-\n-\/**\n- * xmlRegisterNodeFunc:\n- * @node: the current node\n- *\n- * Signature for the registration callback of a created node\n- *\/\n-typedef void (*xmlRegisterNodeFunc) (xmlNodePtr node);\n-\/**\n- * xmlDeregisterNodeFunc:\n- * @node: the current node\n+ * This file was required to access global variables until version v2.12.0.\n@@ -116,1 +16,1 @@\n- * Signature for the deregistration callback of a discarded node\n+ * These includes are for backward compatibility.\n@@ -118,55 +18,5 @@\n-typedef void (*xmlDeregisterNodeFunc) (xmlNodePtr node);\n-\n-typedef struct _xmlGlobalState xmlGlobalState;\n-typedef xmlGlobalState *xmlGlobalStatePtr;\n-struct _xmlGlobalState\n-{\n-        const char *xmlParserVersion;\n-\n-        xmlSAXLocator xmlDefaultSAXLocator;\n-        xmlSAXHandlerV1 xmlDefaultSAXHandler;\n-        xmlSAXHandlerV1 docbDefaultSAXHandler; \/* unused *\/\n-        xmlSAXHandlerV1 htmlDefaultSAXHandler;\n-\n-        xmlFreeFunc xmlFree;\n-        xmlMallocFunc xmlMalloc;\n-        xmlStrdupFunc xmlMemStrdup;\n-        xmlReallocFunc xmlRealloc;\n-\n-        xmlGenericErrorFunc xmlGenericError;\n-        xmlStructuredErrorFunc xmlStructuredError;\n-        void *xmlGenericErrorContext;\n-\n-        int oldXMLWDcompatibility;\n-\n-        xmlBufferAllocationScheme xmlBufferAllocScheme;\n-        int xmlDefaultBufferSize;\n-\n-        int xmlSubstituteEntitiesDefaultValue;\n-        int xmlDoValidityCheckingDefaultValue;\n-        int xmlGetWarningsDefaultValue;\n-        int xmlKeepBlanksDefaultValue;\n-        int xmlLineNumbersDefaultValue;\n-        int xmlLoadExtDtdDefaultValue;\n-        int xmlParserDebugEntities;\n-        int xmlPedanticParserDefaultValue;\n-\n-        int xmlSaveNoEmptyTags;\n-        int xmlIndentTreeOutput;\n-        const char *xmlTreeIndentString;\n-\n-        xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;\n-        xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;\n-\n-        xmlMallocFunc xmlMallocAtomic;\n-        xmlError xmlLastError;\n-\n-        xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;\n-        xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;\n-\n-        void *xmlStructuredErrorContext;\n-};\n-\n-#ifdef __cplusplus\n-}\n-#endif\n+#include <libxml\/HTMLparser.h>\n+#include <libxml\/parser.h>\n+#include <libxml\/xmlerror.h>\n+#include <libxml\/xmlIO.h>\n+#include <libxml\/xmlsave.h>\n@@ -174,0 +24,1 @@\n+\n@@ -178,308 +29,2 @@\n-XMLPUBFUN void XMLCALL  xmlInitializeGlobalState(xmlGlobalStatePtr gs);\n-\n-XMLPUBFUN void XMLCALL xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler);\n-\n-XMLPUBFUN void XMLCALL xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler);\n-\n-XMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlRegisterNodeDefault(xmlRegisterNodeFunc func);\n-XMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func);\n-XMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func);\n-XMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func);\n-\n-XMLPUBFUN xmlOutputBufferCreateFilenameFunc XMLCALL\n-        xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func);\n-XMLPUBFUN xmlParserInputBufferCreateFilenameFunc XMLCALL\n-        xmlThrDefParserInputBufferCreateFilenameDefault(\n-                                xmlParserInputBufferCreateFilenameFunc func);\n-\n-\/** DOC_DISABLE *\/\n-\/*\n- * In general the memory allocation entry points are not kept\n- * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED\n- *    - xmlMalloc\n- *    - xmlMallocAtomic\n- *    - xmlRealloc\n- *    - xmlMemStrdup\n- *    - xmlFree\n- *\/\n-\n-#ifdef LIBXML_THREAD_ALLOC_ENABLED\n-#ifdef LIBXML_THREAD_ENABLED\n-XMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMalloc(void);\n-#define xmlMalloc \\\n-(*(__xmlMalloc()))\n-#else\n-XMLPUBVAR xmlMallocFunc xmlMalloc;\n-#endif\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-XMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMallocAtomic(void);\n-#define xmlMallocAtomic \\\n-(*(__xmlMallocAtomic()))\n-#else\n-XMLPUBVAR xmlMallocFunc xmlMallocAtomic;\n-#endif\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-XMLPUBFUN  xmlReallocFunc * XMLCALL __xmlRealloc(void);\n-#define xmlRealloc \\\n-(*(__xmlRealloc()))\n-#else\n-XMLPUBVAR xmlReallocFunc xmlRealloc;\n-#endif\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-XMLPUBFUN  xmlFreeFunc * XMLCALL __xmlFree(void);\n-#define xmlFree \\\n-(*(__xmlFree()))\n-#else\n-XMLPUBVAR xmlFreeFunc xmlFree;\n-#endif\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-XMLPUBFUN  xmlStrdupFunc * XMLCALL __xmlMemStrdup(void);\n-#define xmlMemStrdup \\\n-(*(__xmlMemStrdup()))\n-#else\n-XMLPUBVAR xmlStrdupFunc xmlMemStrdup;\n-#endif\n-\n-#else \/* !LIBXML_THREAD_ALLOC_ENABLED *\/\n-XMLPUBVAR xmlMallocFunc xmlMalloc;\n-XMLPUBVAR xmlMallocFunc xmlMallocAtomic;\n-XMLPUBVAR xmlReallocFunc xmlRealloc;\n-XMLPUBVAR xmlFreeFunc xmlFree;\n-XMLPUBVAR xmlStrdupFunc xmlMemStrdup;\n-#endif \/* LIBXML_THREAD_ALLOC_ENABLED *\/\n-\n-#ifdef LIBXML_HTML_ENABLED\n-XMLPUBFUN xmlSAXHandlerV1 * XMLCALL __htmlDefaultSAXHandler(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define htmlDefaultSAXHandler \\\n-(*(__htmlDefaultSAXHandler()))\n-#else\n-XMLPUBVAR xmlSAXHandlerV1 htmlDefaultSAXHandler;\n-#endif\n-#endif\n-\n-XMLPUBFUN xmlError * XMLCALL __xmlLastError(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlLastError \\\n-(*(__xmlLastError()))\n-#else\n-XMLPUBVAR xmlError xmlLastError;\n-#endif\n-\n-\/*\n- * Everything starting from the line below is\n- * Automatically generated by build_glob.py.\n- * Do not modify the previous line.\n- *\/\n-\n-\n-XMLPUBFUN int * XMLCALL __oldXMLWDcompatibility(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define oldXMLWDcompatibility \\\n-(*(__oldXMLWDcompatibility()))\n-#else\n-XMLPUBVAR int oldXMLWDcompatibility;\n-#endif\n-\n-XMLPUBFUN xmlBufferAllocationScheme * XMLCALL __xmlBufferAllocScheme(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlBufferAllocScheme \\\n-(*(__xmlBufferAllocScheme()))\n-#else\n-XMLPUBVAR xmlBufferAllocationScheme xmlBufferAllocScheme;\n-#endif\n-XMLPUBFUN xmlBufferAllocationScheme XMLCALL\n-        xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v);\n-\n-XMLPUBFUN int * XMLCALL __xmlDefaultBufferSize(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlDefaultBufferSize \\\n-(*(__xmlDefaultBufferSize()))\n-#else\n-XMLPUBVAR int xmlDefaultBufferSize;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefDefaultBufferSize(int v);\n-\n-XMLPUBFUN xmlSAXHandlerV1 * XMLCALL __xmlDefaultSAXHandler(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlDefaultSAXHandler \\\n-(*(__xmlDefaultSAXHandler()))\n-#else\n-XMLPUBVAR xmlSAXHandlerV1 xmlDefaultSAXHandler;\n-#endif\n-\n-XMLPUBFUN xmlSAXLocator * XMLCALL __xmlDefaultSAXLocator(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlDefaultSAXLocator \\\n-(*(__xmlDefaultSAXLocator()))\n-#else\n-XMLPUBVAR xmlSAXLocator xmlDefaultSAXLocator;\n-#endif\n-\n-XMLPUBFUN int * XMLCALL __xmlDoValidityCheckingDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlDoValidityCheckingDefaultValue \\\n-(*(__xmlDoValidityCheckingDefaultValue()))\n-#else\n-XMLPUBVAR int xmlDoValidityCheckingDefaultValue;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefDoValidityCheckingDefaultValue(int v);\n-\n-XMLPUBFUN xmlGenericErrorFunc * XMLCALL __xmlGenericError(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlGenericError \\\n-(*(__xmlGenericError()))\n-#else\n-XMLPUBVAR xmlGenericErrorFunc xmlGenericError;\n-#endif\n-\n-XMLPUBFUN xmlStructuredErrorFunc * XMLCALL __xmlStructuredError(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlStructuredError \\\n-(*(__xmlStructuredError()))\n-#else\n-XMLPUBVAR xmlStructuredErrorFunc xmlStructuredError;\n-#endif\n-\n-XMLPUBFUN void * * XMLCALL __xmlGenericErrorContext(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlGenericErrorContext \\\n-(*(__xmlGenericErrorContext()))\n-#else\n-XMLPUBVAR void * xmlGenericErrorContext;\n-#endif\n-\n-XMLPUBFUN void * * XMLCALL __xmlStructuredErrorContext(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlStructuredErrorContext \\\n-(*(__xmlStructuredErrorContext()))\n-#else\n-XMLPUBVAR void * xmlStructuredErrorContext;\n-#endif\n-\n-XMLPUBFUN int * XMLCALL __xmlGetWarningsDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlGetWarningsDefaultValue \\\n-(*(__xmlGetWarningsDefaultValue()))\n-#else\n-XMLPUBVAR int xmlGetWarningsDefaultValue;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefGetWarningsDefaultValue(int v);\n-\n-XMLPUBFUN int * XMLCALL __xmlIndentTreeOutput(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlIndentTreeOutput \\\n-(*(__xmlIndentTreeOutput()))\n-#else\n-XMLPUBVAR int xmlIndentTreeOutput;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefIndentTreeOutput(int v);\n-\n-XMLPUBFUN const char * * XMLCALL __xmlTreeIndentString(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlTreeIndentString \\\n-(*(__xmlTreeIndentString()))\n-#else\n-XMLPUBVAR const char * xmlTreeIndentString;\n-#endif\n-XMLPUBFUN const char * XMLCALL xmlThrDefTreeIndentString(const char * v);\n-\n-XMLPUBFUN int * XMLCALL __xmlKeepBlanksDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlKeepBlanksDefaultValue \\\n-(*(__xmlKeepBlanksDefaultValue()))\n-#else\n-XMLPUBVAR int xmlKeepBlanksDefaultValue;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefKeepBlanksDefaultValue(int v);\n-\n-XMLPUBFUN int * XMLCALL __xmlLineNumbersDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlLineNumbersDefaultValue \\\n-(*(__xmlLineNumbersDefaultValue()))\n-#else\n-XMLPUBVAR int xmlLineNumbersDefaultValue;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefLineNumbersDefaultValue(int v);\n-\n-XMLPUBFUN int * XMLCALL __xmlLoadExtDtdDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlLoadExtDtdDefaultValue \\\n-(*(__xmlLoadExtDtdDefaultValue()))\n-#else\n-XMLPUBVAR int xmlLoadExtDtdDefaultValue;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefLoadExtDtdDefaultValue(int v);\n-\n-XMLPUBFUN int * XMLCALL __xmlParserDebugEntities(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlParserDebugEntities \\\n-(*(__xmlParserDebugEntities()))\n-#else\n-XMLPUBVAR int xmlParserDebugEntities;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefParserDebugEntities(int v);\n-\n-XMLPUBFUN const char * * XMLCALL __xmlParserVersion(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlParserVersion \\\n-(*(__xmlParserVersion()))\n-#else\n-XMLPUBVAR const char * xmlParserVersion;\n-#endif\n-\n-XMLPUBFUN int * XMLCALL __xmlPedanticParserDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlPedanticParserDefaultValue \\\n-(*(__xmlPedanticParserDefaultValue()))\n-#else\n-XMLPUBVAR int xmlPedanticParserDefaultValue;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefPedanticParserDefaultValue(int v);\n-\n-XMLPUBFUN int * XMLCALL __xmlSaveNoEmptyTags(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlSaveNoEmptyTags \\\n-(*(__xmlSaveNoEmptyTags()))\n-#else\n-XMLPUBVAR int xmlSaveNoEmptyTags;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefSaveNoEmptyTags(int v);\n-\n-XMLPUBFUN int * XMLCALL __xmlSubstituteEntitiesDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlSubstituteEntitiesDefaultValue \\\n-(*(__xmlSubstituteEntitiesDefaultValue()))\n-#else\n-XMLPUBVAR int xmlSubstituteEntitiesDefaultValue;\n-#endif\n-XMLPUBFUN int XMLCALL xmlThrDefSubstituteEntitiesDefaultValue(int v);\n-\n-XMLPUBFUN xmlRegisterNodeFunc * XMLCALL __xmlRegisterNodeDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlRegisterNodeDefaultValue \\\n-(*(__xmlRegisterNodeDefaultValue()))\n-#else\n-XMLPUBVAR xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;\n-#endif\n-\n-XMLPUBFUN xmlDeregisterNodeFunc * XMLCALL __xmlDeregisterNodeDefaultValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlDeregisterNodeDefaultValue \\\n-(*(__xmlDeregisterNodeDefaultValue()))\n-#else\n-XMLPUBVAR xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;\n-#endif\n-\n-XMLPUBFUN xmlParserInputBufferCreateFilenameFunc * XMLCALL \\\n-                                __xmlParserInputBufferCreateFilenameValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlParserInputBufferCreateFilenameValue \\\n-(*(__xmlParserInputBufferCreateFilenameValue()))\n-#else\n-XMLPUBVAR xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;\n-#endif\n+typedef struct _xmlGlobalState xmlGlobalState;\n+typedef xmlGlobalState *xmlGlobalStatePtr;\n@@ -487,7 +32,4 @@\n-XMLPUBFUN xmlOutputBufferCreateFilenameFunc * XMLCALL __xmlOutputBufferCreateFilenameValue(void);\n-#ifdef LIBXML_THREAD_ENABLED\n-#define xmlOutputBufferCreateFilenameValue \\\n-(*(__xmlOutputBufferCreateFilenameValue()))\n-#else\n-XMLPUBVAR xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;\n-#endif\n+XML_DEPRECATED XMLPUBFUN void\n+xmlInitializeGlobalState(xmlGlobalStatePtr gs);\n+XML_DEPRECATED XMLPUBFUN\n+xmlGlobalStatePtr xmlGetGlobalState(void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/globals.h","additions":15,"deletions":473,"binary":false,"changes":488,"status":"modified"},{"patch":"@@ -14,0 +14,4 @@\n+#include <libxml\/xmlversion.h>\n+#include <libxml\/dict.h>\n+#include <libxml\/xmlstring.h>\n+\n@@ -24,12 +28,0 @@\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#include <libxml\/xmlversion.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/dict.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n@@ -58,1 +50,0 @@\n-\n@@ -106,4 +97,4 @@\n-XMLPUBFUN xmlHashTablePtr XMLCALL\n-                        xmlHashCreate   (int size);\n-XMLPUBFUN xmlHashTablePtr XMLCALL\n-                        xmlHashCreateDict(int size,\n+XMLPUBFUN xmlHashTablePtr\n+                xmlHashCreate           (int size);\n+XMLPUBFUN xmlHashTablePtr\n+                xmlHashCreateDict       (int size,\n@@ -111,5 +102,5 @@\n-XMLPUBFUN void XMLCALL\n-                        xmlHashFree     (xmlHashTablePtr table,\n-                                         xmlHashDeallocator f);\n-XMLPUBFUN void XMLCALL\n-                        xmlHashDefaultDeallocator(void *entry,\n+XMLPUBFUN void\n+                xmlHashFree             (xmlHashTablePtr hash,\n+                                         xmlHashDeallocator dealloc);\n+XMLPUBFUN void\n+                xmlHashDefaultDeallocator(void *entry,\n@@ -121,2 +112,2 @@\n-XMLPUBFUN int XMLCALL\n-                        xmlHashAddEntry (xmlHashTablePtr table,\n+XMLPUBFUN int\n+                xmlHashAddEntry         (xmlHashTablePtr hash,\n@@ -125,2 +116,2 @@\n-XMLPUBFUN int XMLCALL\n-                        xmlHashUpdateEntry(xmlHashTablePtr table,\n+XMLPUBFUN int\n+                xmlHashUpdateEntry      (xmlHashTablePtr hash,\n@@ -129,3 +120,3 @@\n-                                         xmlHashDeallocator f);\n-XMLPUBFUN int XMLCALL\n-                        xmlHashAddEntry2(xmlHashTablePtr table,\n+                                         xmlHashDeallocator dealloc);\n+XMLPUBFUN int\n+                xmlHashAddEntry2        (xmlHashTablePtr hash,\n@@ -135,2 +126,2 @@\n-XMLPUBFUN int XMLCALL\n-                        xmlHashUpdateEntry2(xmlHashTablePtr table,\n+XMLPUBFUN int\n+                xmlHashUpdateEntry2     (xmlHashTablePtr hash,\n@@ -140,3 +131,3 @@\n-                                         xmlHashDeallocator f);\n-XMLPUBFUN int XMLCALL\n-                        xmlHashAddEntry3(xmlHashTablePtr table,\n+                                         xmlHashDeallocator dealloc);\n+XMLPUBFUN int\n+                xmlHashAddEntry3        (xmlHashTablePtr hash,\n@@ -147,2 +138,2 @@\n-XMLPUBFUN int XMLCALL\n-                        xmlHashUpdateEntry3(xmlHashTablePtr table,\n+XMLPUBFUN int\n+                xmlHashUpdateEntry3     (xmlHashTablePtr hash,\n@@ -153,1 +144,1 @@\n-                                         xmlHashDeallocator f);\n+                                         xmlHashDeallocator dealloc);\n@@ -158,10 +149,15 @@\n-XMLPUBFUN int XMLCALL\n-                        xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,\n-                           xmlHashDeallocator f);\n-XMLPUBFUN int XMLCALL\n-                        xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,\n-                            const xmlChar *name2, xmlHashDeallocator f);\n-XMLPUBFUN int  XMLCALL\n-                        xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,\n-                            const xmlChar *name2, const xmlChar *name3,\n-                            xmlHashDeallocator f);\n+XMLPUBFUN int\n+                xmlHashRemoveEntry      (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         xmlHashDeallocator dealloc);\n+XMLPUBFUN int\n+                xmlHashRemoveEntry2     (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         xmlHashDeallocator dealloc);\n+XMLPUBFUN int\n+                xmlHashRemoveEntry3     (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         xmlHashDeallocator dealloc);\n@@ -170,1 +166,1 @@\n- * Retrieve the userdata.\n+ * Retrieve the payload.\n@@ -172,2 +168,2 @@\n-XMLPUBFUN void * XMLCALL\n-                        xmlHashLookup   (xmlHashTablePtr table,\n+XMLPUBFUN void *\n+                xmlHashLookup           (xmlHashTablePtr hash,\n@@ -175,2 +171,2 @@\n-XMLPUBFUN void * XMLCALL\n-                        xmlHashLookup2  (xmlHashTablePtr table,\n+XMLPUBFUN void *\n+                xmlHashLookup2          (xmlHashTablePtr hash,\n@@ -179,2 +175,2 @@\n-XMLPUBFUN void * XMLCALL\n-                        xmlHashLookup3  (xmlHashTablePtr table,\n+XMLPUBFUN void *\n+                xmlHashLookup3          (xmlHashTablePtr hash,\n@@ -184,7 +180,6 @@\n-XMLPUBFUN void * XMLCALL\n-                        xmlHashQLookup  (xmlHashTablePtr table,\n-                                         const xmlChar *name,\n-                                         const xmlChar *prefix);\n-XMLPUBFUN void * XMLCALL\n-                        xmlHashQLookup2 (xmlHashTablePtr table,\n-                                         const xmlChar *name,\n+XMLPUBFUN void *\n+                xmlHashQLookup          (xmlHashTablePtr hash,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name);\n+XMLPUBFUN void *\n+                xmlHashQLookup2         (xmlHashTablePtr hash,\n@@ -192,4 +187,0 @@\n-                                         const xmlChar *name2,\n-                                         const xmlChar *prefix2);\n-XMLPUBFUN void * XMLCALL\n-                        xmlHashQLookup3 (xmlHashTablePtr table,\n@@ -197,0 +188,4 @@\n+                                         const xmlChar *prefix2,\n+                                         const xmlChar *name2);\n+XMLPUBFUN void *\n+                xmlHashQLookup3         (xmlHashTablePtr hash,\n@@ -198,1 +193,1 @@\n-                                         const xmlChar *name2,\n+                                         const xmlChar *name,\n@@ -200,2 +195,3 @@\n-                                         const xmlChar *name3,\n-                                         const xmlChar *prefix3);\n+                                         const xmlChar *name2,\n+                                         const xmlChar *prefix3,\n+                                         const xmlChar *name3);\n@@ -206,8 +202,8 @@\n-XMLPUBFUN xmlHashTablePtr XMLCALL\n-                        xmlHashCopy     (xmlHashTablePtr table,\n-                                         xmlHashCopier f);\n-XMLPUBFUN int XMLCALL\n-                        xmlHashSize     (xmlHashTablePtr table);\n-XMLPUBFUN void XMLCALL\n-                        xmlHashScan     (xmlHashTablePtr table,\n-                                         xmlHashScanner f,\n+XMLPUBFUN xmlHashTablePtr\n+                xmlHashCopy             (xmlHashTablePtr hash,\n+                                         xmlHashCopier copy);\n+XMLPUBFUN int\n+                xmlHashSize             (xmlHashTablePtr hash);\n+XMLPUBFUN void\n+                xmlHashScan             (xmlHashTablePtr hash,\n+                                         xmlHashScanner scan,\n@@ -215,2 +211,2 @@\n-XMLPUBFUN void XMLCALL\n-                        xmlHashScan3    (xmlHashTablePtr table,\n+XMLPUBFUN void\n+                xmlHashScan3            (xmlHashTablePtr hash,\n@@ -220,1 +216,1 @@\n-                                         xmlHashScanner f,\n+                                         xmlHashScanner scan,\n@@ -222,3 +218,3 @@\n-XMLPUBFUN void XMLCALL\n-                        xmlHashScanFull (xmlHashTablePtr table,\n-                                         xmlHashScannerFull f,\n+XMLPUBFUN void\n+                xmlHashScanFull         (xmlHashTablePtr hash,\n+                                         xmlHashScannerFull scan,\n@@ -226,2 +222,2 @@\n-XMLPUBFUN void XMLCALL\n-                        xmlHashScanFull3(xmlHashTablePtr table,\n+XMLPUBFUN void\n+                xmlHashScanFull3        (xmlHashTablePtr hash,\n@@ -231,1 +227,1 @@\n-                                         xmlHashScannerFull f,\n+                                         xmlHashScannerFull scan,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/hash.h","additions":81,"deletions":85,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-XMLPUBFUN xmlListPtr XMLCALL\n+XMLPUBFUN xmlListPtr\n@@ -58,1 +58,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -62,1 +62,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -65,1 +65,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -68,1 +68,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -71,1 +71,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -74,1 +74,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -77,1 +77,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -80,1 +80,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -83,1 +83,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -85,1 +85,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -87,1 +87,1 @@\n-XMLPUBFUN xmlLinkPtr XMLCALL\n+XMLPUBFUN xmlLinkPtr\n@@ -89,1 +89,1 @@\n-XMLPUBFUN xmlLinkPtr XMLCALL\n+XMLPUBFUN xmlLinkPtr\n@@ -91,1 +91,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -94,1 +94,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -96,1 +96,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -98,1 +98,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -101,1 +101,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -106,1 +106,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -108,1 +108,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -110,1 +110,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -114,1 +114,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -118,1 +118,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -121,1 +121,1 @@\n-XMLPUBFUN xmlListPtr XMLCALL\n+XMLPUBFUN xmlListPtr\n@@ -123,1 +123,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -127,1 +127,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/list.h","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-#ifdef LIBXML_FTP_ENABLED\n+#if defined(LIBXML_FTP_ENABLED)\n@@ -83,1 +83,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -86,1 +86,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -93,1 +93,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -96,1 +96,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -99,1 +99,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -106,1 +106,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -109,1 +109,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -112,1 +112,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -115,1 +115,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -118,1 +118,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -121,1 +121,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -128,1 +128,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -136,1 +136,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -139,1 +139,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -146,1 +146,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -150,1 +150,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -155,1 +155,1 @@\n-XMLPUBFUN SOCKET XMLCALL\n+XMLPUBFUN SOCKET\n@@ -158,1 +158,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -161,1 +161,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -167,1 +167,1 @@\n-XMLPUBFUN SOCKET XMLCALL\n+XMLPUBFUN SOCKET\n@@ -171,1 +171,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -177,1 +177,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -185,1 +185,1 @@\n-#endif \/* LIBXML_FTP_ENABLED *\/\n+#endif \/* defined(LIBXML_FTP_ENABLED) || defined(LIBXML_LEGACY_ENABLED) *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/nanoftp.h","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -23,1 +23,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -25,1 +25,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -27,1 +27,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -31,1 +31,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -38,1 +38,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -46,1 +46,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -49,1 +49,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -53,1 +53,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -55,1 +55,1 @@\n-XMLPUBFUN const char * XMLCALL\n+XMLPUBFUN const char *\n@@ -57,1 +57,1 @@\n-XMLPUBFUN const char * XMLCALL\n+XMLPUBFUN const char *\n@@ -59,1 +59,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -61,1 +61,1 @@\n-XMLPUBFUN const char * XMLCALL\n+XMLPUBFUN const char *\n@@ -63,1 +63,1 @@\n-XMLPUBFUN const char * XMLCALL\n+XMLPUBFUN const char *\n@@ -65,1 +65,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -70,1 +70,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -74,1 +74,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/nanohttp.h","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+#define XML_TREE_INTERNALS\n@@ -15,0 +16,1 @@\n+#undef XML_TREE_INTERNALS\n@@ -21,0 +23,6 @@\n+#include <libxml\/xmlmemory.h>\n+#include <libxml\/encoding.h>\n+#include <libxml\/xmlIO.h>\n+\/* for compatibility *\/\n+#include <libxml\/SAX2.h>\n+#include <libxml\/threads.h>\n@@ -64,5 +72,0 @@\n-    \/*\n-     * NOTE: consumed is only tested for equality in the parser code,\n-     *       so even if there is an overflow this should not give troubles\n-     *       for parsing very large instances.\n-     *\/\n@@ -71,1 +74,1 @@\n-    const xmlChar *encoding;          \/* the encoding string for entity *\/\n+    const xmlChar *encoding;          \/* unused *\/\n@@ -73,1 +76,1 @@\n-    int standalone;                   \/* Was that entity marked standalone *\/\n+    int flags;                        \/* Flags *\/\n@@ -75,0 +78,2 @@\n+    unsigned long parentConsumed;     \/* consumed bytes from parents *\/\n+    xmlEntityPtr entity;              \/* entity, if any *\/\n@@ -128,1 +133,2 @@\n-    XML_PARSER_PUBLIC_LITERAL   \/* within a PUBLIC value *\/\n+    XML_PARSER_PUBLIC_LITERAL,  \/* within a PUBLIC value *\/\n+    XML_PARSER_XML_DECL         \/* before XML decl (but after BOM) *\/\n@@ -171,0 +177,2 @@\n+typedef struct _xmlParserNsData xmlParserNsData;\n+typedef struct _xmlAttrHashBucket xmlAttrHashBucket;\n@@ -251,2 +259,1 @@\n-    int                charset;       \/* encoding of the in-memory content\n-                                         actually an xmlCharEncoding *\/\n+    int                charset;       \/* unused *\/\n@@ -282,1 +289,1 @@\n-    int               *attallocs;     \/* which attribute were allocated *\/\n+    unsigned          *attallocs;     \/* which attribute were allocated *\/\n@@ -303,1 +310,1 @@\n-    unsigned long    nbentities;    \/* number of entities references *\/\n+    unsigned long    nbentities;    \/* unused *\/\n@@ -314,0 +321,9 @@\n+\n+    int           endCheckState;    \/* quote state for push parser *\/\n+    unsigned short     nbErrors;    \/* number of errors *\/\n+    unsigned short   nbWarnings;    \/* number of warnings *\/\n+    unsigned            maxAmpl;    \/* maximum amplification factor *\/\n+\n+    xmlParserNsData       *nsdb;    \/* namespace database *\/\n+    unsigned        attrHashMax;    \/* allocated size *\/\n+    xmlAttrHashBucket *attrHash;    \/* atttribute hash table *\/\n@@ -608,1 +624,1 @@\n-typedef void (XMLCDECL *warningSAXFunc) (void *ctx,\n+typedef void (*warningSAXFunc) (void *ctx,\n@@ -618,1 +634,1 @@\n-typedef void (XMLCDECL *errorSAXFunc) (void *ctx,\n+typedef void (*errorSAXFunc) (void *ctx,\n@@ -630,1 +646,1 @@\n-typedef void (XMLCDECL *fatalErrorSAXFunc) (void *ctx,\n+typedef void (*fatalErrorSAXFunc) (void *ctx,\n@@ -734,0 +750,13 @@\n+    \/*\n+     * `startElement` and `endElement` are only used by the legacy SAX1\n+     * interface and should not be used in new software. If you really\n+     * have to enable SAX1, the preferred way is set the `initialized`\n+     * member to 1 instead of XML_SAX2_MAGIC.\n+     *\n+     * For backward compatibility, it's also possible to set the\n+     * `startElementNs` and `endElementNs` handlers to NULL.\n+     *\n+     * You can also set the XML_PARSE_SAX1 parser option, but versions\n+     * older than 2.12.0 will probably crash if this option is provided\n+     * together with custom SAX callbacks.\n+     *\/\n@@ -747,0 +776,4 @@\n+    \/*\n+     * `initialized` should always be set to XML_SAX2_MAGIC to enable the\n+     * modern SAX2 interface.\n+     *\/\n@@ -748,1 +781,3 @@\n-    \/* The following fields are extensions available only on version 2 *\/\n+    \/*\n+     * The following members are only used by the SAX2 interface.\n+     *\/\n@@ -806,2 +841,8 @@\n-#ifdef __cplusplus\n-}\n+\/*\n+ * Variables\n+ *\/\n+\n+XMLPUBVAR const char *const xmlParserVersion;\n+#ifdef LIBXML_THREAD_ENABLED\n+\/* backward compatibility *\/\n+XMLPUBFUN const char *const *__xmlParserVersion(void);\n@@ -810,3 +851,21 @@\n-#include <libxml\/encoding.h>\n-#include <libxml\/xmlIO.h>\n-#include <libxml\/globals.h>\n+\/** DOC_DISABLE *\/\n+#define XML_GLOBALS_PARSER_CORE \\\n+  XML_OP(oldXMLWDcompatibility, int, XML_DEPRECATED) \\\n+  XML_OP(xmlDefaultSAXLocator, xmlSAXLocator, XML_DEPRECATED) \\\n+  XML_OP(xmlDoValidityCheckingDefaultValue, int, XML_DEPRECATED) \\\n+  XML_OP(xmlGetWarningsDefaultValue, int, XML_DEPRECATED) \\\n+  XML_OP(xmlKeepBlanksDefaultValue, int, XML_DEPRECATED) \\\n+  XML_OP(xmlLineNumbersDefaultValue, int, XML_DEPRECATED) \\\n+  XML_OP(xmlLoadExtDtdDefaultValue, int, XML_DEPRECATED) \\\n+  XML_OP(xmlParserDebugEntities, int, XML_DEPRECATED) \\\n+  XML_OP(xmlPedanticParserDefaultValue, int, XML_DEPRECATED) \\\n+  XML_OP(xmlSubstituteEntitiesDefaultValue, int, XML_DEPRECATED)\n+\n+#ifdef LIBXML_OUTPUT_ENABLED\n+  #define XML_GLOBALS_PARSER_OUTPUT \\\n+    XML_OP(xmlIndentTreeOutput, int, XML_NO_ATTR) \\\n+    XML_OP(xmlTreeIndentString, const char *, XML_NO_ATTR) \\\n+    XML_OP(xmlSaveNoEmptyTags, int, XML_NO_ATTR)\n+#else\n+  #define XML_GLOBALS_PARSER_OUTPUT\n+#endif\n@@ -814,2 +873,5 @@\n-#ifdef __cplusplus\n-extern \"C\" {\n+#ifdef LIBXML_SAX1_ENABLED\n+  #define XML_GLOBALS_PARSER_SAX1 \\\n+    XML_OP(xmlDefaultSAXHandler, xmlSAXHandlerV1, XML_DEPRECATED)\n+#else\n+  #define XML_GLOBALS_PARSER_SAX1\n@@ -818,0 +880,33 @@\n+#define XML_GLOBALS_PARSER \\\n+  XML_GLOBALS_PARSER_CORE \\\n+  XML_GLOBALS_PARSER_OUTPUT \\\n+  XML_GLOBALS_PARSER_SAX1\n+\n+#define XML_OP XML_DECLARE_GLOBAL\n+XML_GLOBALS_PARSER\n+#undef XML_OP\n+\n+#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+  #define oldXMLWDcompatibility XML_GLOBAL_MACRO(oldXMLWDcompatibility)\n+  #define xmlDefaultSAXHandler XML_GLOBAL_MACRO(xmlDefaultSAXHandler)\n+  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)\n+  #define xmlDoValidityCheckingDefaultValue \\\n+    XML_GLOBAL_MACRO(xmlDoValidityCheckingDefaultValue)\n+  #define xmlGetWarningsDefaultValue \\\n+    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)\n+  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)\n+  #define xmlLineNumbersDefaultValue \\\n+    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)\n+  #define xmlLoadExtDtdDefaultValue XML_GLOBAL_MACRO(xmlLoadExtDtdDefaultValue)\n+  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)\n+  #define xmlPedanticParserDefaultValue \\\n+    XML_GLOBAL_MACRO(xmlPedanticParserDefaultValue)\n+  #define xmlSubstituteEntitiesDefaultValue \\\n+    XML_GLOBAL_MACRO(xmlSubstituteEntitiesDefaultValue)\n+  #ifdef LIBXML_OUTPUT_ENABLED\n+    #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)\n+    #define xmlTreeIndentString XML_GLOBAL_MACRO(xmlTreeIndentString)\n+    #define xmlSaveNoEmptyTags XML_GLOBAL_MACRO(xmlSaveNoEmptyTags)\n+  #endif\n+#endif\n+\/** DOC_ENABLE *\/\n@@ -822,1 +917,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -824,1 +919,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -826,0 +921,6 @@\n+XML_DEPRECATED\n+XMLPUBFUN void\n+                xmlInitGlobals          (void);\n+XML_DEPRECATED\n+XMLPUBFUN void\n+                xmlCleanupGlobals       (void);\n@@ -830,1 +931,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -833,1 +935,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -841,1 +944,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -843,1 +946,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -845,1 +948,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -849,1 +952,1 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED XMLPUBFUN int\n@@ -851,1 +954,3 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefSubstituteEntitiesDefaultValue(int v);\n+XML_DEPRECATED XMLPUBFUN int\n@@ -853,1 +958,3 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefKeepBlanksDefaultValue(int v);\n+XMLPUBFUN void\n@@ -855,1 +962,1 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED XMLPUBFUN int\n@@ -857,1 +964,3 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefPedanticParserDefaultValue(int v);\n+XML_DEPRECATED XMLPUBFUN int\n@@ -859,0 +968,10 @@\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefLineNumbersDefaultValue(int v);\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefDoValidityCheckingDefaultValue(int v);\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefGetWarningsDefaultValue(int v);\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefLoadExtDtdDefaultValue(int v);\n+XML_DEPRECATED XMLPUBFUN int\n+                xmlThrDefParserDebugEntities(int v);\n@@ -864,1 +983,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -866,1 +986,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -869,1 +990,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -876,1 +998,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -878,1 +1000,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -881,1 +1003,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -885,1 +1008,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -890,1 +1014,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -894,1 +1019,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -899,1 +1025,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -905,1 +1032,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -909,1 +1037,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -914,1 +1043,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -917,1 +1047,2 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDocPtr\n@@ -922,1 +1053,2 @@\n-XMLPUBFUN xmlDtdPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlDtdPtr\n@@ -926,1 +1058,1 @@\n-XMLPUBFUN xmlDtdPtr XMLCALL\n+XMLPUBFUN xmlDtdPtr\n@@ -929,1 +1061,1 @@\n-XMLPUBFUN xmlDtdPtr XMLCALL\n+XMLPUBFUN xmlDtdPtr\n@@ -935,1 +1067,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -943,1 +1075,1 @@\n-XMLPUBFUN xmlParserErrors XMLCALL\n+XMLPUBFUN xmlParserErrors\n@@ -950,1 +1082,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -958,1 +1090,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -967,1 +1100,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -976,1 +1109,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -978,1 +1111,4 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n+                xmlNewSAXParserCtxt     (const xmlSAXHandler *sax,\n+                                         void *userData);\n+XMLPUBFUN int\n@@ -980,1 +1116,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -982,1 +1118,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -985,1 +1121,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -990,1 +1127,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -998,1 +1135,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1002,1 +1139,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1007,1 +1144,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1017,1 +1154,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -1023,1 +1160,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1034,1 +1171,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -1042,1 +1179,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -1050,1 +1187,1 @@\n-XMLPUBFUN const xmlParserNodeInfo* XMLCALL\n+XMLPUBFUN const xmlParserNodeInfo*\n@@ -1053,1 +1190,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1055,1 +1192,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1057,1 +1194,1 @@\n-XMLPUBFUN unsigned long XMLCALL\n+XMLPUBFUN unsigned long\n@@ -1060,1 +1197,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1068,1 +1205,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1070,1 +1207,1 @@\n-XMLPUBFUN xmlExternalEntityLoader XMLCALL\n+XMLPUBFUN xmlExternalEntityLoader\n@@ -1072,1 +1209,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -1080,1 +1217,1 @@\n-XMLPUBFUN long XMLCALL\n+XMLPUBFUN long\n@@ -1120,1 +1257,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1122,1 +1259,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1128,1 +1265,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1131,1 +1268,4 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN void\n+                xmlCtxtSetMaxAmplification(xmlParserCtxtPtr ctxt,\n+                                         unsigned maxAmpl);\n+XMLPUBFUN xmlDocPtr\n@@ -1136,1 +1276,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1140,1 +1280,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1146,1 +1286,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1151,1 +1291,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1158,1 +1298,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1164,1 +1304,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1169,1 +1309,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1176,1 +1316,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1182,1 +1322,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -1238,1 +1378,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/parser.h","additions":233,"deletions":93,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+#include <libxml\/SAX2.h>\n@@ -43,0 +44,7 @@\n+\/**\n+ * XML_MAX_HUGE_LENGTH:\n+ *\n+ * Maximum size allowed when XML_PARSE_HUGE is set.\n+ *\/\n+#define XML_MAX_HUGE_LENGTH 1000000000\n+\n@@ -281,28 +289,0 @@\n-\/**\n- * SKIP_EOL:\n- * @p:  and UTF8 string pointer\n- *\n- * Skips the end of line chars.\n- *\/\n-#define SKIP_EOL(p)                                                     \\\n-    if (*(p) == 0x13) { p++ ; if (*(p) == 0x10) p++; }                  \\\n-    if (*(p) == 0x10) { p++ ; if (*(p) == 0x13) p++; }\n-\n-\/**\n- * MOVETO_ENDTAG:\n- * @p:  and UTF8 string pointer\n- *\n- * Skips to the next '>' char.\n- *\/\n-#define MOVETO_ENDTAG(p)                                                \\\n-    while ((*p) && (*(p) != '>')) (p)++\n-\n-\/**\n- * MOVETO_STARTTAG:\n- * @p:  and UTF8 string pointer\n- *\n- * Skips to the next '<' char.\n- *\/\n-#define MOVETO_STARTTAG(p)                                              \\\n-    while ((*p) && (*(p) != '<')) (p)++\n-\n@@ -319,1 +299,1 @@\n-XMLPUBFUN int XMLCALL                   xmlIsLetter     (int c);\n+XMLPUBFUN int                   xmlIsLetter     (int c);\n@@ -324,1 +304,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -326,1 +306,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -329,1 +309,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -332,1 +312,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -336,1 +316,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -339,1 +319,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -343,1 +323,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -348,10 +328,0 @@\n-#ifdef IN_LIBXML\n-\/* internal error reporting *\/\n-XMLPUBFUN void XMLCALL\n-                        __xmlErrEncoding        (xmlParserCtxtPtr ctxt,\n-                                                 xmlParserErrors xmlerr,\n-                                                 const char *msg,\n-                                                 const xmlChar * str1,\n-                                                 const xmlChar * str2) LIBXML_ATTR_FORMAT(3,0);\n-#endif\n-\n@@ -361,1 +331,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -364,1 +334,2 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlParserInputPtr\n@@ -367,1 +338,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -370,1 +341,1 @@\n-XMLPUBFUN xmlChar XMLCALL\n+XMLPUBFUN xmlChar\n@@ -372,1 +343,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -374,1 +345,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -377,1 +348,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -383,1 +354,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -391,1 +362,2 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN const xmlChar *\n@@ -393,1 +365,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -395,1 +368,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -398,1 +372,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -400,1 +375,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -402,1 +378,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -404,1 +381,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -407,1 +385,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -411,1 +390,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -413,1 +393,2 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN const xmlChar *\n@@ -415,1 +396,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -417,1 +399,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -419,1 +402,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -421,1 +405,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -424,1 +409,2 @@\n-XMLPUBFUN xmlEnumerationPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlEnumerationPtr\n@@ -426,1 +412,2 @@\n-XMLPUBFUN xmlEnumerationPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlEnumerationPtr\n@@ -428,1 +415,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -431,1 +419,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -434,1 +423,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -436,1 +426,2 @@\n-XMLPUBFUN xmlElementContentPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlElementContentPtr\n@@ -440,1 +431,2 @@\n-XMLPUBFUN xmlElementContentPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlElementContentPtr\n@@ -444,1 +436,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -448,1 +441,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -450,1 +444,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -452,1 +447,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -454,1 +450,2 @@\n-XMLPUBFUN xmlEntityPtr XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlEntityPtr\n@@ -456,1 +453,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -458,1 +456,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -460,1 +459,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -463,1 +463,2 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN const xmlChar *\n@@ -466,1 +467,2 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN const xmlChar *\n@@ -468,1 +470,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -471,1 +474,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -473,1 +477,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -475,1 +479,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -477,1 +482,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -479,1 +485,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -481,1 +488,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -483,1 +491,2 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN const xmlChar *\n@@ -485,1 +494,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -487,1 +497,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -489,1 +500,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -491,1 +503,2 @@\n-XMLPUBFUN void XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -493,1 +506,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -522,1 +535,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -529,1 +543,2 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN xmlChar *\n@@ -541,1 +556,2 @@\n-XMLPUBFUN int XMLCALL                   nodePush                (xmlParserCtxtPtr ctxt,\n+XML_DEPRECATED\n+XMLPUBFUN int                   nodePush                (xmlParserCtxtPtr ctxt,\n@@ -543,2 +559,3 @@\n-XMLPUBFUN xmlNodePtr XMLCALL            nodePop                 (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL                   inputPush               (xmlParserCtxtPtr ctxt,\n+XML_DEPRECATED\n+XMLPUBFUN xmlNodePtr            nodePop                 (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int                   inputPush               (xmlParserCtxtPtr ctxt,\n@@ -546,3 +563,5 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL     inputPop                (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN const xmlChar * XMLCALL       namePop                 (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL                   namePush                (xmlParserCtxtPtr ctxt,\n+XMLPUBFUN xmlParserInputPtr     inputPop                (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n+XMLPUBFUN const xmlChar *       namePop                 (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n+XMLPUBFUN int                   namePush                (xmlParserCtxtPtr ctxt,\n@@ -554,2 +573,4 @@\n-XMLPUBFUN int XMLCALL                   xmlSkipBlankChars       (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL                   xmlStringCurrentChar    (xmlParserCtxtPtr ctxt,\n+XML_DEPRECATED\n+XMLPUBFUN int                   xmlSkipBlankChars       (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n+XMLPUBFUN int                   xmlStringCurrentChar    (xmlParserCtxtPtr ctxt,\n@@ -558,2 +579,4 @@\n-XMLPUBFUN void XMLCALL                  xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL                   xmlCheckLanguageID      (const xmlChar *lang);\n+XML_DEPRECATED\n+XMLPUBFUN void                  xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n+XMLPUBFUN int                   xmlCheckLanguageID      (const xmlChar *lang);\n@@ -564,1 +587,2 @@\n-XMLPUBFUN int XMLCALL                   xmlCurrentChar          (xmlParserCtxtPtr ctxt,\n+XML_DEPRECATED\n+XMLPUBFUN int                   xmlCurrentChar          (xmlParserCtxtPtr ctxt,\n@@ -566,1 +590,1 @@\n-XMLPUBFUN int XMLCALL           xmlCopyCharMultiByte    (xmlChar *out,\n+XMLPUBFUN int           xmlCopyCharMultiByte    (xmlChar *out,\n@@ -568,1 +592,1 @@\n-XMLPUBFUN int XMLCALL                   xmlCopyChar             (int len,\n+XMLPUBFUN int                   xmlCopyChar             (int len,\n@@ -571,7 +595,0 @@\n-XMLPUBFUN void XMLCALL                  xmlNextChar             (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN void XMLCALL                  xmlParserInputShrink    (xmlParserInputPtr in);\n-\n-#ifdef LIBXML_HTML_ENABLED\n-\/*\n- * Actually comes from the HTML parser but launched from the init stuff.\n- *\/\n@@ -579,4 +596,3 @@\n-XMLPUBFUN void XMLCALL                  htmlInitAutoClose       (void);\n-XMLPUBFUN htmlParserCtxtPtr XMLCALL     htmlCreateFileParserCtxt(const char *filename,\n-                                                 const char *encoding);\n-#endif\n+XMLPUBFUN void                  xmlNextChar             (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n+XMLPUBFUN void                  xmlParserInputShrink    (xmlParserInputPtr in);\n@@ -603,1 +619,1 @@\n-XMLPUBFUN void XMLCALL          xmlSetEntityReferenceFunc       (xmlEntityReferenceFunc func);\n+XMLPUBFUN void          xmlSetEntityReferenceFunc       (xmlEntityReferenceFunc func);\n@@ -606,1 +622,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -609,1 +625,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -612,1 +628,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -615,1 +631,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -618,1 +634,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -621,1 +637,1 @@\n-XMLPUBFUN void XMLCALL  xmlParserHandleReference(xmlParserCtxtPtr ctxt);\n+XMLPUBFUN void  xmlParserHandleReference(xmlParserCtxtPtr ctxt);\n@@ -623,1 +639,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -630,1 +646,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -638,1 +654,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -644,9 +660,0 @@\n-#ifdef IN_LIBXML\n-\/*\n- * internal only\n- *\/\n-XMLPUBFUN void XMLCALL\n-        xmlErrMemory            (xmlParserCtxtPtr ctxt,\n-                                 const char *extra);\n-#endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/parserInternals.h","additions":150,"deletions":143,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -49,1 +49,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -52,1 +52,1 @@\n-XMLPUBFUN xmlPatternPtr XMLCALL\n+XMLPUBFUN xmlPatternPtr\n@@ -57,1 +57,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -65,1 +65,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -67,1 +67,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -69,1 +69,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -71,1 +71,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -73,1 +73,1 @@\n-XMLPUBFUN xmlStreamCtxtPtr XMLCALL\n+XMLPUBFUN xmlStreamCtxtPtr\n@@ -75,1 +75,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -77,1 +77,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -82,1 +82,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -86,1 +86,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -90,1 +90,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -92,1 +92,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/pattern.h","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-#include <libxml\/hash.h>\n+#include <libxml\/xmlerror.h>\n@@ -16,0 +16,1 @@\n+#include <libxml\/tree.h>\n@@ -35,1 +36,1 @@\n-typedef void (XMLCDECL *xmlRelaxNGValidityErrorFunc) (void *ctx,\n+typedef void (*xmlRelaxNGValidityErrorFunc) (void *ctx,\n@@ -47,1 +48,1 @@\n-typedef void (XMLCDECL *xmlRelaxNGValidityWarningFunc) (void *ctx,\n+typedef void (*xmlRelaxNGValidityWarningFunc) (void *ctx,\n@@ -119,1 +120,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -122,1 +123,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -128,1 +129,1 @@\n-XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlRelaxNGParserCtxtPtr\n@@ -130,1 +131,1 @@\n-XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlRelaxNGParserCtxtPtr\n@@ -133,1 +134,1 @@\n-XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlRelaxNGParserCtxtPtr\n@@ -136,1 +137,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -140,1 +141,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -142,1 +143,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -147,1 +148,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -152,1 +153,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -157,1 +158,1 @@\n-XMLPUBFUN xmlRelaxNGPtr XMLCALL\n+XMLPUBFUN xmlRelaxNGPtr\n@@ -159,1 +160,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -162,1 +163,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -165,1 +166,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -172,1 +173,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -177,1 +178,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -182,1 +183,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -185,1 +186,1 @@\n-XMLPUBFUN xmlRelaxNGValidCtxtPtr XMLCALL\n+XMLPUBFUN xmlRelaxNGValidCtxtPtr\n@@ -187,1 +188,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -189,1 +190,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -195,1 +196,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -199,1 +200,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -203,1 +204,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -207,1 +208,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/relaxng.h","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <libxml\/tree.h>\n@@ -950,2 +951,2 @@\n-XMLPUBFUN void XMLCALL         xmlSchemaFreeType        (xmlSchemaTypePtr type);\n-XMLPUBFUN void XMLCALL         xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard);\n+XMLPUBFUN void         xmlSchemaFreeType        (xmlSchemaTypePtr type);\n+XMLPUBFUN void         xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/schemasInternals.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+#include <libxml\/xmlerror.h>\n@@ -72,1 +73,1 @@\n-XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchematronParserCtxtPtr\n@@ -74,1 +75,1 @@\n-XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchematronParserCtxtPtr\n@@ -77,1 +78,1 @@\n-XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchematronParserCtxtPtr\n@@ -79,1 +80,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -82,1 +83,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -87,1 +88,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -92,1 +93,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -95,1 +96,1 @@\n-XMLPUBFUN xmlSchematronPtr XMLCALL\n+XMLPUBFUN xmlSchematronPtr\n@@ -97,1 +98,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -102,1 +103,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -108,1 +109,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -113,1 +114,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -118,1 +119,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -121,1 +122,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -123,1 +124,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -128,1 +129,1 @@\n-XMLPUBFUN xmlSchematronValidCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchematronValidCtxtPtr\n@@ -131,1 +132,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -133,1 +134,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/schematron.h","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -32,8 +32,4 @@\n-#ifdef __cplusplus\n-}\n-#endif\n-#include <libxml\/globals.h>\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-XMLPUBFUN xmlMutexPtr XMLCALL\n+XMLPUBFUN int\n+                        xmlCheckThreadLocalStorage(void);\n+\n+XMLPUBFUN xmlMutexPtr\n@@ -41,1 +37,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -43,1 +39,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -45,1 +41,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -48,1 +44,1 @@\n-XMLPUBFUN xmlRMutexPtr XMLCALL\n+XMLPUBFUN xmlRMutexPtr\n@@ -50,1 +46,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -52,1 +48,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -54,1 +50,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -61,1 +57,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -63,1 +59,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -65,1 +61,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -67,1 +63,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -69,1 +66,2 @@\n-XMLPUBFUN int XMLCALL\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -72,1 +70,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -74,2 +72,0 @@\n-XMLPUBFUN xmlGlobalStatePtr XMLCALL\n-                        xmlGetGlobalState(void);\n@@ -77,4 +73,4 @@\n-#ifdef HAVE_PTHREAD_H\n-#elif defined(HAVE_WIN32_THREADS) && !defined(HAVE_COMPILER_TLS) && (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n-#if defined(LIBXML_STATIC_FOR_DLL)\n-int XMLCALL\n+\/** DOC_DISABLE *\/\n+#if defined(LIBXML_THREAD_ENABLED) && defined(_WIN32) && \\\n+    defined(LIBXML_STATIC_FOR_DLL)\n+int\n@@ -84,1 +80,1 @@\n-#endif\n+\/** DOC_ENABLE *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/threads.h","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -12,0 +12,9 @@\n+#ifndef XML_TREE_INTERNALS\n+\n+\/*\n+ * Emulate circular dependency for backward compatibility\n+ *\/\n+#include <libxml\/parser.h>\n+\n+#else \/* XML_TREE_INTERNALS *\/\n+\n@@ -19,0 +28,2 @@\n+#include <libxml\/xmlmemory.h>\n+#include <libxml\/xmlregexp.h>\n@@ -77,1 +88,1 @@\n-    XML_BUFFER_ALLOC_IMMUTABLE, \/* immutable buffer *\/\n+    XML_BUFFER_ALLOC_IMMUTABLE, \/* immutable buffer, deprecated *\/\n@@ -120,4 +131,4 @@\n-XMLPUBFUN xmlChar* XMLCALL       xmlBufContent  (const xmlBuf* buf);\n-XMLPUBFUN xmlChar* XMLCALL       xmlBufEnd      (xmlBufPtr buf);\n-XMLPUBFUN size_t XMLCALL         xmlBufUse      (const xmlBufPtr buf);\n-XMLPUBFUN size_t XMLCALL         xmlBufShrink   (xmlBufPtr buf, size_t len);\n+XMLPUBFUN xmlChar*       xmlBufContent  (const xmlBuf* buf);\n+XMLPUBFUN xmlChar*       xmlBufEnd      (xmlBufPtr buf);\n+XMLPUBFUN size_t         xmlBufUse      (const xmlBufPtr buf);\n+XMLPUBFUN size_t         xmlBufShrink   (xmlBufPtr buf, size_t len);\n@@ -183,0 +194,1 @@\n+\/** DOC_DISABLE *\/\n@@ -185,0 +197,1 @@\n+\/** DOC_ENABLE *\/\n@@ -330,8 +343,0 @@\n-#ifdef __cplusplus\n-}\n-#endif\n-#include <libxml\/xmlregexp.h>\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n@@ -574,1 +579,1 @@\n-    const xmlChar  *encoding;   \/* external initial encoding, if any *\/\n+    const xmlChar  *encoding;   \/* actual encoding, if any *\/\n@@ -578,2 +583,1 @@\n-    int             charset;    \/* Internal flag for charset handling,\n-                                   actually an xmlCharEncoding *\/\n+    int             charset;    \/* unused *\/\n@@ -631,0 +635,16 @@\n+\/**\n+ * xmlRegisterNodeFunc:\n+ * @node: the current node\n+ *\n+ * Signature for the registration callback of a created node\n+ *\/\n+typedef void (*xmlRegisterNodeFunc) (xmlNodePtr node);\n+\n+\/**\n+ * xmlDeregisterNodeFunc:\n+ * @node: the current node\n+ *\n+ * Signature for the deregistration callback of a discarded node\n+ *\/\n+typedef void (*xmlDeregisterNodeFunc) (xmlNodePtr node);\n+\n@@ -655,0 +675,22 @@\n+\/** DOC_DISABLE *\/\n+#define XML_GLOBALS_TREE \\\n+  XML_OP(xmlBufferAllocScheme, xmlBufferAllocationScheme, XML_DEPRECATED) \\\n+  XML_OP(xmlDefaultBufferSize, int, XML_DEPRECATED) \\\n+  XML_OP(xmlRegisterNodeDefaultValue, xmlRegisterNodeFunc, XML_DEPRECATED) \\\n+  XML_OP(xmlDeregisterNodeDefaultValue, xmlDeregisterNodeFunc, \\\n+         XML_DEPRECATED)\n+\n+#define XML_OP XML_DECLARE_GLOBAL\n+XML_GLOBALS_TREE\n+#undef XML_OP\n+\n+#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)\n+  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)\n+  #define xmlRegisterNodeDefaultValue \\\n+    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)\n+  #define xmlDeregisterNodeDefaultValue \\\n+    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)\n+#endif\n+\/** DOC_ENABLE *\/\n+\n@@ -658,6 +700,1 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || \\\n-    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || \\\n-    defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || \\\n-    defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || \\\n-    defined(LIBXML_LEGACY_ENABLED)\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -666,1 +703,0 @@\n-#endif\n@@ -669,1 +705,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -672,1 +708,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -675,1 +711,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -680,1 +716,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -685,1 +721,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -688,1 +724,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -696,1 +732,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -698,1 +734,1 @@\n-XMLPUBFUN xmlBufferAllocationScheme XMLCALL\n+XMLPUBFUN xmlBufferAllocationScheme\n@@ -701,1 +737,1 @@\n-XMLPUBFUN xmlBufferPtr XMLCALL\n+XMLPUBFUN xmlBufferPtr\n@@ -703,1 +739,1 @@\n-XMLPUBFUN xmlBufferPtr XMLCALL\n+XMLPUBFUN xmlBufferPtr\n@@ -705,1 +741,1 @@\n-XMLPUBFUN xmlBufferPtr XMLCALL\n+XMLPUBFUN xmlBufferPtr\n@@ -708,1 +744,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -711,1 +747,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -713,1 +749,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -716,1 +752,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -720,1 +756,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -724,1 +760,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -727,1 +763,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -730,1 +766,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -733,1 +769,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -736,1 +772,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -738,1 +774,1 @@\n-XMLPUBFUN const xmlChar* XMLCALL\n+XMLPUBFUN const xmlChar*\n@@ -740,1 +776,1 @@\n-XMLPUBFUN xmlChar* XMLCALL\n+XMLPUBFUN xmlChar*\n@@ -742,1 +778,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -745,1 +781,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -751,1 +787,1 @@\n-XMLPUBFUN xmlDtdPtr XMLCALL\n+XMLPUBFUN xmlDtdPtr\n@@ -756,1 +792,1 @@\n-XMLPUBFUN xmlDtdPtr XMLCALL\n+XMLPUBFUN xmlDtdPtr\n@@ -761,1 +797,1 @@\n-XMLPUBFUN xmlDtdPtr XMLCALL\n+XMLPUBFUN xmlDtdPtr\n@@ -763,1 +799,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -767,1 +803,1 @@\n-XMLPUBFUN xmlNsPtr XMLCALL\n+XMLPUBFUN xmlNsPtr\n@@ -772,1 +808,1 @@\n-XMLPUBFUN xmlNsPtr XMLCALL\n+XMLPUBFUN xmlNsPtr\n@@ -776,1 +812,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -778,1 +814,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -780,1 +816,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -782,1 +818,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -784,1 +820,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -790,1 +826,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -795,1 +831,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -800,1 +836,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -805,1 +841,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -807,1 +843,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -809,1 +845,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -812,1 +848,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -816,1 +852,1 @@\n-XMLPUBFUN xmlDtdPtr XMLCALL\n+XMLPUBFUN xmlDtdPtr\n@@ -820,1 +856,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -827,1 +863,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -832,1 +868,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -837,1 +873,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -840,1 +876,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -844,1 +880,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -850,1 +886,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -853,1 +889,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -855,1 +891,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -859,1 +895,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -862,1 +898,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -866,1 +902,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -869,1 +905,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -872,1 +908,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -874,1 +910,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -878,1 +914,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -881,1 +917,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -884,1 +920,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -887,1 +923,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -891,1 +927,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -894,1 +930,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -897,1 +933,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -902,1 +938,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -907,1 +943,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -914,1 +950,1 @@\n-XMLPUBFUN long XMLCALL\n+XMLPUBFUN long\n@@ -917,1 +953,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -920,1 +956,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -922,1 +958,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -924,1 +960,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -926,1 +962,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -933,1 +969,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -938,1 +974,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -942,1 +978,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -945,1 +981,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -949,1 +985,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -955,1 +991,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -959,1 +995,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -962,1 +998,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -965,1 +1001,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -967,1 +1003,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -970,1 +1006,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -974,1 +1010,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -976,1 +1012,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -978,1 +1014,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -981,1 +1017,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -987,1 +1023,1 @@\n-XMLPUBFUN xmlNsPtr XMLCALL\n+XMLPUBFUN xmlNsPtr\n@@ -991,1 +1027,1 @@\n-XMLPUBFUN xmlNsPtr XMLCALL\n+XMLPUBFUN xmlNsPtr\n@@ -997,1 +1033,1 @@\n-XMLPUBFUN xmlNsPtr * XMLCALL\n+XMLPUBFUN xmlNsPtr *\n@@ -1002,1 +1038,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1005,1 +1041,1 @@\n-XMLPUBFUN xmlNsPtr XMLCALL\n+XMLPUBFUN xmlNsPtr\n@@ -1007,1 +1043,1 @@\n-XMLPUBFUN xmlNsPtr XMLCALL\n+XMLPUBFUN xmlNsPtr\n@@ -1015,1 +1051,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -1019,1 +1055,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -1026,1 +1062,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1029,1 +1065,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1032,1 +1068,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -1035,1 +1071,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -1039,1 +1075,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1043,1 +1079,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -1046,1 +1082,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -1050,1 +1086,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1055,1 +1091,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1060,1 +1096,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1064,1 +1100,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1069,1 +1105,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1072,1 +1108,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1076,1 +1112,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1079,1 +1115,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1082,1 +1118,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1086,1 +1122,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1088,1 +1124,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1091,1 +1127,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1094,1 +1130,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1098,1 +1134,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -1102,1 +1138,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1110,1 +1146,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1113,1 +1149,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1117,1 +1153,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1125,1 +1161,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1128,1 +1164,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1131,1 +1167,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1146,1 +1182,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1155,1 +1191,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1160,1 +1196,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1164,1 +1200,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1169,1 +1205,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1175,1 +1211,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1179,1 +1215,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1182,1 +1218,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1186,1 +1222,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1189,1 +1225,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1193,1 +1229,1 @@\n-XMLPUBFUN size_t XMLCALL\n+XMLPUBFUN size_t\n@@ -1199,1 +1235,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1206,1 +1242,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1210,1 +1246,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1215,1 +1251,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1223,1 +1259,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1229,1 +1265,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1238,1 +1274,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1245,1 +1281,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1247,1 +1283,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1250,1 +1286,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1252,1 +1288,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1258,1 +1294,1 @@\n-XMLPUBFUN xmlDOMWrapCtxtPtr XMLCALL\n+XMLPUBFUN xmlDOMWrapCtxtPtr\n@@ -1260,1 +1296,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -1262,1 +1298,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1266,1 +1302,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1273,1 +1309,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1278,1 +1314,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -1293,1 +1329,1 @@\n-XMLPUBFUN unsigned long XMLCALL\n+XMLPUBFUN unsigned long\n@@ -1295,1 +1331,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -1297,1 +1333,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -1299,1 +1335,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -1301,1 +1337,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -1304,0 +1340,15 @@\n+\n+XMLPUBFUN xmlRegisterNodeFunc\n+            xmlRegisterNodeDefault      (xmlRegisterNodeFunc func);\n+XMLPUBFUN xmlDeregisterNodeFunc\n+            xmlDeregisterNodeDefault    (xmlDeregisterNodeFunc func);\n+XMLPUBFUN xmlRegisterNodeFunc\n+            xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func);\n+XMLPUBFUN xmlDeregisterNodeFunc\n+            xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func);\n+\n+XML_DEPRECATED XMLPUBFUN xmlBufferAllocationScheme\n+            xmlThrDefBufferAllocScheme  (xmlBufferAllocationScheme v);\n+XML_DEPRECATED XMLPUBFUN int\n+            xmlThrDefDefaultBufferSize  (int v);\n+\n@@ -1307,3 +1358,0 @@\n-#ifndef __XML_PARSER_H__\n-#include <libxml\/xmlmemory.h>\n-#endif\n@@ -1313,0 +1361,2 @@\n+#endif \/* XML_TREE_INTERNALS *\/\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/tree.h","additions":234,"deletions":184,"binary":false,"changes":418,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+#include <stdio.h>\n@@ -15,1 +16,1 @@\n-#include <libxml\/tree.h>\n+#include <libxml\/xmlstring.h>\n@@ -52,1 +53,1 @@\n-XMLPUBFUN xmlURIPtr XMLCALL\n+XMLPUBFUN xmlURIPtr\n@@ -54,1 +55,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -57,1 +58,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -60,1 +61,1 @@\n-XMLPUBFUN xmlURIPtr XMLCALL\n+XMLPUBFUN xmlURIPtr\n@@ -62,1 +63,1 @@\n-XMLPUBFUN xmlURIPtr XMLCALL\n+XMLPUBFUN xmlURIPtr\n@@ -65,1 +66,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -68,1 +69,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -70,1 +71,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -73,1 +74,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -76,1 +77,1 @@\n-XMLPUBFUN char * XMLCALL\n+XMLPUBFUN char *\n@@ -80,1 +81,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -82,1 +83,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -84,1 +85,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -86,1 +87,1 @@\n-XMLPUBFUN xmlChar* XMLCALL\n+XMLPUBFUN xmlChar*\n@@ -88,1 +89,1 @@\n-XMLPUBFUN xmlChar* XMLCALL\n+XMLPUBFUN xmlChar*\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/uri.h","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+#define XML_TREE_INTERNALS\n@@ -17,0 +18,1 @@\n+#undef XML_TREE_INTERNALS\n@@ -42,1 +44,1 @@\n-typedef void (XMLCDECL *xmlValidityErrorFunc) (void *ctx,\n+typedef void (*xmlValidityErrorFunc) (void *ctx,\n@@ -57,1 +59,1 @@\n-typedef void (XMLCDECL *xmlValidityWarningFunc) (void *ctx,\n+typedef void (*xmlValidityWarningFunc) (void *ctx,\n@@ -61,15 +63,0 @@\n-#ifdef IN_LIBXML\n-\/**\n- * XML_VCTXT_DTD_VALIDATED:\n- *\n- * Set after xmlValidateDtdFinal was called.\n- *\/\n-#define XML_VCTXT_DTD_VALIDATED (1u << 0)\n-\/**\n- * XML_VCTXT_USE_PCTXT:\n- *\n- * Set if the validation context is part of a parser context.\n- *\/\n-#define XML_VCTXT_USE_PCTXT (1u << 1)\n-#endif\n-\n@@ -153,1 +140,1 @@\n-XMLPUBFUN xmlNotationPtr XMLCALL\n+XMLPUBFUN xmlNotationPtr\n@@ -160,1 +147,1 @@\n-XMLPUBFUN xmlNotationTablePtr XMLCALL\n+XMLPUBFUN xmlNotationTablePtr\n@@ -163,1 +150,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -166,1 +153,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -169,1 +156,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -176,1 +163,1 @@\n-XMLPUBFUN xmlElementContentPtr XMLCALL\n+XMLPUBFUN xmlElementContentPtr\n@@ -179,1 +166,1 @@\n-XMLPUBFUN xmlElementContentPtr XMLCALL\n+XMLPUBFUN xmlElementContentPtr\n@@ -181,1 +168,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -184,1 +171,1 @@\n-XMLPUBFUN xmlElementContentPtr XMLCALL\n+XMLPUBFUN xmlElementContentPtr\n@@ -188,1 +175,1 @@\n-XMLPUBFUN xmlElementContentPtr XMLCALL\n+XMLPUBFUN xmlElementContentPtr\n@@ -191,1 +178,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -194,1 +181,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -201,1 +188,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -209,1 +196,1 @@\n-XMLPUBFUN xmlElementPtr XMLCALL\n+XMLPUBFUN xmlElementPtr\n@@ -216,1 +203,1 @@\n-XMLPUBFUN xmlElementTablePtr XMLCALL\n+XMLPUBFUN xmlElementTablePtr\n@@ -219,1 +206,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -222,1 +209,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -225,1 +212,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -231,1 +218,1 @@\n-XMLPUBFUN xmlEnumerationPtr XMLCALL\n+XMLPUBFUN xmlEnumerationPtr\n@@ -233,1 +220,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -236,1 +223,1 @@\n-XMLPUBFUN xmlEnumerationPtr XMLCALL\n+XMLPUBFUN xmlEnumerationPtr\n@@ -241,1 +228,1 @@\n-XMLPUBFUN xmlAttributePtr XMLCALL\n+XMLPUBFUN xmlAttributePtr\n@@ -252,1 +239,1 @@\n-XMLPUBFUN xmlAttributeTablePtr XMLCALL\n+XMLPUBFUN xmlAttributeTablePtr\n@@ -255,1 +242,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -258,1 +245,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -261,1 +248,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -267,1 +254,1 @@\n-XMLPUBFUN xmlIDPtr XMLCALL\n+XMLPUBFUN xmlIDPtr\n@@ -272,1 +259,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -274,1 +261,1 @@\n-XMLPUBFUN xmlAttrPtr XMLCALL\n+XMLPUBFUN xmlAttrPtr\n@@ -277,1 +264,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -281,1 +268,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -287,1 +274,1 @@\n-XMLPUBFUN xmlRefPtr XMLCALL\n+XMLPUBFUN xmlRefPtr\n@@ -293,1 +280,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -296,1 +283,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -301,1 +288,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -305,1 +292,1 @@\n-XMLPUBFUN xmlListPtr XMLCALL\n+XMLPUBFUN xmlListPtr\n@@ -314,1 +301,1 @@\n-XMLPUBFUN xmlValidCtxtPtr XMLCALL\n+XMLPUBFUN xmlValidCtxtPtr\n@@ -316,1 +303,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -319,1 +306,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -322,1 +309,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -326,1 +313,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -331,1 +318,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -337,1 +324,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -341,1 +328,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -344,1 +331,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -348,1 +335,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -352,1 +339,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -355,1 +342,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -358,1 +345,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -362,1 +349,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -366,1 +353,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -372,1 +359,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -379,1 +366,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -385,1 +372,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -391,1 +378,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -394,1 +381,1 @@\n-XMLPUBFUN xmlAttributePtr XMLCALL\n+XMLPUBFUN xmlAttributePtr\n@@ -398,1 +385,1 @@\n-XMLPUBFUN xmlAttributePtr XMLCALL\n+XMLPUBFUN xmlAttributePtr\n@@ -403,1 +390,1 @@\n-XMLPUBFUN xmlNotationPtr XMLCALL\n+XMLPUBFUN xmlNotationPtr\n@@ -406,1 +393,1 @@\n-XMLPUBFUN xmlElementPtr XMLCALL\n+XMLPUBFUN xmlElementPtr\n@@ -410,1 +397,1 @@\n-XMLPUBFUN xmlElementPtr XMLCALL\n+XMLPUBFUN xmlElementPtr\n@@ -416,1 +403,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -422,1 +409,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -427,1 +414,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -429,1 +416,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -431,1 +418,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -433,1 +420,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -440,1 +427,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -444,1 +431,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -449,1 +436,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -453,1 +440,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/valid.h","additions":74,"deletions":87,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -94,1 +94,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -97,1 +97,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -101,1 +101,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -105,1 +105,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -107,1 +107,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -113,1 +113,1 @@\n-XMLPUBFUN xmlXIncludeCtxtPtr XMLCALL\n+XMLPUBFUN xmlXIncludeCtxtPtr\n@@ -115,1 +115,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -118,1 +118,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -120,1 +120,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xinclude.h","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-XMLPUBFUN xlinkNodeDetectFunc XMLCALL\n+XMLPUBFUN xlinkNodeDetectFunc\n@@ -165,1 +165,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -171,1 +171,1 @@\n-XMLPUBFUN xlinkHandlerPtr XMLCALL\n+XMLPUBFUN xlinkHandlerPtr\n@@ -173,1 +173,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -179,1 +179,1 @@\n-XMLPUBFUN xlinkType XMLCALL\n+XMLPUBFUN xlinkType\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xlink.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -15,0 +15,4 @@\n+#include <libxml\/encoding.h>\n+#define XML_TREE_INTERNALS\n+#include <libxml\/tree.h>\n+#undef XML_TREE_INTERNALS\n@@ -34,1 +38,1 @@\n-typedef int (XMLCALL *xmlInputMatchCallback) (char const *filename);\n+typedef int (*xmlInputMatchCallback) (char const *filename);\n@@ -43,1 +47,1 @@\n-typedef void * (XMLCALL *xmlInputOpenCallback) (char const *filename);\n+typedef void * (*xmlInputOpenCallback) (char const *filename);\n@@ -54,1 +58,1 @@\n-typedef int (XMLCALL *xmlInputReadCallback) (void * context, char * buffer, int len);\n+typedef int (*xmlInputReadCallback) (void * context, char * buffer, int len);\n@@ -63,1 +67,1 @@\n-typedef int (XMLCALL *xmlInputCloseCallback) (void * context);\n+typedef int (*xmlInputCloseCallback) (void * context);\n@@ -80,1 +84,1 @@\n-typedef int (XMLCALL *xmlOutputMatchCallback) (char const *filename);\n+typedef int (*xmlOutputMatchCallback) (char const *filename);\n@@ -89,1 +93,1 @@\n-typedef void * (XMLCALL *xmlOutputOpenCallback) (char const *filename);\n+typedef void * (*xmlOutputOpenCallback) (char const *filename);\n@@ -100,1 +104,1 @@\n-typedef int (XMLCALL *xmlOutputWriteCallback) (void * context, const char * buffer,\n+typedef int (*xmlOutputWriteCallback) (void * context, const char * buffer,\n@@ -110,1 +114,1 @@\n-typedef int (XMLCALL *xmlOutputCloseCallback) (void * context);\n+typedef int (*xmlOutputCloseCallback) (void * context);\n@@ -113,3 +117,13 @@\n-#ifdef __cplusplus\n-}\n-#endif\n+\/**\n+ * xmlParserInputBufferCreateFilenameFunc:\n+ * @URI: the URI to read from\n+ * @enc: the requested source encoding\n+ *\n+ * Signature for the function doing the lookup for a suitable input method\n+ * corresponding to an URI.\n+ *\n+ * Returns the new xmlParserInputBufferPtr in case of success or NULL if no\n+ *         method was found.\n+ *\/\n+typedef xmlParserInputBufferPtr\n+(*xmlParserInputBufferCreateFilenameFunc)(const char *URI, xmlCharEncoding enc);\n@@ -117,4 +131,14 @@\n-#include <libxml\/globals.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/encoding.h>\n+\/**\n+ * xmlOutputBufferCreateFilenameFunc:\n+ * @URI: the URI to write to\n+ * @enc: the requested target encoding\n+ *\n+ * Signature for the function doing the lookup for a suitable output method\n+ * corresponding to an URI.\n+ *\n+ * Returns the new xmlOutputBufferPtr in case of success or NULL if no\n+ *         method was found.\n+ *\/\n+typedef xmlOutputBufferPtr\n+(*xmlOutputBufferCreateFilenameFunc)(const char *URI,\n+        xmlCharEncodingHandlerPtr encoder, int compression);\n@@ -122,3 +146,0 @@\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n@@ -155,0 +176,19 @@\n+\/** DOC_DISABLE *\/\n+#define XML_GLOBALS_IO \\\n+  XML_OP(xmlParserInputBufferCreateFilenameValue, \\\n+           xmlParserInputBufferCreateFilenameFunc, XML_DEPRECATED) \\\n+  XML_OP(xmlOutputBufferCreateFilenameValue, \\\n+           xmlOutputBufferCreateFilenameFunc, XML_DEPRECATED)\n+\n+#define XML_OP XML_DECLARE_GLOBAL\n+XML_GLOBALS_IO\n+#undef XML_OP\n+\n+#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+  #define xmlParserInputBufferCreateFilenameValue \\\n+    XML_GLOBAL_MACRO(xmlParserInputBufferCreateFilenameValue)\n+  #define xmlOutputBufferCreateFilenameValue \\\n+    XML_GLOBAL_MACRO(xmlOutputBufferCreateFilenameValue)\n+#endif\n+\/** DOC_ENABLE *\/\n+\n@@ -158,1 +198,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -161,1 +201,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -164,1 +204,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -166,1 +206,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -169,1 +209,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -172,1 +212,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -175,1 +215,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -178,1 +218,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -181,1 +221,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -184,1 +224,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -189,1 +229,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -192,1 +232,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -195,1 +235,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -199,1 +239,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -201,1 +241,1 @@\n-XMLPUBFUN char * XMLCALL\n+XMLPUBFUN char *\n@@ -204,1 +244,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -218,1 +258,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -220,1 +260,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -222,1 +262,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -224,1 +264,1 @@\n-XMLPUBFUN xmlOutputBufferPtr XMLCALL\n+XMLPUBFUN xmlOutputBufferPtr\n@@ -227,1 +267,1 @@\n-XMLPUBFUN xmlOutputBufferPtr XMLCALL\n+XMLPUBFUN xmlOutputBufferPtr\n@@ -232,1 +272,1 @@\n-XMLPUBFUN xmlOutputBufferPtr XMLCALL\n+XMLPUBFUN xmlOutputBufferPtr\n@@ -236,1 +276,1 @@\n-XMLPUBFUN xmlOutputBufferPtr XMLCALL\n+XMLPUBFUN xmlOutputBufferPtr\n@@ -240,1 +280,1 @@\n-XMLPUBFUN xmlOutputBufferPtr XMLCALL\n+XMLPUBFUN xmlOutputBufferPtr\n@@ -244,1 +284,1 @@\n-XMLPUBFUN xmlOutputBufferPtr XMLCALL\n+XMLPUBFUN xmlOutputBufferPtr\n@@ -251,1 +291,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -253,1 +293,1 @@\n-XMLPUBFUN size_t XMLCALL\n+XMLPUBFUN size_t\n@@ -256,1 +296,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -260,1 +300,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -263,1 +303,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -268,1 +308,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -270,1 +310,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -273,1 +313,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -286,1 +326,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -292,1 +332,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -299,1 +339,1 @@\n-XMLPUBFUN xmlParserInputPtr XMLCALL\n+XMLPUBFUN xmlParserInputPtr\n@@ -308,1 +348,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -311,1 +351,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -316,1 +356,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -318,1 +358,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -320,1 +360,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -324,1 +364,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -331,1 +371,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -333,1 +373,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -336,1 +376,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -340,1 +380,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -344,1 +384,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -351,2 +391,2 @@\n-#ifdef LIBXML_FTP_ENABLED\n-XMLPUBFUN int XMLCALL\n+#if defined(LIBXML_FTP_ENABLED)\n+XMLPUBFUN int\n@@ -354,1 +394,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -356,1 +396,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -360,1 +400,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -362,1 +402,14 @@\n-#endif \/* LIBXML_FTP_ENABLED *\/\n+#endif \/* defined(LIBXML_FTP_ENABLED) *\/\n+\n+XMLPUBFUN xmlParserInputBufferCreateFilenameFunc\n+        xmlParserInputBufferCreateFilenameDefault(\n+                xmlParserInputBufferCreateFilenameFunc func);\n+XMLPUBFUN xmlOutputBufferCreateFilenameFunc\n+        xmlOutputBufferCreateFilenameDefault(\n+                xmlOutputBufferCreateFilenameFunc func);\n+XMLPUBFUN xmlOutputBufferCreateFilenameFunc\n+        xmlThrDefOutputBufferCreateFilenameDefault(\n+                xmlOutputBufferCreateFilenameFunc func);\n+XMLPUBFUN xmlParserInputBufferCreateFilenameFunc\n+        xmlThrDefParserInputBufferCreateFilenameDefault(\n+                xmlParserInputBufferCreateFilenameFunc func);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlIO.h","additions":124,"deletions":71,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -14,1 +14,0 @@\n-#include <libxml\/tree.h>\n@@ -18,1 +17,2 @@\n-#include <libxml\/xmlregexp.h>\n+\n+#include <libxml\/xmlstring.h>\n@@ -43,1 +43,1 @@\n-XMLPUBFUN xmlAutomataPtr XMLCALL\n+XMLPUBFUN xmlAutomataPtr\n@@ -45,1 +45,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -48,1 +48,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -50,1 +50,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -53,1 +53,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -55,1 +55,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -61,1 +61,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -68,1 +68,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -76,1 +76,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -84,1 +84,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -93,1 +93,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -101,1 +101,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -110,1 +110,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -115,1 +115,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -119,1 +119,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -124,1 +124,1 @@\n-XMLPUBFUN xmlAutomataStatePtr XMLCALL\n+XMLPUBFUN xmlAutomataStatePtr\n@@ -129,1 +129,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -134,1 +134,1 @@\n-XMLPUBFUN xmlRegexpPtr XMLCALL\n+XMLPUBFUN struct _xmlRegexp *\n@@ -136,1 +136,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlautomata.h","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -10,2 +10,0 @@\n-#include <libxml\/parser.h>\n-\n@@ -15,0 +13,2 @@\n+#include <libxml\/xmlversion.h>\n+\n@@ -213,0 +213,1 @@\n+    XML_WAR_ENCODING_MISMATCH, \/* 113 *\/\n@@ -847,1 +848,1 @@\n-typedef void (XMLCDECL *xmlGenericErrorFunc) (void *ctx,\n+typedef void (*xmlGenericErrorFunc) (void *ctx,\n@@ -858,1 +859,22 @@\n-typedef void (XMLCALL *xmlStructuredErrorFunc) (void *userData, xmlErrorPtr error);\n+typedef void (*xmlStructuredErrorFunc) (void *userData, const xmlError *error);\n+\n+\/** DOC_DISABLE *\/\n+#define XML_GLOBALS_ERROR \\\n+  XML_OP(xmlLastError, xmlError, XML_DEPRECATED) \\\n+  XML_OP(xmlGenericError, xmlGenericErrorFunc, XML_NO_ATTR) \\\n+  XML_OP(xmlGenericErrorContext, void *, XML_NO_ATTR) \\\n+  XML_OP(xmlStructuredError, xmlStructuredErrorFunc, XML_NO_ATTR) \\\n+  XML_OP(xmlStructuredErrorContext, void *, XML_NO_ATTR)\n+\n+#define XML_OP XML_DECLARE_GLOBAL\n+XML_GLOBALS_ERROR\n+#undef XML_OP\n+\n+#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)\n+  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)\n+  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)\n+  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)\n+  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)\n+#endif\n+\/** DOC_ENABLE *\/\n@@ -864,1 +886,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -867,1 +889,5 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n+    xmlThrDefSetGenericErrorFunc(void *ctx,\n+                                 xmlGenericErrorFunc handler);\n+XML_DEPRECATED\n+XMLPUBFUN void\n@@ -870,1 +896,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -873,0 +899,3 @@\n+XMLPUBFUN void\n+    xmlThrDefSetStructuredErrorFunc(void *ctx,\n+                                 xmlStructuredErrorFunc handler);\n@@ -877,1 +906,1 @@\n-XMLPUBFUN void XMLCDECL\n+XMLPUBFUN void\n@@ -881,1 +910,1 @@\n-XMLPUBFUN void XMLCDECL\n+XMLPUBFUN void\n@@ -885,1 +914,1 @@\n-XMLPUBFUN void XMLCDECL\n+XMLPUBFUN void\n@@ -889,1 +918,1 @@\n-XMLPUBFUN void XMLCDECL\n+XMLPUBFUN void\n@@ -893,4 +922,5 @@\n-XMLPUBFUN void XMLCALL\n-    xmlParserPrintFileInfo      (xmlParserInputPtr input);\n-XMLPUBFUN void XMLCALL\n-    xmlParserPrintFileContext   (xmlParserInputPtr input);\n+struct _xmlParserInput;\n+XMLPUBFUN void\n+    xmlParserPrintFileInfo      (struct _xmlParserInput *input);\n+XMLPUBFUN void\n+    xmlParserPrintFileContext   (struct _xmlParserInput *input);\n@@ -901,1 +931,1 @@\n-XMLPUBFUN xmlErrorPtr XMLCALL\n+XMLPUBFUN const xmlError *\n@@ -903,1 +933,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -905,1 +935,1 @@\n-XMLPUBFUN xmlErrorPtr XMLCALL\n+XMLPUBFUN const xmlError *\n@@ -907,1 +937,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -909,1 +939,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -911,2 +941,2 @@\n-XMLPUBFUN int XMLCALL\n-    xmlCopyError                (xmlErrorPtr from,\n+XMLPUBFUN int\n+    xmlCopyError                (const xmlError *from,\n@@ -915,29 +945,0 @@\n-#ifdef IN_LIBXML\n-\/*\n- * Internal callback reporting routine\n- *\/\n-XMLPUBFUN void XMLCALL\n-    __xmlRaiseError             (xmlStructuredErrorFunc schannel,\n-                                 xmlGenericErrorFunc channel,\n-                                 void *data,\n-                                 void *ctx,\n-                                 void *node,\n-                                 int domain,\n-                                 int code,\n-                                 xmlErrorLevel level,\n-                                 const char *file,\n-                                 int line,\n-                                 const char *str1,\n-                                 const char *str2,\n-                                 const char *str3,\n-                                 int int1,\n-                                 int col,\n-                                 const char *msg,\n-                                 ...) LIBXML_ATTR_FORMAT(16,17);\n-XMLPUBFUN void XMLCALL\n-    __xmlSimpleError            (int domain,\n-                                 int code,\n-                                 xmlNodePtr node,\n-                                 const char *msg,\n-                                 const char *extra) LIBXML_ATTR_FORMAT(4,0);\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlerror.h","additions":52,"deletions":51,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -11,1 +11,0 @@\n-#if defined(_WIN32) || defined(__CYGWIN__)\n@@ -13,17 +12,8 @@\n-\n-#ifdef LIBXML_STATIC\n-  #define XMLPUBLIC\n-#elif defined(IN_LIBXML)\n-  #define XMLPUBLIC __declspec(dllexport)\n-#else\n-  #define XMLPUBLIC __declspec(dllimport)\n-#endif\n-\n-#if defined(LIBXML_FASTCALL)\n-  #define XMLCALL __fastcall\n-#else\n-  #define XMLCALL __cdecl\n-#endif\n-#define XMLCDECL __cdecl\n-\n-\/** DOC_ENABLE *\/\n+#if defined(_WIN32) || defined(__CYGWIN__)\n+  #ifdef LIBXML_STATIC\n+    #define XMLPUBLIC\n+  #elif defined(IN_LIBXML)\n+    #define XMLPUBLIC __declspec(dllexport)\n+  #else\n+    #define XMLPUBLIC __declspec(dllimport)\n+  #endif\n@@ -31,23 +21,1 @@\n-\n-\/**\n- * XMLPUBLIC:\n- *\n- * Macro which declares a public symbol\n- *\/\n-#define XMLPUBLIC\n-\n-\/**\n- * XMLCALL:\n- *\n- * Macro which declares the calling convention for exported functions\n- *\/\n-#define XMLCALL\n-\n-\/**\n- * XMLCDECL:\n- *\n- * Macro which declares the calling convention for exported functions that\n- * use '...'.\n- *\/\n-#define XMLCDECL\n-\n+  #define XMLPUBLIC\n@@ -55,0 +23,1 @@\n+\/** DOC_ENABLE *\/\n@@ -70,0 +39,1 @@\n+\/** DOC_DISABLE *\/\n@@ -71,0 +41,2 @@\n+#define XMLCALL\n+#define XMLCDECL\n@@ -74,0 +46,1 @@\n+\/** DOC_ENABLE *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlexports.h","additions":14,"deletions":41,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -18,26 +18,0 @@\n-\/**\n- * DEBUG_MEMORY:\n- *\n- * DEBUG_MEMORY replaces the allocator with a collect and debug\n- * shell to the libc allocator.\n- * DEBUG_MEMORY should only be activated when debugging\n- * libxml i.e. if libxml has been configured with --with-debug-mem too.\n- *\/\n-\/* #define DEBUG_MEMORY_FREED *\/\n-\/* #define DEBUG_MEMORY_LOCATION *\/\n-\n-#ifdef DEBUG\n-#ifndef DEBUG_MEMORY\n-#define DEBUG_MEMORY\n-#endif\n-#endif\n-\n-\/**\n- * DEBUG_MEMORY_LOCATION:\n- *\n- * DEBUG_MEMORY_LOCATION should be activated only when debugging\n- * libxml i.e. if libxml has been configured with --with-debug-mem too.\n- *\/\n-#ifdef DEBUG_MEMORY_LOCATION\n-#endif\n-\n@@ -57,1 +31,1 @@\n-typedef void (XMLCALL *xmlFreeFunc)(void *mem);\n+typedef void (*xmlFreeFunc)(void *mem);\n@@ -66,1 +40,1 @@\n-typedef void *(LIBXML_ATTR_ALLOC_SIZE(1) XMLCALL *xmlMallocFunc)(size_t size);\n+typedef void *(LIBXML_ATTR_ALLOC_SIZE(1) *xmlMallocFunc)(size_t size);\n@@ -77,1 +51,1 @@\n-typedef void *(XMLCALL *xmlReallocFunc)(void *mem, size_t size);\n+typedef void *(*xmlReallocFunc)(void *mem, size_t size);\n@@ -87,1 +61,1 @@\n-typedef char *(XMLCALL *xmlStrdupFunc)(const char *str);\n+typedef char *(*xmlStrdupFunc)(const char *str);\n@@ -90,7 +64,35 @@\n- * The 4 interfaces used for all memory handling within libxml.\n-LIBXML_DLL_IMPORT xmlFreeFunc xmlFree;\n-LIBXML_DLL_IMPORT xmlMallocFunc xmlMalloc;\n-LIBXML_DLL_IMPORT xmlMallocFunc xmlMallocAtomic;\n-LIBXML_DLL_IMPORT xmlReallocFunc xmlRealloc;\n-LIBXML_DLL_IMPORT xmlStrdupFunc xmlMemStrdup;\n- *\/\n+ * In general the memory allocation entry points are not kept\n+ * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED\n+ *    - xmlMalloc\n+ *    - xmlMallocAtomic\n+ *    - xmlRealloc\n+ *    - xmlMemStrdup\n+ *    - xmlFree\n+ *\/\n+\/** DOC_DISABLE *\/\n+#ifdef LIBXML_THREAD_ALLOC_ENABLED\n+  #define XML_GLOBALS_ALLOC \\\n+    XML_OP(xmlMalloc, xmlMallocFunc, XML_NO_ATTR) \\\n+    XML_OP(xmlMallocAtomic, xmlMallocFunc, XML_NO_ATTR) \\\n+    XML_OP(xmlRealloc, xmlReallocFunc, XML_NO_ATTR) \\\n+    XML_OP(xmlFree, xmlFreeFunc, XML_NO_ATTR) \\\n+    XML_OP(xmlMemStrdup, xmlStrdupFunc, XML_NO_ATTR)\n+  #define XML_OP XML_DECLARE_GLOBAL\n+    XML_GLOBALS_ALLOC\n+  #undef XML_OP\n+  #if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+    #define xmlMalloc XML_GLOBAL_MACRO(xmlMalloc)\n+    #define xmlMallocAtomic XML_GLOBAL_MACRO(xmlMallocAtomic)\n+    #define xmlRealloc XML_GLOBAL_MACRO(xmlRealloc)\n+    #define xmlFree XML_GLOBAL_MACRO(xmlFree)\n+    #define xmlMemStrdup XML_GLOBAL_MACRO(xmlMemStrdup)\n+  #endif\n+#else\n+  #define XML_GLOBALS_ALLOC\n+\/** DOC_ENABLE *\/\n+  XMLPUBVAR xmlMallocFunc xmlMalloc;\n+  XMLPUBVAR xmlMallocFunc xmlMallocAtomic;\n+  XMLPUBVAR xmlReallocFunc xmlRealloc;\n+  XMLPUBVAR xmlFreeFunc xmlFree;\n+  XMLPUBVAR xmlStrdupFunc xmlMemStrdup;\n+#endif\n@@ -103,1 +105,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -108,1 +110,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -113,1 +115,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -119,1 +121,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -130,1 +132,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -137,1 +139,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -142,1 +144,3 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN size_t\n+        xmlMemSize      (void *ptr);\n+XMLPUBFUN int\n@@ -144,1 +148,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -146,1 +150,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -148,1 +152,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -150,1 +154,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -152,1 +156,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -154,1 +158,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -156,1 +160,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -158,1 +162,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -160,1 +164,1 @@\n-XMLPUBFUN char * XMLCALL\n+XMLPUBFUN char *\n@@ -162,1 +166,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -164,1 +168,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -166,1 +170,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -168,1 +172,1 @@\n-XMLPUBFUN char * XMLCALL\n+XMLPUBFUN char *\n@@ -172,0 +176,1 @@\n+\/** DOC_DISABLE *\/\n@@ -213,0 +218,1 @@\n+\/** DOC_ENABLE *\/\n@@ -218,7 +224,0 @@\n-#ifndef __XML_GLOBALS_H\n-#ifndef __XML_THREADS_H__\n-#include <libxml\/threads.h>\n-#include <libxml\/globals.h>\n-#endif\n-#endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlmemory.h","additions":63,"deletions":64,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-XMLPUBFUN xmlModulePtr XMLCALL xmlModuleOpen    (const char *filename,\n+XMLPUBFUN xmlModulePtr xmlModuleOpen    (const char *filename,\n@@ -43,1 +43,1 @@\n-XMLPUBFUN int XMLCALL xmlModuleSymbol           (xmlModulePtr module,\n+XMLPUBFUN int xmlModuleSymbol           (xmlModulePtr module,\n@@ -47,1 +47,1 @@\n-XMLPUBFUN int XMLCALL xmlModuleClose            (xmlModulePtr module);\n+XMLPUBFUN int xmlModuleClose            (xmlModulePtr module);\n@@ -49,1 +49,1 @@\n-XMLPUBFUN int XMLCALL xmlModuleFree             (xmlModulePtr module);\n+XMLPUBFUN int xmlModuleFree             (xmlModulePtr module);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlmodule.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+#include <libxml\/xmlerror.h>\n@@ -20,0 +21,2 @@\n+\/* for compatibility *\/\n+#include <libxml\/parser.h>\n@@ -111,1 +114,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -114,1 +117,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -117,1 +120,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -120,1 +123,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -124,0 +127,3 @@\n+XMLPUBFUN void\n+            xmlTextReaderSetMaxAmplification(xmlTextReaderPtr reader,\n+                   unsigned maxAmpl);\n@@ -128,1 +134,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -132,1 +138,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -135,1 +141,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -139,1 +145,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -141,1 +147,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -147,1 +153,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -149,1 +155,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -151,1 +157,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -153,1 +159,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -155,1 +161,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -157,1 +163,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -159,1 +165,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -161,1 +167,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -163,1 +169,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -165,1 +171,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -168,1 +174,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -170,1 +176,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -172,1 +178,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -174,1 +180,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -176,1 +182,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -178,1 +184,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -180,1 +186,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -183,1 +189,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -190,1 +196,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -192,1 +198,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -194,1 +200,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -196,1 +202,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -198,1 +204,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -200,1 +206,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -202,1 +208,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -208,1 +214,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -210,1 +216,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -213,1 +219,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -216,1 +222,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -220,1 +226,1 @@\n-XMLPUBFUN xmlParserInputBufferPtr XMLCALL\n+XMLPUBFUN xmlParserInputBufferPtr\n@@ -222,1 +228,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -225,1 +231,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -228,1 +234,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -231,1 +237,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -235,1 +241,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -237,1 +243,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -239,1 +245,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -241,1 +247,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -243,1 +249,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -249,1 +255,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -253,1 +259,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -256,1 +262,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -259,1 +265,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -262,1 +268,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -265,1 +271,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -268,1 +274,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -273,1 +279,1 @@\n-XMLPUBFUN xmlDocPtr XMLCALL\n+XMLPUBFUN xmlDocPtr\n@@ -275,1 +281,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -277,1 +283,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -279,1 +285,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -281,1 +287,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -284,1 +290,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -287,1 +293,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -292,1 +298,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -295,1 +301,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -298,1 +304,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -302,1 +308,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -306,1 +312,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -308,1 +314,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -315,1 +321,1 @@\n-XMLPUBFUN long XMLCALL\n+XMLPUBFUN long\n@@ -321,1 +327,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -323,1 +329,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -328,1 +334,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -332,1 +338,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -338,1 +344,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -343,1 +349,1 @@\n-XMLPUBFUN xmlTextReaderPtr XMLCALL\n+XMLPUBFUN xmlTextReaderPtr\n@@ -351,1 +357,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -354,1 +360,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -360,1 +366,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -365,1 +371,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -372,1 +378,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -378,1 +384,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -400,1 +406,1 @@\n-typedef void (XMLCALL *xmlTextReaderErrorFunc)(void *arg,\n+typedef void (*xmlTextReaderErrorFunc)(void *arg,\n@@ -404,1 +410,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -406,1 +412,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -408,1 +414,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -412,1 +418,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -416,1 +422,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlreader.h","additions":93,"deletions":87,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+#include <stdio.h>\n@@ -15,0 +16,1 @@\n+#include <libxml\/xmlstring.h>\n@@ -39,9 +41,0 @@\n-#ifdef __cplusplus\n-}\n-#endif\n-#include <libxml\/tree.h>\n-#include <libxml\/dict.h>\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n@@ -51,1 +44,1 @@\n-XMLPUBFUN xmlRegexpPtr XMLCALL\n+XMLPUBFUN xmlRegexpPtr\n@@ -53,2 +46,2 @@\n-XMLPUBFUN void XMLCALL                   xmlRegFreeRegexp(xmlRegexpPtr regexp);\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN void                   xmlRegFreeRegexp(xmlRegexpPtr regexp);\n+XMLPUBFUN int\n@@ -57,1 +50,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -60,1 +53,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -80,1 +73,1 @@\n-XMLPUBFUN xmlRegExecCtxtPtr XMLCALL\n+XMLPUBFUN xmlRegExecCtxtPtr\n@@ -84,1 +77,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -86,1 +79,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -90,1 +83,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -96,1 +89,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -102,1 +95,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -119,1 +112,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -121,1 +114,1 @@\n-XMLPUBFUN xmlExpCtxtPtr XMLCALL\n+XMLPUBFUN xmlExpCtxtPtr\n@@ -125,1 +118,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -127,1 +120,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -153,1 +146,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -156,1 +149,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -162,1 +155,1 @@\n-XMLPUBFUN xmlExpNodePtr XMLCALL\n+XMLPUBFUN xmlExpNodePtr\n@@ -165,1 +158,1 @@\n-XMLPUBFUN xmlExpNodePtr XMLCALL\n+XMLPUBFUN xmlExpNodePtr\n@@ -169,1 +162,1 @@\n-XMLPUBFUN xmlExpNodePtr XMLCALL\n+XMLPUBFUN xmlExpNodePtr\n@@ -173,1 +166,1 @@\n-XMLPUBFUN xmlExpNodePtr XMLCALL\n+XMLPUBFUN xmlExpNodePtr\n@@ -177,1 +170,1 @@\n-XMLPUBFUN xmlExpNodePtr XMLCALL\n+XMLPUBFUN xmlExpNodePtr\n@@ -185,1 +178,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -187,1 +180,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -189,1 +182,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -194,1 +187,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -199,1 +192,1 @@\n-XMLPUBFUN xmlExpNodePtr XMLCALL\n+XMLPUBFUN xmlExpNodePtr\n@@ -204,1 +197,1 @@\n-XMLPUBFUN xmlExpNodePtr XMLCALL\n+XMLPUBFUN xmlExpNodePtr\n@@ -208,1 +201,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -212,1 +205,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlregexp.h","additions":32,"deletions":39,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-XMLPUBFUN xmlSaveCtxtPtr XMLCALL\n+XMLPUBFUN xmlSaveCtxtPtr\n@@ -48,1 +48,1 @@\n-XMLPUBFUN xmlSaveCtxtPtr XMLCALL\n+XMLPUBFUN xmlSaveCtxtPtr\n@@ -53,1 +53,1 @@\n-XMLPUBFUN xmlSaveCtxtPtr XMLCALL\n+XMLPUBFUN xmlSaveCtxtPtr\n@@ -58,1 +58,1 @@\n-XMLPUBFUN xmlSaveCtxtPtr XMLCALL\n+XMLPUBFUN xmlSaveCtxtPtr\n@@ -65,1 +65,1 @@\n-XMLPUBFUN long XMLCALL\n+XMLPUBFUN long\n@@ -68,1 +68,1 @@\n-XMLPUBFUN long XMLCALL\n+XMLPUBFUN long\n@@ -72,1 +72,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -74,1 +74,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -76,1 +76,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -79,1 +79,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -82,0 +82,8 @@\n+\n+XMLPUBFUN int\n+                xmlThrDefIndentTreeOutput(int v);\n+XMLPUBFUN const char *\n+                xmlThrDefTreeIndentString(const char * v);\n+XMLPUBFUN int\n+                xmlThrDefSaveNoEmptyTags(int v);\n+\n@@ -85,0 +93,1 @@\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlsave.h","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -19,0 +19,2 @@\n+#include <stdio.h>\n+#include <libxml\/encoding.h>\n@@ -20,0 +22,1 @@\n+#include <libxml\/xmlerror.h>\n@@ -95,1 +98,1 @@\n-typedef void (XMLCDECL *xmlSchemaValidityErrorFunc)\n+typedef void (*xmlSchemaValidityErrorFunc)\n@@ -106,1 +109,1 @@\n-typedef void (XMLCDECL *xmlSchemaValidityWarningFunc)\n+typedef void (*xmlSchemaValidityWarningFunc)\n@@ -131,1 +134,1 @@\n-typedef int (XMLCDECL *xmlSchemaValidityLocatorFunc) (void *ctx,\n+typedef int (*xmlSchemaValidityLocatorFunc) (void *ctx,\n@@ -137,1 +140,1 @@\n-XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchemaParserCtxtPtr\n@@ -139,1 +142,1 @@\n-XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchemaParserCtxtPtr\n@@ -142,1 +145,1 @@\n-XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchemaParserCtxtPtr\n@@ -144,1 +147,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -146,1 +149,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -151,1 +154,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -155,1 +158,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -160,1 +163,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -163,1 +166,1 @@\n-XMLPUBFUN xmlSchemaPtr XMLCALL\n+XMLPUBFUN xmlSchemaPtr\n@@ -165,1 +168,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -168,1 +171,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -175,1 +178,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -180,1 +183,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -184,1 +187,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -189,1 +192,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -192,1 +195,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -195,1 +198,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -198,1 +201,1 @@\n-XMLPUBFUN xmlSchemaValidCtxtPtr XMLCALL\n+XMLPUBFUN xmlSchemaValidCtxtPtr\n@@ -200,1 +203,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -202,1 +205,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -205,1 +208,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -208,1 +211,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -214,1 +217,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -219,1 +222,1 @@\n-XMLPUBFUN xmlParserCtxtPtr XMLCALL\n+XMLPUBFUN xmlParserCtxtPtr\n@@ -228,1 +231,1 @@\n-XMLPUBFUN xmlSchemaSAXPlugPtr XMLCALL\n+XMLPUBFUN xmlSchemaSAXPlugPtr\n@@ -232,1 +235,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -236,1 +239,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlschemas.h","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN int\n@@ -36,1 +36,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -38,1 +38,1 @@\n-XMLPUBFUN xmlSchemaTypePtr XMLCALL\n+XMLPUBFUN xmlSchemaTypePtr\n@@ -41,1 +41,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -45,1 +45,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -50,1 +50,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -55,1 +55,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -62,1 +62,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -64,1 +64,1 @@\n-XMLPUBFUN xmlSchemaFacetPtr XMLCALL\n+XMLPUBFUN xmlSchemaFacetPtr\n@@ -66,1 +66,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -71,1 +71,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -73,1 +73,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -76,1 +76,1 @@\n-XMLPUBFUN xmlSchemaTypePtr XMLCALL\n+XMLPUBFUN xmlSchemaTypePtr\n@@ -78,1 +78,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -83,1 +83,1 @@\n-XMLPUBFUN xmlSchemaTypePtr XMLCALL\n+XMLPUBFUN xmlSchemaTypePtr\n@@ -85,1 +85,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -88,1 +88,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -90,1 +90,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -92,1 +92,1 @@\n-XMLPUBFUN unsigned long  XMLCALL\n+XMLPUBFUN unsigned long\n@@ -94,1 +94,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -100,1 +100,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -107,1 +107,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -112,1 +112,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -115,1 +115,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -119,1 +119,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -122,1 +122,1 @@\n-XMLPUBFUN xmlSchemaValPtr XMLCALL\n+XMLPUBFUN xmlSchemaValPtr\n@@ -124,1 +124,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -126,1 +126,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -128,1 +128,1 @@\n-XMLPUBFUN xmlSchemaValPtr XMLCALL\n+XMLPUBFUN xmlSchemaValPtr\n@@ -131,1 +131,1 @@\n-XMLPUBFUN xmlSchemaValPtr XMLCALL\n+XMLPUBFUN xmlSchemaValPtr\n@@ -134,1 +134,1 @@\n-XMLPUBFUN xmlSchemaValPtr XMLCALL\n+XMLPUBFUN xmlSchemaValPtr\n@@ -137,1 +137,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -142,1 +142,1 @@\n-XMLPUBFUN xmlSchemaValPtr XMLCALL\n+XMLPUBFUN xmlSchemaValPtr\n@@ -144,1 +144,1 @@\n-XMLPUBFUN xmlSchemaValType XMLCALL\n+XMLPUBFUN xmlSchemaValType\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlschemastypes.h","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -42,1 +42,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -45,1 +45,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -48,1 +48,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -50,1 +50,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -54,1 +54,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -57,1 +57,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -60,1 +60,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -63,1 +63,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -66,1 +66,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -70,1 +70,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -73,1 +73,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -77,1 +77,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -80,1 +80,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -84,1 +84,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -86,1 +86,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -89,1 +89,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -93,1 +93,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -97,1 +97,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -102,1 +102,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -108,1 +108,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -111,1 +111,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -113,1 +113,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -116,1 +116,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -119,1 +119,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -122,1 +122,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -125,1 +125,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -129,1 +129,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -131,1 +131,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -133,1 +133,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlstring.h","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,128 +26,128 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsAegeanNumbers     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsAlphabeticPresentationForms       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsArabic    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsA  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsB  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsArmenian  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsArrows    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBasicLatin        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBengali   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBlockElements     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBopomofo  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBopomofoExtended  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBoxDrawing        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBraillePatterns   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsBuhid     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsByzantineMusicalSymbols   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibility  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityForms     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographs        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographsSupplement      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKRadicalsSupplement     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKSymbolsandPunctuation  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographs      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionA    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionB    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCherokee  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarks (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarksforSymbols       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCombiningHalfMarks        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCombiningMarksforSymbols  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsControlPictures   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCurrencySymbols   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCypriotSyllabary  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCyrillic  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCyrillicSupplement        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsDeseret   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsDevanagari        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsDingbats  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsEnclosedAlphanumerics     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsEnclosedCJKLettersandMonths       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsEthiopic  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGeneralPunctuation        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGeometricShapes   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGeorgian  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGothic    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGreek     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGreekExtended     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGreekandCoptic    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGujarati  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGurmukhi  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHalfwidthandFullwidthForms        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHangulCompatibilityJamo   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHangulJamo        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHangulSyllables   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHanunoo   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHebrew    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHighPrivateUseSurrogates  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHighSurrogates    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsHiragana  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsIPAExtensions     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsIdeographicDescriptionCharacters  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKanbun    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKangxiRadicals    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKannada   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKatakana  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKatakanaPhoneticExtensions        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKhmer     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKhmerSymbols      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLao       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLatin1Supplement  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedA    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedB    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedAdditional   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLetterlikeSymbols (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLimbu     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLinearBIdeograms  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLinearBSyllabary  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLowSurrogates     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMalayalam (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMathematicalAlphanumericSymbols   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMathematicalOperators     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsA (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsB (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbols      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbolsandArrows     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousTechnical    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMongolian (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMusicalSymbols    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMyanmar   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsNumberForms       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsOgham     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsOldItalic (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsOpticalCharacterRecognition       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsOriya     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsOsmanya   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsPhoneticExtensions        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsPrivateUse        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsPrivateUseArea    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsRunic     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsShavian   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSinhala   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSmallFormVariants (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSpacingModifierLetters    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSpecials  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSuperscriptsandSubscripts (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsA       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsB       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementalMathematicalOperators (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaA      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaB      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSyriac    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTagalog   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTagbanwa  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTags      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTaiLe     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTaiXuanJingSymbols        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTamil     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTelugu    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsThaana    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsThai      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTibetan   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsUgaritic  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsUnifiedCanadianAboriginalSyllabics        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectors        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectorsSupplement      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsYiRadicals        (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsYiSyllables       (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsYijingHexagramSymbols     (int code);\n+XMLPUBFUN int xmlUCSIsAegeanNumbers     (int code);\n+XMLPUBFUN int xmlUCSIsAlphabeticPresentationForms       (int code);\n+XMLPUBFUN int xmlUCSIsArabic    (int code);\n+XMLPUBFUN int xmlUCSIsArabicPresentationFormsA  (int code);\n+XMLPUBFUN int xmlUCSIsArabicPresentationFormsB  (int code);\n+XMLPUBFUN int xmlUCSIsArmenian  (int code);\n+XMLPUBFUN int xmlUCSIsArrows    (int code);\n+XMLPUBFUN int xmlUCSIsBasicLatin        (int code);\n+XMLPUBFUN int xmlUCSIsBengali   (int code);\n+XMLPUBFUN int xmlUCSIsBlockElements     (int code);\n+XMLPUBFUN int xmlUCSIsBopomofo  (int code);\n+XMLPUBFUN int xmlUCSIsBopomofoExtended  (int code);\n+XMLPUBFUN int xmlUCSIsBoxDrawing        (int code);\n+XMLPUBFUN int xmlUCSIsBraillePatterns   (int code);\n+XMLPUBFUN int xmlUCSIsBuhid     (int code);\n+XMLPUBFUN int xmlUCSIsByzantineMusicalSymbols   (int code);\n+XMLPUBFUN int xmlUCSIsCJKCompatibility  (int code);\n+XMLPUBFUN int xmlUCSIsCJKCompatibilityForms     (int code);\n+XMLPUBFUN int xmlUCSIsCJKCompatibilityIdeographs        (int code);\n+XMLPUBFUN int xmlUCSIsCJKCompatibilityIdeographsSupplement      (int code);\n+XMLPUBFUN int xmlUCSIsCJKRadicalsSupplement     (int code);\n+XMLPUBFUN int xmlUCSIsCJKSymbolsandPunctuation  (int code);\n+XMLPUBFUN int xmlUCSIsCJKUnifiedIdeographs      (int code);\n+XMLPUBFUN int xmlUCSIsCJKUnifiedIdeographsExtensionA    (int code);\n+XMLPUBFUN int xmlUCSIsCJKUnifiedIdeographsExtensionB    (int code);\n+XMLPUBFUN int xmlUCSIsCherokee  (int code);\n+XMLPUBFUN int xmlUCSIsCombiningDiacriticalMarks (int code);\n+XMLPUBFUN int xmlUCSIsCombiningDiacriticalMarksforSymbols       (int code);\n+XMLPUBFUN int xmlUCSIsCombiningHalfMarks        (int code);\n+XMLPUBFUN int xmlUCSIsCombiningMarksforSymbols  (int code);\n+XMLPUBFUN int xmlUCSIsControlPictures   (int code);\n+XMLPUBFUN int xmlUCSIsCurrencySymbols   (int code);\n+XMLPUBFUN int xmlUCSIsCypriotSyllabary  (int code);\n+XMLPUBFUN int xmlUCSIsCyrillic  (int code);\n+XMLPUBFUN int xmlUCSIsCyrillicSupplement        (int code);\n+XMLPUBFUN int xmlUCSIsDeseret   (int code);\n+XMLPUBFUN int xmlUCSIsDevanagari        (int code);\n+XMLPUBFUN int xmlUCSIsDingbats  (int code);\n+XMLPUBFUN int xmlUCSIsEnclosedAlphanumerics     (int code);\n+XMLPUBFUN int xmlUCSIsEnclosedCJKLettersandMonths       (int code);\n+XMLPUBFUN int xmlUCSIsEthiopic  (int code);\n+XMLPUBFUN int xmlUCSIsGeneralPunctuation        (int code);\n+XMLPUBFUN int xmlUCSIsGeometricShapes   (int code);\n+XMLPUBFUN int xmlUCSIsGeorgian  (int code);\n+XMLPUBFUN int xmlUCSIsGothic    (int code);\n+XMLPUBFUN int xmlUCSIsGreek     (int code);\n+XMLPUBFUN int xmlUCSIsGreekExtended     (int code);\n+XMLPUBFUN int xmlUCSIsGreekandCoptic    (int code);\n+XMLPUBFUN int xmlUCSIsGujarati  (int code);\n+XMLPUBFUN int xmlUCSIsGurmukhi  (int code);\n+XMLPUBFUN int xmlUCSIsHalfwidthandFullwidthForms        (int code);\n+XMLPUBFUN int xmlUCSIsHangulCompatibilityJamo   (int code);\n+XMLPUBFUN int xmlUCSIsHangulJamo        (int code);\n+XMLPUBFUN int xmlUCSIsHangulSyllables   (int code);\n+XMLPUBFUN int xmlUCSIsHanunoo   (int code);\n+XMLPUBFUN int xmlUCSIsHebrew    (int code);\n+XMLPUBFUN int xmlUCSIsHighPrivateUseSurrogates  (int code);\n+XMLPUBFUN int xmlUCSIsHighSurrogates    (int code);\n+XMLPUBFUN int xmlUCSIsHiragana  (int code);\n+XMLPUBFUN int xmlUCSIsIPAExtensions     (int code);\n+XMLPUBFUN int xmlUCSIsIdeographicDescriptionCharacters  (int code);\n+XMLPUBFUN int xmlUCSIsKanbun    (int code);\n+XMLPUBFUN int xmlUCSIsKangxiRadicals    (int code);\n+XMLPUBFUN int xmlUCSIsKannada   (int code);\n+XMLPUBFUN int xmlUCSIsKatakana  (int code);\n+XMLPUBFUN int xmlUCSIsKatakanaPhoneticExtensions        (int code);\n+XMLPUBFUN int xmlUCSIsKhmer     (int code);\n+XMLPUBFUN int xmlUCSIsKhmerSymbols      (int code);\n+XMLPUBFUN int xmlUCSIsLao       (int code);\n+XMLPUBFUN int xmlUCSIsLatin1Supplement  (int code);\n+XMLPUBFUN int xmlUCSIsLatinExtendedA    (int code);\n+XMLPUBFUN int xmlUCSIsLatinExtendedB    (int code);\n+XMLPUBFUN int xmlUCSIsLatinExtendedAdditional   (int code);\n+XMLPUBFUN int xmlUCSIsLetterlikeSymbols (int code);\n+XMLPUBFUN int xmlUCSIsLimbu     (int code);\n+XMLPUBFUN int xmlUCSIsLinearBIdeograms  (int code);\n+XMLPUBFUN int xmlUCSIsLinearBSyllabary  (int code);\n+XMLPUBFUN int xmlUCSIsLowSurrogates     (int code);\n+XMLPUBFUN int xmlUCSIsMalayalam (int code);\n+XMLPUBFUN int xmlUCSIsMathematicalAlphanumericSymbols   (int code);\n+XMLPUBFUN int xmlUCSIsMathematicalOperators     (int code);\n+XMLPUBFUN int xmlUCSIsMiscellaneousMathematicalSymbolsA (int code);\n+XMLPUBFUN int xmlUCSIsMiscellaneousMathematicalSymbolsB (int code);\n+XMLPUBFUN int xmlUCSIsMiscellaneousSymbols      (int code);\n+XMLPUBFUN int xmlUCSIsMiscellaneousSymbolsandArrows     (int code);\n+XMLPUBFUN int xmlUCSIsMiscellaneousTechnical    (int code);\n+XMLPUBFUN int xmlUCSIsMongolian (int code);\n+XMLPUBFUN int xmlUCSIsMusicalSymbols    (int code);\n+XMLPUBFUN int xmlUCSIsMyanmar   (int code);\n+XMLPUBFUN int xmlUCSIsNumberForms       (int code);\n+XMLPUBFUN int xmlUCSIsOgham     (int code);\n+XMLPUBFUN int xmlUCSIsOldItalic (int code);\n+XMLPUBFUN int xmlUCSIsOpticalCharacterRecognition       (int code);\n+XMLPUBFUN int xmlUCSIsOriya     (int code);\n+XMLPUBFUN int xmlUCSIsOsmanya   (int code);\n+XMLPUBFUN int xmlUCSIsPhoneticExtensions        (int code);\n+XMLPUBFUN int xmlUCSIsPrivateUse        (int code);\n+XMLPUBFUN int xmlUCSIsPrivateUseArea    (int code);\n+XMLPUBFUN int xmlUCSIsRunic     (int code);\n+XMLPUBFUN int xmlUCSIsShavian   (int code);\n+XMLPUBFUN int xmlUCSIsSinhala   (int code);\n+XMLPUBFUN int xmlUCSIsSmallFormVariants (int code);\n+XMLPUBFUN int xmlUCSIsSpacingModifierLetters    (int code);\n+XMLPUBFUN int xmlUCSIsSpecials  (int code);\n+XMLPUBFUN int xmlUCSIsSuperscriptsandSubscripts (int code);\n+XMLPUBFUN int xmlUCSIsSupplementalArrowsA       (int code);\n+XMLPUBFUN int xmlUCSIsSupplementalArrowsB       (int code);\n+XMLPUBFUN int xmlUCSIsSupplementalMathematicalOperators (int code);\n+XMLPUBFUN int xmlUCSIsSupplementaryPrivateUseAreaA      (int code);\n+XMLPUBFUN int xmlUCSIsSupplementaryPrivateUseAreaB      (int code);\n+XMLPUBFUN int xmlUCSIsSyriac    (int code);\n+XMLPUBFUN int xmlUCSIsTagalog   (int code);\n+XMLPUBFUN int xmlUCSIsTagbanwa  (int code);\n+XMLPUBFUN int xmlUCSIsTags      (int code);\n+XMLPUBFUN int xmlUCSIsTaiLe     (int code);\n+XMLPUBFUN int xmlUCSIsTaiXuanJingSymbols        (int code);\n+XMLPUBFUN int xmlUCSIsTamil     (int code);\n+XMLPUBFUN int xmlUCSIsTelugu    (int code);\n+XMLPUBFUN int xmlUCSIsThaana    (int code);\n+XMLPUBFUN int xmlUCSIsThai      (int code);\n+XMLPUBFUN int xmlUCSIsTibetan   (int code);\n+XMLPUBFUN int xmlUCSIsUgaritic  (int code);\n+XMLPUBFUN int xmlUCSIsUnifiedCanadianAboriginalSyllabics        (int code);\n+XMLPUBFUN int xmlUCSIsVariationSelectors        (int code);\n+XMLPUBFUN int xmlUCSIsVariationSelectorsSupplement      (int code);\n+XMLPUBFUN int xmlUCSIsYiRadicals        (int code);\n+XMLPUBFUN int xmlUCSIsYiSyllables       (int code);\n+XMLPUBFUN int xmlUCSIsYijingHexagramSymbols     (int code);\n@@ -155,1 +155,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsBlock     (int code, const char *block);\n+XMLPUBFUN int xmlUCSIsBlock     (int code, const char *block);\n@@ -157,36 +157,36 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCatC      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCc     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCf     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCo     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCs     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatL      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLl     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLm     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLo     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLt     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLu     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatM      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatMc     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatMe     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatMn     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatN      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatNd     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatNl     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatNo     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatP      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPc     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPd     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPe     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPf     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPi     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPo     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPs     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatS      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSc     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSk     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSm     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSo     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZ      (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZl     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZp     (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZs     (int code);\n+XMLPUBFUN int xmlUCSIsCatC      (int code);\n+XMLPUBFUN int xmlUCSIsCatCc     (int code);\n+XMLPUBFUN int xmlUCSIsCatCf     (int code);\n+XMLPUBFUN int xmlUCSIsCatCo     (int code);\n+XMLPUBFUN int xmlUCSIsCatCs     (int code);\n+XMLPUBFUN int xmlUCSIsCatL      (int code);\n+XMLPUBFUN int xmlUCSIsCatLl     (int code);\n+XMLPUBFUN int xmlUCSIsCatLm     (int code);\n+XMLPUBFUN int xmlUCSIsCatLo     (int code);\n+XMLPUBFUN int xmlUCSIsCatLt     (int code);\n+XMLPUBFUN int xmlUCSIsCatLu     (int code);\n+XMLPUBFUN int xmlUCSIsCatM      (int code);\n+XMLPUBFUN int xmlUCSIsCatMc     (int code);\n+XMLPUBFUN int xmlUCSIsCatMe     (int code);\n+XMLPUBFUN int xmlUCSIsCatMn     (int code);\n+XMLPUBFUN int xmlUCSIsCatN      (int code);\n+XMLPUBFUN int xmlUCSIsCatNd     (int code);\n+XMLPUBFUN int xmlUCSIsCatNl     (int code);\n+XMLPUBFUN int xmlUCSIsCatNo     (int code);\n+XMLPUBFUN int xmlUCSIsCatP      (int code);\n+XMLPUBFUN int xmlUCSIsCatPc     (int code);\n+XMLPUBFUN int xmlUCSIsCatPd     (int code);\n+XMLPUBFUN int xmlUCSIsCatPe     (int code);\n+XMLPUBFUN int xmlUCSIsCatPf     (int code);\n+XMLPUBFUN int xmlUCSIsCatPi     (int code);\n+XMLPUBFUN int xmlUCSIsCatPo     (int code);\n+XMLPUBFUN int xmlUCSIsCatPs     (int code);\n+XMLPUBFUN int xmlUCSIsCatS      (int code);\n+XMLPUBFUN int xmlUCSIsCatSc     (int code);\n+XMLPUBFUN int xmlUCSIsCatSk     (int code);\n+XMLPUBFUN int xmlUCSIsCatSm     (int code);\n+XMLPUBFUN int xmlUCSIsCatSo     (int code);\n+XMLPUBFUN int xmlUCSIsCatZ      (int code);\n+XMLPUBFUN int xmlUCSIsCatZl     (int code);\n+XMLPUBFUN int xmlUCSIsCatZp     (int code);\n+XMLPUBFUN int xmlUCSIsCatZs     (int code);\n@@ -194,1 +194,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCat       (int code, const char *cat);\n+XMLPUBFUN int xmlUCSIsCat       (int code, const char *cat);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlunicode.h","additions":166,"deletions":166,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-XMLPUBFUN void XMLCALL xmlCheckVersion(int version);\n+XMLPUBFUN void xmlCheckVersion(int version);\n@@ -316,1 +316,1 @@\n- * Whether the runtime debugging is configured in\n+ * Removed\n@@ -318,1 +318,1 @@\n-#if @WITH_RUN_DEBUG@\n+#if 0\n@@ -412,6 +412,1 @@\n-\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * Macro used to signal to GCC unused function parameters\n- *\/\n+\/** DOC_DISABLE *\/\n@@ -427,6 +422,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n-\n@@ -443,6 +432,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n-\n@@ -460,1 +443,1 @@\n-#  ifdef IN_LIBXML\n+#  if defined (IN_LIBXML) || (__GNUC__ * 100 + __GNUC_MINOR__ < 301)\n@@ -462,1 +445,0 @@\n-#  else\n@@ -464,0 +446,1 @@\n+#  else\n@@ -468,0 +451,18 @@\n+#if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 406)\n+  #if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 800)\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wcast-function-type\\\"\")\n+  #else\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\")\n+  #endif\n+  #define XML_POP_WARNINGS \\\n+    _Pragma(\"GCC diagnostic pop\")\n+#else\n+  #define XML_IGNORE_FPTR_CAST_WARNINGS\n+  #define XML_POP_WARNINGS\n+#endif\n+\n@@ -469,5 +470,0 @@\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * Macro used to signal to GCC unused function parameters\n- *\/\n@@ -475,5 +471,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n@@ -481,5 +472,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n@@ -487,6 +473,0 @@\n-\/**\n- * XML_DEPRECATED:\n- *\n- * Macro used to indicate that a function, variable, type or struct member\n- * is deprecated.\n- *\/\n@@ -494,1 +474,18 @@\n-#define XML_DEPRECATED\n+#  if defined (IN_LIBXML) || !defined (_MSC_VER)\n+#    define XML_DEPRECATED\n+\/* Available since Visual Studio 2005 *\/\n+#  elif defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_DEPRECATED __declspec(deprecated)\n+#  endif\n+#endif\n+#if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS __pragma(warning(push))\n+#else\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS\n+#endif\n+#ifndef XML_POP_WARNINGS\n+#  if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_POP_WARNINGS __pragma(warning(pop))\n+#  else\n+#    define XML_POP_WARNINGS\n+#  endif\n@@ -498,0 +495,11 @@\n+#define XML_NO_ATTR\n+\n+#ifdef LIBXML_THREAD_ENABLED\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBFUN type *__##name(void);\n+  #define XML_GLOBAL_MACRO(name) (*__##name())\n+#else\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBVAR type name;\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlversion.h.in","additions":53,"deletions":45,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    XMLPUBFUN xmlTextWriterPtr XMLCALL\n+    XMLPUBFUN xmlTextWriterPtr\n@@ -34,1 +34,1 @@\n-    XMLPUBFUN xmlTextWriterPtr XMLCALL\n+    XMLPUBFUN xmlTextWriterPtr\n@@ -36,1 +36,1 @@\n-    XMLPUBFUN xmlTextWriterPtr XMLCALL\n+    XMLPUBFUN xmlTextWriterPtr\n@@ -38,1 +38,1 @@\n-    XMLPUBFUN xmlTextWriterPtr XMLCALL\n+    XMLPUBFUN xmlTextWriterPtr\n@@ -40,1 +40,1 @@\n-    XMLPUBFUN xmlTextWriterPtr XMLCALL\n+    XMLPUBFUN xmlTextWriterPtr\n@@ -42,1 +42,1 @@\n-    XMLPUBFUN xmlTextWriterPtr XMLCALL\n+    XMLPUBFUN xmlTextWriterPtr\n@@ -45,1 +45,1 @@\n-    XMLPUBFUN void XMLCALL xmlFreeTextWriter(xmlTextWriterPtr writer);\n+    XMLPUBFUN void xmlFreeTextWriter(xmlTextWriterPtr writer);\n@@ -55,1 +55,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -60,1 +60,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndDocument(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterEndDocument(xmlTextWriterPtr\n@@ -66,1 +66,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterStartComment(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterStartComment(xmlTextWriterPtr\n@@ -68,2 +68,2 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndComment(xmlTextWriterPtr writer);\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int xmlTextWriterEndComment(xmlTextWriterPtr writer);\n+    XMLPUBFUN int\n@@ -73,1 +73,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -78,1 +78,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteComment(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteComment(xmlTextWriterPtr\n@@ -86,1 +86,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -89,1 +89,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterStartElementNS(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterStartElementNS(xmlTextWriterPtr\n@@ -96,2 +96,2 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndElement(xmlTextWriterPtr writer);\n-    XMLPUBFUN int XMLCALL xmlTextWriterFullEndElement(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterEndElement(xmlTextWriterPtr writer);\n+    XMLPUBFUN int xmlTextWriterFullEndElement(xmlTextWriterPtr\n@@ -103,1 +103,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -108,1 +108,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -114,1 +114,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteElement(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteElement(xmlTextWriterPtr\n@@ -119,1 +119,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -126,1 +126,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -134,1 +134,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteElementNS(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteElementNS(xmlTextWriterPtr\n@@ -147,1 +147,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -151,1 +151,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -155,1 +155,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -158,1 +158,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -161,1 +161,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteFormatString(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteFormatString(xmlTextWriterPtr\n@@ -166,1 +166,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteVFormatString(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteVFormatString(xmlTextWriterPtr\n@@ -172,1 +172,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteString(xmlTextWriterPtr writer,\n+    XMLPUBFUN int xmlTextWriterWriteString(xmlTextWriterPtr writer,\n@@ -175,1 +175,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteBase64(xmlTextWriterPtr writer,\n+    XMLPUBFUN int xmlTextWriterWriteBase64(xmlTextWriterPtr writer,\n@@ -178,1 +178,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteBinHex(xmlTextWriterPtr writer,\n+    XMLPUBFUN int xmlTextWriterWriteBinHex(xmlTextWriterPtr writer,\n@@ -185,1 +185,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -188,1 +188,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterStartAttributeNS(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterStartAttributeNS(xmlTextWriterPtr\n@@ -196,1 +196,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndAttribute(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterEndAttribute(xmlTextWriterPtr\n@@ -202,1 +202,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -207,1 +207,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -213,1 +213,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteAttribute(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteAttribute(xmlTextWriterPtr\n@@ -218,1 +218,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -225,1 +225,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -233,1 +233,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteAttributeNS(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteAttributeNS(xmlTextWriterPtr\n@@ -247,1 +247,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -250,1 +250,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndPI(xmlTextWriterPtr writer);\n+    XMLPUBFUN int xmlTextWriterEndPI(xmlTextWriterPtr writer);\n@@ -255,1 +255,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -260,1 +260,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -265,1 +265,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -280,2 +280,2 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterStartCDATA(xmlTextWriterPtr writer);\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndCDATA(xmlTextWriterPtr writer);\n+    XMLPUBFUN int xmlTextWriterStartCDATA(xmlTextWriterPtr writer);\n+    XMLPUBFUN int xmlTextWriterEndCDATA(xmlTextWriterPtr writer);\n@@ -286,1 +286,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -290,1 +290,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -294,1 +294,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -301,1 +301,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -306,1 +306,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndDTD(xmlTextWriterPtr writer);\n+    XMLPUBFUN int xmlTextWriterEndDTD(xmlTextWriterPtr writer);\n@@ -311,1 +311,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -318,1 +318,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -325,1 +325,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -342,1 +342,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -345,1 +345,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDElement(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterEndDTDElement(xmlTextWriterPtr\n@@ -351,1 +351,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -356,1 +356,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -362,1 +362,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDElement(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteDTDElement(xmlTextWriterPtr\n@@ -372,1 +372,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -375,1 +375,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDAttlist(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterEndDTDAttlist(xmlTextWriterPtr\n@@ -381,1 +381,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -386,1 +386,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -392,1 +392,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDAttlist(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteDTDAttlist(xmlTextWriterPtr\n@@ -402,1 +402,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -405,1 +405,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDEntity(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterEndDTDEntity(xmlTextWriterPtr\n@@ -411,1 +411,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -417,1 +417,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -424,1 +424,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -429,1 +429,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -436,1 +436,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -443,1 +443,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDEntity(xmlTextWriterPtr\n+    XMLPUBFUN int xmlTextWriterWriteDTDEntity(xmlTextWriterPtr\n@@ -458,1 +458,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -467,1 +467,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -469,1 +469,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -473,1 +473,1 @@\n-    XMLPUBFUN int XMLCALL\n+    XMLPUBFUN int\n@@ -480,1 +480,1 @@\n-    XMLPUBFUN int XMLCALL xmlTextWriterFlush(xmlTextWriterPtr writer);\n+    XMLPUBFUN int xmlTextWriterFlush(xmlTextWriterPtr writer);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlwriter.h","additions":80,"deletions":80,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-    int              valueFrame;        \/* used to limit Pop on the stack *\/\n+    int              valueFrame;        \/* always zero for compatibility *\/\n@@ -457,1 +457,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -459,1 +459,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -461,1 +461,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -463,1 +463,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -465,1 +465,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -467,1 +467,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -473,1 +473,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -475,1 +475,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -477,1 +477,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -479,1 +479,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -482,1 +482,1 @@\n-XMLPUBFUN double XMLCALL\n+XMLPUBFUN double\n@@ -484,1 +484,1 @@\n-XMLPUBFUN double XMLCALL\n+XMLPUBFUN double\n@@ -486,1 +486,1 @@\n-XMLPUBFUN double XMLCALL\n+XMLPUBFUN double\n@@ -488,1 +488,1 @@\n-XMLPUBFUN double XMLCALL\n+XMLPUBFUN double\n@@ -490,1 +490,1 @@\n-XMLPUBFUN double XMLCALL\n+XMLPUBFUN double\n@@ -493,1 +493,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -495,1 +495,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -497,1 +497,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -499,1 +499,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -501,1 +501,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -504,1 +504,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -506,1 +506,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -508,1 +508,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -514,1 +514,1 @@\n-XMLPUBFUN xmlXPathContextPtr XMLCALL\n+XMLPUBFUN xmlXPathContextPtr\n@@ -516,1 +516,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -518,1 +518,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -526,1 +526,1 @@\n-XMLPUBFUN long XMLCALL\n+XMLPUBFUN long\n@@ -528,1 +528,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -531,1 +531,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -535,1 +535,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -538,1 +538,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -541,1 +541,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -547,1 +547,1 @@\n-XMLPUBFUN xmlXPathCompExprPtr XMLCALL\n+XMLPUBFUN xmlXPathCompExprPtr\n@@ -549,1 +549,1 @@\n-XMLPUBFUN xmlXPathCompExprPtr XMLCALL\n+XMLPUBFUN xmlXPathCompExprPtr\n@@ -552,1 +552,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -555,1 +555,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -558,1 +558,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -563,1 +563,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -565,1 +565,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -567,1 +567,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpath.h","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+#include <stdio.h>\n@@ -103,1 +104,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -105,1 +106,1 @@\n-XMLPUBFUN double XMLCALL\n+XMLPUBFUN double\n@@ -107,1 +108,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -109,1 +110,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -111,1 +112,1 @@\n-XMLPUBFUN void * XMLCALL\n+XMLPUBFUN void *\n@@ -300,1 +301,1 @@\n-    if (ctxt->valueNr < ctxt->valueFrame + (x))                         \\\n+    if (ctxt->valueNr < (x))                                            \\\n@@ -334,1 +335,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -343,1 +344,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -351,1 +352,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -357,1 +358,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -362,1 +363,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -366,1 +367,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -374,1 +375,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -377,1 +378,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -380,1 +381,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -384,1 +385,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -386,1 +387,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -389,1 +390,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -393,1 +394,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -396,1 +397,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -399,1 +400,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -402,1 +403,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -406,1 +407,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -409,1 +410,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -412,1 +413,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -415,1 +416,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -424,1 +425,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -428,1 +429,1 @@\n-XMLPUBFUN const xmlChar * XMLCALL\n+XMLPUBFUN const xmlChar *\n@@ -431,1 +432,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -434,1 +435,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -438,1 +439,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -443,1 +444,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -447,1 +448,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -452,1 +453,1 @@\n-XMLPUBFUN xmlXPathFunction XMLCALL\n+XMLPUBFUN xmlXPathFunction\n@@ -455,1 +456,1 @@\n-XMLPUBFUN xmlXPathFunction XMLCALL\n+XMLPUBFUN xmlXPathFunction\n@@ -459,1 +460,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -461,1 +462,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -464,1 +465,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -468,1 +469,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -474,1 +475,1 @@\n-XMLPUBFUN xmlXPathParserContextPtr XMLCALL\n+XMLPUBFUN xmlXPathParserContextPtr\n@@ -477,1 +478,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -481,1 +482,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -483,1 +484,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -487,1 +488,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -489,1 +490,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -491,1 +492,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -493,1 +494,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -495,1 +496,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -497,1 +498,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -499,1 +500,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -501,1 +502,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -503,1 +504,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -506,1 +507,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -509,1 +510,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -513,1 +514,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -516,1 +517,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -518,1 +519,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -520,1 +521,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -522,1 +523,1 @@\n-XMLPUBFUN xmlChar * XMLCALL\n+XMLPUBFUN xmlChar *\n@@ -528,1 +529,1 @@\n-XMLPUBFUN double XMLCALL\n+XMLPUBFUN double\n@@ -530,1 +531,1 @@\n-XMLPUBFUN int XMLCALL\n+XMLPUBFUN int\n@@ -533,1 +534,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -535,1 +536,1 @@\n-XMLPUBFUN xmlNodeSetPtr XMLCALL\n+XMLPUBFUN xmlNodeSetPtr\n@@ -538,1 +539,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -541,1 +542,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -544,1 +545,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -546,1 +547,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -548,1 +549,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -551,9 +552,9 @@\n-XMLPUBFUN int XMLCALL xmlXPathEqualValues(xmlXPathParserContextPtr ctxt);\n-XMLPUBFUN int XMLCALL xmlXPathNotEqualValues(xmlXPathParserContextPtr ctxt);\n-XMLPUBFUN int XMLCALL xmlXPathCompareValues(xmlXPathParserContextPtr ctxt, int inf, int strict);\n-XMLPUBFUN void XMLCALL xmlXPathValueFlipSign(xmlXPathParserContextPtr ctxt);\n-XMLPUBFUN void XMLCALL xmlXPathAddValues(xmlXPathParserContextPtr ctxt);\n-XMLPUBFUN void XMLCALL xmlXPathSubValues(xmlXPathParserContextPtr ctxt);\n-XMLPUBFUN void XMLCALL xmlXPathMultValues(xmlXPathParserContextPtr ctxt);\n-XMLPUBFUN void XMLCALL xmlXPathDivValues(xmlXPathParserContextPtr ctxt);\n-XMLPUBFUN void XMLCALL xmlXPathModValues(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN int xmlXPathEqualValues(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN int xmlXPathNotEqualValues(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN int xmlXPathCompareValues(xmlXPathParserContextPtr ctxt, int inf, int strict);\n+XMLPUBFUN void xmlXPathValueFlipSign(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN void xmlXPathAddValues(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN void xmlXPathSubValues(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN void xmlXPathMultValues(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN void xmlXPathDivValues(xmlXPathParserContextPtr ctxt);\n+XMLPUBFUN void xmlXPathModValues(xmlXPathParserContextPtr ctxt);\n@@ -561,1 +562,1 @@\n-XMLPUBFUN int XMLCALL xmlXPathIsNodeType(const xmlChar *name);\n+XMLPUBFUN int xmlXPathIsNodeType(const xmlChar *name);\n@@ -566,1 +567,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextSelf(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextSelf(xmlXPathParserContextPtr ctxt,\n@@ -568,1 +569,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextChild(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextChild(xmlXPathParserContextPtr ctxt,\n@@ -570,1 +571,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt,\n@@ -572,1 +573,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextDescendantOrSelf(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextDescendantOrSelf(xmlXPathParserContextPtr ctxt,\n@@ -574,1 +575,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextParent(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextParent(xmlXPathParserContextPtr ctxt,\n@@ -576,1 +577,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAncestorOrSelf(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextAncestorOrSelf(xmlXPathParserContextPtr ctxt,\n@@ -578,1 +579,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextFollowingSibling(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextFollowingSibling(xmlXPathParserContextPtr ctxt,\n@@ -580,1 +581,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt,\n@@ -582,1 +583,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt,\n@@ -584,1 +585,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAttribute(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextAttribute(xmlXPathParserContextPtr ctxt,\n@@ -586,1 +587,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt,\n@@ -588,1 +589,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAncestor(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextAncestor(xmlXPathParserContextPtr ctxt,\n@@ -590,1 +591,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt,\n+XMLPUBFUN xmlNodePtr xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt,\n@@ -595,26 +596,26 @@\n-XMLPUBFUN void XMLCALL xmlXPathLastFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathPositionFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathLocalNameFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathNamespaceURIFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathStringFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathStringLengthFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathConcatFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathContainsFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathStartsWithFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathSubstringAfterFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathNormalizeFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathTranslateFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathNotFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathTrueFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathFalseFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathLangFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathSumFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathFloorFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-XMLPUBFUN void XMLCALL xmlXPathBooleanFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathLastFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathPositionFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathLocalNameFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathNamespaceURIFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathStringFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathStringLengthFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathConcatFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathContainsFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathStartsWithFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathSubstringAfterFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathNormalizeFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathTranslateFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathNotFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathTrueFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathFalseFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathLangFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathSumFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathFloorFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+XMLPUBFUN void xmlXPathBooleanFunction(xmlXPathParserContextPtr ctxt, int nargs);\n@@ -625,1 +626,1 @@\n-XMLPUBFUN void XMLCALL xmlXPathNodeSetFreeNs(xmlNsPtr ns);\n+XMLPUBFUN void xmlXPathNodeSetFreeNs(xmlNsPtr ns);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpathInternals.h","additions":119,"deletions":118,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n+#if defined(LIBXML_XPTR_LOCS_ENABLED)\n@@ -48,1 +48,1 @@\n-XMLPUBFUN xmlLocationSetPtr XMLCALL\n+XMLPUBFUN xmlLocationSetPtr\n@@ -51,1 +51,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -54,1 +54,1 @@\n-XMLPUBFUN xmlLocationSetPtr XMLCALL\n+XMLPUBFUN xmlLocationSetPtr\n@@ -58,1 +58,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -64,1 +64,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -68,1 +68,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -72,1 +72,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -76,1 +76,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -80,1 +80,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -84,1 +84,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -87,1 +87,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -91,1 +91,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -94,1 +94,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -98,1 +98,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -101,1 +101,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -105,1 +105,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -108,1 +108,1 @@\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n+#endif \/* defined(LIBXML_XPTR_LOCS_ENABLED) *\/\n@@ -113,1 +113,1 @@\n-XMLPUBFUN xmlXPathContextPtr XMLCALL\n+XMLPUBFUN xmlXPathContextPtr\n@@ -117,1 +117,1 @@\n-XMLPUBFUN xmlXPathObjectPtr XMLCALL\n+XMLPUBFUN xmlXPathObjectPtr\n@@ -120,1 +120,2 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n+\n+#if defined(LIBXML_XPTR_LOCS_ENABLED)\n@@ -122,1 +123,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -126,1 +127,1 @@\n-XMLPUBFUN xmlNodePtr XMLCALL\n+XMLPUBFUN xmlNodePtr\n@@ -129,1 +130,1 @@\n-XMLPUBFUN void XMLCALL\n+XMLPUBFUN void\n@@ -131,1 +132,1 @@\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n+#endif \/* defined(LIBXML_XPTR_LOCS_ENABLED) *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpointer.h","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+#ifndef XML_BUF_H_PRIVATE__\n+#define XML_BUF_H_PRIVATE__\n+\n+#include <libxml\/tree.h>\n+\n+XML_HIDDEN xmlBufPtr\n+xmlBufCreate(void);\n+XML_HIDDEN xmlBufPtr\n+xmlBufCreateSize(size_t size);\n+\n+XML_HIDDEN int\n+xmlBufSetAllocationScheme(xmlBufPtr buf, xmlBufferAllocationScheme scheme);\n+XML_HIDDEN int\n+xmlBufGetAllocationScheme(xmlBufPtr buf);\n+\n+XML_HIDDEN void\n+xmlBufFree(xmlBufPtr buf);\n+XML_HIDDEN void\n+xmlBufEmpty(xmlBufPtr buf);\n+\n+\/* size_t xmlBufShrink(xmlBufPtr buf, size_t len); *\/\n+XML_HIDDEN int\n+xmlBufGrow(xmlBufPtr buf, int len);\n+XML_HIDDEN int\n+xmlBufResize(xmlBufPtr buf, size_t len);\n+\n+XML_HIDDEN int\n+xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len);\n+XML_HIDDEN int\n+xmlBufCat(xmlBufPtr buf, const xmlChar *str);\n+XML_HIDDEN int\n+xmlBufCCat(xmlBufPtr buf, const char *str);\n+XML_HIDDEN int\n+xmlBufWriteQuotedString(xmlBufPtr buf, const xmlChar *string);\n+\n+XML_HIDDEN size_t\n+xmlBufAvail(const xmlBufPtr buf);\n+XML_HIDDEN size_t\n+xmlBufLength(const xmlBufPtr buf);\n+\/* size_t xmlBufUse(const xmlBufPtr buf); *\/\n+XML_HIDDEN int\n+xmlBufIsEmpty(const xmlBufPtr buf);\n+XML_HIDDEN int\n+xmlBufAddLen(xmlBufPtr buf, size_t len);\n+\n+\/* const xmlChar * xmlBufContent(const xmlBuf *buf); *\/\n+\/* const xmlChar * xmlBufEnd(xmlBufPtr buf); *\/\n+\n+XML_HIDDEN xmlChar *\n+xmlBufDetach(xmlBufPtr buf);\n+\n+XML_HIDDEN size_t\n+xmlBufDump(FILE *file, xmlBufPtr buf);\n+\n+XML_HIDDEN xmlBufPtr\n+xmlBufFromBuffer(xmlBufferPtr buffer);\n+XML_HIDDEN xmlBufferPtr\n+xmlBufBackToBuffer(xmlBufPtr buf);\n+XML_HIDDEN int\n+xmlBufMergeBuffer(xmlBufPtr buf, xmlBufferPtr buffer);\n+\n+XML_HIDDEN int\n+xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input);\n+XML_HIDDEN int\n+xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos);\n+\n+#endif \/* XML_BUF_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/buf.h","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+#ifndef XML_DICT_H_PRIVATE__\n+#define XML_DICT_H_PRIVATE__\n+\n+#include <libxml\/dict.h>\n+\n+\/*\n+ * Values are ANDed with 0xFFFFFFFF to support platforms where\n+ * unsigned is larger than 32 bits. With 32-bit unsigned values,\n+ * modern compilers should optimize the operation away.\n+ *\/\n+\n+#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))\n+#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))\n+\n+\/*\n+ * GoodOAAT: One of a smallest non-multiplicative One-At-a-Time functions\n+ * that passes SMHasher.\n+ *\n+ * Author: Sokolov Yura aka funny-falcon\n+ *\/\n+\n+#define HASH_INIT(h1, h2, seed) \\\n+    do { \\\n+        h1 = seed ^ 0x3b00; \\\n+        h2 = HASH_ROL(seed, 15); \\\n+    } while (0)\n+\n+#define HASH_UPDATE(h1, h2, ch) \\\n+    do { \\\n+        h1 += ch; \\\n+        h1 += h1 << 3; \\\n+        h2 += h1; \\\n+        h2 = HASH_ROL(h2, 7); \\\n+        h2 += h2 << 2; \\\n+    } while (0)\n+\n+\/* Result is in h2 *\/\n+#define HASH_FINISH(h1, h2) \\\n+    do { \\\n+        h1 ^= h2; \\\n+        h1 += HASH_ROL(h2, 14); \\\n+        h2 ^= h1; h2 += HASH_ROR(h1, 6); \\\n+        h1 ^= h2; h1 += HASH_ROL(h2, 5); \\\n+        h2 ^= h1; h2 += HASH_ROR(h1, 8); \\\n+        h2 &= 0xFFFFFFFF; \\\n+    } while (0)\n+\n+typedef struct {\n+    unsigned hashValue;\n+    const xmlChar *name;\n+} xmlHashedString;\n+\n+XML_HIDDEN void\n+xmlInitDictInternal(void);\n+XML_HIDDEN void\n+xmlCleanupDictInternal(void);\n+\n+XML_HIDDEN unsigned\n+xmlDictComputeHash(const xmlDict *dict, const xmlChar *string);\n+XML_HIDDEN unsigned\n+xmlDictCombineHash(unsigned v1, unsigned v2);\n+XML_HIDDEN xmlHashedString\n+xmlDictLookupHashed(xmlDictPtr dict, const xmlChar *name, int len);\n+\n+XML_HIDDEN void\n+xmlInitRandom(void);\n+XML_HIDDEN void\n+xmlCleanupRandom(void);\n+XML_HIDDEN unsigned\n+xmlRandom(void);\n+\n+#endif \/* XML_DICT_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/dict.h","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+#ifndef XML_ENC_H_PRIVATE__\n+#define XML_ENC_H_PRIVATE__\n+\n+#include <libxml\/encoding.h>\n+#include <libxml\/tree.h>\n+\n+XML_HIDDEN void\n+xmlInitEncodingInternal(void);\n+\n+XML_HIDDEN int\n+xmlEncInputChunk(xmlCharEncodingHandler *handler, unsigned char *out,\n+                 int *outlen, const unsigned char *in, int *inlen);\n+XML_HIDDEN int\n+xmlCharEncInput(xmlParserInputBufferPtr input);\n+XML_HIDDEN int\n+xmlCharEncOutput(xmlOutputBufferPtr output, int init);\n+\n+#endif \/* XML_ENC_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/enc.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+#ifndef XML_ENTITIES_H_PRIVATE__\n+#define XML_ENTITIES_H_PRIVATE__\n+\n+#include <libxml\/tree.h>\n+#include <libxml\/xmlstring.h>\n+\n+\/*\n+ * Entity flags\n+ *\n+ * XML_ENT_PARSED: The entity was parsed and `children` points to the\n+ * content.\n+ * XML_ENT_CHECKED: The entity was checked for loops.\n+ *\/\n+#define XML_ENT_PARSED      (1<<0)\n+#define XML_ENT_CHECKED     (1<<1)\n+#define XML_ENT_EXPANDING   (1<<2)\n+#define XML_ENT_CHECKED_LT  (1<<3)\n+#define XML_ENT_CONTAINS_LT (1<<4)\n+\n+XML_HIDDEN xmlChar *\n+xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input);\n+\n+#endif \/* XML_ENTITIES_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/entities.h","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+#ifndef XML_ERROR_H_PRIVATE__\n+#define XML_ERROR_H_PRIVATE__\n+\n+#include <libxml\/xmlerror.h>\n+#include <libxml\/xmlversion.h>\n+\n+struct _xmlNode;\n+\n+XML_HIDDEN void\n+__xmlRaiseError(xmlStructuredErrorFunc schannel,\n+                xmlGenericErrorFunc channel, void *data, void *ctx,\n+                void *nod, int domain, int code, xmlErrorLevel level,\n+                const char *file, int line, const char *str1,\n+                const char *str2, const char *str3, int int1, int col,\n+                const char *msg, ...) LIBXML_ATTR_FORMAT(16,17);\n+XML_HIDDEN void\n+__xmlSimpleError(int domain, int code, struct _xmlNode *node,\n+                 const char *msg, const char *extra) LIBXML_ATTR_FORMAT(4,0);\n+XML_HIDDEN void\n+xmlGenericErrorDefaultFunc(void *ctx, const char *msg,\n+                           ...) LIBXML_ATTR_FORMAT(2,3);\n+\n+#endif \/* XML_ERROR_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/error.h","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+#ifndef XML_GLOBALS_H_PRIVATE__\n+#define XML_GLOBALS_H_PRIVATE__\n+\n+XML_HIDDEN void\n+xmlInitGlobalsInternal(void);\n+XML_HIDDEN void\n+xmlCleanupGlobalsInternal(void);\n+\n+#endif \/* XML_GLOBALS_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/globals.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+#ifndef XML_HTML_H_PRIVATE__\n+#define XML_HTML_H_PRIVATE__\n+\n+#include <libxml\/xmlversion.h>\n+\n+#ifdef LIBXML_HTML_ENABLED\n+\n+XML_HIDDEN void\n+__htmlParseContent(void *ctx);\n+\n+#endif \/* LIBXML_HTML_ENABLED *\/\n+\n+#endif \/* XML_HTML_H_PRIVATE__ *\/\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/html.h","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+#ifndef XML_IO_H_PRIVATE__\n+#define XML_IO_H_PRIVATE__\n+\n+#include <libxml\/encoding.h>\n+#include <libxml\/tree.h>\n+#include <libxml\/xmlversion.h>\n+\n+XML_HIDDEN void\n+__xmlIOErr(int domain, int code, const char *extra);\n+XML_HIDDEN void\n+__xmlLoaderErr(void *ctx, const char *msg,\n+               const char *filename) LIBXML_ATTR_FORMAT(2,0);\n+\n+xmlParserInputBufferPtr\n+xmlParserInputBufferCreateString(const xmlChar *str);\n+\n+#ifdef LIBXML_OUTPUT_ENABLED\n+XML_HIDDEN xmlOutputBufferPtr\n+xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder);\n+#endif\n+\n+#endif \/* XML_IO_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/io.h","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+#ifndef XML_MEMORY_H_PRIVATE__\n+#define XML_MEMORY_H_PRIVATE__\n+\n+XML_HIDDEN void\n+xmlInitMemoryInternal(void);\n+XML_HIDDEN void\n+xmlCleanupMemoryInternal(void);\n+\n+#endif \/* XML_MEMORY_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/memory.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+#ifndef XML_PARSER_H_PRIVATE__\n+#define XML_PARSER_H_PRIVATE__\n+\n+#include <libxml\/parser.h>\n+#include <libxml\/xmlversion.h>\n+\n+\/**\n+ * XML_VCTXT_DTD_VALIDATED:\n+ *\n+ * Set after xmlValidateDtdFinal was called.\n+ *\/\n+#define XML_VCTXT_DTD_VALIDATED (1u << 0)\n+\/**\n+ * XML_VCTXT_USE_PCTXT:\n+ *\n+ * Set if the validation context is part of a parser context.\n+ *\/\n+#define XML_VCTXT_USE_PCTXT (1u << 1)\n+\n+#define XML_INPUT_HAS_ENCODING      (1u << 0)\n+#define XML_INPUT_AUTO_ENCODING     (7u << 1)\n+#define XML_INPUT_AUTO_UTF8         (1u << 1)\n+#define XML_INPUT_AUTO_UTF16LE      (2u << 1)\n+#define XML_INPUT_AUTO_UTF16BE      (3u << 1)\n+#define XML_INPUT_AUTO_OTHER        (4u << 1)\n+#define XML_INPUT_USES_ENC_DECL     (1u << 4)\n+#define XML_INPUT_ENCODING_ERROR    (1u << 5)\n+\n+XML_HIDDEN void\n+xmlErrMemory(xmlParserCtxtPtr ctxt, const char *extra);\n+XML_HIDDEN void\n+xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);\n+XML_HIDDEN void LIBXML_ATTR_FORMAT(3,0)\n+xmlWarningMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n+              const char *msg, const xmlChar *str1, const xmlChar *str2);\n+XML_HIDDEN void\n+__xmlErrEncoding(xmlParserCtxtPtr ctxt, xmlParserErrors xmlerr,\n+                 const char *msg, const xmlChar *str1,\n+                 const xmlChar *str2) LIBXML_ATTR_FORMAT(3,0);\n+XML_HIDDEN void\n+xmlHaltParser(xmlParserCtxtPtr ctxt);\n+XML_HIDDEN int\n+xmlParserGrow(xmlParserCtxtPtr ctxt);\n+XML_HIDDEN void\n+xmlParserShrink(xmlParserCtxtPtr ctxt);\n+\n+XML_HIDDEN void\n+xmlDetectEncoding(xmlParserCtxtPtr ctxt);\n+XML_HIDDEN void\n+xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding);\n+XML_HIDDEN const xmlChar *\n+xmlGetActualEncoding(xmlParserCtxtPtr ctxt);\n+\n+XML_HIDDEN xmlParserNsData *\n+xmlParserNsCreate(void);\n+XML_HIDDEN void\n+xmlParserNsFree(xmlParserNsData *nsdb);\n+\/*\n+ * These functions allow SAX handlers to attach extra data to namespaces\n+ * efficiently and should be made public.\n+ *\/\n+XML_HIDDEN int\n+xmlParserNsUpdateSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n+                     void *saxData);\n+XML_HIDDEN void *\n+xmlParserNsLookupSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix);\n+\n+#endif \/* XML_PARSER_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/parser.h","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+#ifndef XML_SAVE_H_PRIVATE__\n+#define XML_SAVE_H_PRIVATE__\n+\n+#include <libxml\/tree.h>\n+#include <libxml\/xmlversion.h>\n+\n+#ifdef LIBXML_OUTPUT_ENABLED\n+\n+XML_HIDDEN void\n+xmlBufAttrSerializeTxtContent(xmlBufPtr buf, xmlDocPtr doc,\n+                              xmlAttrPtr attr, const xmlChar * string);\n+XML_HIDDEN void\n+xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur);\n+\n+#endif \/* LIBXML_OUTPUT_ENABLED *\/\n+\n+#endif \/* XML_SAVE_H_PRIVATE__ *\/\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/save.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+#ifndef XML_STRING_H_PRIVATE__\n+#define XML_STRING_H_PRIVATE__\n+\n+#include <libxml\/xmlstring.h>\n+\n+XML_HIDDEN xmlChar *\n+xmlEscapeFormatString(xmlChar **msg);\n+\n+#endif \/* XML_STRING_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/string.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+#ifndef XML_THREADS_H_PRIVATE__\n+#define XML_THREADS_H_PRIVATE__\n+\n+#include <libxml\/threads.h>\n+\n+#ifdef LIBXML_THREAD_ENABLED\n+  #ifdef HAVE_PTHREAD_H\n+    #include <pthread.h>\n+    #define HAVE_POSIX_THREADS\n+  #elif defined(_WIN32)\n+    #define WIN32_LEAN_AND_MEAN\n+    #include <windows.h>\n+    #define HAVE_WIN32_THREADS\n+  #endif\n+#endif\n+\n+\/*\n+ * xmlMutex are a simple mutual exception locks\n+ *\/\n+struct _xmlMutex {\n+#ifdef HAVE_POSIX_THREADS\n+    pthread_mutex_t lock;\n+#elif defined HAVE_WIN32_THREADS\n+    CRITICAL_SECTION cs;\n+#else\n+    int empty;\n+#endif\n+};\n+\n+XML_HIDDEN void\n+xmlInitMutex(xmlMutexPtr mutex);\n+XML_HIDDEN void\n+xmlCleanupMutex(xmlMutexPtr mutex);\n+\n+#endif \/* XML_THREADS_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/threads.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+#ifndef XML_TREE_H_PRIVATE__\n+#define XML_TREE_H_PRIVATE__\n+\n+\/*\n+ * Internal variable indicating if a callback has been registered for\n+ * node creation\/destruction. It avoids spending a lot of time in locking\n+ * function while checking if the callback exists.\n+ *\/\n+XML_HIDDEN extern int\n+__xmlRegisterCallbacks;\n+\n+XML_HIDDEN xmlNodePtr\n+xmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n+                  int extended);\n+XML_HIDDEN xmlNodePtr\n+xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent);\n+\n+#endif \/* XML_TREE_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/tree.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+#ifndef XML_XPATH_H_PRIVATE__\n+#define XML_XPATH_H_PRIVATE__\n+\n+XML_HIDDEN void\n+xmlInitXPathInternal(void);\n+\n+#endif \/* XML_XPATH_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/xpath.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -4,3 +4,0 @@\n-#define SEND_ARG2_CAST\n-#define GETHOSTBYNAME_ARG_CAST\n-\n@@ -12,1 +9,1 @@\n-#define HAVE_STDINT_H\n+  #define HAVE_STDINT_H\n@@ -16,6 +13,6 @@\n-#if _MSC_VER < 1900\n-#define snprintf _snprintf\n-#endif\n-#if _MSC_VER < 1500\n-#define vsnprintf(b,c,f,a) _vsnprintf(b,c,f,a)\n-#endif\n+  #if _MSC_VER < 1900\n+    #define snprintf _snprintf\n+  #endif\n+  #if _MSC_VER < 1500\n+    #define vsnprintf(b,c,f,a) _vsnprintf(b,c,f,a)\n+  #endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/win32config.h","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-#define HAVE_GETADDRINFO\n+#ifndef SUPPORT_IP6\n+  #define SUPPORT_IP6\n+#endif\n@@ -31,1 +33,1 @@\n-#undef XML_SOCKLEN_T\n+#ifndef XML_SOCKLEN_T\n@@ -33,0 +35,1 @@\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/wsockcompat.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -10,3 +10,2 @@\n-Requires:\n-Libs: -L${libdir} @XML_LIBS@\n-Libs.private: @XML_PRIVATE_LIBS@ @LIBS@\n+Requires@XML_PC_PRIVATE@: @XML_PC_REQUIRES@\n+Libs: -L${libdir} @XML_LIBS@ @XML_PC_LIBS_PRIVATE@ @XML_PC_LIBS@ @LIBS@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml-2.0-uninstalled.pc.in","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -10,3 +10,2 @@\n-Requires:\n-Libs: -L${libdir} @XML_LIBS@\n-Libs.private: @XML_PRIVATE_LIBS@ @LIBS@\n+Requires@XML_PC_PRIVATE@: @XML_PC_REQUIRES@\n+Libs: -L${libdir} @XML_LIBS@ @XML_PC_LIBS_PRIVATE@ @XML_PC_LIBS@ @LIBS@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml-2.0.pc.in","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -17,6 +17,6 @@\n-#ifndef _LARGEFILE_SOURCE\n-#define _LARGEFILE_SOURCE\n-#endif\n-#ifndef _FILE_OFFSET_BITS\n-#define _FILE_OFFSET_BITS 64\n-#endif\n+  #ifndef _LARGEFILE_SOURCE\n+    #define _LARGEFILE_SOURCE\n+  #endif\n+  #ifndef _FILE_OFFSET_BITS\n+    #define _FILE_OFFSET_BITS 64\n+  #endif\n@@ -26,3 +26,2 @@\n- * Currently supported platforms use either autoconf or\n- * copy to config.h own \"preset\" configuration file.\n- * As result ifdef HAVE_CONFIG_H is omitted here.\n+ * These files are generated by the build system and contain private\n+ * and public build configuration.\n@@ -32,1 +31,0 @@\n-#include <libxml\/xmlstring.h>\n@@ -34,0 +32,5 @@\n+\/*\n+ * Due to some Autotools limitations, this variable must be passed as\n+ * compiler flag. Define a default value if the macro wasn't set by the\n+ * build system.\n+ *\/\n@@ -38,5 +41,3 @@\n-#if defined(__Lynx__)\n-#include <stdio.h> \/* pull definition of size_t *\/\n-#include <varargs.h>\n-int snprintf(char *, size_t, const char *, ...);\n-int vfprintf(FILE *, const char *, va_list);\n+#ifdef WITH_TRIO\n+  #define TRIO_REPLACE_STDIO\n+  #include \"trio.h\"\n@@ -45,2 +46,5 @@\n-#ifndef WITH_TRIO\n-#include <stdio.h>\n+#if !defined(_WIN32) && \\\n+    !defined(__CYGWIN__) && \\\n+    (defined(__clang__) || \\\n+     (defined(__GNUC__) && (__GNUC__ >= 4)))\n+  #define XML_HIDDEN __attribute__((visibility(\"hidden\")))\n@@ -48,20 +52,1 @@\n-\/**\n- * TRIO_REPLACE_STDIO:\n- *\n- * This macro is defined if the trio string formatting functions are to\n- * be used instead of the default stdio ones.\n- *\/\n-#define TRIO_REPLACE_STDIO\n-#include \"trio.h\"\n-#endif\n-\n-#if defined(__clang__) || \\\n-    (defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 406))\n-#define XML_IGNORE_PEDANTIC_WARNINGS \\\n-    _Pragma(\"GCC diagnostic push\") \\\n-    _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\")\n-#define XML_POP_WARNINGS \\\n-    _Pragma(\"GCC diagnostic pop\")\n-#else\n-#define XML_IGNORE_PEDANTIC_WARNINGS\n-#define XML_POP_WARNINGS\n+  #define XML_HIDDEN\n@@ -72,1 +57,1 @@\n-#define ATTRIBUTE_NO_SANITIZE(arg) __attribute__((no_sanitize(arg)))\n+  #define ATTRIBUTE_NO_SANITIZE(arg) __attribute__((no_sanitize(arg)))\n@@ -74,1 +59,1 @@\n-#define ATTRIBUTE_NO_SANITIZE(arg)\n+  #define ATTRIBUTE_NO_SANITIZE(arg)\n@@ -77,17 +62,6 @@\n-\/*\n- * Internal variable indicating if a callback has been registered for\n- * node creation\/destruction. It avoids spending a lot of time in locking\n- * function while checking if the callback exists.\n- *\/\n-extern int __xmlRegisterCallbacks;\n-\/*\n- * internal error reporting routines, shared but not part of the API.\n- *\/\n-void __xmlIOErr(int domain, int code, const char *extra);\n-void __xmlLoaderErr(void *ctx, const char *msg, const char *filename) LIBXML_ATTR_FORMAT(2,0);\n-#ifdef LIBXML_HTML_ENABLED\n-\/*\n- * internal function of HTML parser needed for xmlParseInNodeContext\n- * but not part of the API\n- *\/\n-void __htmlParseContent(void *ctx);\n+#ifdef __clang__\n+  #define ATTRIBUTE_NO_SANITIZE_INTEGER \\\n+    ATTRIBUTE_NO_SANITIZE(\"unsigned-integer-overflow\") \\\n+    ATTRIBUTE_NO_SANITIZE(\"unsigned-shift-base\")\n+#else\n+  #define ATTRIBUTE_NO_SANITIZE_INTEGER\n@@ -96,20 +70,0 @@\n-\/*\n- * internal global initialization critical section routines.\n- *\/\n-void __xmlGlobalInitMutexLock(void);\n-void __xmlGlobalInitMutexUnlock(void);\n-void __xmlGlobalInitMutexDestroy(void);\n-\n-int __xmlInitializeDict(void);\n-\n-\/*\n- * internal thread safe random function\n- *\/\n-int __xmlRandom(void);\n-\n-XMLPUBFUN xmlChar * XMLCALL xmlEscapeFormatString(xmlChar **msg);\n-int xmlInputReadCallbackNop(void *context, char *buffer, int len);\n-\n-#if !defined(PIC) && !defined(NOLIBTOOL) && !defined(LIBXML_STATIC)\n-#  define LIBXML_STATIC\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml.h","additions":30,"deletions":76,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -1,10 +0,0 @@\n-# Configure paths for LIBXML2\n-# Simon Josefsson 2020-02-12\n-# Fix autoconf 2.70+ warnings\n-# Mike Hommey 2004-06-19\n-# use CPPFLAGS instead of CFLAGS\n-# Toshio Kuratomi 2001-04-21\n-# Adapted from:\n-# Configure paths for GLIB\n-# Owen Taylor     97-11-3\n-\n@@ -14,129 +4,3 @@\n-AC_DEFUN([AM_PATH_XML2],[ \n-AC_ARG_WITH(xml-prefix,\n-            [  --with-xml-prefix=PFX   Prefix where libxml is installed (optional)],\n-            xml_config_prefix=\"$withval\", xml_config_prefix=\"\")\n-AC_ARG_WITH(xml-exec-prefix,\n-            [  --with-xml-exec-prefix=PFX Exec prefix where libxml is installed (optional)],\n-            xml_config_exec_prefix=\"$withval\", xml_config_exec_prefix=\"\")\n-AC_ARG_ENABLE(xmltest,\n-              [  --disable-xmltest       Do not try to compile and run a test LIBXML program],,\n-              enable_xmltest=yes)\n-\n-  if test x$xml_config_exec_prefix != x ; then\n-     xml_config_args=\"$xml_config_args\"\n-     if test x${XML2_CONFIG+set} != xset ; then\n-        XML2_CONFIG=$xml_config_exec_prefix\/bin\/xml2-config\n-     fi\n-  fi\n-  if test x$xml_config_prefix != x ; then\n-     xml_config_args=\"$xml_config_args --prefix=$xml_config_prefix\"\n-     if test x${XML2_CONFIG+set} != xset ; then\n-        XML2_CONFIG=$xml_config_prefix\/bin\/xml2-config\n-     fi\n-  fi\n-\n-  AC_PATH_PROG(XML2_CONFIG, xml2-config, no)\n-  min_xml_version=ifelse([$1], ,2.0.0,[$1])\n-  AC_MSG_CHECKING(for libxml - version >= $min_xml_version)\n-  no_xml=\"\"\n-  if test \"$XML2_CONFIG\" = \"no\" ; then\n-    no_xml=yes\n-  else\n-    XML_CPPFLAGS=`$XML2_CONFIG $xml_config_args --cflags`\n-    XML_LIBS=`$XML2_CONFIG $xml_config_args --libs`\n-    xml_config_major_version=`$XML2_CONFIG $xml_config_args --version | \\\n-           sed 's\/\\([[0-9]]*\\).\\([[0-9]]*\\).\\([[0-9]]*\\)\/\\1\/'`\n-    xml_config_minor_version=`$XML2_CONFIG $xml_config_args --version | \\\n-           sed 's\/\\([[0-9]]*\\).\\([[0-9]]*\\).\\([[0-9]]*\\)\/\\2\/'`\n-    xml_config_micro_version=`$XML2_CONFIG $xml_config_args --version | \\\n-           sed 's\/\\([[0-9]]*\\).\\([[0-9]]*\\).\\([[0-9]]*\\)\/\\3\/'`\n-    if test \"x$enable_xmltest\" = \"xyes\" ; then\n-      ac_save_CPPFLAGS=\"$CPPFLAGS\"\n-      ac_save_LIBS=\"$LIBS\"\n-      CPPFLAGS=\"$CPPFLAGS $XML_CPPFLAGS\"\n-      LIBS=\"$XML_LIBS $LIBS\"\n-dnl\n-dnl Now check if the installed libxml is sufficiently new.\n-dnl (Also sanity checks the results of xml2-config to some extent)\n-dnl\n-      rm -f conf.xmltest\n-      AC_RUN_IFELSE(\n-            [AC_LANG_SOURCE([[\n-#include <stdlib.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include <libxml\/xmlversion.h>\n-\n-int \n-main()\n-{\n-  int xml_major_version, xml_minor_version, xml_micro_version;\n-  int major, minor, micro;\n-  char *tmp_version;\n-\n-  system(\"touch conf.xmltest\");\n-\n-  \/* Capture xml2-config output via autoconf\/configure variables *\/\n-  \/* HP\/UX 9 (%@#!) writes to sscanf strings *\/\n-  tmp_version = (char *)strdup(\"$min_xml_version\");\n-  if (sscanf(tmp_version, \"%d.%d.%d\", &major, &minor, &micro) != 3) {\n-     printf(\"%s, bad version string from xml2-config\\n\", \"$min_xml_version\");\n-     exit(1);\n-   }\n-   free(tmp_version);\n-\n-   \/* Capture the version information from the header files *\/\n-   tmp_version = (char *)strdup(LIBXML_DOTTED_VERSION);\n-   if (sscanf(tmp_version, \"%d.%d.%d\", &xml_major_version, &xml_minor_version, &xml_micro_version) != 3) {\n-     printf(\"%s, bad version string from libxml includes\\n\", \"LIBXML_DOTTED_VERSION\");\n-     exit(1);\n-   }\n-   free(tmp_version);\n-\n- \/* Compare xml2-config output to the libxml headers *\/\n-  if ((xml_major_version != $xml_config_major_version) ||\n-      (xml_minor_version != $xml_config_minor_version) ||\n-      (xml_micro_version != $xml_config_micro_version))\n-    {\n-      printf(\"*** libxml header files (version %d.%d.%d) do not match\\n\",\n-         xml_major_version, xml_minor_version, xml_micro_version);\n-      printf(\"*** xml2-config (version %d.%d.%d)\\n\",\n-         $xml_config_major_version, $xml_config_minor_version, $xml_config_micro_version);\n-      return 1;\n-    } \n-\/* Compare the headers to the library to make sure we match *\/\n-  \/* Less than ideal -- doesn't provide us with return value feedback, \n-   * only exits if there's a serious mismatch between header and library.\n-   *\/\n-    LIBXML_TEST_VERSION;\n-\n-    \/* Test that the library is greater than our minimum version *\/\n-    if ((xml_major_version > major) ||\n-        ((xml_major_version == major) && (xml_minor_version > minor)) ||\n-        ((xml_major_version == major) && (xml_minor_version == minor) &&\n-        (xml_micro_version >= micro)))\n-      {\n-        return 0;\n-       }\n-     else\n-      {\n-        printf(\"\\n*** An old version of libxml (%d.%d.%d) was found.\\n\",\n-               xml_major_version, xml_minor_version, xml_micro_version);\n-        printf(\"*** You need a version of libxml newer than %d.%d.%d.\\n\",\n-           major, minor, micro);\n-        printf(\"***\\n\");\n-        printf(\"*** If you have already installed a sufficiently new version, this error\\n\");\n-        printf(\"*** probably means that the wrong copy of the xml2-config shell script is\\n\");\n-        printf(\"*** being found. The easiest way to fix this is to remove the old version\\n\");\n-        printf(\"*** of LIBXML, but you can also set the XML2_CONFIG environment to point to the\\n\");\n-        printf(\"*** correct copy of xml2-config. (In this case, you will have to\\n\");\n-        printf(\"*** modify your LD_LIBRARY_PATH environment variable, or edit \/etc\/ld.so.conf\\n\");\n-        printf(\"*** so that the correct libraries are found at run-time))\\n\");\n-    }\n-  return 1;\n-}\n-]])],, no_xml=yes,[echo $ac_n \"cross compiling; assumed OK... $ac_c\"])\n-       CPPFLAGS=\"$ac_save_CPPFLAGS\"\n-       LIBS=\"$ac_save_LIBS\"\n-     fi\n-  fi\n+AC_DEFUN([AM_PATH_XML2],[\n+  m4_warn([obsolete], [AM_PATH_XML2 is deprecated, use PKG_CHECK_MODULES instead])\n+  AC_REQUIRE([PKG_PROG_PKG_CONFIG])\n@@ -144,39 +8,2 @@\n-  if test \"x$no_xml\" = x ; then\n-     AC_MSG_RESULT(yes (version $xml_config_major_version.$xml_config_minor_version.$xml_config_micro_version))\n-     ifelse([$2], , :, [$2])     \n-  else\n-     AC_MSG_RESULT(no)\n-     if test \"$XML2_CONFIG\" = \"no\" ; then\n-       echo \"*** The xml2-config script installed by LIBXML could not be found\"\n-       echo \"*** If libxml was installed in PREFIX, make sure PREFIX\/bin is in\"\n-       echo \"*** your path, or set the XML2_CONFIG environment variable to the\"\n-       echo \"*** full path to xml2-config.\"\n-     else\n-       if test -f conf.xmltest ; then\n-        :\n-       else\n-          echo \"*** Could not run libxml test program, checking why...\"\n-          CPPFLAGS=\"$CPPFLAGS $XML_CPPFLAGS\"\n-          LIBS=\"$LIBS $XML_LIBS\"\n-\t  AC_LINK_IFELSE(\n-            [AC_LANG_PROGRAM([[\n-#include <libxml\/xmlversion.h>\n-#include <stdio.h>\n-]],    [[ LIBXML_TEST_VERSION; return 0;]])],\n-        [ echo \"*** The test program compiled, but did not run. This usually means\"\n-          echo \"*** that the run-time linker is not finding LIBXML or finding the wrong\"\n-          echo \"*** version of LIBXML. If it is not finding LIBXML, you'll need to set your\"\n-          echo \"*** LD_LIBRARY_PATH environment variable, or edit \/etc\/ld.so.conf to point\"\n-          echo \"*** to the installed location  Also, make sure you have run ldconfig if that\"\n-          echo \"*** is required on your system\"\n-          echo \"***\"\n-          echo \"*** If you have an old version installed, it is best to remove it, although\"\n-          echo \"*** you may also be able to get things to work by modifying LD_LIBRARY_PATH\" ],\n-        [ echo \"*** The test program failed to compile or link. See the file config.log for the\"\n-          echo \"*** exact error that occurred. This usually means LIBXML was incorrectly installed\"\n-          echo \"*** or that you have moved LIBXML since it was installed. In the latter case, you\"\n-          echo \"*** may want to edit the xml2-config script: $XML2_CONFIG\" ])\n-          CPPFLAGS=\"$ac_save_CPPFLAGS\"\n-          LIBS=\"$ac_save_LIBS\"\n-       fi\n-     fi\n+  verdep=ifelse([$1], [], [], [\">= $1\"])\n+  PKG_CHECK_MODULES(XML, [libxml-2.0 $verdep], [$2], [$3])\n@@ -184,4 +11,1 @@\n-     XML_CPPFLAGS=\"\"\n-     XML_LIBS=\"\"\n-     ifelse([$3], , :, [$3])\n-  fi\n+  XML_CPPFLAGS=$XML_CFLAGS\n@@ -190,1 +14,0 @@\n-  rm -f conf.xmltest\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml.m4","additions":6,"deletions":183,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -58,0 +58,5 @@\n+  if(NOT Iconv_FOUND)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"Iconv dependency was not found\")\n+    return()\n+  endif()\n@@ -64,0 +69,5 @@\n+  if(NOT Threads_FOUND)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"Threads dependency was not found\")\n+    return()\n+  endif()\n@@ -70,0 +80,5 @@\n+  if(NOT ICU_FOUND)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"ICU dependency was not found\")\n+    return()\n+  endif()\n@@ -76,0 +91,5 @@\n+  if(NOT LibLZMA_FOUND)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"LibLZMA dependency was not found\")\n+    return()\n+  endif()\n@@ -82,0 +102,5 @@\n+  if(NOT ZLIB_FOUND)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_FOUND FALSE)\n+    set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE \"ZLIB dependency was not found\")\n+    return()\n+  endif()\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml2-config.cmake.in","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,11 +2,1 @@\n-# Officially exported symbols, for which header\n-# file definitions are installed in \/usr\/include\/libxml2\n-#\n-# Automatically generated from symbols.xml and syms.xsl\n-#\n-# Versions here are *fixed* to match the libxml2 version\n-# at which the symbol was introduced. This ensures that\n-# a new client app requiring symbol foo() can't accidentally\n-# run with old libxml2.so not providing foo() - the global\n-# soname version info can't enforce this since we never\n-# change the soname\n+# Retained for backward compatibility. Don't add new symbols.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml2.syms","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <libxml\/xmlerror.h>\n@@ -25,1 +26,0 @@\n-#include <libxml\/globals.h>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/list.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#elif defined (_WIN32)\n+#include <io.h>\n@@ -51,3 +53,0 @@\n-#ifdef HAVE_SYS_TYPES_H\n-#include <sys\/types.h>\n-#endif\n@@ -60,8 +59,0 @@\n-#include <libxml\/globals.h>\n-\n-\/* #define DEBUG_FTP 1  *\/\n-#ifdef STANDALONE\n-#ifndef DEBUG_FTP\n-#define DEBUG_FTP 1\n-#endif\n-#endif\n@@ -69,0 +60,2 @@\n+#include \"private\/error.h\"\n+#include \"private\/io.h\"\n@@ -78,1 +71,0 @@\n-#if !defined(__BEOS__) || defined(__HAIKU__)\n@@ -81,13 +73,0 @@\n-#endif\n-\n-#ifdef __BEOS__\n-#ifndef PF_INET\n-#define PF_INET AF_INET\n-#endif\n-#endif\n-\n-#ifdef _AIX\n-#ifdef HAVE_BROKEN_SS_FAMILY\n-#define ss_family __ss_family\n-#endif\n-#endif\n@@ -99,0 +78,3 @@\n+#define GETHOSTBYNAME_ARG_CAST (char *)\n+#define SEND_ARG2_CAST (char *)\n+\n@@ -420,8 +402,0 @@\n-#ifdef DEBUG_FTP\n-    if (URL == NULL)\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"Removing FTP proxy info\\n\");\n-    else\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"Using FTP proxy %s\\n\", URL);\n-#endif\n@@ -560,5 +534,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNanoFTPGetMore : controlBufIndex = %d\\n\",\n-                ctxt->controlBufIndex);\n-#endif\n@@ -569,5 +538,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNanoFTPGetMore : controlBufUsed = %d\\n\",\n-                ctxt->controlBufUsed);\n-#endif\n@@ -577,5 +541,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNanoFTPGetMore : controlBufIndex > controlBufUsed %d > %d\\n\",\n-               ctxt->controlBufIndex, ctxt->controlBufUsed);\n-#endif\n@@ -596,4 +555,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNanoFTPGetMore : buffer full %d \\n\", ctxt->controlBufUsed);\n-#endif\n@@ -613,5 +568,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"xmlNanoFTPGetMore : read %d [%d - %d]\\n\", len,\n-           ctxt->controlBufUsed, ctxt->controlBufUsed + len);\n-#endif\n@@ -655,4 +605,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"\\n<<<\\n%s\\n--\\n\", ptr);\n-#endif\n@@ -685,4 +631,0 @@\n-#ifdef DEBUG_FTP\n-    ptr = &ctxt->controlBuf[ctxt->controlBufIndex];\n-    xmlGenericError(xmlGenericErrorContext, \"\\n---\\n%s\\n--\\n\", ptr);\n-#endif\n@@ -690,3 +632,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"Got %d\\n\", res);\n-#endif\n@@ -761,3 +700,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -789,3 +725,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -820,3 +753,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf); \/* Just to be consistent, even though we know it can't have a % in it *\/\n-#endif\n@@ -1016,3 +946,0 @@\n-#ifdef DEBUG_FTP\n-            xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1039,3 +966,0 @@\n-#ifdef DEBUG_FTP\n-                    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1080,3 +1004,0 @@\n-#ifdef DEBUG_FTP\n-                xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1112,3 +1033,0 @@\n-#ifdef DEBUG_FTP\n-                xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1134,3 +1052,0 @@\n-#ifdef DEBUG_FTP\n-                xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1285,3 +1200,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1336,3 +1248,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1408,3 +1317,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1508,3 +1414,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1555,3 +1458,0 @@\n-#ifdef DEBUG_FTP\n-        perror(\"select\");\n-#endif\n@@ -1562,4 +1462,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNanoFTPCloseConnection: timeout\\n\");\n-#endif\n@@ -1746,3 +1642,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1770,3 +1663,0 @@\n-#ifdef DEBUG_FTP\n-            perror(\"select\");\n-#endif\n@@ -1797,3 +1687,0 @@\n-#ifdef DEBUG_FTP\n-        write(1, &buf[indx], len);\n-#endif\n@@ -1841,3 +1728,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1861,3 +1745,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n@@ -1915,3 +1796,0 @@\n-#ifdef DEBUG_FTP\n-            perror(\"select\");\n-#endif\n@@ -1974,3 +1852,0 @@\n-#ifdef DEBUG_FTP\n-    xmlGenericError(xmlGenericErrorContext, \"Recvd %d bytes\\n\", len);\n-#endif\n@@ -2095,1 +1970,0 @@\n-    xmlMemoryDump();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/nanoftp.c","additions":7,"deletions":133,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+#include <ctype.h>\n@@ -24,3 +25,2 @@\n-#endif\n-#ifdef HAVE_SYS_TYPES_H\n-#include <sys\/types.h>\n+#elif defined (_WIN32)\n+#include <io.h>\n@@ -40,6 +40,0 @@\n-#ifdef HAVE_RESOLV_H\n-#ifdef HAVE_ARPA_NAMESER_H\n-#include <arpa\/nameser.h>\n-#endif\n-#include <resolv.h>\n-#endif\n@@ -73,1 +67,0 @@\n-#include <libxml\/globals.h>\n@@ -78,1 +71,0 @@\n-#include <libxml\/globals.h>\n@@ -81,0 +73,3 @@\n+#include \"private\/error.h\"\n+#include \"private\/io.h\"\n+\n@@ -85,1 +80,0 @@\n-#if !defined(__BEOS__) || defined(__HAIKU__)\n@@ -87,1 +81,0 @@\n-#endif\n@@ -92,6 +85,0 @@\n-#ifdef __BEOS__\n-#ifndef PF_INET\n-#define PF_INET AF_INET\n-#endif\n-#endif\n-\n@@ -102,0 +89,3 @@\n+#define GETHOSTBYNAME_ARG_CAST (char *)\n+#define SEND_ARG2_CAST (char *)\n+\n@@ -103,1 +93,0 @@\n-#define DEBUG_HTTP\n@@ -191,14 +180,0 @@\n-#ifdef SUPPORT_IP6\n-static\n-int have_ipv6(void) {\n-    SOCKET s;\n-\n-    s = socket (AF_INET6, SOCK_STREAM, 0);\n-    if (s != INVALID_SOCKET) {\n-        close (s);\n-        return (1);\n-    }\n-    return (0);\n-}\n-#endif\n-\n@@ -353,8 +328,0 @@\n-#ifdef DEBUG_HTTP\n-    if (URL == NULL)\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"Removing HTTP proxy info\\n\");\n-    else\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"Using HTTP proxy %s\\n\", URL);\n-#endif\n@@ -538,1 +505,1 @@\n-            ctxt->in = (char *) xmlMallocAtomic(65000 * sizeof(char));\n+            ctxt->in = (char *) xmlMallocAtomic(65000);\n@@ -879,3 +846,0 @@\n-#ifdef DEBUG_HTTP\n-        perror(\"socket\");\n-#endif\n@@ -899,9 +863,0 @@\n-#if defined(__BEOS__) && !defined(__HAIKU__)\n-    {\n-        bool noblock = true;\n-\n-        status =\n-            setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &noblock,\n-                       sizeof(noblock));\n-    }\n-#else \/* __BEOS__ *\/\n@@ -919,3 +874,0 @@\n-#ifdef DEBUG_HTTP\n-        perror(\"nonblocking\");\n-#endif\n@@ -926,1 +878,0 @@\n-#endif \/* !__BEOS__ *\/\n@@ -1045,1 +996,0 @@\n-    struct in6_addr ia6;\n@@ -1051,3 +1001,0 @@\n-#ifdef SUPPORT_IP6\n-    memset (&sockin6, 0, sizeof(sockin6));\n-#endif\n@@ -1055,13 +1002,1 @@\n-#if !defined(HAVE_GETADDRINFO) && defined(SUPPORT_IP6) && defined(RES_USE_INET6)\n-    if (have_ipv6 ())\n-    {\n-        if (!(_res.options & RES_INIT))\n-            res_init();\n-        _res.options |= RES_USE_INET6;\n-    }\n-#endif\n-\n-#if defined(HAVE_GETADDRINFO) && defined(SUPPORT_IP6) && !defined(_WIN32)\n-    if (have_ipv6 ())\n-#endif\n-#if defined(HAVE_GETADDRINFO) && (defined(SUPPORT_IP6) || defined(_WIN32))\n+#if defined(SUPPORT_IP6)\n@@ -1072,0 +1007,2 @@\n+        memset (&sockin6, 0, sizeof(sockin6));\n+\n@@ -1092,2 +1029,1 @@\n-#ifdef SUPPORT_IP6\n-            } else if (have_ipv6 () && (res->ai_family == AF_INET6)) {\n+            } else if (res->ai_family == AF_INET6) {\n@@ -1102,1 +1038,0 @@\n-#endif\n@@ -1116,5 +1051,1 @@\n-#endif\n-#if defined(HAVE_GETADDRINFO) && defined(SUPPORT_IP6) && !defined(_WIN32)\n-    else\n-#endif\n-#if !defined(HAVE_GETADDRINFO) || !defined(_WIN32)\n+#else\n@@ -1182,13 +1113,0 @@\n-#ifdef SUPPORT_IP6\n-            } else if (have_ipv6 () && (h->h_addrtype == AF_INET6)) {\n-                \/* AAAA records (IPv6) *\/\n-                if ((unsigned int) h->h_length > sizeof(ia6)) {\n-                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n-                    return INVALID_SOCKET;\n-                }\n-                memcpy (&ia6, h->h_addr_list[i], h->h_length);\n-                sockin6.sin6_family = h->h_addrtype;\n-                sockin6.sin6_addr = ia6;\n-                sockin6.sin6_port = htons (port);\n-                addr = (struct sockaddr *) &sockin6;\n-#endif\n@@ -1205,5 +1123,0 @@\n-#ifdef DEBUG_HTTP\n-    xmlGenericError(xmlGenericErrorContext,\n-                    \"xmlNanoHTTPConnectHost:  unable to connect to '%s'.\\n\",\n-                    host);\n-#endif\n@@ -1330,0 +1243,101 @@\n+\n+\/**\n+ * xmlNanoHTTPHostnameMatch:\n+ * @pattern: The pattern as it appears in no_proxy environment variable\n+ * @hostname: The hostname to test as it appears in the URL\n+ *\n+ * This function tests whether a given hostname matches a pattern. The pattern\n+ * usually is a token from the no_proxy environment variable. Wildcards in the\n+ * pattern are not supported.\n+ *\n+ * Returns true, iff hostname matches the pattern.\n+ *\/\n+\n+static int\n+xmlNanoHTTPHostnameMatch(const char *pattern, const char *hostname) {\n+    int idx_pattern, idx_hostname;\n+    const char * pattern_start;\n+\n+    if (!pattern || *pattern == '\\0' || !hostname)\n+        return 0;\n+\n+    \/* Ignore trailing '.' *\/\n+    if (*pattern == '.') {\n+        idx_pattern = strlen(pattern) -1;\n+        pattern_start = pattern + 1;\n+    }\n+    else {\n+        idx_pattern = strlen(pattern);\n+        pattern_start = pattern;\n+    }\n+    idx_hostname = strlen(hostname);\n+\n+    for (; idx_pattern >= 0 && idx_hostname >= 0;\n+           --idx_pattern, --idx_hostname) {\n+        if (tolower(pattern_start[idx_pattern]) != tolower(hostname[idx_hostname]))\n+            break;\n+    }\n+\n+    return idx_pattern == -1 && (idx_hostname == -1|| hostname[idx_hostname] == '.');\n+}\n+\n+\n+\/**\n+ * xmlNanoHTTPBypassProxy:\n+ * @hostname: The hostname as it appears in the URL\n+ *\n+ * This function evaluates the no_proxy environment variable and returns\n+ * whether the proxy server should be bypassed for a given host.\n+ *\n+ * Returns true, iff a proxy server should be bypassed for the given hostname.\n+ *\/\n+\n+static int\n+xmlNanoHTTPBypassProxy(const char *hostname) {\n+    size_t envlen;\n+    char *env = getenv(\"no_proxy\"), *cpy=NULL, *p=NULL;\n+    if (!env)\n+        return 0;\n+\n+    \/* (Avoid strdup because it's not portable.) *\/\n+    envlen = strlen(env) + 1;\n+    cpy = xmlMalloc(envlen);\n+    memcpy(cpy, env, envlen);\n+    env = cpy;\n+\n+    \/* The remainder of the function is basically a tokenizing: *\/\n+    while (isspace(*env))\n+        ++env;\n+    if (*env == '\\0') {\n+        xmlFree(cpy);\n+        return 0;\n+    }\n+\n+    p = env;\n+    while (*env) {\n+\n+        if (*env != ',') {\n+            ++env;\n+            continue;\n+        }\n+\n+        *(env++) = '\\0';\n+        if (xmlNanoHTTPHostnameMatch(p, hostname)) {\n+            xmlFree(cpy);\n+            return 1;\n+        }\n+\n+        while (isspace(*env))\n+            ++env;\n+        p = env;\n+    }\n+    if (xmlNanoHTTPHostnameMatch(p, hostname)) {\n+        xmlFree(cpy);\n+        return 1;\n+    }\n+\n+    xmlFree(cpy);\n+    return 0;\n+}\n+\n+\n@@ -1357,0 +1371,1 @@\n+    int use_proxy;\n@@ -1358,3 +1373,0 @@\n-#ifdef DEBUG_HTTP\n-    int xmt_bytes;\n-#endif\n@@ -1391,1 +1403,2 @@\n-    if (proxy) {\n+    use_proxy = proxy && !xmlNanoHTTPBypassProxy(ctxt->hostname);\n+    if (use_proxy) {\n@@ -1426,1 +1439,1 @@\n-        if (proxy)\n+        if (use_proxy)\n@@ -1440,1 +1453,1 @@\n-    if (proxy) {\n+    if (use_proxy) {\n@@ -1479,7 +1492,0 @@\n-#ifdef DEBUG_HTTP\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"-> %s%s\", proxy? \"(Proxy) \" : \"\", bp);\n-    if ((blen -= strlen(bp)+1) < 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"ERROR: overflowed buffer by %d bytes\\n\", -blen);\n-#endif\n@@ -1489,9 +1495,0 @@\n-#ifdef DEBUG_HTTP\n-    xmt_bytes = xmlNanoHTTPSend(ctxt, ctxt->out, blen );\n-    if ( xmt_bytes != blen )\n-        xmlGenericError( xmlGenericErrorContext,\n-                        \"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\\n\",\n-                        xmt_bytes, blen,\n-                        \"bytes of HTTP headers sent to host\",\n-                        ctxt->hostname );\n-#else\n@@ -1499,1 +1496,0 @@\n-#endif\n@@ -1502,10 +1498,0 @@\n-#ifdef DEBUG_HTTP\n-        xmt_bytes = xmlNanoHTTPSend( ctxt, input, ilen );\n-\n-        if ( xmt_bytes != ilen )\n-            xmlGenericError( xmlGenericErrorContext,\n-                        \"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\\n\",\n-                        xmt_bytes, ilen,\n-                        \"bytes of HTTP content sent to host\",\n-                        ctxt->hostname );\n-#else\n@@ -1513,1 +1499,0 @@\n-#endif\n@@ -1526,3 +1511,0 @@\n-#ifdef DEBUG_HTTP\n-        xmlGenericError(xmlGenericErrorContext, \"<- %s\\n\", p);\n-#endif\n@@ -1534,4 +1516,0 @@\n-#ifdef DEBUG_HTTP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"\\nRedirect to: %s\\n\", ctxt->location);\n-#endif\n@@ -1550,4 +1528,0 @@\n-#ifdef DEBUG_HTTP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNanoHTTPMethodRedir: Too many redirects, aborting ...\\n\");\n-#endif\n@@ -1573,11 +1547,0 @@\n-#ifdef DEBUG_HTTP\n-    if (ctxt->contentType != NULL)\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"\\nCode %d, content-type '%s'\\n\\n\",\n-               ctxt->returnValue, ctxt->contentType);\n-    else\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"\\nCode %d, no content-type\\n\\n\",\n-               ctxt->returnValue);\n-#endif\n-\n@@ -1877,1 +1840,0 @@\n-    xmlMemoryDump();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/nanohttp.c","additions":121,"deletions":159,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include <libxml\/parser.h>\n@@ -55,2 +56,0 @@\n-#include <libxml\/threads.h>\n-#include <libxml\/globals.h>\n@@ -58,1 +57,0 @@\n-#include <libxml\/parser.h>\n@@ -66,0 +64,1 @@\n+#include <libxml\/SAX2.h>\n@@ -69,4 +68,0 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-#include <libxml\/xmlschemastypes.h>\n-#include <libxml\/relaxng.h>\n-#endif\n@@ -74,2 +69,12 @@\n-#include \"buf.h\"\n-#include \"enc.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/dict.h\"\n+#include \"private\/entities.h\"\n+#include \"private\/error.h\"\n+#include \"private\/html.h\"\n+#include \"private\/io.h\"\n+#include \"private\/parser.h\"\n+\n+#define NS_INDEX_EMPTY  INT_MAX\n+#define NS_INDEX_XML    (INT_MAX - 1)\n+#define URI_HASH_EMPTY  0xD943A04E\n+#define URI_HASH_XML    0xF0451F02\n@@ -84,2 +89,7 @@\n-static void\n-xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);\n+typedef struct {\n+    void *saxData;\n+    unsigned prefixHashValue;\n+    unsigned uriHashValue;\n+    unsigned elementId;\n+    int oldIndex;\n+} xmlParserNsExtra;\n@@ -87,3 +97,7 @@\n-static xmlParserCtxtPtr\n-xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,\n-                          const xmlChar *base, xmlParserCtxtPtr pctx);\n+typedef struct {\n+    unsigned hashValue;\n+    int index;\n+} xmlParserNsBucket;\n+\n+struct _xmlParserNsData {\n+    xmlParserNsExtra *extra;\n@@ -91,1 +105,16 @@\n-static void xmlHaltParser(xmlParserCtxtPtr ctxt);\n+    unsigned hashSize;\n+    unsigned hashElems;\n+    xmlParserNsBucket *hash;\n+\n+    unsigned elementId;\n+    int defaultNsIndex;\n+};\n+\n+struct _xmlAttrHashBucket {\n+    int index;\n+};\n+\n+static xmlParserCtxtPtr\n+xmlCreateEntityParserCtxtInternal(xmlSAXHandlerPtr sax, void *userData,\n+        const xmlChar *URL, const xmlChar *ID, const xmlChar *base,\n+        xmlParserCtxtPtr pctx);\n@@ -105,2 +134,0 @@\n-#define XML_MAX_HUGE_LENGTH 1000000000\n-\n@@ -111,4 +138,2 @@\n- * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity\n- *    replacement over the size in byte of the input indicates that you have\n- *    and exponential behaviour. A value of 10 correspond to at least 3 entity\n- *    replacement per byte of input.\n+ * Constants for protection against abusive entity expansion\n+ * (\"billion laughs\").\n@@ -116,1 +141,0 @@\n-#define XML_PARSER_NON_LINEAR 10\n@@ -119,7 +143,1 @@\n- * xmlParserEntityCheck\n- *\n- * Function to check non-linear entity expansion behaviour\n- * This is here to detect and stop exponential linear entity expansion\n- * This is not a limitation of the parser but a safety\n- * boundary feature. It can be disabled with the XML_PARSE_HUGE\n- * parser option.\n+ * A certain amount of entity expansion which is always allowed.\n@@ -127,43 +145,1 @@\n-static int\n-xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,\n-                     xmlEntityPtr ent, size_t replacement)\n-{\n-    size_t consumed = 0;\n-    int i;\n-\n-    if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))\n-        return (0);\n-    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n-        return (1);\n-\n-    \/*\n-     * This may look absurd but is needed to detect\n-     * entities problems\n-     *\/\n-    if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-        (ent->content != NULL) && (ent->checked == 0) &&\n-        (ctxt->errNo != XML_ERR_ENTITY_LOOP)) {\n-        unsigned long oldnbent = ctxt->nbentities, diff;\n-        xmlChar *rep;\n-\n-        ent->checked = 1;\n-\n-        ++ctxt->depth;\n-        rep = xmlStringDecodeEntities(ctxt, ent->content,\n-                                  XML_SUBSTITUTE_REF, 0, 0, 0);\n-        --ctxt->depth;\n-        if ((rep == NULL) || (ctxt->errNo == XML_ERR_ENTITY_LOOP)) {\n-            ent->content[0] = 0;\n-        }\n-\n-        diff = ctxt->nbentities - oldnbent + 1;\n-        if (diff > INT_MAX \/ 2)\n-            diff = INT_MAX \/ 2;\n-        ent->checked = diff * 2;\n-        if (rep != NULL) {\n-            if (xmlStrchr(rep, '<'))\n-                ent->checked |= 1;\n-            xmlFree(rep);\n-            rep = NULL;\n-        }\n-    }\n+#define XML_PARSER_ALLOWED_EXPANSION 1000000\n@@ -171,90 +147,6 @@\n-    \/*\n-     * Prevent entity exponential check, not just replacement while\n-     * parsing the DTD\n-     * The check is potentially costly so do that only once in a thousand\n-     *\/\n-    if ((ctxt->instate == XML_PARSER_DTD) && (ctxt->nbentities > 10000) &&\n-        (ctxt->nbentities % 1024 == 0)) {\n-        for (i = 0;i < ctxt->inputNr;i++) {\n-            consumed += ctxt->inputTab[i]->consumed +\n-                       (ctxt->inputTab[i]->cur - ctxt->inputTab[i]->base);\n-        }\n-        if (ctxt->nbentities > consumed * XML_PARSER_NON_LINEAR) {\n-            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n-            ctxt->instate = XML_PARSER_EOF;\n-            return (1);\n-        }\n-        consumed = 0;\n-    }\n-\n-\n-\n-    if (replacement != 0) {\n-        if (replacement < XML_MAX_TEXT_LENGTH)\n-            return(0);\n-\n-        \/*\n-         * If the volume of entity copy reaches 10 times the\n-         * amount of parsed data and over the large text threshold\n-         * then that's very likely to be an abuse.\n-         *\/\n-        if (ctxt->input != NULL) {\n-            consumed = ctxt->input->consumed +\n-                       (ctxt->input->cur - ctxt->input->base);\n-        }\n-        consumed += ctxt->sizeentities;\n-\n-        if (replacement < XML_PARSER_NON_LINEAR * consumed)\n-            return(0);\n-    } else if (size != 0) {\n-        \/*\n-         * Do the check based on the replacement size of the entity\n-         *\/\n-        if (size < XML_PARSER_BIG_ENTITY)\n-            return(0);\n-\n-        \/*\n-         * A limit on the amount of text data reasonably used\n-         *\/\n-        if (ctxt->input != NULL) {\n-            consumed = ctxt->input->consumed +\n-                (ctxt->input->cur - ctxt->input->base);\n-        }\n-        consumed += ctxt->sizeentities;\n-\n-        if ((size < XML_PARSER_NON_LINEAR * consumed) &&\n-            (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n-            return (0);\n-    } else if (ent != NULL) {\n-        \/*\n-         * use the number of parsed entities in the replacement\n-         *\/\n-        size = ent->checked \/ 2;\n-\n-        \/*\n-         * The amount of data parsed counting entities size only once\n-         *\/\n-        if (ctxt->input != NULL) {\n-            consumed = ctxt->input->consumed +\n-                (ctxt->input->cur - ctxt->input->base);\n-        }\n-        consumed += ctxt->sizeentities;\n-\n-        \/*\n-         * Check the density of entities for the amount of data\n-         * knowing an entity reference will take at least 3 bytes\n-         *\/\n-        if (size * 3 < consumed * XML_PARSER_NON_LINEAR)\n-            return (0);\n-    } else {\n-        \/*\n-         * strange we got no data for checking\n-         *\/\n-        if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&\n-             (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||\n-            (ctxt->nbentities <= 10000))\n-            return (0);\n-    }\n-    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n-    return (1);\n-}\n+\/*\n+ * Fixed cost for each entity reference. This crudely models processing time\n+ * as well to protect, for example, against exponential expansion of empty\n+ * or very short entities.\n+ *\/\n+#define XML_ENT_FIXED_COST 20\n@@ -274,1 +166,0 @@\n-#define SAX2 1\n@@ -290,0 +181,8 @@\n+\/**\n+ * xmlParserVersion:\n+ *\n+ * Constant string describing the internal version of the library\n+ *\/\n+const char *const\n+xmlParserVersion = LIBXML_VERSION_STRING LIBXML_VERSION_EXTRA;\n+\n@@ -312,2 +211,1 @@\n-xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options,\n-                          const char *encoding);\n+xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options);\n@@ -369,216 +267,0 @@\n-\/**\n- * xmlFatalErr:\n- * @ctxt:  an XML parser context\n- * @error:  the error number\n- * @extra:  extra information string\n- *\n- * Handle a fatal parser error, i.e. violating Well-Formedness constraints\n- *\/\n-static void\n-xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info)\n-{\n-    const char *errmsg;\n-\n-    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n-        (ctxt->instate == XML_PARSER_EOF))\n-        return;\n-    switch (error) {\n-        case XML_ERR_INVALID_HEX_CHARREF:\n-            errmsg = \"CharRef: invalid hexadecimal value\";\n-            break;\n-        case XML_ERR_INVALID_DEC_CHARREF:\n-            errmsg = \"CharRef: invalid decimal value\";\n-            break;\n-        case XML_ERR_INVALID_CHARREF:\n-            errmsg = \"CharRef: invalid value\";\n-            break;\n-        case XML_ERR_INTERNAL_ERROR:\n-            errmsg = \"internal error\";\n-            break;\n-        case XML_ERR_PEREF_AT_EOF:\n-            errmsg = \"PEReference at end of document\";\n-            break;\n-        case XML_ERR_PEREF_IN_PROLOG:\n-            errmsg = \"PEReference in prolog\";\n-            break;\n-        case XML_ERR_PEREF_IN_EPILOG:\n-            errmsg = \"PEReference in epilog\";\n-            break;\n-        case XML_ERR_PEREF_NO_NAME:\n-            errmsg = \"PEReference: no name\";\n-            break;\n-        case XML_ERR_PEREF_SEMICOL_MISSING:\n-            errmsg = \"PEReference: expecting ';'\";\n-            break;\n-        case XML_ERR_ENTITY_LOOP:\n-            errmsg = \"Detected an entity reference loop\";\n-            break;\n-        case XML_ERR_ENTITY_NOT_STARTED:\n-            errmsg = \"EntityValue: \\\" or ' expected\";\n-            break;\n-        case XML_ERR_ENTITY_PE_INTERNAL:\n-            errmsg = \"PEReferences forbidden in internal subset\";\n-            break;\n-        case XML_ERR_ENTITY_NOT_FINISHED:\n-            errmsg = \"EntityValue: \\\" or ' expected\";\n-            break;\n-        case XML_ERR_ATTRIBUTE_NOT_STARTED:\n-            errmsg = \"AttValue: \\\" or ' expected\";\n-            break;\n-        case XML_ERR_LT_IN_ATTRIBUTE:\n-            errmsg = \"Unescaped '<' not allowed in attributes values\";\n-            break;\n-        case XML_ERR_LITERAL_NOT_STARTED:\n-            errmsg = \"SystemLiteral \\\" or ' expected\";\n-            break;\n-        case XML_ERR_LITERAL_NOT_FINISHED:\n-            errmsg = \"Unfinished System or Public ID \\\" or ' expected\";\n-            break;\n-        case XML_ERR_MISPLACED_CDATA_END:\n-            errmsg = \"Sequence ']]>' not allowed in content\";\n-            break;\n-        case XML_ERR_URI_REQUIRED:\n-            errmsg = \"SYSTEM or PUBLIC, the URI is missing\";\n-            break;\n-        case XML_ERR_PUBID_REQUIRED:\n-            errmsg = \"PUBLIC, the Public Identifier is missing\";\n-            break;\n-        case XML_ERR_HYPHEN_IN_COMMENT:\n-            errmsg = \"Comment must not contain '--' (double-hyphen)\";\n-            break;\n-        case XML_ERR_PI_NOT_STARTED:\n-            errmsg = \"xmlParsePI : no target name\";\n-            break;\n-        case XML_ERR_RESERVED_XML_NAME:\n-            errmsg = \"Invalid PI name\";\n-            break;\n-        case XML_ERR_NOTATION_NOT_STARTED:\n-            errmsg = \"NOTATION: Name expected here\";\n-            break;\n-        case XML_ERR_NOTATION_NOT_FINISHED:\n-            errmsg = \"'>' required to close NOTATION declaration\";\n-            break;\n-        case XML_ERR_VALUE_REQUIRED:\n-            errmsg = \"Entity value required\";\n-            break;\n-        case XML_ERR_URI_FRAGMENT:\n-            errmsg = \"Fragment not allowed\";\n-            break;\n-        case XML_ERR_ATTLIST_NOT_STARTED:\n-            errmsg = \"'(' required to start ATTLIST enumeration\";\n-            break;\n-        case XML_ERR_NMTOKEN_REQUIRED:\n-            errmsg = \"NmToken expected in ATTLIST enumeration\";\n-            break;\n-        case XML_ERR_ATTLIST_NOT_FINISHED:\n-            errmsg = \"')' required to finish ATTLIST enumeration\";\n-            break;\n-        case XML_ERR_MIXED_NOT_STARTED:\n-            errmsg = \"MixedContentDecl : '|' or ')*' expected\";\n-            break;\n-        case XML_ERR_PCDATA_REQUIRED:\n-            errmsg = \"MixedContentDecl : '#PCDATA' expected\";\n-            break;\n-        case XML_ERR_ELEMCONTENT_NOT_STARTED:\n-            errmsg = \"ContentDecl : Name or '(' expected\";\n-            break;\n-        case XML_ERR_ELEMCONTENT_NOT_FINISHED:\n-            errmsg = \"ContentDecl : ',' '|' or ')' expected\";\n-            break;\n-        case XML_ERR_PEREF_IN_INT_SUBSET:\n-            errmsg =\n-                \"PEReference: forbidden within markup decl in internal subset\";\n-            break;\n-        case XML_ERR_GT_REQUIRED:\n-            errmsg = \"expected '>'\";\n-            break;\n-        case XML_ERR_CONDSEC_INVALID:\n-            errmsg = \"XML conditional section '[' expected\";\n-            break;\n-        case XML_ERR_EXT_SUBSET_NOT_FINISHED:\n-            errmsg = \"Content error in the external subset\";\n-            break;\n-        case XML_ERR_CONDSEC_INVALID_KEYWORD:\n-            errmsg =\n-                \"conditional section INCLUDE or IGNORE keyword expected\";\n-            break;\n-        case XML_ERR_CONDSEC_NOT_FINISHED:\n-            errmsg = \"XML conditional section not closed\";\n-            break;\n-        case XML_ERR_XMLDECL_NOT_STARTED:\n-            errmsg = \"Text declaration '<?xml' required\";\n-            break;\n-        case XML_ERR_XMLDECL_NOT_FINISHED:\n-            errmsg = \"parsing XML declaration: '?>' expected\";\n-            break;\n-        case XML_ERR_EXT_ENTITY_STANDALONE:\n-            errmsg = \"external parsed entities cannot be standalone\";\n-            break;\n-        case XML_ERR_ENTITYREF_SEMICOL_MISSING:\n-            errmsg = \"EntityRef: expecting ';'\";\n-            break;\n-        case XML_ERR_DOCTYPE_NOT_FINISHED:\n-            errmsg = \"DOCTYPE improperly terminated\";\n-            break;\n-        case XML_ERR_LTSLASH_REQUIRED:\n-            errmsg = \"EndTag: '<\/' not found\";\n-            break;\n-        case XML_ERR_EQUAL_REQUIRED:\n-            errmsg = \"expected '='\";\n-            break;\n-        case XML_ERR_STRING_NOT_CLOSED:\n-            errmsg = \"String not closed expecting \\\" or '\";\n-            break;\n-        case XML_ERR_STRING_NOT_STARTED:\n-            errmsg = \"String not started expecting ' or \\\"\";\n-            break;\n-        case XML_ERR_ENCODING_NAME:\n-            errmsg = \"Invalid XML encoding name\";\n-            break;\n-        case XML_ERR_STANDALONE_VALUE:\n-            errmsg = \"standalone accepts only 'yes' or 'no'\";\n-            break;\n-        case XML_ERR_DOCUMENT_EMPTY:\n-            errmsg = \"Document is empty\";\n-            break;\n-        case XML_ERR_DOCUMENT_END:\n-            errmsg = \"Extra content at the end of the document\";\n-            break;\n-        case XML_ERR_NOT_WELL_BALANCED:\n-            errmsg = \"chunk is not well balanced\";\n-            break;\n-        case XML_ERR_EXTRA_CONTENT:\n-            errmsg = \"extra content at the end of well balanced chunk\";\n-            break;\n-        case XML_ERR_VERSION_MISSING:\n-            errmsg = \"Malformed declaration expecting version\";\n-            break;\n-        case XML_ERR_NAME_TOO_LONG:\n-            errmsg = \"Name too long\";\n-            break;\n-#if 0\n-        case:\n-            errmsg = \"\";\n-            break;\n-#endif\n-        default:\n-            errmsg = \"Unregistered error message\";\n-    }\n-    if (ctxt != NULL)\n-        ctxt->errNo = error;\n-    if (info == NULL) {\n-        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,\n-                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, \"%s\\n\",\n-                        errmsg);\n-    } else {\n-        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,\n-                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, \"%s: %s\\n\",\n-                        errmsg, info);\n-    }\n-    if (ctxt != NULL) {\n-        ctxt->wellFormed = 0;\n-        if (ctxt->recovery == 0)\n-            ctxt->disableSAX = 1;\n-    }\n-}\n-\n@@ -621,1 +303,1 @@\n-static void LIBXML_ATTR_FORMAT(3,0)\n+void LIBXML_ATTR_FORMAT(3,0)\n@@ -857,0 +539,84 @@\n+static void\n+xmlSaturatedAdd(unsigned long *dst, unsigned long val) {\n+    if (val > ULONG_MAX - *dst)\n+        *dst = ULONG_MAX;\n+    else\n+        *dst += val;\n+}\n+\n+static void\n+xmlSaturatedAddSizeT(unsigned long *dst, unsigned long val) {\n+    if (val > ULONG_MAX - *dst)\n+        *dst = ULONG_MAX;\n+    else\n+        *dst += val;\n+}\n+\n+\/**\n+ * xmlParserEntityCheck:\n+ * @ctxt:  parser context\n+ * @extra:  sum of unexpanded entity sizes\n+ *\n+ * Check for non-linear entity expansion behaviour.\n+ *\n+ * In some cases like xmlStringDecodeEntities, this function is called\n+ * for each, possibly nested entity and its unexpanded content length.\n+ *\n+ * In other cases like xmlParseReference, it's only called for each\n+ * top-level entity with its unexpanded content length plus the sum of\n+ * the unexpanded content lengths (plus fixed cost) of all nested\n+ * entities.\n+ *\n+ * Summing the unexpanded lengths also adds the length of the reference.\n+ * This is by design. Taking the length of the entity name into account\n+ * discourages attacks that try to waste CPU time with abusively long\n+ * entity names. See test\/recurse\/lol6.xml for example. Each call also\n+ * adds some fixed cost XML_ENT_FIXED_COST to discourage attacks with\n+ * short entities.\n+ *\n+ * Returns 1 on error, 0 on success.\n+ *\/\n+static int\n+xmlParserEntityCheck(xmlParserCtxtPtr ctxt, unsigned long extra)\n+{\n+    unsigned long consumed;\n+    xmlParserInputPtr input = ctxt->input;\n+    xmlEntityPtr entity = input->entity;\n+\n+    \/*\n+     * Compute total consumed bytes so far, including input streams of\n+     * external entities.\n+     *\/\n+    consumed = input->parentConsumed;\n+    if ((entity == NULL) ||\n+        ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+         ((entity->flags & XML_ENT_PARSED) == 0))) {\n+        xmlSaturatedAdd(&consumed, input->consumed);\n+        xmlSaturatedAddSizeT(&consumed, input->cur - input->base);\n+    }\n+    xmlSaturatedAdd(&consumed, ctxt->sizeentities);\n+\n+    \/*\n+     * Add extra cost and some fixed cost.\n+     *\/\n+    xmlSaturatedAdd(&ctxt->sizeentcopy, extra);\n+    xmlSaturatedAdd(&ctxt->sizeentcopy, XML_ENT_FIXED_COST);\n+\n+    \/*\n+     * It's important to always use saturation arithmetic when tracking\n+     * entity sizes to make the size checks reliable. If \"sizeentcopy\"\n+     * overflows, we have to abort.\n+     *\/\n+    if ((ctxt->sizeentcopy > XML_PARSER_ALLOWED_EXPANSION) &&\n+        ((ctxt->sizeentcopy >= ULONG_MAX) ||\n+         (ctxt->sizeentcopy \/ ctxt->maxAmpl > consumed))) {\n+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_LOOP,\n+                       \"Maximum entity amplification factor exceeded, see \"\n+                       \"xmlCtxtSetMaxAmplification.\\n\");\n+        xmlHaltParser(ctxt);\n+        return(1);\n+    }\n+\n+    return(0);\n+}\n+\n@@ -1052,3 +818,0 @@\n-#ifdef LIBXML_DEBUG_RUNTIME\n-            return(1);\n-#else\n@@ -1056,1 +819,0 @@\n-#endif\n@@ -1103,1 +865,5 @@\n-    if ((sax) &&  (sax->initialized == XML_SAX2_MAGIC) &&\n+    \/*\n+     * Only enable SAX2 if there SAX2 element handlers, except when there\n+     * are no element handlers at all.\n+     *\/\n+    if ((sax) && (sax->initialized == XML_SAX2_MAGIC) &&\n@@ -1121,0 +887,9 @@\n+typedef struct {\n+    xmlHashedString prefix;\n+    xmlHashedString name;\n+    xmlHashedString value;\n+    const xmlChar *valueEnd;\n+    int external;\n+    int expandedSize;\n+} xmlDefAttr;\n+\n@@ -1128,1 +903,1 @@\n-    const xmlChar *values[]; \/* array of localname\/prefix\/values\/external *\/\n+    xmlDefAttr attrs[]; \/* array of localname\/prefix\/values\/external *\/\n@@ -1130,1 +905,1 @@\n-    const xmlChar *values[5];\n+    xmlDefAttr attrs[1];\n@@ -1222,1 +997,1 @@\n-        *len = (int) strlen((const char *)ret);\n+        *len = strlen((const char *)ret);\n@@ -1247,3 +1022,6 @@\n-    int len;\n-    const xmlChar *name;\n-    const xmlChar *prefix;\n+    xmlDefAttr *attr;\n+    int len, expandedSize;\n+    xmlHashedString name;\n+    xmlHashedString prefix;\n+    xmlHashedString hvalue;\n+    const xmlChar *localname;\n@@ -1269,4 +1047,4 @@\n-    name = xmlSplitQName3(fullname, &len);\n-    if (name == NULL) {\n-        name = xmlDictLookup(ctxt->dict, fullname, -1);\n-        prefix = NULL;\n+    localname = xmlSplitQName3(fullname, &len);\n+    if (localname == NULL) {\n+        name = xmlDictLookupHashed(ctxt->dict, fullname, -1);\n+        prefix.name = NULL;\n@@ -1274,2 +1052,4 @@\n-        name = xmlDictLookup(ctxt->dict, name, -1);\n-        prefix = xmlDictLookup(ctxt->dict, fullname, len);\n+        name = xmlDictLookupHashed(ctxt->dict, localname, -1);\n+        prefix = xmlDictLookupHashed(ctxt->dict, fullname, len);\n+        if (prefix.name == NULL)\n+            goto mem_error;\n@@ -1277,0 +1057,2 @@\n+    if (name.name == NULL)\n+        goto mem_error;\n@@ -1281,14 +1063,3 @@\n-    defaults = xmlHashLookup2(ctxt->attsDefault, name, prefix);\n-    if (defaults == NULL) {\n-        defaults = (xmlDefAttrsPtr) xmlMalloc(sizeof(xmlDefAttrs) +\n-                           (4 * 5) * sizeof(const xmlChar *));\n-        if (defaults == NULL)\n-            goto mem_error;\n-        defaults->nbAttrs = 0;\n-        defaults->maxAttrs = 4;\n-        if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,\n-                                defaults, NULL) < 0) {\n-            xmlFree(defaults);\n-            goto mem_error;\n-        }\n-    } else if (defaults->nbAttrs >= defaults->maxAttrs) {\n+    defaults = xmlHashLookup2(ctxt->attsDefault, name.name, prefix.name);\n+    if ((defaults == NULL) ||\n+        (defaults->nbAttrs >= defaults->maxAttrs)) {\n@@ -1296,0 +1067,1 @@\n+        int newSize;\n@@ -1297,2 +1069,3 @@\n-        temp = (xmlDefAttrsPtr) xmlRealloc(defaults, sizeof(xmlDefAttrs) +\n-                       (2 * defaults->maxAttrs * 5) * sizeof(const xmlChar *));\n+        newSize = (defaults != NULL) ? 2 * defaults->maxAttrs : 4;\n+        temp = xmlRealloc(defaults,\n+                          sizeof(*defaults) + newSize * sizeof(xmlDefAttr));\n@@ -1301,0 +1074,3 @@\n+        if (defaults == NULL)\n+            temp->nbAttrs = 0;\n+        temp->maxAttrs = newSize;\n@@ -1302,2 +1078,1 @@\n-        defaults->maxAttrs *= 2;\n-        if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,\n+        if (xmlHashUpdateEntry2(ctxt->attsDefault, name.name, prefix.name,\n@@ -1311,1 +1086,1 @@\n-     * Split the element name into prefix:localname , the string found\n+     * Split the attribute name into prefix:localname , the string found\n@@ -1314,4 +1089,4 @@\n-    name = xmlSplitQName3(fullattr, &len);\n-    if (name == NULL) {\n-        name = xmlDictLookup(ctxt->dict, fullattr, -1);\n-        prefix = NULL;\n+    localname = xmlSplitQName3(fullattr, &len);\n+    if (localname == NULL) {\n+        name = xmlDictLookupHashed(ctxt->dict, fullattr, -1);\n+        prefix.name = NULL;\n@@ -1319,2 +1094,4 @@\n-        name = xmlDictLookup(ctxt->dict, name, -1);\n-        prefix = xmlDictLookup(ctxt->dict, fullattr, len);\n+        name = xmlDictLookupHashed(ctxt->dict, localname, -1);\n+        prefix = xmlDictLookupHashed(ctxt->dict, fullattr, len);\n+        if (prefix.name == NULL)\n+            goto mem_error;\n@@ -1322,0 +1099,2 @@\n+    if (name.name == NULL)\n+        goto mem_error;\n@@ -1323,2 +1102,0 @@\n-    defaults->values[5 * defaults->nbAttrs] = name;\n-    defaults->values[5 * defaults->nbAttrs + 1] = prefix;\n@@ -1326,9 +1103,17 @@\n-    len = xmlStrlen(value);\n-    value = xmlDictLookup(ctxt->dict, value, len);\n-    defaults->values[5 * defaults->nbAttrs + 2] = value;\n-    defaults->values[5 * defaults->nbAttrs + 3] = value + len;\n-    if (ctxt->external)\n-        defaults->values[5 * defaults->nbAttrs + 4] = BAD_CAST \"external\";\n-    else\n-        defaults->values[5 * defaults->nbAttrs + 4] = NULL;\n-    defaults->nbAttrs++;\n+    len = strlen((const char *) value);\n+    hvalue = xmlDictLookupHashed(ctxt->dict, value, len);\n+    if (hvalue.name == NULL)\n+        goto mem_error;\n+\n+    expandedSize = strlen((const char *) name.name);\n+    if (prefix.name != NULL)\n+        expandedSize += strlen((const char *) prefix.name);\n+    expandedSize += len;\n+\n+    attr = &defaults->attrs[defaults->nbAttrs++];\n+    attr->name = name;\n+    attr->prefix = prefix;\n+    attr->value = hvalue;\n+    attr->valueEnd = hvalue.name + len;\n+    attr->external = ctxt->external;\n+    attr->expandedSize = expandedSize;\n@@ -1419,0 +1204,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -1618,1 +1405,0 @@\n-#ifdef SAX2\n@@ -1620,4 +1406,1 @@\n- * nsPush:\n- * @ctxt:  an XML parser context\n- * @prefix:  the namespace prefix or NULL\n- * @URL:  the namespace name\n+ * xmlParserNsCreate:\n@@ -1625,1 +1408,1 @@\n- * Pushes a new parser namespace on top of the ns stack\n+ * Create a new namespace database.\n@@ -1627,2 +1410,1 @@\n- * Returns -1 in case of error, -2 if the namespace should be discarded\n- *         and the index in the stack otherwise.\n+ * Returns the new obejct.\n@@ -1630,40 +1412,10 @@\n-static int\n-nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL)\n-{\n-    if (ctxt->options & XML_PARSE_NSCLEAN) {\n-        int i;\n-        for (i = ctxt->nsNr - 2;i >= 0;i -= 2) {\n-            if (ctxt->nsTab[i] == prefix) {\n-                \/* in scope *\/\n-                if (ctxt->nsTab[i + 1] == URL)\n-                    return(-2);\n-                \/* out of scope keep it *\/\n-                break;\n-            }\n-        }\n-    }\n-    if ((ctxt->nsMax == 0) || (ctxt->nsTab == NULL)) {\n-        ctxt->nsMax = 10;\n-        ctxt->nsNr = 0;\n-        ctxt->nsTab = (const xmlChar **)\n-                      xmlMalloc(ctxt->nsMax * sizeof(xmlChar *));\n-        if (ctxt->nsTab == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            ctxt->nsMax = 0;\n-            return (-1);\n-        }\n-    } else if (ctxt->nsNr >= ctxt->nsMax) {\n-        const xmlChar ** tmp;\n-        ctxt->nsMax *= 2;\n-        tmp = (const xmlChar **) xmlRealloc((char *) ctxt->nsTab,\n-                                    ctxt->nsMax * sizeof(ctxt->nsTab[0]));\n-        if (tmp == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            ctxt->nsMax \/= 2;\n-            return (-1);\n-        }\n-        ctxt->nsTab = tmp;\n-    }\n-    ctxt->nsTab[ctxt->nsNr++] = prefix;\n-    ctxt->nsTab[ctxt->nsNr++] = URL;\n-    return (ctxt->nsNr);\n+xmlParserNsData *\n+xmlParserNsCreate(void) {\n+    xmlParserNsData *nsdb = xmlMalloc(sizeof(*nsdb));\n+\n+    if (nsdb == NULL)\n+        return(NULL);\n+    memset(nsdb, 0, sizeof(*nsdb));\n+    nsdb->defaultNsIndex = INT_MAX;\n+\n+    return(nsdb);\n@@ -1671,0 +1423,1 @@\n+\n@@ -1672,5 +1425,2 @@\n- * nsPop:\n- * @ctxt: an XML parser context\n- * @nr:  the number to pop\n- *\n- * Pops the top @nr parser prefix\/namespace from the ns stack\n+ * xmlParserNsFree:\n+ * @nsdb: namespace database\n@@ -1678,1 +1428,1 @@\n- * Returns the number of namespaces removed\n+ * Free a namespace database.\n@@ -1680,12 +1430,4 @@\n-static int\n-nsPop(xmlParserCtxtPtr ctxt, int nr)\n-{\n-    int i;\n-\n-    if (ctxt->nsTab == NULL) return(0);\n-    if (ctxt->nsNr < nr) {\n-        xmlGenericError(xmlGenericErrorContext, \"Pbm popping %d NS\\n\", nr);\n-        nr = ctxt->nsNr;\n-    }\n-    if (ctxt->nsNr <= 0)\n-        return (0);\n+void\n+xmlParserNsFree(xmlParserNsData *nsdb) {\n+    if (nsdb == NULL)\n+        return;\n@@ -1693,5 +1435,417 @@\n-    for (i = 0;i < nr;i++) {\n-         ctxt->nsNr--;\n-         ctxt->nsTab[ctxt->nsNr] = NULL;\n-    }\n-    return(nr);\n+    xmlFree(nsdb->extra);\n+    xmlFree(nsdb->hash);\n+    xmlFree(nsdb);\n+}\n+\n+\/**\n+ * xmlParserNsReset:\n+ * @nsdb: namespace database\n+ *\n+ * Reset a namespace database.\n+ *\/\n+static void\n+xmlParserNsReset(xmlParserNsData *nsdb) {\n+    if (nsdb == NULL)\n+        return;\n+\n+    nsdb->hashElems = 0;\n+    nsdb->elementId = 0;\n+    nsdb->defaultNsIndex = INT_MAX;\n+\n+    if (nsdb->hash)\n+        memset(nsdb->hash, 0, nsdb->hashSize * sizeof(nsdb->hash[0]));\n+}\n+\n+\/**\n+ * xmlParserStartElement:\n+ * @nsdb: namespace database\n+ *\n+ * Signal that a new element has started.\n+ *\n+ * Returns 0 on success, -1 if the element counter overflowed.\n+ *\/\n+static int\n+xmlParserNsStartElement(xmlParserNsData *nsdb) {\n+    if (nsdb->elementId == UINT_MAX)\n+        return(-1);\n+    nsdb->elementId++;\n+\n+    return(0);\n+}\n+\n+\/**\n+ * xmlParserNsLookup:\n+ * @ctxt: parser context\n+ * @prefix: namespace prefix\n+ * @bucketPtr: optional bucket (return value)\n+ *\n+ * Lookup namespace with given prefix. If @bucketPtr is non-NULL, it will\n+ * be set to the matching bucket, or the first empty bucket if no match\n+ * was found.\n+ *\n+ * Returns the namespace index on success, INT_MAX if no namespace was\n+ * found.\n+ *\/\n+static int\n+xmlParserNsLookup(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix,\n+                  xmlParserNsBucket **bucketPtr) {\n+    xmlParserNsBucket *bucket;\n+    unsigned index, hashValue;\n+\n+    if (prefix->name == NULL)\n+        return(ctxt->nsdb->defaultNsIndex);\n+\n+    if (ctxt->nsdb->hashSize == 0)\n+        return(INT_MAX);\n+\n+    hashValue = prefix->hashValue;\n+    index = hashValue & (ctxt->nsdb->hashSize - 1);\n+    bucket = &ctxt->nsdb->hash[index];\n+\n+    while (bucket->hashValue) {\n+        if ((bucket->hashValue == hashValue) &&\n+            (bucket->index != INT_MAX)) {\n+            if (ctxt->nsTab[bucket->index * 2] == prefix->name) {\n+                if (bucketPtr != NULL)\n+                    *bucketPtr = bucket;\n+                return(bucket->index);\n+            }\n+        }\n+\n+        index++;\n+        bucket++;\n+        if (index == ctxt->nsdb->hashSize) {\n+            index = 0;\n+            bucket = ctxt->nsdb->hash;\n+        }\n+    }\n+\n+    if (bucketPtr != NULL)\n+        *bucketPtr = bucket;\n+    return(INT_MAX);\n+}\n+\n+\/**\n+ * xmlParserNsLookupUri:\n+ * @ctxt: parser context\n+ * @prefix: namespace prefix\n+ *\n+ * Lookup namespace URI with given prefix.\n+ *\n+ * Returns the namespace URI on success, NULL if no namespace was found.\n+ *\/\n+static const xmlChar *\n+xmlParserNsLookupUri(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix) {\n+    const xmlChar *ret;\n+    int nsIndex;\n+\n+    if (prefix->name == ctxt->str_xml)\n+        return(ctxt->str_xml_ns);\n+\n+    nsIndex = xmlParserNsLookup(ctxt, prefix, NULL);\n+    if (nsIndex == INT_MAX)\n+        return(NULL);\n+\n+    ret = ctxt->nsTab[nsIndex * 2 + 1];\n+    if (ret[0] == 0)\n+        ret = NULL;\n+    return(ret);\n+}\n+\n+\/**\n+ * xmlParserNsLookupSax:\n+ * @ctxt: parser context\n+ * @prefix: namespace prefix\n+ *\n+ * Lookup extra data for the given prefix. This returns data stored\n+ * with xmlParserNsUdpateSax.\n+ *\n+ * Returns the data on success, NULL if no namespace was found.\n+ *\/\n+void *\n+xmlParserNsLookupSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {\n+    xmlHashedString hprefix;\n+    int nsIndex;\n+\n+    if (prefix == ctxt->str_xml)\n+        return(NULL);\n+\n+    hprefix.name = prefix;\n+    if (prefix != NULL)\n+        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);\n+    else\n+        hprefix.hashValue = 0;\n+    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);\n+    if (nsIndex == INT_MAX)\n+        return(NULL);\n+\n+    return(ctxt->nsdb->extra[nsIndex].saxData);\n+}\n+\n+\/**\n+ * xmlParserNsUpdateSax:\n+ * @ctxt: parser context\n+ * @prefix: namespace prefix\n+ * @saxData: extra data for SAX handler\n+ *\n+ * Sets or updates extra data for the given prefix. This value will be\n+ * returned by xmlParserNsLookupSax as long as the namespace with the\n+ * given prefix is in scope.\n+ *\n+ * Returns the data on success, NULL if no namespace was found.\n+ *\/\n+int\n+xmlParserNsUpdateSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n+                     void *saxData) {\n+    xmlHashedString hprefix;\n+    int nsIndex;\n+\n+    if (prefix == ctxt->str_xml)\n+        return(-1);\n+\n+    hprefix.name = prefix;\n+    if (prefix != NULL)\n+        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);\n+    else\n+        hprefix.hashValue = 0;\n+    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);\n+    if (nsIndex == INT_MAX)\n+        return(-1);\n+\n+    ctxt->nsdb->extra[nsIndex].saxData = saxData;\n+    return(0);\n+}\n+\n+\/**\n+ * xmlParserNsGrow:\n+ * @ctxt: parser context\n+ *\n+ * Grows the namespace tables.\n+ *\n+ * Returns 0 on success, -1 if a memory allocation failed.\n+ *\/\n+static int\n+xmlParserNsGrow(xmlParserCtxtPtr ctxt) {\n+    const xmlChar **table;\n+    xmlParserNsExtra *extra;\n+    int newSize;\n+\n+    if (ctxt->nsMax > INT_MAX \/ 2)\n+        goto error;\n+    newSize = ctxt->nsMax ? ctxt->nsMax * 2 : 16;\n+\n+    table = xmlRealloc(ctxt->nsTab, 2 * newSize * sizeof(table[0]));\n+    if (table == NULL)\n+        goto error;\n+    ctxt->nsTab = table;\n+\n+    extra = xmlRealloc(ctxt->nsdb->extra, newSize * sizeof(extra[0]));\n+    if (extra == NULL)\n+        goto error;\n+    ctxt->nsdb->extra = extra;\n+\n+    ctxt->nsMax = newSize;\n+    return(0);\n+\n+error:\n+    xmlErrMemory(ctxt, NULL);\n+    return(-1);\n+}\n+\n+\/**\n+ * xmlParserNsPush:\n+ * @ctxt: parser context\n+ * @prefix: prefix with hash value\n+ * @uri: uri with hash value\n+ * @saxData: extra data for SAX handler\n+ * @defAttr: whether the namespace comes from a default attribute\n+ *\n+ * Push a new namespace on the table.\n+ *\n+ * Returns 1 if the namespace was pushed, 0 if the namespace was ignored,\n+ * -1 if a memory allocation failed.\n+ *\/\n+static int\n+xmlParserNsPush(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix,\n+                const xmlHashedString *uri, void *saxData, int defAttr) {\n+    xmlParserNsBucket *bucket = NULL;\n+    xmlParserNsExtra *extra;\n+    const xmlChar **ns;\n+    unsigned hashValue, nsIndex, oldIndex;\n+\n+    if ((prefix != NULL) && (prefix->name == ctxt->str_xml))\n+        return(0);\n+\n+    if ((ctxt->nsNr >= ctxt->nsMax) && (xmlParserNsGrow(ctxt) < 0)) {\n+        xmlErrMemory(ctxt, NULL);\n+        return(-1);\n+    }\n+\n+    \/*\n+     * Default namespace and 'xml' namespace\n+     *\/\n+    if ((prefix == NULL) || (prefix->name == NULL)) {\n+        oldIndex = ctxt->nsdb->defaultNsIndex;\n+\n+        if (oldIndex != INT_MAX) {\n+            extra = &ctxt->nsdb->extra[oldIndex];\n+\n+            if (extra->elementId == ctxt->nsdb->elementId) {\n+                if (defAttr == 0)\n+                    xmlErrAttributeDup(ctxt, NULL, BAD_CAST \"xmlns\");\n+                return(0);\n+            }\n+\n+            if ((ctxt->options & XML_PARSE_NSCLEAN) &&\n+                (uri->name == ctxt->nsTab[oldIndex * 2 + 1]))\n+                return(0);\n+        }\n+\n+        ctxt->nsdb->defaultNsIndex = ctxt->nsNr;\n+        goto populate_entry;\n+    }\n+\n+    \/*\n+     * Hash table lookup\n+     *\/\n+    oldIndex = xmlParserNsLookup(ctxt, prefix, &bucket);\n+    if (oldIndex != INT_MAX) {\n+        extra = &ctxt->nsdb->extra[oldIndex];\n+\n+        \/*\n+         * Check for duplicate definitions on the same element.\n+         *\/\n+        if (extra->elementId == ctxt->nsdb->elementId) {\n+            if (defAttr == 0)\n+                xmlErrAttributeDup(ctxt, BAD_CAST \"xmlns\", prefix->name);\n+            return(0);\n+        }\n+\n+        if ((ctxt->options & XML_PARSE_NSCLEAN) &&\n+            (uri->name == ctxt->nsTab[bucket->index * 2 + 1]))\n+            return(0);\n+\n+        bucket->index = ctxt->nsNr;\n+        goto populate_entry;\n+    }\n+\n+    \/*\n+     * Insert new bucket\n+     *\/\n+\n+    hashValue = prefix->hashValue;\n+\n+    \/*\n+     * Grow hash table, 50% fill factor\n+     *\/\n+    if (ctxt->nsdb->hashElems + 1 > ctxt->nsdb->hashSize \/ 2) {\n+        xmlParserNsBucket *newHash;\n+        unsigned newSize, i, index;\n+\n+        if (ctxt->nsdb->hashSize > UINT_MAX \/ 2) {\n+            xmlErrMemory(ctxt, NULL);\n+            return(-1);\n+        }\n+        newSize = ctxt->nsdb->hashSize ? ctxt->nsdb->hashSize * 2 : 16;\n+        newHash = xmlMalloc(newSize * sizeof(newHash[0]));\n+        if (newHash == NULL) {\n+            xmlErrMemory(ctxt, NULL);\n+            return(-1);\n+        }\n+        memset(newHash, 0, newSize * sizeof(newHash[0]));\n+\n+        for (i = 0; i < ctxt->nsdb->hashSize; i++) {\n+            unsigned hv = ctxt->nsdb->hash[i].hashValue;\n+            unsigned newIndex;\n+\n+            if (hv == 0)\n+                continue;\n+            newIndex = hv & (newSize - 1);\n+\n+            while (newHash[newIndex].hashValue != 0) {\n+                newIndex++;\n+                if (newIndex == newSize)\n+                    newIndex = 0;\n+            }\n+\n+            newHash[newIndex] = ctxt->nsdb->hash[i];\n+        }\n+\n+        xmlFree(ctxt->nsdb->hash);\n+        ctxt->nsdb->hash = newHash;\n+        ctxt->nsdb->hashSize = newSize;\n+\n+        \/*\n+         * Relookup\n+         *\/\n+        index = hashValue & (newSize - 1);\n+\n+        while (newHash[index].hashValue != 0) {\n+            index++;\n+            if (index == newSize)\n+                index = 0;\n+        }\n+\n+        bucket = &newHash[index];\n+    }\n+\n+    bucket->hashValue = hashValue;\n+    bucket->index = ctxt->nsNr;\n+    ctxt->nsdb->hashElems++;\n+    oldIndex = INT_MAX;\n+\n+populate_entry:\n+    nsIndex = ctxt->nsNr;\n+\n+    ns = &ctxt->nsTab[nsIndex * 2];\n+    ns[0] = prefix ? prefix->name : NULL;\n+    ns[1] = uri->name;\n+\n+    extra = &ctxt->nsdb->extra[nsIndex];\n+    extra->saxData = saxData;\n+    extra->prefixHashValue = prefix ? prefix->hashValue : 0;\n+    extra->uriHashValue = uri->hashValue;\n+    extra->elementId = ctxt->nsdb->elementId;\n+    extra->oldIndex = oldIndex;\n+\n+    ctxt->nsNr++;\n+\n+    return(1);\n+}\n+\n+\/**\n+ * xmlParserNsPop:\n+ * @ctxt: an XML parser context\n+ * @nr:  the number to pop\n+ *\n+ * Pops the top @nr namespaces and restores the hash table.\n+ *\n+ * Returns the number of namespaces popped.\n+ *\/\n+static int\n+xmlParserNsPop(xmlParserCtxtPtr ctxt, int nr)\n+{\n+    int i;\n+\n+    \/* assert(nr <= ctxt->nsNr); *\/\n+\n+    for (i = ctxt->nsNr - 1; i >= ctxt->nsNr - nr; i--) {\n+        const xmlChar *prefix = ctxt->nsTab[i * 2];\n+        xmlParserNsExtra *extra = &ctxt->nsdb->extra[i];\n+\n+        if (prefix == NULL) {\n+            ctxt->nsdb->defaultNsIndex = extra->oldIndex;\n+        } else {\n+            xmlHashedString hprefix;\n+            xmlParserNsBucket *bucket = NULL;\n+\n+            hprefix.name = prefix;\n+            hprefix.hashValue = extra->prefixHashValue;\n+            xmlParserNsLookup(ctxt, &hprefix, &bucket);\n+            \/* assert(bucket && bucket->hashValue); *\/\n+            bucket->index = extra->oldIndex;\n+        }\n+    }\n+\n+    ctxt->nsNr -= nr;\n+    return(nr);\n@@ -1699,1 +1853,0 @@\n-#endif\n@@ -1704,1 +1857,1 @@\n-    int *attallocs;\n+    unsigned *attallocs;\n@@ -1707,13 +1860,3 @@\n-    if (ctxt->atts == NULL) {\n-        maxatts = 55; \/* allow for 10 attrs by default *\/\n-        atts = (const xmlChar **)\n-               xmlMalloc(maxatts * sizeof(xmlChar *));\n-        if (atts == NULL) goto mem_error;\n-        ctxt->atts = atts;\n-        attallocs = (int *) xmlMalloc((maxatts \/ 5) * sizeof(int));\n-        if (attallocs == NULL) goto mem_error;\n-        ctxt->attallocs = attallocs;\n-        ctxt->maxatts = maxatts;\n-    } else if (nr + 5 > ctxt->maxatts) {\n-        maxatts = (nr + 5) * 2;\n-        atts = (const xmlChar **) xmlRealloc((void *) ctxt->atts,\n+    if (nr + 5 > ctxt->maxatts) {\n+        maxatts = ctxt->maxatts == 0 ? 55 : (nr + 5) * 2;\n+        atts = (const xmlChar **) xmlMalloc(\n@@ -1722,0 +1865,9 @@\n+        attallocs = xmlRealloc(ctxt->attallocs,\n+                               (maxatts \/ 5) * sizeof(attallocs[0]));\n+        if (attallocs == NULL) {\n+            xmlFree(atts);\n+            goto mem_error;\n+        }\n+        if (ctxt->maxatts > 0)\n+            memcpy(atts, ctxt->atts, ctxt->maxatts * sizeof(const xmlChar *));\n+        xmlFree(ctxt->atts);\n@@ -1723,3 +1875,0 @@\n-        attallocs = (int *) xmlRealloc((void *) ctxt->attallocs,\n-                                     (maxatts \/ 5) * sizeof(int));\n-        if (attallocs == NULL) goto mem_error;\n@@ -1750,6 +1899,6 @@\n-        ctxt->inputMax *= 2;\n-        ctxt->inputTab =\n-            (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,\n-                                             ctxt->inputMax *\n-                                             sizeof(ctxt->inputTab[0]));\n-        if (ctxt->inputTab == NULL) {\n+        size_t newSize = ctxt->inputMax * 2;\n+        xmlParserInputPtr *tmp;\n+\n+        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,\n+                                               newSize * sizeof(*tmp));\n+        if (tmp == NULL) {\n@@ -1757,1 +1906,0 @@\n-            ctxt->inputMax \/= 2;\n@@ -1760,0 +1908,2 @@\n+        ctxt->inputTab = tmp;\n+        ctxt->inputMax = newSize;\n@@ -1796,0 +1946,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -1834,0 +1986,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -1945,0 +2099,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -1972,0 +2128,1 @@\n+\n@@ -1976,0 +2133,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -2091,1 +2250,1 @@\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);                   \\\n+        xmlParserGrow(ctxt);                                            \\\n@@ -2103,1 +2262,1 @@\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);                   \\\n+        xmlParserGrow(ctxt);                                            \\\n@@ -2106,14 +2265,6 @@\n-#define SHRINK if ((ctxt->progressive == 0) &&                          \\\n-                   (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \\\n-                   (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n-        xmlSHRINK (ctxt);\n-\n-static void xmlSHRINK (xmlParserCtxtPtr ctxt) {\n-    xmlParserInputShrink(ctxt->input);\n-    if (*ctxt->input->cur == 0)\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-}\n-\n-#define GROW if ((ctxt->progressive == 0) &&                            \\\n-                 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))   \\\n-        xmlGROW (ctxt);\n+\/* Don't shrink push parser buffer. *\/\n+#define SHRINK \\\n+    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \\\n+        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \\\n+        (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n+        xmlParserShrink(ctxt);\n@@ -2121,23 +2272,2 @@\n-static void xmlGROW (xmlParserCtxtPtr ctxt) {\n-    ptrdiff_t curEnd = ctxt->input->end - ctxt->input->cur;\n-    ptrdiff_t curBase = ctxt->input->cur - ctxt->input->base;\n-\n-    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||\n-         (curBase > XML_MAX_LOOKUP_LIMIT)) &&\n-         ((ctxt->input->buf) &&\n-          (ctxt->input->buf->readcallback != xmlInputReadCallbackNop)) &&\n-        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n-        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n-        xmlHaltParser(ctxt);\n-        return;\n-    }\n-    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-    if ((ctxt->input->cur > ctxt->input->end) ||\n-        (ctxt->input->cur < ctxt->input->base)) {\n-        xmlHaltParser(ctxt);\n-        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"cur index out of bound\");\n-        return;\n-    }\n-    if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0))\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-}\n+#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)     \\\n+        xmlParserGrow(ctxt);\n@@ -2153,1 +2283,1 @@\n-            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);               \\\n+            xmlParserGrow(ctxt);                                                \\\n@@ -2166,2 +2296,2 @@\n-#define COPY_BUF(l,b,i,v)                                               \\\n-    if (l == 1) b[i++] = (xmlChar) v;                                   \\\n+#define COPY_BUF(b, i, v)                                               \\\n+    if (v < 0x80) b[i++] = v;                                           \\\n@@ -2170,3 +2300,0 @@\n-#define CUR_CONSUMED \\\n-    (ctxt->input->consumed + (ctxt->input->cur - ctxt->input->base))\n-\n@@ -2177,0 +2304,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -2209,1 +2338,1 @@\n-                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                xmlParserGrow(ctxt);\n@@ -2217,1 +2346,1 @@\n-        while (1) {\n+        while (ctxt->instate != XML_PARSER_EOF) {\n@@ -2228,0 +2357,3 @@\n+                unsigned long consumed;\n+                xmlEntityPtr ent;\n+\n@@ -2230,0 +2362,19 @@\n+\n+                consumed = ctxt->input->consumed;\n+                xmlSaturatedAddSizeT(&consumed,\n+                                     ctxt->input->cur - ctxt->input->base);\n+\n+                \/*\n+                 * Add to sizeentities when parsing an external entity\n+                 * for the first time.\n+                 *\/\n+                ent = ctxt->input->entity;\n+                if ((ent->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+                    ((ent->flags & XML_ENT_PARSED) == 0)) {\n+                    ent->flags |= XML_ENT_PARSED;\n+\n+                    xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n+                }\n+\n+                xmlParserEntityCheck(ctxt, consumed);\n+\n@@ -2266,0 +2417,2 @@\n+    xmlParserInputPtr input;\n+\n@@ -2274,1 +2427,4 @@\n-    xmlFreeInputStream(inputPop(ctxt));\n+    input = inputPop(ctxt);\n+    if (input->entity != NULL)\n+        input->entity->flags &= ~XML_ENT_EXPANDING;\n+    xmlFreeInputStream(input);\n@@ -2276,1 +2432,1 @@\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        xmlParserGrow(ctxt);\n@@ -2303,1 +2459,1 @@\n-        (ctxt->inputNr > 1024)) {\n+        (ctxt->inputNr > 100)) {\n@@ -2320,1 +2476,3 @@\n- * parse Reference declarations\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse a numeric character reference. Always consumes '&'.\n@@ -2401,0 +2559,2 @@\n+        if (RAW == '&')\n+            SKIP(1);\n@@ -2521,0 +2681,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -2565,0 +2727,1 @@\n+        case XML_PARSER_XML_DECL:\n@@ -2624,1 +2787,1 @@\n- * xmlStringLenDecodeEntities:\n+ * xmlStringDecodeEntitiesInt:\n@@ -2632,9 +2795,1 @@\n- *\n- * Takes a entity string content and process to do the adequate substitutions.\n- *\n- * [67] Reference ::= EntityRef | CharRef\n- *\n- * [69] PEReference ::= '%' Name ';'\n- *\n- * Returns A newly allocated string with the substitution done. The caller\n- *      must deallocate it !\n+ * @check:  whether to perform entity checks\n@@ -2642,3 +2797,4 @@\n-xmlChar *\n-xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n-                      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n+static xmlChar *\n+xmlStringDecodeEntitiesInt(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n+                           int what, xmlChar end, xmlChar  end2, xmlChar end3,\n+                           int check) {\n@@ -2655,1 +2811,1 @@\n-    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n+    if (str == NULL)\n@@ -2661,2 +2817,3 @@\n-        (ctxt->depth > 1024)) {\n-        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+        (ctxt->depth > 100)) {\n+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_LOOP,\n+                       \"Maximum entity nesting depth exceeded\");\n@@ -2690,1 +2847,1 @@\n-            COPY_BUF(0,buffer,nbchars,val);\n+            COPY_BUF(buffer, nbchars, val);\n@@ -2700,3 +2857,0 @@\n-            xmlParserEntityCheck(ctxt, 0, ent, 0);\n-            if (ent != NULL)\n-                ctxt->nbentities += ent->checked \/ 2;\n@@ -2706,1 +2860,1 @@\n-                    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n+                    COPY_BUF(buffer, nbchars, ent->content[0]);\n@@ -2716,0 +2870,11 @@\n+                if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))\n+                    goto int_error;\n+\n+                if (ent->flags & XML_ENT_EXPANDING) {\n+                    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+                    xmlHaltParser(ctxt);\n+                    ent->content[0] = 0;\n+                    goto int_error;\n+                }\n+\n+                ent->flags |= XML_ENT_EXPANDING;\n@@ -2717,2 +2882,2 @@\n-                rep = xmlStringDecodeEntities(ctxt, ent->content, what,\n-                                              0, 0, 0);\n+                rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,\n+                        ent->length, what, 0, 0, 0, check);\n@@ -2720,0 +2885,2 @@\n+                ent->flags &= ~XML_ENT_EXPANDING;\n+\n@@ -2729,2 +2896,0 @@\n-                        if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n-                            goto int_error;\n@@ -2753,3 +2918,0 @@\n-            xmlParserEntityCheck(ctxt, 0, ent, 0);\n-            if (ent != NULL)\n-                ctxt->nbentities += ent->checked \/ 2;\n@@ -2774,7 +2936,22 @@\n-                ctxt->depth++;\n-                rep = xmlStringDecodeEntities(ctxt, ent->content, what,\n-                                              0, 0, 0);\n-                ctxt->depth--;\n-                if (rep == NULL) {\n-                    if (ent->content != NULL)\n-                        ent->content[0] = 0;\n+\n+                if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))\n+                    goto int_error;\n+\n+                if (ent->flags & XML_ENT_EXPANDING) {\n+                    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+                    xmlHaltParser(ctxt);\n+                    if (ent->content != NULL)\n+                        ent->content[0] = 0;\n+                    goto int_error;\n+                }\n+\n+                ent->flags |= XML_ENT_EXPANDING;\n+                ctxt->depth++;\n+                rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,\n+                        ent->length, what, 0, 0, 0, check);\n+                ctxt->depth--;\n+                ent->flags &= ~XML_ENT_EXPANDING;\n+\n+                if (rep == NULL) {\n+                    if (ent->content != NULL)\n+                        ent->content[0] = 0;\n@@ -2787,2 +2964,0 @@\n-                        if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n-                            goto int_error;\n@@ -2796,1 +2971,1 @@\n-            COPY_BUF(l,buffer,nbchars,c);\n+            COPY_BUF(buffer, nbchars, c);\n@@ -2820,0 +2995,31 @@\n+\/**\n+ * xmlStringLenDecodeEntities:\n+ * @ctxt:  the parser context\n+ * @str:  the input string\n+ * @len: the string length\n+ * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF\n+ * @end:  an end marker xmlChar, 0 if none\n+ * @end2:  an end marker xmlChar, 0 if none\n+ * @end3:  an end marker xmlChar, 0 if none\n+ *\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Takes a entity string content and process to do the adequate substitutions.\n+ *\n+ * [67] Reference ::= EntityRef | CharRef\n+ *\n+ * [69] PEReference ::= '%' Name ';'\n+ *\n+ * Returns A newly allocated string with the substitution done. The caller\n+ *      must deallocate it !\n+ *\/\n+xmlChar *\n+xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n+                           int what, xmlChar end, xmlChar  end2,\n+                           xmlChar end3) {\n+    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n+        return(NULL);\n+    return(xmlStringDecodeEntitiesInt(ctxt, str, len, what,\n+                                      end, end2, end3, 0));\n+}\n+\n@@ -2829,0 +3035,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -2842,2 +3050,2 @@\n-    return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what,\n-           end, end2, end3));\n+    return(xmlStringDecodeEntitiesInt(ctxt, str, xmlStrlen(str), what,\n+                                      end, end2, end3, 0));\n@@ -2983,1 +3191,1 @@\n-        buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+        buffer = (xmlChar *) xmlMallocAtomic(max);\n@@ -2994,2 +3202,1 @@\n-                tmp = (xmlChar *) xmlRealloc(buffer,\n-                                                max * sizeof(xmlChar));\n+                tmp = (xmlChar *) xmlRealloc(buffer, max);\n@@ -3062,1 +3269,1 @@\n-            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            buffer = (xmlChar *) xmlMallocAtomic(max);\n@@ -3073,2 +3280,1 @@\n-                    tmp = (xmlChar *) xmlRealloc(buffer,\n-                                                    max * sizeof(xmlChar));\n+                    tmp = (xmlChar *) xmlRealloc(buffer, max);\n@@ -3110,8 +3316,0 @@\n-#ifdef DEBUG\n-static unsigned long nbParseName = 0;\n-static unsigned long nbParseNmToken = 0;\n-static unsigned long nbParseNCName = 0;\n-static unsigned long nbParseNCNameComplex = 0;\n-static unsigned long nbParseNameComplex = 0;\n-static unsigned long nbParseStringName = 0;\n-#endif\n@@ -3206,1 +3404,0 @@\n-    int count = 0;\n@@ -3211,4 +3408,0 @@\n-#ifdef DEBUG\n-    nbParseNameComplex++;\n-#endif\n-\n@@ -3218,3 +3411,0 @@\n-    GROW;\n-    if (ctxt->instate == XML_PARSER_EOF)\n-        return(NULL);\n@@ -3269,6 +3459,0 @@\n-            if (count++ > XML_PARSER_CHUNK_SIZE) {\n-                count = 0;\n-                GROW;\n-                if (ctxt->instate == XML_PARSER_EOF)\n-                    return(NULL);\n-            }\n@@ -3296,6 +3480,0 @@\n-            if (count++ > XML_PARSER_CHUNK_SIZE) {\n-                count = 0;\n-                GROW;\n-                if (ctxt->instate == XML_PARSER_EOF)\n-                    return(NULL);\n-            }\n@@ -3308,0 +3486,2 @@\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return(NULL);\n@@ -3331,0 +3511,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -3353,4 +3535,2 @@\n-\n-#ifdef DEBUG\n-    nbParseName++;\n-#endif\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return(NULL);\n@@ -3390,1 +3570,1 @@\n-static const xmlChar *\n+static xmlHashedString\n@@ -3392,0 +3572,1 @@\n+    xmlHashedString ret;\n@@ -3394,1 +3575,0 @@\n-    int count = 0;\n@@ -3400,3 +3580,2 @@\n-#ifdef DEBUG\n-    nbParseNCNameComplex++;\n-#endif\n+    ret.name = NULL;\n+    ret.hashValue = 0;\n@@ -3407,1 +3586,0 @@\n-    GROW;\n@@ -3412,1 +3590,1 @@\n-        return(NULL);\n+        return(ret);\n@@ -3417,6 +3595,0 @@\n-        if (count++ > XML_PARSER_CHUNK_SIZE) {\n-            count = 0;\n-            GROW;\n-            if (ctxt->instate == XML_PARSER_EOF)\n-                return(NULL);\n-        }\n@@ -3427,14 +3599,0 @@\n-        if (c == 0) {\n-            count = 0;\n-            \/*\n-             * when shrinking to extend the buffer we really need to preserve\n-             * the part of the name we already parsed. Hence rolling back\n-             * by current length.\n-             *\/\n-            ctxt->input->cur -= l;\n-            GROW;\n-            if (ctxt->instate == XML_PARSER_EOF)\n-                return(NULL);\n-            ctxt->input->cur += l;\n-            c = CUR_CHAR(l);\n-        }\n@@ -3442,0 +3600,2 @@\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return(ret);\n@@ -3444,1 +3604,1 @@\n-        return(NULL);\n+        return(ret);\n@@ -3446,1 +3606,2 @@\n-    return(xmlDictLookup(ctxt->dict, (BASE_PTR + startPosition), len));\n+    ret = xmlDictLookupHashed(ctxt->dict, (BASE_PTR + startPosition), len);\n+    return(ret);\n@@ -3464,1 +3625,1 @@\n-static const xmlChar *\n+static xmlHashedString\n@@ -3467,1 +3628,1 @@\n-    const xmlChar *ret;\n+    xmlHashedString ret;\n@@ -3473,3 +3634,1 @@\n-#ifdef DEBUG\n-    nbParseNCName++;\n-#endif\n+    ret.name = NULL;\n@@ -3498,1 +3657,1 @@\n-                return(NULL);\n+                return(ret);\n@@ -3500,1 +3659,1 @@\n-            ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n+            ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);\n@@ -3503,1 +3662,1 @@\n-            if (ret == NULL) {\n+            if (ret.name == NULL) {\n@@ -3582,4 +3741,0 @@\n-#ifdef DEBUG\n-    nbParseStringName++;\n-#endif\n-\n@@ -3591,1 +3746,1 @@\n-    COPY_BUF(l,buf,len,c);\n+    COPY_BUF(buf, len, c);\n@@ -3595,1 +3750,1 @@\n-        COPY_BUF(l,buf,len,c);\n+        COPY_BUF(buf, len, c);\n@@ -3606,1 +3761,1 @@\n-            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            buffer = (xmlChar *) xmlMallocAtomic(max);\n@@ -3617,2 +3772,1 @@\n-                    tmp = (xmlChar *) xmlRealloc(buffer,\n-                                                    max * sizeof(xmlChar));\n+                    tmp = (xmlChar *) xmlRealloc(buffer, max);\n@@ -3626,1 +3780,1 @@\n-                COPY_BUF(l,buffer,len,c);\n+                COPY_BUF(buffer, len, c);\n@@ -3652,0 +3806,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -3666,1 +3822,0 @@\n-    int count = 0;\n@@ -3671,7 +3826,0 @@\n-#ifdef DEBUG\n-    nbParseNmToken++;\n-#endif\n-\n-    GROW;\n-    if (ctxt->instate == XML_PARSER_EOF)\n-        return(NULL);\n@@ -3681,5 +3829,1 @@\n-        if (count++ > XML_PARSER_CHUNK_SIZE) {\n-            count = 0;\n-            GROW;\n-        }\n-        COPY_BUF(l,buf,len,c);\n+        COPY_BUF(buf, len, c);\n@@ -3688,7 +3832,0 @@\n-        if (c == 0) {\n-            count = 0;\n-            GROW;\n-            if (ctxt->instate == XML_PARSER_EOF)\n-                return(NULL);\n-            c = CUR_CHAR(l);\n-        }\n@@ -3703,1 +3840,1 @@\n-            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            buffer = (xmlChar *) xmlMallocAtomic(max);\n@@ -3710,8 +3847,0 @@\n-                if (count++ > XML_PARSER_CHUNK_SIZE) {\n-                    count = 0;\n-                    GROW;\n-                    if (ctxt->instate == XML_PARSER_EOF) {\n-                        xmlFree(buffer);\n-                        return(NULL);\n-                    }\n-                }\n@@ -3722,2 +3851,1 @@\n-                    tmp = (xmlChar *) xmlRealloc(buffer,\n-                                                    max * sizeof(xmlChar));\n+                    tmp = (xmlChar *) xmlRealloc(buffer, max);\n@@ -3731,3 +3859,1 @@\n-                COPY_BUF(l,buffer,len,c);\n-                NEXTL(l);\n-                c = CUR_CHAR(l);\n+                COPY_BUF(buffer, len, c);\n@@ -3739,0 +3865,2 @@\n+                NEXTL(l);\n+                c = CUR_CHAR(l);\n@@ -3741,0 +3869,4 @@\n+            if (ctxt->instate == XML_PARSER_EOF) {\n+                xmlFree(buffer);\n+                return(NULL);\n+            }\n@@ -3744,0 +3876,2 @@\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return(NULL);\n@@ -3758,0 +3892,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -3786,1 +3922,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+    buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -3818,1 +3954,1 @@\n-            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            tmp = (xmlChar *) xmlRealloc(buf, size);\n@@ -3825,1 +3961,1 @@\n-        COPY_BUF(l,buf,len,c);\n+        COPY_BUF(buf, len, c);\n@@ -3894,2 +4030,2 @@\n-    ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,\n-                                  0, 0, 0);\n+    ret = xmlStringDecodeEntitiesInt(ctxt, buf, len, XML_SUBSTITUTE_PEREF,\n+                                     0, 0, 0, \/* check *\/ 1);\n@@ -3897,0 +4033,1 @@\n+\n@@ -3994,3 +4131,0 @@\n-                ctxt->nbentities++;\n-                if (ent != NULL)\n-                    ctxt->nbentities += ent->owner;\n@@ -4015,0 +4149,3 @@\n+                        if (xmlParserEntityCheck(ctxt, ent->length))\n+                            goto error;\n+\n@@ -4016,3 +4153,3 @@\n-                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n-                                                      XML_SUBSTITUTE_REF,\n-                                                      0, 0, 0);\n+                        rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,\n+                                ent->length, XML_SUBSTITUTE_REF, 0, 0, 0,\n+                                \/* check *\/ 1);\n@@ -4048,2 +4185,3 @@\n-                     * This may look absurd but is needed to detect\n-                     * entities problems\n+                     * We also check for recursion and amplification\n+                     * when entities are not substituted. They're\n+                     * often expanded later.\n@@ -4052,2 +4190,3 @@\n-                        (ent->content != NULL) && (ent->checked == 0)) {\n-                        unsigned long oldnbent = ctxt->nbentities, diff;\n+                        (ent->content != NULL)) {\n+                        if ((ent->flags & XML_ENT_CHECKED) == 0) {\n+                            unsigned long oldCopy = ctxt->sizeentcopy;\n@@ -4055,4 +4194,1 @@\n-                        ++ctxt->depth;\n-                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n-                                                  XML_SUBSTITUTE_REF, 0, 0, 0);\n-                        --ctxt->depth;\n+                            ctxt->sizeentcopy = ent->length;\n@@ -4060,9 +4196,27 @@\n-                        diff = ctxt->nbentities - oldnbent + 1;\n-                        if (diff > INT_MAX \/ 2)\n-                            diff = INT_MAX \/ 2;\n-                        ent->checked = diff * 2;\n-                        if (rep != NULL) {\n-                            if (xmlStrchr(rep, '<'))\n-                                ent->checked |= 1;\n-                            xmlFree(rep);\n-                            rep = NULL;\n+                            ++ctxt->depth;\n+                            rep = xmlStringDecodeEntitiesInt(ctxt,\n+                                    ent->content, ent->length,\n+                                    XML_SUBSTITUTE_REF, 0, 0, 0,\n+                                    \/* check *\/ 1);\n+                            --ctxt->depth;\n+\n+                            \/*\n+                             * If we're parsing DTD content, the entity\n+                             * might reference other entities which\n+                             * weren't defined yet, so the check isn't\n+                             * reliable.\n+                             *\/\n+                            if (ctxt->inSubset == 0) {\n+                                ent->flags |= XML_ENT_CHECKED;\n+                                ent->expandedSize = ctxt->sizeentcopy;\n+                            }\n+\n+                            if (rep != NULL) {\n+                                xmlFree(rep);\n+                                rep = NULL;\n+                            } else {\n+                                ent->content[0] = 0;\n+                            }\n+\n+                            if (xmlParserEntityCheck(ctxt, oldCopy))\n+                                goto error;\n@@ -4070,1 +4224,2 @@\n-                            ent->content[0] = 0;\n+                            if (xmlParserEntityCheck(ctxt, ent->expandedSize))\n+                                goto error;\n@@ -4090,1 +4245,1 @@\n-                        COPY_BUF(l,buf,len,0x20);\n+                        COPY_BUF(buf, len, 0x20);\n@@ -4099,1 +4254,1 @@\n-                COPY_BUF(l,buf,len,c);\n+                COPY_BUF(buf, len, c);\n@@ -4134,1 +4289,1 @@\n-    if (attlen != NULL) *attlen = (int) len;\n+    if (attlen != NULL) *attlen = len;\n@@ -4151,0 +4306,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -4191,0 +4348,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -4209,1 +4368,0 @@\n-    int count = 0;\n@@ -4211,1 +4369,0 @@\n-    SHRINK;\n@@ -4223,1 +4380,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+    buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -4235,1 +4392,1 @@\n-            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            tmp = (xmlChar *) xmlRealloc(buf, size);\n@@ -4244,18 +4401,1 @@\n-        count++;\n-        if (count > 50) {\n-            SHRINK;\n-            GROW;\n-            count = 0;\n-            if (ctxt->instate == XML_PARSER_EOF) {\n-                xmlFree(buf);\n-                return(NULL);\n-            }\n-        }\n-        COPY_BUF(l,buf,len,cur);\n-        NEXTL(l);\n-        cur = CUR_CHAR(l);\n-        if (cur == 0) {\n-            GROW;\n-            SHRINK;\n-            cur = CUR_CHAR(l);\n-        }\n+        COPY_BUF(buf, len, cur);\n@@ -4268,0 +4408,2 @@\n+        NEXTL(l);\n+        cur = CUR_CHAR(l);\n@@ -4270,0 +4412,4 @@\n+    if (ctxt->instate == XML_PARSER_EOF) {\n+        xmlFree(buf);\n+        return(NULL);\n+    }\n@@ -4283,0 +4429,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -4300,1 +4448,0 @@\n-    int count = 0;\n@@ -4303,1 +4450,0 @@\n-    SHRINK;\n@@ -4314,1 +4460,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+    buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -4326,1 +4472,1 @@\n-            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            tmp = (xmlChar *) xmlRealloc(buf, size);\n@@ -4335,17 +4481,0 @@\n-        count++;\n-        if (count > 50) {\n-            SHRINK;\n-            GROW;\n-            count = 0;\n-            if (ctxt->instate == XML_PARSER_EOF) {\n-                xmlFree(buf);\n-                return(NULL);\n-            }\n-        }\n-        NEXT;\n-        cur = CUR;\n-        if (cur == 0) {\n-            GROW;\n-            SHRINK;\n-            cur = CUR;\n-        }\n@@ -4357,0 +4486,2 @@\n+        NEXT;\n+        cur = CUR;\n@@ -4359,0 +4490,4 @@\n+    if (ctxt->instate == XML_PARSER_EOF) {\n+        xmlFree(buf);\n+        return(NULL);\n+    }\n@@ -4362,1 +4497,1 @@\n-        NEXT;\n+        NEXTL(1);\n@@ -4368,1 +4503,1 @@\n-static void xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata);\n+static void xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial);\n@@ -4409,1 +4544,1 @@\n- * xmlParseCharData:\n+ * xmlParseCharDataInternal:\n@@ -4411,1 +4546,1 @@\n- * @cdata:  int indicating whether we are within a CDATA section\n+ * @partial:  buffer may contain partial UTF-8 sequences\n@@ -4413,2 +4548,2 @@\n- * parse a CharData section.\n- * if we are within a CDATA section ']]>' marks an end of section.\n+ * Parse character data. Always makes progress if the first char isn't\n+ * '<' or '&'.\n@@ -4423,3 +4558,2 @@\n-\n-void\n-xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata) {\n+static void\n+xmlParseCharDataInternal(xmlParserCtxtPtr ctxt, int partial) {\n@@ -4432,1 +4566,0 @@\n-    SHRINK;\n@@ -4438,3 +4571,2 @@\n-    if (!cdata) {\n-        in = ctxt->input->cur;\n-        do {\n+    in = ctxt->input->cur;\n+    do {\n@@ -4442,57 +4574,4 @@\n-            while (*in == 0x20) { in++; ctxt->input->col++; }\n-            if (*in == 0xA) {\n-                do {\n-                    ctxt->input->line++; ctxt->input->col = 1;\n-                    in++;\n-                } while (*in == 0xA);\n-                goto get_more_space;\n-            }\n-            if (*in == '<') {\n-                nbchar = in - ctxt->input->cur;\n-                if (nbchar > 0) {\n-                    const xmlChar *tmp = ctxt->input->cur;\n-                    ctxt->input->cur = in;\n-\n-                    if ((ctxt->sax != NULL) &&\n-                        (ctxt->sax->ignorableWhitespace !=\n-                         ctxt->sax->characters)) {\n-                        if (areBlanks(ctxt, tmp, nbchar, 1)) {\n-                            if (ctxt->sax->ignorableWhitespace != NULL)\n-                                ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                                       tmp, nbchar);\n-                        } else {\n-                            if (ctxt->sax->characters != NULL)\n-                                ctxt->sax->characters(ctxt->userData,\n-                                                      tmp, nbchar);\n-                            if (*ctxt->space == -1)\n-                                *ctxt->space = -2;\n-                        }\n-                    } else if ((ctxt->sax != NULL) &&\n-                               (ctxt->sax->characters != NULL)) {\n-                        ctxt->sax->characters(ctxt->userData,\n-                                              tmp, nbchar);\n-                    }\n-                }\n-                return;\n-            }\n-\n-get_more:\n-            ccol = ctxt->input->col;\n-            while (test_char_data[*in]) {\n-                in++;\n-                ccol++;\n-            }\n-            ctxt->input->col = ccol;\n-            if (*in == 0xA) {\n-                do {\n-                    ctxt->input->line++; ctxt->input->col = 1;\n-                    in++;\n-                } while (*in == 0xA);\n-                goto get_more;\n-            }\n-            if (*in == ']') {\n-                if ((in[1] == ']') && (in[2] == '>')) {\n-                    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n-                    ctxt->input->cur = in + 1;\n-                    return;\n-                }\n+        while (*in == 0x20) { in++; ctxt->input->col++; }\n+        if (*in == 0xA) {\n+            do {\n+                ctxt->input->line++; ctxt->input->col = 1;\n@@ -4500,3 +4579,4 @@\n-                ctxt->input->col++;\n-                goto get_more;\n-            }\n+            } while (*in == 0xA);\n+            goto get_more_space;\n+        }\n+        if (*in == '<') {\n@@ -4505,0 +4585,3 @@\n+                const xmlChar *tmp = ctxt->input->cur;\n+                ctxt->input->cur = in;\n+\n@@ -4506,0 +4589,1 @@\n+                    (ctxt->disableSAX == 0) &&\n@@ -4507,6 +4591,2 @@\n-                     ctxt->sax->characters) &&\n-                    (IS_BLANK_CH(*ctxt->input->cur))) {\n-                    const xmlChar *tmp = ctxt->input->cur;\n-                    ctxt->input->cur = in;\n-\n-                    if (areBlanks(ctxt, tmp, nbchar, 0)) {\n+                     ctxt->sax->characters)) {\n+                    if (areBlanks(ctxt, tmp, nbchar, 1)) {\n@@ -4515,1 +4595,1 @@\n-                                                           tmp, nbchar);\n+                                                   tmp, nbchar);\n@@ -4523,8 +4603,5 @@\n-                    line = ctxt->input->line;\n-                    col = ctxt->input->col;\n-                } else if (ctxt->sax != NULL) {\n-                    if (ctxt->sax->characters != NULL)\n-                        ctxt->sax->characters(ctxt->userData,\n-                                              ctxt->input->cur, nbchar);\n-                    line = ctxt->input->line;\n-                    col = ctxt->input->col;\n+                } else if ((ctxt->sax != NULL) &&\n+                           (ctxt->disableSAX == 0) &&\n+                           (ctxt->sax->characters != NULL)) {\n+                    ctxt->sax->characters(ctxt->userData,\n+                                          tmp, nbchar);\n@@ -4532,3 +4609,0 @@\n-                \/* something really bad happened in the SAX callback *\/\n-                if (ctxt->instate != XML_PARSER_CONTENT)\n-                    return;\n@@ -4536,2 +4610,13 @@\n-            ctxt->input->cur = in;\n-            if (*in == 0xD) {\n+            return;\n+        }\n+\n+get_more:\n+        ccol = ctxt->input->col;\n+        while (test_char_data[*in]) {\n+            in++;\n+            ccol++;\n+        }\n+        ctxt->input->col = ccol;\n+        if (*in == 0xA) {\n+            do {\n+                ctxt->input->line++; ctxt->input->col = 1;\n@@ -4539,12 +4624,8 @@\n-                if (*in == 0xA) {\n-                    ctxt->input->cur = in;\n-                    in++;\n-                    ctxt->input->line++; ctxt->input->col = 1;\n-                    continue; \/* while *\/\n-                }\n-                in--;\n-            }\n-            if (*in == '<') {\n-                return;\n-            }\n-            if (*in == '&') {\n+            } while (*in == 0xA);\n+            goto get_more;\n+        }\n+        if (*in == ']') {\n+            if ((in[1] == ']') && (in[2] == '>')) {\n+                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n+                if (ctxt->instate != XML_PARSER_EOF)\n+                    ctxt->input->cur = in + 1;\n@@ -4553,3 +4634,36 @@\n-            SHRINK;\n-            GROW;\n-            if (ctxt->instate == XML_PARSER_EOF)\n+            in++;\n+            ctxt->input->col++;\n+            goto get_more;\n+        }\n+        nbchar = in - ctxt->input->cur;\n+        if (nbchar > 0) {\n+            if ((ctxt->sax != NULL) &&\n+                (ctxt->disableSAX == 0) &&\n+                (ctxt->sax->ignorableWhitespace !=\n+                 ctxt->sax->characters) &&\n+                (IS_BLANK_CH(*ctxt->input->cur))) {\n+                const xmlChar *tmp = ctxt->input->cur;\n+                ctxt->input->cur = in;\n+\n+                if (areBlanks(ctxt, tmp, nbchar, 0)) {\n+                    if (ctxt->sax->ignorableWhitespace != NULL)\n+                        ctxt->sax->ignorableWhitespace(ctxt->userData,\n+                                                       tmp, nbchar);\n+                } else {\n+                    if (ctxt->sax->characters != NULL)\n+                        ctxt->sax->characters(ctxt->userData,\n+                                              tmp, nbchar);\n+                    if (*ctxt->space == -1)\n+                        *ctxt->space = -2;\n+                }\n+                line = ctxt->input->line;\n+                col = ctxt->input->col;\n+            } else if ((ctxt->sax != NULL) &&\n+                       (ctxt->disableSAX == 0)) {\n+                if (ctxt->sax->characters != NULL)\n+                    ctxt->sax->characters(ctxt->userData,\n+                                          ctxt->input->cur, nbchar);\n+                line = ctxt->input->line;\n+                col = ctxt->input->col;\n+            }\n+            if (ctxt->instate == XML_PARSER_EOF)\n@@ -4557,4 +4671,25 @@\n-            in = ctxt->input->cur;\n-        } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n-        nbchar = 0;\n-    }\n+        }\n+        ctxt->input->cur = in;\n+        if (*in == 0xD) {\n+            in++;\n+            if (*in == 0xA) {\n+                ctxt->input->cur = in;\n+                in++;\n+                ctxt->input->line++; ctxt->input->col = 1;\n+                continue; \/* while *\/\n+            }\n+            in--;\n+        }\n+        if (*in == '<') {\n+            return;\n+        }\n+        if (*in == '&') {\n+            return;\n+        }\n+        SHRINK;\n+        GROW;\n+        if (ctxt->instate == XML_PARSER_EOF)\n+            return;\n+        in = ctxt->input->cur;\n+    } while (((*in >= 0x20) && (*in <= 0x7F)) ||\n+             (*in == 0x09) || (*in == 0x0a));\n@@ -4563,1 +4698,1 @@\n-    xmlParseCharDataComplex(ctxt, cdata);\n+    xmlParseCharDataComplex(ctxt, partial);\n@@ -4571,0 +4706,2 @@\n+ * Always makes progress if the first char isn't '<' or '&'.\n+ *\n@@ -4576,1 +4713,1 @@\n-xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) {\n+xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {\n@@ -4580,1 +4717,0 @@\n-    int count = 0;\n@@ -4582,2 +4718,0 @@\n-    SHRINK;\n-    GROW;\n@@ -4587,7 +4721,3 @@\n-           (IS_CHAR(cur))) \/* test also done in xmlCurrentChar() *\/ {\n-        if ((cur == ']') && (NXT(1) == ']') &&\n-            (NXT(2) == '>')) {\n-            if (cdata) break;\n-            else {\n-                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n-            }\n+           (IS_CHAR(cur))) {\n+        if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {\n+            xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n@@ -4595,1 +4725,1 @@\n-        COPY_BUF(l,buf,nbchar,cur);\n+        COPY_BUF(buf, nbchar, cur);\n@@ -4598,1 +4728,0 @@\n-        cur = CUR_CHAR(l);\n@@ -4623,3 +4752,0 @@\n-        }\n-        count++;\n-        if (count > 50) {\n@@ -4627,4 +4753,0 @@\n-            GROW;\n-            count = 0;\n-            if (ctxt->instate == XML_PARSER_EOF)\n-                return;\n@@ -4632,0 +4754,1 @@\n+        cur = CUR_CHAR(l);\n@@ -4633,0 +4756,2 @@\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return;\n@@ -4651,6 +4776,21 @@\n-    if ((cur != 0) && (!IS_CHAR(cur))) {\n-        \/* Generate the error and skip the offending character *\/\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n-                          \"PCDATA invalid Char value %d\\n\",\n-                          cur);\n-        NEXTL(l);\n+    \/*\n+     * cur == 0 can mean\n+     *\n+     * - XML_PARSER_EOF or memory error. This is checked above.\n+     * - An actual 0 character.\n+     * - End of buffer.\n+     * - An incomplete UTF-8 sequence. This is allowed if partial is set.\n+     *\/\n+    if (ctxt->input->cur < ctxt->input->end) {\n+        if ((cur == 0) && (CUR != 0)) {\n+            if (partial == 0) {\n+                xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n+                        \"Incomplete UTF-8 sequence starting with %02X\\n\", CUR);\n+                NEXTL(1);\n+            }\n+        } else if ((cur != '<') && (cur != '&')) {\n+            \/* Generate the error and skip the offending character *\/\n+            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n+                              \"PCDATA invalid Char value %d\\n\", cur);\n+            NEXTL(l);\n+        }\n@@ -4660,0 +4800,12 @@\n+\/**\n+ * xmlParseCharData:\n+ * @ctxt:  an XML parser context\n+ * @cdata:  unused\n+ *\n+ * DEPRECATED: Internal function, don't use.\n+ *\/\n+void\n+xmlParseCharData(xmlParserCtxtPtr ctxt, ATTRIBUTE_UNUSED int cdata) {\n+    xmlParseCharDataInternal(ctxt, 0);\n+}\n+\n@@ -4667,0 +4819,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -4686,2 +4840,0 @@\n-    SHRINK;\n-\n@@ -4755,1 +4907,0 @@\n-    size_t count = 0;\n@@ -4766,1 +4917,1 @@\n-        buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+        buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -4772,1 +4923,0 @@\n-    GROW;       \/* Assure there's enough input data *\/\n@@ -4790,1 +4940,1 @@\n-                          q);\n+                          r);\n@@ -4818,1 +4968,8 @@\n-        COPY_BUF(ql,buf,len,q);\n+        COPY_BUF(buf, len, q);\n+        if (len > maxLength) {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n+                         \"Comment too big found\", NULL);\n+            xmlFree (buf);\n+            return;\n+        }\n+\n@@ -4824,10 +4981,0 @@\n-        count++;\n-        if (count > 50) {\n-            SHRINK;\n-            GROW;\n-            count = 0;\n-            if (ctxt->instate == XML_PARSER_EOF) {\n-                xmlFree(buf);\n-                return;\n-            }\n-        }\n@@ -4836,5 +4983,0 @@\n-        if (cur == 0) {\n-            SHRINK;\n-            GROW;\n-            cur = CUR_CHAR(l);\n-        }\n@@ -4842,6 +4984,0 @@\n-        if (len > maxLength) {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-                         \"Comment too big found\", NULL);\n-            xmlFree (buf);\n-            return;\n-        }\n@@ -4850,0 +4986,4 @@\n+    if (ctxt->instate == XML_PARSER_EOF) {\n+        xmlFree(buf);\n+        return;\n+    }\n@@ -4881,1 +5021,4 @@\n- * Skip an XML (SGML) comment <!-- .... -->\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse an XML (SGML) comment. Always consumes '<!'.\n+ *\n@@ -4904,2 +5047,5 @@\n-    if ((RAW != '<') || (NXT(1) != '!') ||\n-        (NXT(2) != '-') || (NXT(3) != '-')) return;\n+    if ((RAW != '<') || (NXT(1) != '!'))\n+        return;\n+    SKIP(2);\n+    if ((RAW != '-') || (NXT(1) != '-'))\n+        return;\n@@ -4909,2 +5055,1 @@\n-    SKIP(4);\n-    SHRINK;\n+    SKIP(2);\n@@ -4946,2 +5091,6 @@\n-            if ((ctxt->sax != NULL) &&\n-                (ctxt->sax->comment != NULL)) {\n+            if (buf == NULL) {\n+                if ((*in == '-') && (in[1] == '-'))\n+                    size = nbchar + 1;\n+                else\n+                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n+                buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -4949,23 +5098,14 @@\n-                    if ((*in == '-') && (in[1] == '-'))\n-                        size = nbchar + 1;\n-                    else\n-                        size = XML_PARSER_BUFFER_SIZE + nbchar;\n-                    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n-                    if (buf == NULL) {\n-                        xmlErrMemory(ctxt, NULL);\n-                        ctxt->instate = state;\n-                        return;\n-                    }\n-                    len = 0;\n-                } else if (len + nbchar + 1 >= size) {\n-                    xmlChar *new_buf;\n-                    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n-                    new_buf = (xmlChar *) xmlRealloc(buf,\n-                                                     size * sizeof(xmlChar));\n-                    if (new_buf == NULL) {\n-                        xmlFree (buf);\n-                        xmlErrMemory(ctxt, NULL);\n-                        ctxt->instate = state;\n-                        return;\n-                    }\n-                    buf = new_buf;\n+                    xmlErrMemory(ctxt, NULL);\n+                    ctxt->instate = state;\n+                    return;\n+                }\n+                len = 0;\n+            } else if (len + nbchar + 1 >= size) {\n+                xmlChar *new_buf;\n+                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n+                new_buf = (xmlChar *) xmlRealloc(buf, size);\n+                if (new_buf == NULL) {\n+                    xmlFree (buf);\n+                    xmlErrMemory(ctxt, NULL);\n+                    ctxt->instate = state;\n+                    return;\n@@ -4973,3 +5113,1 @@\n-                memcpy(&buf[len], ctxt->input->cur, nbchar);\n-                len += nbchar;\n-                buf[len] = 0;\n+                buf = new_buf;\n@@ -4977,0 +5115,3 @@\n+            memcpy(&buf[len], ctxt->input->cur, nbchar);\n+            len += nbchar;\n+            buf[len] = 0;\n@@ -5058,0 +5199,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -5166,0 +5309,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -5184,1 +5329,0 @@\n-    int count = 0;\n@@ -5194,1 +5338,0 @@\n-        SHRINK;\n@@ -5221,1 +5364,1 @@\n-            buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+            buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -5247,18 +5390,1 @@\n-                count++;\n-                if (count > 50) {\n-                    SHRINK;\n-                    GROW;\n-                    if (ctxt->instate == XML_PARSER_EOF) {\n-                        xmlFree(buf);\n-                        return;\n-                    }\n-                    count = 0;\n-                }\n-                COPY_BUF(l,buf,len,cur);\n-                NEXTL(l);\n-                cur = CUR_CHAR(l);\n-                if (cur == 0) {\n-                    SHRINK;\n-                    GROW;\n-                    cur = CUR_CHAR(l);\n-                }\n+                COPY_BUF(buf, len, cur);\n@@ -5272,0 +5398,2 @@\n+                NEXTL(l);\n+                cur = CUR_CHAR(l);\n@@ -5274,0 +5402,4 @@\n+            if (ctxt->instate == XML_PARSER_EOF) {\n+                xmlFree(buf);\n+                return;\n+            }\n@@ -5318,1 +5450,3 @@\n- * parse a notation declaration\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse a notation declaration. Always consumes '<!'.\n@@ -5336,1 +5470,5 @@\n-    if (CMP10(CUR_PTR, '<', '!', 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {\n+    if ((CUR != '<') || (NXT(1) != '!'))\n+        return;\n+    SKIP(2);\n+\n+    if (CMP8(CUR_PTR, 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {\n@@ -5338,2 +5476,1 @@\n-        SHRINK;\n-        SKIP(10);\n+        SKIP(8);\n@@ -5390,1 +5527,3 @@\n- * parse <!ENTITY declarations\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse an entity declaration. Always consumes '<!'.\n@@ -5417,0 +5556,4 @@\n+    if ((CUR != '<') || (NXT(1) != '!'))\n+        return;\n+    SKIP(2);\n+\n@@ -5418,1 +5561,1 @@\n-    if (CMP8(CUR_PTR, '<', '!', 'E', 'N', 'T', 'I', 'T', 'Y')) {\n+    if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {\n@@ -5420,2 +5563,1 @@\n-        SHRINK;\n-        SKIP(8);\n+        SKIP(6);\n@@ -5519,1 +5661,1 @@\n-                            return;\n+                            goto done;\n@@ -5590,1 +5732,1 @@\n-                                return;\n+                                goto done;\n@@ -5657,0 +5799,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -5718,0 +5862,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -5740,1 +5886,0 @@\n-    SHRINK;\n@@ -5790,0 +5935,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -5810,1 +5957,0 @@\n-    SHRINK;\n@@ -5860,0 +6006,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -5893,0 +6041,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -5935,1 +6085,0 @@\n-    SHRINK;\n@@ -5968,1 +6117,3 @@\n- * : parse the Attribute list def for an element\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse an attribute list declaration for an element. Always consumes '<!'.\n@@ -5981,1 +6132,5 @@\n-    if (CMP9(CUR_PTR, '<', '!', 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {\n+    if ((CUR != '<') || (NXT(1) != '!'))\n+        return;\n+    SKIP(2);\n+\n+    if (CMP7(CUR_PTR, 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {\n@@ -5984,1 +6139,1 @@\n-        SKIP(9);\n+        SKIP(7);\n@@ -6089,0 +6244,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -6112,1 +6269,0 @@\n-        SHRINK;\n@@ -6284,1 +6440,0 @@\n-    SHRINK;\n@@ -6507,0 +6662,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -6544,0 +6701,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -6588,1 +6747,3 @@\n- * parse an Element declaration.\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse an element declaration. Always consumes '<!'.\n@@ -6603,0 +6764,4 @@\n+    if ((CUR != '<') || (NXT(1) != '!'))\n+        return(ret);\n+    SKIP(2);\n+\n@@ -6604,1 +6769,1 @@\n-    if (CMP9(CUR_PTR, '<', '!', 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {\n+    if (CMP7(CUR_PTR, 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {\n@@ -6607,1 +6772,1 @@\n-        SKIP(9);\n+        SKIP(7);\n@@ -6695,0 +6860,2 @@\n+ * Parse a conditional section. Always consumes '<!['.\n+ *\n@@ -6745,2 +6912,0 @@\n-                int state;\n-                xmlParserInputState instate;\n@@ -6763,9 +6928,0 @@\n-                \/*\n-                 * Parse up to the end of the conditional section but disable\n-                 * SAX event generating DTD building in the meantime\n-                 *\/\n-                state = ctxt->disableSAX;\n-                instate = ctxt->instate;\n-                if (ctxt->recovery == 0) ctxt->disableSAX = 1;\n-                ctxt->instate = XML_PARSER_IGNORE;\n-\n@@ -6792,3 +6948,0 @@\n-                ctxt->disableSAX = state;\n-                ctxt->instate = instate;\n-\n@@ -6819,4 +6972,1 @@\n-        } else {\n-            int id = ctxt->input->id;\n-            unsigned long cons = CUR_CONSUMED;\n-\n+        } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {\n@@ -6824,6 +6974,4 @@\n-\n-            if ((id == ctxt->input->id) && (cons == CUR_CONSUMED)) {\n-                xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n-                xmlHaltParser(ctxt);\n-                goto error;\n-            }\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n+            xmlHaltParser(ctxt);\n+            goto error;\n@@ -6836,0 +6984,1 @@\n+        SHRINK;\n@@ -6847,1 +6996,3 @@\n- * parse Markup declarations\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse markup declarations. Always consumes '<!' or '<?'.\n@@ -6876,0 +7027,2 @@\n+                    else\n+                        SKIP(2);\n@@ -6888,0 +7041,1 @@\n+                    SKIP(2);\n@@ -6909,0 +7063,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -6917,1 +7073,0 @@\n-    const xmlChar *encoding;\n@@ -6956,1 +7111,3 @@\n-    encoding = xmlParseEncodingDecl(ctxt);\n+    xmlParseEncodingDecl(ctxt);\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return;\n@@ -6964,4 +7121,0 @@\n-    if ((encoding == NULL) && (ctxt->errNo == XML_ERR_OK)) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,\n-                       \"Missing encoding in text declaration\\n\");\n-    }\n@@ -6977,0 +7130,2 @@\n+        int c;\n+\n@@ -6978,2 +7133,5 @@\n-        MOVETO_ENDTAG(CUR_PTR);\n-        NEXT;\n+        while ((c = CUR) != 0) {\n+            NEXT;\n+            if (c == '>')\n+                break;\n+        }\n@@ -6982,1 +7140,2 @@\n-    ctxt->instate = oldstate;\n+    if (ctxt->instate != XML_PARSER_EOF)\n+        ctxt->instate = oldstate;\n@@ -7001,1 +7160,0 @@\n-    GROW;\n@@ -7003,13 +7161,1 @@\n-    if ((ctxt->encoding == NULL) &&\n-        (ctxt->input->end - ctxt->input->cur >= 4)) {\n-        xmlChar start[4];\n-        xmlCharEncoding enc;\n-\n-        start[0] = RAW;\n-        start[1] = NXT(1);\n-        start[2] = NXT(2);\n-        start[3] = NXT(3);\n-        enc = xmlDetectCharEncoding(start, 4);\n-        if (enc != XML_CHAR_ENCODING_NONE)\n-            xmlSwitchEncoding(ctxt, enc);\n-    }\n+    xmlDetectEncoding(ctxt);\n@@ -7041,6 +7187,1 @@\n-    while (((RAW == '<') && (NXT(1) == '?')) ||\n-           ((RAW == '<') && (NXT(1) == '!')) ||\n-           (RAW == '%')) {\n-        int id = ctxt->input->id;\n-        unsigned long cons = CUR_CONSUMED;\n-\n+    while ((ctxt->instate != XML_PARSER_EOF) && (RAW != 0)) {\n@@ -7050,1 +7191,1 @@\n-        } else\n+        } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {\n@@ -7052,3 +7193,1 @@\n-        SKIP_BLANKS;\n-\n-        if ((id == ctxt->input->id) && (cons == CUR_CONSUMED)) {\n+        } else {\n@@ -7056,1 +7195,2 @@\n-            break;\n+            xmlHaltParser(ctxt);\n+            return;\n@@ -7058,0 +7198,2 @@\n+        SKIP_BLANKS;\n+        SHRINK;\n@@ -7070,0 +7212,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -7075,0 +7219,2 @@\n+ * Always consumes '&'.\n+ *\n@@ -7095,1 +7241,0 @@\n-        int hex = NXT(2);\n@@ -7100,31 +7245,9 @@\n-        if (ctxt->charset != XML_CHAR_ENCODING_UTF8) {\n-            \/*\n-             * So we are using non-UTF-8 buffers\n-             * Check that the char fit on 8bits, if not\n-             * generate a CharRef.\n-             *\/\n-            if (value <= 0xFF) {\n-                out[0] = value;\n-                out[1] = 0;\n-                if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n-                    (!ctxt->disableSAX))\n-                    ctxt->sax->characters(ctxt->userData, out, 1);\n-            } else {\n-                if ((hex == 'x') || (hex == 'X'))\n-                    snprintf((char *)out, sizeof(out), \"#x%X\", value);\n-                else\n-                    snprintf((char *)out, sizeof(out), \"#%d\", value);\n-                if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n-                    (!ctxt->disableSAX))\n-                    ctxt->sax->reference(ctxt->userData, out);\n-            }\n-        } else {\n-            \/*\n-             * Just encode the value in UTF-8\n-             *\/\n-            COPY_BUF(0 ,out, i, value);\n-            out[i] = 0;\n-            if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n-                (!ctxt->disableSAX))\n-                ctxt->sax->characters(ctxt->userData, out, i);\n-        }\n+\n+        \/*\n+         * Just encode the value in UTF-8\n+         *\/\n+        COPY_BUF(out, i, value);\n+        out[i] = 0;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->characters(ctxt->userData, out, i);\n@@ -7141,1 +7264,1 @@\n-    was_checked = ent->checked;\n+    was_checked = ent->flags & XML_ENT_PARSED;\n@@ -7166,0 +7289,33 @@\n+     *\n+     * FIXME: This doesn't work correctly since entities can be\n+     * expanded with different namespace declarations in scope.\n+     * For example:\n+     *\n+     * <!DOCTYPE doc [\n+     *   <!ENTITY ent \"<ns:elem\/>\">\n+     * ]>\n+     * <doc>\n+     *   <decl1 xmlns:ns=\"urn:ns1\">\n+     *     &ent;\n+     *   <\/decl1>\n+     *   <decl2 xmlns:ns=\"urn:ns2\">\n+     *     &ent;\n+     *   <\/decl2>\n+     * <\/doc>\n+     *\n+     * Proposed fix:\n+     *\n+     * - Remove the ent->owner optimization which tries to avoid the\n+     *   initial copy of the entity. Always make entities own the\n+     *   subtree.\n+     * - Ignore current namespace declarations when parsing the\n+     *   entity. If a prefix can't be resolved, don't report an error\n+     *   but mark it as unresolved.\n+     * - Try to resolve these prefixes when expanding the entity.\n+     *   This will require a specialized version of xmlStaticCopyNode\n+     *   which can also make use of the namespace hash table to avoid\n+     *   quadratic behavior.\n+     *\n+     * Alternatively, we could simply reparse the entity on each\n+     * expansion like we already do with custom SAX callbacks.\n+     * External entity content should be cached in this case.\n@@ -7167,2 +7323,1 @@\n-    if (((ent->checked == 0) ||\n-         ((ent->children == NULL) && (ctxt->options & XML_PARSE_NOENT))) &&\n+    if (((ent->flags & XML_ENT_PARSED) == 0) &&\n@@ -7171,1 +7326,1 @@\n-        unsigned long oldnbent = ctxt->nbentities, diff;\n+        unsigned long oldsizeentcopy = ctxt->sizeentcopy;\n@@ -7184,2 +7339,13 @@\n-        \/*\n-         * Check that this entity is well formed\n+        \/* Avoid overflow as much as possible *\/\n+        ctxt->sizeentcopy = 0;\n+\n+        if (ent->flags & XML_ENT_EXPANDING) {\n+            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+            xmlHaltParser(ctxt);\n+            return;\n+        }\n+\n+        ent->flags |= XML_ENT_EXPANDING;\n+\n+        \/*\n+         * Check that this entity is well formed\n@@ -7208,10 +7374,3 @@\n-        \/*\n-         * Store the number of entities needing parsing for this entity\n-         * content and do checkings\n-         *\/\n-        diff = ctxt->nbentities - oldnbent + 1;\n-        if (diff > INT_MAX \/ 2)\n-            diff = INT_MAX \/ 2;\n-        ent->checked = diff * 2;\n-        if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))\n-            ent->checked |= 1;\n+        ent->flags &= ~XML_ENT_EXPANDING;\n+        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n+        ent->expandedSize = ctxt->sizeentcopy;\n@@ -7219,1 +7378,0 @@\n-            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n@@ -7224,1 +7382,1 @@\n-        if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {\n+        if (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {\n@@ -7230,36 +7388,17 @@\n-            if (((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||\n-             (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&&\n-                (ent->children == NULL)) {\n-                ent->children = list;\n-                \/*\n-                 * Prune it directly in the generated document\n-                 * except for single text nodes.\n-                 *\/\n-                if ((ctxt->replaceEntities == 0) ||\n-                    (ctxt->parseMode == XML_PARSE_READER) ||\n-                    ((list->type == XML_TEXT_NODE) &&\n-                     (list->next == NULL))) {\n-                    ent->owner = 1;\n-                    while (list != NULL) {\n-                        list->parent = (xmlNodePtr) ent;\n-                        if (list->doc != ent->doc)\n-                            xmlSetTreeDoc(list, ent->doc);\n-                        if (list->next == NULL)\n-                            ent->last = list;\n-                        list = list->next;\n-                    }\n-                    list = NULL;\n-                } else {\n-                    ent->owner = 0;\n-                    while (list != NULL) {\n-                        list->parent = (xmlNodePtr) ctxt->node;\n-                        list->doc = ctxt->myDoc;\n-                        if (list->next == NULL)\n-                            ent->last = list;\n-                        list = list->next;\n-                    }\n-                    list = ent->children;\n-#ifdef LIBXML_LEGACY_ENABLED\n-                    if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n-                        xmlAddEntityReference(ent, list, NULL);\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n+            ent->children = list;\n+            \/*\n+             * Prune it directly in the generated document\n+             * except for single text nodes.\n+             *\/\n+            if ((ctxt->replaceEntities == 0) ||\n+                (ctxt->parseMode == XML_PARSE_READER) ||\n+                ((list->type == XML_TEXT_NODE) &&\n+                 (list->next == NULL))) {\n+                ent->owner = 1;\n+                while (list != NULL) {\n+                    list->parent = (xmlNodePtr) ent;\n+                    if (list->doc != ent->doc)\n+                        xmlSetTreeDoc(list, ent->doc);\n+                    if (list->next == NULL)\n+                        ent->last = list;\n+                    list = list->next;\n@@ -7267,2 +7406,0 @@\n-            } else {\n-                xmlFreeNodeList(list);\n@@ -7270,0 +7407,14 @@\n+            } else {\n+                ent->owner = 0;\n+                while (list != NULL) {\n+                    list->parent = (xmlNodePtr) ctxt->node;\n+                    list->doc = ctxt->myDoc;\n+                    if (list->next == NULL)\n+                        ent->last = list;\n+                    list = list->next;\n+                }\n+                list = ent->children;\n+#ifdef LIBXML_LEGACY_ENABLED\n+                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n+                    xmlAddEntityReference(ent, list, NULL);\n+#endif \/* LIBXML_LEGACY_ENABLED *\/\n@@ -7277,1 +7428,0 @@\n-            xmlParserEntityCheck(ctxt, 0, ent, 0);\n@@ -7282,2 +7432,0 @@\n-        if (ent->checked == 0)\n-            ent->checked = 2;\n@@ -7287,2 +7435,0 @@\n-    } else if (ent->checked != 1) {\n-        ctxt->nbentities += ent->checked \/ 2;\n@@ -7322,0 +7468,2 @@\n+                unsigned long oldsizeentities = ctxt->sizeentities;\n+\n@@ -7327,0 +7475,3 @@\n+\n+                \/* Undo the change to sizeentities *\/\n+                ctxt->sizeentities = oldsizeentities;\n@@ -7336,0 +7487,2 @@\n+            if (xmlParserEntityCheck(ctxt, 0))\n+                return;\n@@ -7348,0 +7501,8 @@\n+    \/*\n+     * We also check for amplification if entities aren't substituted.\n+     * They might be expanded later.\n+     *\/\n+    if ((was_checked != 0) &&\n+        (xmlParserEntityCheck(ctxt, ent->expandedSize)))\n+        return;\n+\n@@ -7360,1 +7521,1 @@\n-    if ((ctxt->replaceEntities) || (ent->children == NULL))  {\n+    if (ctxt->replaceEntities)  {\n@@ -7374,1 +7535,1 @@\n-        if ((ctxt->node != NULL) && (ent->children != NULL)) {\n+        if (ctxt->node != NULL) {\n@@ -7384,7 +7545,0 @@\n-                \/*\n-                 * We are copying here, make sure there is no abuse\n-                 *\/\n-                ctxt->sizeentcopy += ent->length + 5;\n-                if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))\n-                    return;\n-\n@@ -7432,7 +7586,0 @@\n-                \/*\n-                 * We are copying here, make sure there is no abuse\n-                 *\/\n-                ctxt->sizeentcopy += ent->length + 5;\n-                if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))\n-                    return;\n-\n@@ -7461,1 +7608,0 @@\n-                        xmlAddChild(ctxt->node, cur);\n@@ -7463,0 +7609,1 @@\n+                    xmlAddChild(ctxt->node, cur);\n@@ -7506,1 +7653,3 @@\n- * parse ENTITY references declarations\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse an entitiy reference. Always consumes '&'.\n@@ -7563,5 +7712,0 @@\n-    \/*\n-     * Increase the number of entity references parsed\n-     *\/\n-    ctxt->nbentities++;\n-\n@@ -7617,0 +7761,1 @@\n+                (ctxt->disableSAX == 0) &&\n@@ -7621,1 +7766,0 @@\n-        xmlParserEntityCheck(ctxt, 0, ent, 0);\n@@ -7652,1 +7796,0 @@\n-             (ent != NULL) &&\n@@ -7654,4 +7797,4 @@\n-        if (((ent->checked & 1) || (ent->checked == 0)) &&\n-             (ent->content != NULL) && (xmlStrchr(ent->content, '<'))) {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n-        \"'<' in entity '%s' is not allowed in attributes values\\n\", name);\n+        if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {\n+            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))\n+                ent->flags |= XML_ENT_CONTAINS_LT;\n+            ent->flags |= XML_ENT_CHECKED_LT;\n@@ -7659,0 +7802,4 @@\n+        if (ent->flags & XML_ENT_CONTAINS_LT)\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n+                    \"'<' in entity '%s' is not allowed in attributes \"\n+                    \"values\\n\", name);\n@@ -7760,5 +7907,0 @@\n-    \/*\n-     * Increase the number of entity references parsed\n-     *\/\n-    ctxt->nbentities++;\n-\n@@ -7815,1 +7957,0 @@\n-        xmlParserEntityCheck(ctxt, 0, ent, 0);\n@@ -7846,6 +7987,10 @@\n-             (ent != NULL) && (ent->content != NULL) &&\n-             (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-             (xmlStrchr(ent->content, '<'))) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n-     \"'<' in entity '%s' is not allowed in attributes values\\n\",\n-                          name);\n+             (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {\n+        if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {\n+            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))\n+                ent->flags |= XML_ENT_CONTAINS_LT;\n+            ent->flags |= XML_ENT_CHECKED_LT;\n+        }\n+        if (ent->flags & XML_ENT_CONTAINS_LT)\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n+                    \"'<' in entity '%s' is not allowed in attributes \"\n+                    \"values\\n\", name);\n@@ -7886,1 +8031,4 @@\n- * parse PEReference declarations\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse a parameter entity reference. Always consumes '%'.\n+ *\n@@ -7936,5 +8084,0 @@\n-    \/*\n-     * Increase the number of entity references parsed\n-     *\/\n-    ctxt->nbentities++;\n-\n@@ -7982,1 +8125,0 @@\n-        xmlParserEntityCheck(ctxt, 0, NULL, 0);\n@@ -7993,5 +8135,2 @@\n-            xmlChar start[4];\n-            xmlCharEncoding enc;\n-\n-            if (xmlParserEntityCheck(ctxt, 0, entity, 0))\n-                return;\n+            unsigned long parentConsumed;\n+            xmlEntityPtr oldEnt;\n@@ -8008,0 +8147,17 @@\n+            if (entity->flags & XML_ENT_EXPANDING) {\n+                xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+                xmlHaltParser(ctxt);\n+                return;\n+            }\n+\n+            \/* Must be computed from old input before pushing new input. *\/\n+            parentConsumed = ctxt->input->parentConsumed;\n+            oldEnt = ctxt->input->entity;\n+            if ((oldEnt == NULL) ||\n+                ((oldEnt->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+                 ((oldEnt->flags & XML_ENT_PARSED) == 0))) {\n+                xmlSaturatedAdd(&parentConsumed, ctxt->input->consumed);\n+                xmlSaturatedAddSizeT(&parentConsumed,\n+                                     ctxt->input->cur - ctxt->input->base);\n+            }\n+\n@@ -8014,0 +8170,4 @@\n+            entity->flags |= XML_ENT_EXPANDING;\n+\n+            input->parentConsumed = parentConsumed;\n+\n@@ -8015,22 +8175,1 @@\n-                \/*\n-                 * Get the 4 first bytes and decode the charset\n-                 * if enc != XML_CHAR_ENCODING_NONE\n-                 * plug some encoding conversion routines.\n-                 * Note that, since we may have some non-UTF8\n-                 * encoding (like UTF16, bug 135229), the 'length'\n-                 * is not known, but we can calculate based upon\n-                 * the amount of data in the buffer.\n-                 *\/\n-                GROW\n-                if (ctxt->instate == XML_PARSER_EOF)\n-                    return;\n-                if ((ctxt->input->end - ctxt->input->cur)>=4) {\n-                    start[0] = RAW;\n-                    start[1] = NXT(1);\n-                    start[2] = NXT(2);\n-                    start[3] = NXT(3);\n-                    enc = xmlDetectCharEncoding(start, 4);\n-                    if (enc != XML_CHAR_ENCODING_NONE) {\n-                        xmlSwitchEncoding(ctxt, enc);\n-                    }\n-                }\n+                xmlDetectEncoding(ctxt);\n@@ -8061,4 +8200,8 @@\n-    xmlParserInputPtr input;\n-    xmlBufferPtr buf;\n-    int l, c;\n-    int count = 0;\n+    xmlParserInputPtr oldinput, input = NULL;\n+    xmlParserInputPtr *oldinputTab;\n+    const xmlChar *oldencoding;\n+    xmlChar *content = NULL;\n+    size_t length, i;\n+    int oldinputNr, oldinputMax, oldprogressive;\n+    int ret = -1;\n+    int res;\n@@ -8079,9 +8222,2 @@\n-    buf = xmlBufferCreate();\n-    if (buf == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                    \"xmlLoadEntityContent parameter error\");\n-        return(-1);\n-    }\n-    xmlBufferSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n-\n-    input = xmlNewEntityInputStream(ctxt, entity);\n+    input = xmlLoadExternalEntity((char *) entity->URI,\n+           (char *) entity->ExternalID, ctxt);\n@@ -8091,1 +8227,0 @@\n-        xmlBufferFree(buf);\n@@ -8095,6 +8230,15 @@\n-    \/*\n-     * Push the entity as the current input, read char by char\n-     * saving to the buffer until the end of the entity or an error\n-     *\/\n-    if (xmlPushInput(ctxt, input) < 0) {\n-        xmlBufferFree(buf);\n+    oldinput = ctxt->input;\n+    oldinputNr = ctxt->inputNr;\n+    oldinputMax = ctxt->inputMax;\n+    oldinputTab = ctxt->inputTab;\n+    oldencoding = ctxt->encoding;\n+    oldprogressive = ctxt->progressive;\n+\n+    ctxt->input = NULL;\n+    ctxt->inputNr = 0;\n+    ctxt->inputMax = 1;\n+    ctxt->encoding = NULL;\n+    ctxt->progressive = 0;\n+    ctxt->inputTab = xmlMalloc(sizeof(xmlParserInputPtr));\n+    if (ctxt->inputTab == NULL) {\n+        xmlErrMemory(ctxt, NULL);\n@@ -8102,1 +8246,1 @@\n-        return(-1);\n+        goto error;\n@@ -8105,23 +8249,18 @@\n-    GROW;\n-    c = CUR_CHAR(l);\n-    while ((ctxt->input == input) && (ctxt->input->cur < ctxt->input->end) &&\n-           (IS_CHAR(c))) {\n-        xmlBufferAdd(buf, ctxt->input->cur, l);\n-        if (count++ > XML_PARSER_CHUNK_SIZE) {\n-            count = 0;\n-            GROW;\n-            if (ctxt->instate == XML_PARSER_EOF) {\n-                xmlBufferFree(buf);\n-                return(-1);\n-            }\n-        }\n-        NEXTL(l);\n-        c = CUR_CHAR(l);\n-        if (c == 0) {\n-            count = 0;\n-            GROW;\n-            if (ctxt->instate == XML_PARSER_EOF) {\n-                xmlBufferFree(buf);\n-                return(-1);\n-            }\n-            c = CUR_CHAR(l);\n+    xmlBufResetInput(input->buf->buffer, input);\n+\n+    inputPush(ctxt, input);\n+\n+    xmlDetectEncoding(ctxt);\n+\n+    \/*\n+     * Parse a possible text declaration first\n+     *\/\n+    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n+        xmlParseTextDecl(ctxt);\n+        \/*\n+         * An XML-1.0 document can't reference an entity not XML-1.0\n+         *\/\n+        if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n+            (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n+                           \"Version mismatch between document and entity\\n\");\n@@ -8131,8 +8270,15 @@\n-    if ((ctxt->input == input) && (ctxt->input->cur >= ctxt->input->end)) {\n-        xmlPopInput(ctxt);\n-    } else if (!IS_CHAR(c)) {\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n-                          \"xmlLoadEntityContent: invalid char value %d\\n\",\n-                          c);\n-        xmlBufferFree(buf);\n-        return(-1);\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        goto error;\n+\n+    length = input->cur - input->base;\n+    xmlBufShrink(input->buf->buffer, length);\n+    xmlSaturatedAdd(&ctxt->sizeentities, length);\n+\n+    while ((res = xmlParserInputBufferGrow(input->buf, 4096)) > 0)\n+        ;\n+\n+    xmlBufResetInput(input->buf->buffer, input);\n+\n+    if (res < 0) {\n+        xmlFatalErr(ctxt, input->buf->error, NULL);\n+        goto error;\n@@ -8140,3 +8286,0 @@\n-    entity->content = buf->content;\n-    buf->content = NULL;\n-    xmlBufferFree(buf);\n@@ -8144,1 +8287,43 @@\n-    return(0);\n+    length = xmlBufUse(input->buf->buffer);\n+    content = xmlBufDetach(input->buf->buffer);\n+\n+    if (length > INT_MAX) {\n+        xmlErrMemory(ctxt, NULL);\n+        goto error;\n+    }\n+\n+    for (i = 0; i < length; ) {\n+        int clen = length - i;\n+        int c = xmlGetUTF8Char(content + i, &clen);\n+\n+        if ((c < 0) || (!IS_CHAR(c))) {\n+            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n+                              \"xmlLoadEntityContent: invalid char value %d\\n\",\n+                              content[i]);\n+            goto error;\n+        }\n+        i += clen;\n+    }\n+\n+    xmlSaturatedAdd(&ctxt->sizeentities, length);\n+    entity->content = content;\n+    entity->length = length;\n+    content = NULL;\n+    ret = 0;\n+\n+error:\n+    while (ctxt->inputNr > 0)\n+        xmlFreeInputStream(inputPop(ctxt));\n+    xmlFree(ctxt->inputTab);\n+    xmlFree((xmlChar *) ctxt->encoding);\n+\n+    ctxt->input = oldinput;\n+    ctxt->inputNr = oldinputNr;\n+    ctxt->inputMax = oldinputMax;\n+    ctxt->inputTab = oldinputTab;\n+    ctxt->encoding = oldencoding;\n+    ctxt->progressive = oldprogressive;\n+\n+    xmlFree(content);\n+\n+    return(ret);\n@@ -8207,5 +8392,0 @@\n-    \/*\n-     * Increase the number of entity references parsed\n-     *\/\n-    ctxt->nbentities++;\n-\n@@ -8249,1 +8429,0 @@\n-        xmlParserEntityCheck(ctxt, 0, NULL, 0);\n@@ -8271,0 +8450,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -8367,0 +8548,1 @@\n+        SKIP_BLANKS;\n@@ -8369,6 +8551,0 @@\n-            int id = ctxt->input->id;\n-            unsigned long cons = CUR_CONSUMED;\n-\n-            SKIP_BLANKS;\n-            xmlParseMarkupDecl(ctxt);\n-            xmlParsePEReference(ctxt);\n@@ -8383,3 +8559,5 @@\n-            }\n-\n-            if ((id == ctxt->input->id) && (cons == CUR_CONSUMED)) {\n+            } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {\n+                xmlParseMarkupDecl(ctxt);\n+            } else if (RAW == '%') {\n+                xmlParsePEReference(ctxt);\n+            } else {\n@@ -8387,5 +8565,4 @@\n-             \"xmlParseInternalSubset: error detected in Markup declaration\\n\");\n-                if (ctxt->inputNr > baseInputNr)\n-                    xmlPopInput(ctxt);\n-                else\n-                    break;\n+                        \"xmlParseInternalSubset: error detected in\"\n+                        \" Markup declaration\\n\");\n+                xmlHaltParser(ctxt);\n+                return;\n@@ -8393,0 +8570,3 @@\n+            SKIP_BLANKS;\n+            SHRINK;\n+            GROW;\n@@ -8416,0 +8596,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -8470,1 +8652,1 @@\n-        return(NULL);\n+        return(name);\n@@ -8509,2 +8691,3 @@\n- * parse a start of tag either for rule element or\n- * EmptyElement. In both case we don't parse the tag closing chars.\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse a start tag. Always consumes '<'.\n@@ -8564,3 +8747,0 @@\n-        int id = ctxt->input->id;\n-        unsigned long cons = CUR_CONSUMED;\n-\n@@ -8568,1 +8748,6 @@\n-        if ((attname != NULL) && (attvalue != NULL)) {\n+        if (attname == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n+                           \"xmlParseStartTag: problem parsing attributes\\n\");\n+            break;\n+        }\n+        if (attvalue != NULL) {\n@@ -8630,6 +8815,0 @@\n-        if ((cons == CUR_CONSUMED) && (id == ctxt->input->id) &&\n-            (attname == NULL) && (attvalue == NULL)) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n-                           \"xmlParseStartTag: problem parsing attributes\\n\");\n-            break;\n-        }\n@@ -8666,1 +8845,1 @@\n- * parse an end of tag\n+ * Parse an end tag. Always consumes '<\/'.\n@@ -8728,0 +8907,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -8749,2 +8930,2 @@\n-\/*\n- * xmlGetNamespace:\n+\/**\n+ * xmlParseQNameHashed:\n@@ -8752,1 +8933,3 @@\n- * @prefix:  the prefix to lookup\n+ * @prefix:  pointer to store the prefix part\n+ *\n+ * parse an XML Namespace QName\n@@ -8754,2 +8937,3 @@\n- * Lookup the namespace name for the @prefix (which ca be NULL)\n- * The prefix must come from the @ctxt->dict dictionary\n+ * [6]  QName  ::= (Prefix ':')? LocalPart\n+ * [7]  Prefix  ::= NCName\n+ * [8]  LocalPart  ::= NCName\n@@ -8757,1 +8941,1 @@\n- * Returns the namespace name or NULL if not bound\n+ * Returns the Name parsed or NULL\n@@ -8759,3 +8943,0 @@\n-static const xmlChar *\n-xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {\n-    int i;\n@@ -8763,6 +8944,20 @@\n-    if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);\n-    for (i = ctxt->nsNr - 2;i >= 0;i-=2)\n-        if (ctxt->nsTab[i] == prefix) {\n-            if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))\n-                return(NULL);\n-            return(ctxt->nsTab[i + 1]);\n+static xmlHashedString\n+xmlParseQNameHashed(xmlParserCtxtPtr ctxt, xmlHashedString *prefix) {\n+    xmlHashedString l, p;\n+    int start, isNCName = 0;\n+\n+    l.name = NULL;\n+    p.name = NULL;\n+\n+    GROW;\n+    if (ctxt->instate == XML_PARSER_EOF)\n+        return(l);\n+    start = CUR_PTR - BASE_PTR;\n+\n+    l = xmlParseNCName(ctxt);\n+    if (l.name != NULL) {\n+        isNCName = 1;\n+        if (CUR == ':') {\n+            NEXT;\n+            p = l;\n+            l = xmlParseNCName(ctxt);\n@@ -8770,1 +8965,23 @@\n-    return(NULL);\n+    }\n+    if ((l.name == NULL) || (CUR == ':')) {\n+        xmlChar *tmp;\n+\n+        l.name = NULL;\n+        p.name = NULL;\n+        if (ctxt->instate == XML_PARSER_EOF)\n+            return(l);\n+        if ((isNCName == 0) && (CUR != ':'))\n+            return(l);\n+        tmp = xmlParseNmtoken(ctxt);\n+        if (tmp != NULL)\n+            xmlFree(tmp);\n+        if (ctxt->instate == XML_PARSER_EOF)\n+            return(l);\n+        l = xmlDictLookupHashed(ctxt->dict, BASE_PTR + start,\n+                                CUR_PTR - (BASE_PTR + start));\n+        xmlNsErr(ctxt, XML_NS_ERR_QNAME,\n+                 \"Failed to parse QName '%s'\\n\", l.name, NULL, NULL);\n+    }\n+\n+    *prefix = p;\n+    return(l);\n@@ -8789,3 +9006,1 @@\n-    const xmlChar *l, *p;\n-\n-    GROW;\n+    xmlHashedString n, p;\n@@ -8793,11 +9008,2 @@\n-    l = xmlParseNCName(ctxt);\n-    if (l == NULL) {\n-        if (CUR == ':') {\n-            l = xmlParseName(ctxt);\n-            if (l != NULL) {\n-                xmlNsErr(ctxt, XML_NS_ERR_QNAME,\n-                         \"Failed to parse QName '%s'\\n\", l, NULL, NULL);\n-                *prefix = NULL;\n-                return(l);\n-            }\n-        }\n+    n = xmlParseQNameHashed(ctxt, &p);\n+    if (n.name == NULL)\n@@ -8805,52 +9011,2 @@\n-    }\n-    if (CUR == ':') {\n-        NEXT;\n-        p = l;\n-        l = xmlParseNCName(ctxt);\n-        if (l == NULL) {\n-            xmlChar *tmp;\n-\n-            if (ctxt->instate == XML_PARSER_EOF)\n-                return(NULL);\n-            xmlNsErr(ctxt, XML_NS_ERR_QNAME,\n-                     \"Failed to parse QName '%s:'\\n\", p, NULL, NULL);\n-            l = xmlParseNmtoken(ctxt);\n-            if (l == NULL) {\n-                if (ctxt->instate == XML_PARSER_EOF)\n-                    return(NULL);\n-                tmp = xmlBuildQName(BAD_CAST \"\", p, NULL, 0);\n-            } else {\n-                tmp = xmlBuildQName(l, p, NULL, 0);\n-                xmlFree((char *)l);\n-            }\n-            p = xmlDictLookup(ctxt->dict, tmp, -1);\n-            if (tmp != NULL) xmlFree(tmp);\n-            *prefix = NULL;\n-            return(p);\n-        }\n-        if (CUR == ':') {\n-            xmlChar *tmp;\n-\n-            xmlNsErr(ctxt, XML_NS_ERR_QNAME,\n-                     \"Failed to parse QName '%s:%s:'\\n\", p, l, NULL);\n-            NEXT;\n-            tmp = (xmlChar *) xmlParseName(ctxt);\n-            if (tmp != NULL) {\n-                tmp = xmlBuildQName(tmp, l, NULL, 0);\n-                l = xmlDictLookup(ctxt->dict, tmp, -1);\n-                if (tmp != NULL) xmlFree(tmp);\n-                *prefix = p;\n-                return(l);\n-            }\n-            if (ctxt->instate == XML_PARSER_EOF)\n-                return(NULL);\n-            tmp = xmlBuildQName(BAD_CAST \"\", l, NULL, 0);\n-            l = xmlDictLookup(ctxt->dict, tmp, -1);\n-            if (tmp != NULL) xmlFree(tmp);\n-            *prefix = p;\n-            return(l);\n-        }\n-        *prefix = p;\n-    } else\n-        *prefix = NULL;\n-    return(l);\n+    *prefix = p.name;\n+    return(n.name);\n@@ -8908,0 +9064,2 @@\n+    if (ret == NULL)\n+        return(NULL);\n@@ -9093,0 +9251,1 @@\n+        if (alloc) *alloc = 0;\n@@ -9102,1 +9261,0 @@\n-    if (alloc) *alloc = 0;\n@@ -9124,1 +9282,1 @@\n-static const xmlChar *\n+static xmlHashedString\n@@ -9127,1 +9285,1 @@\n-                   const xmlChar ** prefix, xmlChar ** value,\n+                   xmlHashedString * hprefix, xmlChar ** value,\n@@ -9130,1 +9288,2 @@\n-    const xmlChar *name;\n+    xmlHashedString hname;\n+    const xmlChar *prefix, *name;\n@@ -9136,2 +9295,2 @@\n-    name = xmlParseQName(ctxt, prefix);\n-    if (name == NULL) {\n+    hname = xmlParseQNameHashed(ctxt, hprefix);\n+    if (hname.name == NULL) {\n@@ -9140,1 +9299,1 @@\n-        return (NULL);\n+        return(hname);\n@@ -9142,0 +9301,5 @@\n+    name = hname.name;\n+    if (hprefix->name != NULL)\n+        prefix = hprefix->name;\n+    else\n+        prefix = NULL;\n@@ -9150,1 +9314,2 @@\n-                                                 pref, elem, *prefix, name);\n+                                                 pref, elem,\n+                                                 prefix, name);\n@@ -9163,0 +9328,4 @@\n+        if (val == NULL) {\n+            hname.name = NULL;\n+            return(hname);\n+        }\n@@ -9185,1 +9354,1 @@\n-        return (NULL);\n+        return(hname);\n@@ -9188,1 +9357,1 @@\n-    if (*prefix == ctxt->str_xml) {\n+    if (prefix == ctxt->str_xml) {\n@@ -9224,1 +9393,50 @@\n-    return (name);\n+    return (hname);\n+}\n+\n+\/**\n+ * xmlAttrHashInsert:\n+ * @ctxt: parser context\n+ * @size: size of the hash table\n+ * @name: attribute name\n+ * @uri: namespace uri\n+ * @hashValue: combined hash value of name and uri\n+ * @aindex: attribute index (this is a multiple of 5)\n+ *\n+ * Inserts a new attribute into the hash table.\n+ *\n+ * Returns INT_MAX if no existing attribute was found, the attribute\n+ * index if an attribute was found, -1 if a memory allocation failed.\n+ *\/\n+static int\n+xmlAttrHashInsert(xmlParserCtxtPtr ctxt, unsigned size, const xmlChar *name,\n+                  const xmlChar *uri, unsigned hashValue, int aindex) {\n+    xmlAttrHashBucket *table = ctxt->attrHash;\n+    xmlAttrHashBucket *bucket;\n+    unsigned hindex;\n+\n+    hindex = hashValue & (size - 1);\n+    bucket = &table[hindex];\n+\n+    while (bucket->index >= 0) {\n+        const xmlChar **atts = &ctxt->atts[bucket->index];\n+\n+        if (name == atts[0]) {\n+            int nsIndex = (int) (ptrdiff_t) atts[2];\n+\n+            if ((nsIndex == NS_INDEX_EMPTY) ? (uri == NULL) :\n+                (nsIndex == NS_INDEX_XML) ? (uri == ctxt->str_xml_ns) :\n+                (uri == ctxt->nsTab[nsIndex * 2 + 1]))\n+                return(bucket->index);\n+        }\n+\n+        hindex++;\n+        bucket++;\n+        if (hindex >= size) {\n+            hindex = 0;\n+            bucket = table;\n+        }\n+    }\n+\n+    bucket->index = aindex;\n+\n+    return(INT_MAX);\n@@ -9226,0 +9444,1 @@\n+\n@@ -9230,2 +9449,2 @@\n- * parse a start of tag either for rule element or\n- * EmptyElement. In both case we don't parse the tag closing chars.\n+ * Parse a start tag. Always consumes '<'.\n+ *\n@@ -9257,1 +9476,5 @@\n-                  const xmlChar **URI, int *tlen) {\n+                  const xmlChar **URI, int *nbNsPtr) {\n+    xmlHashedString hlocalname;\n+    xmlHashedString hprefix;\n+    xmlHashedString hattname;\n+    xmlHashedString haprefix;\n@@ -9262,2 +9485,2 @@\n-    const xmlChar *nsname;\n-    xmlChar *attvalue;\n+    const xmlChar *uri;\n+    xmlChar *attvalue = NULL;\n@@ -9265,0 +9488,1 @@\n+    unsigned attrHashSize = 0;\n@@ -9267,3 +9491,2 @@\n-    int i, j, nbNs, attval;\n-    unsigned long cur;\n-    int nsNr = ctxt->nsNr;\n+    int i, j, nbNs, nbTotalDef, attval, nsIndex, maxAtts;\n+    int alloc = 0;\n@@ -9274,9 +9497,0 @@\n-    \/*\n-     * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that\n-     *       point since the attribute values may be stored as pointers to\n-     *       the buffer and calling SHRINK would destroy them !\n-     *       The Shrinking is only possible once the full set of attribute\n-     *       callbacks have been done.\n-     *\/\n-    SHRINK;\n-    cur = ctxt->input->cur - ctxt->input->base;\n@@ -9288,0 +9502,1 @@\n+    nbTotalDef = 0;\n@@ -9289,2 +9504,0 @@\n-    \/* Forget any namespaces added during an earlier parse of this element. *\/\n-    ctxt->nsNr = nsNr;\n@@ -9292,2 +9505,7 @@\n-    localname = xmlParseQName(ctxt, &prefix);\n-    if (localname == NULL) {\n+    if (xmlParserNsStartElement(ctxt->nsdb) < 0) {\n+        xmlErrMemory(ctxt, NULL);\n+        return(NULL);\n+    }\n+\n+    hlocalname = xmlParseQNameHashed(ctxt, &hprefix);\n+    if (hlocalname.name == NULL) {\n@@ -9298,1 +9516,2 @@\n-    *tlen = ctxt->input->cur - ctxt->input->base - cur;\n+    localname = hlocalname.name;\n+    prefix = hprefix.name;\n@@ -9308,0 +9527,24 @@\n+    \/*\n+     * The ctxt->atts array will be ultimately passed to the SAX callback\n+     * containing five xmlChar pointers for each attribute:\n+     *\n+     * [0] attribute name\n+     * [1] attribute prefix\n+     * [2] namespace URI\n+     * [3] attribute value\n+     * [4] end of attribute value\n+     *\n+     * To save memory, we reuse this array temporarily and store integers\n+     * in these pointer variables.\n+     *\n+     * [0] attribute name\n+     * [1] attribute prefix\n+     * [2] hash value of attribute prefix, and later namespace index\n+     * [3] for non-allocated values: ptrdiff_t offset into input buffer\n+     * [4] for non-allocated values: ptrdiff_t offset into input buffer\n+     *\n+     * The ctxt->attallocs array contains an additional unsigned int for\n+     * each attribute, containing the hash value of the attribute name\n+     * and the alloc flag in bit 31.\n+     *\/\n+\n@@ -9311,3 +9554,1 @@\n-        int id = ctxt->input->id;\n-        unsigned long cons = CUR_CONSUMED;\n-        int len = -1, alloc = 0;\n+        int len = -1;\n@@ -9315,3 +9556,9 @@\n-        attname = xmlParseAttribute2(ctxt, prefix, localname,\n-                                     &aprefix, &attvalue, &len, &alloc);\n-        if ((attname == NULL) || (attvalue == NULL))\n+        hattname = xmlParseAttribute2(ctxt, prefix, localname,\n+                                          &haprefix, &attvalue, &len,\n+                                          &alloc);\n+        if (hattname.name == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                 \"xmlParseStartTag: problem parsing attributes\\n\");\n+            break;\n+        }\n+        if (attvalue == NULL)\n@@ -9319,0 +9566,2 @@\n+        attname = hattname.name;\n+        aprefix = haprefix.name;\n@@ -9322,2 +9571,2 @@\n-            const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);\n-            xmlURIPtr uri;\n+            xmlHashedString huri;\n+            xmlURIPtr parsedUri;\n@@ -9325,6 +9574,5 @@\n-            if (URL == NULL) {\n-                xmlErrMemory(ctxt, \"dictionary allocation failure\");\n-                if ((attvalue != NULL) && (alloc != 0))\n-                    xmlFree(attvalue);\n-                localname = NULL;\n-                goto done;\n+            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);\n+            uri = huri.name;\n+            if (uri == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                goto next_attr;\n@@ -9332,3 +9580,3 @@\n-            if (*URL != 0) {\n-                uri = xmlParseURI((const char *) URL);\n-                if (uri == NULL) {\n+            if (*uri != 0) {\n+                parsedUri = xmlParseURI((const char *) uri);\n+                if (parsedUri == NULL) {\n@@ -9337,1 +9585,1 @@\n-                                       URL, NULL, NULL);\n+                                       uri, NULL, NULL);\n@@ -9339,1 +9587,1 @@\n-                    if (uri->scheme == NULL) {\n+                    if (parsedUri->scheme == NULL) {\n@@ -9342,1 +9590,1 @@\n-                                  URL, NULL, NULL);\n+                                  uri, NULL, NULL);\n@@ -9344,1 +9592,1 @@\n-                    xmlFreeURI(uri);\n+                    xmlFreeURI(parsedUri);\n@@ -9346,1 +9594,1 @@\n-                if (URL == ctxt->str_xml_ns) {\n+                if (uri == ctxt->str_xml_ns) {\n@@ -9355,1 +9603,1 @@\n-                    (xmlStrEqual(URL,\n+                    (xmlStrEqual(uri,\n@@ -9363,10 +9611,0 @@\n-            \/*\n-             * check that it's not a defined namespace\n-             *\/\n-            for (j = 1;j <= nbNs;j++)\n-                if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n-                    break;\n-            if (j <= nbNs)\n-                xmlErrAttributeDup(ctxt, NULL, attname);\n-            else\n-                if (nsPush(ctxt, NULL, URL) > 0) nbNs++;\n@@ -9374,0 +9612,2 @@\n+            if (xmlParserNsPush(ctxt, NULL, &huri, NULL, 0) > 0)\n+                nbNs++;\n@@ -9375,2 +9615,9 @@\n-            const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);\n-            xmlURIPtr uri;\n+            xmlHashedString huri;\n+            xmlURIPtr parsedUri;\n+\n+            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);\n+            uri = huri.name;\n+            if (uri == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                goto next_attr;\n+            }\n@@ -9379,1 +9626,1 @@\n-                if (URL != ctxt->str_xml_ns) {\n+                if (uri != ctxt->str_xml_ns) {\n@@ -9389,1 +9636,1 @@\n-            if (URL == ctxt->str_xml_ns) {\n+            if (uri == ctxt->str_xml_ns) {\n@@ -9404,1 +9651,1 @@\n-                (xmlStrEqual(URL,\n+                (xmlStrEqual(uri,\n@@ -9411,1 +9658,1 @@\n-            if ((URL == NULL) || (URL[0] == 0)) {\n+            if ((uri == NULL) || (uri[0] == 0)) {\n@@ -9417,2 +9664,2 @@\n-                uri = xmlParseURI((const char *) URL);\n-                if (uri == NULL) {\n+                parsedUri = xmlParseURI((const char *) uri);\n+                if (parsedUri == NULL) {\n@@ -9421,1 +9668,1 @@\n-                                       attname, URL, NULL);\n+                                       attname, uri, NULL);\n@@ -9423,1 +9670,1 @@\n-                    if ((ctxt->pedantic) && (uri->scheme == NULL)) {\n+                    if ((ctxt->pedantic) && (parsedUri->scheme == NULL)) {\n@@ -9426,1 +9673,1 @@\n-                                  attname, URL, NULL);\n+                                  attname, uri, NULL);\n@@ -9428,1 +9675,1 @@\n-                    xmlFreeURI(uri);\n+                    xmlFreeURI(parsedUri);\n@@ -9432,11 +9679,2 @@\n-            \/*\n-             * check that it's not a defined namespace\n-             *\/\n-            for (j = 1;j <= nbNs;j++)\n-                if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n-                    break;\n-            if (j <= nbNs)\n-                xmlErrAttributeDup(ctxt, aprefix, attname);\n-            else\n-                if (nsPush(ctxt, attname, URL) > 0) nbNs++;\n-\n+            if (xmlParserNsPush(ctxt, &hattname, &huri, NULL, 0) > 0)\n+                nbNs++;\n@@ -9445,1 +9683,2 @@\n-             * Add the pair to atts\n+             * Populate attributes array, see above for repurposing\n+             * of xmlChar pointers.\n@@ -9454,1 +9693,2 @@\n-            ctxt->attallocs[nratts++] = alloc;\n+            ctxt->attallocs[nratts++] = (hattname.hashValue & 0x7FFFFFFF) |\n+                                        ((unsigned) alloc << 31);\n@@ -9457,13 +9697,15 @@\n-            \/*\n-             * The namespace URI field is used temporarily to point at the\n-             * base of the current input buffer for non-alloced attributes.\n-             * When the input buffer is reallocated, all the pointers become\n-             * invalid, but they can be reconstructed later.\n-             *\/\n-            if (alloc)\n-                atts[nbatts++] = NULL;\n-            else\n-                atts[nbatts++] = ctxt->input->base;\n-            atts[nbatts++] = attvalue;\n-            attvalue += len;\n-            atts[nbatts++] = attvalue;\n+            atts[nbatts++] = (const xmlChar *) (size_t) haprefix.hashValue;\n+            if (alloc) {\n+                atts[nbatts++] = attvalue;\n+                attvalue += len;\n+                atts[nbatts++] = attvalue;\n+            } else {\n+                \/*\n+                 * attvalue points into the input buffer which can be\n+                 * reallocated. Store differences to input->base instead.\n+                 * The pointers will be reconstructed later.\n+                 *\/\n+                atts[nbatts++] = (void *) (attvalue - BASE_PTR);\n+                attvalue += len;\n+                atts[nbatts++] = (void *) (attvalue - BASE_PTR);\n+            }\n@@ -9493,6 +9735,0 @@\n-        if ((cons == CUR_CONSUMED) && (id == ctxt->input->id) &&\n-            (attname == NULL) && (attvalue == NULL)) {\n-            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                 \"xmlParseStartTag: problem parsing attributes\\n\");\n-            break;\n-        }\n@@ -9509,14 +9745,0 @@\n-    \/* Reconstruct attribute value pointers. *\/\n-    for (i = 0, j = 0; j < nratts; i += 5, j++) {\n-        if (atts[i+2] != NULL) {\n-            \/*\n-             * Arithmetic on dangling pointers is technically undefined\n-             * behavior, but well...\n-             *\/\n-            ptrdiff_t offset = ctxt->input->base - atts[i+2];\n-            atts[i+2]  = NULL;    \/* Reset repurposed namespace URI *\/\n-            atts[i+3] += offset;  \/* value *\/\n-            atts[i+4] += offset;  \/* valuend *\/\n-        }\n-    }\n-\n@@ -9524,1 +9746,1 @@\n-     * The attributes defaulting\n+     * Namespaces from default attributes\n@@ -9531,3 +9753,5 @@\n-            for (i = 0;i < defaults->nbAttrs;i++) {\n-                attname = defaults->values[5 * i];\n-                aprefix = defaults->values[5 * i + 1];\n+            for (i = 0; i < defaults->nbAttrs; i++) {\n+                xmlDefAttr *attr = &defaults->attrs[i];\n+\n+                attname = attr->name.name;\n+                aprefix = attr->prefix.name;\n@@ -9535,3 +9759,0 @@\n-                \/*\n-                 * special work for namespaces defaulted defs\n-                 *\/\n@@ -9539,7 +9760,1 @@\n-                    \/*\n-                     * check that it's not a defined namespace\n-                     *\/\n-                    for (j = 1;j <= nbNs;j++)\n-                        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n-                            break;\n-                    if (j <= nbNs) continue;\n+                    xmlParserEntityCheck(ctxt, attr->expandedSize);\n@@ -9547,6 +9762,2 @@\n-                    nsname = xmlGetNamespace(ctxt, NULL);\n-                    if (nsname != defaults->values[5 * i + 2]) {\n-                        if (nsPush(ctxt, NULL,\n-                                   defaults->values[5 * i + 2]) > 0)\n-                            nbNs++;\n-                    }\n+                    if (xmlParserNsPush(ctxt, NULL, &attr->value, NULL, 1) > 0)\n+                        nbNs++;\n@@ -9554,7 +9765,1 @@\n-                    \/*\n-                     * check that it's not a defined namespace\n-                     *\/\n-                    for (j = 1;j <= nbNs;j++)\n-                        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n-                            break;\n-                    if (j <= nbNs) continue;\n+                    xmlParserEntityCheck(ctxt, attr->expandedSize);\n@@ -9562,6 +9767,3 @@\n-                    nsname = xmlGetNamespace(ctxt, attname);\n-                    if (nsname != defaults->values[2]) {\n-                        if (nsPush(ctxt, attname,\n-                                   defaults->values[5 * i + 2]) > 0)\n-                            nbNs++;\n-                    }\n+                    if (xmlParserNsPush(ctxt, &attr->name, &attr->value,\n+                                      NULL, 1) > 0)\n+                        nbNs++;\n@@ -9569,32 +9771,1 @@\n-                    \/*\n-                     * check that it's not a defined attribute\n-                     *\/\n-                    for (j = 0;j < nbatts;j+=5) {\n-                        if ((attname == atts[j]) && (aprefix == atts[j+1]))\n-                            break;\n-                    }\n-                    if (j < nbatts) continue;\n-\n-                    if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n-                        if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n-                            localname = NULL;\n-                            goto done;\n-                        }\n-                        maxatts = ctxt->maxatts;\n-                        atts = ctxt->atts;\n-                    }\n-                    atts[nbatts++] = attname;\n-                    atts[nbatts++] = aprefix;\n-                    if (aprefix == NULL)\n-                        atts[nbatts++] = NULL;\n-                    else\n-                        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);\n-                    atts[nbatts++] = defaults->values[5 * i + 2];\n-                    atts[nbatts++] = defaults->values[5 * i + 3];\n-                    if ((ctxt->standalone == 1) &&\n-                        (defaults->values[5 * i + 4] != NULL)) {\n-                        xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n-          \"standalone: attribute %s on %s defaulted from external subset\\n\",\n-                                         attname, localname);\n-                    }\n-                    nbdef++;\n+                    nbTotalDef += 1;\n@@ -9607,1 +9778,1 @@\n-     * The attributes checkings\n+     * Resolve attribute namespaces\n@@ -9609,1 +9780,4 @@\n-    for (i = 0; i < nbatts;i += 5) {\n+    for (i = 0; i < nbatts; i += 5) {\n+        attname = atts[i];\n+        aprefix = atts[i+1];\n+\n@@ -9613,3 +9787,9 @@\n-        if (atts[i + 1] != NULL) {\n-            nsname = xmlGetNamespace(ctxt, atts[i + 1]);\n-            if (nsname == NULL) {\n+        if (aprefix == NULL) {\n+            nsIndex = NS_INDEX_EMPTY;\n+        } else if (aprefix == ctxt->str_xml) {\n+            nsIndex = NS_INDEX_XML;\n+        } else {\n+            haprefix.name = aprefix;\n+            haprefix.hashValue = (size_t) atts[i+2];\n+            nsIndex = xmlParserNsLookup(ctxt, &haprefix, NULL);\n+            if (nsIndex == INT_MAX) {\n@@ -9618,1 +9798,2 @@\n-                    atts[i + 1], atts[i], localname);\n+                    aprefix, attname, localname);\n+                nsIndex = NS_INDEX_EMPTY;\n@@ -9620,16 +9801,71 @@\n-            atts[i + 2] = nsname;\n-        } else\n-            nsname = NULL;\n-        \/*\n-         * [ WFC: Unique Att Spec ]\n-         * No attribute name may appear more than once in the same\n-         * start-tag or empty-element tag.\n-         * As extended by the Namespace in XML REC.\n-         *\/\n-        for (j = 0; j < i;j += 5) {\n-            if (atts[i] == atts[j]) {\n-                if (atts[i+1] == atts[j+1]) {\n-                    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);\n-                    break;\n-                }\n-                if ((nsname != NULL) && (atts[j + 2] == nsname)) {\n+        }\n+\n+        atts[i+2] = (const xmlChar *) (ptrdiff_t) nsIndex;\n+    }\n+\n+    \/*\n+     * Maximum number of attributes including default attributes.\n+     *\/\n+    maxAtts = nratts + nbTotalDef;\n+\n+    \/*\n+     * Verify that attribute names are unique.\n+     *\/\n+    if (maxAtts > 1) {\n+        attrHashSize = 4;\n+        while (attrHashSize \/ 2 < (unsigned) maxAtts)\n+            attrHashSize *= 2;\n+\n+        if (attrHashSize > ctxt->attrHashMax) {\n+            xmlAttrHashBucket *tmp;\n+\n+            tmp = xmlRealloc(ctxt->attrHash, attrHashSize * sizeof(tmp[0]));\n+            if (tmp == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                goto done;\n+            }\n+\n+            ctxt->attrHash = tmp;\n+            ctxt->attrHashMax = attrHashSize;\n+        }\n+\n+        memset(ctxt->attrHash, -1, attrHashSize * sizeof(ctxt->attrHash[0]));\n+\n+        for (i = 0, j = 0; j < nratts; i += 5, j++) {\n+            const xmlChar *nsuri;\n+            unsigned hashValue, nameHashValue, uriHashValue;\n+            int res;\n+\n+            attname = atts[i];\n+            aprefix = atts[i+1];\n+            nsIndex = (ptrdiff_t) atts[i+2];\n+            \/* Hash values always have bit 31 set, see dict.c *\/\n+            nameHashValue = ctxt->attallocs[j] | 0x80000000;\n+\n+            if (nsIndex == NS_INDEX_EMPTY) {\n+                nsuri = NULL;\n+                uriHashValue = URI_HASH_EMPTY;\n+            } else if (nsIndex == NS_INDEX_XML) {\n+                nsuri = ctxt->str_xml_ns;\n+                uriHashValue = URI_HASH_XML;\n+            } else {\n+                nsuri = ctxt->nsTab[nsIndex * 2 + 1];\n+                uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;\n+            }\n+\n+            hashValue = xmlDictCombineHash(nameHashValue, uriHashValue);\n+            res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,\n+                                    hashValue, i);\n+            if (res < 0)\n+                continue;\n+\n+            \/*\n+             * [ WFC: Unique Att Spec ]\n+             * No attribute name may appear more than once in the same\n+             * start-tag or empty-element tag.\n+             * As extended by the Namespace in XML REC.\n+             *\/\n+            if (res < INT_MAX) {\n+                if (aprefix == atts[res+1]) {\n+                    xmlErrAttributeDup(ctxt, aprefix, attname);\n+                } else {\n@@ -9638,2 +9874,69 @@\n-                             atts[i], nsname, NULL);\n-                    break;\n+                             attname, nsuri, NULL);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Default attributes\n+     *\/\n+    if (ctxt->attsDefault != NULL) {\n+        xmlDefAttrsPtr defaults;\n+\n+        defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n+        if (defaults != NULL) {\n+            for (i = 0; i < defaults->nbAttrs; i++) {\n+                xmlDefAttr *attr = &defaults->attrs[i];\n+                const xmlChar *nsuri;\n+                unsigned hashValue, uriHashValue;\n+                int res;\n+\n+                attname = attr->name.name;\n+                aprefix = attr->prefix.name;\n+\n+                if ((attname == ctxt->str_xmlns) && (aprefix == NULL))\n+                    continue;\n+                if (aprefix == ctxt->str_xmlns)\n+                    continue;\n+\n+                if (aprefix == NULL) {\n+                    nsIndex = NS_INDEX_EMPTY;\n+                    nsuri = NULL;\n+                    uriHashValue = URI_HASH_EMPTY;\n+                } if (aprefix == ctxt->str_xml) {\n+                    nsIndex = NS_INDEX_XML;\n+                    nsuri = ctxt->str_xml_ns;\n+                    uriHashValue = URI_HASH_XML;\n+                } else if (aprefix != NULL) {\n+                    nsIndex = xmlParserNsLookup(ctxt, &attr->prefix, NULL);\n+                    if (nsIndex == INT_MAX) {\n+                        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n+                                 \"Namespace prefix %s for %s on %s is not \"\n+                                 \"defined\\n\",\n+                                 aprefix, attname, localname);\n+                        nsIndex = NS_INDEX_EMPTY;\n+                        nsuri = NULL;\n+                        uriHashValue = URI_HASH_EMPTY;\n+                    } else {\n+                        nsuri = ctxt->nsTab[nsIndex * 2 + 1];\n+                        uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;\n+                    }\n+                }\n+\n+                \/*\n+                 * Check whether the attribute exists\n+                 *\/\n+                if (maxAtts > 1) {\n+                    hashValue = xmlDictCombineHash(attr->name.hashValue,\n+                                                   uriHashValue);\n+                    res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,\n+                                            hashValue, nbatts);\n+                    if (res < 0)\n+                        continue;\n+                    if (res < INT_MAX) {\n+                        if (aprefix == atts[res+1])\n+                            continue;\n+                        xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,\n+                                 \"Namespaced Attribute %s in '%s' redefined\\n\",\n+                                 attname, nsuri, NULL);\n+                    }\n@@ -9641,0 +9944,24 @@\n+\n+                xmlParserEntityCheck(ctxt, attr->expandedSize);\n+\n+                if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n+                    if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n+                        localname = NULL;\n+                        goto done;\n+                    }\n+                    maxatts = ctxt->maxatts;\n+                    atts = ctxt->atts;\n+                }\n+\n+                atts[nbatts++] = attname;\n+                atts[nbatts++] = aprefix;\n+                atts[nbatts++] = (const xmlChar *) (ptrdiff_t) nsIndex;\n+                atts[nbatts++] = attr->value.name;\n+                atts[nbatts++] = attr->valueEnd;\n+                if ((ctxt->standalone == 1) && (attr->external != 0)) {\n+                    xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n+                            \"standalone: attribute %s on %s defaulted \"\n+                            \"from external subset\\n\",\n+                            attname, localname);\n+                }\n+                nbdef++;\n@@ -9645,2 +9972,21 @@\n-    nsname = xmlGetNamespace(ctxt, prefix);\n-    if ((prefix != NULL) && (nsname == NULL)) {\n+    \/*\n+     * Reconstruct attribute pointers\n+     *\/\n+    for (i = 0, j = 0; i < nbatts; i += 5, j++) {\n+        \/* namespace URI *\/\n+        nsIndex = (ptrdiff_t) atts[i+2];\n+        if (nsIndex == INT_MAX)\n+            atts[i+2] = NULL;\n+        else if (nsIndex == INT_MAX - 1)\n+            atts[i+2] = ctxt->str_xml_ns;\n+        else\n+            atts[i+2] = ctxt->nsTab[nsIndex * 2 + 1];\n+\n+        if ((j < nratts) && (ctxt->attallocs[j] & 0x80000000) == 0) {\n+            atts[i+3] = BASE_PTR + (ptrdiff_t) atts[i+3];  \/* value *\/\n+            atts[i+4] = BASE_PTR + (ptrdiff_t) atts[i+4];  \/* valuend *\/\n+        }\n+    }\n+\n+    uri = xmlParserNsLookupUri(ctxt, &hprefix);\n+    if ((prefix != NULL) && (uri == NULL)) {\n@@ -9652,1 +9998,1 @@\n-    *URI = nsname;\n+    *URI = uri;\n@@ -9655,1 +10001,1 @@\n-     * SAX: Start of Element !\n+     * SAX callback\n@@ -9660,2 +10006,2 @@\n-            ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n-                          nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs],\n+            ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,\n+                          nbNs, ctxt->nsTab + 2 * (ctxt->nsNr - nbNs),\n@@ -9664,2 +10010,2 @@\n-            ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n-                          nsname, 0, NULL, nbatts \/ 5, nbdef, atts);\n+            ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,\n+                          0, NULL, nbatts \/ 5, nbdef, atts);\n@@ -9670,1 +10016,1 @@\n-     * Free up attribute allocated strings if needed\n+     * Free allocated attribute values\n@@ -9673,3 +10019,3 @@\n-        for (i = 3,j = 0; j < nratts;i += 5,j++)\n-            if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))\n-                xmlFree((xmlChar *) atts[i]);\n+        for (i = 0, j = 0; j < nratts; i += 5, j++)\n+            if (ctxt->attallocs[j] & 0x80000000)\n+                xmlFree((xmlChar *) atts[i+3]);\n@@ -9678,0 +10024,1 @@\n+    *nbNsPtr = nbNs;\n@@ -9687,1 +10034,1 @@\n- * parse an end of tag\n+ * Parse an end tag. Always consumes '<\/'.\n@@ -9747,1 +10094,1 @@\n-        nsPop(ctxt, tag->nsNr);\n+        xmlParserNsPop(ctxt, tag->nsNr);\n@@ -9754,1 +10101,3 @@\n- * Parse escaped pure raw content.\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Parse escaped pure raw content. Always consumes '<!['.\n@@ -9772,1 +10121,0 @@\n-    int count = 0;\n@@ -9777,4 +10125,1 @@\n-    \/* Check 2.6.0 was NXT(0) not RAW *\/\n-    if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n-        SKIP(9);\n-    } else\n+    if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))\n@@ -9782,0 +10127,5 @@\n+    SKIP(3);\n+\n+    if (!CMP6(CUR_PTR, 'C', 'D', 'A', 'T', 'A', '['))\n+        return;\n+    SKIP(6);\n@@ -9787,2 +10137,1 @@\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        return;\n+        goto out;\n@@ -9794,2 +10143,1 @@\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        return;\n+        goto out;\n@@ -9799,1 +10147,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+    buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -9802,1 +10150,1 @@\n-        return;\n+        goto out;\n@@ -9809,1 +10157,1 @@\n-            tmp = (xmlChar *) xmlRealloc(buf, size * 2 * sizeof(xmlChar));\n+            tmp = (xmlChar *) xmlRealloc(buf, size * 2);\n@@ -9811,1 +10159,0 @@\n-                xmlFree(buf);\n@@ -9813,1 +10160,1 @@\n-                return;\n+                goto out;\n@@ -9818,1 +10165,6 @@\n-        COPY_BUF(rl,buf,len,r);\n+        COPY_BUF(buf, len, r);\n+        if (len > maxLength) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n+                           \"CData section too big found\\n\");\n+            goto out;\n+        }\n@@ -9823,10 +10175,0 @@\n-        count++;\n-        if (count > 50) {\n-            SHRINK;\n-            GROW;\n-            if (ctxt->instate == XML_PARSER_EOF) {\n-                xmlFree(buf);\n-                return;\n-            }\n-            count = 0;\n-        }\n@@ -9835,6 +10177,0 @@\n-        if (len > maxLength) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n-                           \"CData section too big found\\n\");\n-            xmlFree(buf);\n-            return;\n-        }\n@@ -9843,1 +10179,4 @@\n-    ctxt->instate = XML_PARSER_CONTENT;\n+    if (ctxt->instate == XML_PARSER_EOF) {\n+        xmlFree(buf);\n+        return;\n+    }\n@@ -9847,2 +10186,1 @@\n-        xmlFree(buf);\n-        return;\n+        goto out;\n@@ -9861,0 +10199,4 @@\n+\n+out:\n+    if (ctxt->instate != XML_PARSER_EOF)\n+        ctxt->instate = XML_PARSER_CONTENT;\n@@ -9877,1 +10219,1 @@\n-    while ((RAW != 0) &&\n+    while ((ctxt->input->cur < ctxt->input->end) &&\n@@ -9879,2 +10221,0 @@\n-        int id = ctxt->input->id;\n-        unsigned long cons = CUR_CONSUMED;\n@@ -9933,1 +10273,1 @@\n-            xmlParseCharData(ctxt, 0);\n+            xmlParseCharDataInternal(ctxt, 0);\n@@ -9936,1 +10276,0 @@\n-        GROW;\n@@ -9938,7 +10277,1 @@\n-\n-        if ((cons == CUR_CONSUMED) && (id == ctxt->input->id)) {\n-            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"detected an error in element content\\n\");\n-            xmlHaltParser(ctxt);\n-            break;\n-        }\n+        GROW;\n@@ -9963,1 +10296,3 @@\n-    if ((ctxt->instate != XML_PARSER_EOF) && (ctxt->nameNr > nameNr)) {\n+    if ((ctxt->instate != XML_PARSER_EOF) &&\n+        (ctxt->errNo == XML_ERR_OK) &&\n+        (ctxt->nameNr > nameNr)) {\n@@ -9976,0 +10311,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -9995,6 +10332,8 @@\n-    if (CUR == 0) {\n-        const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n-        int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n-        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n-                \"Premature end of data in tag %s line %d\\n\",\n-                name, line, NULL);\n+    if (ctxt->input->cur >= ctxt->input->end) {\n+        if (ctxt->errNo == XML_ERR_OK) {\n+            const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n+            int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n+            xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n+                    \"Premature end of data in tag %s line %d\\n\",\n+                    name, line, NULL);\n+        }\n@@ -10013,0 +10352,2 @@\n+ *\n+ * Always consumes '<'.\n@@ -10020,3 +10361,3 @@\n-    int line, tlen = 0;\n-    xmlNodePtr ret;\n-    int nsNr = ctxt->nsNr;\n+    int line;\n+    xmlNodePtr cur;\n+    int nbNs = 0;\n@@ -10051,1 +10392,1 @@\n-        name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n+        name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);\n@@ -10062,2 +10403,2 @@\n-    nameNsPush(ctxt, name, prefix, URI, line, ctxt->nsNr - nsNr);\n-    ret = ctxt->node;\n+    nameNsPush(ctxt, name, prefix, URI, line, nbNs);\n+    cur = ctxt->node;\n@@ -10094,8 +10435,8 @@\n-        if (nsNr != ctxt->nsNr)\n-            nsPop(ctxt, ctxt->nsNr - nsNr);\n-        if ( ret != NULL && ctxt->record_info ) {\n-           node_info.end_pos = ctxt->input->consumed +\n-                              (CUR_PTR - ctxt->input->base);\n-           node_info.end_line = ctxt->input->line;\n-           node_info.node = ret;\n-           xmlParserAddNodeInfo(ctxt, &node_info);\n+        if (nbNs > 0)\n+            xmlParserNsPop(ctxt, nbNs);\n+        if (cur != NULL && ctxt->record_info) {\n+            node_info.node = cur;\n+            node_info.end_pos = ctxt->input->consumed +\n+                                (CUR_PTR - ctxt->input->base);\n+            node_info.end_line = ctxt->input->line;\n+            xmlParserAddNodeInfo(ctxt, &node_info);\n@@ -10107,0 +10448,6 @@\n+        if (cur != NULL && ctxt->record_info) {\n+            node_info.node = cur;\n+            node_info.end_pos = 0;\n+            node_info.end_line = 0;\n+            xmlParserAddNodeInfo(ctxt, &node_info);\n+        }\n@@ -10118,13 +10465,2 @@\n-        if (nsNr != ctxt->nsNr)\n-            nsPop(ctxt, ctxt->nsNr - nsNr);\n-\n-        \/*\n-         * Capture end position and add node\n-         *\/\n-        if ( ret != NULL && ctxt->record_info ) {\n-           node_info.end_pos = ctxt->input->consumed +\n-                              (CUR_PTR - ctxt->input->base);\n-           node_info.end_line = ctxt->input->line;\n-           node_info.node = ret;\n-           xmlParserAddNodeInfo(ctxt, &node_info);\n-        }\n+        if (nbNs > 0)\n+            xmlParserNsPop(ctxt, nbNs);\n@@ -10141,1 +10477,1 @@\n- * Parse the end of an XML element.\n+ * Parse the end of an XML element. Always consumes '<\/'.\n@@ -10145,2 +10481,1 @@\n-    xmlParserNodeInfo node_info;\n-    xmlNodePtr ret = ctxt->node;\n+    xmlNodePtr cur = ctxt->node;\n@@ -10148,1 +10483,3 @@\n-    if (ctxt->nameNr <= 0)\n+    if (ctxt->nameNr <= 0) {\n+        if ((RAW == '<') && (NXT(1) == '\/'))\n+            SKIP(2);\n@@ -10150,0 +10487,1 @@\n+    }\n@@ -10164,1 +10502,1 @@\n-     * Capture end position and add node\n+     * Capture end position\n@@ -10166,6 +10504,9 @@\n-    if ( ret != NULL && ctxt->record_info ) {\n-       node_info.end_pos = ctxt->input->consumed +\n-                          (CUR_PTR - ctxt->input->base);\n-       node_info.end_line = ctxt->input->line;\n-       node_info.node = ret;\n-       xmlParserAddNodeInfo(ctxt, &node_info);\n+    if (cur != NULL && ctxt->record_info) {\n+        xmlParserNodeInfoPtr node_info;\n+\n+        node_info = (xmlParserNodeInfoPtr) xmlParserFindNodeInfo(ctxt, cur);\n+        if (node_info != NULL) {\n+            node_info->end_pos = ctxt->input->consumed +\n+                                 (CUR_PTR - ctxt->input->base);\n+            node_info->end_line = ctxt->input->line;\n+        }\n@@ -10179,0 +10520,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10194,1 +10537,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+    buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -10219,1 +10562,1 @@\n-            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            tmp = (xmlChar *) xmlRealloc(buf, size);\n@@ -10239,0 +10582,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10286,0 +10631,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10297,0 +10644,3 @@\n+    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+                    XML_MAX_TEXT_LENGTH :\n+                    XML_MAX_NAME_LENGTH;\n@@ -10302,1 +10652,1 @@\n-        buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+        buf = (xmlChar *) xmlMallocAtomic(size);\n@@ -10320,1 +10670,1 @@\n-                tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+                tmp = (xmlChar *) xmlRealloc(buf, size);\n@@ -10329,0 +10679,5 @@\n+            if (len > maxLength) {\n+                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"EncName\");\n+                xmlFree(buf);\n+                return(NULL);\n+            }\n@@ -10331,5 +10686,0 @@\n-            if (cur == 0) {\n-                SHRINK;\n-                GROW;\n-                cur = CUR;\n-            }\n@@ -10348,0 +10698,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10362,7 +10714,12 @@\n-    if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g')) {\n-        SKIP(8);\n-        SKIP_BLANKS;\n-        if (RAW != '=') {\n-            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n-            return(NULL);\n-        }\n+    if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g') == 0)\n+        return(NULL);\n+\n+    SKIP(8);\n+    SKIP_BLANKS;\n+    if (RAW != '=') {\n+        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n+        return(NULL);\n+    }\n+    NEXT;\n+    SKIP_BLANKS;\n+    if (RAW == '\"') {\n@@ -10370,11 +10727,6 @@\n-        SKIP_BLANKS;\n-        if (RAW == '\"') {\n-            NEXT;\n-            encoding = xmlParseEncName(ctxt);\n-            if (RAW != '\"') {\n-                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-                xmlFree((xmlChar *) encoding);\n-                return(NULL);\n-            } else\n-                NEXT;\n-        } else if (RAW == '\\''){\n+        encoding = xmlParseEncName(ctxt);\n+        if (RAW != '\"') {\n+            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            xmlFree((xmlChar *) encoding);\n+            return(NULL);\n+        } else\n@@ -10382,15 +10734,5 @@\n-            encoding = xmlParseEncName(ctxt);\n-            if (RAW != '\\'') {\n-                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-                xmlFree((xmlChar *) encoding);\n-                return(NULL);\n-            } else\n-                NEXT;\n-        } else {\n-            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n-        }\n-\n-        \/*\n-         * Non standard parsing, allowing the user to ignore encoding\n-         *\/\n-        if (ctxt->options & XML_PARSE_IGNORE_ENC) {\n+    } else if (RAW == '\\''){\n+        NEXT;\n+        encoding = xmlParseEncName(ctxt);\n+        if (RAW != '\\'') {\n+            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n@@ -10399,55 +10741,4 @@\n-        }\n-\n-        \/*\n-         * UTF-16 encoding switch has already taken place at this stage,\n-         * more over the little-endian\/big-endian selection is already done\n-         *\/\n-        if ((encoding != NULL) &&\n-            ((!xmlStrcasecmp(encoding, BAD_CAST \"UTF-16\")) ||\n-             (!xmlStrcasecmp(encoding, BAD_CAST \"UTF16\")))) {\n-            \/*\n-             * If no encoding was passed to the parser, that we are\n-             * using UTF-16 and no decoder is present i.e. the\n-             * document is apparently UTF-8 compatible, then raise an\n-             * encoding mismatch fatal error\n-             *\/\n-            if ((ctxt->encoding == NULL) &&\n-                (ctxt->input->buf != NULL) &&\n-                (ctxt->input->buf->encoder == NULL)) {\n-                xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,\n-                  \"Document labelled UTF-16 but has UTF-8 content\\n\");\n-            }\n-            if (ctxt->encoding != NULL)\n-                xmlFree((xmlChar *) ctxt->encoding);\n-            ctxt->encoding = encoding;\n-        }\n-        \/*\n-         * UTF-8 encoding is handled natively\n-         *\/\n-        else if ((encoding != NULL) &&\n-            ((!xmlStrcasecmp(encoding, BAD_CAST \"UTF-8\")) ||\n-             (!xmlStrcasecmp(encoding, BAD_CAST \"UTF8\")))) {\n-            if (ctxt->encoding != NULL)\n-                xmlFree((xmlChar *) ctxt->encoding);\n-            ctxt->encoding = encoding;\n-        }\n-        else if (encoding != NULL) {\n-            xmlCharEncodingHandlerPtr handler;\n-\n-            if (ctxt->input->encoding != NULL)\n-                xmlFree((xmlChar *) ctxt->input->encoding);\n-            ctxt->input->encoding = encoding;\n-\n-            handler = xmlFindCharEncodingHandler((const char *) encoding);\n-            if (handler != NULL) {\n-                if (xmlSwitchToEncoding(ctxt, handler) < 0) {\n-                    \/* failed to convert *\/\n-                    ctxt->errNo = XML_ERR_UNSUPPORTED_ENCODING;\n-                    return(NULL);\n-                }\n-            } else {\n-                xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                        \"Unsupported encoding %s\\n\", encoding);\n-                return(NULL);\n-            }\n-        }\n+        } else\n+            NEXT;\n+    } else {\n+        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n@@ -10455,1 +10746,7 @@\n-    return(encoding);\n+\n+    if (encoding == NULL)\n+        return(NULL);\n+\n+    xmlSetDeclaredEncoding(ctxt, encoding);\n+\n+    return(ctxt->encoding);\n@@ -10462,0 +10759,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10546,0 +10845,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10560,1 +10861,2 @@\n-    ctxt->input->standalone = -2;\n+\n+    ctxt->standalone = -2;\n@@ -10627,1 +10929,1 @@\n-    if ((ctxt->input->encoding != NULL) && (!IS_BLANK_CH(RAW))) {\n+    if ((ctxt->encoding != NULL) && (!IS_BLANK_CH(RAW))) {\n@@ -10641,1 +10943,1 @@\n-    ctxt->input->standalone = xmlParseSDDecl(ctxt);\n+    ctxt->standalone = xmlParseSDDecl(ctxt);\n@@ -10651,0 +10953,2 @@\n+        int c;\n+\n@@ -10652,2 +10956,5 @@\n-        MOVETO_ENDTAG(CUR_PTR);\n-        NEXT;\n+        while ((c = CUR) != 0) {\n+            NEXT;\n+            if (c == '>')\n+                break;\n+        }\n@@ -10661,0 +10968,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10698,3 +11007,0 @@\n-    xmlChar start[4];\n-    xmlCharEncoding enc;\n-\n@@ -10721,17 +11027,1 @@\n-    if ((ctxt->encoding == NULL) &&\n-        ((ctxt->input->end - ctxt->input->cur) >= 4)) {\n-        \/*\n-         * Get the 4 first bytes and decode the charset\n-         * if enc != XML_CHAR_ENCODING_NONE\n-         * plug some encoding conversion routines.\n-         *\/\n-        start[0] = RAW;\n-        start[1] = NXT(1);\n-        start[2] = NXT(2);\n-        start[3] = NXT(3);\n-        enc = xmlDetectCharEncoding(&start[0], 4);\n-        if (enc != XML_CHAR_ENCODING_NONE) {\n-            xmlSwitchEncoding(ctxt, enc);\n-        }\n-    }\n-\n+    xmlDetectEncoding(ctxt);\n@@ -10744,9 +11034,1 @@\n-    \/*\n-     * Check for the XMLDecl in the Prolog.\n-     * do not GROW here to avoid the detected encoder to decode more\n-     * than just the first line, unless the amount of data is really\n-     * too small to hold \"<?xml version=\"1.0\" encoding=\"foo\"\n-     *\/\n-    if ((ctxt->input->end - ctxt->input->cur) < 35) {\n-       GROW;\n-    }\n+    GROW;\n@@ -10766,1 +11048,0 @@\n-        ctxt->standalone = ctxt->input->standalone;\n@@ -10837,2 +11118,8 @@\n-        if (RAW != 0) {\n-            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+        if (ctxt->input->cur < ctxt->input->end) {\n+            if (ctxt->errNo == XML_ERR_OK)\n+                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+        } else if ((ctxt->input->buf != NULL) &&\n+                   (ctxt->input->buf->encoder != NULL) &&\n+                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           \"Truncated multi-byte sequence at EOF\\n\");\n@@ -10890,3 +11177,0 @@\n-    xmlChar start[4];\n-    xmlCharEncoding enc;\n-\n@@ -10898,2 +11182,0 @@\n-    GROW;\n-\n@@ -10906,16 +11188,1 @@\n-    \/*\n-     * Get the 4 first bytes and decode the charset\n-     * if enc != XML_CHAR_ENCODING_NONE\n-     * plug some encoding conversion routines.\n-     *\/\n-    if ((ctxt->input->end - ctxt->input->cur) >= 4) {\n-        start[0] = RAW;\n-        start[1] = NXT(1);\n-        start[2] = NXT(2);\n-        start[3] = NXT(3);\n-        enc = xmlDetectCharEncoding(start, 4);\n-        if (enc != XML_CHAR_ENCODING_NONE) {\n-            xmlSwitchEncoding(ctxt, enc);\n-        }\n-    }\n-\n+    xmlDetectEncoding(ctxt);\n@@ -10988,1 +11255,1 @@\n- * xmlParseLookupSequence:\n+ * xmlParseLookupChar:\n@@ -10990,9 +11257,1 @@\n- * @first:  the first char to lookup\n- * @next:  the next char to lookup or zero\n- * @third:  the next char to lookup or zero\n- *\n- * Try to find if a sequence (first, next, third) or  just (first next) or\n- * (first) is available in the input stream.\n- * This function has a side effect of (possibly) incrementing ctxt->checkIndex\n- * to avoid rescanning sequences of bytes, it DOES change the state of the\n- * parser, do not use liberally.\n+ * @c:  character\n@@ -11000,2 +11259,1 @@\n- * Returns the index to the current parsing point if the full sequence\n- *      is available, -1 otherwise.\n+ * Check whether the input buffer contains a character.\n@@ -11004,15 +11262,5 @@\n-xmlParseLookupSequence(xmlParserCtxtPtr ctxt, xmlChar first,\n-                       xmlChar next, xmlChar third) {\n-    int base, len;\n-    xmlParserInputPtr in;\n-    const xmlChar *buf;\n-\n-    in = ctxt->input;\n-    if (in == NULL) return(-1);\n-    base = in->cur - in->base;\n-    if (base < 0) return(-1);\n-    if (ctxt->checkIndex > base)\n-        base = ctxt->checkIndex;\n-    if (in->buf == NULL) {\n-        buf = in->base;\n-        len = in->length;\n+xmlParseLookupChar(xmlParserCtxtPtr ctxt, int c) {\n+    const xmlChar *cur;\n+\n+    if (ctxt->checkIndex == 0) {\n+        cur = ctxt->input->cur + 1;\n@@ -11020,14 +11268,7 @@\n-        buf = xmlBufContent(in->buf->buffer);\n-        len = xmlBufUse(in->buf->buffer);\n-    }\n-    \/* take into account the sequence length *\/\n-    if (third) len -= 2;\n-    else if (next) len --;\n-    for (;base < len;base++) {\n-        if (buf[base] == first) {\n-            if (third != 0) {\n-                if ((buf[base + 1] != next) ||\n-                    (buf[base + 2] != third)) continue;\n-            } else if (next != 0) {\n-                if (buf[base + 1] != next) continue;\n-            }\n+        cur = ctxt->input->cur + ctxt->checkIndex;\n+    }\n+\n+    if (memchr(cur, c, ctxt->input->end - cur) == NULL) {\n+        size_t index = ctxt->input->end - ctxt->input->cur;\n+\n+        if (index > LONG_MAX) {\n@@ -11035,15 +11276,1 @@\n-#ifdef DEBUG_PUSH\n-            if (next == 0)\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: lookup '%c' found at %d\\n\",\n-                        first, base);\n-            else if (third == 0)\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: lookup '%c%c' found at %d\\n\",\n-                        first, next, base);\n-            else\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: lookup '%c%c%c' found at %d\\n\",\n-                        first, next, third, base);\n-#endif\n-            return(base - (in->cur - in->base));\n+            return(1);\n@@ -11051,0 +11278,5 @@\n+        ctxt->checkIndex = index;\n+        return(0);\n+    } else {\n+        ctxt->checkIndex = 0;\n+        return(1);\n@@ -11052,8 +11284,90 @@\n-    ctxt->checkIndex = base;\n-#ifdef DEBUG_PUSH\n-    if (next == 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"PP: lookup '%c' failed\\n\", first);\n-    else if (third == 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"PP: lookup '%c%c' failed\\n\", first, next);\n+}\n+\n+\/**\n+ * xmlParseLookupString:\n+ * @ctxt:  an XML parser context\n+ * @startDelta: delta to apply at the start\n+ * @str:  string\n+ * @strLen:  length of string\n+ *\n+ * Check whether the input buffer contains a string.\n+ *\/\n+static const xmlChar *\n+xmlParseLookupString(xmlParserCtxtPtr ctxt, size_t startDelta,\n+                     const char *str, size_t strLen) {\n+    const xmlChar *cur, *term;\n+\n+    if (ctxt->checkIndex == 0) {\n+        cur = ctxt->input->cur + startDelta;\n+    } else {\n+        cur = ctxt->input->cur + ctxt->checkIndex;\n+    }\n+\n+    term = BAD_CAST strstr((const char *) cur, str);\n+    if (term == NULL) {\n+        const xmlChar *end = ctxt->input->end;\n+        size_t index;\n+\n+        \/* Rescan (strLen - 1) characters. *\/\n+        if ((size_t) (end - cur) < strLen)\n+            end = cur;\n+        else\n+            end -= strLen - 1;\n+        index = end - ctxt->input->cur;\n+        if (index > LONG_MAX) {\n+            ctxt->checkIndex = 0;\n+            return(ctxt->input->end - strLen);\n+        }\n+        ctxt->checkIndex = index;\n+    } else {\n+        ctxt->checkIndex = 0;\n+    }\n+\n+    return(term);\n+}\n+\n+\/**\n+ * xmlParseLookupCharData:\n+ * @ctxt:  an XML parser context\n+ *\n+ * Check whether the input buffer contains terminated char data.\n+ *\/\n+static int\n+xmlParseLookupCharData(xmlParserCtxtPtr ctxt) {\n+    const xmlChar *cur = ctxt->input->cur + ctxt->checkIndex;\n+    const xmlChar *end = ctxt->input->end;\n+    size_t index;\n+\n+    while (cur < end) {\n+        if ((*cur == '<') || (*cur == '&')) {\n+            ctxt->checkIndex = 0;\n+            return(1);\n+        }\n+        cur++;\n+    }\n+\n+    index = cur - ctxt->input->cur;\n+    if (index > LONG_MAX) {\n+        ctxt->checkIndex = 0;\n+        return(1);\n+    }\n+    ctxt->checkIndex = index;\n+    return(0);\n+}\n+\n+\/**\n+ * xmlParseLookupGt:\n+ * @ctxt:  an XML parser context\n+ *\n+ * Check whether there's enough data in the input buffer to finish parsing\n+ * a start tag. This has to take quotes into account.\n+ *\/\n+static int\n+xmlParseLookupGt(xmlParserCtxtPtr ctxt) {\n+    const xmlChar *cur;\n+    const xmlChar *end = ctxt->input->end;\n+    int state = ctxt->endCheckState;\n+    size_t index;\n+\n+    if (ctxt->checkIndex == 0)\n+        cur = ctxt->input->cur + 1;\n@@ -11061,4 +11375,25 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"PP: lookup '%c%c%c' failed\\n\", first, next, third);\n-#endif\n-    return(-1);\n+        cur = ctxt->input->cur + ctxt->checkIndex;\n+\n+    while (cur < end) {\n+        if (state) {\n+            if (*cur == state)\n+                state = 0;\n+        } else if (*cur == '\\'' || *cur == '\"') {\n+            state = *cur;\n+        } else if (*cur == '>') {\n+            ctxt->checkIndex = 0;\n+            ctxt->endCheckState = 0;\n+            return(1);\n+        }\n+        cur++;\n+    }\n+\n+    index = cur - ctxt->input->cur;\n+    if (index > LONG_MAX) {\n+        ctxt->checkIndex = 0;\n+        ctxt->endCheckState = 0;\n+        return(1);\n+    }\n+    ctxt->checkIndex = index;\n+    ctxt->endCheckState = state;\n+    return(0);\n@@ -11068,1 +11403,1 @@\n- * xmlParseGetLasts:\n+ * xmlParseLookupInternalSubset:\n@@ -11070,2 +11405,0 @@\n- * @lastlt:  pointer to store the last '<' from the input\n- * @lastgt:  pointer to store the last '>' from the input\n@@ -11073,1 +11406,2 @@\n- * Lookup the last < and > in the current chunk\n+ * Check whether there's enough data in the input buffer to finish parsing\n+ * the internal subset.\n@@ -11075,4 +11409,13 @@\n-static void\n-xmlParseGetLasts(xmlParserCtxtPtr ctxt, const xmlChar **lastlt,\n-                 const xmlChar **lastgt) {\n-    const xmlChar *tmp;\n+static int\n+xmlParseLookupInternalSubset(xmlParserCtxtPtr ctxt) {\n+    \/*\n+     * Sorry, but progressive parsing of the internal subset is not\n+     * supported. We first check that the full content of the internal\n+     * subset is available and parsing is launched only at that point.\n+     * Internal subset ends with \"']' S? '>'\" in an unescaped section and\n+     * not in a ']]>' sequence which are conditional sections.\n+     *\/\n+    const xmlChar *cur, *start;\n+    const xmlChar *end = ctxt->input->end;\n+    int state = ctxt->endCheckState;\n+    size_t index;\n@@ -11080,4 +11423,4 @@\n-    if ((ctxt == NULL) || (lastlt == NULL) || (lastgt == NULL)) {\n-        xmlGenericError(xmlGenericErrorContext,\n-                    \"Internal error: xmlParseGetLasts\\n\");\n-        return;\n+    if (ctxt->checkIndex == 0) {\n+        cur = ctxt->input->cur + 1;\n+    } else {\n+        cur = ctxt->input->cur + ctxt->checkIndex;\n@@ -11085,21 +11428,11 @@\n-    if ((ctxt->progressive != 0) && (ctxt->inputNr == 1)) {\n-        tmp = ctxt->input->end;\n-        tmp--;\n-        while ((tmp >= ctxt->input->base) && (*tmp != '<')) tmp--;\n-        if (tmp < ctxt->input->base) {\n-            *lastlt = NULL;\n-            *lastgt = NULL;\n-        } else {\n-            *lastlt = tmp;\n-            tmp++;\n-            while ((tmp < ctxt->input->end) && (*tmp != '>')) {\n-                if (*tmp == '\\'') {\n-                    tmp++;\n-                    while ((tmp < ctxt->input->end) && (*tmp != '\\'')) tmp++;\n-                    if (tmp < ctxt->input->end) tmp++;\n-                } else if (*tmp == '\"') {\n-                    tmp++;\n-                    while ((tmp < ctxt->input->end) && (*tmp != '\"')) tmp++;\n-                    if (tmp < ctxt->input->end) tmp++;\n-                } else\n-                    tmp++;\n+    start = cur;\n+\n+    while (cur < end) {\n+        if (state == '-') {\n+            if ((*cur == '-') &&\n+                (cur[1] == '-') &&\n+                (cur[2] == '>')) {\n+                state = 0;\n+                cur += 3;\n+                start = cur;\n+                continue;\n@@ -11107,10 +11440,13 @@\n-            if (tmp < ctxt->input->end)\n-                *lastgt = tmp;\n-            else {\n-                tmp = *lastlt;\n-                tmp--;\n-                while ((tmp >= ctxt->input->base) && (*tmp != '>')) tmp--;\n-                if (tmp >= ctxt->input->base)\n-                    *lastgt = tmp;\n-                else\n-                    *lastgt = NULL;\n+        }\n+        else if (state == ']') {\n+            if (*cur == '>') {\n+                ctxt->checkIndex = 0;\n+                ctxt->endCheckState = 0;\n+                return(1);\n+            }\n+            if (IS_BLANK_CH(*cur)) {\n+                state = ' ';\n+            } else if (*cur != ']') {\n+                state = 0;\n+                start = cur;\n+                continue;\n@@ -11119,3 +11455,45 @@\n-    } else {\n-        *lastlt = NULL;\n-        *lastgt = NULL;\n+        else if (state == ' ') {\n+            if (*cur == '>') {\n+                ctxt->checkIndex = 0;\n+                ctxt->endCheckState = 0;\n+                return(1);\n+            }\n+            if (!IS_BLANK_CH(*cur)) {\n+                state = 0;\n+                start = cur;\n+                continue;\n+            }\n+        }\n+        else if (state != 0) {\n+            if (*cur == state) {\n+                state = 0;\n+                start = cur + 1;\n+            }\n+        }\n+        else if (*cur == '<') {\n+            if ((cur[1] == '!') &&\n+                (cur[2] == '-') &&\n+                (cur[3] == '-')) {\n+                state = '-';\n+                cur += 4;\n+                \/* Don't treat <!--> as comment *\/\n+                start = cur;\n+                continue;\n+            }\n+        }\n+        else if ((*cur == '\"') || (*cur == '\\'') || (*cur == ']')) {\n+            state = *cur;\n+        }\n+\n+        cur++;\n+    }\n+\n+    \/*\n+     * Rescan the three last characters to detect \"<!--\" and \"-->\"\n+     * split across chunks.\n+     *\/\n+    if ((state == 0) || (state == '-')) {\n+        if (cur - start < 3)\n+            cur = start;\n+        else\n+            cur -= 3;\n@@ -11123,0 +11501,9 @@\n+    index = cur - ctxt->input->cur;\n+    if (index > LONG_MAX) {\n+        ctxt->checkIndex = 0;\n+        ctxt->endCheckState = 0;\n+        return(1);\n+    }\n+    ctxt->checkIndex = index;\n+    ctxt->endCheckState = state;\n+    return(0);\n@@ -11124,0 +11511,1 @@\n+\n@@ -11204,1 +11592,1 @@\n-    int avail, tlen;\n+    size_t avail;\n@@ -11206,1 +11594,0 @@\n-    const xmlChar *lastlt, *lastgt;\n@@ -11211,53 +11598,0 @@\n-#ifdef DEBUG_PUSH\n-    switch (ctxt->instate) {\n-        case XML_PARSER_EOF:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try EOF\\n\"); break;\n-        case XML_PARSER_START:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try START\\n\"); break;\n-        case XML_PARSER_MISC:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try MISC\\n\");break;\n-        case XML_PARSER_COMMENT:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try COMMENT\\n\");break;\n-        case XML_PARSER_PROLOG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try PROLOG\\n\");break;\n-        case XML_PARSER_START_TAG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try START_TAG\\n\");break;\n-        case XML_PARSER_CONTENT:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try CONTENT\\n\");break;\n-        case XML_PARSER_CDATA_SECTION:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try CDATA_SECTION\\n\");break;\n-        case XML_PARSER_END_TAG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try END_TAG\\n\");break;\n-        case XML_PARSER_ENTITY_DECL:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try ENTITY_DECL\\n\");break;\n-        case XML_PARSER_ENTITY_VALUE:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try ENTITY_VALUE\\n\");break;\n-        case XML_PARSER_ATTRIBUTE_VALUE:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try ATTRIBUTE_VALUE\\n\");break;\n-        case XML_PARSER_DTD:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try DTD\\n\");break;\n-        case XML_PARSER_EPILOG:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try EPILOG\\n\");break;\n-        case XML_PARSER_PI:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try PI\\n\");break;\n-        case XML_PARSER_IGNORE:\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PP: try IGNORE\\n\");break;\n-    }\n-#endif\n-\n@@ -11266,2 +11600,1 @@\n-        xmlSHRINK(ctxt);\n-        ctxt->checkIndex = 0;\n+        xmlParserShrink(ctxt);\n@@ -11269,1 +11602,0 @@\n-    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n@@ -11275,26 +11607,1 @@\n-        if (ctxt->input == NULL) break;\n-        if (ctxt->input->buf == NULL)\n-            avail = ctxt->input->length -\n-                    (ctxt->input->cur - ctxt->input->base);\n-        else {\n-            \/*\n-             * If we are operating on converted input, try to flush\n-             * remaining chars to avoid them stalling in the non-converted\n-             * buffer. But do not do this in document start where\n-             * encoding=\"...\" may not have been read and we work on a\n-             * guessed encoding.\n-             *\/\n-            if ((ctxt->instate != XML_PARSER_START) &&\n-                (ctxt->input->buf->raw != NULL) &&\n-                (xmlBufIsEmpty(ctxt->input->buf->raw) == 0)) {\n-                size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,\n-                                                 ctxt->input);\n-                size_t current = ctxt->input->cur - ctxt->input->base;\n-\n-                xmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\n-                xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,\n-                                      base, current);\n-            }\n-            avail = xmlBufUse(ctxt->input->buf->buffer) -\n-                    (ctxt->input->cur - ctxt->input->base);\n-        }\n+        avail = ctxt->input->end - ctxt->input->cur;\n@@ -11310,3 +11617,5 @@\n-                if (ctxt->charset == XML_CHAR_ENCODING_NONE) {\n-                    xmlChar start[4];\n-                    xmlCharEncoding enc;\n+                \/*\n+                 * Very first chars read from the document flow.\n+                 *\/\n+                if ((!terminate) && (avail < 4))\n+                    goto done;\n@@ -11314,5 +11623,7 @@\n-                    \/*\n-                     * Very first chars read from the document flow.\n-                     *\/\n-                    if (avail < 4)\n-                        goto done;\n+                \/*\n+                 * We need more bytes to detect EBCDIC code pages.\n+                 * See xmlDetectEBCDIC.\n+                 *\/\n+                if ((CMP4(CUR_PTR, 0x4C, 0x6F, 0xA7, 0x94)) &&\n+                    (!terminate) && (avail < 200))\n+                    goto done;\n@@ -11320,15 +11631,5 @@\n-                    \/*\n-                     * Get the 4 first bytes and decode the charset\n-                     * if enc != XML_CHAR_ENCODING_NONE\n-                     * plug some encoding conversion routines,\n-                     * else xmlSwitchEncoding will set to (default)\n-                     * UTF8.\n-                     *\/\n-                    start[0] = RAW;\n-                    start[1] = NXT(1);\n-                    start[2] = NXT(2);\n-                    start[3] = NXT(3);\n-                    enc = xmlDetectCharEncoding(start, 4);\n-                    xmlSwitchEncoding(ctxt, enc);\n-                    break;\n-                }\n+                xmlDetectEncoding(ctxt);\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n+                ctxt->instate = XML_PARSER_XML_DECL;\n+                break;\n@@ -11336,1 +11637,2 @@\n-                if (avail < 2)\n+            case XML_PARSER_XML_DECL:\n+                if ((!terminate) && (avail < 2))\n@@ -11340,14 +11642,0 @@\n-                if (cur == 0) {\n-                    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n-                        ctxt->sax->setDocumentLocator(ctxt->userData,\n-                                                      &xmlDefaultSAXLocator);\n-                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n-                    xmlHaltParser(ctxt);\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: entering EOF\\n\");\n-#endif\n-                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-                        ctxt->sax->endDocument(ctxt->userData);\n-                    goto done;\n-                }\n@@ -11356,1 +11644,0 @@\n-                    if (avail < 5) return(ret);\n@@ -11358,5 +11645,2 @@\n-                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n-                        return(ret);\n-                    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n-                        ctxt->sax->setDocumentLocator(ctxt->userData,\n-                                                      &xmlDefaultSAXLocator);\n+                        (!xmlParseLookupString(ctxt, 2, \"?>\", 2)))\n+                        goto done;\n@@ -11368,4 +11652,0 @@\n-#ifdef DEBUG_PUSH\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"PP: Parsing XML Decl\\n\");\n-#endif\n@@ -11381,12 +11661,0 @@\n-                        ctxt->standalone = ctxt->input->standalone;\n-                        if ((ctxt->encoding == NULL) &&\n-                            (ctxt->input->encoding != NULL))\n-                            ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n-                        if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                            (!ctxt->disableSAX))\n-                            ctxt->sax->startDocument(ctxt->userData);\n-                        ctxt->instate = XML_PARSER_MISC;\n-#ifdef DEBUG_PUSH\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"PP: entering MISC\\n\");\n-#endif\n@@ -11395,8 +11663,0 @@\n-                        if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                            (!ctxt->disableSAX))\n-                            ctxt->sax->startDocument(ctxt->userData);\n-                        ctxt->instate = XML_PARSER_MISC;\n-#ifdef DEBUG_PUSH\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"PP: entering MISC\\n\");\n-#endif\n@@ -11405,3 +11665,0 @@\n-                    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n-                        ctxt->sax->setDocumentLocator(ctxt->userData,\n-                                                      &xmlDefaultSAXLocator);\n@@ -11413,8 +11670,0 @@\n-                    if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                        (!ctxt->disableSAX))\n-                        ctxt->sax->startDocument(ctxt->userData);\n-                    ctxt->instate = XML_PARSER_MISC;\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: entering MISC\\n\");\n-#endif\n@@ -11422,0 +11671,9 @@\n+                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n+                    ctxt->sax->setDocumentLocator(ctxt->userData,\n+                                                  &xmlDefaultSAXLocator);\n+                if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n+                    (!ctxt->disableSAX))\n+                    ctxt->sax->startDocument(ctxt->userData);\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n+                ctxt->instate = XML_PARSER_MISC;\n@@ -11428,1 +11686,1 @@\n-                int nsNr = ctxt->nsNr;\n+                int nbNs = 0;\n@@ -11430,1 +11688,1 @@\n-                if ((avail < 2) && (ctxt->inputNr == 1))\n+                if ((!terminate) && (avail < 2))\n@@ -11434,1 +11692,2 @@\n-                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+                    xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n+                                   \"Start tag expected, '<' not found\");\n@@ -11440,9 +11699,2 @@\n-                if (!terminate) {\n-                    if (ctxt->progressive) {\n-                        \/* > can be found unescaped in attribute values *\/\n-                        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n-                            goto done;\n-                    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n-                        goto done;\n-                    }\n-                }\n+                if ((!terminate) && (!xmlParseLookupGt(ctxt)))\n+                    goto done;\n@@ -11458,1 +11710,1 @@\n-                    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n+                    name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);\n@@ -11495,2 +11747,2 @@\n-                        if (ctxt->nsNr - nsNr > 0)\n-                            nsPop(ctxt, ctxt->nsNr - nsNr);\n+                        if (nbNs > 0)\n+                            xmlParserNsPop(ctxt, nbNs);\n@@ -11505,2 +11757,0 @@\n-                    if (ctxt->instate == XML_PARSER_EOF)\n-                        goto done;\n@@ -11508,9 +11758,1 @@\n-                    if (ctxt->nameNr == 0) {\n-                        ctxt->instate = XML_PARSER_EPILOG;\n-                    } else {\n-                        ctxt->instate = XML_PARSER_CONTENT;\n-                    }\n-                    ctxt->progressive = 1;\n-                    break;\n-                }\n-                if (RAW == '>') {\n+                } else if (RAW == '>') {\n@@ -11518,0 +11760,1 @@\n+                    nameNsPush(ctxt, name, prefix, URI, line, nbNs);\n@@ -11524,0 +11767,2 @@\n+                    if (nbNs > 0)\n+                        xmlParserNsPop(ctxt, nbNs);\n@@ -11525,1 +11770,0 @@\n-                nameNsPush(ctxt, name, prefix, URI, line, ctxt->nsNr - nsNr);\n@@ -11527,2 +11771,6 @@\n-                ctxt->instate = XML_PARSER_CONTENT;\n-                ctxt->progressive = 1;\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n+                if (ctxt->nameNr == 0)\n+                    ctxt->instate = XML_PARSER_EPILOG;\n+                else\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -11532,4 +11780,0 @@\n-                int id;\n-                unsigned long cons;\n-                if ((avail < 2) && (ctxt->inputNr == 1))\n-                    goto done;\n@@ -11537,1 +11781,0 @@\n-                next = ctxt->input->cur[1];\n@@ -11539,9 +11782,2 @@\n-                id = ctxt->input->id;\n-                cons = CUR_CONSUMED;\n-                if ((cur == '<') && (next == '\/')) {\n-                    ctxt->instate = XML_PARSER_END_TAG;\n-                    break;\n-                } else if ((cur == '<') && (next == '?')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n-                        ctxt->progressive = XML_PARSER_PI;\n+                if (cur == '<') {\n+                    if ((!terminate) && (avail < 2))\n@@ -11549,11 +11785,1 @@\n-                    }\n-                    xmlParsePI(ctxt);\n-                    ctxt->instate = XML_PARSER_CONTENT;\n-                    ctxt->progressive = 1;\n-                } else if ((cur == '<') && (next != '!')) {\n-                    ctxt->instate = XML_PARSER_START_TAG;\n-                    break;\n-                } else if ((cur == '<') && (next == '!') &&\n-                           (ctxt->input->cur[2] == '-') &&\n-                           (ctxt->input->cur[3] == '-')) {\n-                    int term;\n+                    next = ctxt->input->cur[1];\n@@ -11561,8 +11787,45 @@\n-                    if (avail < 4)\n-                        goto done;\n-                    ctxt->input->cur += 4;\n-                    term = xmlParseLookupSequence(ctxt, '-', '-', '>');\n-                    ctxt->input->cur -= 4;\n-                    if ((!terminate) && (term < 0)) {\n-                        ctxt->progressive = XML_PARSER_COMMENT;\n-                        goto done;\n+                    if (next == '\/') {\n+                        ctxt->instate = XML_PARSER_END_TAG;\n+                        break;\n+                    } else if (next == '?') {\n+                        if ((!terminate) &&\n+                            (!xmlParseLookupString(ctxt, 2, \"?>\", 2)))\n+                            goto done;\n+                        xmlParsePI(ctxt);\n+                        if (ctxt->instate == XML_PARSER_EOF)\n+                            goto done;\n+                        ctxt->instate = XML_PARSER_CONTENT;\n+                        break;\n+                    } else if (next == '!') {\n+                        if ((!terminate) && (avail < 3))\n+                            goto done;\n+                        next = ctxt->input->cur[2];\n+\n+                        if (next == '-') {\n+                            if ((!terminate) && (avail < 4))\n+                                goto done;\n+                            if (ctxt->input->cur[3] == '-') {\n+                                if ((!terminate) &&\n+                                    (!xmlParseLookupString(ctxt, 4, \"-->\", 3)))\n+                                    goto done;\n+                                xmlParseComment(ctxt);\n+                                if (ctxt->instate == XML_PARSER_EOF)\n+                                    goto done;\n+                                ctxt->instate = XML_PARSER_CONTENT;\n+                                break;\n+                            }\n+                        } else if (next == '[') {\n+                            if ((!terminate) && (avail < 9))\n+                                goto done;\n+                            if ((ctxt->input->cur[2] == '[') &&\n+                                (ctxt->input->cur[3] == 'C') &&\n+                                (ctxt->input->cur[4] == 'D') &&\n+                                (ctxt->input->cur[5] == 'A') &&\n+                                (ctxt->input->cur[6] == 'T') &&\n+                                (ctxt->input->cur[7] == 'A') &&\n+                                (ctxt->input->cur[8] == '[')) {\n+                                SKIP(9);\n+                                ctxt->instate = XML_PARSER_CDATA_SECTION;\n+                                break;\n+                            }\n+                        }\n@@ -11570,17 +11833,0 @@\n-                    xmlParseComment(ctxt);\n-                    ctxt->instate = XML_PARSER_CONTENT;\n-                    ctxt->progressive = 1;\n-                } else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\n-                    (ctxt->input->cur[2] == '[') &&\n-                    (ctxt->input->cur[3] == 'C') &&\n-                    (ctxt->input->cur[4] == 'D') &&\n-                    (ctxt->input->cur[5] == 'A') &&\n-                    (ctxt->input->cur[6] == 'T') &&\n-                    (ctxt->input->cur[7] == 'A') &&\n-                    (ctxt->input->cur[8] == '[')) {\n-                    SKIP(9);\n-                    ctxt->instate = XML_PARSER_CDATA_SECTION;\n-                    break;\n-                } else if ((cur == '<') && (next == '!') &&\n-                           (avail < 9)) {\n-                    goto done;\n@@ -11588,2 +11834,1 @@\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\n+                    if ((!terminate) && (!xmlParseLookupChar(ctxt, ';')))\n@@ -11592,0 +11837,1 @@\n+                    break;\n@@ -11605,12 +11851,3 @@\n-                    if ((ctxt->inputNr == 1) &&\n-                        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\n-                        if (!terminate) {\n-                            if (ctxt->progressive) {\n-                                if ((lastlt == NULL) ||\n-                                    (ctxt->input->cur > lastlt))\n-                                    goto done;\n-                            } else if (xmlParseLookupSequence(ctxt,\n-                                                              '<', 0, 0) < 0) {\n-                                goto done;\n-                            }\n-                        }\n+                    if (avail < XML_PARSER_BIG_BUFFER_SIZE) {\n+                        if ((!terminate) && (!xmlParseLookupCharData(ctxt)))\n+                            goto done;\n@@ -11619,6 +11856,1 @@\n-                    xmlParseCharData(ctxt, 0);\n-                }\n-                if ((cons == CUR_CONSUMED) && (id == ctxt->input->id)) {\n-                    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                                \"detected an error in element content\\n\");\n-                    xmlHaltParser(ctxt);\n+                    xmlParseCharDataInternal(ctxt, !terminate);\n@@ -11627,0 +11859,2 @@\n+\n+                ctxt->instate = XML_PARSER_START_TAG;\n@@ -11630,1 +11864,1 @@\n-                if (avail < 2)\n+                if ((!terminate) && (!xmlParseLookupChar(ctxt, '>')))\n@@ -11632,9 +11866,0 @@\n-                if (!terminate) {\n-                    if (ctxt->progressive) {\n-                        \/* > can be found unescaped in attribute values *\/\n-                        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n-                            goto done;\n-                    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n-                        goto done;\n-                    }\n-                }\n@@ -11649,3 +11874,3 @@\n-                if (ctxt->instate == XML_PARSER_EOF) {\n-                    \/* Nothing *\/\n-                } else if (ctxt->nameNr == 0) {\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n+                if (ctxt->nameNr == 0) {\n@@ -11662,23 +11887,21 @@\n-                int base;\n-\n-                base = xmlParseLookupSequence(ctxt, ']', ']', '>');\n-                if (base < 0) {\n-                    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\n-                        int tmp;\n-\n-                        tmp = xmlCheckCdataPush(ctxt->input->cur,\n-                                                XML_PARSER_BIG_BUFFER_SIZE, 0);\n-                        if (tmp < 0) {\n-                            tmp = -tmp;\n-                            ctxt->input->cur += tmp;\n-                            goto encoding_error;\n-                        }\n-                        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-                            if (ctxt->sax->cdataBlock != NULL)\n-                                ctxt->sax->cdataBlock(ctxt->userData,\n-                                                      ctxt->input->cur, tmp);\n-                            else if (ctxt->sax->characters != NULL)\n-                                ctxt->sax->characters(ctxt->userData,\n-                                                      ctxt->input->cur, tmp);\n-                        }\n-                        if (ctxt->instate == XML_PARSER_EOF)\n+                const xmlChar *term;\n+\n+                if (terminate) {\n+                    \/*\n+                     * Don't call xmlParseLookupString. If 'terminate'\n+                     * is set, checkIndex is invalid.\n+                     *\/\n+                    term = BAD_CAST strstr((const char *) ctxt->input->cur,\n+                                           \"]]>\");\n+                } else {\n+                    term = xmlParseLookupString(ctxt, 0, \"]]>\", 3);\n+                }\n+\n+                if (term == NULL) {\n+                    int tmp, size;\n+\n+                    if (terminate) {\n+                        \/* Unfinished CDATA section *\/\n+                        size = ctxt->input->end - ctxt->input->cur;\n+                    } else {\n+                        if (avail < XML_PARSER_BIG_BUFFER_SIZE + 2)\n@@ -11686,1 +11909,0 @@\n-                        SKIPL(tmp);\n@@ -11688,0 +11910,2 @@\n+                        \/* XXX: Why don't we pass the full buffer? *\/\n+                        size = XML_PARSER_BIG_BUFFER_SIZE;\n@@ -11689,1 +11913,17 @@\n-                    goto done;\n+                    tmp = xmlCheckCdataPush(ctxt->input->cur, size, 0);\n+                    if (tmp <= 0) {\n+                        tmp = -tmp;\n+                        ctxt->input->cur += tmp;\n+                        goto encoding_error;\n+                    }\n+                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n+                        if (ctxt->sax->cdataBlock != NULL)\n+                            ctxt->sax->cdataBlock(ctxt->userData,\n+                                                  ctxt->input->cur, tmp);\n+                        else if (ctxt->sax->characters != NULL)\n+                            ctxt->sax->characters(ctxt->userData,\n+                                                  ctxt->input->cur, tmp);\n+                    }\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    SKIPL(tmp);\n@@ -11691,0 +11931,1 @@\n+                    int base = term - CUR_PTR;\n@@ -11724,1 +11965,0 @@\n-                    ctxt->checkIndex = 0;\n@@ -11726,4 +11966,0 @@\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: entering CONTENT\\n\");\n-#endif\n@@ -11734,105 +11970,0 @@\n-                SKIP_BLANKS;\n-                if (ctxt->input->buf == NULL)\n-                    avail = ctxt->input->length -\n-                            (ctxt->input->cur - ctxt->input->base);\n-                else\n-                    avail = xmlBufUse(ctxt->input->buf->buffer) -\n-                            (ctxt->input->cur - ctxt->input->base);\n-                if (avail < 2)\n-                    goto done;\n-                cur = ctxt->input->cur[0];\n-                next = ctxt->input->cur[1];\n-                if ((cur == '<') && (next == '?')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n-                        ctxt->progressive = XML_PARSER_PI;\n-                        goto done;\n-                    }\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: Parsing PI\\n\");\n-#endif\n-                    xmlParsePI(ctxt);\n-                    if (ctxt->instate == XML_PARSER_EOF)\n-                        goto done;\n-                    ctxt->instate = XML_PARSER_MISC;\n-                    ctxt->progressive = 1;\n-                    ctxt->checkIndex = 0;\n-                } else if ((cur == '<') && (next == '!') &&\n-                    (ctxt->input->cur[2] == '-') &&\n-                    (ctxt->input->cur[3] == '-')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n-                        ctxt->progressive = XML_PARSER_COMMENT;\n-                        goto done;\n-                    }\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: Parsing Comment\\n\");\n-#endif\n-                    xmlParseComment(ctxt);\n-                    if (ctxt->instate == XML_PARSER_EOF)\n-                        goto done;\n-                    ctxt->instate = XML_PARSER_MISC;\n-                    ctxt->progressive = 1;\n-                    ctxt->checkIndex = 0;\n-                } else if ((cur == '<') && (next == '!') &&\n-                    (ctxt->input->cur[2] == 'D') &&\n-                    (ctxt->input->cur[3] == 'O') &&\n-                    (ctxt->input->cur[4] == 'C') &&\n-                    (ctxt->input->cur[5] == 'T') &&\n-                    (ctxt->input->cur[6] == 'Y') &&\n-                    (ctxt->input->cur[7] == 'P') &&\n-                    (ctxt->input->cur[8] == 'E')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0)) {\n-                        ctxt->progressive = XML_PARSER_DTD;\n-                        goto done;\n-                    }\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: Parsing internal subset\\n\");\n-#endif\n-                    ctxt->inSubset = 1;\n-                    ctxt->progressive = 0;\n-                    ctxt->checkIndex = 0;\n-                    xmlParseDocTypeDecl(ctxt);\n-                    if (ctxt->instate == XML_PARSER_EOF)\n-                        goto done;\n-                    if (RAW == '[') {\n-                        ctxt->instate = XML_PARSER_DTD;\n-#ifdef DEBUG_PUSH\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"PP: entering DTD\\n\");\n-#endif\n-                    } else {\n-                        \/*\n-                         * Create and update the external subset.\n-                         *\/\n-                        ctxt->inSubset = 2;\n-                        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-                            (ctxt->sax->externalSubset != NULL))\n-                            ctxt->sax->externalSubset(ctxt->userData,\n-                                    ctxt->intSubName, ctxt->extSubSystem,\n-                                    ctxt->extSubURI);\n-                        ctxt->inSubset = 0;\n-                        xmlCleanSpecialAttr(ctxt);\n-                        ctxt->instate = XML_PARSER_PROLOG;\n-#ifdef DEBUG_PUSH\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"PP: entering PROLOG\\n\");\n-#endif\n-                    }\n-                } else if ((cur == '<') && (next == '!') &&\n-                           (avail < 9)) {\n-                    goto done;\n-                } else {\n-                    ctxt->instate = XML_PARSER_START_TAG;\n-                    ctxt->progressive = XML_PARSER_START_TAG;\n-                    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: entering START_TAG\\n\");\n-#endif\n-                }\n-                break;\n@@ -11840,55 +11971,0 @@\n-                SKIP_BLANKS;\n-                if (ctxt->input->buf == NULL)\n-                    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n-                else\n-                    avail = xmlBufUse(ctxt->input->buf->buffer) -\n-                            (ctxt->input->cur - ctxt->input->base);\n-                if (avail < 2)\n-                    goto done;\n-                cur = ctxt->input->cur[0];\n-                next = ctxt->input->cur[1];\n-                if ((cur == '<') && (next == '?')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n-                        ctxt->progressive = XML_PARSER_PI;\n-                        goto done;\n-                    }\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: Parsing PI\\n\");\n-#endif\n-                    xmlParsePI(ctxt);\n-                    if (ctxt->instate == XML_PARSER_EOF)\n-                        goto done;\n-                    ctxt->instate = XML_PARSER_PROLOG;\n-                    ctxt->progressive = 1;\n-                } else if ((cur == '<') && (next == '!') &&\n-                    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n-                        ctxt->progressive = XML_PARSER_COMMENT;\n-                        goto done;\n-                    }\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: Parsing Comment\\n\");\n-#endif\n-                    xmlParseComment(ctxt);\n-                    if (ctxt->instate == XML_PARSER_EOF)\n-                        goto done;\n-                    ctxt->instate = XML_PARSER_PROLOG;\n-                    ctxt->progressive = 1;\n-                } else if ((cur == '<') && (next == '!') &&\n-                           (avail < 4)) {\n-                    goto done;\n-                } else {\n-                    ctxt->instate = XML_PARSER_START_TAG;\n-                    if (ctxt->progressive == 0)\n-                        ctxt->progressive = XML_PARSER_START_TAG;\n-                    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: entering START_TAG\\n\");\n-#endif\n-                }\n-                break;\n@@ -11897,6 +11973,2 @@\n-                if (ctxt->input->buf == NULL)\n-                    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n-                else\n-                    avail = xmlBufUse(ctxt->input->buf->buffer) -\n-                            (ctxt->input->cur - ctxt->input->base);\n-                if (avail < 2)\n+                avail = ctxt->input->end - ctxt->input->cur;\n+                if (avail < 1)\n@@ -11904,30 +11976,2 @@\n-                cur = ctxt->input->cur[0];\n-                next = ctxt->input->cur[1];\n-                if ((cur == '<') && (next == '?')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n-                        ctxt->progressive = XML_PARSER_PI;\n-                        goto done;\n-                    }\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: Parsing PI\\n\");\n-#endif\n-                    xmlParsePI(ctxt);\n-                    if (ctxt->instate == XML_PARSER_EOF)\n-                        goto done;\n-                    ctxt->instate = XML_PARSER_EPILOG;\n-                    ctxt->progressive = 1;\n-                } else if ((cur == '<') && (next == '!') &&\n-                    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n-                    if ((!terminate) &&\n-                        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n-                        ctxt->progressive = XML_PARSER_COMMENT;\n-                        goto done;\n-                    }\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: Parsing Comment\\n\");\n-#endif\n-                    xmlParseComment(ctxt);\n-                    if (ctxt->instate == XML_PARSER_EOF)\n+                if (ctxt->input->cur[0] == '<') {\n+                    if ((!terminate) && (avail < 2))\n@@ -11935,96 +11979,24 @@\n-                    ctxt->instate = XML_PARSER_EPILOG;\n-                    ctxt->progressive = 1;\n-                } else if ((cur == '<') && (next == '!') &&\n-                           (avail < 4)) {\n-                    goto done;\n-                } else {\n-                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n-                    xmlHaltParser(ctxt);\n-#ifdef DEBUG_PUSH\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: entering EOF\\n\");\n-#endif\n-                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-                        ctxt->sax->endDocument(ctxt->userData);\n-                    goto done;\n-                }\n-                break;\n-            case XML_PARSER_DTD: {\n-                \/*\n-                 * Sorry but progressive parsing of the internal subset\n-                 * is not expected to be supported. We first check that\n-                 * the full content of the internal subset is available and\n-                 * the parsing is launched only at that point.\n-                 * Internal subset ends up with \"']' S? '>'\" in an unescaped\n-                 * section and not in a ']]>' sequence which are conditional\n-                 * sections (whoever argued to keep that crap in XML deserve\n-                 * a place in hell !).\n-                 *\/\n-                int base, i;\n-                xmlChar *buf;\n-                xmlChar quote = 0;\n-                size_t use;\n-\n-                base = ctxt->input->cur - ctxt->input->base;\n-                if (base < 0) return(0);\n-                if (ctxt->checkIndex > base)\n-                    base = ctxt->checkIndex;\n-                buf = xmlBufContent(ctxt->input->buf->buffer);\n-                use = xmlBufUse(ctxt->input->buf->buffer);\n-                for (;(unsigned int) base < use; base++) {\n-                    if (quote != 0) {\n-                        if (buf[base] == quote)\n-                            quote = 0;\n-                        continue;\n-                    }\n-                    if ((quote == 0) && (buf[base] == '<')) {\n-                        int found  = 0;\n-                        \/* special handling of comments *\/\n-                        if (((unsigned int) base + 4 < use) &&\n-                            (buf[base + 1] == '!') &&\n-                            (buf[base + 2] == '-') &&\n-                            (buf[base + 3] == '-')) {\n-                            for (;(unsigned int) base + 3 < use; base++) {\n-                                if ((buf[base] == '-') &&\n-                                    (buf[base + 1] == '-') &&\n-                                    (buf[base + 2] == '>')) {\n-                                    found = 1;\n-                                    base += 2;\n-                                    break;\n-                                }\n-                            }\n-                            if (!found) {\n-#if 0\n-                                fprintf(stderr, \"unfinished comment\\n\");\n-#endif\n-                                break; \/* for *\/\n-                            }\n-                            continue;\n-                        }\n-                    }\n-                    if (buf[base] == '\"') {\n-                        quote = '\"';\n-                        continue;\n-                    }\n-                    if (buf[base] == '\\'') {\n-                        quote = '\\'';\n-                        continue;\n-                    }\n-                    if (buf[base] == ']') {\n-#if 0\n-                        fprintf(stderr, \"%c%c%c%c: \", buf[base],\n-                                buf[base + 1], buf[base + 2], buf[base + 3]);\n-#endif\n-                        if ((unsigned int) base +1 >= use)\n-                            break;\n-                        if (buf[base + 1] == ']') {\n-                            \/* conditional crap, skip both ']' ! *\/\n-                            base++;\n-                            continue;\n-                        }\n-                        for (i = 1; (unsigned int) base + i < use; i++) {\n-                            if (buf[base + i] == '>') {\n-#if 0\n-                                fprintf(stderr, \"found\\n\");\n-#endif\n-                                goto found_end_int_subset;\n+                    next = ctxt->input->cur[1];\n+                    if (next == '?') {\n+                        if ((!terminate) &&\n+                            (!xmlParseLookupString(ctxt, 2, \"?>\", 2)))\n+                            goto done;\n+                        xmlParsePI(ctxt);\n+                        if (ctxt->instate == XML_PARSER_EOF)\n+                            goto done;\n+                        break;\n+                    } else if (next == '!') {\n+                        if ((!terminate) && (avail < 3))\n+                            goto done;\n+\n+                        if (ctxt->input->cur[2] == '-') {\n+                            if ((!terminate) && (avail < 4))\n+                                goto done;\n+                            if (ctxt->input->cur[3] == '-') {\n+                                if ((!terminate) &&\n+                                    (!xmlParseLookupString(ctxt, 4, \"-->\", 3)))\n+                                    goto done;\n+                                xmlParseComment(ctxt);\n+                                if (ctxt->instate == XML_PARSER_EOF)\n+                                    goto done;\n+                                break;\n@@ -12032,5 +12004,38 @@\n-                            if (!IS_BLANK_CH(buf[base + i])) {\n-#if 0\n-                                fprintf(stderr, \"not found\\n\");\n-#endif\n-                                goto not_end_of_int_subset;\n+                        } else if (ctxt->instate == XML_PARSER_MISC) {\n+                            if ((!terminate) && (avail < 9))\n+                                goto done;\n+                            if ((ctxt->input->cur[2] == 'D') &&\n+                                (ctxt->input->cur[3] == 'O') &&\n+                                (ctxt->input->cur[4] == 'C') &&\n+                                (ctxt->input->cur[5] == 'T') &&\n+                                (ctxt->input->cur[6] == 'Y') &&\n+                                (ctxt->input->cur[7] == 'P') &&\n+                                (ctxt->input->cur[8] == 'E')) {\n+                                if ((!terminate) && (!xmlParseLookupGt(ctxt)))\n+                                    goto done;\n+                                ctxt->inSubset = 1;\n+                                xmlParseDocTypeDecl(ctxt);\n+                                if (ctxt->instate == XML_PARSER_EOF)\n+                                    goto done;\n+                                if (RAW == '[') {\n+                                    ctxt->instate = XML_PARSER_DTD;\n+                                } else {\n+                                    \/*\n+                                     * Create and update the external subset.\n+                                     *\/\n+                                    ctxt->inSubset = 2;\n+                                    if ((ctxt->sax != NULL) &&\n+                                        (!ctxt->disableSAX) &&\n+                                        (ctxt->sax->externalSubset != NULL))\n+                                        ctxt->sax->externalSubset(\n+                                                ctxt->userData,\n+                                                ctxt->intSubName,\n+                                                ctxt->extSubSystem,\n+                                                ctxt->extSubURI);\n+                                    ctxt->inSubset = 0;\n+                                    xmlCleanSpecialAttr(ctxt);\n+                                    if (ctxt->instate == XML_PARSER_EOF)\n+                                        goto done;\n+                                    ctxt->instate = XML_PARSER_PROLOG;\n+                                }\n+                                break;\n@@ -12039,5 +12044,0 @@\n-#if 0\n-                        fprintf(stderr, \"end of stream\\n\");\n-#endif\n-                        break;\n-\n@@ -12045,2 +12045,0 @@\n-not_end_of_int_subset:\n-                    continue; \/* for *\/\n@@ -12048,13 +12046,0 @@\n-                \/*\n-                 * We didn't found the end of the Internal subset\n-                 *\/\n-                if (quote == 0)\n-                    ctxt->checkIndex = base;\n-                else\n-                    ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                if (next == 0)\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PP: lookup of int subset end filed\\n\");\n-#endif\n-                goto done;\n@@ -12062,2 +12047,13 @@\n-found_end_int_subset:\n-                ctxt->checkIndex = 0;\n+                if (ctxt->instate == XML_PARSER_EPILOG) {\n+                    if (ctxt->errNo == XML_ERR_OK)\n+                        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+                    ctxt->instate = XML_PARSER_EOF;\n+                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                        ctxt->sax->endDocument(ctxt->userData);\n+                } else {\n+                    ctxt->instate = XML_PARSER_START_TAG;\n+                }\n+                break;\n+            case XML_PARSER_DTD: {\n+                if ((!terminate) && (!xmlParseLookupInternalSubset(ctxt)))\n+                    goto done;\n@@ -12077,5 +12073,0 @@\n-                ctxt->checkIndex = 0;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering PROLOG\\n\");\n-#endif\n@@ -12084,68 +12075,1 @@\n-            case XML_PARSER_COMMENT:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == COMMENT\\n\");\n-                ctxt->instate = XML_PARSER_CONTENT;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_IGNORE:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == IGNORE\");\n-                ctxt->instate = XML_PARSER_DTD;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering DTD\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_PI:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == PI\\n\");\n-                ctxt->instate = XML_PARSER_CONTENT;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering CONTENT\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_ENTITY_DECL:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == ENTITY_DECL\\n\");\n-                ctxt->instate = XML_PARSER_DTD;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering DTD\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_ENTITY_VALUE:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == ENTITY_VALUE\\n\");\n-                ctxt->instate = XML_PARSER_CONTENT;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering DTD\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_ATTRIBUTE_VALUE:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\n-                ctxt->instate = XML_PARSER_START_TAG;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering START_TAG\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_SYSTEM_LITERAL:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == SYSTEM_LITERAL\\n\");\n-                ctxt->instate = XML_PARSER_START_TAG;\n-#ifdef DEBUG_PUSH\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: entering START_TAG\\n\");\n-#endif\n-                break;\n-            case XML_PARSER_PUBLIC_LITERAL:\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PP: internal error, state == PUBLIC_LITERAL\\n\");\n-                ctxt->instate = XML_PARSER_START_TAG;\n-#ifdef DEBUG_PUSH\n+            default:\n@@ -12153,2 +12077,2 @@\n-                        \"PP: entering START_TAG\\n\");\n-#endif\n+                        \"PP: internal error\\n\");\n+                ctxt->instate = XML_PARSER_EOF;\n@@ -12159,3 +12083,0 @@\n-#ifdef DEBUG_PUSH\n-    xmlGenericError(xmlGenericErrorContext, \"PP: done %d\\n\", ret);\n-#endif\n@@ -12164,1 +12085,5 @@\n-    {\n+    if (ctxt->input->end - ctxt->input->cur < 4) {\n+        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                     \"Input is not proper UTF-8, indicate encoding !\\n\",\n+                     NULL, NULL);\n+    } else {\n@@ -12177,49 +12102,0 @@\n-\/**\n- * xmlParseCheckTransition:\n- * @ctxt:  an XML parser context\n- * @chunk:  a char array\n- * @size:  the size in byte of the chunk\n- *\n- * Check depending on the current parser state if the chunk given must be\n- * processed immediately or one need more data to advance on parsing.\n- *\n- * Returns -1 in case of error, 0 if the push is not needed and 1 if needed\n- *\/\n-static int\n-xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {\n-    if ((ctxt == NULL) || (chunk == NULL) || (size < 0))\n-        return(-1);\n-    if (ctxt->instate == XML_PARSER_START_TAG) {\n-        if (memchr(chunk, '>', size) != NULL)\n-            return(1);\n-        return(0);\n-    }\n-    if (ctxt->progressive == XML_PARSER_COMMENT) {\n-        if (memchr(chunk, '>', size) != NULL)\n-            return(1);\n-        return(0);\n-    }\n-    if (ctxt->instate == XML_PARSER_CDATA_SECTION) {\n-        if (memchr(chunk, '>', size) != NULL)\n-            return(1);\n-        return(0);\n-    }\n-    if (ctxt->progressive == XML_PARSER_PI) {\n-        if (memchr(chunk, '>', size) != NULL)\n-            return(1);\n-        return(0);\n-    }\n-    if (ctxt->instate == XML_PARSER_END_TAG) {\n-        if (memchr(chunk, '>', size) != NULL)\n-            return(1);\n-        return(0);\n-    }\n-    if ((ctxt->progressive == XML_PARSER_DTD) ||\n-        (ctxt->instate == XML_PARSER_DTD)) {\n-        if (memchr(chunk, '>', size) != NULL)\n-            return(1);\n-        return(0);\n-    }\n-    return(1);\n-}\n-\n@@ -12241,3 +12117,0 @@\n-    int remain = 0;\n-    size_t old_avail = 0;\n-    size_t avail = 0;\n@@ -12251,0 +12124,4 @@\n+    if (ctxt->input == NULL)\n+        return(-1);\n+\n+    ctxt->progressive = 1;\n@@ -12259,2 +12136,0 @@\n-xmldecl_done:\n-\n@@ -12263,2 +12138,1 @@\n-        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-        size_t cur = ctxt->input->cur - ctxt->input->base;\n+        size_t pos = ctxt->input->cur - ctxt->input->base;\n@@ -12267,36 +12141,0 @@\n-        old_avail = xmlBufUse(ctxt->input->buf->buffer);\n-        \/*\n-         * Specific handling if we autodetected an encoding, we should not\n-         * push more than the first line ... which depend on the encoding\n-         * And only push the rest once the final encoding was detected\n-         *\/\n-        if ((ctxt->instate == XML_PARSER_START) && (ctxt->input != NULL) &&\n-            (ctxt->input->buf != NULL) && (ctxt->input->buf->encoder != NULL)) {\n-            unsigned int len = 45;\n-\n-            if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n-                               BAD_CAST \"UTF-16\")) ||\n-                (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n-                               BAD_CAST \"UTF16\")))\n-                len = 90;\n-            else if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n-                                    BAD_CAST \"UCS-4\")) ||\n-                     (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n-                                    BAD_CAST \"UCS4\")))\n-                len = 180;\n-\n-            if (ctxt->input->buf->rawconsumed < len)\n-                len -= ctxt->input->buf->rawconsumed;\n-\n-            \/*\n-             * Change size for reading the initial declaration only\n-             * if size is greater than len. Otherwise, memmove in xmlBufferAdd\n-             * will blindly copy extra bytes from memory.\n-             *\/\n-            if ((unsigned int) size > len) {\n-                remain = size - len;\n-                size = len;\n-            } else {\n-                remain = 0;\n-            }\n-        }\n@@ -12304,1 +12142,1 @@\n-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n+        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n@@ -12306,1 +12144,1 @@\n-            ctxt->errNo = XML_PARSER_EOF;\n+            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n@@ -12308,1 +12146,1 @@\n-            return (XML_PARSER_EOF);\n+            return(ctxt->errNo);\n@@ -12310,42 +12148,0 @@\n-#ifdef DEBUG_PUSH\n-        xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n-#endif\n-\n-    } else if (ctxt->instate != XML_PARSER_EOF) {\n-        if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n-            xmlParserInputBufferPtr in = ctxt->input->buf;\n-            if ((in->encoder != NULL) && (in->buffer != NULL) &&\n-                    (in->raw != NULL)) {\n-                int nbchars;\n-                size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n-                size_t current = ctxt->input->cur - ctxt->input->base;\n-\n-                nbchars = xmlCharEncInput(in, terminate);\n-                xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n-                if (nbchars < 0) {\n-                    \/* TODO 2.6.0 *\/\n-                    xmlGenericError(xmlGenericErrorContext,\n-                                    \"xmlParseChunk: encoder error\\n\");\n-                    xmlHaltParser(ctxt);\n-                    return(XML_ERR_INVALID_ENCODING);\n-                }\n-            }\n-        }\n-    }\n-    if (remain != 0) {\n-        xmlParseTryOrFinish(ctxt, 0);\n-    } else {\n-        if ((ctxt->input != NULL) && (ctxt->input->buf != NULL))\n-            avail = xmlBufUse(ctxt->input->buf->buffer);\n-        \/*\n-         * Depending on the current state it may not be such\n-         * a good idea to try parsing if there is nothing in the chunk\n-         * which would be worth doing a parser state transition and we\n-         * need to wait for more data\n-         *\/\n-        if ((terminate) || (avail > XML_MAX_TEXT_LENGTH) ||\n-            (old_avail == 0) || (avail == 0) ||\n-            (xmlParseCheckTransition(ctxt,\n-                       (const char *)&ctxt->input->base[old_avail],\n-                                     avail - old_avail)))\n-            xmlParseTryOrFinish(ctxt, terminate);\n@@ -12353,0 +12149,2 @@\n+\n+    xmlParseTryOrFinish(ctxt, terminate);\n@@ -12366,6 +12164,0 @@\n-    if (remain != 0) {\n-        chunk += size;\n-        size = remain;\n-        remain = 0;\n-        goto xmldecl_done;\n-    }\n@@ -12374,5 +12166,2 @@\n-        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,\n-                                         ctxt->input);\n-        size_t current = ctxt->input->cur - ctxt->input->base;\n-\n-        xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n+        size_t pos = ctxt->input->cur - ctxt->input->base;\n+        int res;\n@@ -12380,2 +12169,7 @@\n-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,\n-                              base, current);\n+        res = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n+        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n+        if (res < 0) {\n+            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n+            xmlHaltParser(ctxt);\n+            return(ctxt->errNo);\n+        }\n@@ -12387,11 +12181,0 @@\n-        int cur_avail = 0;\n-\n-        if (ctxt->input != NULL) {\n-            if (ctxt->input->buf == NULL)\n-                cur_avail = ctxt->input->length -\n-                            (ctxt->input->cur - ctxt->input->base);\n-            else\n-                cur_avail = xmlBufUse(ctxt->input->buf->buffer) -\n-                                      (ctxt->input->cur - ctxt->input->base);\n-        }\n-\n@@ -12400,4 +12183,17 @@\n-            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n-        }\n-        if ((ctxt->instate == XML_PARSER_EPILOG) && (cur_avail > 0)) {\n-            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+            if (ctxt->nameNr > 0) {\n+                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n+                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n+                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n+                        \"Premature end of data in tag %s line %d\\n\",\n+                        name, line, NULL);\n+            } else if (ctxt->instate == XML_PARSER_START) {\n+                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+            } else {\n+                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n+                               \"Start tag expected, '<' not found\\n\");\n+            }\n+        } else if ((ctxt->input->buf != NULL) &&\n+                   (ctxt->input->buf->encoder != NULL) &&\n+                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           \"Truncated multi-byte sequence at EOF\\n\");\n@@ -12448,7 +12244,0 @@\n-    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;\n-\n-    \/*\n-     * plug some encoding conversion routines\n-     *\/\n-    if ((chunk != NULL) && (size >= 4))\n-        enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);\n@@ -12456,1 +12245,1 @@\n-    buf = xmlAllocParserInputBuffer(enc);\n+    buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n@@ -12459,1 +12248,1 @@\n-    ctxt = xmlNewParserCtxt();\n+    ctxt = xmlNewSAXParserCtxt(sax, user_data);\n@@ -12466,20 +12255,0 @@\n-    if (sax != NULL) {\n-#ifdef LIBXML_SAX1_ENABLED\n-        if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n-            xmlFree(ctxt->sax);\n-        ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));\n-        if (ctxt->sax == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            xmlFreeParserInputBuffer(buf);\n-            xmlFreeParserCtxt(ctxt);\n-            return(NULL);\n-        }\n-        memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n-        if (sax->initialized == XML_SAX2_MAGIC)\n-            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n-        else\n-            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n-        if (user_data != NULL)\n-            ctxt->userData = user_data;\n-    }\n@@ -12505,0 +12274,1 @@\n+            xmlFreeInputStream(inputStream);\n@@ -12514,18 +12284,4 @@\n-    \/*\n-     * If the caller didn't provide an initial 'chunk' for determining\n-     * the encoding, we set the context to XML_CHAR_ENCODING_NONE so\n-     * that it can be automatically determined later\n-     *\/\n-    if ((size == 0) || (chunk == NULL)) {\n-        ctxt->charset = XML_CHAR_ENCODING_NONE;\n-    } else if ((ctxt->input != NULL) && (ctxt->input->buf != NULL)) {\n-        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-        size_t cur = ctxt->input->cur - ctxt->input->base;\n-\n-        xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n-\n-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n-#ifdef DEBUG_PUSH\n-        xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n-#endif\n-    }\n+    if ((size != 0) && (chunk != NULL) &&\n+        (ctxt->input != NULL) && (ctxt->input->buf != NULL)) {\n+        size_t pos = ctxt->input->cur - ctxt->input->base;\n+        int res;\n@@ -12533,2 +12289,6 @@\n-    if (enc != XML_CHAR_ENCODING_NONE) {\n-        xmlSwitchEncoding(ctxt, enc);\n+        res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n+        if (res < 0) {\n+            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n+            xmlHaltParser(ctxt);\n+        }\n@@ -12541,35 +12301,0 @@\n-\/**\n- * xmlHaltParser:\n- * @ctxt:  an XML parser context\n- *\n- * Blocks further parser processing don't override error\n- * for internal use\n- *\/\n-static void\n-xmlHaltParser(xmlParserCtxtPtr ctxt) {\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->instate = XML_PARSER_EOF;\n-    ctxt->disableSAX = 1;\n-    while (ctxt->inputNr > 1)\n-        xmlFreeInputStream(inputPop(ctxt));\n-    if (ctxt->input != NULL) {\n-        \/*\n-         * in case there was a specific allocation deallocate before\n-         * overriding base\n-         *\/\n-        if (ctxt->input->free != NULL) {\n-            ctxt->input->free((xmlChar *) ctxt->input->base);\n-            ctxt->input->free = NULL;\n-        }\n-        if (ctxt->input->buf != NULL) {\n-            xmlFreeParserInputBuffer(ctxt->input->buf);\n-            ctxt->input->buf = NULL;\n-        }\n-        ctxt->input->cur = BAD_CAST\"\";\n-        ctxt->input->length = 0;\n-        ctxt->input->base = ctxt->input->cur;\n-        ctxt->input->end = ctxt->input->cur;\n-    }\n-}\n-\n@@ -12620,25 +12345,5 @@\n-\n-    ctxt = xmlNewParserCtxt();\n-    if (ctxt == NULL) {\n-        xmlFreeParserInputBuffer(buf);\n-        return(NULL);\n-    }\n-    if (sax != NULL) {\n-#ifdef LIBXML_SAX1_ENABLED\n-        if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n-            xmlFree(ctxt->sax);\n-        ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));\n-        if (ctxt->sax == NULL) {\n-            xmlFreeParserInputBuffer(buf);\n-            xmlErrMemory(ctxt, NULL);\n-            xmlFreeParserCtxt(ctxt);\n-            return(NULL);\n-        }\n-        memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n-        if (sax->initialized == XML_SAX2_MAGIC)\n-            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n-        else\n-            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n-        if (user_data != NULL)\n-            ctxt->userData = user_data;\n+\n+    ctxt = xmlNewSAXParserCtxt(sax, user_data);\n+    if (ctxt == NULL) {\n+        xmlFreeParserInputBuffer(buf);\n+        return(NULL);\n@@ -12682,1 +12387,0 @@\n-    xmlChar start[4];\n@@ -12687,1 +12391,1 @@\n-    ctxt = xmlNewParserCtxt();\n+    ctxt = xmlNewSAXParserCtxt(sax, NULL);\n@@ -12696,9 +12400,0 @@\n-    \/*\n-     * Set-up the SAX context\n-     *\/\n-    if (sax != NULL) {\n-        if (ctxt->sax != NULL)\n-            xmlFree(ctxt->sax);\n-        ctxt->sax = sax;\n-        ctxt->userData = ctxt;\n-    }\n@@ -12713,1 +12408,0 @@\n-        if (sax != NULL) ctxt->sax = NULL;\n@@ -12723,1 +12417,0 @@\n-        if (sax != NULL) ctxt->sax = NULL;\n@@ -12731,7 +12424,0 @@\n-    pinput->filename = NULL;\n-    pinput->line = 1;\n-    pinput->col = 1;\n-    pinput->base = ctxt->input->cur;\n-    pinput->cur = ctxt->input->cur;\n-    pinput->free = NULL;\n-\n@@ -12751,16 +12437,1 @@\n-    if ((enc == XML_CHAR_ENCODING_NONE) &&\n-        ((ctxt->input->end - ctxt->input->cur) >= 4)) {\n-        \/*\n-         * Get the 4 first bytes and decode the charset\n-         * if enc != XML_CHAR_ENCODING_NONE\n-         * plug some encoding conversion routines.\n-         *\/\n-        start[0] = RAW;\n-        start[1] = NXT(1);\n-        start[2] = NXT(2);\n-        start[3] = NXT(3);\n-        enc = xmlDetectCharEncoding(start, 4);\n-        if (enc != XML_CHAR_ENCODING_NONE) {\n-            xmlSwitchEncoding(ctxt, enc);\n-        }\n-    }\n+    xmlDetectEncoding(ctxt);\n@@ -12790,1 +12461,0 @@\n-    if (sax != NULL) ctxt->sax = NULL;\n@@ -12802,0 +12472,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -12813,1 +12485,0 @@\n-    xmlCharEncoding enc;\n@@ -12818,1 +12489,1 @@\n-    ctxt = xmlNewParserCtxt();\n+    ctxt = xmlNewSAXParserCtxt(sax, NULL);\n@@ -12826,10 +12497,0 @@\n-    \/*\n-     * Set-up the SAX context\n-     *\/\n-    if (sax != NULL) {\n-        if (ctxt->sax != NULL)\n-            xmlFree(ctxt->sax);\n-        ctxt->sax = sax;\n-        ctxt->userData = ctxt;\n-    }\n-\n@@ -12853,1 +12514,0 @@\n-        if (sax != NULL) ctxt->sax = NULL;\n@@ -12864,1 +12524,0 @@\n-        if (sax != NULL) ctxt->sax = NULL;\n@@ -12870,4 +12529,2 @@\n-    if ((ctxt->input->end - ctxt->input->cur) >= 4) {\n-        enc = xmlDetectCharEncoding(ctxt->input->cur, 4);\n-        xmlSwitchEncoding(ctxt, enc);\n-    }\n+\n+    xmlDetectEncoding(ctxt);\n@@ -12879,5 +12536,0 @@\n-    input->line = 1;\n-    input->col = 1;\n-    input->base = ctxt->input->cur;\n-    input->cur = ctxt->input->cur;\n-    input->free = NULL;\n@@ -12892,1 +12544,0 @@\n-        if (sax != NULL) ctxt->sax = NULL;\n@@ -12921,1 +12572,0 @@\n-    if (sax != NULL) ctxt->sax = NULL;\n@@ -13012,1 +12662,0 @@\n-    xmlSAXHandlerPtr oldsax = NULL;\n@@ -13014,2 +12663,0 @@\n-    xmlChar start[4];\n-    xmlCharEncoding enc;\n@@ -13019,1 +12666,3 @@\n-        (depth > 1024)) {\n+        (depth > 100)) {\n+        xmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,\n+                       \"Maximum entity nesting depth exceeded\");\n@@ -13030,2 +12679,2 @@\n-\n-    ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, oldctxt);\n+    ctxt = xmlCreateEntityParserCtxtInternal(sax, user_data, URL, ID, NULL,\n+                                             oldctxt);\n@@ -13033,6 +12682,3 @@\n-    ctxt->userData = ctxt;\n-    if (sax != NULL) {\n-        oldsax = ctxt->sax;\n-        ctxt->sax = sax;\n-        if (user_data != NULL)\n-            ctxt->userData = user_data;\n+    if (oldctxt != NULL) {\n+        ctxt->nbErrors = oldctxt->nbErrors;\n+        ctxt->nbWarnings = oldctxt->nbWarnings;\n@@ -13041,0 +12687,1 @@\n+\n@@ -13061,1 +12708,0 @@\n-            ctxt->sax = oldsax;\n@@ -13077,16 +12723,1 @@\n-    \/*\n-     * Get the 4 first bytes and decode the charset\n-     * if enc != XML_CHAR_ENCODING_NONE\n-     * plug some encoding conversion routines.\n-     *\/\n-    GROW;\n-    if ((ctxt->input->end - ctxt->input->cur) >= 4) {\n-        start[0] = RAW;\n-        start[1] = NXT(1);\n-        start[2] = NXT(2);\n-        start[3] = NXT(3);\n-        enc = xmlDetectCharEncoding(start, 4);\n-        if (enc != XML_CHAR_ENCODING_NONE) {\n-            xmlSwitchEncoding(ctxt, enc);\n-        }\n-    }\n+    xmlDetectEncoding(ctxt);\n@@ -13121,0 +12752,1 @@\n+            ctxt->vctxt.flags = oldctxt->vctxt.flags;\n@@ -13159,4 +12791,6 @@\n-        if (ctxt->errNo == 0)\n-            ret = XML_ERR_INTERNAL_ERROR;\n-        else\n-            ret = (xmlParserErrors)ctxt->errNo;\n+        ret = (xmlParserErrors)ctxt->errNo;\n+        if (oldctxt != NULL) {\n+            oldctxt->errNo = ctxt->errNo;\n+            oldctxt->wellFormed = 0;\n+            xmlCopyError(&ctxt->lastError, &oldctxt->lastError);\n+        }\n@@ -13182,7 +12816,0 @@\n-    \/*\n-     * Record in the parent context the number of entities replacement\n-     * done when parsing that reference.\n-     *\/\n-    if (oldctxt != NULL)\n-        oldctxt->nbentities += ctxt->nbentities;\n-\n@@ -13193,2 +12820,9 @@\n-        oldctxt->sizeentities += ctxt->input->consumed;\n-        oldctxt->sizeentities += (ctxt->input->cur - ctxt->input->base);\n+        unsigned long consumed = ctxt->input->consumed;\n+\n+        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);\n+\n+        xmlSaturatedAdd(&oldctxt->sizeentities, consumed);\n+        xmlSaturatedAdd(&oldctxt->sizeentities, ctxt->sizeentities);\n+\n+        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);\n+        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);\n@@ -13196,5 +12830,0 @@\n-    \/*\n-     * And record the last error if any\n-     *\/\n-    if ((oldctxt != NULL) && (ctxt->lastError.code != XML_ERR_OK))\n-        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);\n@@ -13202,2 +12831,0 @@\n-    if (sax != NULL)\n-        ctxt->sax = oldsax;\n@@ -13208,0 +12835,2 @@\n+        oldctxt->nbErrors = ctxt->nbErrors;\n+        oldctxt->nbWarnings = ctxt->nbWarnings;\n@@ -13311,1 +12940,0 @@\n-    int size;\n@@ -13313,3 +12941,2 @@\n-#ifdef SAX2\n-    int i;\n-#endif\n+    xmlHashedString hprefix, huri;\n+    unsigned i;\n@@ -13318,1 +12945,3 @@\n-        (oldctxt->depth >  1024)) {\n+        (oldctxt->depth >  100)) {\n+        xmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,\n+                       \"Maximum entity nesting depth exceeded\");\n@@ -13328,3 +12957,1 @@\n-    size = xmlStrlen(string);\n-\n-    ctxt = xmlCreateMemoryParserCtxt((char *) string, size);\n+    ctxt = xmlCreateDocParserCtxt(string);\n@@ -13332,0 +12959,2 @@\n+    ctxt->nbErrors = oldctxt->nbErrors;\n+    ctxt->nbWarnings = oldctxt->nbWarnings;\n@@ -13338,1 +12967,1 @@\n-    ctxt->input_id = oldctxt->input_id + 1;\n+    ctxt->input_id = oldctxt->input_id;\n@@ -13343,4 +12972,37 @@\n-#ifdef SAX2\n-    \/* propagate namespaces down the entity *\/\n-    for (i = 0;i < oldctxt->nsNr;i += 2) {\n-        nsPush(ctxt, oldctxt->nsTab[i], oldctxt->nsTab[i+1]);\n+    \/*\n+     * Propagate namespaces down the entity\n+     *\n+     * Making entities and namespaces work correctly requires additional\n+     * changes, see xmlParseReference.\n+     *\/\n+\n+    \/* Default namespace *\/\n+    hprefix.name = NULL;\n+    hprefix.hashValue = 0;\n+    huri.name = xmlParserNsLookupUri(oldctxt, &hprefix);\n+    huri.hashValue = 0;\n+    if (huri.name != NULL)\n+        xmlParserNsPush(ctxt, NULL, &huri, NULL, 0);\n+\n+    for (i = 0; i < oldctxt->nsdb->hashSize; i++) {\n+        xmlParserNsBucket *bucket = &oldctxt->nsdb->hash[i];\n+        const xmlChar **ns;\n+        xmlParserNsExtra *extra;\n+        unsigned nsIndex;\n+\n+        if ((bucket->hashValue != 0) &&\n+            (bucket->index != INT_MAX)) {\n+            nsIndex = bucket->index;\n+            ns = &oldctxt->nsTab[nsIndex * 2];\n+            extra = &oldctxt->nsdb->extra[nsIndex];\n+\n+            hprefix.name = ns[0];\n+            hprefix.hashValue = bucket->hashValue;\n+            huri.name = ns[1];\n+            huri.hashValue = extra->uriHashValue;\n+            \/*\n+             * Don't copy SAX data to avoid a use-after-free with XML reader.\n+             * This matches the pre-2.12 behavior.\n+             *\/\n+            xmlParserNsPush(ctxt, &hprefix, &huri, NULL, 0);\n+        }\n@@ -13348,1 +13010,0 @@\n-#endif\n@@ -13360,4 +13021,2 @@\n-            ctxt->sax = oldsax;\n-            ctxt->dict = NULL;\n-            xmlFreeParserCtxt(ctxt);\n-            return(XML_ERR_INTERNAL_ERROR);\n+            ret = XML_ERR_INTERNAL_ERROR;\n+            goto error;\n@@ -13376,7 +13035,2 @@\n-        ctxt->sax = oldsax;\n-        ctxt->dict = NULL;\n-        xmlFreeParserCtxt(ctxt);\n-        if (newDoc != NULL) {\n-            xmlFreeDoc(newDoc);\n-        }\n-        return(XML_ERR_INTERNAL_ERROR);\n+        ret = XML_ERR_INTERNAL_ERROR;\n+        goto error;\n@@ -13389,1 +13043,1 @@\n-    ctxt->depth = oldctxt->depth + 1;\n+    ctxt->depth = oldctxt->depth;\n@@ -13414,4 +13068,4 @@\n-        if (ctxt->errNo == 0)\n-            ret = XML_ERR_INTERNAL_ERROR;\n-        else\n-            ret = (xmlParserErrors)ctxt->errNo;\n+        ret = (xmlParserErrors)ctxt->errNo;\n+        oldctxt->errNo = ctxt->errNo;\n+        oldctxt->wellFormed = 0;\n+        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);\n@@ -13419,1 +13073,1 @@\n-      ret = XML_ERR_OK;\n+        ret = XML_ERR_OK;\n@@ -13452,2 +13106,1 @@\n-     * Record in the parent context the number of entities replacement\n-     * done when parsing that reference.\n+     * Also record the size of the entity parsed\n@@ -13455,2 +13108,2 @@\n-    if (oldctxt != NULL)\n-        oldctxt->nbentities += ctxt->nbentities;\n+    if (ctxt->input != NULL && oldctxt != NULL) {\n+        unsigned long consumed = ctxt->input->consumed;\n@@ -13458,5 +13111,1 @@\n-    \/*\n-     * Also record the last error if any\n-     *\/\n-    if (ctxt->lastError.code != XML_ERR_OK)\n-        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);\n+        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);\n@@ -13464,0 +13113,8 @@\n+        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);\n+        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);\n+    }\n+\n+    oldctxt->nbErrors = ctxt->nbErrors;\n+    oldctxt->nbWarnings = ctxt->nbWarnings;\n+\n+error:\n@@ -13498,1 +13155,0 @@\n-#ifdef SAX2\n@@ -13576,4 +13232,0 @@\n-        if (ctxt->encoding != NULL)\n-            xmlFree((xmlChar *) ctxt->encoding);\n-        ctxt->encoding = xmlStrdup((const xmlChar *) doc->encoding);\n-\n@@ -13588,1 +13240,1 @@\n-    xmlCtxtUseOptionsInternal(ctxt, options, NULL);\n+    xmlCtxtUseOptionsInternal(ctxt, options);\n@@ -13602,1 +13254,1 @@\n-    if (node->type == XML_ELEMENT_NODE) {\n+    if (node->type == XML_ELEMENT_NODE)\n@@ -13604,0 +13256,2 @@\n+\n+    if ((ctxt->html == 0) && (node->type == XML_ELEMENT_NODE)) {\n@@ -13610,1 +13264,1 @@\n-            const xmlChar *iprefix, *ihref;\n+            xmlHashedString hprefix, huri;\n@@ -13613,10 +13267,3 @@\n-                if (ctxt->dict) {\n-                    iprefix = xmlDictLookup(ctxt->dict, ns->prefix, -1);\n-                    ihref = xmlDictLookup(ctxt->dict, ns->href, -1);\n-                } else {\n-                    iprefix = ns->prefix;\n-                    ihref = ns->href;\n-                }\n-\n-                if (xmlGetNamespace(ctxt, iprefix) == NULL) {\n-                    nsPush(ctxt, iprefix, ihref);\n+                hprefix = xmlDictLookupHashed(ctxt->dict, ns->prefix, -1);\n+                huri = xmlDictLookupHashed(ctxt->dict, ns->href, -1);\n+                if (xmlParserNsPush(ctxt, &hprefix, &huri, ns, 1) > 0)\n@@ -13624,1 +13271,0 @@\n-                }\n@@ -13645,1 +13291,1 @@\n-    nsPop(ctxt, nsnr);\n+    xmlParserNsPop(ctxt, nsnr);\n@@ -13699,3 +13345,0 @@\n-#else \/* !SAX2 *\/\n-    return(XML_ERR_INTERNAL_ERROR);\n-#endif\n@@ -13738,1 +13381,0 @@\n-    int size;\n@@ -13751,3 +13393,1 @@\n-    size = xmlStrlen(string);\n-\n-    ctxt = xmlCreateMemoryParserCtxt((char *) string, size);\n+    ctxt = xmlCreateDocParserCtxt(string);\n@@ -13776,0 +13416,2 @@\n+        newDoc->dict = ctxt->dict;\n+        xmlDictReference(newDoc->dict);\n@@ -13777,1 +13419,1 @@\n-        xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);\n+        xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT);\n@@ -13801,1 +13443,0 @@\n-        newDoc->children->doc = doc;\n@@ -13878,0 +13519,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -13954,2 +13597,3 @@\n-xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,\n-                          const xmlChar *base, xmlParserCtxtPtr pctx) {\n+xmlCreateEntityParserCtxtInternal(xmlSAXHandlerPtr sax, void *userData,\n+        const xmlChar *URL, const xmlChar *ID, const xmlChar *base,\n+        xmlParserCtxtPtr pctx) {\n@@ -13961,1 +13605,1 @@\n-    ctxt = xmlNewParserCtxt();\n+    ctxt = xmlNewSAXParserCtxt(sax, userData);\n@@ -13969,5 +13613,1 @@\n-        \/*\n-         * this is a subparser of pctx, so the input_id should be\n-         * incremented to distinguish from main entity\n-         *\/\n-        ctxt->input_id = pctx->input_id + 1;\n+        ctxt->input_id = pctx->input_id;\n@@ -14029,1 +13669,1 @@\n-    return xmlCreateEntityParserCtxtInternal(URL, ID, base, NULL);\n+    return xmlCreateEntityParserCtxtInternal(NULL, NULL, URL, ID, base, NULL);\n@@ -14064,1 +13704,1 @@\n-        xmlCtxtUseOptionsInternal(ctxt, options, NULL);\n+        xmlCtxtUseOptionsInternal(ctxt, options);\n@@ -14107,0 +13747,2 @@\n+ * DEPRECATED: Use xmlNewSAXParserCtxt and xmlCtxtReadFile.\n+ *\n@@ -14175,0 +13817,2 @@\n+ * DEPRECATED: Use xmlNewSAXParserCtxt and xmlCtxtReadFile.\n+ *\n@@ -14193,0 +13837,2 @@\n+ * DEPRECATED: Use xmlReadDoc with XML_PARSE_RECOVER.\n+ *\n@@ -14209,0 +13855,2 @@\n+ * DEPRECATED: Use xmlReadFile.\n+ *\n@@ -14225,0 +13873,2 @@\n+ * DEPRECATED: Use xmlReadFile with XML_PARSE_RECOVER.\n+ *\n@@ -14245,0 +13895,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -14280,0 +13932,2 @@\n+ * DEPRECATED: Use xmlNewSAXParserCtxt and xmlCtxtReadFile.\n+ *\n@@ -14353,1 +14007,0 @@\n-    \/* TODO: xmlParserInputBufferCreateStatic, requires some serious changes *\/\n@@ -14385,0 +14038,2 @@\n+ * DEPRECATED: Use xmlNewSAXParserCtxt and xmlCtxtReadMemory.\n+ *\n@@ -14440,0 +14095,2 @@\n+ * DEPRECATED: Use xmlNewSAXParserCtxt and xmlCtxtReadMemory.\n+ *\n@@ -14457,0 +14114,2 @@\n+ * DEPRECATED: Use xmlReadMemory.\n+ *\n@@ -14471,0 +14130,2 @@\n+ * DEPRECATED: Use xmlReadMemory with XML_PARSE_RECOVER.\n+ *\n@@ -14489,1 +14150,2 @@\n- * A better SAX parsing routine.\n+ * DEPRECATED: Use xmlNewSAXParserCtxt and xmlCtxtReadMemory.\n+ *\n@@ -14535,1 +14197,1 @@\n- * @cur:  a pointer to an array of xmlChar\n+ * @str:  a pointer to an array of xmlChar\n@@ -14542,2 +14204,4 @@\n-xmlCreateDocParserCtxt(const xmlChar *cur) {\n-    int len;\n+xmlCreateDocParserCtxt(const xmlChar *str) {\n+    xmlParserCtxtPtr ctxt;\n+    xmlParserInputPtr input;\n+    xmlParserInputBufferPtr buf;\n@@ -14545,1 +14209,17 @@\n-    if (cur == NULL)\n+    if (str == NULL)\n+        return(NULL);\n+\n+    ctxt = xmlNewParserCtxt();\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    buf = xmlParserInputBufferCreateString(str);\n+    if (buf == NULL) {\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+\n+    input = xmlNewInputStream(ctxt);\n+    if (input == NULL) {\n+        xmlFreeParserInputBuffer(buf);\n+        xmlFreeParserCtxt(ctxt);\n@@ -14547,2 +14227,8 @@\n-    len = xmlStrlen(cur);\n-    return(xmlCreateMemoryParserCtxt((const char *)cur, len));\n+    }\n+\n+    input->filename = NULL;\n+    input->buf = buf;\n+    xmlBufResetInput(input->buf->buffer, input);\n+\n+    inputPush(ctxt, input);\n+    return(ctxt);\n@@ -14559,0 +14245,2 @@\n+ * DEPRECATED: Use xmlNewSAXParserCtxt and xmlCtxtReadDoc.\n+ *\n@@ -14602,0 +14290,2 @@\n+ * DEPRECATED: Use xmlReadDoc.\n+ *\n@@ -14654,122 +14344,0 @@\n-\/************************************************************************\n- *                                                                      *\n- *                              Miscellaneous                           *\n- *                                                                      *\n- ************************************************************************\/\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-#include <libxml\/xpath.h>\n-#endif\n-\n-extern void XMLCDECL xmlGenericErrorDefaultFunc(void *ctx, const char *msg, ...);\n-static int xmlParserInitialized = 0;\n-\n-\/**\n- * xmlInitParser:\n- *\n- * Initialization function for the XML parser.\n- * This is not reentrant. Call once before processing in case of\n- * use in multithreaded programs.\n- *\/\n-\n-void\n-xmlInitParser(void) {\n-    if (xmlParserInitialized != 0)\n-        return;\n-\n-#if defined(_WIN32) && (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n-    if (xmlFree == free)\n-        atexit(xmlCleanupParser);\n-#endif\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-    __xmlGlobalInitMutexLock();\n-    if (xmlParserInitialized == 0) {\n-#endif\n-        xmlInitThreads();\n-        xmlInitGlobals();\n-        if ((xmlGenericError == xmlGenericErrorDefaultFunc) ||\n-            (xmlGenericError == NULL))\n-            initGenericErrorDefaultFunc(NULL);\n-        xmlInitMemory();\n-        xmlInitializeDict();\n-        xmlInitCharEncodingHandlers();\n-        xmlDefaultSAXHandlerInit();\n-        xmlRegisterDefaultInputCallbacks();\n-#ifdef LIBXML_OUTPUT_ENABLED\n-        xmlRegisterDefaultOutputCallbacks();\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-#ifdef LIBXML_HTML_ENABLED\n-        htmlInitAutoClose();\n-        htmlDefaultSAXHandlerInit();\n-#endif\n-#ifdef LIBXML_XPATH_ENABLED\n-        xmlXPathInit();\n-#endif\n-        xmlParserInitialized = 1;\n-#ifdef LIBXML_THREAD_ENABLED\n-    }\n-    __xmlGlobalInitMutexUnlock();\n-#endif\n-}\n-\n-\/**\n- * xmlCleanupParser:\n- *\n- * This function name is somewhat misleading. It does not clean up\n- * parser state, it cleans up memory allocated by the library itself.\n- * It is a cleanup function for the XML library. It tries to reclaim all\n- * related global memory allocated for the library processing.\n- * It doesn't deallocate any document related memory. One should\n- * call xmlCleanupParser() only when the process has finished using\n- * the library and all XML\/HTML documents built with it.\n- * See also xmlInitParser() which has the opposite function of preparing\n- * the library for operations.\n- *\n- * WARNING: if your application is multithreaded or has plugin support\n- *          calling this may crash the application if another thread or\n- *          a plugin is still using libxml2. It's sometimes very hard to\n- *          guess if libxml2 is in use in the application, some libraries\n- *          or plugins may use it without notice. In case of doubt abstain\n- *          from calling this function or do it just before calling exit()\n- *          to avoid leak reports from valgrind !\n- *\/\n-\n-void\n-xmlCleanupParser(void) {\n-    if (!xmlParserInitialized)\n-        return;\n-\n-    xmlCleanupCharEncodingHandlers();\n-#ifdef LIBXML_CATALOG_ENABLED\n-    xmlCatalogCleanup();\n-#endif\n-    xmlDictCleanup();\n-    xmlCleanupInputCallbacks();\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    xmlCleanupOutputCallbacks();\n-#endif\n-#ifdef LIBXML_SCHEMAS_ENABLED\n-    xmlSchemaCleanupTypes();\n-    xmlRelaxNGCleanupTypes();\n-#endif\n-    xmlCleanupGlobals();\n-    xmlCleanupThreads(); \/* must be last if called not from the main thread *\/\n-    xmlCleanupMemory();\n-    xmlParserInitialized = 0;\n-}\n-\n-#if defined(HAVE_ATTRIBUTE_DESTRUCTOR) && !defined(LIBXML_STATIC) && \\\n-    !defined(_WIN32)\n-static void\n-ATTRIBUTE_DESTRUCTOR\n-xmlDestructor(void) {\n-    \/*\n-     * Calling custom deallocation functions in a destructor can cause\n-     * problems, for example with Nokogiri.\n-     *\/\n-    if (xmlFree == free)\n-        xmlCleanupParser();\n-}\n-#endif\n-\n@@ -14833,0 +14401,1 @@\n+    xmlParserNsReset(ctxt->nsdb);\n@@ -14867,0 +14436,1 @@\n+    ctxt->endCheckState = 0;\n@@ -14870,1 +14440,0 @@\n-    ctxt->charset = XML_CHAR_ENCODING_UTF8;\n@@ -14872,1 +14441,0 @@\n-    ctxt->nbentities = 0;\n@@ -14890,0 +14458,2 @@\n+    ctxt->nbErrors = 0;\n+    ctxt->nbWarnings = 0;\n@@ -14912,1 +14482,0 @@\n-    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;\n@@ -14917,4 +14486,1 @@\n-    if ((encoding == NULL) && (chunk != NULL) && (size >= 4))\n-        enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);\n-\n-    buf = xmlAllocParserInputBuffer(enc);\n+    buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n@@ -14955,4 +14521,2 @@\n-        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-        size_t cur = ctxt->input->cur - ctxt->input->base;\n-\n-        xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        size_t pos = ctxt->input->cur - ctxt->input->base;\n+        int res;\n@@ -14960,4 +14524,7 @@\n-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n-#ifdef DEBUG_PUSH\n-        xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n-#endif\n+        res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n+        if (res < 0) {\n+            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n+            xmlHaltParser(ctxt);\n+            return(1);\n+        }\n@@ -14969,4 +14536,0 @@\n-        if (ctxt->encoding != NULL)\n-            xmlFree((xmlChar *) ctxt->encoding);\n-        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);\n-\n@@ -14980,2 +14543,0 @@\n-    } else if (enc != XML_CHAR_ENCODING_NONE) {\n-        xmlSwitchEncoding(ctxt, enc);\n@@ -15000,1 +14561,1 @@\n-xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options, const char *encoding)\n+xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options)\n@@ -15004,5 +14565,0 @@\n-    if (encoding != NULL) {\n-        if (ctxt->encoding != NULL)\n-            xmlFree((xmlChar *) ctxt->encoding);\n-        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);\n-    }\n@@ -15067,2 +14623,0 @@\n-        ctxt->sax->startElement = xmlSAX2StartElement;\n-        ctxt->sax->endElement = xmlSAX2EndElement;\n@@ -15143,1 +14697,20 @@\n-   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));\n+   return(xmlCtxtUseOptionsInternal(ctxt, options));\n+}\n+\n+\/**\n+ * xmlCtxtSetMaxAmplification:\n+ * @ctxt: an XML parser context\n+ * @maxAmpl:  maximum amplification factor\n+ *\n+ * To protect against exponential entity expansion (\"billion laughs\"), the\n+ * size of serialized output is (roughly) limited to the input size\n+ * multiplied by this factor. The default value is 5.\n+ *\n+ * When working with documents making heavy use of entity expansion, it can\n+ * be necessary to increase the value. For security reasons, this should only\n+ * be considered when processing trusted input.\n+ *\/\n+void\n+xmlCtxtSetMaxAmplification(xmlParserCtxtPtr ctxt, unsigned maxAmpl)\n+{\n+    ctxt->maxAmpl = maxAmpl;\n@@ -15164,1 +14737,1 @@\n-    xmlCtxtUseOptionsInternal(ctxt, options, encoding);\n+    xmlCtxtUseOptionsInternal(ctxt, options);\n@@ -15168,0 +14741,6 @@\n+        \/*\n+         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the\n+         * caller provided an encoding. Otherwise, we might switch to\n+         * the encoding from the XML declaration which is likely to\n+         * break things. Also see xmlSwitchInputEncoding.\n+         *\/\n@@ -15357,1 +14936,1 @@\n- * @cur:  a pointer to a zero terminated string\n+ * @str:  a pointer to a zero terminated string\n@@ -15368,1 +14947,1 @@\n-xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar * cur,\n+xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar *str,\n@@ -15371,1 +14950,6 @@\n-    if (cur == NULL)\n+    xmlParserInputBufferPtr input;\n+    xmlParserInputPtr stream;\n+\n+    if (ctxt == NULL)\n+        return (NULL);\n+    if (str == NULL)\n@@ -15373,2 +14957,17 @@\n-    return (xmlCtxtReadMemory(ctxt, (const char *) cur, xmlStrlen(cur), URL,\n-                              encoding, options));\n+    xmlInitParser();\n+\n+    xmlCtxtReset(ctxt);\n+\n+    input = xmlParserInputBufferCreateString(str);\n+    if (input == NULL) {\n+        return(NULL);\n+    }\n+\n+    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n+    if (stream == NULL) {\n+        xmlFreeParserInputBuffer(input);\n+        return(NULL);\n+    }\n+\n+    inputPush(ctxt, stream);\n+    return (xmlDoRead(ctxt, URL, encoding, options, 1));\n@@ -15440,1 +15039,2 @@\n-    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n+    input = xmlParserInputBufferCreateStatic(buffer, size,\n+                                             XML_CHAR_ENCODING_NONE);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/parser.c","additions":2980,"deletions":3380,"binary":false,"changes":6360,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include <libxml\/valid.h>\n@@ -31,1 +30,0 @@\n-#include <libxml\/valid.h>\n@@ -35,1 +33,1 @@\n-#include <libxml\/SAX.h>\n+#include <libxml\/xmlsave.h>\n@@ -39,1 +37,0 @@\n-#include <libxml\/globals.h>\n@@ -44,1 +41,0 @@\n-#define VALID_CTXT(ctxt) (CUR(ctxt) <= END(ctxt))\n@@ -46,2 +42,11 @@\n-#include \"buf.h\"\n-#include \"enc.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/enc.h\"\n+#include \"private\/error.h\"\n+#include \"private\/io.h\"\n+#include \"private\/parser.h\"\n+\n+\/*\n+ * XML_MAX_AMPLIFICATION_DEFAULT is the default maximum allowed amplification\n+ * factor of serialized output after entity expansion.\n+ *\/\n+#define XML_MAX_AMPLIFICATION_DEFAULT 5\n@@ -62,1 +67,1 @@\n-    int myversion = (int) LIBXML_VERSION;\n+    int myversion = LIBXML_VERSION;\n@@ -175,0 +180,222 @@\n+\/**\n+ * xmlFatalErr:\n+ * @ctxt:  an XML parser context\n+ * @error:  the error number\n+ * @info:  extra information string\n+ *\n+ * Handle a fatal parser error, i.e. violating Well-Formedness constraints\n+ *\/\n+void\n+xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info)\n+{\n+    const char *errmsg;\n+\n+    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n+        (ctxt->instate == XML_PARSER_EOF))\n+        return;\n+    switch (error) {\n+        case XML_ERR_INVALID_HEX_CHARREF:\n+            errmsg = \"CharRef: invalid hexadecimal value\";\n+            break;\n+        case XML_ERR_INVALID_DEC_CHARREF:\n+            errmsg = \"CharRef: invalid decimal value\";\n+            break;\n+        case XML_ERR_INVALID_CHARREF:\n+            errmsg = \"CharRef: invalid value\";\n+            break;\n+        case XML_ERR_INTERNAL_ERROR:\n+            errmsg = \"internal error\";\n+            break;\n+        case XML_ERR_PEREF_AT_EOF:\n+            errmsg = \"PEReference at end of document\";\n+            break;\n+        case XML_ERR_PEREF_IN_PROLOG:\n+            errmsg = \"PEReference in prolog\";\n+            break;\n+        case XML_ERR_PEREF_IN_EPILOG:\n+            errmsg = \"PEReference in epilog\";\n+            break;\n+        case XML_ERR_PEREF_NO_NAME:\n+            errmsg = \"PEReference: no name\";\n+            break;\n+        case XML_ERR_PEREF_SEMICOL_MISSING:\n+            errmsg = \"PEReference: expecting ';'\";\n+            break;\n+        case XML_ERR_ENTITY_LOOP:\n+            errmsg = \"Detected an entity reference loop\";\n+            break;\n+        case XML_ERR_ENTITY_NOT_STARTED:\n+            errmsg = \"EntityValue: \\\" or ' expected\";\n+            break;\n+        case XML_ERR_ENTITY_PE_INTERNAL:\n+            errmsg = \"PEReferences forbidden in internal subset\";\n+            break;\n+        case XML_ERR_ENTITY_NOT_FINISHED:\n+            errmsg = \"EntityValue: \\\" or ' expected\";\n+            break;\n+        case XML_ERR_ATTRIBUTE_NOT_STARTED:\n+            errmsg = \"AttValue: \\\" or ' expected\";\n+            break;\n+        case XML_ERR_LT_IN_ATTRIBUTE:\n+            errmsg = \"Unescaped '<' not allowed in attributes values\";\n+            break;\n+        case XML_ERR_LITERAL_NOT_STARTED:\n+            errmsg = \"SystemLiteral \\\" or ' expected\";\n+            break;\n+        case XML_ERR_LITERAL_NOT_FINISHED:\n+            errmsg = \"Unfinished System or Public ID \\\" or ' expected\";\n+            break;\n+        case XML_ERR_MISPLACED_CDATA_END:\n+            errmsg = \"Sequence ']]>' not allowed in content\";\n+            break;\n+        case XML_ERR_URI_REQUIRED:\n+            errmsg = \"SYSTEM or PUBLIC, the URI is missing\";\n+            break;\n+        case XML_ERR_PUBID_REQUIRED:\n+            errmsg = \"PUBLIC, the Public Identifier is missing\";\n+            break;\n+        case XML_ERR_HYPHEN_IN_COMMENT:\n+            errmsg = \"Comment must not contain '--' (double-hyphen)\";\n+            break;\n+        case XML_ERR_PI_NOT_STARTED:\n+            errmsg = \"xmlParsePI : no target name\";\n+            break;\n+        case XML_ERR_RESERVED_XML_NAME:\n+            errmsg = \"Invalid PI name\";\n+            break;\n+        case XML_ERR_NOTATION_NOT_STARTED:\n+            errmsg = \"NOTATION: Name expected here\";\n+            break;\n+        case XML_ERR_NOTATION_NOT_FINISHED:\n+            errmsg = \"'>' required to close NOTATION declaration\";\n+            break;\n+        case XML_ERR_VALUE_REQUIRED:\n+            errmsg = \"Entity value required\";\n+            break;\n+        case XML_ERR_URI_FRAGMENT:\n+            errmsg = \"Fragment not allowed\";\n+            break;\n+        case XML_ERR_ATTLIST_NOT_STARTED:\n+            errmsg = \"'(' required to start ATTLIST enumeration\";\n+            break;\n+        case XML_ERR_NMTOKEN_REQUIRED:\n+            errmsg = \"NmToken expected in ATTLIST enumeration\";\n+            break;\n+        case XML_ERR_ATTLIST_NOT_FINISHED:\n+            errmsg = \"')' required to finish ATTLIST enumeration\";\n+            break;\n+        case XML_ERR_MIXED_NOT_STARTED:\n+            errmsg = \"MixedContentDecl : '|' or ')*' expected\";\n+            break;\n+        case XML_ERR_PCDATA_REQUIRED:\n+            errmsg = \"MixedContentDecl : '#PCDATA' expected\";\n+            break;\n+        case XML_ERR_ELEMCONTENT_NOT_STARTED:\n+            errmsg = \"ContentDecl : Name or '(' expected\";\n+            break;\n+        case XML_ERR_ELEMCONTENT_NOT_FINISHED:\n+            errmsg = \"ContentDecl : ',' '|' or ')' expected\";\n+            break;\n+        case XML_ERR_PEREF_IN_INT_SUBSET:\n+            errmsg =\n+                \"PEReference: forbidden within markup decl in internal subset\";\n+            break;\n+        case XML_ERR_GT_REQUIRED:\n+            errmsg = \"expected '>'\";\n+            break;\n+        case XML_ERR_CONDSEC_INVALID:\n+            errmsg = \"XML conditional section '[' expected\";\n+            break;\n+        case XML_ERR_EXT_SUBSET_NOT_FINISHED:\n+            errmsg = \"Content error in the external subset\";\n+            break;\n+        case XML_ERR_CONDSEC_INVALID_KEYWORD:\n+            errmsg =\n+                \"conditional section INCLUDE or IGNORE keyword expected\";\n+            break;\n+        case XML_ERR_CONDSEC_NOT_FINISHED:\n+            errmsg = \"XML conditional section not closed\";\n+            break;\n+        case XML_ERR_XMLDECL_NOT_STARTED:\n+            errmsg = \"Text declaration '<?xml' required\";\n+            break;\n+        case XML_ERR_XMLDECL_NOT_FINISHED:\n+            errmsg = \"parsing XML declaration: '?>' expected\";\n+            break;\n+        case XML_ERR_EXT_ENTITY_STANDALONE:\n+            errmsg = \"external parsed entities cannot be standalone\";\n+            break;\n+        case XML_ERR_ENTITYREF_SEMICOL_MISSING:\n+            errmsg = \"EntityRef: expecting ';'\";\n+            break;\n+        case XML_ERR_DOCTYPE_NOT_FINISHED:\n+            errmsg = \"DOCTYPE improperly terminated\";\n+            break;\n+        case XML_ERR_LTSLASH_REQUIRED:\n+            errmsg = \"EndTag: '<\/' not found\";\n+            break;\n+        case XML_ERR_EQUAL_REQUIRED:\n+            errmsg = \"expected '='\";\n+            break;\n+        case XML_ERR_STRING_NOT_CLOSED:\n+            errmsg = \"String not closed expecting \\\" or '\";\n+            break;\n+        case XML_ERR_STRING_NOT_STARTED:\n+            errmsg = \"String not started expecting ' or \\\"\";\n+            break;\n+        case XML_ERR_ENCODING_NAME:\n+            errmsg = \"Invalid XML encoding name\";\n+            break;\n+        case XML_ERR_STANDALONE_VALUE:\n+            errmsg = \"standalone accepts only 'yes' or 'no'\";\n+            break;\n+        case XML_ERR_DOCUMENT_EMPTY:\n+            errmsg = \"Document is empty\";\n+            break;\n+        case XML_ERR_DOCUMENT_END:\n+            errmsg = \"Extra content at the end of the document\";\n+            break;\n+        case XML_ERR_NOT_WELL_BALANCED:\n+            errmsg = \"chunk is not well balanced\";\n+            break;\n+        case XML_ERR_EXTRA_CONTENT:\n+            errmsg = \"extra content at the end of well balanced chunk\";\n+            break;\n+        case XML_ERR_VERSION_MISSING:\n+            errmsg = \"Malformed declaration expecting version\";\n+            break;\n+        case XML_ERR_NAME_TOO_LONG:\n+            errmsg = \"Name too long\";\n+            break;\n+        case XML_ERR_INVALID_ENCODING:\n+            errmsg = \"Invalid bytes in character encoding\";\n+            break;\n+        case XML_IO_UNKNOWN:\n+            errmsg = \"I\/O error\";\n+            break;\n+#if 0\n+        case:\n+            errmsg = \"\";\n+            break;\n+#endif\n+        default:\n+            errmsg = \"Unregistered error message\";\n+    }\n+    if (ctxt != NULL)\n+        ctxt->errNo = error;\n+    if (info == NULL) {\n+        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,\n+                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, \"%s\\n\",\n+                        errmsg);\n+    } else {\n+        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,\n+                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, \"%s: %s\\n\",\n+                        errmsg, info);\n+    }\n+    if (ctxt != NULL) {\n+        ctxt->wellFormed = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n+    }\n+}\n+\n@@ -223,5 +450,0 @@\n-\/* #define DEBUG_INPUT *\/\n-\/* #define DEBUG_STACK *\/\n-\/* #define DEBUG_PUSH *\/\n-\n-\n@@ -231,16 +453,32 @@\n-#ifdef DEBUG_INPUT\n-#define CHECK_BUFFER(in) check_buffer(in)\n-\n-static\n-void check_buffer(xmlParserInputPtr in) {\n-    if (in->base != xmlBufContent(in->buf->buffer)) {\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlParserInput: base mismatch problem\\n\");\n-    }\n-    if (in->cur < in->base) {\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlParserInput: cur < base problem\\n\");\n-    }\n-    if (in->cur > in->base + xmlBufUse(in->buf->buffer)) {\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlParserInput: cur > base + use problem\\n\");\n+\/**\n+ * xmlHaltParser:\n+ * @ctxt:  an XML parser context\n+ *\n+ * Blocks further parser processing don't override error\n+ * for internal use\n+ *\/\n+void\n+xmlHaltParser(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return;\n+    ctxt->instate = XML_PARSER_EOF;\n+    ctxt->disableSAX = 1;\n+    while (ctxt->inputNr > 1)\n+        xmlFreeInputStream(inputPop(ctxt));\n+    if (ctxt->input != NULL) {\n+        \/*\n+         * in case there was a specific allocation deallocate before\n+         * overriding base\n+         *\/\n+        if (ctxt->input->free != NULL) {\n+            ctxt->input->free((xmlChar *) ctxt->input->base);\n+            ctxt->input->free = NULL;\n+        }\n+        if (ctxt->input->buf != NULL) {\n+            xmlFreeParserInputBuffer(ctxt->input->buf);\n+            ctxt->input->buf = NULL;\n+        }\n+        ctxt->input->cur = BAD_CAST\"\";\n+        ctxt->input->length = 0;\n+        ctxt->input->base = ctxt->input->cur;\n+        ctxt->input->end = ctxt->input->cur;\n@@ -248,3 +486,0 @@\n-    xmlGenericError(xmlGenericErrorContext,\"buffer %x : content %x, cur %d, use %d\\n\",\n-            (int) in, (int) xmlBufContent(in->buf->buffer), in->cur - in->base,\n-            xmlBufUse(in->buf->buffer));\n@@ -253,5 +488,0 @@\n-#else\n-#define CHECK_BUFFER(in)\n-#endif\n-\n-\n@@ -263,1 +493,1 @@\n- * This function was internal and is deprecated.\n+ * DEPRECATED: This function was internal and is deprecated.\n@@ -272,0 +502,51 @@\n+\/**\n+ * xmlParserGrow:\n+ * @ctxt:  an XML parser context\n+ *\n+ * Grow the input buffer.\n+ *\n+ * Returns the number of bytes read or -1 in case of error.\n+ *\/\n+int\n+xmlParserGrow(xmlParserCtxtPtr ctxt) {\n+    xmlParserInputPtr in = ctxt->input;\n+    xmlParserInputBufferPtr buf = in->buf;\n+    ptrdiff_t curEnd = in->end - in->cur;\n+    ptrdiff_t curBase = in->cur - in->base;\n+    int ret;\n+\n+    if (buf == NULL)\n+        return(0);\n+    \/* Don't grow push parser buffer. *\/\n+    if ((ctxt->progressive) && (ctxt->inputNr <= 1))\n+        return(0);\n+    \/* Don't grow memory buffers. *\/\n+    if ((buf->encoder == NULL) && (buf->readcallback == NULL))\n+        return(0);\n+    if (buf->error != 0)\n+        return(-1);\n+\n+    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||\n+         (curBase > XML_MAX_LOOKUP_LIMIT)) &&\n+        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n+        xmlErrMemory(ctxt, \"Huge input lookup\");\n+        xmlHaltParser(ctxt);\n+        return(-1);\n+    }\n+\n+    if (curEnd >= INPUT_CHUNK)\n+        return(0);\n+\n+    ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);\n+    xmlBufUpdateInput(buf->buffer, in, curBase);\n+\n+    if (ret < 0) {\n+        xmlFatalErr(ctxt, buf->error, NULL);\n+        \/* Buffer contents may be lost in case of memory errors. *\/\n+        if (buf->error == XML_ERR_NO_MEMORY)\n+            xmlHaltParser(ctxt);\n+    }\n+\n+    return(ret);\n+}\n+\n@@ -277,0 +558,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -289,3 +572,0 @@\n-#ifdef DEBUG_INPUT\n-    xmlGenericError(xmlGenericErrorContext, \"Grow\\n\");\n-#endif\n@@ -297,1 +577,3 @@\n-    CHECK_BUFFER(in);\n+    \/* Don't grow memory buffers. *\/\n+    if ((in->buf->encoder == NULL) && (in->buf->readcallback == NULL))\n+        return(0);\n@@ -301,3 +583,0 @@\n-\n-        CHECK_BUFFER(in);\n-\n@@ -306,4 +585,1 @@\n-    if (in->buf->readcallback != NULL) {\n-        ret = xmlParserInputBufferGrow(in->buf, len);\n-    } else\n-        return(0);\n+    ret = xmlParserInputBufferGrow(in->buf, len);\n@@ -312,0 +588,6 @@\n+    if (in->base == NULL) {\n+        in->base = BAD_CAST \"\";\n+        in->cur = in->base;\n+        in->end = in->base;\n+        return(-1);\n+    }\n@@ -315,2 +597,0 @@\n-    CHECK_BUFFER(in);\n-\n@@ -320,0 +600,41 @@\n+\/**\n+ * xmlParserShrink:\n+ * @ctxt:  an XML parser context\n+ *\n+ * Shrink the input buffer.\n+ *\/\n+void\n+xmlParserShrink(xmlParserCtxtPtr ctxt) {\n+    xmlParserInputPtr in = ctxt->input;\n+    xmlParserInputBufferPtr buf = in->buf;\n+    size_t used;\n+\n+    if (buf == NULL)\n+        return;\n+    \/* Don't shrink pull parser memory buffers. *\/\n+    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) &&\n+        (buf->encoder == NULL) &&\n+        (buf->readcallback == NULL))\n+        return;\n+\n+    used = in->cur - in->base;\n+    \/*\n+     * Do not shrink on large buffers whose only a tiny fraction\n+     * was consumed\n+     *\/\n+    if (used > INPUT_CHUNK) {\n+        size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);\n+\n+        if (res > 0) {\n+            used -= res;\n+            if ((res > ULONG_MAX) ||\n+                (in->consumed > ULONG_MAX - (unsigned long)res))\n+                in->consumed = ULONG_MAX;\n+            else\n+                in->consumed += res;\n+        }\n+    }\n+\n+    xmlBufUpdateInput(buf->buffer, in, used);\n+}\n+\n@@ -324,0 +645,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -331,3 +654,0 @@\n-#ifdef DEBUG_INPUT\n-    xmlGenericError(xmlGenericErrorContext, \"Shrink\\n\");\n-#endif\n@@ -340,2 +660,0 @@\n-    CHECK_BUFFER(in);\n-\n@@ -351,1 +669,5 @@\n-            in->consumed += ret;\n+            if ((ret > ULONG_MAX) ||\n+                (in->consumed > ULONG_MAX - (unsigned long)ret))\n+                in->consumed = ULONG_MAX;\n+            else\n+                in->consumed += ret;\n@@ -360,0 +682,7 @@\n+    if (in->base == NULL) {\n+        \/* TODO: raise error *\/\n+        in->base = BAD_CAST \"\";\n+        in->cur = in->base;\n+        in->end = in->base;\n+        return;\n+    }\n@@ -362,2 +691,0 @@\n-\n-    CHECK_BUFFER(in);\n@@ -376,0 +703,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -382,0 +711,4 @@\n+    const unsigned char *cur;\n+    size_t avail;\n+    int c;\n+\n@@ -386,6 +719,1 @@\n-    if (!(VALID_CTXT(ctxt))) {\n-        xmlErrInternal(ctxt, \"Parser input data memory error\\n\", NULL);\n-        ctxt->errNo = XML_ERR_INTERNAL_ERROR;\n-        xmlStopParser(ctxt);\n-        return;\n-    }\n+    avail = ctxt->input->end - ctxt->input->cur;\n@@ -393,3 +721,6 @@\n-    if ((*ctxt->input->cur == 0) &&\n-        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {\n-        return;\n+    if (avail < INPUT_CHUNK) {\n+        xmlParserGrow(ctxt);\n+        if ((ctxt->instate == XML_PARSER_EOF) ||\n+            (ctxt->input->cur >= ctxt->input->end))\n+            return;\n+        avail = ctxt->input->end - ctxt->input->cur;\n@@ -398,3 +729,2 @@\n-    if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-        const unsigned char *cur;\n-        unsigned char c;\n+    cur = ctxt->input->cur;\n+    c = *cur;\n@@ -402,9 +732,18 @@\n-        \/*\n-         *   2.11 End-of-Line Handling\n-         *   the literal two-character sequence \"#xD#xA\" or a standalone\n-         *   literal #xD, an XML processor must pass to the application\n-         *   the single character #xA.\n-         *\/\n-        if (*(ctxt->input->cur) == '\\n') {\n-            ctxt->input->line++; ctxt->input->col = 1;\n-        } else\n+    if (c < 0x80) {\n+        if (c == '\\n') {\n+            ctxt->input->cur++;\n+            ctxt->input->line++;\n+            ctxt->input->col = 1;\n+        } else if (c == '\\r') {\n+            \/*\n+             *   2.11 End-of-Line Handling\n+             *   the literal two-character sequence \"#xD#xA\" or a standalone\n+             *   literal #xD, an XML processor must pass to the application\n+             *   the single character #xA.\n+             *\/\n+            ctxt->input->cur += ((cur[1] == '\\n') ? 2 : 1);\n+            ctxt->input->line++;\n+            ctxt->input->col = 1;\n+            return;\n+        } else {\n+            ctxt->input->cur++;\n@@ -412,0 +751,3 @@\n+        }\n+    } else {\n+        ctxt->input->col++;\n@@ -413,12 +755,2 @@\n-        \/*\n-         * We are supposed to handle UTF8, check it's valid\n-         * From rfc2044: encoding of the Unicode values on UTF-8:\n-         *\n-         * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-         * 0000 0000-0000 007F   0xxxxxxx\n-         * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-         * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-         *\n-         * Check for the 0x110000 limit too\n-         *\/\n-        cur = ctxt->input->cur;\n+        if ((avail < 2) || (cur[1] & 0xc0) != 0x80)\n+            goto encoding_error;\n@@ -426,3 +758,3 @@\n-        c = *cur;\n-        if (c & 0x80) {\n-            if (c == 0xC0)\n+        if (c < 0xe0) {\n+            \/* 2-byte code *\/\n+            if (c < 0xc2)\n@@ -430,5 +762,5 @@\n-            if (cur[1] == 0) {\n-                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                cur = ctxt->input->cur;\n-            }\n-            if ((cur[1] & 0xc0) != 0x80)\n+            ctxt->input->cur += 2;\n+        } else {\n+            unsigned int val = (c << 8) | cur[1];\n+\n+            if ((avail < 3) || (cur[2] & 0xc0) != 0x80)\n@@ -436,2 +768,0 @@\n-            if ((c & 0xe0) == 0xe0) {\n-                unsigned int val;\n@@ -439,5 +769,7 @@\n-                if (cur[2] == 0) {\n-                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                    cur = ctxt->input->cur;\n-                }\n-                if ((cur[2] & 0xc0) != 0x80)\n+            if (c < 0xf0) {\n+                \/* 3-byte code *\/\n+                if ((val < 0xe0a0) || ((val >= 0xeda0) && (val < 0xee00)))\n+                    goto encoding_error;\n+                ctxt->input->cur += 3;\n+            } else {\n+                if ((avail < 4) || ((cur[3] & 0xc0) != 0x80))\n@@ -445,40 +777,0 @@\n-                if ((c & 0xf0) == 0xf0) {\n-                    if (cur[3] == 0) {\n-                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                        cur = ctxt->input->cur;\n-                    }\n-                    if (((c & 0xf8) != 0xf0) ||\n-                        ((cur[3] & 0xc0) != 0x80))\n-                        goto encoding_error;\n-                    \/* 4-byte code *\/\n-                    ctxt->input->cur += 4;\n-                    val = (cur[0] & 0x7) << 18;\n-                    val |= (cur[1] & 0x3f) << 12;\n-                    val |= (cur[2] & 0x3f) << 6;\n-                    val |= cur[3] & 0x3f;\n-                } else {\n-                    \/* 3-byte code *\/\n-                    ctxt->input->cur += 3;\n-                    val = (cur[0] & 0xf) << 12;\n-                    val |= (cur[1] & 0x3f) << 6;\n-                    val |= cur[2] & 0x3f;\n-                }\n-                if (((val > 0xd7ff) && (val < 0xe000)) ||\n-                    ((val > 0xfffd) && (val < 0x10000)) ||\n-                    (val >= 0x110000)) {\n-                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                                  \"Char 0x%X out of allowed range\\n\",\n-                                  val);\n-                }\n-            } else\n-                \/* 2-byte code *\/\n-                ctxt->input->cur += 2;\n-        } else\n-            \/* 1-byte code *\/\n-            ctxt->input->cur++;\n-    } else {\n-        \/*\n-         * Assume it's a fixed length encoding (1) with\n-         * a compatible encoding for the ASCII set, since\n-         * XML constructs only use < 128 chars\n-         *\/\n@@ -486,5 +778,6 @@\n-        if (*(ctxt->input->cur) == '\\n') {\n-            ctxt->input->line++; ctxt->input->col = 1;\n-        } else\n-            ctxt->input->col++;\n-        ctxt->input->cur++;\n+                \/* 4-byte code *\/\n+                if ((val < 0xf090) || (val >= 0xf490))\n+                    goto encoding_error;\n+                ctxt->input->cur += 4;\n+            }\n+        }\n@@ -492,2 +785,1 @@\n-    if (*ctxt->input->cur == 0)\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+\n@@ -495,15 +787,0 @@\n-encoding_error:\n-    \/*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertised in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     *\/\n-    if ((ctxt == NULL) || (ctxt->input == NULL) ||\n-        (ctxt->input->end - ctxt->input->cur < 4)) {\n-        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-                     \"Input is not proper UTF-8, indicate encoding !\\n\",\n-                     NULL, NULL);\n-    } else {\n-        char buffer[150];\n@@ -511,6 +788,19 @@\n-        snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-                        ctxt->input->cur[0], ctxt->input->cur[1],\n-                        ctxt->input->cur[2], ctxt->input->cur[3]);\n-        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-                     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n-                     BAD_CAST buffer, NULL);\n+encoding_error:\n+    \/* Only report the first error *\/\n+    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {\n+        if ((ctxt == NULL) || (ctxt->input == NULL) ||\n+            (ctxt->input->end - ctxt->input->cur < 4)) {\n+            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                         \"Input is not proper UTF-8, indicate encoding !\\n\",\n+                         NULL, NULL);\n+        } else {\n+            char buffer[150];\n+\n+            snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n+                            ctxt->input->cur[0], ctxt->input->cur[1],\n+                            ctxt->input->cur[2], ctxt->input->cur[3]);\n+            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                         \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n+                         BAD_CAST buffer, NULL);\n+        }\n+        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;\n@@ -518,1 +808,0 @@\n-    ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -528,0 +817,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -543,0 +834,4 @@\n+    const unsigned char *cur;\n+    size_t avail;\n+    int c;\n+\n@@ -547,3 +842,7 @@\n-    if ((*ctxt->input->cur >= 0x20) && (*ctxt->input->cur <= 0x7F)) {\n-            *len = 1;\n-            return((int) *ctxt->input->cur);\n+    avail = ctxt->input->end - ctxt->input->cur;\n+\n+    if (avail < INPUT_CHUNK) {\n+        xmlParserGrow(ctxt);\n+        if (ctxt->instate == XML_PARSER_EOF)\n+            return(0);\n+        avail = ctxt->input->end - ctxt->input->cur;\n@@ -551,15 +850,0 @@\n-    if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-        \/*\n-         * We are supposed to handle UTF8, check it's valid\n-         * From rfc2044: encoding of the Unicode values on UTF-8:\n-         *\n-         * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-         * 0000 0000-0000 007F   0xxxxxxx\n-         * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-         * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-         *\n-         * Check for the 0x110000 limit too\n-         *\/\n-        const unsigned char *cur = ctxt->input->cur;\n-        unsigned char c;\n-        unsigned int val;\n@@ -567,33 +851,25 @@\n-        c = *cur;\n-        if (c & 0x80) {\n-            if (((c & 0x40) == 0) || (c == 0xC0))\n-                goto encoding_error;\n-            if (cur[1] == 0) {\n-                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                cur = ctxt->input->cur;\n-            }\n-            if ((cur[1] & 0xc0) != 0x80)\n-                goto encoding_error;\n-            if ((c & 0xe0) == 0xe0) {\n-                if (cur[2] == 0) {\n-                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                    cur = ctxt->input->cur;\n-                }\n-                if ((cur[2] & 0xc0) != 0x80)\n-                    goto encoding_error;\n-                if ((c & 0xf0) == 0xf0) {\n-                    if (cur[3] == 0) {\n-                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                        cur = ctxt->input->cur;\n-                    }\n-                    if (((c & 0xf8) != 0xf0) ||\n-                        ((cur[3] & 0xc0) != 0x80))\n-                        goto encoding_error;\n-                    \/* 4-byte code *\/\n-                    *len = 4;\n-                    val = (cur[0] & 0x7) << 18;\n-                    val |= (cur[1] & 0x3f) << 12;\n-                    val |= (cur[2] & 0x3f) << 6;\n-                    val |= cur[3] & 0x3f;\n-                    if (val < 0x10000)\n-                        goto encoding_error;\n+    cur = ctxt->input->cur;\n+    c = *cur;\n+\n+    if (c < 0x80) {\n+        \/* 1-byte code *\/\n+        if (c < 0x20) {\n+            \/*\n+             *   2.11 End-of-Line Handling\n+             *   the literal two-character sequence \"#xD#xA\" or a standalone\n+             *   literal #xD, an XML processor must pass to the application\n+             *   the single character #xA.\n+             *\/\n+            if (c == '\\r') {\n+                \/*\n+                 * TODO: This function shouldn't change the 'cur' pointer\n+                 * as side effect, but the NEXTL macro in parser.c relies\n+                 * on this behavior when incrementing line numbers.\n+                 *\/\n+                if (cur[1] == '\\n')\n+                    ctxt->input->cur++;\n+                *len = 1;\n+                c = '\\n';\n+            } else if (c == 0) {\n+                if (ctxt->input->cur >= ctxt->input->end) {\n+                    *len = 0;\n@@ -601,7 +877,7 @@\n-                  \/* 3-byte code *\/\n-                    *len = 3;\n-                    val = (cur[0] & 0xf) << 12;\n-                    val |= (cur[1] & 0x3f) << 6;\n-                    val |= cur[2] & 0x3f;\n-                    if (val < 0x800)\n-                        goto encoding_error;\n+                    *len = 1;\n+                    \/*\n+                     * TODO: Null bytes should be handled by callers,\n+                     * but this can be tricky.\n+                     *\/\n+                    xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n+                            \"Char 0x0 out of allowed range\\n\", c);\n@@ -610,6 +886,1 @@\n-              \/* 2-byte code *\/\n-                *len = 2;\n-                val = (cur[0] & 0x1f) << 6;\n-                val |= cur[1] & 0x3f;\n-                if (val < 0x80)\n-                    goto encoding_error;\n+                *len = 1;\n@@ -617,5 +888,0 @@\n-            if (!IS_CHAR(val)) {\n-                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                                  \"Char 0x%X out of allowed range\\n\", val);\n-            }\n-            return(val);\n@@ -623,1 +889,0 @@\n-            \/* 1-byte code *\/\n@@ -625,12 +890,46 @@\n-            if (*ctxt->input->cur == 0)\n-                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->end > ctxt->input->cur)) {\n-                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                                  \"Char 0x0 out of allowed range\\n\", 0);\n-            }\n-            if (*ctxt->input->cur == 0xD) {\n-                if (ctxt->input->cur[1] == 0xA) {\n-                    ctxt->input->cur++;\n-                }\n-                return(0xA);\n+        }\n+\n+        return(c);\n+    } else {\n+        int val;\n+\n+        if (avail < 2)\n+            goto incomplete_sequence;\n+        if ((cur[1] & 0xc0) != 0x80)\n+            goto encoding_error;\n+\n+        if (c < 0xe0) {\n+            \/* 2-byte code *\/\n+            if (c < 0xc2)\n+                goto encoding_error;\n+            val = (c & 0x1f) << 6;\n+            val |= cur[1] & 0x3f;\n+            *len = 2;\n+        } else {\n+            if (avail < 3)\n+                goto incomplete_sequence;\n+            if ((cur[2] & 0xc0) != 0x80)\n+                goto encoding_error;\n+\n+            if (c < 0xf0) {\n+                \/* 3-byte code *\/\n+                val = (c & 0xf) << 12;\n+                val |= (cur[1] & 0x3f) << 6;\n+                val |= cur[2] & 0x3f;\n+                if ((val < 0x800) || ((val >= 0xd800) && (val < 0xe000)))\n+                    goto encoding_error;\n+                *len = 3;\n+            } else {\n+                if (avail < 4)\n+                    goto incomplete_sequence;\n+                if ((cur[3] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+\n+                \/* 4-byte code *\/\n+                val = (c & 0x0f) << 18;\n+                val |= (cur[1] & 0x3f) << 12;\n+                val |= (cur[2] & 0x3f) << 6;\n+                val |= cur[3] & 0x3f;\n+                if ((val < 0x10000) || (val >= 0x110000))\n+                    goto encoding_error;\n+                *len = 4;\n@@ -638,1 +937,0 @@\n-            return((int) *ctxt->input->cur);\n@@ -640,0 +938,2 @@\n+\n+        return(val);\n@@ -641,9 +941,17 @@\n-    \/*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     *\/\n-    *len = 1;\n-    if (*ctxt->input->cur == 0xD) {\n-        if (ctxt->input->cur[1] == 0xA) {\n-            ctxt->input->cur++;\n+\n+encoding_error:\n+    \/* Only report the first error *\/\n+    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {\n+        if (ctxt->input->end - ctxt->input->cur < 4) {\n+            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                         \"Input is not proper UTF-8, indicate encoding !\\n\",\n+                         NULL, NULL);\n+        } else {\n+            char buffer[150];\n+\n+            snprintf(&buffer[0], 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n+                            ctxt->input->cur[0], ctxt->input->cur[1],\n+                            ctxt->input->cur[2], ctxt->input->cur[3]);\n+            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                         \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n+                         BAD_CAST buffer, NULL);\n@@ -651,1 +959,1 @@\n-        return(0xA);\n+        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;\n@@ -653,2 +961,4 @@\n-    return((int) *ctxt->input->cur);\n-encoding_error:\n+    *len = 1;\n+    return(0xFFFD); \/* U+FFFD Replacement Character *\/\n+\n+incomplete_sequence:\n@@ -658,13 +968,2 @@\n-     * an error but return 0 to indicate an end of stream problem\n-     *\/\n-    if (ctxt->input->end - ctxt->input->cur < 4) {\n-        *len = 0;\n-        return(0);\n-    }\n-\n-    \/*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertised in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n+     * an error but return 0. This should only happen when push parsing\n+     * char data.\n@@ -672,13 +971,2 @@\n-    {\n-        char buffer[150];\n-\n-        snprintf(&buffer[0], 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-                        ctxt->input->cur[0], ctxt->input->cur[1],\n-                        ctxt->input->cur[2], ctxt->input->cur[3]);\n-        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-                     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n-                     BAD_CAST buffer, NULL);\n-    }\n-    ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n-    return((int) *ctxt->input->cur);\n+    *len = 0;\n+    return(0);\n@@ -693,0 +981,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -700,67 +990,3 @@\n-xmlStringCurrentChar(xmlParserCtxtPtr ctxt, const xmlChar * cur, int *len)\n-{\n-    if ((len == NULL) || (cur == NULL)) return(0);\n-    if ((ctxt == NULL) || (ctxt->charset == XML_CHAR_ENCODING_UTF8)) {\n-        \/*\n-         * We are supposed to handle UTF8, check it's valid\n-         * From rfc2044: encoding of the Unicode values on UTF-8:\n-         *\n-         * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-         * 0000 0000-0000 007F   0xxxxxxx\n-         * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-         * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-         *\n-         * Check for the 0x110000 limit too\n-         *\/\n-        unsigned char c;\n-        unsigned int val;\n-\n-        c = *cur;\n-        if (c & 0x80) {\n-            if ((cur[1] & 0xc0) != 0x80)\n-                goto encoding_error;\n-            if ((c & 0xe0) == 0xe0) {\n-\n-                if ((cur[2] & 0xc0) != 0x80)\n-                    goto encoding_error;\n-                if ((c & 0xf0) == 0xf0) {\n-                    if (((c & 0xf8) != 0xf0) || ((cur[3] & 0xc0) != 0x80))\n-                        goto encoding_error;\n-                    \/* 4-byte code *\/\n-                    *len = 4;\n-                    val = (cur[0] & 0x7) << 18;\n-                    val |= (cur[1] & 0x3f) << 12;\n-                    val |= (cur[2] & 0x3f) << 6;\n-                    val |= cur[3] & 0x3f;\n-                } else {\n-                    \/* 3-byte code *\/\n-                    *len = 3;\n-                    val = (cur[0] & 0xf) << 12;\n-                    val |= (cur[1] & 0x3f) << 6;\n-                    val |= cur[2] & 0x3f;\n-                }\n-            } else {\n-                \/* 2-byte code *\/\n-                *len = 2;\n-                val = (cur[0] & 0x1f) << 6;\n-                val |= cur[1] & 0x3f;\n-            }\n-            if (!IS_CHAR(val)) {\n-                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                                  \"Char 0x%X out of allowed range\\n\", val);\n-            }\n-            return (val);\n-        } else {\n-            \/* 1-byte code *\/\n-            *len = 1;\n-            return ((int) *cur);\n-        }\n-    }\n-    \/*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     *\/\n-    *len = 1;\n-    return ((int) *cur);\n-encoding_error:\n+xmlStringCurrentChar(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n+                     const xmlChar *cur, int *len) {\n+    int c;\n@@ -768,8 +994,1 @@\n-    \/*\n-     * An encoding problem may arise from a truncated input buffer\n-     * splitting a character in the middle. In that case do not raise\n-     * an error but return 0 to indicate an end of stream problem\n-     *\/\n-    if ((ctxt == NULL) || (ctxt->input == NULL) ||\n-        (ctxt->input->end - ctxt->input->cur < 4)) {\n-        *len = 0;\n+    if ((cur == NULL) || (len == NULL))\n@@ -777,10 +996,0 @@\n-    }\n-    \/*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertised in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     *\/\n-    {\n-        char buffer[150];\n@@ -788,9 +997,5 @@\n-        snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-                        ctxt->input->cur[0], ctxt->input->cur[1],\n-                        ctxt->input->cur[2], ctxt->input->cur[3]);\n-        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-                     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n-                     BAD_CAST buffer, NULL);\n-    }\n-    *len = 1;\n-    return ((int) *cur);\n+    \/* cur is zero-terminated, so we can lie about its length. *\/\n+    *len = 4;\n+    c = xmlGetUTF8Char(cur, len);\n+\n+    return((c < 0) ? 0 : c);\n@@ -810,1 +1015,1 @@\n-    if (out == NULL) return(0);\n+    if ((out == NULL) || (val < 0)) return(0);\n@@ -836,1 +1041,1 @@\n-    *out = (xmlChar) val;\n+    *out = val;\n@@ -853,1 +1058,1 @@\n-    if (out == NULL) return(0);\n+    if ((out == NULL) || (val < 0)) return(0);\n@@ -858,1 +1063,1 @@\n-    *out = (xmlChar) val;\n+    *out = val;\n@@ -868,3 +1073,60 @@\n-static int\n-xmlSwitchInputEncodingInt(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n-                          xmlCharEncodingHandlerPtr handler, int len);\n+static xmlCharEncodingHandlerPtr\n+xmlDetectEBCDIC(xmlParserInputPtr input) {\n+    xmlChar out[200];\n+    xmlCharEncodingHandlerPtr handler;\n+    int inlen, outlen, res, i;\n+\n+    \/*\n+     * To detect the EBCDIC code page, we convert the first 200 bytes\n+     * to EBCDIC-US and try to find the encoding declaration.\n+     *\/\n+    handler = xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC);\n+    if (handler == NULL)\n+        return(NULL);\n+    outlen = sizeof(out) - 1;\n+    inlen = input->end - input->cur;\n+    res = xmlEncInputChunk(handler, out, &outlen, input->cur, &inlen);\n+    if (res < 0)\n+        return(handler);\n+    out[outlen] = 0;\n+\n+    for (i = 0; i < outlen; i++) {\n+        if (out[i] == '>')\n+            break;\n+        if ((out[i] == 'e') &&\n+            (xmlStrncmp(out + i, BAD_CAST \"encoding\", 8) == 0)) {\n+            int start, cur, quote;\n+\n+            i += 8;\n+            while (IS_BLANK_CH(out[i]))\n+                i += 1;\n+            if (out[i++] != '=')\n+                break;\n+            while (IS_BLANK_CH(out[i]))\n+                i += 1;\n+            quote = out[i++];\n+            if ((quote != '\\'') && (quote != '\"'))\n+                break;\n+            start = i;\n+            cur = out[i];\n+            while (((cur >= 'a') && (cur <= 'z')) ||\n+                   ((cur >= 'A') && (cur <= 'Z')) ||\n+                   ((cur >= '0') && (cur <= '9')) ||\n+                   (cur == '.') || (cur == '_') ||\n+                   (cur == '-'))\n+                cur = out[++i];\n+            if (cur != quote)\n+                break;\n+            out[i] = 0;\n+            xmlCharEncCloseFunc(handler);\n+            return(xmlFindCharEncodingHandler((char *) out + start));\n+        }\n+    }\n+\n+    \/*\n+     * ICU handlers are stateful, so we have to recreate them.\n+     *\/\n+    xmlCharEncCloseFunc(handler);\n+    return(xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC));\n+}\n+\n@@ -876,2 +1138,4 @@\n- * change the input functions when discovering the character encoding\n- * of a given entity.\n+ * Use encoding specified by enum to decode input data.\n+ *\n+ * This function can be used to enforce the encoding of chunks passed\n+ * to xmlParseChunk.\n@@ -884,2 +1148,2 @@\n-    xmlCharEncodingHandlerPtr handler;\n-    int len = -1;\n+    xmlCharEncodingHandlerPtr handler = NULL;\n+    int check = 1;\n@@ -888,1 +1152,3 @@\n-    if (ctxt == NULL) return(-1);\n+    if ((ctxt == NULL) || (ctxt->input == NULL))\n+        return(-1);\n+\n@@ -890,4 +1156,0 @@\n-        case XML_CHAR_ENCODING_ERROR:\n-            __xmlErrEncoding(ctxt, XML_ERR_UNKNOWN_ENCODING,\n-                           \"encoding unknown\\n\", NULL, NULL);\n-            return(-1);\n@@ -895,3 +1157,0 @@\n-            \/* let's assume it's UTF-8 without the XML decl *\/\n-            ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-            return(0);\n@@ -899,93 +1158,17 @@\n-            \/* default encoding, no conversion should be needed *\/\n-            ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-\n-            \/*\n-             * Errata on XML-1.0 June 20 2001\n-             * Specific handling of the Byte Order Mark for\n-             * UTF-8\n-             *\/\n-            if ((ctxt->input != NULL) &&\n-                (ctxt->input->cur[0] == 0xEF) &&\n-                (ctxt->input->cur[1] == 0xBB) &&\n-                (ctxt->input->cur[2] == 0xBF)) {\n-                ctxt->input->cur += 3;\n-            }\n-            return(0);\n-    case XML_CHAR_ENCODING_UTF16LE:\n-    case XML_CHAR_ENCODING_UTF16BE:\n-        \/*The raw input characters are encoded\n-         *in UTF-16. As we expect this function\n-         *to be called after xmlCharEncInFunc, we expect\n-         *ctxt->input->cur to contain UTF-8 encoded characters.\n-         *So the raw UTF16 Byte Order Mark\n-         *has also been converted into\n-         *an UTF-8 BOM. Let's skip that BOM.\n-         *\/\n-        if ((ctxt->input != NULL) && (ctxt->input->cur != NULL) &&\n-            (ctxt->input->cur[0] == 0xEF) &&\n-            (ctxt->input->cur[1] == 0xBB) &&\n-            (ctxt->input->cur[2] == 0xBF)) {\n-            ctxt->input->cur += 3;\n-        }\n-        len = 90;\n-        break;\n-    case XML_CHAR_ENCODING_UCS2:\n-        len = 90;\n-        break;\n-    case XML_CHAR_ENCODING_UCS4BE:\n-    case XML_CHAR_ENCODING_UCS4LE:\n-    case XML_CHAR_ENCODING_UCS4_2143:\n-    case XML_CHAR_ENCODING_UCS4_3412:\n-        len = 180;\n-        break;\n-    case XML_CHAR_ENCODING_EBCDIC:\n-    case XML_CHAR_ENCODING_8859_1:\n-    case XML_CHAR_ENCODING_8859_2:\n-    case XML_CHAR_ENCODING_8859_3:\n-    case XML_CHAR_ENCODING_8859_4:\n-    case XML_CHAR_ENCODING_8859_5:\n-    case XML_CHAR_ENCODING_8859_6:\n-    case XML_CHAR_ENCODING_8859_7:\n-    case XML_CHAR_ENCODING_8859_8:\n-    case XML_CHAR_ENCODING_8859_9:\n-    case XML_CHAR_ENCODING_ASCII:\n-    case XML_CHAR_ENCODING_2022_JP:\n-    case XML_CHAR_ENCODING_SHIFT_JIS:\n-    case XML_CHAR_ENCODING_EUC_JP:\n-        len = 45;\n-        break;\n-    }\n-    handler = xmlGetCharEncodingHandler(enc);\n-    if (handler == NULL) {\n-        \/*\n-         * Default handlers.\n-         *\/\n-        switch (enc) {\n-            case XML_CHAR_ENCODING_ASCII:\n-                \/* default encoding, no conversion should be needed *\/\n-                ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-                return(0);\n-            case XML_CHAR_ENCODING_8859_1:\n-                if ((ctxt->inputNr == 1) &&\n-                    (ctxt->encoding == NULL) &&\n-                    (ctxt->input != NULL) &&\n-                    (ctxt->input->encoding != NULL)) {\n-                    ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n-                }\n-                ctxt->charset = enc;\n-                return(0);\n-            default:\n-                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                        \"encoding not supported: %s\\n\",\n-                        BAD_CAST xmlGetCharEncodingName(enc), NULL);\n-                \/*\n-                 * TODO: We could recover from errors in external entities\n-                 * if we didn't stop the parser. But most callers of this\n-                 * function don't check the return value.\n-                 *\/\n-                xmlStopParser(ctxt);\n-                return(-1);\n-        }\n-    }\n-    ret = xmlSwitchInputEncodingInt(ctxt, ctxt->input, handler, len);\n-    if ((ret < 0) || (ctxt->errNo == XML_I18N_CONV_FAILED)) {\n+        case XML_CHAR_ENCODING_ASCII:\n+            check = 0;\n+            break;\n+        case XML_CHAR_ENCODING_EBCDIC:\n+            handler = xmlDetectEBCDIC(ctxt->input);\n+            break;\n+        default:\n+            handler = xmlGetCharEncodingHandler(enc);\n+            break;\n+    }\n+\n+    if ((check) && (handler == NULL)) {\n+        const char *name = xmlGetCharEncodingName(enc);\n+\n+        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                \"encoding not supported: %s\\n\",\n+                BAD_CAST (name ? name : \"<null>\"), NULL);\n@@ -993,1 +1176,3 @@\n-         * on encoding conversion errors, stop the parser\n+         * TODO: We could recover from errors in external entities\n+         * if we didn't stop the parser. But most callers of this\n+         * function don't check the return value.\n@@ -996,1 +1181,7 @@\n-        ctxt->errNo = XML_I18N_CONV_FAILED;\n+        return(-1);\n+    }\n+\n+    ret = xmlSwitchInputEncoding(ctxt, ctxt->input, handler);\n+\n+    if ((ret >= 0) && (enc == XML_CHAR_ENCODING_NONE)) {\n+        ctxt->input->flags &= ~XML_INPUT_HAS_ENCODING;\n@@ -998,0 +1189,1 @@\n+\n@@ -1002,1 +1194,1 @@\n- * xmlSwitchInputEncodingInt:\n+ * xmlSwitchInputEncoding:\n@@ -1006,1 +1198,0 @@\n- * @len:  the number of bytes to convert for the first line or -1\n@@ -1008,2 +1199,3 @@\n- * change the input functions when discovering the character encoding\n- * of a given entity.\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Use encoding handler to decode input data.\n@@ -1013,3 +1205,3 @@\n-static int\n-xmlSwitchInputEncodingInt(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n-                          xmlCharEncodingHandlerPtr handler, int len)\n+int\n+xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n+                       xmlCharEncodingHandlerPtr handler)\n@@ -1018,0 +1210,1 @@\n+    xmlParserInputBufferPtr in;\n@@ -1019,3 +1212,2 @@\n-    if (handler == NULL)\n-        return (-1);\n-    if (input == NULL)\n+    if ((input == NULL) || (input->buf == NULL)) {\n+        xmlCharEncCloseFunc(handler);\n@@ -1023,2 +1215,2 @@\n-    if (input->buf != NULL) {\n-        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+    }\n+    in = input->buf;\n@@ -1026,7 +1218,1 @@\n-        if (input->buf->encoder != NULL) {\n-            \/*\n-             * Check in case the auto encoding detection triggered\n-             * in already.\n-             *\/\n-            if (input->buf->encoder == handler)\n-                return (0);\n+    input->flags |= XML_INPUT_HAS_ENCODING;\n@@ -1034,9 +1220,8 @@\n-            \/*\n-             * \"UTF-16\" can be used for both LE and BE\n-             if ((!xmlStrncmp(BAD_CAST input->buf->encoder->name,\n-             BAD_CAST \"UTF-16\", 6)) &&\n-             (!xmlStrncmp(BAD_CAST handler->name,\n-             BAD_CAST \"UTF-16\", 6))) {\n-             return(0);\n-             }\n-             *\/\n+    \/*\n+     * UTF-8 requires no encoding handler.\n+     *\/\n+    if ((handler != NULL) &&\n+        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST \"UTF-8\") == 0)) {\n+        xmlCharEncCloseFunc(handler);\n+        handler = NULL;\n+    }\n@@ -1044,15 +1229,2 @@\n-            \/*\n-             * Note: this is a bit dangerous, but that's what it\n-             * takes to use nearly compatible signature for different\n-             * encodings.\n-             *\n-             * FIXME: Encoders might buffer partial byte sequences, so\n-             * this probably can't work. We should return an error and\n-             * make sure that callers never try to switch the encoding\n-             * twice.\n-             *\/\n-            xmlCharEncCloseFunc(input->buf->encoder);\n-            input->buf->encoder = handler;\n-            return (0);\n-        }\n-        input->buf->encoder = handler;\n+    if (in->encoder == handler)\n+        return (0);\n@@ -1060,0 +1232,1 @@\n+    if (in->encoder != NULL) {\n@@ -1061,1 +1234,6 @@\n-         * Is there already some content down the pipe to convert ?\n+         * Switching encodings during parsing is a really bad idea,\n+         * but Chromium can switch between ISO-8859-1 and UTF-16 before\n+         * separate calls to xmlParseChunk.\n+         *\n+         * TODO: We should check whether the \"raw\" input buffer is empty and\n+         * convert the old content using the old encoder.\n@@ -1063,3 +1241,0 @@\n-        if (xmlBufIsEmpty(input->buf->buffer) == 0) {\n-            int processed;\n-            unsigned int use;\n@@ -1067,61 +1242,2 @@\n-            \/*\n-             * Specific handling of the Byte Order Mark for\n-             * UTF-16\n-             *\/\n-            if ((handler->name != NULL) &&\n-                (!strcmp(handler->name, \"UTF-16LE\") ||\n-                 !strcmp(handler->name, \"UTF-16\")) &&\n-                (input->cur[0] == 0xFF) && (input->cur[1] == 0xFE)) {\n-                input->cur += 2;\n-            }\n-            if ((handler->name != NULL) &&\n-                (!strcmp(handler->name, \"UTF-16BE\")) &&\n-                (input->cur[0] == 0xFE) && (input->cur[1] == 0xFF)) {\n-                input->cur += 2;\n-            }\n-            \/*\n-             * Errata on XML-1.0 June 20 2001\n-             * Specific handling of the Byte Order Mark for\n-             * UTF-8\n-             *\/\n-            if ((handler->name != NULL) &&\n-                (!strcmp(handler->name, \"UTF-8\")) &&\n-                (input->cur[0] == 0xEF) &&\n-                (input->cur[1] == 0xBB) && (input->cur[2] == 0xBF)) {\n-                input->cur += 3;\n-            }\n-\n-            \/*\n-             * Shrink the current input buffer.\n-             * Move it as the raw buffer and create a new input buffer\n-             *\/\n-            processed = input->cur - input->base;\n-            xmlBufShrink(input->buf->buffer, processed);\n-            input->buf->raw = input->buf->buffer;\n-            input->buf->buffer = xmlBufCreate();\n-            input->buf->rawconsumed = processed;\n-            use = xmlBufUse(input->buf->raw);\n-\n-            if (ctxt->html) {\n-                \/*\n-                 * convert as much as possible of the buffer\n-                 *\/\n-                nbchars = xmlCharEncInput(input->buf, 1);\n-            } else {\n-                \/*\n-                 * convert just enough to get\n-                 * '<?xml version=\"1.0\" encoding=\"xxx\"?>'\n-                 * parsed with the autodetected encoding\n-                 * into the parser reading buffer.\n-                 *\/\n-                nbchars = xmlCharEncFirstLineInput(input->buf, len);\n-            }\n-            xmlBufResetInput(input->buf->buffer, input);\n-            if (nbchars < 0) {\n-                xmlErrInternal(ctxt,\n-                               \"switching encoding: encoder error\\n\",\n-                               NULL);\n-                return (-1);\n-            }\n-            input->buf->rawconsumed += use - xmlBufUse(input->buf->raw);\n-        }\n+        xmlCharEncCloseFunc(in->encoder);\n+        in->encoder = handler;\n@@ -1129,3 +1245,10 @@\n-    } else {\n-        xmlErrInternal(ctxt,\n-                \"static memory buffer doesn't support encoding\\n\", NULL);\n+    }\n+\n+    in->encoder = handler;\n+\n+    \/*\n+     * Is there already some content down the pipe to convert ?\n+     *\/\n+    if (xmlBufIsEmpty(in->buffer) == 0) {\n+        size_t processed;\n+\n@@ -1133,3 +1256,2 @@\n-         * Callers assume that the input buffer takes ownership of the\n-         * encoding handler. xmlCharEncCloseFunc frees unregistered\n-         * handlers and avoids a memory leak.\n+         * Shrink the current input buffer.\n+         * Move it as the raw buffer and create a new input buffer\n@@ -1137,2 +1259,17 @@\n-        xmlCharEncCloseFunc(handler);\n-        return (-1);\n+        processed = input->cur - input->base;\n+        xmlBufShrink(in->buffer, processed);\n+        input->consumed += processed;\n+        in->raw = in->buffer;\n+        in->buffer = xmlBufCreate();\n+        in->rawconsumed = processed;\n+\n+        nbchars = xmlCharEncInput(in);\n+        xmlBufResetInput(in->buffer, input);\n+        if (nbchars < 0) {\n+            \/* TODO: This could be an out of memory or an encoding error. *\/\n+            xmlErrInternal(ctxt,\n+                           \"switching encoding: encoder error\\n\",\n+                           NULL);\n+            xmlHaltParser(ctxt);\n+            return (-1);\n+        }\n@@ -1140,0 +1277,1 @@\n+    return (0);\n@@ -1143,1 +1281,1 @@\n- * xmlSwitchInputEncoding:\n+ * xmlSwitchToEncoding:\n@@ -1145,1 +1283,0 @@\n- * @input:  the input stream\n@@ -1148,1 +1285,1 @@\n- * DEPRECATED: Use xmlSwitchToEncoding\n+ * Use encoding handler to decode input data.\n@@ -1150,2 +1287,2 @@\n- * change the input functions when discovering the character encoding\n- * of a given entity.\n+ * This function can be used to enforce the encoding of chunks passed\n+ * to xmlParseChunk.\n@@ -1156,3 +1293,5 @@\n-xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n-                          xmlCharEncodingHandlerPtr handler) {\n-    return(xmlSwitchInputEncodingInt(ctxt, input, handler, -1));\n+xmlSwitchToEncoding(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr handler)\n+{\n+    if (ctxt == NULL)\n+        return(-1);\n+    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));\n@@ -1162,1 +1301,1 @@\n- * xmlSwitchToEncoding:\n+ * xmlDetectEncoding:\n@@ -1164,1 +1303,0 @@\n- * @handler:  the encoding handler\n@@ -1166,2 +1304,1 @@\n- * change the input functions when discovering the character encoding\n- * of a given entity.\n+ * Handle optional BOM, detect and switch to encoding.\n@@ -1169,1 +1306,1 @@\n- * Returns 0 in case of success, -1 otherwise\n+ * Assumes that there are at least four bytes in the input buffer.\n@@ -1171,6 +1308,196 @@\n-int\n-xmlSwitchToEncoding(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr handler)\n-{\n-    if (ctxt == NULL)\n-        return(-1);\n-    return(xmlSwitchInputEncodingInt(ctxt, ctxt->input, handler, -1));\n+void\n+xmlDetectEncoding(xmlParserCtxtPtr ctxt) {\n+    const xmlChar *in;\n+    xmlCharEncoding enc;\n+    int bomSize;\n+    int autoFlag = 0;\n+\n+    if (xmlParserGrow(ctxt) < 0)\n+        return;\n+    in = ctxt->input->cur;\n+    if (ctxt->input->end - in < 4)\n+        return;\n+\n+    if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {\n+        \/*\n+         * If the encoding was already set, only skip the BOM which was\n+         * possibly decoded to UTF-8.\n+         *\/\n+        if ((in[0] == 0xEF) && (in[1] == 0xBB) && (in[2] == 0xBF)) {\n+            ctxt->input->cur += 3;\n+        }\n+\n+        return;\n+    }\n+\n+    enc = XML_CHAR_ENCODING_NONE;\n+    bomSize = 0;\n+\n+    switch (in[0]) {\n+        case 0x00:\n+            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {\n+                enc = XML_CHAR_ENCODING_UCS4BE;\n+                autoFlag = XML_INPUT_AUTO_OTHER;\n+            } else if ((in[1] == 0x3C) && (in[2] == 0x00) && (in[3] == 0x3F)) {\n+                enc = XML_CHAR_ENCODING_UTF16BE;\n+                autoFlag = XML_INPUT_AUTO_UTF16BE;\n+            }\n+            break;\n+\n+        case 0x3C:\n+            if (in[1] == 0x00) {\n+                if ((in[2] == 0x00) && (in[3] == 0x00)) {\n+                    enc = XML_CHAR_ENCODING_UCS4LE;\n+                    autoFlag = XML_INPUT_AUTO_OTHER;\n+                } else if ((in[2] == 0x3F) && (in[3] == 0x00)) {\n+                    enc = XML_CHAR_ENCODING_UTF16LE;\n+                    autoFlag = XML_INPUT_AUTO_UTF16LE;\n+                }\n+            }\n+            break;\n+\n+        case 0x4C:\n+            if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {\n+                enc = XML_CHAR_ENCODING_EBCDIC;\n+                autoFlag = XML_INPUT_AUTO_OTHER;\n+            }\n+            break;\n+\n+        case 0xEF:\n+            if ((in[1] == 0xBB) && (in[2] == 0xBF)) {\n+                enc = XML_CHAR_ENCODING_UTF8;\n+                autoFlag = XML_INPUT_AUTO_UTF8;\n+                bomSize = 3;\n+            }\n+            break;\n+\n+        case 0xFE:\n+            if (in[1] == 0xFF) {\n+                enc = XML_CHAR_ENCODING_UTF16BE;\n+                autoFlag = XML_INPUT_AUTO_UTF16BE;\n+                bomSize = 2;\n+            }\n+            break;\n+\n+        case 0xFF:\n+            if (in[1] == 0xFE) {\n+                enc = XML_CHAR_ENCODING_UTF16LE;\n+                autoFlag = XML_INPUT_AUTO_UTF16LE;\n+                bomSize = 2;\n+            }\n+            break;\n+    }\n+\n+    if (bomSize > 0) {\n+        ctxt->input->cur += bomSize;\n+    }\n+\n+    if (enc != XML_CHAR_ENCODING_NONE) {\n+        ctxt->input->flags |= autoFlag;\n+        xmlSwitchEncoding(ctxt, enc);\n+    }\n+}\n+\n+\/**\n+ * xmlSetDeclaredEncoding:\n+ * @ctxt:  the parser context\n+ * @encoding:  declared encoding\n+ *\n+ * Set the encoding from a declaration in the document.\n+ *\n+ * If no encoding was set yet, switch the encoding. Otherwise, only warn\n+ * about encoding mismatches.\n+ *\n+ * Takes ownership of 'encoding'.\n+ *\/\n+void\n+xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {\n+    if (ctxt->encoding != NULL)\n+        xmlFree((xmlChar *) ctxt->encoding);\n+    ctxt->encoding = encoding;\n+\n+    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&\n+        ((ctxt->options & XML_PARSE_IGNORE_ENC) == 0)) {\n+        xmlCharEncodingHandlerPtr handler;\n+\n+        handler = xmlFindCharEncodingHandler((const char *) encoding);\n+        if (handler == NULL) {\n+            __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                             \"Unsupported encoding: %s\\n\",\n+                             encoding, NULL);\n+            return;\n+        }\n+\n+        xmlSwitchToEncoding(ctxt, handler);\n+        ctxt->input->flags |= XML_INPUT_USES_ENC_DECL;\n+    } else if (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {\n+        static const char *allowedUTF8[] = {\n+            \"UTF-8\", \"UTF8\", NULL\n+        };\n+        static const char *allowedUTF16LE[] = {\n+            \"UTF-16\", \"UTF-16LE\", \"UTF16\", NULL\n+        };\n+        static const char *allowedUTF16BE[] = {\n+            \"UTF-16\", \"UTF-16BE\", \"UTF16\", NULL\n+        };\n+        const char **allowed = NULL;\n+        const char *autoEnc = NULL;\n+\n+        switch (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {\n+            case XML_INPUT_AUTO_UTF8:\n+                allowed = allowedUTF8;\n+                autoEnc = \"UTF-8\";\n+                break;\n+            case XML_INPUT_AUTO_UTF16LE:\n+                allowed = allowedUTF16LE;\n+                autoEnc = \"UTF-16LE\";\n+                break;\n+            case XML_INPUT_AUTO_UTF16BE:\n+                allowed = allowedUTF16BE;\n+                autoEnc = \"UTF-16BE\";\n+                break;\n+        }\n+\n+        if (allowed != NULL) {\n+            const char **p;\n+            int match = 0;\n+\n+            for (p = allowed; *p != NULL; p++) {\n+                if (xmlStrcasecmp(encoding, BAD_CAST *p) == 0) {\n+                    match = 1;\n+                    break;\n+                }\n+            }\n+\n+            if (match == 0) {\n+                xmlWarningMsg(ctxt, XML_WAR_ENCODING_MISMATCH,\n+                              \"Encoding '%s' doesn't match \"\n+                              \"auto-detected '%s'\\n\",\n+                              encoding, BAD_CAST autoEnc);\n+            }\n+        }\n+    }\n+}\n+\n+\/**\n+ * xmlGetActualEncoding:\n+ * @ctxt:  the parser context\n+ *\n+ * Returns the actual used to parse the document. This can differ from\n+ * the declared encoding.\n+ *\/\n+const xmlChar *\n+xmlGetActualEncoding(xmlParserCtxtPtr ctxt) {\n+    const xmlChar *encoding = NULL;\n+\n+    if ((ctxt->input->flags & XML_INPUT_USES_ENC_DECL) ||\n+        (ctxt->input->flags & XML_INPUT_AUTO_ENCODING)) {\n+        \/* Preserve encoding exactly *\/\n+        encoding = ctxt->encoding;\n+    } else if ((ctxt->input->buf) && (ctxt->input->buf->encoder)) {\n+        encoding = BAD_CAST ctxt->input->buf->encoder->name;\n+    } else if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {\n+        encoding = BAD_CAST \"UTF-8\";\n+    }\n+\n+    return(encoding);\n@@ -1197,1 +1524,0 @@\n-    if (input->encoding != NULL) xmlFree((char *) input->encoding);\n@@ -1226,1 +1552,0 @@\n-    input->standalone = -1;\n@@ -1233,1 +1558,5 @@\n-    if (ctxt != NULL)\n+    if (ctxt != NULL) {\n+        if (input->id >= INT_MAX) {\n+            xmlErrMemory(ctxt, \"Input ID overflow\\n\");\n+            return(NULL);\n+        }\n@@ -1235,0 +1564,1 @@\n+    }\n@@ -1278,0 +1608,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -1302,2 +1634,5 @@\n-                return(xmlLoadExternalEntity((char *) entity->URI,\n-                       (char *) entity->ExternalID, ctxt));\n+                input = xmlLoadExternalEntity((char *) entity->URI,\n+                       (char *) entity->ExternalID, ctxt);\n+                if (input != NULL)\n+                    input->entity = entity;\n+                return(input);\n@@ -1334,0 +1669,1 @@\n+    input->entity = entity;\n@@ -1348,0 +1684,1 @@\n+    xmlParserInputBufferPtr buf;\n@@ -1357,0 +1694,5 @@\n+    buf = xmlParserInputBufferCreateString(buffer);\n+    if (buf == NULL) {\n+        xmlErrMemory(ctxt, NULL);\n+        return(NULL);\n+    }\n@@ -1360,0 +1702,1 @@\n+        xmlFreeParserInputBuffer(buf);\n@@ -1362,4 +1705,2 @@\n-    input->base = buffer;\n-    input->cur = buffer;\n-    input->length = xmlStrlen(buffer);\n-    input->end = &buffer[input->length];\n+    input->buf = buf;\n+    xmlBufResetInput(input->buf->buffer, input);\n@@ -1435,2 +1776,4 @@\n- * xmlInitParserCtxt:\n- * @ctxt:  an XML parser context\n+ * xmlInitSAXParserCtxt:\n+ * @ctxt:  XML parser context\n+ * @sax:  SAX handlert\n+ * @userData:  user data\n@@ -1438,1 +1781,1 @@\n- * Initialize a parser context\n+ * Initialize a SAX parser context\n@@ -1443,2 +1786,3 @@\n-int\n-xmlInitParserCtxt(xmlParserCtxtPtr ctxt)\n+static int\n+xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,\n+                     void *userData)\n@@ -1469,1 +1813,2 @@\n-    else\n+    if (sax == NULL) {\n+        memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n@@ -1471,0 +1816,10 @@\n+        ctxt->userData = ctxt;\n+    } else {\n+        if (sax->initialized == XML_SAX2_MAGIC) {\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n+        } else {\n+            memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n+        }\n+        ctxt->userData = userData ? userData : ctxt;\n+    }\n@@ -1568,1 +1923,0 @@\n-    ctxt->userData = ctxt;\n@@ -1610,1 +1964,0 @@\n-    ctxt->charset = XML_CHAR_ENCODING_UTF8;\n@@ -1612,1 +1965,0 @@\n-    ctxt->nbentities = 0;\n@@ -1616,0 +1968,1 @@\n+    ctxt->maxAmpl = XML_MAX_AMPLIFICATION_DEFAULT;\n@@ -1617,0 +1970,9 @@\n+\n+    if (ctxt->nsdb == NULL) {\n+        ctxt->nsdb = xmlParserNsCreate();\n+        if (ctxt->nsdb == NULL) {\n+            xmlErrMemory(ctxt, NULL);\n+            return(-1);\n+        }\n+    }\n+\n@@ -1620,0 +1982,18 @@\n+\/**\n+ * xmlInitParserCtxt:\n+ * @ctxt:  an XML parser context\n+ *\n+ * DEPRECATED: Internal function which will be made private in a future\n+ * version.\n+ *\n+ * Initialize a parser context\n+ *\n+ * Returns 0 in case of success and -1 in case of error\n+ *\/\n+\n+int\n+xmlInitParserCtxt(xmlParserCtxtPtr ctxt)\n+{\n+    return(xmlInitSAXParserCtxt(ctxt, NULL, NULL));\n+}\n+\n@@ -1658,1 +2038,3 @@\n-    if (ctxt->nsTab != NULL) xmlFree((char *) ctxt->nsTab);\n+    if (ctxt->nsTab != NULL) xmlFree(ctxt->nsTab);\n+    if (ctxt->nsdb != NULL) xmlParserNsFree(ctxt->nsdb);\n+    if (ctxt->attrHash != NULL) xmlFree(ctxt->attrHash);\n@@ -1716,0 +2098,17 @@\n+{\n+    return(xmlNewSAXParserCtxt(NULL, NULL));\n+}\n+\n+\/**\n+ * xmlNewSAXParserCtxt:\n+ * @sax:  SAX handler\n+ * @userData:  user data\n+ *\n+ * Allocate and initialize a new SAX parser context. If userData is NULL,\n+ * the parser context will be passed as user data.\n+ *\n+ * Returns the xmlParserCtxtPtr or NULL if memory allocation failed.\n+ *\/\n+\n+xmlParserCtxtPtr\n+xmlNewSAXParserCtxt(const xmlSAXHandler *sax, void *userData)\n@@ -1725,1 +2124,1 @@\n-    if (xmlInitParserCtxt(ctxt) < 0) {\n+    if (xmlInitSAXParserCtxt(ctxt, sax, userData) < 0) {\n@@ -1760,0 +2159,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -1785,0 +2186,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -1801,0 +2204,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -1819,0 +2224,1 @@\n+ * DEPRECATED: Don't use.\n@@ -1862,0 +2268,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -1932,0 +2340,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_PEDANTIC.\n+ *\n@@ -1949,0 +2359,2 @@\n+ * DEPRECATED: The modern options API always enables line numbers.\n+ *\n@@ -1967,0 +2379,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_NOENT.\n+ *\n@@ -1989,0 +2403,2 @@\n+ * DEPRECATED: Use the modern options API with XML_PARSE_NOBLANKS.\n+ *\n@@ -2014,1 +2430,4 @@\n-    if (!val) xmlIndentTreeOutput = 1;\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    if (!val)\n+        xmlIndentTreeOutput = 1;\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/parserInternals.c","additions":1080,"deletions":661,"binary":false,"changes":1741,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include <libxml\/pattern.h>\n@@ -32,1 +33,0 @@\n-#include <libxml\/hash.h>\n@@ -36,1 +36,0 @@\n-#include <libxml\/pattern.h>\n@@ -40,2 +39,0 @@\n-\/* #define DEBUG_STREAMING *\/\n-\n@@ -938,1 +935,0 @@\n-            XML_PAT_FREE_STRING(ctxt, prefix);\n@@ -963,1 +959,0 @@\n-                XML_PAT_FREE_STRING(ctxt, prefix);\n@@ -968,1 +963,2 @@\n-        XML_PAT_FREE_STRING(ctxt, prefix);\n+        XML_PAT_FREE_STRING(ctxt, name);\n+        name = NULL;\n@@ -987,0 +983,2 @@\n+    if (name != NULL)\n+        XML_PAT_FREE_STRING(ctxt, name);\n@@ -1418,56 +1416,0 @@\n-#ifdef DEBUG_STREAMING\n-static void\n-xmlDebugStreamComp(xmlStreamCompPtr stream) {\n-    int i;\n-\n-    if (stream == NULL) {\n-        printf(\"Stream: NULL\\n\");\n-        return;\n-    }\n-    printf(\"Stream: %d steps\\n\", stream->nbStep);\n-    for (i = 0;i < stream->nbStep;i++) {\n-        if (stream->steps[i].ns != NULL) {\n-            printf(\"{%s}\", stream->steps[i].ns);\n-        }\n-        if (stream->steps[i].name == NULL) {\n-            printf(\"* \");\n-        } else {\n-            printf(\"%s \", stream->steps[i].name);\n-        }\n-        if (stream->steps[i].flags & XML_STREAM_STEP_ROOT)\n-            printf(\"root \");\n-        if (stream->steps[i].flags & XML_STREAM_STEP_DESC)\n-            printf(\"\/\/ \");\n-        if (stream->steps[i].flags & XML_STREAM_STEP_FINAL)\n-            printf(\"final \");\n-        printf(\"\\n\");\n-    }\n-}\n-static void\n-xmlDebugStreamCtxt(xmlStreamCtxtPtr ctxt, int match) {\n-    int i;\n-\n-    if (ctxt == NULL) {\n-        printf(\"Stream: NULL\\n\");\n-        return;\n-    }\n-    printf(\"Stream: level %d, %d states: \", ctxt->level, ctxt->nbState);\n-    if (match)\n-        printf(\"matches\\n\");\n-    else\n-        printf(\"\\n\");\n-    for (i = 0;i < ctxt->nbState;i++) {\n-        if (ctxt->states[2 * i] < 0)\n-            printf(\" %d: free\\n\", i);\n-        else {\n-            printf(\" %d: step %d, level %d\", i, ctxt->states[2 * i],\n-                   ctxt->states[(2 * i) + 1]);\n-            if (ctxt->comp->steps[ctxt->states[2 * i]].flags &\n-                XML_STREAM_STEP_DESC)\n-                printf(\" \/\/\\n\");\n-            else\n-                printf(\"\\n\");\n-        }\n-    }\n-}\n-#endif\n@@ -1732,3 +1674,0 @@\n-#ifdef DEBUG_STREAMING\n-    xmlDebugStreamComp(stream);\n-#endif\n@@ -1855,3 +1794,0 @@\n-#ifdef DEBUG_STREAMING\n-    xmlStreamCtxtPtr orig = stream;\n-#endif\n@@ -2042,8 +1978,2 @@\n-                if (desc) {\n-                    if (final) {\n-                        ret = 1;\n-                    } else {\n-                        \/* descending match create a new state *\/\n-                        xmlStreamCtxtAddState(stream, stepNr + 1,\n-                                              stream->level + 1);\n-                    }\n+                if (final) {\n+                    ret = 1;\n@@ -2051,6 +1981,2 @@\n-                    if (final) {\n-                        ret = 1;\n-                    } else {\n-                        xmlStreamCtxtAddState(stream, stepNr + 1,\n-                                              stream->level + 1);\n-                    }\n+                    xmlStreamCtxtAddState(stream, stepNr + 1,\n+                                          stream->level + 1);\n@@ -2185,3 +2111,0 @@\n-#ifdef DEBUG_STREAMING\n-    xmlDebugStreamCtxt(orig, ret);\n-#endif\n@@ -2210,1 +2133,1 @@\n-    return (xmlStreamPushInternal(stream, name, ns, (int) XML_ELEMENT_NODE));\n+    return (xmlStreamPushInternal(stream, name, ns, XML_ELEMENT_NODE));\n@@ -2260,1 +2183,1 @@\n-    return (xmlStreamPushInternal(stream, name, ns, (int) XML_ATTRIBUTE_NODE));\n+    return (xmlStreamPushInternal(stream, name, ns, XML_ATTRIBUTE_NODE));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/pattern.c","additions":11,"deletions":88,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -17,9 +17,3 @@\n-#include <libxml\/globals.h>\n-\n-#ifdef HAVE_PTHREAD_H\n-#include <pthread.h>\n-#elif defined HAVE_WIN32_THREADS\n-#define WIN32_LEAN_AND_MEAN\n-#include <windows.h>\n-#ifndef HAVE_COMPILER_TLS\n-#include <process.h>\n+#include <libxml\/parser.h>\n+#ifdef LIBXML_CATALOG_ENABLED\n+#include <libxml\/catalog.h>\n@@ -27,5 +21,3 @@\n-#endif\n-\n-#ifdef HAVE_BEOS_THREADS\n-#include <OS.h>\n-#include <TLS.h>\n+#ifdef LIBXML_SCHEMAS_ENABLED\n+#include <libxml\/xmlschemastypes.h>\n+#include <libxml\/relaxng.h>\n@@ -38,1 +30,6 @@\n-\/* #define DEBUG_THREADS *\/\n+#include \"private\/dict.h\"\n+#include \"private\/enc.h\"\n+#include \"private\/globals.h\"\n+#include \"private\/memory.h\"\n+#include \"private\/threads.h\"\n+#include \"private\/xpath.h\"\n@@ -40,1 +37,3 @@\n-#ifdef HAVE_PTHREAD_H\n+#if defined(HAVE_POSIX_THREADS) && \\\n+    defined(__GLIBC__) && \\\n+    __GLIBC__ * 100 + __GLIBC_MINOR__ >= 234\n@@ -42,2 +41,7 @@\n-#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 303) && \\\n-    defined(__GLIBC__) && defined(__linux__)\n+\/*\n+ * The modern way available since glibc 2.32.\n+ *\n+ * The check above is for glibc 2.34 which merged the pthread symbols into\n+ * libc. Since we still allow linking without pthread symbols (see below),\n+ * this only works if pthread symbols are guaranteed to be available.\n+ *\/\n@@ -45,1 +49,1 @@\n-static int libxml_is_threaded = -1;\n+#include <sys\/single_threaded.h>\n@@ -47,1 +51,20 @@\n-#define XML_PTHREAD_WEAK\n+#define XML_IS_THREADED() (!__libc_single_threaded)\n+#define XML_IS_NEVER_THREADED() 0\n+\n+#elif defined(HAVE_POSIX_THREADS) && \\\n+      defined(__GLIBC__) && \\\n+      defined(__GNUC__)\n+\n+\/*\n+ * The traditional way to check for single-threaded applications with\n+ * glibc was to check whether the separate libpthread library is\n+ * linked in. This works by not linking libxml2 with libpthread (see\n+ * BASE_THREAD_LIBS in configure.ac and Makefile.am) and declaring\n+ * pthread functions as weak symbols.\n+ *\n+ * In glibc 2.34, the pthread symbols were moved from libpthread to libc,\n+ * so this doesn't work anymore.\n+ *\n+ * At some point, this legacy code and the BASE_THREAD_LIBS hack in\n+ * configure.ac can probably be removed.\n+ *\/\n@@ -49,5 +72,0 @@\n-#pragma weak pthread_once\n-#pragma weak pthread_getspecific\n-#pragma weak pthread_setspecific\n-#pragma weak pthread_key_create\n-#pragma weak pthread_key_delete\n@@ -63,2 +81,0 @@\n-#pragma weak pthread_key_create\n-#pragma weak pthread_key_delete\n@@ -67,1 +83,5 @@\n-#else \/* __GNUC__, __GLIBC__, __linux__ *\/\n+#define XML_PTHREAD_WEAK\n+#define XML_IS_THREADED() libxml_is_threaded\n+#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)\n+\n+static int libxml_is_threaded = -1;\n@@ -69,1 +89,1 @@\n-static int libxml_is_threaded = 1;\n+#else \/* other POSIX platforms *\/\n@@ -71,1 +91,2 @@\n-#endif \/* __GNUC__, __GLIBC__, __linux__ *\/\n+#define XML_IS_THREADED() 1\n+#define XML_IS_NEVER_THREADED() 0\n@@ -73,1 +94,1 @@\n-#endif \/* HAVE_PTHREAD_H *\/\n+#endif\n@@ -81,16 +102,0 @@\n-\/*\n- * xmlMutex are a simple mutual exception locks\n- *\/\n-struct _xmlMutex {\n-#ifdef HAVE_PTHREAD_H\n-    pthread_mutex_t lock;\n-#elif defined HAVE_WIN32_THREADS\n-    CRITICAL_SECTION cs;\n-#elif defined HAVE_BEOS_THREADS\n-    sem_id sem;\n-    thread_id tid;\n-#else\n-    int empty;\n-#endif\n-};\n-\n@@ -101,1 +106,1 @@\n-#ifdef HAVE_PTHREAD_H\n+#ifdef HAVE_POSIX_THREADS\n@@ -109,4 +114,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    xmlMutexPtr lock;\n-    thread_id tid;\n-    int32 count;\n@@ -118,35 +119,0 @@\n-\/*\n- * This module still has some internal static data.\n- *   - xmlLibraryLock a global lock\n- *   - globalkey used for per-thread data\n- *\/\n-\n-#ifdef HAVE_PTHREAD_H\n-static pthread_key_t globalkey;\n-static pthread_t mainthread;\n-static pthread_once_t once_control = PTHREAD_ONCE_INIT;\n-static pthread_once_t once_control_init = PTHREAD_ONCE_INIT;\n-static pthread_mutex_t global_init_lock = PTHREAD_MUTEX_INITIALIZER;\n-#elif defined HAVE_WIN32_THREADS\n-#if defined(HAVE_COMPILER_TLS)\n-static __declspec(thread) xmlGlobalState tlstate;\n-static __declspec(thread) int tlstate_inited = 0;\n-#else \/* HAVE_COMPILER_TLS *\/\n-static DWORD globalkey = TLS_OUT_OF_INDEXES;\n-#endif \/* HAVE_COMPILER_TLS *\/\n-static DWORD mainthread;\n-static struct {\n-    DWORD done;\n-    LONG control;\n-} run_once = { 0, 0};\n-static volatile LPCRITICAL_SECTION global_init_lock = NULL;\n-\n-\/* endif HAVE_WIN32_THREADS *\/\n-#elif defined HAVE_BEOS_THREADS\n-int32 globalkey = 0;\n-thread_id mainthread = 0;\n-int32 run_once_init = 0;\n-static int32 global_init_lock = -1;\n-static vint32 global_init_count = 0;\n-#endif\n-\n@@ -155,2 +121,16 @@\n-#ifdef LIBXML_THREAD_ENABLED\n-static void xmlOnceInit(void);\n+\/**\n+ * xmlInitMutex:\n+ * @mutex:  the mutex\n+ *\n+ * Initialize a mutex.\n+ *\/\n+void\n+xmlInitMutex(xmlMutexPtr mutex)\n+{\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_NEVER_THREADED() == 0)\n+        pthread_mutex_init(&mutex->lock, NULL);\n+#elif defined HAVE_WIN32_THREADS\n+    InitializeCriticalSection(&mutex->cs);\n+#else\n+    (void) mutex;\n@@ -158,0 +138,1 @@\n+}\n@@ -174,3 +155,16 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded != 0)\n-        pthread_mutex_init(&tok->lock, NULL);\n+    xmlInitMutex(tok);\n+    return (tok);\n+}\n+\n+\/**\n+ * xmlCleanupMutex:\n+ * @mutex:  the simple mutex\n+ *\n+ * Reclaim resources associated with a mutex.\n+ *\/\n+void\n+xmlCleanupMutex(xmlMutexPtr mutex)\n+{\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_NEVER_THREADED() == 0)\n+        pthread_mutex_destroy(&mutex->lock);\n@@ -178,7 +172,3 @@\n-    InitializeCriticalSection(&tok->cs);\n-#elif defined HAVE_BEOS_THREADS\n-    if ((tok->sem = create_sem(1, \"xmlMutex\")) < B_OK) {\n-        free(tok);\n-        return NULL;\n-    }\n-    tok->tid = -1;\n+    DeleteCriticalSection(&mutex->cs);\n+#else\n+    (void) mutex;\n@@ -186,1 +176,0 @@\n-    return (tok);\n@@ -193,2 +182,1 @@\n- * xmlFreeMutex() is used to reclaim resources associated with a libxml2 token\n- * struct.\n+ * Free a mutex.\n@@ -202,8 +190,1 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded != 0)\n-        pthread_mutex_destroy(&tok->lock);\n-#elif defined HAVE_WIN32_THREADS\n-    DeleteCriticalSection(&tok->cs);\n-#elif defined HAVE_BEOS_THREADS\n-    delete_sem(tok->sem);\n-#endif\n+    xmlCleanupMutex(tok);\n@@ -224,2 +205,6 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded != 0)\n+#ifdef HAVE_POSIX_THREADS\n+    \/*\n+     * This assumes that __libc_single_threaded won't change while the\n+     * lock is held.\n+     *\/\n+    if (XML_IS_THREADED() != 0)\n@@ -229,8 +214,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    if (acquire_sem(tok->sem) != B_NO_ERROR) {\n-#ifdef DEBUG_THREADS\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"xmlMutexLock():BeOS:Couldn't acquire semaphore\\n\");\n-#endif\n-    }\n-    tok->tid = find_thread(NULL);\n@@ -252,2 +229,2 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded != 0)\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_THREADED() != 0)\n@@ -257,5 +234,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    if (tok->tid == find_thread(NULL)) {\n-        tok->tid = -1;\n-        release_sem(tok->sem);\n-    }\n@@ -282,2 +254,2 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded != 0) {\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_NEVER_THREADED() == 0) {\n@@ -291,6 +263,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    if ((tok->lock = xmlNewMutex()) == NULL) {\n-        free(tok);\n-        return NULL;\n-    }\n-    tok->count = 0;\n@@ -313,2 +279,2 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded != 0) {\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_NEVER_THREADED() == 0) {\n@@ -320,2 +286,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    xmlFreeMutex(tok->lock);\n@@ -337,2 +301,2 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded == 0)\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_THREADED() == 0)\n@@ -359,8 +323,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    if (tok->lock->tid == find_thread(NULL)) {\n-        tok->count++;\n-        return;\n-    } else {\n-        xmlMutexLock(tok->lock);\n-        tok->count = 1;\n-    }\n@@ -381,2 +337,2 @@\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded == 0)\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_THREADED() == 0)\n@@ -395,336 +351,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    if (tok->lock->tid == find_thread(NULL)) {\n-        tok->count--;\n-        if (tok->count == 0) {\n-            xmlMutexUnlock(tok->lock);\n-        }\n-        return;\n-    }\n-#endif\n-}\n-\n-\/**\n- * xmlGlobalInitMutexLock\n- *\n- * Makes sure that the global initialization mutex is initialized and\n- * locks it.\n- *\/\n-void\n-__xmlGlobalInitMutexLock(void)\n-{\n-    \/* Make sure the global init lock is initialized and then lock it. *\/\n-#ifdef HAVE_PTHREAD_H\n-    \/* The mutex is statically initialized, so we just lock it. *\/\n-#ifdef XML_PTHREAD_WEAK\n-    if (pthread_mutex_lock == NULL)\n-        return;\n-#endif \/* XML_PTHREAD_WEAK *\/\n-    pthread_mutex_lock(&global_init_lock);\n-#elif defined HAVE_WIN32_THREADS\n-    LPCRITICAL_SECTION cs;\n-\n-    \/* Create a new critical section *\/\n-    if (global_init_lock == NULL) {\n-        cs = malloc(sizeof(CRITICAL_SECTION));\n-        if (cs == NULL) {\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"xmlGlobalInitMutexLock: out of memory\\n\");\n-            return;\n-        }\n-        InitializeCriticalSection(cs);\n-\n-        \/* Swap it into the global_init_lock *\/\n-#ifdef InterlockedCompareExchangePointer\n-        InterlockedCompareExchangePointer((void **) &global_init_lock,\n-                                          cs, NULL);\n-#else \/* Use older void* version *\/\n-        InterlockedCompareExchange((void **) &global_init_lock,\n-                                   (void *) cs, NULL);\n-#endif \/* InterlockedCompareExchangePointer *\/\n-\n-        \/* If another thread successfully recorded its critical\n-         * section in the global_init_lock then discard the one\n-         * allocated by this thread. *\/\n-        if (global_init_lock != cs) {\n-            DeleteCriticalSection(cs);\n-            free(cs);\n-        }\n-    }\n-\n-    \/* Lock the chosen critical section *\/\n-    EnterCriticalSection(global_init_lock);\n-#elif defined HAVE_BEOS_THREADS\n-    int32 sem;\n-\n-    \/* Allocate a new semaphore *\/\n-    sem = create_sem(1, \"xmlGlobalinitMutex\");\n-\n-    while (global_init_lock == -1) {\n-        if (atomic_add(&global_init_count, 1) == 0) {\n-            global_init_lock = sem;\n-        } else {\n-            snooze(1);\n-            atomic_add(&global_init_count, -1);\n-        }\n-    }\n-\n-    \/* If another thread successfully recorded its critical\n-     * section in the global_init_lock then discard the one\n-     * allocated by this thread. *\/\n-    if (global_init_lock != sem)\n-        delete_sem(sem);\n-\n-    \/* Acquire the chosen semaphore *\/\n-    if (acquire_sem(global_init_lock) != B_NO_ERROR) {\n-#ifdef DEBUG_THREADS\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"xmlGlobalInitMutexLock():BeOS:Couldn't acquire semaphore\\n\");\n-#endif\n-    }\n-#endif\n-}\n-\n-void\n-__xmlGlobalInitMutexUnlock(void)\n-{\n-#ifdef HAVE_PTHREAD_H\n-#ifdef XML_PTHREAD_WEAK\n-    if (pthread_mutex_unlock == NULL)\n-        return;\n-#endif \/* XML_PTHREAD_WEAK *\/\n-    pthread_mutex_unlock(&global_init_lock);\n-#elif defined HAVE_WIN32_THREADS\n-    if (global_init_lock != NULL) {\n-        LeaveCriticalSection(global_init_lock);\n-    }\n-#elif defined HAVE_BEOS_THREADS\n-    release_sem(global_init_lock);\n-#endif\n-}\n-\n-\/**\n- * xmlGlobalInitMutexDestroy\n- *\n- * Makes sure that the global initialization mutex is destroyed before\n- * application termination.\n- *\/\n-void\n-__xmlGlobalInitMutexDestroy(void)\n-{\n-#ifdef HAVE_PTHREAD_H\n-#elif defined HAVE_WIN32_THREADS\n-    if (global_init_lock != NULL) {\n-        DeleteCriticalSection(global_init_lock);\n-        free(global_init_lock);\n-        global_init_lock = NULL;\n-    }\n-#endif\n-}\n-\n-\/************************************************************************\n- *                                                                      *\n- *                      Per thread global state handling                *\n- *                                                                      *\n- ************************************************************************\/\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-#ifdef xmlLastError\n-#undef xmlLastError\n-#endif\n-\n-\/**\n- * xmlFreeGlobalState:\n- * @state:  a thread global state\n- *\n- * xmlFreeGlobalState() is called when a thread terminates with a non-NULL\n- * global state. It is is used here to reclaim memory resources.\n- *\/\n-static void\n-xmlFreeGlobalState(void *state)\n-{\n-    xmlGlobalState *gs = (xmlGlobalState *) state;\n-\n-    \/* free any memory allocated in the thread's xmlLastError *\/\n-    xmlResetError(&(gs->xmlLastError));\n-    free(state);\n-}\n-\n-\/**\n- * xmlNewGlobalState:\n- *\n- * xmlNewGlobalState() allocates a global state. This structure is used to\n- * hold all data for use by a thread when supporting backwards compatibility\n- * of libxml2 to pre-thread-safe behaviour.\n- *\n- * Returns the newly allocated xmlGlobalStatePtr or NULL in case of error\n- *\/\n-static xmlGlobalStatePtr\n-xmlNewGlobalState(void)\n-{\n-    xmlGlobalState *gs;\n-\n-    gs = malloc(sizeof(xmlGlobalState));\n-    if (gs == NULL) {\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"xmlGetGlobalState: out of memory\\n\");\n-        return (NULL);\n-    }\n-\n-    memset(gs, 0, sizeof(xmlGlobalState));\n-    xmlInitializeGlobalState(gs);\n-    return (gs);\n-}\n-#endif \/* LIBXML_THREAD_ENABLED *\/\n-\n-#ifdef HAVE_PTHREAD_H\n-#elif defined HAVE_WIN32_THREADS\n-#if !defined(HAVE_COMPILER_TLS)\n-#if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n-typedef struct _xmlGlobalStateCleanupHelperParams {\n-    HANDLE thread;\n-    void *memory;\n-} xmlGlobalStateCleanupHelperParams;\n-\n-static void XMLCDECL\n-xmlGlobalStateCleanupHelper(void *p)\n-{\n-    xmlGlobalStateCleanupHelperParams *params =\n-        (xmlGlobalStateCleanupHelperParams *) p;\n-    WaitForSingleObject(params->thread, INFINITE);\n-    CloseHandle(params->thread);\n-    xmlFreeGlobalState(params->memory);\n-    free(params);\n-    _endthread();\n-}\n-#else \/* LIBXML_STATIC && !LIBXML_STATIC_FOR_DLL *\/\n-\n-typedef struct _xmlGlobalStateCleanupHelperParams {\n-    void *memory;\n-    struct _xmlGlobalStateCleanupHelperParams *prev;\n-    struct _xmlGlobalStateCleanupHelperParams *next;\n-} xmlGlobalStateCleanupHelperParams;\n-\n-static xmlGlobalStateCleanupHelperParams *cleanup_helpers_head = NULL;\n-static CRITICAL_SECTION cleanup_helpers_cs;\n-\n-#endif \/* LIBXMLSTATIC && !LIBXML_STATIC_FOR_DLL *\/\n-#endif \/* HAVE_COMPILER_TLS *\/\n-#endif \/* HAVE_WIN32_THREADS *\/\n-\n-#if defined HAVE_BEOS_THREADS\n-\n-\/**\n- * xmlGlobalStateCleanup:\n- * @data: unused parameter\n- *\n- * Used for Beos only\n- *\/\n-void\n-xmlGlobalStateCleanup(void *data)\n-{\n-    void *globalval = tls_get(globalkey);\n-\n-    if (globalval != NULL)\n-        xmlFreeGlobalState(globalval);\n-}\n-#endif\n-\n-\/**\n- * xmlGetGlobalState:\n- *\n- * xmlGetGlobalState() is called to retrieve the global state for a thread.\n- *\n- * Returns the thread global state or NULL in case of error\n- *\/\n-xmlGlobalStatePtr\n-xmlGetGlobalState(void)\n-{\n-#ifdef HAVE_PTHREAD_H\n-    xmlGlobalState *globalval;\n-\n-    if (libxml_is_threaded == 0)\n-        return (NULL);\n-\n-    pthread_once(&once_control, xmlOnceInit);\n-\n-    if ((globalval = (xmlGlobalState *)\n-         pthread_getspecific(globalkey)) == NULL) {\n-        xmlGlobalState *tsd = xmlNewGlobalState();\n-        if (tsd == NULL)\n-            return(NULL);\n-\n-        pthread_setspecific(globalkey, tsd);\n-        return (tsd);\n-    }\n-    return (globalval);\n-#elif defined HAVE_WIN32_THREADS\n-#if defined(HAVE_COMPILER_TLS)\n-    if (!tlstate_inited) {\n-        tlstate_inited = 1;\n-        xmlInitializeGlobalState(&tlstate);\n-    }\n-    return &tlstate;\n-#else \/* HAVE_COMPILER_TLS *\/\n-    xmlGlobalState *globalval;\n-    xmlGlobalStateCleanupHelperParams *p;\n-\n-    xmlOnceInit();\n-#if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n-    globalval = (xmlGlobalState *) TlsGetValue(globalkey);\n-#else\n-    p = (xmlGlobalStateCleanupHelperParams *) TlsGetValue(globalkey);\n-    globalval = (xmlGlobalState *) (p ? p->memory : NULL);\n-#endif\n-    if (globalval == NULL) {\n-        xmlGlobalState *tsd = xmlNewGlobalState();\n-\n-        if (tsd == NULL)\n-            return(NULL);\n-        p = (xmlGlobalStateCleanupHelperParams *)\n-            malloc(sizeof(xmlGlobalStateCleanupHelperParams));\n-        if (p == NULL) {\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"xmlGetGlobalState: out of memory\\n\");\n-            xmlFreeGlobalState(tsd);\n-            return(NULL);\n-        }\n-        p->memory = tsd;\n-#if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n-        DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),\n-                        GetCurrentProcess(), &p->thread, 0, TRUE,\n-                        DUPLICATE_SAME_ACCESS);\n-        TlsSetValue(globalkey, tsd);\n-        _beginthread(xmlGlobalStateCleanupHelper, 0, p);\n-#else\n-        EnterCriticalSection(&cleanup_helpers_cs);\n-        if (cleanup_helpers_head != NULL) {\n-            cleanup_helpers_head->prev = p;\n-        }\n-        p->next = cleanup_helpers_head;\n-        p->prev = NULL;\n-        cleanup_helpers_head = p;\n-        TlsSetValue(globalkey, p);\n-        LeaveCriticalSection(&cleanup_helpers_cs);\n-#endif\n-\n-        return (tsd);\n-    }\n-    return (globalval);\n-#endif \/* HAVE_COMPILER_TLS *\/\n-#elif defined HAVE_BEOS_THREADS\n-    xmlGlobalState *globalval;\n-\n-    xmlOnceInit();\n-\n-    if ((globalval = (xmlGlobalState *) tls_get(globalkey)) == NULL) {\n-        xmlGlobalState *tsd = xmlNewGlobalState();\n-        if (tsd == NULL)\n-            return (NULL);\n-\n-        tls_set(globalkey, tsd);\n-        on_exit_thread(xmlGlobalStateCleanup, NULL);\n-        return (tsd);\n-    }\n-    return (globalval);\n-#else\n-    return (NULL);\n@@ -743,0 +363,2 @@\n+ * DEPRECATED: Internal function, do not use.\n+ *\n@@ -752,1 +374,1 @@\n-#ifdef HAVE_PTHREAD_H\n+#ifdef HAVE_POSIX_THREADS\n@@ -756,1 +378,1 @@\n-    if (libxml_is_threaded == 0)\n+    if (XML_IS_THREADED() == 0)\n@@ -764,2 +386,0 @@\n-#elif defined HAVE_BEOS_THREADS\n-    return find_thread(NULL);\n@@ -771,36 +391,0 @@\n-\/**\n- * xmlIsMainThread:\n- *\n- * xmlIsMainThread() check whether the current thread is the main thread.\n- *\n- * Returns 1 if the current thread is the main thread, 0 otherwise\n- *\/\n-int\n-xmlIsMainThread(void)\n-{\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded == -1)\n-        xmlInitThreads();\n-    if (libxml_is_threaded == 0)\n-        return (1);\n-    pthread_once(&once_control, xmlOnceInit);\n-#elif defined HAVE_WIN32_THREADS\n-    xmlOnceInit();\n-#elif defined HAVE_BEOS_THREADS\n-    xmlOnceInit();\n-#endif\n-\n-#ifdef DEBUG_THREADS\n-    xmlGenericError(xmlGenericErrorContext, \"xmlIsMainThread()\\n\");\n-#endif\n-#ifdef HAVE_PTHREAD_H\n-    return (pthread_equal(mainthread,pthread_self()));\n-#elif defined HAVE_WIN32_THREADS\n-    return (mainthread == GetCurrentThreadId());\n-#elif defined HAVE_BEOS_THREADS\n-    return (mainthread == find_thread(NULL));\n-#else\n-    return (1);\n-#endif\n-}\n-\n@@ -816,3 +400,0 @@\n-#ifdef DEBUG_THREADS\n-    xmlGenericError(xmlGenericErrorContext, \"xmlLockLibrary()\\n\");\n-#endif\n@@ -831,3 +412,0 @@\n-#ifdef DEBUG_THREADS\n-    xmlGenericError(xmlGenericErrorContext, \"xmlUnlockLibrary()\\n\");\n-#endif\n@@ -840,5 +418,1 @@\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n- * initialize the library.\n- *\n- * xmlInitThreads() is used to to initialize all the thread related\n- * data of the libxml2 library.\n+ * DEPRECATED: Alias for xmlInitParser.\n@@ -849,1 +423,42 @@\n-#ifdef HAVE_PTHREAD_H\n+    xmlInitParser();\n+}\n+\n+\/**\n+ * xmlCleanupThreads:\n+ *\n+ * DEPRECATED: This function is a no-op. Call xmlCleanupParser\n+ * to free global state but see the warnings there. xmlCleanupParser\n+ * should be only called once at program exit. In most cases, you don't\n+ * have call cleanup functions at all.\n+ *\/\n+void\n+xmlCleanupThreads(void)\n+{\n+}\n+\n+\/************************************************************************\n+ *                                                                      *\n+ *                      Library wide initialization                     *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n+static int xmlParserInitialized = 0;\n+static int xmlParserInnerInitialized = 0;\n+\n+\n+#ifdef HAVE_POSIX_THREADS\n+static pthread_mutex_t global_init_lock = PTHREAD_MUTEX_INITIALIZER;\n+#elif defined HAVE_WIN32_THREADS\n+static volatile LPCRITICAL_SECTION global_init_lock = NULL;\n+#endif\n+\n+\/**\n+ * xmlGlobalInitMutexLock\n+ *\n+ * Makes sure that the global initialization mutex is initialized and\n+ * locks it.\n+ *\/\n+static void\n+xmlGlobalInitMutexLock(void) {\n+#ifdef HAVE_POSIX_THREADS\n+\n@@ -851,6 +466,7 @@\n-    if (libxml_is_threaded == -1) {\n-        if ((pthread_once != NULL) &&\n-            (pthread_getspecific != NULL) &&\n-            (pthread_setspecific != NULL) &&\n-            (pthread_key_create != NULL) &&\n-            (pthread_key_delete != NULL) &&\n+    \/*\n+     * This is somewhat unreliable since libpthread could be loaded\n+     * later with dlopen() and threads could be created. But it's\n+     * long-standing behavior and hard to work around.\n+     *\/\n+    if (libxml_is_threaded == -1)\n+        libxml_is_threaded =\n@@ -864,1 +480,5 @@\n-            (pthread_equal != NULL) &&\n+            \/*\n+             * pthread_equal can be inline, resuting in -Waddress warnings.\n+             * Let's assume it's available if all the other functions are.\n+             *\/\n+            \/* (pthread_equal != NULL) && *\/\n@@ -866,2 +486,2 @@\n-            (pthread_cond_signal != NULL)) {\n-            libxml_is_threaded = 1;\n+            (pthread_cond_signal != NULL);\n+#endif\n@@ -869,2 +489,17 @@\n-\/* fprintf(stderr, \"Running multithreaded\\n\"); *\/\n-        } else {\n+    \/* The mutex is statically initialized, so we just lock it. *\/\n+    if (XML_IS_THREADED() != 0)\n+        pthread_mutex_lock(&global_init_lock);\n+\n+#elif defined HAVE_WIN32_THREADS\n+\n+    LPCRITICAL_SECTION cs;\n+\n+    \/* Create a new critical section *\/\n+    if (global_init_lock == NULL) {\n+        cs = malloc(sizeof(CRITICAL_SECTION));\n+        if (cs == NULL) {\n+            xmlGenericError(xmlGenericErrorContext,\n+                            \"xmlGlobalInitMutexLock: out of memory\\n\");\n+            return;\n+        }\n+        InitializeCriticalSection(cs);\n@@ -872,2 +507,15 @@\n-\/* fprintf(stderr, \"Running without multithread\\n\"); *\/\n-            libxml_is_threaded = 0;\n+        \/* Swap it into the global_init_lock *\/\n+#ifdef InterlockedCompareExchangePointer\n+        InterlockedCompareExchangePointer((void **) &global_init_lock,\n+                                          cs, NULL);\n+#else \/* Use older void* version *\/\n+        InterlockedCompareExchange((void **) &global_init_lock,\n+                                   (void *) cs, NULL);\n+#endif \/* InterlockedCompareExchangePointer *\/\n+\n+        \/* If another thread successfully recorded its critical\n+         * section in the global_init_lock then discard the one\n+         * allocated by this thread. *\/\n+        if (global_init_lock != cs) {\n+            DeleteCriticalSection(cs);\n+            free(cs);\n@@ -876,1 +524,15 @@\n-#endif \/* XML_PTHREAD_WEAK *\/\n+\n+    \/* Lock the chosen critical section *\/\n+    EnterCriticalSection(global_init_lock);\n+\n+#endif\n+}\n+\n+static void\n+xmlGlobalInitMutexUnlock(void) {\n+#ifdef HAVE_POSIX_THREADS\n+    if (XML_IS_THREADED() != 0)\n+        pthread_mutex_unlock(&global_init_lock);\n+#elif defined HAVE_WIN32_THREADS\n+    if (global_init_lock != NULL)\n+        LeaveCriticalSection(global_init_lock);\n@@ -881,1 +543,1 @@\n- * xmlCleanupThreads:\n+ * xmlGlobalInitMutexDestroy\n@@ -883,4 +545,17 @@\n- * DEPRECATED: This function will be made private. Call xmlCleanupParser\n- * to free global state but see the warnings there. xmlCleanupParser\n- * should be only called once at program exit. In most cases, you don't\n- * have call cleanup functions at all.\n+ * Makes sure that the global initialization mutex is destroyed before\n+ * application termination.\n+ *\/\n+static void\n+xmlGlobalInitMutexDestroy(void) {\n+#ifdef HAVE_POSIX_THREADS\n+#elif defined HAVE_WIN32_THREADS\n+    if (global_init_lock != NULL) {\n+        DeleteCriticalSection(global_init_lock);\n+        free(global_init_lock);\n+        global_init_lock = NULL;\n+    }\n+#endif\n+}\n+\n+\/**\n+ * xmlInitParser:\n@@ -888,2 +563,57 @@\n- * xmlCleanupThreads() is used to to cleanup all the thread related\n- * data of the libxml2 library once processing has ended.\n+ * Initialization function for the XML parser.\n+ *\n+ * Call once from the main thread before using the library in\n+ * multithreaded programs.\n+ *\/\n+void\n+xmlInitParser(void) {\n+    \/*\n+     * Note that the initialization code must not make memory allocations.\n+     *\/\n+    if (xmlParserInitialized != 0)\n+        return;\n+\n+    xmlGlobalInitMutexLock();\n+\n+    if (xmlParserInnerInitialized == 0) {\n+#if defined(_WIN32) && \\\n+    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \\\n+    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n+        if (xmlFree == free)\n+            atexit(xmlCleanupParser);\n+#endif\n+\n+        xmlInitMemoryInternal(); \/* Should come second *\/\n+        xmlInitGlobalsInternal();\n+        xmlInitRandom();\n+        xmlInitDictInternal();\n+        xmlInitEncodingInternal();\n+#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+        xmlInitXPathInternal();\n+#endif\n+\n+        xmlRegisterDefaultInputCallbacks();\n+#ifdef LIBXML_OUTPUT_ENABLED\n+        xmlRegisterDefaultOutputCallbacks();\n+#endif \/* LIBXML_OUTPUT_ENABLED *\/\n+\n+        xmlParserInnerInitialized = 1;\n+    }\n+\n+    xmlGlobalInitMutexUnlock();\n+\n+    xmlParserInitialized = 1;\n+}\n+\n+\/**\n+ * xmlCleanupParser:\n+ *\n+ * This function name is somewhat misleading. It does not clean up\n+ * parser state, it cleans up memory allocated by the library itself.\n+ * It is a cleanup function for the XML library. It tries to reclaim all\n+ * related global memory allocated for the library processing.\n+ * It doesn't deallocate any document related memory. One should\n+ * call xmlCleanupParser() only when the process has finished using\n+ * the library and all XML\/HTML documents built with it.\n+ * See also xmlInitParser() which has the opposite function of preparing\n+ * the library for operations.\n@@ -900,38 +630,3 @@\n-xmlCleanupThreads(void)\n-{\n-#ifdef DEBUG_THREADS\n-    xmlGenericError(xmlGenericErrorContext, \"xmlCleanupThreads()\\n\");\n-#endif\n-#ifdef HAVE_PTHREAD_H\n-    if (libxml_is_threaded != 0)\n-        pthread_key_delete(globalkey);\n-    once_control = once_control_init;\n-#elif defined(HAVE_WIN32_THREADS)\n-#if !defined(HAVE_COMPILER_TLS)\n-    if (globalkey != TLS_OUT_OF_INDEXES) {\n-#if !defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL)\n-        xmlGlobalStateCleanupHelperParams *p;\n-\n-        EnterCriticalSection(&cleanup_helpers_cs);\n-        p = cleanup_helpers_head;\n-        while (p != NULL) {\n-            xmlGlobalStateCleanupHelperParams *temp = p;\n-\n-            p = p->next;\n-            xmlFreeGlobalState(temp->memory);\n-            free(temp);\n-        }\n-        cleanup_helpers_head = 0;\n-        LeaveCriticalSection(&cleanup_helpers_cs);\n-#endif\n-        TlsFree(globalkey);\n-        globalkey = TLS_OUT_OF_INDEXES;\n-    }\n-#if !defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL)\n-    DeleteCriticalSection(&cleanup_helpers_cs);\n-#endif\n-#endif\n-    run_once.done = 0;\n-    run_once.control = 0;\n-#endif\n-}\n+xmlCleanupParser(void) {\n+    if (!xmlParserInitialized)\n+        return;\n@@ -939,1 +634,1 @@\n-#ifdef LIBXML_THREAD_ENABLED\n+    \/* These functions can call xmlFree. *\/\n@@ -941,22 +636,3 @@\n-\/**\n- * xmlOnceInit\n- *\n- * xmlOnceInit() is used to initialize the value of mainthread for use\n- * in other routines. This function should only be called using\n- * pthread_once() in association with the once_control variable to ensure\n- * that the function is only called once. See man pthread_once for more\n- * details.\n- *\/\n-static void\n-xmlOnceInit(void)\n-{\n-#ifdef HAVE_PTHREAD_H\n-    (void) pthread_key_create(&globalkey, xmlFreeGlobalState);\n-    mainthread = pthread_self();\n-    __xmlInitializeDict();\n-#elif defined(HAVE_WIN32_THREADS)\n-    if (!run_once.done) {\n-        if (InterlockedIncrement(&run_once.control) == 1) {\n-#if !defined(HAVE_COMPILER_TLS)\n-#if !defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL)\n-            InitializeCriticalSection(&cleanup_helpers_cs);\n+    xmlCleanupCharEncodingHandlers();\n+#ifdef LIBXML_CATALOG_ENABLED\n+    xmlCatalogCleanup();\n@@ -964,1 +640,3 @@\n-            globalkey = TlsAlloc();\n+#ifdef LIBXML_SCHEMAS_ENABLED\n+    xmlSchemaCleanupTypes();\n+    xmlRelaxNGCleanupTypes();\n@@ -966,18 +644,6 @@\n-            mainthread = GetCurrentThreadId();\n-            __xmlInitializeDict();\n-            run_once.done = 1;\n-        } else {\n-            \/* Another thread is working; give up our slice and\n-             * wait until they're done. *\/\n-            while (!run_once.done)\n-                Sleep(0);\n-        }\n-    }\n-#elif defined HAVE_BEOS_THREADS\n-    if (atomic_add(&run_once_init, 1) == 0) {\n-        globalkey = tls_allocate();\n-        tls_set(globalkey, NULL);\n-        mainthread = find_thread(NULL);\n-        __xmlInitializeDict();\n-    } else\n-        atomic_add(&run_once_init, -1);\n+\n+    \/* These functions should never call xmlFree. *\/\n+\n+    xmlCleanupInputCallbacks();\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    xmlCleanupOutputCallbacks();\n@@ -985,0 +651,14 @@\n+\n+    xmlCleanupDictInternal();\n+    xmlCleanupRandom();\n+    xmlCleanupGlobalsInternal();\n+    \/*\n+     * Must come last. On Windows, xmlCleanupGlobalsInternal can call\n+     * xmlFree which uses xmlMemMutex in debug mode.\n+     *\/\n+    xmlCleanupMemoryInternal();\n+\n+    xmlGlobalInitMutexDestroy();\n+\n+    xmlParserInitialized = 0;\n+    xmlParserInnerInitialized = 0;\n@@ -986,1 +666,0 @@\n-#endif\n@@ -988,60 +667,13 @@\n-\/**\n- * DllMain:\n- * @hinstDLL: handle to DLL instance\n- * @fdwReason: Reason code for entry\n- * @lpvReserved: generic pointer (depends upon reason code)\n- *\n- * Entry point for Windows library. It is being used to free thread-specific\n- * storage.\n- *\n- * Returns TRUE always\n- *\/\n-#ifdef HAVE_PTHREAD_H\n-#elif defined(HAVE_WIN32_THREADS) && !defined(HAVE_COMPILER_TLS) && (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n-#if defined(LIBXML_STATIC_FOR_DLL)\n-int XMLCALL\n-xmlDllMain(ATTRIBUTE_UNUSED void *hinstDLL, unsigned long fdwReason,\n-           ATTRIBUTE_UNUSED void *lpvReserved)\n-#else\n-\/* declare to avoid \"no previous prototype for 'DllMain'\" warning *\/\n-\/* Note that we do NOT want to include this function declaration in\n-   a public header because it's meant to be called by Windows itself,\n-   not a program that uses this library.  This also has to be exported. *\/\n-\n-XMLPUBFUN BOOL WINAPI\n-DllMain (HINSTANCE hinstDLL,\n-         DWORD     fdwReason,\n-         LPVOID    lpvReserved);\n-\n-BOOL WINAPI\n-DllMain(ATTRIBUTE_UNUSED HINSTANCE hinstDLL, DWORD fdwReason,\n-        ATTRIBUTE_UNUSED LPVOID lpvReserved)\n-#endif\n-{\n-    switch (fdwReason) {\n-        case DLL_THREAD_DETACH:\n-            if (globalkey != TLS_OUT_OF_INDEXES) {\n-                xmlGlobalState *globalval = NULL;\n-                xmlGlobalStateCleanupHelperParams *p =\n-                    (xmlGlobalStateCleanupHelperParams *)\n-                    TlsGetValue(globalkey);\n-                globalval = (xmlGlobalState *) (p ? p->memory : NULL);\n-                if (globalval) {\n-                    xmlFreeGlobalState(globalval);\n-                    TlsSetValue(globalkey, NULL);\n-                }\n-                if (p) {\n-                    EnterCriticalSection(&cleanup_helpers_cs);\n-                    if (p == cleanup_helpers_head)\n-                        cleanup_helpers_head = p->next;\n-                    else\n-                        p->prev->next = p->next;\n-                    if (p->next != NULL)\n-                        p->next->prev = p->prev;\n-                    LeaveCriticalSection(&cleanup_helpers_cs);\n-                    free(p);\n-                }\n-            }\n-            break;\n-    }\n-    return TRUE;\n+#if defined(HAVE_ATTRIBUTE_DESTRUCTOR) && \\\n+    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \\\n+    !defined(LIBXML_STATIC) && \\\n+    !defined(_WIN32)\n+static void\n+ATTRIBUTE_DESTRUCTOR\n+xmlDestructor(void) {\n+    \/*\n+     * Calling custom deallocation functions in a destructor can cause\n+     * problems, for example with Nokogiri.\n+     *\/\n+    if (xmlFree == free)\n+        xmlCleanupParser();\n@@ -1050,0 +682,1 @@\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/threads.c","additions":334,"deletions":701,"binary":false,"changes":1035,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include <libxml\/xmlmemory.h>\n@@ -33,0 +32,1 @@\n+#include <libxml\/xmlmemory.h>\n@@ -36,1 +36,0 @@\n-#include <libxml\/valid.h>\n@@ -39,1 +38,0 @@\n-#include <libxml\/globals.h>\n@@ -47,2 +45,4 @@\n-#include \"buf.h\"\n-#include \"save.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/entities.h\"\n+#include \"private\/error.h\"\n+#include \"private\/tree.h\"\n@@ -143,3 +143,0 @@\n-\/* #define DEBUG_BUFFER *\/\n-\/* #define DEBUG_TREE *\/\n-\n@@ -358,1 +355,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)\n@@ -430,1 +426,0 @@\n-#endif\n@@ -806,4 +801,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlSetNs: node == NULL\\n\");\n-#endif\n@@ -826,4 +817,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlFreeNs : ns == NULL\\n\");\n-#endif\n@@ -847,4 +834,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlFreeNsList : ns == NULL\\n\");\n-#endif\n@@ -878,6 +861,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewDtd(%s): document %s already have a DTD %s\\n\",\n-            \/* !!! *\/ (char *) name, doc->name,\n-            \/* !!! *\/ (char *)doc->extSubset->name);\n-#endif\n@@ -952,6 +929,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-\n-     \"xmlCreateIntSubset(): document %s already have an internal subset\\n\",\n-            doc->name);\n-#endif\n@@ -1211,4 +1182,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlFreeDoc : document == NULL\\n\");\n-#endif\n@@ -1217,5 +1184,0 @@\n-#ifdef LIBXML_DEBUG_RUNTIME\n-#ifdef LIBXML_DEBUG_ENABLED\n-    xmlDebugCheckDocument(stderr, cur);\n-#endif\n-#endif\n@@ -1417,1 +1379,3 @@\n-                        else if ((ent != NULL) && (ent->children == NULL)) {\n+                        else if ((ent != NULL) &&\n+                                 ((ent->flags & XML_ENT_PARSED) == 0) &&\n+                                 ((ent->flags & XML_ENT_EXPANDING) == 0)) {\n@@ -1420,2 +1384,5 @@\n-                            \/* Set to non-NULL value to avoid recursion. *\/\n-                            ent->children = (xmlNodePtr) -1;\n+                            \/*\n+                             * The entity should have been checked already,\n+                             * but set the flag anyway to avoid recursion.\n+                             *\/\n+                            ent->flags |= XML_ENT_EXPANDING;\n@@ -1425,0 +1392,2 @@\n+                            ent->flags &= ~XML_ENT_EXPANDING;\n+                            ent->flags |= XML_ENT_PARSED;\n@@ -1496,1 +1465,1 @@\n-    xmlNodePtr ret = NULL, last = NULL;\n+    xmlNodePtr ret = NULL, head = NULL, last = NULL;\n@@ -1498,1 +1467,1 @@\n-    xmlChar *val;\n+    xmlChar *val = NULL;\n@@ -1596,2 +1565,1 @@\n-                            if (node == NULL) {\n-                                if (val != NULL) xmlFree(val);\n+                            if (node == NULL)\n@@ -1599,1 +1567,0 @@\n-                            }\n@@ -1603,1 +1570,1 @@\n-                                last = ret = node;\n+                                last = head = node;\n@@ -1613,2 +1580,1 @@\n-                        if (node == NULL) {\n-                            if (val != NULL) xmlFree(val);\n+                        if (node == NULL)\n@@ -1616,2 +1582,3 @@\n-                        }\n-                        else if ((ent != NULL) && (ent->children == NULL)) {\n+                        if ((ent != NULL) &&\n+                            ((ent->flags & XML_ENT_PARSED) == 0) &&\n+                            ((ent->flags & XML_ENT_EXPANDING) == 0)) {\n@@ -1620,2 +1587,5 @@\n-                            \/* Set to non-NULL value to avoid recursion. *\/\n-                            ent->children = (xmlNodePtr) -1;\n+                            \/*\n+                             * The entity should have been checked already,\n+                             * but set the flag anyway to avoid recursion.\n+                             *\/\n+                            ent->flags |= XML_ENT_EXPANDING;\n@@ -1625,0 +1595,2 @@\n+                            ent->flags &= ~XML_ENT_EXPANDING;\n+                            ent->flags |= XML_ENT_PARSED;\n@@ -1633,1 +1605,1 @@\n-                            last = ret = node;\n+                            last = head = node;\n@@ -1639,0 +1611,1 @@\n+                    val = NULL;\n@@ -1657,1 +1630,1 @@\n-    if ((cur != q) || (ret == NULL)) {\n+    if ((cur != q) || (head == NULL)) {\n@@ -1666,4 +1639,2 @@\n-        if (node == NULL) {\n-            xmlBufFree(buf);\n-            return(NULL);\n-        }\n+        if (node == NULL)\n+            goto out;\n@@ -1673,1 +1644,1 @@\n-            ret = node;\n+            head = node;\n@@ -1679,0 +1650,3 @@\n+    ret = head;\n+    head = NULL;\n+\n@@ -1681,0 +1655,2 @@\n+    if (val != NULL) xmlFree(val);\n+    if (head != NULL) xmlFreeNodeList(head);\n@@ -1866,1 +1842,1 @@\n-            ((node->doc == NULL) ||\n+            ((node->doc == NULL) || (node->doc->dict == NULL) ||\n@@ -1879,0 +1855,1 @@\n+             (node->doc->dict == NULL) ||\n@@ -1956,4 +1933,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewProp : name == NULL\\n\");\n-#endif\n@@ -1982,4 +1955,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewNsProp : name == NULL\\n\");\n-#endif\n@@ -2007,4 +1976,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewNsPropEatName : name == NULL\\n\");\n-#endif\n@@ -2036,4 +2001,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewDocProp : name == NULL\\n\");\n-#endif\n@@ -2134,4 +2095,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlRemoveProp : cur == NULL\\n\");\n-#endif\n@@ -2141,4 +2098,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlRemoveProp : cur->parent == NULL\\n\");\n-#endif\n@@ -2165,4 +2118,0 @@\n-#ifdef DEBUG_TREE\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"xmlRemoveProp : attribute not owned by its node\\n\");\n-#endif\n@@ -2186,4 +2135,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewPI : name == NULL\\n\");\n-#endif\n@@ -2251,4 +2196,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewNode : name == NULL\\n\");\n-#endif\n@@ -2295,4 +2236,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewNode : name == NULL\\n\");\n-#endif\n@@ -2389,2 +2326,3 @@\n-        if ((name != NULL) && (doc != NULL) &&\n-            (!(xmlDictOwns(doc->dict, name))))\n+        if ((name != NULL) &&\n+            ((doc == NULL) || (doc->dict == NULL) ||\n+             (!(xmlDictOwns(doc->dict, name)))))\n@@ -2516,4 +2454,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewTextChild : parent == NULL\\n\");\n-#endif\n@@ -2524,4 +2458,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewTextChild : name == NULL\\n\");\n-#endif\n@@ -2951,4 +2881,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewChild : parent == NULL\\n\");\n-#endif\n@@ -2959,4 +2885,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewChild : name == NULL\\n\");\n-#endif\n@@ -3079,4 +3001,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddNextSibling : cur == NULL\\n\");\n-#endif\n@@ -3086,4 +3004,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddNextSibling : elem == NULL\\n\");\n-#endif\n@@ -3094,4 +3008,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddNextSibling : cur == elem\\n\");\n-#endif\n@@ -3159,4 +3069,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddPrevSibling : cur == NULL\\n\");\n-#endif\n@@ -3166,4 +3072,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddPrevSibling : elem == NULL\\n\");\n-#endif\n@@ -3174,4 +3076,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddPrevSibling : cur == elem\\n\");\n-#endif\n@@ -3239,4 +3137,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddSibling : cur == NULL\\n\");\n-#endif\n@@ -3247,4 +3141,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddSibling : elem == NULL\\n\");\n-#endif\n@@ -3255,4 +3145,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddSibling : cur == elem\\n\");\n-#endif\n@@ -3317,4 +3203,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddChildList : parent == NULL\\n\");\n-#endif\n@@ -3325,4 +3207,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddChildList : child == NULL\\n\");\n-#endif\n@@ -3334,4 +3212,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"Elements moved to a different document\\n\");\n-#endif\n@@ -3409,4 +3283,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddChild : parent == NULL\\n\");\n-#endif\n@@ -3417,4 +3287,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddChild : child == NULL\\n\");\n-#endif\n@@ -3425,4 +3291,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlAddChild : parent == cur\\n\");\n-#endif\n@@ -3531,4 +3393,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlGetLastChild : parent == NULL\\n\");\n-#endif\n@@ -3899,4 +3757,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlUnlinkNode : node == NULL\\n\");\n-#endif\n@@ -3979,4 +3833,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlReplaceNode : old == NULL or without parent\\n\");\n-#endif\n@@ -3993,4 +3843,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlReplaceNode : Trying to replace attribute node with other node type\\n\");\n-#endif\n@@ -4000,4 +3846,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlReplaceNode : Trying to replace a non-attribute node with attribute node\\n\");\n-#endif\n@@ -4056,4 +3898,0 @@\n-#ifdef DEBUG_TREE\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"xmlCopyNamespace: invalid type %d\\n\", cur->type);\n-#endif\n@@ -4080,0 +3918,4 @@\n+        if (q == NULL) {\n+            xmlFreeNsList(ret);\n+            return(NULL);\n+        }\n@@ -4091,3 +3933,0 @@\n-static xmlNodePtr\n-xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent);\n-\n@@ -4224,1 +4063,2 @@\n-        if (q == NULL)\n+        if (q == NULL) {\n+            xmlFreePropList(ret);\n@@ -4226,0 +4066,1 @@\n+        }\n@@ -4257,1 +4098,1 @@\n-static xmlNodePtr\n+xmlNodePtr\n@@ -4368,1 +4209,4 @@\n-             * and add it at the top of the new tree\n+             * and add it at the top of the new tree.\n+             *\n+             * TODO: Searching the original tree seems unnecessary. We\n+             * already have a namespace URI.\n@@ -4376,2 +4220,2 @@\n-                } else {\n-                        ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n+            } else {\n+                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n@@ -4456,1 +4300,1 @@\n-static xmlNodePtr\n+xmlNodePtr\n@@ -4460,0 +4304,2 @@\n+    xmlDtdPtr newSubset = NULL;\n+    int linkedSubset = 0;\n@@ -4468,1 +4314,1 @@\n-            if (doc->intSubset == NULL) {\n+            if ((doc->intSubset == NULL) && (newSubset == NULL)) {\n@@ -4470,1 +4316,1 @@\n-                if (q == NULL) return(NULL);\n+                if (q == NULL) goto error;\n@@ -4473,1 +4319,1 @@\n-                doc->intSubset = (xmlDtdPtr) q;\n+                newSubset = (xmlDtdPtr) q;\n@@ -4476,0 +4322,1 @@\n+                linkedSubset = 1;\n@@ -4482,1 +4329,1 @@\n-        if (q == NULL) return(NULL);\n+        if (q == NULL) goto error;\n@@ -4494,0 +4341,2 @@\n+    if ((doc != NULL) && (newSubset != NULL))\n+        doc->intSubset = newSubset;\n@@ -4495,0 +4344,5 @@\n+error:\n+    if (linkedSubset != 0)\n+        xmlUnlinkNode((xmlNodePtr) doc->intSubset);\n+    xmlFreeNodeList(ret);\n+    return(NULL);\n@@ -4811,1 +4665,1 @@\n-    buffer = (xmlChar *) xmlMallocAtomic(buf_len * sizeof(xmlChar));\n+    buffer = (xmlChar *) xmlMallocAtomic(buf_len);\n@@ -4816,1 +4670,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(buf_len * sizeof(xmlChar));\n+    buf = (xmlChar *) xmlMallocAtomic(buf_len);\n@@ -5755,4 +5609,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNodeSetContent : node == NULL\\n\");\n-#endif\n@@ -5828,4 +5678,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNodeSetContentLen : node == NULL\\n\");\n-#endif\n@@ -5898,4 +5744,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNodeAddContentLen : node == NULL\\n\");\n-#endif\n@@ -5972,4 +5814,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNodeAddContent : node == NULL\\n\");\n-#endif\n@@ -6022,1 +5860,1 @@\n-    int maxns = 10;\n+    int maxns = 0;\n@@ -6032,10 +5870,0 @@\n-                if (ret == NULL) {\n-                    ret =\n-                        (xmlNsPtr *) xmlMalloc((maxns + 1) *\n-                                               sizeof(xmlNsPtr));\n-                    if (ret == NULL) {\n-                        xmlTreeErrMemory(\"getting namespace list\");\n-                        return (NULL);\n-                    }\n-                    ret[nbns] = NULL;\n-                }\n@@ -6049,4 +5877,5 @@\n-                        maxns *= 2;\n-                        ret = (xmlNsPtr *) xmlRealloc(ret,\n-                                                      (maxns +\n-                                                       1) *\n+                        xmlNsPtr *tmp;\n+\n+                        maxns = maxns ? maxns * 2 : 10;\n+                        tmp = (xmlNsPtr *) xmlRealloc(ret,\n+                                                      (maxns + 1) *\n@@ -6054,1 +5883,1 @@\n-                        if (ret == NULL) {\n+                        if (tmp == NULL) {\n@@ -6056,0 +5885,1 @@\n+                            xmlFree(ret);\n@@ -6058,0 +5888,1 @@\n+                        ret = tmp;\n@@ -6348,4 +6179,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewReconciledNs : tree == NULL\\n\");\n-#endif\n@@ -6355,4 +6182,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlNewReconciledNs : ns == NULL\\n\");\n-#endif\n@@ -7105,4 +6928,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlTextConcat: node is not text nor CDATA\\n\");\n-#endif\n@@ -7149,1 +6968,1 @@\n-    ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));\n+    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n@@ -7182,1 +7001,1 @@\n-        ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));\n+        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n@@ -7211,2 +7030,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)\n-        return(NULL);\n@@ -7228,5 +7045,1 @@\n- * routine to create an XML buffer from an immutable memory area.\n- * The area won't be modified nor copied, and is expected to be\n- * present until the end of the buffer lifetime.\n- *\n- * returns the new structure.\n+ * Returns an XML buffer initialized with bytes.\n@@ -7236,1 +7049,1 @@\n-    xmlBufferPtr ret;\n+    xmlBufferPtr buf = xmlBufferCreateSize(size);\n@@ -7238,15 +7051,2 @@\n-    if ((mem == NULL) || (size == 0))\n-        return(NULL);\n-    if (size > UINT_MAX)\n-        return(NULL);\n-\n-    ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));\n-    if (ret == NULL) {\n-        xmlTreeErrMemory(\"creating buffer\");\n-        return(NULL);\n-    }\n-    ret->use = size;\n-    ret->size = size;\n-    ret->alloc = XML_BUFFER_ALLOC_IMMUTABLE;\n-    ret->content = (xmlChar *) mem;\n-    return(ret);\n+    xmlBufferAdd(buf, mem, size);\n+    return(buf);\n@@ -7266,4 +7066,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferSetAllocationScheme: buf == NULL\\n\");\n-#endif\n@@ -7272,2 +7068,1 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||\n-        (buf->alloc == XML_BUFFER_ALLOC_IO)) return;\n+    if (buf->alloc == XML_BUFFER_ALLOC_IO) return;\n@@ -7276,2 +7071,1 @@\n-        (scheme == XML_BUFFER_ALLOC_HYBRID) ||\n-        (scheme == XML_BUFFER_ALLOC_IMMUTABLE))\n+        (scheme == XML_BUFFER_ALLOC_HYBRID))\n@@ -7291,4 +7085,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferFree: buf == NULL\\n\");\n-#endif\n@@ -7301,2 +7091,1 @@\n-    } else if ((buf->content != NULL) &&\n-        (buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)) {\n+    } else if (buf->content != NULL) {\n@@ -7319,4 +7108,1 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) {\n-        buf->content = BAD_CAST \"\";\n-    } else if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n-               (buf->contentIO != NULL)) {\n+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n@@ -7349,2 +7135,1 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||\n-        ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL))) {\n+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n@@ -7394,1 +7179,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);\n@@ -7444,4 +7228,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferDump: buf == NULL\\n\");\n-#endif\n@@ -7451,4 +7231,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferDump: buf->content == NULL\\n\");\n-#endif\n@@ -7459,2 +7235,2 @@\n-    ret = fwrite(buf->content, sizeof(xmlChar), buf->use, file);\n-    return(ret > INT_MAX ? INT_MAX : (int)ret);\n+    ret = fwrite(buf->content, 1, buf->use, file);\n+    return(ret > INT_MAX ? INT_MAX : ret);\n@@ -7518,2 +7294,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);\n-\n@@ -7637,1 +7411,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n@@ -7639,4 +7412,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferAdd: len < 0\\n\");\n-#endif\n@@ -7666,1 +7435,1 @@\n-    memmove(&buf->content[buf->use], str, len*sizeof(xmlChar));\n+    memmove(&buf->content[buf->use], str, len);\n@@ -7690,1 +7459,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n@@ -7692,4 +7460,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferAddHead: str == NULL\\n\");\n-#endif\n@@ -7699,4 +7463,0 @@\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferAddHead: len < 0\\n\");\n-#endif\n@@ -7761,1 +7521,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n@@ -7793,1 +7552,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;\n@@ -7809,1 +7567,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;\n@@ -7828,1 +7585,0 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;\n@@ -7831,4 +7587,0 @@\n-#ifdef DEBUG_BUFFER\n-            xmlGenericError(xmlGenericErrorContext,\n- \"xmlBufferWriteQuotedString: string contains quote and double-quotes !\\n\");\n-#endif\n@@ -10251,0 +10003,87 @@\n+\/************************************************************************\n+ *                                                                      *\n+ *                      XHTML detection                                 *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n+#define XHTML_STRICT_PUBLIC_ID BAD_CAST \\\n+   \"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\"\n+#define XHTML_STRICT_SYSTEM_ID BAD_CAST \\\n+   \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-strict.dtd\"\n+#define XHTML_FRAME_PUBLIC_ID BAD_CAST \\\n+   \"-\/\/W3C\/\/DTD XHTML 1.0 Frameset\/\/EN\"\n+#define XHTML_FRAME_SYSTEM_ID BAD_CAST \\\n+   \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-frameset.dtd\"\n+#define XHTML_TRANS_PUBLIC_ID BAD_CAST \\\n+   \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\"\n+#define XHTML_TRANS_SYSTEM_ID BAD_CAST \\\n+   \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\"\n+\n+\/**\n+ * xmlIsXHTML:\n+ * @systemID:  the system identifier\n+ * @publicID:  the public identifier\n+ *\n+ * Try to find if the document correspond to an XHTML DTD\n+ *\n+ * Returns 1 if true, 0 if not and -1 in case of error\n+ *\/\n+int\n+xmlIsXHTML(const xmlChar *systemID, const xmlChar *publicID) {\n+    if ((systemID == NULL) && (publicID == NULL))\n+        return(-1);\n+    if (publicID != NULL) {\n+        if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);\n+    }\n+    if (systemID != NULL) {\n+        if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);\n+    }\n+    return(0);\n+}\n+\n+\/************************************************************************\n+ *                                                                      *\n+ *                      Node callbacks                                  *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n+\/**\n+ * xmlRegisterNodeDefault:\n+ * @func: function pointer to the new RegisterNodeFunc\n+ *\n+ * Registers a callback for node creation\n+ *\n+ * Returns the old value of the registration function\n+ *\/\n+xmlRegisterNodeFunc\n+xmlRegisterNodeDefault(xmlRegisterNodeFunc func)\n+{\n+    xmlRegisterNodeFunc old = xmlRegisterNodeDefaultValue;\n+\n+    __xmlRegisterCallbacks = 1;\n+    xmlRegisterNodeDefaultValue = func;\n+    return(old);\n+}\n+\n+\/**\n+ * xmlDeregisterNodeDefault:\n+ * @func: function pointer to the new DeregisterNodeFunc\n+ *\n+ * Registers a callback for node destruction\n+ *\n+ * Returns the previous value of the deregistration function\n+ *\/\n+xmlDeregisterNodeFunc\n+xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func)\n+{\n+    xmlDeregisterNodeFunc old = xmlDeregisterNodeDefaultValue;\n+\n+    __xmlRegisterCallbacks = 1;\n+    xmlDeregisterNodeDefaultValue = func;\n+    return(old);\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/tree.c","additions":187,"deletions":348,"binary":false,"changes":535,"status":"modified"},{"patch":"@@ -19,1 +19,0 @@\n-#include <libxml\/globals.h>\n@@ -22,0 +21,2 @@\n+#include \"private\/error.h\"\n+\n@@ -36,0 +37,3 @@\n+#define PORT_EMPTY           0\n+#define PORT_EMPTY_SERVER   -1\n+\n@@ -771,2 +775,5 @@\n-        if (uri->server == NULL)\n-            uri->port = -1;\n+        \/*\n+         * An empty server is marked with a special URI value.\n+         *\/\n+        if ((uri->server == NULL) && (uri->port == PORT_EMPTY))\n+            uri->port = PORT_EMPTY_SERVER;\n@@ -1029,0 +1036,1 @@\n+    ret->port = PORT_EMPTY;\n@@ -1077,1 +1085,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic((max + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMallocAtomic(max + 1);\n@@ -1120,1 +1128,1 @@\n-        if ((uri->server != NULL) || (uri->port == -1)) {\n+        if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {\n@@ -1165,1 +1173,2 @@\n-                    ret[len++] = *p++;\n+                    \/* TODO: escaping? *\/\n+                    ret[len++] = (xmlChar) *p++;\n@@ -1167,7 +1176,6 @@\n-                if (uri->port > 0) {\n-                    if (len + 10 >= max) {\n-                        temp = xmlSaveUriRealloc(ret, &max);\n-                        if (temp == NULL) goto mem_error;\n-                        ret = temp;\n-                    }\n-                    len += snprintf((char *) &ret[len], max - len, \":%d\", uri->port);\n+            }\n+            if (uri->port > 0) {\n+                if (len + 10 >= max) {\n+                    temp = xmlSaveUriRealloc(ret, &max);\n+                    if (temp == NULL) goto mem_error;\n+                    ret = temp;\n@@ -1175,0 +1183,1 @@\n+                len += snprintf((char *) &ret[len], max - len, \":%d\", uri->port);\n@@ -1658,0 +1667,1 @@\n+            \/* Explicit sign change *\/\n@@ -1673,2 +1683,2 @@\n- * This routine escapes a string to hex, ignoring reserved characters (a-z)\n- * and the characters in the exception list.\n+ * This routine escapes a string to hex, ignoring reserved characters\n+ * (a-z, A-Z, 0-9, \"@-_.!~*'()\") and the characters in the exception list.\n@@ -1820,2 +1830,2 @@\n-    if (uri->port) {\n-        xmlChar port[10];\n+    if (uri->port > 0) {\n+        xmlChar port[11];\n@@ -1823,1 +1833,1 @@\n-        snprintf((char *) port, 10, \"%d\", uri->port);\n+        snprintf((char *) port, 11, \"%d\", uri->port);\n@@ -1969,1 +1979,2 @@\n-        ((ref->authority == NULL) && (ref->server == NULL))) {\n+        ((ref->authority == NULL) && (ref->server == NULL) &&\n+         (ref->port == PORT_EMPTY))) {\n@@ -1974,1 +1985,1 @@\n-        else if ((bas->server != NULL) || (bas->port == -1)) {\n+        else {\n@@ -2023,1 +2034,2 @@\n-    if ((ref->authority != NULL) || (ref->server != NULL)) {\n+    if ((ref->authority != NULL) || (ref->server != NULL) ||\n+         (ref->port != PORT_EMPTY)) {\n@@ -2027,1 +2039,2 @@\n-            res->server = xmlMemStrdup(ref->server);\n+            if (ref->server != NULL)\n+                res->server = xmlMemStrdup(ref->server);\n@@ -2038,1 +2051,1 @@\n-    else if ((bas->server != NULL) || (bas->port == -1)) {\n+    else if ((bas->server != NULL) || (bas->port != PORT_EMPTY)) {\n@@ -2108,1 +2121,1 @@\n-        if ((out == 0) && (bas->server != NULL))\n+        if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))\n@@ -2226,1 +2239,2 @@\n-         (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)))) {\n+         (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)) ||\n+         (bas->port != ref->port))) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/uri.c","additions":39,"deletions":25,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include <libxml\/globals.h>\n@@ -26,4 +25,6 @@\n-static xmlElementPtr xmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name,\n-                                   int create);\n-\/* #define DEBUG_VALID_ALGO *\/\n-\/* #define DEBUG_REGEXP_ALGO *\/\n+#include \"private\/error.h\"\n+#include \"private\/parser.h\"\n+\n+static xmlElementPtr\n+xmlGetDtdElementDesc2(xmlValidCtxtPtr ctxt, xmlDtdPtr dtd, const xmlChar *name,\n+                      int create);\n@@ -67,3 +68,1 @@\n-            long delta = (char *) ctxt - (char *) ctxt->userData;\n-            if ((delta > 0) && (delta < 250))\n-                pctxt = ctxt->userData;\n+            pctxt = ctxt->userData;\n@@ -106,3 +105,1 @@\n-            long delta = (char *) ctxt - (char *) ctxt->userData;\n-            if ((delta > 0) && (delta < 250))\n-                pctxt = ctxt->userData;\n+            pctxt = ctxt->userData;\n@@ -152,3 +149,1 @@\n-            long delta = (char *) ctxt - (char *) ctxt->userData;\n-            if ((delta > 0) && (delta < 250))\n-                pctxt = ctxt->userData;\n+            pctxt = ctxt->userData;\n@@ -194,3 +189,1 @@\n-            long delta = (char *) ctxt - (char *) ctxt->userData;\n-            if ((delta > 0) && (delta < 250))\n-                pctxt = ctxt->userData;\n+            pctxt = ctxt->userData;\n@@ -234,3 +227,1 @@\n-            long delta = (char *) ctxt - (char *) ctxt->userData;\n-            if ((delta > 0) && (delta < 250))\n-                pctxt = ctxt->userData;\n+            pctxt = ctxt->userData;\n@@ -474,145 +465,0 @@\n-#ifdef DEBUG_VALID_ALGO\n-static void\n-xmlValidPrintNode(xmlNodePtr cur) {\n-    if (cur == NULL) {\n-        xmlGenericError(xmlGenericErrorContext, \"null\");\n-        return;\n-    }\n-    switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"%s \", cur->name);\n-            break;\n-        case XML_TEXT_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"text \");\n-            break;\n-        case XML_CDATA_SECTION_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"cdata \");\n-            break;\n-        case XML_ENTITY_REF_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"&%s; \", cur->name);\n-            break;\n-        case XML_PI_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"pi(%s) \", cur->name);\n-            break;\n-        case XML_COMMENT_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"comment \");\n-            break;\n-        case XML_ATTRIBUTE_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?attr? \");\n-            break;\n-        case XML_ENTITY_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?ent? \");\n-            break;\n-        case XML_DOCUMENT_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?doc? \");\n-            break;\n-        case XML_DOCUMENT_TYPE_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?doctype? \");\n-            break;\n-        case XML_DOCUMENT_FRAG_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?frag? \");\n-            break;\n-        case XML_NOTATION_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?nota? \");\n-            break;\n-        case XML_HTML_DOCUMENT_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?html? \");\n-            break;\n-        case XML_DTD_NODE:\n-            xmlGenericError(xmlGenericErrorContext, \"?dtd? \");\n-            break;\n-        case XML_ELEMENT_DECL:\n-            xmlGenericError(xmlGenericErrorContext, \"?edecl? \");\n-            break;\n-        case XML_ATTRIBUTE_DECL:\n-            xmlGenericError(xmlGenericErrorContext, \"?adecl? \");\n-            break;\n-        case XML_ENTITY_DECL:\n-            xmlGenericError(xmlGenericErrorContext, \"?entdecl? \");\n-            break;\n-        case XML_NAMESPACE_DECL:\n-            xmlGenericError(xmlGenericErrorContext, \"?nsdecl? \");\n-            break;\n-        case XML_XINCLUDE_START:\n-            xmlGenericError(xmlGenericErrorContext, \"incstart \");\n-            break;\n-        case XML_XINCLUDE_END:\n-            xmlGenericError(xmlGenericErrorContext, \"incend \");\n-            break;\n-    }\n-}\n-\n-static void\n-xmlValidPrintNodeList(xmlNodePtr cur) {\n-    if (cur == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"null \");\n-    while (cur != NULL) {\n-        xmlValidPrintNode(cur);\n-        cur = cur->next;\n-    }\n-}\n-\n-static void\n-xmlValidDebug(xmlNodePtr cur, xmlElementContentPtr cont) {\n-    char expr[5000];\n-\n-    expr[0] = 0;\n-    xmlGenericError(xmlGenericErrorContext, \"valid: \");\n-    xmlValidPrintNodeList(cur);\n-    xmlGenericError(xmlGenericErrorContext, \"against \");\n-    xmlSnprintfElementContent(expr, 5000, cont, 1);\n-    xmlGenericError(xmlGenericErrorContext, \"%s\\n\", expr);\n-}\n-\n-static void\n-xmlValidDebugState(xmlValidStatePtr state) {\n-    xmlGenericError(xmlGenericErrorContext, \"(\");\n-    if (state->cont == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"null,\");\n-    else\n-        switch (state->cont->type) {\n-            case XML_ELEMENT_CONTENT_PCDATA:\n-                xmlGenericError(xmlGenericErrorContext, \"pcdata,\");\n-                break;\n-            case XML_ELEMENT_CONTENT_ELEMENT:\n-                xmlGenericError(xmlGenericErrorContext, \"%s,\",\n-                                state->cont->name);\n-                break;\n-            case XML_ELEMENT_CONTENT_SEQ:\n-                xmlGenericError(xmlGenericErrorContext, \"seq,\");\n-                break;\n-            case XML_ELEMENT_CONTENT_OR:\n-                xmlGenericError(xmlGenericErrorContext, \"or,\");\n-                break;\n-        }\n-    xmlValidPrintNode(state->node);\n-    xmlGenericError(xmlGenericErrorContext, \",%d,%X,%d)\",\n-            state->depth, state->occurs, state->state);\n-}\n-\n-static void\n-xmlValidStateDebug(xmlValidCtxtPtr ctxt) {\n-    int i, j;\n-\n-    xmlGenericError(xmlGenericErrorContext, \"state: \");\n-    xmlValidDebugState(ctxt->vstate);\n-    xmlGenericError(xmlGenericErrorContext, \" stack: %d \",\n-            ctxt->vstateNr - 1);\n-    for (i = 0, j = ctxt->vstateNr - 1;(i < 3) && (j > 0);i++,j--)\n-        xmlValidDebugState(&ctxt->vstateTab[j]);\n-    xmlGenericError(xmlGenericErrorContext, \"\\n\");\n-}\n-\n-\/*****\n-#define DEBUG_VALID_STATE(n,c) xmlValidDebug(n,c);\n- *****\/\n-\n-#define DEBUG_VALID_STATE(n,c) xmlValidStateDebug(ctxt);\n-#define DEBUG_VALID_MSG(m)                                      \\\n-    xmlGenericError(xmlGenericErrorContext, \"%s\\n\", m);\n-\n-#else\n-#define DEBUG_VALID_STATE(n,c)\n-#define DEBUG_VALID_MSG(m)\n-#endif\n-\n@@ -835,1 +681,1 @@\n-               \"Content model of %s is not determinist: %s\\n\",\n+               \"Content model of %s is not deterministic: %s\\n\",\n@@ -837,3 +683,0 @@\n-#ifdef DEBUG_REGEXP_ALGO\n-        xmlRegexpPrint(stderr, elem->contModel);\n-#endif\n@@ -888,0 +731,2 @@\n+    if (cur == NULL)\n+        return;\n@@ -1059,1 +904,1 @@\n-                tmp->c1->parent = ret;\n+                tmp->c1->parent = tmp;\n@@ -2123,1 +1968,1 @@\n-    elemDef = xmlGetDtdElementDesc2(dtd, elem, 1);\n+    elemDef = xmlGetDtdElementDesc2(ctxt, dtd, elem, 1);\n@@ -3287,1 +3132,2 @@\n-xmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name, int create) {\n+xmlGetDtdElementDesc2(xmlValidCtxtPtr ctxt, xmlDtdPtr dtd, const xmlChar *name,\n+                      int create) {\n@@ -3310,1 +3156,1 @@\n-            xmlVErrMemory(NULL, \"element table allocation failed\");\n+            xmlVErrMemory(ctxt, \"element table allocation failed\");\n@@ -3323,2 +3169,2 @@\n-            xmlVErrMemory(NULL, \"malloc failed\");\n-            return(NULL);\n+            xmlVErrMemory(ctxt, \"malloc failed\");\n+            goto error;\n@@ -3336,1 +3182,5 @@\n-        xmlHashAddEntry2(table, name, prefix, cur);\n+        if (xmlHashAddEntry2(table, name, prefix, cur) < 0) {\n+            xmlVErrMemory(ctxt, \"adding entry failed\");\n+            xmlFreeElement(cur);\n+            cur = NULL;\n+        }\n@@ -3338,0 +3188,1 @@\n+error:\n@@ -4893,2 +4744,0 @@\n-        DEBUG_VALID_MSG(\"restored parent branch\");\n-        DEBUG_VALID_STATE(NODE, CONT)\n@@ -4899,1 +4748,0 @@\n-    DEBUG_VALID_STATE(NODE, CONT)\n@@ -4906,0 +4754,1 @@\n+         (CONT->parent == (xmlElementContentPtr) 1) ||\n@@ -4910,1 +4759,0 @@\n-        DEBUG_VALID_MSG(\"saving parent branch\");\n@@ -4922,1 +4770,0 @@\n-                DEBUG_VALID_MSG(\"pcdata failed no node\");\n@@ -4927,1 +4774,0 @@\n-                DEBUG_VALID_MSG(\"pcdata found, skip to next\");\n@@ -4945,1 +4791,0 @@\n-                DEBUG_VALID_MSG(\"pcdata failed\");\n@@ -4952,1 +4797,0 @@\n-                DEBUG_VALID_MSG(\"element failed no node\");\n@@ -4968,1 +4812,0 @@\n-                DEBUG_VALID_MSG(\"element found, skip to next\");\n@@ -4984,1 +4827,0 @@\n-                DEBUG_VALID_MSG(\"element failed\");\n@@ -5017,2 +4859,1 @@\n-            DEBUG_VALID_MSG(\"saving 'or' branch\");\n-            if (vstateVPush(ctxt, CONT->c2, NODE, (unsigned char)(DEPTH + 1),\n+            if (vstateVPush(ctxt, CONT->c2, NODE, DEPTH + 1,\n@@ -5059,1 +4900,0 @@\n-        DEBUG_VALID_MSG(\"error found returning\");\n@@ -5074,1 +4914,0 @@\n-                    DEBUG_VALID_MSG(\"Once branch failed, rollback\");\n@@ -5076,1 +4915,0 @@\n-                        DEBUG_VALID_MSG(\"exhaustion, failed\");\n@@ -5085,1 +4923,0 @@\n-                        DEBUG_VALID_MSG(\"Plus branch failed, rollback\");\n@@ -5087,1 +4924,0 @@\n-                            DEBUG_VALID_MSG(\"exhaustion, failed\");\n@@ -5094,1 +4930,0 @@\n-                    DEBUG_VALID_MSG(\"Plus branch found\");\n@@ -5098,7 +4933,0 @@\n-#ifdef DEBUG_VALID_ALGO\n-                    if (OCCURRENCE == 0) {\n-                        DEBUG_VALID_MSG(\"Mult branch failed\");\n-                    } else {\n-                        DEBUG_VALID_MSG(\"Mult branch found\");\n-                    }\n-#endif\n@@ -5108,1 +4936,0 @@\n-                    DEBUG_VALID_MSG(\"Option branch failed\");\n@@ -5115,1 +4942,0 @@\n-                    DEBUG_VALID_MSG(\"Option branch succeeded\");\n@@ -5119,1 +4945,0 @@\n-                    DEBUG_VALID_MSG(\"Once branch succeeded\");\n@@ -5124,1 +4949,0 @@\n-                        DEBUG_VALID_MSG(\"Plus branch rollback\");\n@@ -5129,1 +4953,0 @@\n-                        DEBUG_VALID_MSG(\"Plus branch exhausted\");\n@@ -5133,1 +4956,0 @@\n-                    DEBUG_VALID_MSG(\"Plus branch succeeded, continuing\");\n@@ -5138,1 +4960,0 @@\n-                        DEBUG_VALID_MSG(\"Mult branch rollback\");\n@@ -5143,1 +4964,0 @@\n-                        DEBUG_VALID_MSG(\"Mult branch exhausted\");\n@@ -5147,1 +4967,0 @@\n-                    DEBUG_VALID_MSG(\"Mult branch succeeded, continuing\");\n@@ -5158,1 +4977,2 @@\n-        if (CONT->parent == NULL)\n+        if ((CONT->parent == NULL) ||\n+            (CONT->parent == (xmlElementContentPtr) 1))\n@@ -5163,1 +4983,0 @@\n-                DEBUG_VALID_MSG(\"Error: parent pcdata\");\n@@ -5166,1 +4985,0 @@\n-                DEBUG_VALID_MSG(\"Error: parent element\");\n@@ -5170,1 +4988,0 @@\n-                    DEBUG_VALID_MSG(\"Or succeeded\");\n@@ -5174,1 +4991,0 @@\n-                    DEBUG_VALID_MSG(\"Or failed\");\n@@ -5181,1 +4997,0 @@\n-                    DEBUG_VALID_MSG(\"Sequence failed\");\n@@ -5185,1 +5000,0 @@\n-                    DEBUG_VALID_MSG(\"Sequence testing 2nd branch\");\n@@ -5189,1 +5003,0 @@\n-                    DEBUG_VALID_MSG(\"Sequence succeeded\");\n@@ -5199,1 +5012,0 @@\n-        DEBUG_VALID_MSG(\"Failed, remaining input, rollback\");\n@@ -5201,1 +5013,0 @@\n-            DEBUG_VALID_MSG(\"exhaustion, failed\");\n@@ -5212,1 +5023,0 @@\n-        DEBUG_VALID_MSG(\"Failure, rollback\");\n@@ -5214,1 +5024,0 @@\n-            DEBUG_VALID_MSG(\"exhaustion, failed\");\n@@ -5440,3 +5249,7 @@\n-        xmlErrValidWarning(ctxt, child, XML_DTD_CONTENT_NOT_DETERMINIST,\n-               \"Content model for Element %s is ambiguous\\n\",\n-                           name, NULL, NULL);\n+        char expr[5000];\n+        expr[0] = 0;\n+        xmlSnprintfElementContent(expr, 5000, elemDecl->content, 1);\n+        xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n+                XML_DTD_CONTENT_NOT_DETERMINIST,\n+                \"Content model of %s is not deterministic: %s\\n\",\n+                name, BAD_CAST expr, NULL);\n@@ -5449,1 +5262,0 @@\n-        DEBUG_VALID_MSG(\"Found an entity reference, linearizing\");\n@@ -5663,0 +5475,1 @@\n+#ifdef LIBXML_REGEXP_ENABLED\n@@ -5728,0 +5541,1 @@\n+#endif \/* LIBXML_REGEXP_ENABLED *\/\n@@ -5992,1 +5806,1 @@\n-                    if (ret == 0) {\n+                    if (ret <= 0) {\n@@ -5995,1 +5809,1 @@\n-           \"Element %s content does not follow the DTD, Expecting more child\\n\",\n+           \"Element %s content does not follow the DTD, Expecting more children\\n\",\n@@ -5997,0 +5811,1 @@\n+                        ret = 0;\n@@ -6452,1 +6267,1 @@\n- * @elem:  an element instance\n+ * @root:  an element instance\n@@ -6460,2 +6275,2 @@\n-xmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem) {\n-    xmlNodePtr child;\n+xmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr root) {\n+    xmlNodePtr elem;\n@@ -6467,10 +6282,1 @@\n-    if (elem == NULL) return(0);\n-\n-    \/*\n-     * XInclude elements were added after parsing in the infoset,\n-     * they don't really mean anything validation wise.\n-     *\/\n-    if ((elem->type == XML_XINCLUDE_START) ||\n-        (elem->type == XML_XINCLUDE_END) ||\n-        (elem->type == XML_NAMESPACE_DECL))\n-        return(1);\n+    if (root == NULL) return(0);\n@@ -6480,6 +6286,13 @@\n-    \/*\n-     * Entities references have to be handled separately\n-     *\/\n-    if (elem->type == XML_ENTITY_REF_NODE) {\n-        return(1);\n-    }\n+    elem = root;\n+    while (1) {\n+        ret &= xmlValidateOneElement(ctxt, doc, elem);\n+\n+        if (elem->type == XML_ELEMENT_NODE) {\n+            attr = elem->properties;\n+            while (attr != NULL) {\n+                value = xmlNodeListGetString(doc, attr->children, 0);\n+                ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);\n+                if (value != NULL)\n+                    xmlFree((char *)value);\n+                attr= attr->next;\n+            }\n@@ -6487,9 +6300,16 @@\n-    ret &= xmlValidateOneElement(ctxt, doc, elem);\n-    if (elem->type == XML_ELEMENT_NODE) {\n-        attr = elem->properties;\n-        while (attr != NULL) {\n-            value = xmlNodeListGetString(doc, attr->children, 0);\n-            ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);\n-            if (value != NULL)\n-                xmlFree((char *)value);\n-            attr= attr->next;\n+            ns = elem->nsDef;\n+            while (ns != NULL) {\n+                if (elem->ns == NULL)\n+                    ret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,\n+                                                   ns, ns->href);\n+                else\n+                    ret &= xmlValidateOneNamespace(ctxt, doc, elem,\n+                                                   elem->ns->prefix, ns,\n+                                                   ns->href);\n+                ns = ns->next;\n+            }\n+\n+            if (elem->children != NULL) {\n+                elem = elem->children;\n+                continue;\n+            }\n@@ -6497,9 +6317,7 @@\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (elem->ns == NULL)\n-                ret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,\n-                                               ns, ns->href);\n-            else\n-                ret &= xmlValidateOneNamespace(ctxt, doc, elem,\n-                                               elem->ns->prefix, ns, ns->href);\n-            ns = ns->next;\n+\n+        while (1) {\n+            if (elem == root)\n+                goto done;\n+            if (elem->next != NULL)\n+                break;\n+            elem = elem->parent;\n@@ -6507,5 +6325,1 @@\n-    }\n-    child = elem->children;\n-    while (child != NULL) {\n-        ret &= xmlValidateElement(ctxt, doc, child);\n-        child = child->next;\n+        elem = elem->next;\n@@ -6514,0 +6328,1 @@\n+done:\n@@ -7010,1 +6825,1 @@\n-static void XMLCDECL xmlNoValidityErr(void *ctx ATTRIBUTE_UNUSED,\n+static void xmlNoValidityErr(void *ctx ATTRIBUTE_UNUSED,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/valid.c","additions":86,"deletions":271,"binary":false,"changes":357,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-XML_DEF = $(XML_BASENAME).def\n@@ -45,1 +44,1 @@\n-CPP = cpp32.exe -P- -DWIN32\n+CPP = cpp32.exe -P-\n@@ -53,1 +52,1 @@\n-CFLAGS = -q -DWIN32 -D_NO_VCL -D_WINDOWS -D_MBCS -DEILSEQ=2 -DNOLIBTOOL -w-\n+CFLAGS = -q -D_NO_VCL -D_WINDOWS -D_MBCS -DEILSEQ=2 -DNOLIBTOOL -w-\n@@ -61,4 +60,2 @@\n-!if \"$(WITH_THREADS)\" == \"yes\" || \"$(WITH_THREADS)\" == \"ctls\"\n-CFLAGS = $(CFLAGS) -DHAVE_WIN32_THREADS -DHAVE_COMPILER_TLS\n-!else if \"$(WITH_THREADS)\" == \"native\"\n-CFLAGS = $(CFLAGS) -DHAVE_WIN32_THREADS\n+!if \"$(WITH_THREADS)\" == \"ctls\"\n+CFLAGS = $(CFLAGS) \"-DXML_THREAD_LOCAL=__declspec(thread)\"\n@@ -208,1 +205,0 @@\n-\t$(BINDIR)\\testAutomata.exe\\\n@@ -298,5 +294,0 @@\n-# Creates the export definition file (DEF) for libxml.\n-#$(XML_INTDIR)\\$(XML_DEF) : $(XML_INTDIR)\\$(DUMMY) $(XML_DEF).src def4bcb.exe\n-#\t$(CPP) $(CPPFLAGS) -o $(XML_INTDIR)\\$(XML_DEF).tmp $(XML_DEF).src\n-#\tdef4bcb -msnames < $(XML_INTDIR)\\$(XML_DEF).tmp > $(XML_INTDIR)\\$(XML_DEF)\n-\n@@ -307,2 +298,2 @@\n-#$(BINDIR)\\$(XML_SO) : $(BINDIR)\\$(DUMMY) $(XML_OBJS) $(XML_INTDIR)\\$(XML_DEF)\n-#\t$(LD) $(LDFLAGS) -Tpd -Gi c0d32.obj $(XML_OBJS),$(BINDIR)\\$(XML_SO),,$(LIBS),$(XML_INTDIR)\\$(XML_DEF)\n+#$(BINDIR)\\$(XML_SO) : $(BINDIR)\\$(DUMMY) $(XML_OBJS)\n+#\t$(LD) $(LDFLAGS) -Tpd -Gi c0d32.obj $(XML_OBJS),$(BINDIR)\\$(XML_SO),,$(LIBS)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/Makefile.bcb","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-CFLAGS += -DWIN32 -D_WINDOWS -D_MBCS -DNOLIBTOOL \n+CFLAGS += -D_WINDOWS -D_MBCS -DNOLIBTOOL\n@@ -48,3 +48,0 @@\n-ifeq ($(WITH_THREADS),yes) \n-CFLAGS += -DHAVE_WIN32_THREADS -DHAVE_COMPILER_TLS\n-endif\n@@ -52,4 +49,1 @@\n-CFLAGS += -DHAVE_WIN32_THREADS -DHAVE_COMPILER_TLS\n-endif\n-ifeq ($(WITH_THREADS),native)\n-CFLAGS += -DHAVE_WIN32_THREADS\n+CFLAGS += \"-DXML_THREAD_LOCAL=__declspec(thread)\"\n@@ -204,1 +198,0 @@\n-\t$(BINDIR)\/testAutomata.exe\\\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/Makefile.mingw","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-XML_DEF = $(XML_BASENAME).def\n@@ -52,4 +51,2 @@\n-!if \"$(WITH_THREADS)\" == \"yes\" || \"$(WITH_THREADS)\" == \"ctls\"\n-CFLAGS = $(CFLAGS) \/D \"HAVE_WIN32_THREADS\" \/D \"HAVE_COMPILER_TLS\"\n-!else if \"$(WITH_THREADS)\" == \"native\"\n-CFLAGS = $(CFLAGS) \/D \"HAVE_WIN32_THREADS\"\n+!if \"$(WITH_THREADS)\" == \"ctls\"\n+CFLAGS = $(CFLAGS) \/D \"XML_THREAD_LOCAL=__declspec(thread)\"\n@@ -258,1 +255,0 @@\n-\t$(BINDIR)\\testAutomata.exe\\\n@@ -371,3 +367,0 @@\n-# Creates the export definition file (DEF) for libxml.\n-$(XML_INTDIR)\\$(XML_DEF) : $(XML_INTDIR) $(XML_DEF).src\n-\t$(CPP) $(CPPFLAGS) $(XML_DEF).src > $(XML_INTDIR)\\$(XML_DEF)\n@@ -378,1 +371,1 @@\n-$(BINDIR)\\$(XML_SO) : $(BINDIR) $(XML_OBJS) $(XML_INTDIR)\\$(XML_DEF) $(XML_INTDIR)\\$(XML_RES)\n+$(BINDIR)\\$(XML_SO) : $(BINDIR) $(XML_OBJS) $(XML_INTDIR)\\$(XML_RES)\n@@ -383,4 +376,0 @@\n-#$(BINDIR)\\$(XML_SO) : $(BINDIR) $(XML_OBJS) $(XML_INTDIR)\\$(XML_DEF)\n-#\t$(LD) $(LDFLAGS) \/DLL \/DEF:$(XML_INTDIR)\\$(XML_DEF) \\\n-#\t\t\/IMPLIB:$(BINDIR)\\$(XML_IMP) \/OUT:$(BINDIR)\\$(XML_SO) $(XML_OBJS) $(LIBS)\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/Makefile.msvc","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5,0 +5,3 @@\n+DEPRECATION WARNING: The build system in the win32 directory is deprecated\n+and will be removed in a future release. Please switch to CMake.\n+\n@@ -7,1 +10,1 @@\n-using a POSIX emulator, such as Cygwin. Check the Unix instructions for \n+using a POSIX emulator, such as Cygwin. Check the Unix instructions for\n@@ -40,1 +43,1 @@\n-be that a subdirectory of the directory where this file resides \n+be that a subdirectory of the directory where this file resides\n@@ -82,1 +85,1 @@\n-  cscript configure.js compiler=msvc prefix=c:\\opt \n+  cscript configure.js compiler=msvc prefix=c:\\opt\n@@ -86,2 +89,2 @@\n-compiler, install the library in c:\\opt, use c:\\opt\\include and \n-c:\\opt\\lib as additional search paths for the compiler and the linker \n+compiler, install the library in c:\\opt, use c:\\opt\\include and\n+c:\\opt\\lib as additional search paths for the compiler and the linker\n@@ -147,2 +150,2 @@\n-it will link to its own C-runtime named msvcr70.dll or msvcr71.dll. This \n-file is not available on any machine which doesn't have Visual Studio \n+it will link to its own C-runtime named msvcr70.dll or msvcr71.dll. This\n+file is not available on any machine which doesn't have Visual Studio\n@@ -155,1 +158,1 @@\n-When specifying paths to configure.js, please use slashes instead of \n+When specifying paths to configure.js, please use slashes instead of\n@@ -157,1 +160,1 @@\n-this is the case, and you specify backslashes, then the compiler will \n+this is the case, and you specify backslashes, then the compiler will\n@@ -165,1 +168,1 @@\n-the basic instructions found in this file file. Be sure to specify \n+the basic instructions found in this file file. Be sure to specify\n@@ -176,5 +179,5 @@\n-obtain the iconv library and include files. To get them, just follow the links \n-at http:\/\/www.gnu.org\/software\/libiconv\/ - there are pre-compiled Win32 \n-versions available, but note that these where built with MSVC. Hence the \n-supplied import library is in COFF format rather than OMF format. You can \n-convert this library by using Borland's COFF2OMF utility, or use IMPLIB to \n+obtain the iconv library and include files. To get them, just follow the links\n+at http:\/\/www.gnu.org\/software\/libiconv\/ - there are pre-compiled Win32\n+versions available, but note that these where built with MSVC. Hence the\n+supplied import library is in COFF format rather than OMF format. You can\n+convert this library by using Borland's COFF2OMF utility, or use IMPLIB to\n@@ -195,1 +198,1 @@\n-Borland compiler, by default, prepends an underscore character to global \n+Borland compiler, by default, prepends an underscore character to global\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/Readme.txt","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-var withRunDebug = false;\n@@ -135,1 +134,0 @@\n-\ttxt += \"  run_debug:  Enable memory debugger (\" + (withRunDebug? \"yes\" : \"no\")  + \")\\n\";\n@@ -232,1 +230,0 @@\n-\tvf.WriteLine(\"WITH_RUN_DEBUG=\" + (withRunDebug? \"1\" : \"0\"));\n@@ -340,2 +337,0 @@\n-\t\t} else if (s.search(\/\\@WITH_RUN_DEBUG\\@\/) != -1) {\n-\t\t\tof.WriteLine(s.replace(\/\\@WITH_RUN_DEBUG\\@\/, withRunDebug? \"1\" : \"0\"));\n@@ -495,2 +490,0 @@\n-\t\telse if (opt == \"run_debug\")\n-\t\t\twithRunDebug = strToBool(arg.substring(opt.length + 1, arg.length));\n@@ -675,1 +668,0 @@\n-txtOut += \" Runtime debugging: \" + boolToStr(withRunDebug) + \"\\n\";\n@@ -709,0 +701,4 @@\n+txtOut += \"\\n\";\n+txtOut += \"DEPRECATION WARNING: The build system in the win32 directory is\\n\";\n+txtOut += \"deprecated and will be removed in a future release. Please switch\\n\";\n+txtOut += \"to CMake.\\n\";\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/configure.js","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -18,3 +18,0 @@\n-#ifdef HAVE_SYS_TYPES_H\n-#include <sys\/types.h>\n-#endif\n@@ -56,0 +53,1 @@\n+#include <libxml\/xmlIO.h>\n@@ -59,1 +57,0 @@\n-#include <libxml\/xmlIO.h>\n@@ -67,1 +64,0 @@\n-#include <libxml\/globals.h>\n@@ -69,2 +65,5 @@\n-#include \"buf.h\"\n-#include \"enc.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/enc.h\"\n+#include \"private\/error.h\"\n+#include \"private\/io.h\"\n+#include \"private\/parser.h\"\n@@ -73,2 +72,0 @@\n-\/* #define DEBUG_EXTERNAL_ENTITIES *\/\n-\/* #define DEBUG_INPUT *\/\n@@ -76,3 +73,0 @@\n-#ifdef DEBUG_INPUT\n-#define MINLEN 40\n-#else\n@@ -80,1 +74,0 @@\n-#endif\n@@ -114,3 +107,0 @@\n-\n-xmlOutputBufferPtr\n-xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder);\n@@ -217,0 +207,1 @@\n+#if defined(LIBXML_HTTP_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)\n@@ -228,0 +219,1 @@\n+#endif\n@@ -722,14 +714,0 @@\n-\/**\n- * xmlInputReadCallbackNop:\n- *\n- * No Operation xmlInputReadCallback function, does nothing.\n- *\n- * Returns zero\n- *\/\n-int\n-xmlInputReadCallbackNop(void *context ATTRIBUTE_UNUSED,\n-                        char *buffer ATTRIBUTE_UNUSED,\n-                        int len ATTRIBUTE_UNUSED) {\n-    return(0);\n-}\n-\n@@ -1269,1 +1247,1 @@\n-#include \"xzlib.h\"\n+#include \"private\/xzlib.h\"\n@@ -1467,4 +1445,0 @@\n-#ifdef DEBUG_HTTP\n-    int z_err;\n-#endif\n-\n@@ -1475,7 +1449,0 @@\n-#ifdef DEBUG_HTTP\n-    z_err = deflateEnd( &buff->zctrl );\n-    if ( z_err != Z_OK )\n-        xmlGenericError( xmlGenericErrorContext,\n-                        \"xmlFreeZMemBuff:  Error releasing zlib context:  %d\\n\",\n-                        z_err );\n-#else\n@@ -1483,1 +1450,0 @@\n-#endif\n@@ -1581,9 +1547,0 @@\n-#ifdef DEBUG_HTTP\n-    if ( cur_used > new_size )\n-        xmlGenericError( xmlGenericErrorContext,\n-                        \"xmlZMemBuffExtend:  %s\\n%s %d bytes.\\n\",\n-                        \"Buffer overwrite detected during compressed memory\",\n-                        \"buffer extension.  Overflowed by\",\n-                        (cur_used - new_size ) );\n-#endif\n-\n@@ -2010,52 +1967,0 @@\n-#ifdef DEBUG_HTTP\n-            \/*  If testing\/debugging - dump reply with request content  *\/\n-\n-            FILE *      tst_file = NULL;\n-            char        buffer[ 4096 ];\n-            char *      dump_name = NULL;\n-            int         avail;\n-\n-            xmlGenericError( xmlGenericErrorContext,\n-                        \"xmlNanoHTTPCloseWrite:  HTTP %s to\\n%s returned %d.\\n\",\n-                        http_mthd, ctxt->uri,\n-                        xmlNanoHTTPReturnCode( http_ctxt ) );\n-\n-            \/*\n-            **  Since either content or reply may be gzipped,\n-            **  dump them to separate files instead of the\n-            **  standard error context.\n-            *\/\n-\n-            dump_name = tempnam( NULL, \"lxml\" );\n-            if ( dump_name != NULL ) {\n-                (void)snprintf( buffer, sizeof(buffer), \"%s.content\", dump_name );\n-\n-                tst_file = fopen( buffer, \"wb\" );\n-                if ( tst_file != NULL ) {\n-                    xmlGenericError( xmlGenericErrorContext,\n-                        \"Transmitted content saved in file:  %s\\n\", buffer );\n-\n-                    fwrite( http_content, sizeof( char ),\n-                                        content_lgth, tst_file );\n-                    fclose( tst_file );\n-                }\n-\n-                (void)snprintf( buffer, sizeof(buffer), \"%s.reply\", dump_name );\n-                tst_file = fopen( buffer, \"wb\" );\n-                if ( tst_file != NULL ) {\n-                    xmlGenericError( xmlGenericErrorContext,\n-                        \"Reply content saved in file:  %s\\n\", buffer );\n-\n-\n-                    while ( (avail = xmlNanoHTTPRead( http_ctxt,\n-                                        buffer, sizeof( buffer ) )) > 0 ) {\n-\n-                        fwrite( buffer, sizeof( char ), avail, tst_file );\n-                    }\n-\n-                    fclose( tst_file );\n-                }\n-\n-                free( dump_name );\n-            }\n-#endif  \/*  DEBUG_HTTP  *\/\n@@ -2346,1 +2251,0 @@\n-        xmlIOErrMemory(\"creating input buffer\");\n@@ -2349,1 +2253,1 @@\n-    memset(ret, 0, (size_t) sizeof(xmlParserInputBuffer));\n+    memset(ret, 0, sizeof(xmlParserInputBuffer));\n@@ -2385,1 +2289,0 @@\n-        xmlIOErrMemory(\"creating output buffer\");\n@@ -2388,1 +2291,1 @@\n-    memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));\n+    memset(ret, 0, sizeof(xmlOutputBuffer));\n@@ -2433,1 +2336,0 @@\n-        xmlIOErrMemory(\"creating output buffer\");\n@@ -2436,1 +2338,1 @@\n-    memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));\n+    memset(ret, 0, sizeof(xmlOutputBuffer));\n@@ -2931,0 +2833,30 @@\n+typedef struct {\n+    char *mem;\n+    const char *cur;\n+    size_t size;\n+} xmlMemIOCtxt;\n+\n+static int\n+xmlMemRead(void *vctxt, char *buf, int size) {\n+    xmlMemIOCtxt *ctxt = vctxt;\n+\n+    if ((size_t) size > ctxt->size)\n+        size = ctxt->size;\n+\n+    memcpy(buf, ctxt->cur, size);\n+    ctxt->cur += size;\n+    ctxt->size -= size;\n+\n+    return size;\n+}\n+\n+static int\n+xmlMemClose(void *vctxt) {\n+    xmlMemIOCtxt *ctxt = vctxt;\n+\n+    if (ctxt->mem != 0)\n+        xmlFree(ctxt->mem);\n+    xmlFree(ctxt);\n+    return(0);\n+}\n+\n@@ -2937,2 +2869,1 @@\n- * Create a buffered parser input for the progressive parsing for the input\n- * from a memory area.\n+ * Create a parser input buffer for parsing from a memory area.\n@@ -2940,1 +2871,10 @@\n- * Returns the new parser input or NULL\n+ * This function makes a copy of the whole input buffer. If you are sure\n+ * that the contents of the buffer will remain valid until the document\n+ * was parsed, you can avoid the copy by using\n+ * xmlParserInputBufferCreateStatic.\n+ *\n+ * The encoding argument is deprecated and should be set to\n+ * XML_CHAR_ENCODING_NONE. The encoding can be changed with\n+ * xmlSwitchEncoding or xmlSwitchEncodingName later on.\n+ *\n+ * Returns the new parser input or NULL in case of error.\n@@ -2944,2 +2884,3 @@\n-    xmlParserInputBufferPtr ret;\n-    int errcode;\n+    xmlParserInputBufferPtr buf;\n+    xmlMemIOCtxt *ctxt;\n+    char *copy;\n@@ -2947,2 +2888,2 @@\n-    if (size < 0) return(NULL);\n-    if (mem == NULL) return(NULL);\n+    if ((size < 0) || (mem == NULL))\n+        return(NULL);\n@@ -2950,10 +2891,8 @@\n-    ret = xmlAllocParserInputBuffer(enc);\n-    if (ret != NULL) {\n-        ret->context = (void *) mem;\n-        ret->readcallback = xmlInputReadCallbackNop;\n-        ret->closecallback = NULL;\n-        errcode = xmlBufAdd(ret->buffer, (const xmlChar *) mem, size);\n-        if (errcode != 0) {\n-            xmlFree(ret);\n-            return(NULL);\n-        }\n+    copy = (char *) xmlStrndup((const xmlChar *) mem, size);\n+    if (copy == NULL)\n+        return(NULL);\n+\n+    buf = xmlParserInputBufferCreateStatic(copy, size, enc);\n+    if (buf == NULL) {\n+        xmlFree(copy);\n+        return(NULL);\n@@ -2962,1 +2901,4 @@\n-    return(ret);\n+    ctxt = buf->context;\n+    ctxt->mem = copy;\n+\n+    return(buf);\n@@ -2971,4 +2913,1 @@\n- * Create a buffered parser input for the progressive parsing for the input\n- * from an immutable memory area. This will not copy the memory area to\n- * the buffer, but the memory is expected to be available until the end of\n- * the parsing, this is useful for example when using mmap'ed file.\n+ * Create a parser input buffer for parsing from a memory area.\n@@ -2976,1 +2915,9 @@\n- * Returns the new parser input or NULL\n+ * This functions assumes that the contents of the input buffer remain\n+ * valid until the document was parsed. Use xmlParserInputBufferCreateMem\n+ * otherwise.\n+ *\n+ * The encoding argument is deprecated and should be set to\n+ * XML_CHAR_ENCODING_NONE. The encoding can be changed with\n+ * xmlSwitchEncoding or xmlSwitchEncodingName later on.\n+ *\n+ * Returns the new parser input or NULL in case of error.\n@@ -2982,0 +2929,1 @@\n+    xmlMemIOCtxt *ctxt;\n@@ -2983,2 +2931,2 @@\n-    if (size < 0) return(NULL);\n-    if (mem == NULL) return(NULL);\n+    if ((size < 0) || (mem == NULL))\n+        return(NULL);\n@@ -2986,3 +2934,7 @@\n-    ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));\n-    if (ret == NULL) {\n-        xmlIOErrMemory(\"creating input buffer\");\n+    ret = xmlAllocParserInputBuffer(enc);\n+    if (ret == NULL)\n+        return(NULL);\n+\n+    ctxt = xmlMalloc(sizeof(*ctxt));\n+    if (ctxt == NULL) {\n+        xmlFreeParserInputBuffer(ret);\n@@ -2991,4 +2943,59 @@\n-    memset(ret, 0, (size_t) sizeof(xmlParserInputBuffer));\n-    ret->buffer = xmlBufCreateStatic((void *)mem, (size_t) size);\n-    if (ret->buffer == NULL) {\n-        xmlFree(ret);\n+    ctxt->mem = NULL;\n+    ctxt->cur = mem;\n+    ctxt->size = size;\n+\n+    ret->context = ctxt;\n+    ret->readcallback = xmlMemRead;\n+    ret->closecallback = xmlMemClose;\n+\n+    return(ret);\n+}\n+\n+typedef struct {\n+    const xmlChar *str;\n+} xmlStringIOCtxt;\n+\n+static int\n+xmlStringRead(void *vctxt, char *buf, int size) {\n+    xmlStringIOCtxt *ctxt = vctxt;\n+    const xmlChar *zero;\n+    size_t len;\n+\n+    zero = memchr(ctxt->str, 0, size);\n+    len = zero ? zero - ctxt->str : size;\n+\n+    memcpy(buf, ctxt->str, len);\n+    ctxt->str += len;\n+\n+    return(len);\n+}\n+\n+static int\n+xmlStringClose(void *vctxt) {\n+    xmlFree(vctxt);\n+    return(0);\n+}\n+\n+\/**\n+ * xmlParserInputBufferCreateString:\n+ * @str:  a null-terminated string\n+ *\n+ * Create a buffered parser input for the progressive parsing for the input\n+ * from a null-terminated C string.\n+ *\n+ * Returns the new parser input or NULL\n+ *\/\n+xmlParserInputBufferPtr\n+xmlParserInputBufferCreateString(const xmlChar *str) {\n+    xmlParserInputBufferPtr ret;\n+    xmlStringIOCtxt *ctxt;\n+\n+    if (str == NULL) return(NULL);\n+\n+    ret = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n+    if (ret == NULL)\n+        return(NULL);\n+\n+    ctxt = xmlMalloc(sizeof(*ctxt));\n+    if (ctxt == NULL) {\n+        xmlFreeParserInputBuffer(ret);\n@@ -2997,9 +3004,5 @@\n-    ret->encoder = xmlGetCharEncodingHandler(enc);\n-    if (ret->encoder != NULL)\n-        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);\n-    else\n-        ret->raw = NULL;\n-    ret->compressed = -1;\n-    ret->context = (void *) mem;\n-    ret->readcallback = NULL;\n-    ret->closecallback = NULL;\n+    ctxt->str = str;\n+\n+    ret->context = ctxt;\n+    ret->readcallback = xmlStringRead;\n+    ret->closecallback = xmlStringClose;\n@@ -3162,2 +3165,0 @@\n-        unsigned int use;\n-\n@@ -3169,0 +3170,4 @@\n+            if (in->raw == NULL) {\n+                in->error = XML_ERR_NO_MEMORY;\n+                return(-1);\n+            }\n@@ -3171,1 +3176,2 @@\n-        if (ret != 0)\n+        if (ret != 0) {\n+            in->error = XML_ERR_NO_MEMORY;\n@@ -3173,0 +3179,1 @@\n+        }\n@@ -3177,5 +3184,2 @@\n-        use = xmlBufUse(in->raw);\n-        nbchars = xmlCharEncInput(in, 1);\n-        if (nbchars < 0) {\n-            xmlIOErr(XML_IO_ENCODER, NULL);\n-            in->error = XML_IO_ENCODER;\n+        nbchars = xmlCharEncInput(in);\n+        if (nbchars < 0)\n@@ -3183,2 +3187,0 @@\n-        }\n-        in->rawconsumed += (use - xmlBufUse(in->raw));\n@@ -3188,1 +3190,2 @@\n-        if (ret != 0)\n+        if (ret != 0) {\n+            in->error = XML_ERR_NO_MEMORY;\n@@ -3190,0 +3193,1 @@\n+        }\n@@ -3191,5 +3195,0 @@\n-#ifdef DEBUG_INPUT\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"I\/O: pushed %d chars, buffer %d\/%d\\n\",\n-            nbchars, xmlBufUse(in->buffer), xmlBufLength(in->buffer));\n-#endif\n@@ -3229,1 +3228,1 @@\n-    char *buffer = NULL;\n+    xmlBufPtr buf;\n@@ -3231,1 +3230,0 @@\n-    int nbchars = 0;\n@@ -3237,4 +3235,9 @@\n-    if (xmlBufGrow(in->buffer, len + 1) < 0) {\n-        xmlIOErrMemory(\"growing input buffer\");\n-        in->error = XML_ERR_NO_MEMORY;\n-        return(-1);\n+    if (in->encoder == NULL) {\n+        if (in->readcallback == NULL)\n+            return(0);\n+        buf = in->buffer;\n+    } else {\n+        if (in->raw == NULL) {\n+            in->raw = xmlBufCreate();\n+        }\n+        buf = in->raw;\n@@ -3242,1 +3245,0 @@\n-    buffer = (char *)xmlBufEnd(in->buffer);\n@@ -3248,1 +3250,6 @@\n-        res = in->readcallback(in->context, &buffer[0], len);\n+        if (xmlBufGrow(buf, len + 1) < 0) {\n+            in->error = XML_ERR_NO_MEMORY;\n+            return(-1);\n+        }\n+\n+        res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);\n@@ -3251,7 +3258,9 @@\n-    } else {\n-        xmlIOErr(XML_IO_NO_INPUT, NULL);\n-        in->error = XML_IO_NO_INPUT;\n-        return(-1);\n-    }\n-    if (res < 0) {\n-        return(-1);\n+        if (res < 0) {\n+            in->error = XML_IO_UNKNOWN;\n+            return(-1);\n+        }\n+\n+        if (xmlBufAddLen(buf, res) < 0) {\n+            in->error = XML_ERR_NO_MEMORY;\n+            return(-1);\n+        }\n@@ -3270,1 +3279,0 @@\n-    len = res;\n@@ -3272,20 +3280,2 @@\n-        unsigned int use;\n-\n-        \/*\n-         * Store the data in the incoming raw buffer\n-         *\/\n-        if (in->raw == NULL) {\n-            in->raw = xmlBufCreate();\n-        }\n-        res = xmlBufAdd(in->raw, (const xmlChar *) buffer, len);\n-        if (res != 0)\n-            return(-1);\n-\n-        \/*\n-         * convert as much as possible to the parser reading buffer.\n-         *\/\n-        use = xmlBufUse(in->raw);\n-        nbchars = xmlCharEncInput(in, 1);\n-        if (nbchars < 0) {\n-            xmlIOErr(XML_IO_ENCODER, NULL);\n-            in->error = XML_IO_ENCODER;\n+        res = xmlCharEncInput(in);\n+        if (res < 0)\n@@ -3293,5 +3283,0 @@\n-        }\n-        in->rawconsumed += (use - xmlBufUse(in->raw));\n-    } else {\n-        nbchars = len;\n-        xmlBufAddLen(in->buffer, nbchars);\n@@ -3299,6 +3284,1 @@\n-#ifdef DEBUG_INPUT\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"I\/O: read %d chars, buffer %d\\n\",\n-            nbchars, xmlBufUse(in->buffer));\n-#endif\n-    return(nbchars);\n+    return(res);\n@@ -3321,7 +3301,1 @@\n-    if ((in == NULL) || (in->error)) return(-1);\n-    if (in->readcallback != NULL)\n-        return(xmlParserInputBufferGrow(in, len));\n-    else if (xmlBufGetAllocationScheme(in->buffer) == XML_BUFFER_ALLOC_IMMUTABLE)\n-        return(0);\n-    else\n-        return(-1);\n+    return(xmlParserInputBufferGrow(in, len));\n@@ -3435,4 +3409,0 @@\n-#ifdef DEBUG_INPUT\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"I\/O: wrote %d chars\\n\", written);\n-#endif\n@@ -3493,1 +3463,1 @@\n-            *out++ = (unsigned char) *in;\n+            *out++ = *in;\n@@ -3529,2 +3499,1 @@\n-        (out->buffer == NULL) ||\n-        (xmlBufGetAllocationScheme(out->buffer) == XML_BUFFER_ALLOC_IMMUTABLE))\n+        (out->buffer == NULL))\n@@ -3636,4 +3605,0 @@\n-#ifdef DEBUG_INPUT\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"I\/O: wrote %d chars\\n\", written);\n-#endif\n@@ -3727,4 +3692,0 @@\n-#ifdef DEBUG_INPUT\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"I\/O: flushed %d chars\\n\", ret);\n-#endif\n@@ -3840,2 +3801,0 @@\n-                    if (ret->encoding == NULL)\n-                        ret->encoding = xmlStrdup(BAD_CAST encoding);\n@@ -3983,4 +3942,0 @@\n-#ifdef DEBUG_EXTERNAL_ENTITIES\n-    xmlGenericError(xmlGenericErrorContext,\n-                    \"xmlDefaultExternalEntityLoader(%s, xxx)\\n\", URL);\n-#endif\n@@ -4060,1 +4015,1 @@\n-            xmlIOErrMemory(\"building canonical path\\n\");\n+            xmlErrMemory(ctxt, \"building canonical path\\n\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlIO.c","additions":198,"deletions":243,"binary":false,"changes":441,"status":"modified"},{"patch":"@@ -15,2 +15,0 @@\n-\/* #define DEBUG_MEMORY *\/\n-\n@@ -29,1 +27,0 @@\n-#include <libxml\/globals.h>     \/* must come before xmlmemory.h *\/\n@@ -32,0 +29,1 @@\n+#include <libxml\/parser.h>\n@@ -34,1 +32,3 @@\n-static int xmlMemInitialized = 0;\n+#include \"private\/memory.h\"\n+#include \"private\/threads.h\"\n+\n@@ -38,1 +38,1 @@\n-static xmlMutexPtr xmlMemMutex = NULL;\n+static xmlMutex xmlMemMutex;\n@@ -150,5 +150,1 @@\n-    if (!xmlMemInitialized) xmlInitMemory();\n-#ifdef DEBUG_MEMORY\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Malloc(%d)\\n\",size);\n-#endif\n+    xmlInitParser();\n@@ -161,1 +157,0 @@\n-        xmlMemoryDump();\n@@ -170,1 +165,0 @@\n-        xmlMemoryDump();\n@@ -178,1 +172,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -186,6 +180,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n-\n-#ifdef DEBUG_MEMORY\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Malloc(%d) Ok\\n\",size);\n-#endif\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -226,5 +215,1 @@\n-    if (!xmlMemInitialized) xmlInitMemory();\n-#ifdef DEBUG_MEMORY\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Malloc(%d)\\n\",size);\n-#endif\n+    xmlInitParser();\n@@ -237,1 +222,0 @@\n-        xmlMemoryDump();\n@@ -246,1 +230,0 @@\n-        xmlMemoryDump();\n@@ -254,1 +237,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -262,6 +245,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n-\n-#ifdef DEBUG_MEMORY\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Malloc(%d) Ok\\n\",size);\n-#endif\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -316,3 +294,0 @@\n-#ifdef DEBUG_MEMORY\n-    size_t oldsize;\n-#endif\n@@ -323,1 +298,1 @@\n-    if (!xmlMemInitialized) xmlInitMemory();\n+    xmlInitParser();\n@@ -334,1 +309,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -337,3 +312,0 @@\n-#ifdef DEBUG_MEMORY\n-    oldsize = p->mh_size;\n-#endif\n@@ -343,1 +315,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -348,1 +320,0 @@\n-        xmlMemoryDump();\n@@ -371,1 +342,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -378,1 +349,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -382,4 +353,0 @@\n-#ifdef DEBUG_MEMORY\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Realloced(%d to %d) Ok\\n\", oldsize, size);\n-#endif\n@@ -418,3 +385,0 @@\n-#ifdef DEBUG_MEMORY\n-    size_t size;\n-#endif\n@@ -449,1 +413,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -452,3 +416,0 @@\n-#ifdef DEBUG_MEMORY\n-    size = p->mh_size;\n-#endif\n@@ -458,1 +419,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -464,5 +425,0 @@\n-#ifdef DEBUG_MEMORY\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Freed(%d) Ok\\n\", size);\n-#endif\n-\n@@ -496,1 +452,1 @@\n-    if (!xmlMemInitialized) xmlInitMemory();\n+    xmlInitParser();\n@@ -502,1 +458,0 @@\n-        xmlMemoryDump();\n@@ -515,1 +470,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -523,1 +478,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -559,0 +514,21 @@\n+\/**\n+ * xmlMemSize:\n+ * @ptr:  pointer to the memory allocation\n+ *\n+ * Returns the size of a memory allocation.\n+ *\/\n+\n+size_t\n+xmlMemSize(void *ptr) {\n+    MEMHDR *p;\n+\n+    if (ptr == NULL)\n+        return(0);\n+\n+    p = CLIENT_2_HDR(ptr);\n+    if (p->mh_tag != MEMTAG)\n+        return(0);\n+\n+    return(p->mh_size);\n+}\n+\n@@ -569,6 +545,1 @@\n-    int res;\n-\n-    xmlMutexLock(xmlMemMutex);\n-    res = debugMemSize;\n-    xmlMutexUnlock(xmlMemMutex);\n-    return(res);\n+    return(debugMemSize);\n@@ -589,1 +560,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -591,1 +562,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -595,62 +566,0 @@\n-#ifdef MEM_LIST\n-\/**\n- * xmlMemContentShow:\n- * @fp:  a FILE descriptor used as the output file\n- * @p:  a memory block header\n- *\n- * tries to show some content from the memory block\n- *\/\n-\n-static void\n-xmlMemContentShow(FILE *fp, MEMHDR *p)\n-{\n-    int i,j,k,len;\n-    const char *buf;\n-\n-    if (p == NULL) {\n-        fprintf(fp, \" NULL\");\n-        return;\n-    }\n-    len = p->mh_size;\n-    buf = (const char *) HDR_2_CLIENT(p);\n-\n-    for (i = 0;i < len;i++) {\n-        if (buf[i] == 0) break;\n-        if (!isprint((unsigned char) buf[i])) break;\n-    }\n-    if ((i < 4) && ((buf[i] != 0) || (i == 0))) {\n-        if (len >= 4) {\n-            MEMHDR *q;\n-            void *cur;\n-\n-            for (j = 0;(j < len -3) && (j < 40);j += 4) {\n-                cur = *((void **) &buf[j]);\n-                q = CLIENT_2_HDR(cur);\n-                p = memlist;\n-                k = 0;\n-                while (p != NULL) {\n-                    if (p == q) break;\n-                    p = p->mh_next;\n-                    if (k++ > 100) break;\n-                }\n-                if ((p != NULL) && (p == q)) {\n-                    fprintf(fp, \" pointer to #%lu at index %d\",\n-                            p->mh_number, j);\n-                    return;\n-                }\n-            }\n-        }\n-    } else if ((i == 0) && (buf[i] == 0)) {\n-        fprintf(fp,\" null\");\n-    } else {\n-        if (buf[i] == 0) fprintf(fp,\" \\\"%.25s\\\"\", buf);\n-        else {\n-            fprintf(fp,\" [\");\n-            for (j = 0;j < i;j++)\n-                fprintf(fp,\"%c\", buf[j]);\n-            fprintf(fp,\"]\");\n-        }\n-    }\n-}\n-#endif\n-\n@@ -691,1 +600,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -704,1 +613,1 @@\n-                xmlMutexUnlock(xmlMemMutex);\n+                xmlMutexUnlock(&xmlMemMutex);\n@@ -713,4 +622,0 @@\n-        if (nb < 100)\n-            xmlMemContentShow(fp, p);\n-        else\n-            fprintf(fp,\" skip\");\n@@ -722,1 +627,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -768,1 +673,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -781,1 +686,1 @@\n-                xmlMutexUnlock(xmlMemMutex);\n+                xmlMutexUnlock(&xmlMemMutex);\n@@ -790,4 +695,0 @@\n-        if (nb < 100)\n-            xmlMemContentShow(fp, p);\n-        else\n-            fprintf(fp,\" skip\");\n@@ -798,1 +699,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -814,4 +715,0 @@\n-#ifdef MEM_LIST_DEBUG\n-     if (stderr)\n-     Mem_Display(stderr);\n-#endif\n@@ -827,4 +724,0 @@\n-#ifdef MEM_LIST_DEBUG\n-     if (stderr)\n-     Mem_Display(stderr);\n-#endif\n@@ -875,1 +768,1 @@\n-    xmlMutexLock(xmlMemMutex);\n+    xmlMutexLock(&xmlMemMutex);\n@@ -893,1 +786,0 @@\n-            xmlMemContentShow(fp, p);\n@@ -899,1 +791,1 @@\n-    xmlMutexUnlock(xmlMemMutex);\n+    xmlMutexUnlock(&xmlMemMutex);\n@@ -938,2 +830,10 @@\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n- * initialize the library.\n+ * DEPRECATED: Alias for xmlInitParser.\n+ *\/\n+int\n+xmlInitMemory(void) {\n+    xmlInitParser();\n+    return(0);\n+}\n+\n+\/**\n+ * xmlInitMemoryInternal:\n@@ -945,3 +845,2 @@\n-int\n-xmlInitMemory(void)\n-{\n+void\n+xmlInitMemoryInternal(void) {\n@@ -949,11 +848,1 @@\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlInitMemory()\\n\");\n-#endif\n-    \/*\n-     This is really not good code (see Bug 130419).  Suggestions for\n-     improvement will be welcome!\n-    *\/\n-     if (xmlMemInitialized) return(-1);\n-     xmlMemInitialized = 1;\n-     xmlMemMutex = xmlNewMutex();\n+     xmlInitMutex(&xmlMemMutex);\n@@ -970,5 +859,0 @@\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlInitMemory() Ok\\n\");\n-#endif\n-     return(0);\n@@ -980,1 +864,1 @@\n- * DEPRECATED: This function will be made private. Call xmlCleanupParser\n+ * DEPRECATED: This function is a no-op. Call xmlCleanupParser\n@@ -984,0 +868,7 @@\n+ *\/\n+void\n+xmlCleanupMemory(void) {\n+}\n+\n+\/**\n+ * xmlCleanupMemoryInternal:\n@@ -989,14 +880,10 @@\n-xmlCleanupMemory(void) {\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlCleanupMemory()\\n\");\n-#endif\n-    if (xmlMemInitialized == 0)\n-        return;\n-\n-    xmlFreeMutex(xmlMemMutex);\n-    xmlMemMutex = NULL;\n-    xmlMemInitialized = 0;\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlCleanupMemory() Ok\\n\");\n+xmlCleanupMemoryInternal(void) {\n+    \/*\n+     * Don't clean up mutex on Windows. Global state destructors can call\n+     * malloc functions after xmlCleanupParser was called. If memory\n+     * debugging is enabled, xmlMemMutex can be used after cleanup.\n+     *\n+     * See python\/tests\/thread2.py\n+     *\/\n+#if !defined(LIBXML_THREAD_ENABLED) || !defined(_WIN32)\n+    xmlCleanupMutex(&xmlMemMutex);\n@@ -1024,4 +911,0 @@\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlMemSetup()\\n\");\n-#endif\n@@ -1041,4 +924,0 @@\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlMemSetup() Ok\\n\");\n-#endif\n@@ -1091,4 +970,0 @@\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlGcMemSetup()\\n\");\n-#endif\n@@ -1110,4 +985,0 @@\n-#ifdef DEBUG_MEMORY\n-     xmlGenericError(xmlGenericErrorContext,\n-             \"xmlGcMemSetup() Ok\\n\");\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlmemory.c","additions":84,"deletions":213,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -42,1 +42,6 @@\n-#include \"buf.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/parser.h\"\n+#include \"private\/tree.h\"\n+#ifdef LIBXML_XINCLUDE_ENABLED\n+#include \"private\/xinclude.h\"\n+#endif\n@@ -76,3 +81,0 @@\n-\/* #define DEBUG_CALLBACKS *\/\n-\/* #define DEBUG_READER *\/\n-\n@@ -89,6 +91,0 @@\n-#ifdef DEBUG_READER\n-#define DUMP_READER xmlTextReaderDebug(reader);\n-#else\n-#define DUMP_READER\n-#endif\n-\n@@ -504,27 +500,0 @@\n-#ifdef DEBUG_READER\n-static void\n-xmlTextReaderDebug(xmlTextReaderPtr reader) {\n-    if ((reader == NULL) || (reader->ctxt == NULL)) {\n-        fprintf(stderr, \"xmlTextReader NULL\\n\");\n-        return;\n-    }\n-    fprintf(stderr, \"xmlTextReader: state %d depth %d \",\n-            reader->state, reader->depth);\n-    if (reader->node == NULL) {\n-        fprintf(stderr, \"node = NULL\\n\");\n-    } else {\n-        fprintf(stderr, \"node %s\\n\", reader->node->name);\n-    }\n-    fprintf(stderr, \"  input: base %d, cur %d, depth %d: \",\n-            reader->base, reader->cur, reader->ctxt->nodeNr);\n-    if (reader->input->buffer == NULL) {\n-        fprintf(stderr, \"buffer is NULL\\n\");\n-    } else {\n-#ifdef LIBXML_DEBUG_ENABLED\n-        xmlDebugDumpString(stderr,\n-                &reader->input->buffer->content[reader->cur]);\n-#endif\n-        fprintf(stderr, \"\\n\");\n-    }\n-}\n-#endif\n@@ -539,1 +508,1 @@\n- * Returns 0 in case of error, the index in the stack otherwise\n+ * Returns -1 in case of error, the index in the stack otherwise\n@@ -544,9 +513,0 @@\n-    if (reader->entMax <= 0) {\n-        reader->entMax = 10;\n-        reader->entTab = (xmlNodePtr *) xmlMalloc(reader->entMax *\n-                                                  sizeof(reader->entTab[0]));\n-        if (reader->entTab == NULL) {\n-            xmlGenericError(xmlGenericErrorContext, \"xmlMalloc failed !\\n\");\n-            return (0);\n-        }\n-    }\n@@ -554,6 +514,6 @@\n-        reader->entMax *= 2;\n-        reader->entTab =\n-            (xmlNodePtr *) xmlRealloc(reader->entTab,\n-                                      reader->entMax *\n-                                      sizeof(reader->entTab[0]));\n-        if (reader->entTab == NULL) {\n+        size_t newSize = reader->entMax == 0 ? 10 : reader->entMax * 2;\n+        xmlNodePtr *tmp;\n+\n+        tmp = (xmlNodePtr *) xmlRealloc(reader->entTab,\n+                                        newSize * sizeof(*tmp));\n+        if (tmp == NULL) {\n@@ -561,1 +521,1 @@\n-            return (0);\n+            return (-1);\n@@ -563,0 +523,2 @@\n+        reader->entTab = tmp;\n+        reader->entMax = newSize;\n@@ -608,3 +570,0 @@\n-#ifdef DEBUG_CALLBACKS\n-    printf(\"xmlTextReaderStartElement(%s)\\n\", fullname);\n-#endif\n@@ -634,3 +593,0 @@\n-#ifdef DEBUG_CALLBACKS\n-    printf(\"xmlTextReaderEndElement(%s)\\n\", fullname);\n-#endif\n@@ -671,3 +627,0 @@\n-#ifdef DEBUG_CALLBACKS\n-    printf(\"xmlTextReaderStartElementNs(%s)\\n\", localname);\n-#endif\n@@ -705,3 +658,0 @@\n-#ifdef DEBUG_CALLBACKS\n-    printf(\"xmlTextReaderEndElementNs(%s)\\n\", localname);\n-#endif\n@@ -728,3 +678,0 @@\n-#ifdef DEBUG_CALLBACKS\n-    printf(\"xmlTextReaderCharacters()\\n\");\n-#endif\n@@ -750,3 +697,0 @@\n-#ifdef DEBUG_CALLBACKS\n-    printf(\"xmlTextReaderCDataBlock()\\n\");\n-#endif\n@@ -772,1 +716,0 @@\n-    int alloc;\n@@ -780,1 +723,0 @@\n-    alloc = xmlBufGetAllocationScheme(inbuf);\n@@ -789,2 +731,1 @@\n-                if ((val == 0) &&\n-                    (alloc == XML_BUFFER_ALLOC_IMMUTABLE)) {\n+                if (val == 0) {\n@@ -793,1 +734,1 @@\n-                        reader->state = oldstate;\n+                        break;\n@@ -796,0 +737,2 @@\n+                    xmlGenericError(xmlGenericErrorContext,\n+                                    \"xmlParserInputBufferRead failed\\n\");\n@@ -798,7 +741,1 @@\n-                    if ((oldstate != XML_TEXTREADER_START) ||\n-                        (reader->ctxt->myDoc != NULL))\n-                        return(val);\n-                } else if (val == 0) {\n-                    \/* mark the end of the stream and process the remains *\/\n-                    reader->mode = XML_TEXTREADER_MODE_EOF;\n-                    break;\n+                    return(val);\n@@ -834,0 +771,1 @@\n+    reader->state = oldstate;\n@@ -839,1 +777,1 @@\n-        if (alloc != XML_BUFFER_ALLOC_IMMUTABLE) {\n+        if (reader->input->readcallback != NULL) {\n@@ -870,1 +808,0 @@\n-    reader->state = oldstate;\n@@ -1037,1 +974,5 @@\n-                xmlTextReaderEntPush(reader, node);\n+                if (xmlTextReaderEntPush(reader, node) < 0) {\n+                    if (node == oldnode)\n+                        break;\n+                    goto skip_children;\n+                }\n@@ -1234,4 +1175,0 @@\n-#ifdef DEBUG_READER\n-    fprintf(stderr, \"\\nREAD \");\n-    DUMP_READER\n-#endif\n@@ -1429,2 +1366,0 @@\n-    DUMP_READER\n-\n@@ -1447,0 +1382,1 @@\n+        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n@@ -1456,0 +1392,1 @@\n+            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n@@ -1482,1 +1419,2 @@\n-            xmlTextReaderEntPush(reader, reader->node);\n+            if (xmlTextReaderEntPush(reader, reader->node) < 0)\n+                goto get_next_node;\n@@ -2861,1 +2799,2 @@\n-    xmlDocPtr doc = NULL;\n+    const xmlChar *encoding = NULL;\n+\n@@ -2864,6 +2803,0 @@\n-    if (reader->doc != NULL)\n-        doc = reader->doc;\n-    else if (reader->ctxt != NULL)\n-        doc = reader->ctxt->myDoc;\n-    if (doc == NULL)\n-        return(NULL);\n@@ -2871,4 +2804,6 @@\n-    if (doc->encoding == NULL)\n-        return(NULL);\n-    else\n-      return(CONSTSTR(doc->encoding));\n+    if (reader->ctxt != NULL)\n+        encoding = xmlGetActualEncoding(reader->ctxt);\n+    else if (reader->doc != NULL)\n+        encoding = reader->doc->encoding;\n+\n+    return(CONSTSTR(encoding));\n@@ -3616,1 +3551,1 @@\n-    return((int) '\"');\n+    return('\"');\n@@ -3981,1 +3916,1 @@\n-static void XMLCDECL\n+static void\n@@ -3984,1 +3919,1 @@\n-static void XMLCDECL\n+static void\n@@ -3987,1 +3922,1 @@\n-static void XMLCDECL\n+static void\n@@ -3990,1 +3925,1 @@\n-static void XMLCDECL\n+static void\n@@ -3993,1 +3928,1 @@\n-static void XMLCDECL\n+static void\n@@ -4016,1 +3951,1 @@\n-static void XMLCDECL\n+static void\n@@ -4040,1 +3975,1 @@\n-  xmlTextReaderStructuredError(void *ctxt, xmlErrorPtr error);\n+xmlTextReaderStructuredError(void *ctxt, const xmlError *error);\n@@ -4043,1 +3978,1 @@\n-xmlTextReaderValidityStructuredRelay(void *userData, xmlErrorPtr error)\n+xmlTextReaderValidityStructuredRelay(void *userData, const xmlError *error)\n@@ -4774,1 +4709,1 @@\n-xmlTextReaderStructuredError(void *ctxt, xmlErrorPtr error)\n+xmlTextReaderStructuredError(void *ctxt, const xmlError *error)\n@@ -4785,1 +4720,1 @@\n-static void XMLCDECL LIBXML_ATTR_FORMAT(2,3)\n+static void LIBXML_ATTR_FORMAT(2,3)\n@@ -4798,1 +4733,1 @@\n-static void XMLCDECL LIBXML_ATTR_FORMAT(2,3)\n+static void LIBXML_ATTR_FORMAT(2,3)\n@@ -4810,1 +4745,1 @@\n-static void XMLCDECL\n+static void\n@@ -4830,1 +4765,1 @@\n-static void XMLCDECL\n+static void\n@@ -5237,0 +5172,13 @@\n+\/**\n+ * xmlTextReaderSetMaxAmplification:\n+ * @reader: an XML reader\n+ * @maxAmpl:  maximum amplification factor\n+ *\n+ * Set the maximum amplification factor. See xmlCtxtSetMaxAmplification.\n+ *\/\n+void\n+xmlTextReaderSetMaxAmplification(xmlTextReaderPtr reader, unsigned maxAmpl)\n+{\n+    xmlCtxtSetMaxAmplification(reader->ctxt, maxAmpl);\n+}\n+\n@@ -5364,2 +5312,1 @@\n-    buf = xmlParserInputBufferCreateStatic(buffer, size,\n-                                      XML_CHAR_ENCODING_NONE);\n+    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n@@ -5591,1 +5538,1 @@\n-    input = xmlParserInputBufferCreateStatic(buffer, size,\n+    input = xmlParserInputBufferCreateMem(buffer, size,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlreader.c","additions":69,"deletions":122,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -22,3 +22,4 @@\n-#include \"buf.h\"\n-#include \"enc.h\"\n-#include \"save.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/enc.h\"\n+#include \"private\/error.h\"\n+#include \"private\/save.h\"\n@@ -26,17 +27,1 @@\n-\/************************************************************************\n- *                                                                      *\n- *                      XHTML detection                                 *\n- *                                                                      *\n- ************************************************************************\/\n-#define XHTML_STRICT_PUBLIC_ID BAD_CAST \\\n-   \"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\"\n-#define XHTML_STRICT_SYSTEM_ID BAD_CAST \\\n-   \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-strict.dtd\"\n-#define XHTML_FRAME_PUBLIC_ID BAD_CAST \\\n-   \"-\/\/W3C\/\/DTD XHTML 1.0 Frameset\/\/EN\"\n-#define XHTML_FRAME_SYSTEM_ID BAD_CAST \\\n-   \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-frameset.dtd\"\n-#define XHTML_TRANS_PUBLIC_ID BAD_CAST \\\n-   \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\"\n-#define XHTML_TRANS_SYSTEM_ID BAD_CAST \\\n-   \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\"\n+#ifdef LIBXML_OUTPUT_ENABLED\n@@ -45,27 +30,0 @@\n-\/**\n- * xmlIsXHTML:\n- * @systemID:  the system identifier\n- * @publicID:  the public identifier\n- *\n- * Try to find if the document correspond to an XHTML DTD\n- *\n- * Returns 1 if true, 0 if not and -1 in case of error\n- *\/\n-int\n-xmlIsXHTML(const xmlChar *systemID, const xmlChar *publicID) {\n-    if ((systemID == NULL) && (publicID == NULL))\n-        return(-1);\n-    if (publicID != NULL) {\n-        if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);\n-        if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);\n-        if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);\n-    }\n-    if (systemID != NULL) {\n-        if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);\n-        if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);\n-        if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);\n-    }\n-    return(0);\n-}\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n@@ -466,1 +424,1 @@\n-void\n+static void\n@@ -490,1 +448,1 @@\n-void\n+static void\n@@ -514,1 +472,1 @@\n-void\n+static void\n@@ -537,1 +495,1 @@\n-void\n+static void\n@@ -598,1 +556,0 @@\n-void xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur);\n@@ -1893,1 +1850,1 @@\n- * @node:  the top node of the subtree to save\n+ * @cur:  the top node of the subtree to save\n@@ -2181,1 +2138,1 @@\n-    return((int) ret);\n+    return(ret);\n@@ -2212,4 +2169,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"xmlNodeDump : node == NULL\\n\");\n-#endif\n@@ -2219,4 +2172,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"xmlNodeDump : buf == NULL\\n\");\n-#endif\n@@ -2264,4 +2213,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"xmlElemDump : cur == NULL\\n\");\n-#endif\n@@ -2270,6 +2215,0 @@\n-#ifdef DEBUG_TREE\n-    if (doc == NULL) {\n-        xmlGenericError(xmlGenericErrorContext,\n-                        \"xmlElemDump : doc == NULL\\n\");\n-    }\n-#endif\n@@ -2320,0 +2259,2 @@\n+    (void) doc;\n+\n@@ -2409,0 +2350,1 @@\n+        xmlCharEncCloseFunc(conv_hdlr);\n@@ -2512,4 +2454,0 @@\n-#ifdef DEBUG_TREE\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlDocDump : document == NULL\\n\");\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlsave.c","additions":14,"deletions":76,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+#include \"private\/parser.h\"\n+#include \"private\/string.h\"\n+\n@@ -46,1 +49,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic(((size_t) len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);\n@@ -48,1 +51,0 @@\n-        xmlErrMemory(NULL, NULL);\n@@ -51,1 +53,1 @@\n-    memcpy(ret, cur, len * sizeof(xmlChar));\n+    memcpy(ret, cur, len);\n@@ -91,1 +93,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic(((size_t) len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);\n@@ -93,1 +95,0 @@\n-        xmlErrMemory(NULL, NULL);\n@@ -97,0 +98,1 @@\n+        \/* Explicit sign change *\/\n@@ -460,1 +462,1 @@\n-    ret = (xmlChar *) xmlRealloc(cur, ((size_t) size + len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlRealloc(cur, (size_t) size + len + 1);\n@@ -462,1 +464,0 @@\n-        xmlErrMemory(NULL, NULL);\n@@ -465,1 +466,1 @@\n-    memcpy(&ret[size], add, len * sizeof(xmlChar));\n+    memcpy(&ret[size], add, len);\n@@ -500,1 +501,1 @@\n-    ret = (xmlChar *) xmlMalloc(((size_t) size + len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMalloc((size_t) size + len + 1);\n@@ -502,1 +503,0 @@\n-        xmlErrMemory(NULL, NULL);\n@@ -505,2 +505,2 @@\n-    memcpy(ret, str1, size * sizeof(xmlChar));\n-    memcpy(&ret[size], str2, len * sizeof(xmlChar));\n+    memcpy(ret, str1, size);\n+    memcpy(&ret[size], str2, len);\n@@ -546,1 +546,1 @@\n-int XMLCDECL\n+int\n@@ -715,2 +715,0 @@\n-    if (*len < 1)\n-        goto error;\n@@ -719,2 +717,2 @@\n-    if (c & 0x80) {\n-        if (*len < 2)\n+    if (c < 0x80) {\n+        if (*len < 1)\n@@ -722,1 +720,4 @@\n-        if ((utf[1] & 0xc0) != 0x80)\n+        \/* 1-byte code *\/\n+        *len = 1;\n+    } else {\n+        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))\n@@ -724,2 +725,2 @@\n-        if ((c & 0xe0) == 0xe0) {\n-            if (*len < 3)\n+        if (c < 0xe0) {\n+            if (c < 0xc2)\n@@ -727,1 +728,6 @@\n-            if ((utf[2] & 0xc0) != 0x80)\n+            \/* 2-byte code *\/\n+            *len = 2;\n+            c = (c & 0x1f) << 6;\n+            c |= utf[1] & 0x3f;\n+        } else {\n+            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))\n@@ -729,2 +735,7 @@\n-            if ((c & 0xf0) == 0xf0) {\n-                if (*len < 4)\n+            if (c < 0xf0) {\n+                \/* 3-byte code *\/\n+                *len = 3;\n+                c = (c & 0xf) << 12;\n+                c |= (utf[1] & 0x3f) << 6;\n+                c |= utf[2] & 0x3f;\n+                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))\n@@ -732,1 +743,2 @@\n-                if ((c & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)\n+            } else {\n+                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))\n@@ -736,1 +748,1 @@\n-                c = (utf[0] & 0x7) << 18;\n+                c = (c & 0x7) << 18;\n@@ -740,6 +752,2 @@\n-            } else {\n-              \/* 3-byte code *\/\n-                *len = 3;\n-                c = (utf[0] & 0xf) << 12;\n-                c |= (utf[1] & 0x3f) << 6;\n-                c |= utf[2] & 0x3f;\n+                if ((c < 0x10000) || (c >= 0x110000))\n+                    goto error;\n@@ -747,5 +755,0 @@\n-        } else {\n-          \/* 2-byte code *\/\n-            *len = 2;\n-            c = (utf[0] & 0x1f) << 6;\n-            c |= utf[1] & 0x3f;\n@@ -753,3 +756,0 @@\n-    } else {\n-        \/* 1-byte code *\/\n-        *len = 1;\n@@ -874,1 +874,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic(((size_t) i + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMallocAtomic((size_t) i + 1);\n@@ -878,1 +878,1 @@\n-    memcpy(ret, utf, i * sizeof(xmlChar));\n+    memcpy(ret, utf, i);\n@@ -1025,1 +1025,1 @@\n-    result = (xmlChar *) xmlMallocAtomic(resultLen * sizeof(xmlChar));\n+    result = (xmlChar *) xmlMallocAtomic(resultLen);\n@@ -1031,1 +1031,0 @@\n-        xmlErrMemory(NULL, NULL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlstring.c","additions":42,"deletions":43,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+#include <libxml\/SAX2.h>\n@@ -24,3 +25,4 @@\n-#include \"buf.h\"\n-#include \"enc.h\"\n-#include \"save.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/enc.h\"\n+#include \"private\/error.h\"\n+#include \"private\/save.h\"\n@@ -191,1 +193,1 @@\n-    memset(ret, 0, (size_t) sizeof(xmlTextWriter));\n+    memset(ret, 0, sizeof(xmlTextWriter));\n@@ -711,1 +713,5 @@\n-    sum += xmlTextWriterFlush(writer);\n+    count = xmlTextWriterFlush(writer);\n+    if (count < 0)\n+        return -1;\n+    sum += count;\n+\n@@ -866,1 +872,1 @@\n-int XMLCDECL\n+int\n@@ -1294,1 +1300,1 @@\n-int XMLCDECL\n+int\n@@ -1420,1 +1426,1 @@\n-int XMLCDECL\n+int\n@@ -1966,1 +1972,1 @@\n-int XMLCDECL\n+int\n@@ -2061,1 +2067,1 @@\n-int XMLCDECL\n+int\n@@ -2169,1 +2175,1 @@\n-int XMLCDECL\n+int\n@@ -2266,1 +2272,1 @@\n-int XMLCDECL\n+int\n@@ -2523,1 +2529,1 @@\n-int XMLCDECL\n+int\n@@ -2738,1 +2744,1 @@\n-int XMLCDECL\n+int\n@@ -3047,1 +3053,1 @@\n-int XMLCDECL\n+int\n@@ -3291,1 +3297,1 @@\n-int XMLCDECL\n+int\n@@ -3528,1 +3534,1 @@\n-int XMLCDECL\n+int\n@@ -3786,1 +3792,1 @@\n-int XMLCDECL\n+int\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlwriter.c","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include <libxml\/valid.h>\n@@ -47,1 +46,0 @@\n-#include <libxml\/globals.h>\n@@ -52,1 +50,3 @@\n-#include \"buf.h\"\n+#include \"private\/buf.h\"\n+#include \"private\/error.h\"\n+#include \"private\/xpath.h\"\n@@ -90,7 +90,0 @@\n-\/*\n-* XP_DEBUG_OBJ_USAGE:\n-* Internal flag to enable tracking of how much XPath objects have been\n-* created.\n-*\/\n-\/* #define XP_DEBUG_OBJ_USAGE *\/\n-\n@@ -132,0 +125,3 @@\n+#elif defined(_WIN32)\n+\/* Windows typically limits stack size to 1MB. *\/\n+#define XPATH_MAX_RECURSION_DEPTH 1000\n@@ -143,0 +139,110 @@\n+#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+\n+\/************************************************************************\n+ *                                                                      *\n+ *                      Floating point stuff                            *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n+double xmlXPathNAN = 0.0;\n+double xmlXPathPINF = 0.0;\n+double xmlXPathNINF = 0.0;\n+\n+\/**\n+ * xmlXPathInit:\n+ *\n+ * DEPRECATED: Alias for xmlInitParser.\n+ *\/\n+void\n+xmlXPathInit(void) {\n+    xmlInitParser();\n+}\n+\n+\/**\n+ * xmlInitXPathInternal:\n+ *\n+ * Initialize the XPath environment\n+ *\/\n+ATTRIBUTE_NO_SANITIZE(\"float-divide-by-zero\")\n+void\n+xmlInitXPathInternal(void) {\n+#if defined(NAN) && defined(INFINITY)\n+    xmlXPathNAN = NAN;\n+    xmlXPathPINF = INFINITY;\n+    xmlXPathNINF = -INFINITY;\n+#else\n+    \/* MSVC doesn't allow division by zero in constant expressions. *\/\n+    double zero = 0.0;\n+    xmlXPathNAN = 0.0 \/ zero;\n+    xmlXPathPINF = 1.0 \/ zero;\n+    xmlXPathNINF = -xmlXPathPINF;\n+#endif\n+}\n+\n+\/**\n+ * xmlXPathIsNaN:\n+ * @val:  a double value\n+ *\n+ * Checks whether a double is a NaN.\n+ *\n+ * Returns 1 if the value is a NaN, 0 otherwise\n+ *\/\n+int\n+xmlXPathIsNaN(double val) {\n+#ifdef isnan\n+    return isnan(val);\n+#else\n+    return !(val == val);\n+#endif\n+}\n+\n+\/**\n+ * xmlXPathIsInf:\n+ * @val:  a double value\n+ *\n+ * Checks whether a double is an infinity.\n+ *\n+ * Returns 1 if the value is +Infinite, -1 if -Infinite, 0 otherwise\n+ *\/\n+int\n+xmlXPathIsInf(double val) {\n+#ifdef isinf\n+    return isinf(val) ? (val > 0 ? 1 : -1) : 0;\n+#else\n+    if (val >= xmlXPathPINF)\n+        return 1;\n+    if (val <= -xmlXPathPINF)\n+        return -1;\n+    return 0;\n+#endif\n+}\n+\n+#endif \/* SCHEMAS or XPATH *\/\n+\n+#ifdef LIBXML_XPATH_ENABLED\n+\n+\/*\n+ * TODO: when compatibility allows remove all \"fake node libxslt\" strings\n+ *       the test should just be name[0] = ' '\n+ *\/\n+\n+static xmlNs xmlXPathXMLNamespaceStruct = {\n+    NULL,\n+    XML_NAMESPACE_DECL,\n+    XML_XML_NAMESPACE,\n+    BAD_CAST \"xml\",\n+    NULL,\n+    NULL\n+};\n+static xmlNsPtr xmlXPathXMLNamespace = &xmlXPathXMLNamespaceStruct;\n+#ifndef LIBXML_THREAD_ENABLED\n+\/*\n+ * Optimizer is disabled only when threaded apps are detected while\n+ * the library ain't compiled for thread safety.\n+ *\/\n+static int xmlXPathDisableOptimizer = 0;\n+#endif\n+\n+static void\n+xmlXPathNodeSetClear(xmlNodeSetPtr set, int hasNsNodes);\n+\n@@ -470,101 +576,0 @@\n-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n-\n-\/************************************************************************\n- *                                                                      *\n- *                      Floating point stuff                            *\n- *                                                                      *\n- ************************************************************************\/\n-\n-double xmlXPathNAN = 0.0;\n-double xmlXPathPINF = 0.0;\n-double xmlXPathNINF = 0.0;\n-\n-\/**\n- * xmlXPathInit:\n- *\n- * DEPRECATED: This function will be made private. Call xmlInitParser to\n- * initialize the library.\n- *\n- * Initialize the XPath environment\n- *\/\n-ATTRIBUTE_NO_SANITIZE(\"float-divide-by-zero\")\n-void\n-xmlXPathInit(void) {\n-#if defined(NAN) && defined(INFINITY)\n-    xmlXPathNAN = NAN;\n-    xmlXPathPINF = INFINITY;\n-    xmlXPathNINF = -INFINITY;\n-#else\n-    \/* MSVC doesn't allow division by zero in constant expressions. *\/\n-    double zero = 0.0;\n-    xmlXPathNAN = 0.0 \/ zero;\n-    xmlXPathPINF = 1.0 \/ zero;\n-    xmlXPathNINF = -xmlXPathPINF;\n-#endif\n-}\n-\n-\/**\n- * xmlXPathIsNaN:\n- * @val:  a double value\n- *\n- * Returns 1 if the value is a NaN, 0 otherwise\n- *\/\n-int\n-xmlXPathIsNaN(double val) {\n-#ifdef isnan\n-    return isnan(val);\n-#else\n-    return !(val == val);\n-#endif\n-}\n-\n-\/**\n- * xmlXPathIsInf:\n- * @val:  a double value\n- *\n- * Returns 1 if the value is +Infinite, -1 if -Infinite, 0 otherwise\n- *\/\n-int\n-xmlXPathIsInf(double val) {\n-#ifdef isinf\n-    return isinf(val) ? (val > 0 ? 1 : -1) : 0;\n-#else\n-    if (val >= xmlXPathPINF)\n-        return 1;\n-    if (val <= -xmlXPathPINF)\n-        return -1;\n-    return 0;\n-#endif\n-}\n-\n-#endif \/* SCHEMAS or XPATH *\/\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-\n-\/*\n- * TODO: when compatibility allows remove all \"fake node libxslt\" strings\n- *       the test should just be name[0] = ' '\n- *\/\n-#ifdef DEBUG_XPATH_EXPRESSION\n-#define DEBUG_STEP\n-#define DEBUG_EXPR\n-#define DEBUG_EVAL_COUNTS\n-#endif\n-\n-static xmlNs xmlXPathXMLNamespaceStruct = {\n-    NULL,\n-    XML_NAMESPACE_DECL,\n-    XML_XML_NAMESPACE,\n-    BAD_CAST \"xml\",\n-    NULL,\n-    NULL\n-};\n-static xmlNsPtr xmlXPathXMLNamespace = &xmlXPathXMLNamespaceStruct;\n-#ifndef LIBXML_THREAD_ENABLED\n-\/*\n- * Optimizer is disabled only when threaded apps are detected while\n- * the library ain't compiled for thread safety.\n- *\/\n-static int xmlXPathDisableOptimizer = 0;\n-#endif\n-\n@@ -703,0 +708,3 @@\n+    \/* Only report the first error *\/\n+    if (ctxt->error != 0)\n+        return;\n@@ -808,16 +816,15 @@\n-    if (list->items == NULL) {\n-        if (initialSize <= 0)\n-            initialSize = 1;\n-        list->items = (void **) xmlMalloc(initialSize * sizeof(void *));\n-        if (list->items == NULL) {\n-            xmlXPathErrMemory(NULL,\n-                \"xmlPointerListCreate: allocating item\\n\");\n-            return(-1);\n-        }\n-        list->number = 0;\n-        list->size = initialSize;\n-    } else if (list->size <= list->number) {\n-        if (list->size > 50000000) {\n-            xmlXPathErrMemory(NULL,\n-                \"xmlPointerListAddSize: re-allocating item\\n\");\n-            return(-1);\n+    if (list->size <= list->number) {\n+        void **tmp;\n+        size_t newSize;\n+\n+        if (list->size == 0) {\n+            if (initialSize <= 0)\n+                initialSize = 1;\n+            newSize = initialSize;\n+        } else {\n+            if (list->size > 50000000) {\n+                xmlXPathErrMemory(NULL,\n+                    \"xmlPointerListAddSize: re-allocating item\\n\");\n+                return(-1);\n+            }\n+            newSize = list->size * 2;\n@@ -825,4 +832,2 @@\n-        list->size *= 2;\n-        list->items = (void **) xmlRealloc(list->items,\n-            list->size * sizeof(void *));\n-        if (list->items == NULL) {\n+        tmp = (void **) xmlRealloc(list->items, newSize * sizeof(void *));\n+        if (tmp == NULL) {\n@@ -831,1 +836,0 @@\n-            list->size = 0;\n@@ -834,0 +838,2 @@\n+        list->items = tmp;\n+        list->size = newSize;\n@@ -969,4 +975,0 @@\n-#ifdef DEBUG_EVAL_COUNTS\n-    int nb;\n-    xmlChar *string;\n-#endif\n@@ -1031,3 +1033,0 @@\n-#ifdef DEBUG_EVAL_COUNTS\n-    cur->nb = 0;\n-#endif\n@@ -1076,5 +1075,0 @@\n-#ifdef DEBUG_EVAL_COUNTS\n-    if (comp->string != NULL) {\n-        xmlFree(comp->string);\n-    }\n-#endif\n@@ -1227,27 +1221,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    int dbgCachedAll;\n-    int dbgCachedNodeset;\n-    int dbgCachedString;\n-    int dbgCachedBool;\n-    int dbgCachedNumber;\n-    int dbgCachedPoint;\n-    int dbgCachedRange;\n-    int dbgCachedLocset;\n-    int dbgCachedUsers;\n-    int dbgCachedXSLTTree;\n-    int dbgCachedUndefined;\n-\n-\n-    int dbgReusedAll;\n-    int dbgReusedNodeset;\n-    int dbgReusedString;\n-    int dbgReusedBool;\n-    int dbgReusedNumber;\n-    int dbgReusedPoint;\n-    int dbgReusedRange;\n-    int dbgReusedLocset;\n-    int dbgReusedUsers;\n-    int dbgReusedXSLTTree;\n-    int dbgReusedUndefined;\n-\n-#endif\n@@ -1710,472 +1677,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-\n-\/*\n-* XPath object usage related debugging variables.\n-*\/\n-static int xmlXPathDebugObjCounterUndefined = 0;\n-static int xmlXPathDebugObjCounterNodeset = 0;\n-static int xmlXPathDebugObjCounterBool = 0;\n-static int xmlXPathDebugObjCounterNumber = 0;\n-static int xmlXPathDebugObjCounterString = 0;\n-static int xmlXPathDebugObjCounterPoint = 0;\n-static int xmlXPathDebugObjCounterRange = 0;\n-static int xmlXPathDebugObjCounterLocset = 0;\n-static int xmlXPathDebugObjCounterUsers = 0;\n-static int xmlXPathDebugObjCounterXSLTTree = 0;\n-static int xmlXPathDebugObjCounterAll = 0;\n-\n-static int xmlXPathDebugObjTotalUndefined = 0;\n-static int xmlXPathDebugObjTotalNodeset = 0;\n-static int xmlXPathDebugObjTotalBool = 0;\n-static int xmlXPathDebugObjTotalNumber = 0;\n-static int xmlXPathDebugObjTotalString = 0;\n-static int xmlXPathDebugObjTotalPoint = 0;\n-static int xmlXPathDebugObjTotalRange = 0;\n-static int xmlXPathDebugObjTotalLocset = 0;\n-static int xmlXPathDebugObjTotalUsers = 0;\n-static int xmlXPathDebugObjTotalXSLTTree = 0;\n-static int xmlXPathDebugObjTotalAll = 0;\n-\n-static int xmlXPathDebugObjMaxUndefined = 0;\n-static int xmlXPathDebugObjMaxNodeset = 0;\n-static int xmlXPathDebugObjMaxBool = 0;\n-static int xmlXPathDebugObjMaxNumber = 0;\n-static int xmlXPathDebugObjMaxString = 0;\n-static int xmlXPathDebugObjMaxPoint = 0;\n-static int xmlXPathDebugObjMaxRange = 0;\n-static int xmlXPathDebugObjMaxLocset = 0;\n-static int xmlXPathDebugObjMaxUsers = 0;\n-static int xmlXPathDebugObjMaxXSLTTree = 0;\n-static int xmlXPathDebugObjMaxAll = 0;\n-\n-static void\n-xmlXPathDebugObjUsageReset(xmlXPathContextPtr ctxt)\n-{\n-    if (ctxt != NULL) {\n-        if (ctxt->cache != NULL) {\n-            xmlXPathContextCachePtr cache =\n-                (xmlXPathContextCachePtr) ctxt->cache;\n-\n-            cache->dbgCachedAll = 0;\n-            cache->dbgCachedNodeset = 0;\n-            cache->dbgCachedString = 0;\n-            cache->dbgCachedBool = 0;\n-            cache->dbgCachedNumber = 0;\n-            cache->dbgCachedPoint = 0;\n-            cache->dbgCachedRange = 0;\n-            cache->dbgCachedLocset = 0;\n-            cache->dbgCachedUsers = 0;\n-            cache->dbgCachedXSLTTree = 0;\n-            cache->dbgCachedUndefined = 0;\n-\n-            cache->dbgReusedAll = 0;\n-            cache->dbgReusedNodeset = 0;\n-            cache->dbgReusedString = 0;\n-            cache->dbgReusedBool = 0;\n-            cache->dbgReusedNumber = 0;\n-            cache->dbgReusedPoint = 0;\n-            cache->dbgReusedRange = 0;\n-            cache->dbgReusedLocset = 0;\n-            cache->dbgReusedUsers = 0;\n-            cache->dbgReusedXSLTTree = 0;\n-            cache->dbgReusedUndefined = 0;\n-        }\n-    }\n-\n-    xmlXPathDebugObjCounterUndefined = 0;\n-    xmlXPathDebugObjCounterNodeset = 0;\n-    xmlXPathDebugObjCounterBool = 0;\n-    xmlXPathDebugObjCounterNumber = 0;\n-    xmlXPathDebugObjCounterString = 0;\n-    xmlXPathDebugObjCounterPoint = 0;\n-    xmlXPathDebugObjCounterRange = 0;\n-    xmlXPathDebugObjCounterLocset = 0;\n-    xmlXPathDebugObjCounterUsers = 0;\n-    xmlXPathDebugObjCounterXSLTTree = 0;\n-    xmlXPathDebugObjCounterAll = 0;\n-\n-    xmlXPathDebugObjTotalUndefined = 0;\n-    xmlXPathDebugObjTotalNodeset = 0;\n-    xmlXPathDebugObjTotalBool = 0;\n-    xmlXPathDebugObjTotalNumber = 0;\n-    xmlXPathDebugObjTotalString = 0;\n-    xmlXPathDebugObjTotalPoint = 0;\n-    xmlXPathDebugObjTotalRange = 0;\n-    xmlXPathDebugObjTotalLocset = 0;\n-    xmlXPathDebugObjTotalUsers = 0;\n-    xmlXPathDebugObjTotalXSLTTree = 0;\n-    xmlXPathDebugObjTotalAll = 0;\n-\n-    xmlXPathDebugObjMaxUndefined = 0;\n-    xmlXPathDebugObjMaxNodeset = 0;\n-    xmlXPathDebugObjMaxBool = 0;\n-    xmlXPathDebugObjMaxNumber = 0;\n-    xmlXPathDebugObjMaxString = 0;\n-    xmlXPathDebugObjMaxPoint = 0;\n-    xmlXPathDebugObjMaxRange = 0;\n-    xmlXPathDebugObjMaxLocset = 0;\n-    xmlXPathDebugObjMaxUsers = 0;\n-    xmlXPathDebugObjMaxXSLTTree = 0;\n-    xmlXPathDebugObjMaxAll = 0;\n-\n-}\n-\n-static void\n-xmlXPathDebugObjUsageRequested(xmlXPathContextPtr ctxt,\n-                              xmlXPathObjectType objType)\n-{\n-    int isCached = 0;\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->cache != NULL) {\n-            xmlXPathContextCachePtr cache =\n-                (xmlXPathContextCachePtr) ctxt->cache;\n-\n-            isCached = 1;\n-\n-            cache->dbgReusedAll++;\n-            switch (objType) {\n-                case XPATH_UNDEFINED:\n-                    cache->dbgReusedUndefined++;\n-                    break;\n-                case XPATH_NODESET:\n-                    cache->dbgReusedNodeset++;\n-                    break;\n-                case XPATH_BOOLEAN:\n-                    cache->dbgReusedBool++;\n-                    break;\n-                case XPATH_NUMBER:\n-                    cache->dbgReusedNumber++;\n-                    break;\n-                case XPATH_STRING:\n-                    cache->dbgReusedString++;\n-                    break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                case XPATH_POINT:\n-                    cache->dbgReusedPoint++;\n-                    break;\n-                case XPATH_RANGE:\n-                    cache->dbgReusedRange++;\n-                    break;\n-                case XPATH_LOCATIONSET:\n-                    cache->dbgReusedLocset++;\n-                    break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-                case XPATH_USERS:\n-                    cache->dbgReusedUsers++;\n-                    break;\n-                case XPATH_XSLT_TREE:\n-                    cache->dbgReusedXSLTTree++;\n-                    break;\n-                default:\n-                    break;\n-            }\n-        }\n-    }\n-\n-    switch (objType) {\n-        case XPATH_UNDEFINED:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalUndefined++;\n-            xmlXPathDebugObjCounterUndefined++;\n-            if (xmlXPathDebugObjCounterUndefined >\n-                xmlXPathDebugObjMaxUndefined)\n-                xmlXPathDebugObjMaxUndefined =\n-                    xmlXPathDebugObjCounterUndefined;\n-            break;\n-        case XPATH_NODESET:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalNodeset++;\n-            xmlXPathDebugObjCounterNodeset++;\n-            if (xmlXPathDebugObjCounterNodeset >\n-                xmlXPathDebugObjMaxNodeset)\n-                xmlXPathDebugObjMaxNodeset =\n-                    xmlXPathDebugObjCounterNodeset;\n-            break;\n-        case XPATH_BOOLEAN:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalBool++;\n-            xmlXPathDebugObjCounterBool++;\n-            if (xmlXPathDebugObjCounterBool >\n-                xmlXPathDebugObjMaxBool)\n-                xmlXPathDebugObjMaxBool =\n-                    xmlXPathDebugObjCounterBool;\n-            break;\n-        case XPATH_NUMBER:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalNumber++;\n-            xmlXPathDebugObjCounterNumber++;\n-            if (xmlXPathDebugObjCounterNumber >\n-                xmlXPathDebugObjMaxNumber)\n-                xmlXPathDebugObjMaxNumber =\n-                    xmlXPathDebugObjCounterNumber;\n-            break;\n-        case XPATH_STRING:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalString++;\n-            xmlXPathDebugObjCounterString++;\n-            if (xmlXPathDebugObjCounterString >\n-                xmlXPathDebugObjMaxString)\n-                xmlXPathDebugObjMaxString =\n-                    xmlXPathDebugObjCounterString;\n-            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalPoint++;\n-            xmlXPathDebugObjCounterPoint++;\n-            if (xmlXPathDebugObjCounterPoint >\n-                xmlXPathDebugObjMaxPoint)\n-                xmlXPathDebugObjMaxPoint =\n-                    xmlXPathDebugObjCounterPoint;\n-            break;\n-        case XPATH_RANGE:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalRange++;\n-            xmlXPathDebugObjCounterRange++;\n-            if (xmlXPathDebugObjCounterRange >\n-                xmlXPathDebugObjMaxRange)\n-                xmlXPathDebugObjMaxRange =\n-                    xmlXPathDebugObjCounterRange;\n-            break;\n-        case XPATH_LOCATIONSET:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalLocset++;\n-            xmlXPathDebugObjCounterLocset++;\n-            if (xmlXPathDebugObjCounterLocset >\n-                xmlXPathDebugObjMaxLocset)\n-                xmlXPathDebugObjMaxLocset =\n-                    xmlXPathDebugObjCounterLocset;\n-            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        case XPATH_USERS:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalUsers++;\n-            xmlXPathDebugObjCounterUsers++;\n-            if (xmlXPathDebugObjCounterUsers >\n-                xmlXPathDebugObjMaxUsers)\n-                xmlXPathDebugObjMaxUsers =\n-                    xmlXPathDebugObjCounterUsers;\n-            break;\n-        case XPATH_XSLT_TREE:\n-            if (! isCached)\n-                xmlXPathDebugObjTotalXSLTTree++;\n-            xmlXPathDebugObjCounterXSLTTree++;\n-            if (xmlXPathDebugObjCounterXSLTTree >\n-                xmlXPathDebugObjMaxXSLTTree)\n-                xmlXPathDebugObjMaxXSLTTree =\n-                    xmlXPathDebugObjCounterXSLTTree;\n-            break;\n-        default:\n-            break;\n-    }\n-    if (! isCached)\n-        xmlXPathDebugObjTotalAll++;\n-    xmlXPathDebugObjCounterAll++;\n-    if (xmlXPathDebugObjCounterAll >\n-        xmlXPathDebugObjMaxAll)\n-        xmlXPathDebugObjMaxAll =\n-            xmlXPathDebugObjCounterAll;\n-}\n-\n-static void\n-xmlXPathDebugObjUsageReleased(xmlXPathContextPtr ctxt,\n-                              xmlXPathObjectType objType)\n-{\n-    int isCached = 0;\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->cache != NULL) {\n-            xmlXPathContextCachePtr cache =\n-                (xmlXPathContextCachePtr) ctxt->cache;\n-\n-            isCached = 1;\n-\n-            cache->dbgCachedAll++;\n-            switch (objType) {\n-                case XPATH_UNDEFINED:\n-                    cache->dbgCachedUndefined++;\n-                    break;\n-                case XPATH_NODESET:\n-                    cache->dbgCachedNodeset++;\n-                    break;\n-                case XPATH_BOOLEAN:\n-                    cache->dbgCachedBool++;\n-                    break;\n-                case XPATH_NUMBER:\n-                    cache->dbgCachedNumber++;\n-                    break;\n-                case XPATH_STRING:\n-                    cache->dbgCachedString++;\n-                    break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                case XPATH_POINT:\n-                    cache->dbgCachedPoint++;\n-                    break;\n-                case XPATH_RANGE:\n-                    cache->dbgCachedRange++;\n-                    break;\n-                case XPATH_LOCATIONSET:\n-                    cache->dbgCachedLocset++;\n-                    break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-                case XPATH_USERS:\n-                    cache->dbgCachedUsers++;\n-                    break;\n-                case XPATH_XSLT_TREE:\n-                    cache->dbgCachedXSLTTree++;\n-                    break;\n-                default:\n-                    break;\n-            }\n-\n-        }\n-    }\n-    switch (objType) {\n-        case XPATH_UNDEFINED:\n-            xmlXPathDebugObjCounterUndefined--;\n-            break;\n-        case XPATH_NODESET:\n-            xmlXPathDebugObjCounterNodeset--;\n-            break;\n-        case XPATH_BOOLEAN:\n-            xmlXPathDebugObjCounterBool--;\n-            break;\n-        case XPATH_NUMBER:\n-            xmlXPathDebugObjCounterNumber--;\n-            break;\n-        case XPATH_STRING:\n-            xmlXPathDebugObjCounterString--;\n-            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-            xmlXPathDebugObjCounterPoint--;\n-            break;\n-        case XPATH_RANGE:\n-            xmlXPathDebugObjCounterRange--;\n-            break;\n-        case XPATH_LOCATIONSET:\n-            xmlXPathDebugObjCounterLocset--;\n-            break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        case XPATH_USERS:\n-            xmlXPathDebugObjCounterUsers--;\n-            break;\n-        case XPATH_XSLT_TREE:\n-            xmlXPathDebugObjCounterXSLTTree--;\n-            break;\n-        default:\n-            break;\n-    }\n-    xmlXPathDebugObjCounterAll--;\n-}\n-\n-static void\n-xmlXPathDebugObjUsageDisplay(xmlXPathContextPtr ctxt)\n-{\n-    int reqAll, reqNodeset, reqString, reqBool, reqNumber,\n-        reqXSLTTree, reqUndefined;\n-    int caAll = 0, caNodeset = 0, caString = 0, caBool = 0,\n-        caNumber = 0, caXSLTTree = 0, caUndefined = 0;\n-    int reAll = 0, reNodeset = 0, reString = 0, reBool = 0,\n-        reNumber = 0, reXSLTTree = 0, reUndefined = 0;\n-    int leftObjs = xmlXPathDebugObjCounterAll;\n-\n-    reqAll = xmlXPathDebugObjTotalAll;\n-    reqNodeset = xmlXPathDebugObjTotalNodeset;\n-    reqString = xmlXPathDebugObjTotalString;\n-    reqBool = xmlXPathDebugObjTotalBool;\n-    reqNumber = xmlXPathDebugObjTotalNumber;\n-    reqXSLTTree = xmlXPathDebugObjTotalXSLTTree;\n-    reqUndefined = xmlXPathDebugObjTotalUndefined;\n-\n-    printf(\"# XPath object usage:\\n\");\n-\n-    if (ctxt != NULL) {\n-        if (ctxt->cache != NULL) {\n-            xmlXPathContextCachePtr cache =\n-                (xmlXPathContextCachePtr) ctxt->cache;\n-\n-            reAll = cache->dbgReusedAll;\n-            reqAll += reAll;\n-            reNodeset = cache->dbgReusedNodeset;\n-            reqNodeset += reNodeset;\n-            reString = cache->dbgReusedString;\n-            reqString += reString;\n-            reBool = cache->dbgReusedBool;\n-            reqBool += reBool;\n-            reNumber = cache->dbgReusedNumber;\n-            reqNumber += reNumber;\n-            reXSLTTree = cache->dbgReusedXSLTTree;\n-            reqXSLTTree += reXSLTTree;\n-            reUndefined = cache->dbgReusedUndefined;\n-            reqUndefined += reUndefined;\n-\n-            caAll = cache->dbgCachedAll;\n-            caBool = cache->dbgCachedBool;\n-            caNodeset = cache->dbgCachedNodeset;\n-            caString = cache->dbgCachedString;\n-            caNumber = cache->dbgCachedNumber;\n-            caXSLTTree = cache->dbgCachedXSLTTree;\n-            caUndefined = cache->dbgCachedUndefined;\n-\n-            if (cache->nodesetObjs)\n-                leftObjs -= cache->nodesetObjs->number;\n-            if (cache->stringObjs)\n-                leftObjs -= cache->stringObjs->number;\n-            if (cache->booleanObjs)\n-                leftObjs -= cache->booleanObjs->number;\n-            if (cache->numberObjs)\n-                leftObjs -= cache->numberObjs->number;\n-            if (cache->miscObjs)\n-                leftObjs -= cache->miscObjs->number;\n-        }\n-    }\n-\n-    printf(\"# all\\n\");\n-    printf(\"#   total  : %d\\n\", reqAll);\n-    printf(\"#   left  : %d\\n\", leftObjs);\n-    printf(\"#   created: %d\\n\", xmlXPathDebugObjTotalAll);\n-    printf(\"#   reused : %d\\n\", reAll);\n-    printf(\"#   max    : %d\\n\", xmlXPathDebugObjMaxAll);\n-\n-    printf(\"# node-sets\\n\");\n-    printf(\"#   total  : %d\\n\", reqNodeset);\n-    printf(\"#   created: %d\\n\", xmlXPathDebugObjTotalNodeset);\n-    printf(\"#   reused : %d\\n\", reNodeset);\n-    printf(\"#   max    : %d\\n\", xmlXPathDebugObjMaxNodeset);\n-\n-    printf(\"# strings\\n\");\n-    printf(\"#   total  : %d\\n\", reqString);\n-    printf(\"#   created: %d\\n\", xmlXPathDebugObjTotalString);\n-    printf(\"#   reused : %d\\n\", reString);\n-    printf(\"#   max    : %d\\n\", xmlXPathDebugObjMaxString);\n-\n-    printf(\"# booleans\\n\");\n-    printf(\"#   total  : %d\\n\", reqBool);\n-    printf(\"#   created: %d\\n\", xmlXPathDebugObjTotalBool);\n-    printf(\"#   reused : %d\\n\", reBool);\n-    printf(\"#   max    : %d\\n\", xmlXPathDebugObjMaxBool);\n-\n-    printf(\"# numbers\\n\");\n-    printf(\"#   total  : %d\\n\", reqNumber);\n-    printf(\"#   created: %d\\n\", xmlXPathDebugObjTotalNumber);\n-    printf(\"#   reused : %d\\n\", reNumber);\n-    printf(\"#   max    : %d\\n\", xmlXPathDebugObjMaxNumber);\n-\n-    printf(\"# XSLT result tree fragments\\n\");\n-    printf(\"#   total  : %d\\n\", reqXSLTTree);\n-    printf(\"#   created: %d\\n\", xmlXPathDebugObjTotalXSLTTree);\n-    printf(\"#   reused : %d\\n\", reXSLTTree);\n-    printf(\"#   max    : %d\\n\", xmlXPathDebugObjMaxXSLTTree);\n-\n-    printf(\"# undefined\\n\");\n-    printf(\"#   total  : %d\\n\", reqUndefined);\n-    printf(\"#   created: %d\\n\", xmlXPathDebugObjTotalUndefined);\n-    printf(\"#   reused : %d\\n\", reUndefined);\n-    printf(\"#   max    : %d\\n\", xmlXPathDebugObjMaxUndefined);\n-\n-}\n-\n-#endif \/* XP_DEBUG_OBJ_USAGE *\/\n-\n@@ -2207,1 +1702,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathContextCache));\n+    memset(ret, 0 , sizeof(xmlXPathContextCache));\n@@ -2237,3 +1732,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-        xmlXPathDebugObjCounterAll--;\n-#endif\n@@ -2326,0 +1818,2 @@\n+ *\n+ * In case of error the node set is destroyed and NULL is returned.\n@@ -2343,3 +1837,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n-#endif\n@@ -2380,3 +1871,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n-#endif\n@@ -2396,3 +1884,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n-#endif\n@@ -2444,3 +1929,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n-#endif\n@@ -2452,0 +1934,1 @@\n+            xmlNodeSetPtr set;\n@@ -2456,0 +1939,7 @@\n+            set = xmlXPathNodeSetCreate(val);\n+            if (set == NULL) {\n+                ctxt->lastError.domain = XML_FROM_XPATH;\n+                ctxt->lastError.code = XML_ERR_NO_MEMORY;\n+                return(NULL);\n+            }\n+\n@@ -2461,9 +1951,1 @@\n-            ret->nodesetval = xmlXPathNodeSetCreate(val);\n-            if (ret->nodesetval == NULL) {\n-                ctxt->lastError.domain = XML_FROM_XPATH;\n-                ctxt->lastError.code = XML_ERR_NO_MEMORY;\n-                return(NULL);\n-            }\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n-#endif\n+            ret->nodesetval = set;\n@@ -2477,1 +1959,1 @@\n- * xmlXPathCacheNewCString:\n+ * xmlXPathCacheNewString:\n@@ -2479,1 +1961,1 @@\n- * @val:  the char * value\n+ * @val:  the xmlChar * value\n@@ -2481,1 +1963,1 @@\n- * This is the cached version of xmlXPathNewCString().\n+ * This is the cached version of xmlXPathNewString().\n@@ -2487,1 +1969,1 @@\n-xmlXPathCacheNewCString(xmlXPathContextPtr ctxt, const char *val)\n+xmlXPathCacheNewString(xmlXPathContextPtr ctxt, const xmlChar *val)\n@@ -2496,0 +1978,9 @@\n+            xmlChar *copy;\n+\n+            if (val == NULL)\n+                val = BAD_CAST \"\";\n+            copy = xmlStrdup(val);\n+            if (copy == NULL) {\n+                xmlXPathErrMemory(ctxt, NULL);\n+                return(NULL);\n+            }\n@@ -2499,1 +1990,0 @@\n-\n@@ -2501,4 +1991,1 @@\n-            ret->stringval = xmlStrdup(BAD_CAST val);\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n-#endif\n+            ret->stringval = copy;\n@@ -2510,0 +1997,9 @@\n+            xmlChar *copy;\n+\n+            if (val == NULL)\n+                val = BAD_CAST \"\";\n+            copy = xmlStrdup(val);\n+            if (copy == NULL) {\n+                xmlXPathErrMemory(ctxt, NULL);\n+                return(NULL);\n+            }\n@@ -2515,4 +2011,1 @@\n-            ret->stringval = xmlStrdup(BAD_CAST val);\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n-#endif\n+            ret->stringval = copy;\n@@ -2522,1 +2015,1 @@\n-    return(xmlXPathNewCString(val));\n+    return(xmlXPathNewString(val));\n@@ -2526,1 +2019,1 @@\n- * xmlXPathCacheNewString:\n+ * xmlXPathCacheNewCString:\n@@ -2528,1 +2021,1 @@\n- * @val:  the xmlChar * value\n+ * @val:  the char * value\n@@ -2530,1 +2023,1 @@\n- * This is the cached version of xmlXPathNewString().\n+ * This is the cached version of xmlXPathNewCString().\n@@ -2536,1 +2029,1 @@\n-xmlXPathCacheNewString(xmlXPathContextPtr ctxt, const xmlChar *val)\n+xmlXPathCacheNewCString(xmlXPathContextPtr ctxt, const char *val)\n@@ -2538,39 +2031,1 @@\n-    if ((ctxt != NULL) && (ctxt->cache)) {\n-        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n-\n-        if ((cache->stringObjs != NULL) &&\n-            (cache->stringObjs->number != 0))\n-        {\n-            xmlXPathObjectPtr ret;\n-\n-            ret = (xmlXPathObjectPtr)\n-                cache->stringObjs->items[--cache->stringObjs->number];\n-            ret->type = XPATH_STRING;\n-            if (val != NULL)\n-                ret->stringval = xmlStrdup(val);\n-            else\n-                ret->stringval = xmlStrdup((const xmlChar *)\"\");\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n-#endif\n-            return(ret);\n-        } else if ((cache->miscObjs != NULL) &&\n-            (cache->miscObjs->number != 0))\n-        {\n-            xmlXPathObjectPtr ret;\n-\n-            ret = (xmlXPathObjectPtr)\n-                cache->miscObjs->items[--cache->miscObjs->number];\n-\n-            ret->type = XPATH_STRING;\n-            if (val != NULL)\n-                ret->stringval = xmlStrdup(val);\n-            else\n-                ret->stringval = xmlStrdup((const xmlChar *)\"\");\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n-#endif\n-            return(ret);\n-        }\n-    }\n-    return(xmlXPathNewString(val));\n+    return xmlXPathCacheNewString(ctxt, BAD_CAST val);\n@@ -2604,3 +2059,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);\n-#endif\n@@ -2618,3 +2070,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);\n-#endif\n@@ -2652,3 +2101,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);\n-#endif\n@@ -2666,3 +2112,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);\n-#endif\n@@ -2696,3 +2139,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext, \"STRING: undefined\\n\");\n-#endif\n@@ -2815,36 +2255,0 @@\n-\/**\n- * xmlXPathSetFrame:\n- * @ctxt: an XPath parser context\n- *\n- * Set the callee evaluation frame\n- *\n- * Returns the previous frame value to be restored once done\n- *\/\n-static int\n-xmlXPathSetFrame(xmlXPathParserContextPtr ctxt) {\n-    int ret;\n-\n-    if (ctxt == NULL)\n-        return(0);\n-    ret = ctxt->valueFrame;\n-    ctxt->valueFrame = ctxt->valueNr;\n-    return(ret);\n-}\n-\n-\/**\n- * xmlXPathPopFrame:\n- * @ctxt: an XPath parser context\n- * @frame: the previous frame value\n- *\n- * Remove the callee evaluation frame\n- *\/\n-static void\n-xmlXPathPopFrame(xmlXPathParserContextPtr ctxt, int frame) {\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->valueNr < ctxt->valueFrame) {\n-        xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_STACK_ERROR);\n-    }\n-    ctxt->valueFrame = frame;\n-}\n-\n@@ -2867,5 +2271,0 @@\n-    if (ctxt->valueNr <= ctxt->valueFrame) {\n-        xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_STACK_ERROR);\n-        return (NULL);\n-    }\n-\n@@ -2890,0 +2289,2 @@\n+ *\n+ * The object is destroyed in case of error.\n@@ -2908,0 +2309,1 @@\n+            xmlXPathFreeObject(value);\n@@ -2915,0 +2317,1 @@\n+            xmlXPathFreeObject(value);\n@@ -3100,1 +2503,1 @@\n-    if (l == 1) b[i++] = (xmlChar) v;                                  \\\n+    if (l == 1) b[i++] = v;                                            \\\n@@ -3307,1 +2710,1 @@\n-    return((long) count);\n+    return(count);\n@@ -3583,1 +2986,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));\n+    memset(ret, 0 , sizeof(xmlNodeSet));\n@@ -3593,1 +2996,1 @@\n-               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+               XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -3597,0 +3000,1 @@\n+            xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n@@ -3598,3 +3002,5 @@\n-            \/* TODO: Check memory error. *\/\n-            ret->nodeTab[ret->nodeNr++] =\n-                xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+            if (nsNode == NULL) {\n+                xmlXPathFreeNodeSet(ret);\n+                return(NULL);\n+            }\n+            ret->nodeTab[ret->nodeNr++] = nsNode;\n@@ -3657,1 +3063,1 @@\n-\n+    xmlNodePtr nsNode;\n@@ -3687,1 +3093,1 @@\n-               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+               XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -3705,2 +3111,4 @@\n-    \/* TODO: Check memory error. *\/\n-    cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);\n+    nsNode = xmlXPathNodeSetDupNs(node, ns);\n+    if(nsNode == NULL)\n+        return(-1);\n+    cur->nodeTab[cur->nodeNr++] = nsNode;\n@@ -3743,1 +3151,1 @@\n-               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+               XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -3763,0 +3171,1 @@\n+        xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n@@ -3764,3 +3173,3 @@\n-        \/* TODO: Check memory error. *\/\n-        cur->nodeTab[cur->nodeNr++] =\n-            xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+        if (nsNode == NULL)\n+            return(-1);\n+        cur->nodeTab[cur->nodeNr++] = nsNode;\n@@ -3798,1 +3207,1 @@\n-               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+               XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -3818,0 +3227,1 @@\n+        xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n@@ -3819,3 +3229,3 @@\n-        \/* TODO: Check memory error. *\/\n-        cur->nodeTab[cur->nodeNr++] =\n-            xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+        if (nsNode == NULL)\n+            return(-1);\n+        cur->nodeTab[cur->nodeNr++] = nsNode;\n@@ -3836,0 +3246,2 @@\n+ *\n+ * Frees @val1 in case of error.\n@@ -3845,16 +3257,0 @@\n-    if (val1 == NULL)\n-        return (NULL);\n-#if 0\n-        \/*\n-        * TODO: The optimization won't work in every case, since\n-        *  those nasty namespace nodes need to be added with\n-        *  xmlXPathNodeSetDupNs() to the set; thus a pure\n-        *  memcpy is not possible.\n-        *  If there was a flag on the nodesetval, indicating that\n-        *  some temporary nodes are in, that would be helpful.\n-        *\/\n-        \/*\n-        * Optimization: Create an equally sized node-set\n-        * and memcpy the content.\n-        *\/\n-        val1 = xmlXPathNodeSetCreateSize(val2->nodeNr);\n@@ -3862,12 +3258,1 @@\n-            return(NULL);\n-        if (val2->nodeNr != 0) {\n-            if (val2->nodeNr == 1)\n-                *(val1->nodeTab) = *(val2->nodeTab);\n-            else {\n-                memcpy(val1->nodeTab, val2->nodeTab,\n-                    val2->nodeNr * sizeof(xmlNodePtr));\n-            }\n-            val1->nodeNr = val2->nodeNr;\n-        }\n-        return(val1);\n-#endif\n+            return (NULL);\n@@ -3912,1 +3297,1 @@\n-                return(NULL);\n+                goto error;\n@@ -3915,1 +3300,1 @@\n-                   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                   XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -3922,1 +3307,1 @@\n-                return(NULL);\n+                goto error;\n@@ -3928,1 +3313,1 @@\n-                return(NULL);\n+                goto error;\n@@ -3935,0 +3320,1 @@\n+            xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n@@ -3936,3 +3322,3 @@\n-            \/* TODO: Check memory error. *\/\n-            val1->nodeTab[val1->nodeNr++] =\n-                xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+            if (nsNode == NULL)\n+                goto error;\n+            val1->nodeTab[val1->nodeNr++] = nsNode;\n@@ -3944,0 +3330,4 @@\n+\n+error:\n+    xmlXPathFreeNodeSet(val1);\n+    return(NULL);\n@@ -3956,0 +3346,2 @@\n+ *\n+ * Frees @set1 in case of error.\n@@ -3984,1 +3376,0 @@\n-                        set2->nodeTab[i] = NULL;\n@@ -3998,1 +3389,1 @@\n-                    return(NULL);\n+                    goto error;\n@@ -4001,1 +3392,1 @@\n-                    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -4008,1 +3399,1 @@\n-                    return(NULL);\n+                    goto error;\n@@ -4014,1 +3405,1 @@\n-                    return(NULL);\n+                    goto error;\n@@ -4021,1 +3412,1 @@\n-            {}\n+            set2->nodeTab[i] = NULL;\n@@ -4026,0 +3417,5 @@\n+\n+error:\n+    xmlXPathFreeNodeSet(set1);\n+    xmlXPathNodeSetClear(set2, 1);\n+    return(NULL);\n@@ -4037,0 +3433,2 @@\n+ *\n+ * Frees @set1 in case of error.\n@@ -4052,1 +3450,1 @@\n-                    return(NULL);\n+                    goto error;\n@@ -4055,1 +3453,1 @@\n-                    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -4062,1 +3460,1 @@\n-                    return(NULL);\n+                    goto error;\n@@ -4068,1 +3466,1 @@\n-                    return(NULL);\n+                    goto error;\n@@ -4074,0 +3472,1 @@\n+            set2->nodeTab[i] = NULL;\n@@ -4078,0 +3477,5 @@\n+\n+error:\n+    xmlXPathFreeNodeSet(set1);\n+    xmlXPathNodeSetClear(set2, 1);\n+    return(NULL);\n@@ -4101,5 +3505,0 @@\n-#ifdef DEBUG\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlXPathNodeSetDel: Node %s wasn't found in NodeList\\n\",\n-                val->name);\n-#endif\n@@ -4255,41 +3654,0 @@\n-#if defined(DEBUG) || defined(DEBUG_STEP)\n-\/**\n- * xmlGenericErrorContextNodeSet:\n- * @output:  a FILE * for the output\n- * @obj:  the xmlNodeSetPtr to display\n- *\n- * Quick display of a NodeSet\n- *\/\n-void\n-xmlGenericErrorContextNodeSet(FILE *output, xmlNodeSetPtr obj) {\n-    int i;\n-\n-    if (output == NULL) output = xmlGenericErrorContext;\n-    if (obj == NULL)  {\n-        fprintf(output, \"NodeSet == NULL !\\n\");\n-        return;\n-    }\n-    if (obj->nodeNr == 0) {\n-        fprintf(output, \"NodeSet is empty\\n\");\n-        return;\n-    }\n-    if (obj->nodeTab == NULL) {\n-        fprintf(output, \" nodeTab == NULL !\\n\");\n-        return;\n-    }\n-    for (i = 0; i < obj->nodeNr; i++) {\n-        if (obj->nodeTab[i] == NULL) {\n-            fprintf(output, \" NULL !\\n\");\n-            return;\n-        }\n-        if ((obj->nodeTab[i]->type == XML_DOCUMENT_NODE) ||\n-            (obj->nodeTab[i]->type == XML_HTML_DOCUMENT_NODE))\n-            fprintf(output, \" \/\");\n-        else if (obj->nodeTab[i]->name == NULL)\n-            fprintf(output, \" noname!\");\n-        else fprintf(output, \" %s\", obj->nodeTab[i]->name);\n-    }\n-    fprintf(output, \"\\n\");\n-}\n-#endif\n-\n@@ -4314,1 +3672,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -4320,3 +3678,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);\n-#endif\n@@ -4344,1 +3699,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -4349,3 +3704,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_XSLT_TREE);\n-#endif\n@@ -4395,0 +3747,2 @@\n+ *\n+ * In case of error the node set is destroyed and NULL is returned.\n@@ -4403,0 +3757,1 @@\n+        xmlXPathFreeNodeSet(val);\n@@ -4405,1 +3760,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -4408,3 +3763,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);\n-#endif\n@@ -4424,3 +3776,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageReleased(NULL, obj->type);\n-#endif\n@@ -4535,2 +3884,4 @@\n-            xmlHashAddEntry(hash, strval, strval);\n-            \/* TODO: Propagate memory error. *\/\n+            if (xmlHashAddEntry(hash, strval, strval) < 0) {\n+                xmlFree(strval);\n+                goto error;\n+            }\n@@ -4538,1 +3889,1 @@\n-                break;\n+                goto error;\n@@ -4545,0 +3896,5 @@\n+\n+error:\n+    xmlHashFree(hash, xmlHashDefaultDeallocator);\n+    xmlXPathFreeNodeSet(ret);\n+    return(NULL);\n@@ -4857,1 +4213,1 @@\n-XML_IGNORE_PEDANTIC_WARNINGS\n+XML_IGNORE_FPTR_CAST_WARNINGS\n@@ -4940,1 +4296,1 @@\n-XML_IGNORE_PEDANTIC_WARNINGS\n+XML_IGNORE_FPTR_CAST_WARNINGS\n@@ -5121,0 +4477,2 @@\n+    xmlChar *copy;\n+\n@@ -5135,2 +4493,11 @@\n-    return(xmlHashUpdateEntry(ctxt->nsHash, prefix, (void *) xmlStrdup(ns_uri),\n-                              xmlHashDefaultDeallocator));\n+\n+    copy = xmlStrdup(ns_uri);\n+    if (copy == NULL)\n+        return(-1);\n+    if (xmlHashUpdateEntry(ctxt->nsHash, prefix, copy,\n+                           xmlHashDefaultDeallocator) < 0) {\n+        xmlFree(copy);\n+        return(-1);\n+    }\n+\n+    return(0);\n@@ -5214,1 +4581,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -5217,3 +4584,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_NUMBER);\n-#endif\n@@ -5240,1 +4604,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -5243,3 +4607,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_BOOLEAN);\n-#endif\n@@ -5266,1 +4627,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -5268,7 +4629,7 @@\n-    if (val != NULL)\n-        ret->stringval = xmlStrdup(val);\n-    else\n-        ret->stringval = xmlStrdup((const xmlChar *)\"\");\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_STRING);\n-#endif\n+    if (val == NULL)\n+        val = BAD_CAST \"\";\n+    ret->stringval = xmlStrdup(val);\n+    if (ret->stringval == NULL) {\n+        xmlFree(ret);\n+        return(NULL);\n+    }\n@@ -5285,0 +4646,2 @@\n+ *\n+ * Frees @val in case of error.\n@@ -5293,0 +4656,1 @@\n+        xmlFree(val);\n@@ -5295,1 +4659,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -5298,3 +4662,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_STRING);\n-#endif\n@@ -5314,14 +4675,1 @@\n-    xmlXPathObjectPtr ret;\n-\n-    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n-    if (ret == NULL) {\n-        xmlXPathErrMemory(NULL, \"creating string object\\n\");\n-        return(NULL);\n-    }\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n-    ret->type = XPATH_STRING;\n-    ret->stringval = xmlStrdup(BAD_CAST val);\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_STRING);\n-#endif\n-    return(ret);\n+    return(xmlXPathNewString(BAD_CAST val));\n@@ -5360,1 +4708,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n+    memset(ret, 0 , sizeof(xmlXPathObject));\n@@ -5363,3 +4711,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, XPATH_USERS);\n-#endif\n@@ -5389,4 +4734,1 @@\n-    memcpy(ret, val , (size_t) sizeof(xmlXPathObject));\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageRequested(NULL, val->type);\n-#endif\n+    memcpy(ret, val , sizeof(xmlXPathObject));\n@@ -5403,0 +4745,4 @@\n+            if (ret->stringval == NULL) {\n+                xmlFree(ret);\n+                return(NULL);\n+            }\n@@ -5496,3 +4842,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-    xmlXPathDebugObjUsageReleased(NULL, obj->type);\n-#endif\n@@ -5597,5 +4940,0 @@\n-\n-#ifdef XP_DEBUG_OBJ_USAGE\n-        xmlXPathDebugObjUsageReleased(ctxt, obj->type);\n-#endif\n-\n@@ -5642,3 +4980,0 @@\n-#ifdef XP_DEBUG_OBJ_USAGE\n-        xmlXPathDebugObjUsageReleased(NULL, obj->type);\n-#endif\n@@ -5761,3 +5096,0 @@\n-#ifdef DEBUG_EXPR\n-            xmlGenericError(xmlGenericErrorContext, \"String: undefined\\n\");\n-#endif\n@@ -5810,3 +5142,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext, \"STRING: undefined\\n\");\n-#endif\n@@ -5930,3 +5259,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext, \"NUMBER: undefined\\n\");\n-#endif\n@@ -6044,3 +5370,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext, \"BOOLEAN: undefined\\n\");\n-#endif\n@@ -6121,1 +5444,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathContext));\n+    memset(ret, 0 , sizeof(xmlXPathContext));\n@@ -6229,1 +5552,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));\n+    memset(ret, 0 , sizeof(xmlXPathParserContext));\n@@ -6265,1 +5588,1 @@\n-    memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));\n+    memset(ret, 0 , sizeof(xmlXPathParserContext));\n@@ -6278,1 +5601,0 @@\n-    ret->valueFrame = 0;\n@@ -6363,2 +5685,1 @@\n-            return(((unsigned int) string[0]) +\n-                   (((unsigned int) string[1]) << 8));\n+            return(string[0] + (string[1] << 8));\n@@ -6371,2 +5692,1 @@\n-            return(((unsigned int) string[0]) +\n-                   (((unsigned int) string[1]) << 8));\n+            return(string[0] + (string[1] << 8));\n@@ -6394,1 +5714,1 @@\n-                return(ret + (((unsigned int) string[0]) << 8));\n+                return(ret + (string[0] << 8));\n@@ -6398,1 +5718,1 @@\n-                ret = (unsigned int) string[0];\n+                ret = string[0];\n@@ -6400,2 +5720,1 @@\n-                return(((unsigned int) string[0]) +\n-                       (((unsigned int) string[1]) << 8));\n+                return(string[0] + (string[1] << 8));\n@@ -6407,5 +5726,6 @@\n-        if ((tmp->children != NULL) && (tmp->type != XML_DTD_NODE)) {\n-            if (tmp->children->type != XML_ENTITY_DECL) {\n-                tmp = tmp->children;\n-                continue;\n-            }\n+        if ((tmp->children != NULL) &&\n+            (tmp->type != XML_DTD_NODE) &&\n+            (tmp->type != XML_ENTITY_REF_NODE) &&\n+            (tmp->children->type != XML_ENTITY_DECL)) {\n+            tmp = tmp->children;\n+            continue;\n@@ -6450,1 +5770,1 @@\n-        return((unsigned int) 0);\n+        return(0);\n@@ -6453,2 +5773,1 @@\n-    return(((unsigned int) string[0]) +\n-           (((unsigned int) string[1]) << 8));\n+    return(string[0] + (string[1] << 8));\n@@ -6817,0 +6136,1 @@\n+                CHECK_ERROR0;\n@@ -6971,4 +6291,0 @@\n-#ifdef DEBUG_EXPR\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"Equal: undefined\\n\");\n-#endif\n@@ -6979,4 +6295,0 @@\n-#ifdef DEBUG_EXPR\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"Equal: undefined\\n\");\n-#endif\n@@ -6985,5 +6297,0 @@\n-#ifdef DEBUG_EXPR\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"Equal: %d boolean %d \\n\",\n-                            arg1->boolval, arg2->boolval);\n-#endif\n@@ -7019,4 +6326,0 @@\n-#ifdef DEBUG_EXPR\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"Equal: undefined\\n\");\n-#endif\n@@ -7032,0 +6335,2 @@\n+                    if (ctxt->error)\n+                        break;\n@@ -7078,4 +6383,0 @@\n-#ifdef DEBUG_EXPR\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"Equal: undefined\\n\");\n-#endif\n@@ -7097,0 +6398,2 @@\n+                    if (ctxt->error)\n+                        break;\n@@ -7180,4 +6483,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"Equal: by pointer\\n\");\n-#endif\n@@ -7203,4 +6502,0 @@\n-#ifdef DEBUG_EXPR\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"Equal: undefined\\n\");\n-#endif\n@@ -7267,4 +6562,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"NotEqual: by pointer\\n\");\n-#endif\n@@ -7290,4 +6581,0 @@\n-#ifdef DEBUG_EXPR\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"NotEqual: undefined\\n\");\n-#endif\n@@ -7396,5 +6683,0 @@\n-    if (arg1->type != XPATH_NUMBER) {\n-        xmlXPathFreeObject(arg1);\n-        xmlXPathFreeObject(arg2);\n-        XP_ERROR0(XPATH_INVALID_OPERAND);\n-    }\n@@ -7406,5 +6688,2 @@\n-    if (arg2->type != XPATH_NUMBER) {\n-        xmlXPathReleaseObject(ctxt->context, arg1);\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-        XP_ERROR0(XPATH_INVALID_OPERAND);\n-    }\n+    if (ctxt->error)\n+        goto error;\n@@ -7460,0 +6739,1 @@\n+error:\n@@ -8492,4 +7772,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"last() : %d\\n\", ctxt->context->contextSize);\n-#endif\n@@ -8519,4 +7795,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext, \"position() : %d\\n\",\n-                ctxt->context->proximityPosition);\n-#endif\n@@ -8845,3 +8117,2 @@\n-                    if (fullname == NULL) {\n-                        XP_ERROR(XPATH_MEMORY_ERROR);\n-                    }\n+                    if (fullname == NULL)\n+                        xmlXPathPErrMemory(ctxt, NULL);\n@@ -9199,1 +8470,1 @@\n-      offset = (int)(point - str->stringval);\n+      offset = point - str->stringval;\n@@ -9242,1 +8513,1 @@\n-      offset = (int)(point - str->stringval) + xmlStrlen(find->stringval);\n+      offset = point - str->stringval + xmlStrlen(find->stringval);\n@@ -9339,1 +8610,1 @@\n-    xmlChar ch;\n+    int ch;\n@@ -9745,1 +9016,1 @@\n-        return((int) *cur);\n+        return(*cur);\n@@ -9927,1 +9198,1 @@\n-            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            buffer = (xmlChar *) xmlMallocAtomic(max);\n@@ -9944,2 +9215,1 @@\n-                    tmp = (xmlChar *) xmlRealloc(buffer,\n-                                                 max * sizeof(xmlChar));\n+                    tmp = (xmlChar *) xmlRealloc(buffer, max);\n@@ -9997,3 +9267,0 @@\n-    if ((*cur != '.') && ((*cur < '0') || (*cur > '9')) && (*cur != '-')) {\n-        return(xmlXPathNAN);\n-    }\n@@ -10004,0 +9271,3 @@\n+    if ((*cur != '.') && ((*cur < '0') || (*cur > '9'))) {\n+        return(xmlXPathNAN);\n+    }\n@@ -10260,1 +9530,4 @@\n-    if (ret == NULL) return;\n+    if (ret == NULL) {\n+        xmlXPathPErrMemory(ctxt, NULL);\n+        return;\n+    }\n@@ -10366,8 +9639,0 @@\n-#ifdef DEBUG_EXPR\n-    if (prefix == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"Calling function %s\\n\",\n-                        name);\n-    else\n-        xmlGenericError(xmlGenericErrorContext, \"Calling function %s:%s\\n\",\n-                        prefix, name);\n-#endif\n@@ -10590,4 +9855,0 @@\n-#ifdef DEBUG_STEP\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"PathExpr: Axis\\n\");\n-#endif\n@@ -10603,4 +9864,0 @@\n-#ifdef DEBUG_STEP\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PathExpr: AbbrRelLocation\\n\");\n-#endif\n@@ -10613,4 +9870,0 @@\n-#ifdef DEBUG_STEP\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PathExpr: AbbrRelLocation\\n\");\n-#endif\n@@ -10622,4 +9875,0 @@\n-#ifdef DEBUG_STEP\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"PathExpr: Type search\\n\");\n-#endif\n@@ -10633,4 +9882,0 @@\n-#ifdef DEBUG_STEP\n-                        xmlGenericError(xmlGenericErrorContext,\n-                                \"PathExpr: function call\\n\");\n-#endif\n@@ -10642,4 +9887,0 @@\n-#ifdef DEBUG_STEP\n-                    xmlGenericError(xmlGenericErrorContext,\n-                            \"PathExpr: AbbrRelLocation\\n\");\n-#endif\n@@ -10659,4 +9900,0 @@\n-#ifdef DEBUG_STEP\n-                xmlGenericError(xmlGenericErrorContext,\n-                        \"PathExpr: AbbrRelLocation\\n\");\n-#endif\n@@ -11373,14 +10610,0 @@\n-#ifdef DEBUG_STEP\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"Basis : computing new set\\n\");\n-#endif\n-\n-#ifdef DEBUG_STEP\n-        xmlGenericError(xmlGenericErrorContext, \"Basis : \");\n-        if (ctxt->value == NULL)\n-            xmlGenericError(xmlGenericErrorContext, \"no value\\n\");\n-        else if (ctxt->value->nodesetval == NULL)\n-            xmlGenericError(xmlGenericErrorContext, \"Empty\\n\");\n-        else\n-            xmlGenericErrorContextNodeSet(stdout, ctxt->value->nodesetval);\n-#endif\n@@ -11410,10 +10633,0 @@\n-#ifdef DEBUG_STEP\n-    xmlGenericError(xmlGenericErrorContext, \"Step : \");\n-    if (ctxt->value == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"no value\\n\");\n-    else if (ctxt->value->nodesetval == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"Empty\\n\");\n-    else\n-        xmlGenericErrorContextNodeSet(xmlGenericErrorContext,\n-                ctxt->value->nodesetval);\n-#endif\n@@ -11521,87 +10734,0 @@\n-#ifdef DEBUG_STEP\n-static void\n-xmlXPathDebugDumpStepAxis(xmlXPathStepOpPtr op,\n-                          int nbNodes)\n-{\n-    xmlGenericError(xmlGenericErrorContext, \"new step : \");\n-    switch (op->value) {\n-        case AXIS_ANCESTOR:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'ancestors' \");\n-            break;\n-        case AXIS_ANCESTOR_OR_SELF:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"axis 'ancestors-or-self' \");\n-            break;\n-        case AXIS_ATTRIBUTE:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'attributes' \");\n-            break;\n-        case AXIS_CHILD:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'child' \");\n-            break;\n-        case AXIS_DESCENDANT:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'descendant' \");\n-            break;\n-        case AXIS_DESCENDANT_OR_SELF:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"axis 'descendant-or-self' \");\n-            break;\n-        case AXIS_FOLLOWING:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'following' \");\n-            break;\n-        case AXIS_FOLLOWING_SIBLING:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"axis 'following-siblings' \");\n-            break;\n-        case AXIS_NAMESPACE:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'namespace' \");\n-            break;\n-        case AXIS_PARENT:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'parent' \");\n-            break;\n-        case AXIS_PRECEDING:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'preceding' \");\n-            break;\n-        case AXIS_PRECEDING_SIBLING:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"axis 'preceding-sibling' \");\n-            break;\n-        case AXIS_SELF:\n-            xmlGenericError(xmlGenericErrorContext, \"axis 'self' \");\n-            break;\n-    }\n-    xmlGenericError(xmlGenericErrorContext,\n-        \" context contains %d nodes\\n\", nbNodes);\n-    switch (op->value2) {\n-        case NODE_TEST_NONE:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"           searching for none !!!\\n\");\n-            break;\n-        case NODE_TEST_TYPE:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"           searching for type %d\\n\", op->value3);\n-            break;\n-        case NODE_TEST_PI:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"           searching for PI !!!\\n\");\n-            break;\n-        case NODE_TEST_ALL:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"           searching for *\\n\");\n-            break;\n-        case NODE_TEST_NS:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"           searching for namespace %s\\n\",\n-                            op->value5);\n-            break;\n-        case NODE_TEST_NAME:\n-            xmlGenericError(xmlGenericErrorContext,\n-                            \"           searching for name %s\\n\", op->value5);\n-            if (op->value4)\n-                xmlGenericError(xmlGenericErrorContext,\n-                                \"           with namespace %s\\n\", op->value4);\n-            break;\n-    }\n-    xmlGenericError(xmlGenericErrorContext, \"Testing : \");\n-}\n-#endif \/* DEBUG_STEP *\/\n-\n@@ -11998,3 +11124,0 @@\n-#ifdef DEBUG_STEP\n-    int nbMatches = 0, prevMatches = 0;\n-#endif\n@@ -12125,5 +11248,0 @@\n-#ifdef DEBUG_STEP\n-    xmlXPathDebugDumpStepAxis(op,\n-        (obj->nodesetval != NULL) ? obj->nodesetval->nodeNr : 0);\n-#endif\n-\n@@ -12263,4 +11381,0 @@\n-#ifdef DEBUG_STEP\n-            xmlGenericError(xmlGenericErrorContext, \" %s\", cur->name);\n-#endif\n-\n@@ -12453,5 +11567,0 @@\n-#ifdef DEBUG_STEP\n-        if (seq != NULL)\n-            nbMatches += seq->nodeNr;\n-#endif\n-\n@@ -12569,6 +11678,0 @@\n-#ifdef DEBUG_STEP\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"\\nExamined %d nodes, found %d nodes at that step\\n\",\n-        total, nbMatches);\n-#endif\n-\n@@ -12865,0 +11968,1 @@\n+    xmlXPathObjectPtr obj;\n@@ -12932,0 +12036,5 @@\n+    \/*\n+     * In case of errors, xmlXPathNodeSetFilter can pop additional nodes from\n+     * the stack. We have to temporarily remove the nodeset object from the\n+     * stack to avoid freeing it prematurely.\n+     *\/\n@@ -12933,1 +12042,2 @@\n-    set = ctxt->value->nodesetval;\n+    obj = valuePop(ctxt);\n+    set = obj->nodesetval;\n@@ -12939,0 +12049,1 @@\n+    valuePush(ctxt, obj);\n@@ -13155,1 +12266,1 @@\n-                frame = xmlXPathSetFrame(ctxt);\n+                frame = ctxt->valueNr;\n@@ -13159,2 +12270,1 @@\n-                    if (ctxt->error != XPATH_EXPRESSION_OK) {\n-                        xmlXPathPopFrame(ctxt, frame);\n+                    if (ctxt->error != XPATH_EXPRESSION_OK)\n@@ -13162,1 +12272,0 @@\n-                    }\n@@ -13164,1 +12273,1 @@\n-                if (ctxt->valueNr < ctxt->valueFrame + op->value) {\n+                if (ctxt->valueNr < frame + op->value) {\n@@ -13168,1 +12277,0 @@\n-                    xmlXPathPopFrame(ctxt, frame);\n@@ -13176,1 +12284,0 @@\n-                        xmlXPathPopFrame(ctxt, frame);\n@@ -13195,1 +12302,0 @@\n-                            xmlXPathPopFrame(ctxt, frame);\n@@ -13219,1 +12325,1 @@\n-                    (ctxt->valueNr != ctxt->valueFrame + 1))\n+                    (ctxt->valueNr != frame + 1))\n@@ -13221,1 +12327,0 @@\n-                xmlXPathPopFrame(ctxt, frame);\n@@ -13236,0 +12341,1 @@\n+                xmlXPathObjectPtr obj;\n@@ -13350,0 +12456,6 @@\n+                \/*\n+                 * In case of errors, xmlXPathNodeSetFilter can pop additional\n+                 * nodes from the stack. We have to temporarily remove the\n+                 * nodeset object from the stack to avoid freeing it\n+                 * prematurely.\n+                 *\/\n@@ -13351,1 +12463,2 @@\n-                set = ctxt->value->nodesetval;\n+                obj = valuePop(ctxt);\n+                set = obj->nodesetval;\n@@ -13355,0 +12468,1 @@\n+                valuePush(ctxt, obj);\n@@ -13648,2 +12762,0 @@\n-    int nb_nodes = 0;\n-\n@@ -13766,2 +12878,0 @@\n-        nb_nodes++;\n-\n@@ -13859,5 +12969,0 @@\n-#if 0\n-    printf(\"stream eval: checked %d nodes selected %d\\n\",\n-           nb_nodes, retObj->nodesetval->nodeNr);\n-#endif\n-\n@@ -13902,1 +13007,0 @@\n-        ctxt->valueFrame = 0;\n@@ -14117,0 +13221,1 @@\n+                xmlFreePattern(stream);\n@@ -14270,4 +13375,0 @@\n-#ifdef DEBUG_EVAL_COUNTS\n-        comp->string = xmlStrdup(str);\n-        comp->nb = 0;\n-#endif\n@@ -14330,7 +13431,0 @@\n-#ifdef DEBUG_EVAL_COUNTS\n-    comp->nb++;\n-    if ((comp->string != NULL) && (comp->nb > 100)) {\n-        fprintf(stderr, \"100 x %s\\n\", comp->string);\n-        comp->nb = 0;\n-    }\n-#endif\n@@ -14338,0 +13432,2 @@\n+    if (pctxt == NULL)\n+        return(-1);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xpath.c","additions":366,"deletions":1270,"binary":false,"changes":1636,"status":"modified"},{"patch":"@@ -4,3 +4,0 @@\n-#define SEND_ARG2_CAST\n-#define GETHOSTBYNAME_ARG_CAST\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/config.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-XMLPUBFUN void XMLCALL xmlCheckVersion(int version);\n+XMLPUBFUN void xmlCheckVersion(int version);\n@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.10.4\"\n+#define LIBXML_DOTTED_VERSION \"2.12.6\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 21004\n+#define LIBXML_VERSION 21206\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"21004\"\n+#define LIBXML_VERSION_STRING \"21206\"\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(21004);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(21206);\n@@ -316,1 +316,1 @@\n- * Whether the runtime debugging is configured in\n+ * Removed\n@@ -412,6 +412,1 @@\n-\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * Macro used to signal to GCC unused function parameters\n- *\/\n+\/** DOC_DISABLE *\/\n@@ -427,6 +422,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n-\n@@ -443,6 +432,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n-\n@@ -460,1 +443,1 @@\n-#  ifdef IN_LIBXML\n+#  if defined (IN_LIBXML) || (__GNUC__ * 100 + __GNUC_MINOR__ < 301)\n@@ -462,1 +445,0 @@\n-#  else\n@@ -464,0 +446,1 @@\n+#  else\n@@ -468,0 +451,18 @@\n+#if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 406)\n+  #if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 800)\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wcast-function-type\\\"\")\n+  #else\n+    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n+      _Pragma(\"GCC diagnostic push\") \\\n+      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\")\n+  #endif\n+  #define XML_POP_WARNINGS \\\n+    _Pragma(\"GCC diagnostic pop\")\n+#else\n+  #define XML_IGNORE_FPTR_CAST_WARNINGS\n+  #define XML_POP_WARNINGS\n+#endif\n+\n@@ -469,5 +470,0 @@\n-\/**\n- * ATTRIBUTE_UNUSED:\n- *\n- * Macro used to signal to GCC unused function parameters\n- *\/\n@@ -475,5 +471,0 @@\n-\/**\n- * LIBXML_ATTR_ALLOC_SIZE:\n- *\n- * Macro used to indicate to GCC this is an allocator function\n- *\/\n@@ -481,5 +472,0 @@\n-\/**\n- * LIBXML_ATTR_FORMAT:\n- *\n- * Macro used to indicate to GCC the parameter are printf like\n- *\/\n@@ -487,6 +473,0 @@\n-\/**\n- * XML_DEPRECATED:\n- *\n- * Macro used to indicate that a function, variable, type or struct member\n- * is deprecated.\n- *\/\n@@ -494,1 +474,18 @@\n-#define XML_DEPRECATED\n+#  if defined (IN_LIBXML) || !defined (_MSC_VER)\n+#    define XML_DEPRECATED\n+\/* Available since Visual Studio 2005 *\/\n+#  elif defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_DEPRECATED __declspec(deprecated)\n+#  endif\n+#endif\n+#if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS __pragma(warning(push))\n+#else\n+#  define XML_IGNORE_FPTR_CAST_WARNINGS\n+#endif\n+#ifndef XML_POP_WARNINGS\n+#  if defined (_MSC_VER) && (_MSC_VER >= 1400)\n+#    define XML_POP_WARNINGS __pragma(warning(pop))\n+#  else\n+#    define XML_POP_WARNINGS\n+#  endif\n@@ -498,0 +495,11 @@\n+#define XML_NO_ATTR\n+\n+#ifdef LIBXML_THREAD_ENABLED\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBFUN type *__##name(void);\n+  #define XML_GLOBAL_MACRO(name) (*__##name())\n+#else\n+  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n+    attrs XMLPUBVAR type name;\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/include\/libxml\/xmlversion.h","additions":56,"deletions":48,"binary":false,"changes":104,"status":"modified"}]}