{"files":[{"patch":"@@ -64,0 +64,1 @@\n+  bool is_identity             () const { return (_flags & JVM_ACC_IDENTITY                  ) != 0; }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -253,0 +253,1 @@\n+  bool is_abstract_value_klass() { return is_abstract() && !flags().is_identity(); }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -553,0 +553,2 @@\n+  ciType* improve_abstract_inline_type_klass(ciType* field_klass);\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  field_klass = improve_abstract_inline_type_klass(field_klass);\n@@ -228,0 +229,17 @@\n+\/\/ If the field klass is an abstract value klass (for which we do not know the layout, yet), it could have a unique\n+\/\/ concrete sub klass for which we have a fixed layout. This allows us to use InlineTypeNodes instead.\n+ciType* Parse::improve_abstract_inline_type_klass(ciType* field_klass) {\n+  Dependencies* dependencies = C->dependencies();\n+  if (UseUniqueSubclasses && dependencies != nullptr && field_klass->is_instance_klass()) {\n+    ciInstanceKlass* instance_klass = field_klass->as_instance_klass();\n+    if (instance_klass->is_loaded() && instance_klass->is_abstract_value_klass()) {\n+      ciInstanceKlass* sub_klass = instance_klass->unique_concrete_subklass();\n+      if (sub_klass != nullptr && sub_klass != field_klass) {\n+        field_klass = sub_klass;\n+        dependencies->assert_abstract_with_unique_concrete_subtype(instance_klass, sub_klass);\n+      }\n+    }\n+  }\n+  return field_klass;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4375,0 +4375,25 @@\n+\n+    abstract value static class AbstractValueClassSingleSubclass {\n+    }\n+\n+    value static class UniqueValueSubClass extends AbstractValueClassSingleSubclass {\n+        int x = 34;\n+    }\n+\n+    static AbstractValueClassSingleSubclass abstractValueClassSingleSubclass = new UniqueValueSubClass();\n+\n+    @Test\n+    public void testUniqueConcreteValueSubKlass(boolean flag) {\n+        \/\/ C2 should recognize that even though we do not know the exact layout of the underlying inline type of the\n+        \/\/ abstract field abstractValueClassSingleSubclass (i.e. cannot scalarize), we only have a unique concrete sub\n+        \/\/ class from which we know at compile time whether it can be scalarized or not. This unique sub class\n+        \/\/ optimization was missing, resulting in a missing InlineTypeNode assertion failure.\n+        doNothing(abstractValueClassSingleSubclass, flag ? 23 : 34);\n+    }\n+\n+    void doNothing(Object a, int i) {}\n+\n+    @Run(test = \"testUniqueConcreteValueSubKlass\")\n+    public void testUniqueConcreteValueSubKlass_verifier() {\n+        testUniqueConcreteValueSubKlass(true);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"}]}