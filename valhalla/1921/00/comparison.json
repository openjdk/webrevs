{"files":[{"patch":"@@ -4390,1 +4390,1 @@\n-    required: {0}!\\n\\\n+    required: {0}\\n\\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -203,1 +204,1 @@\n-            return printer.visit(type.stripMetadata(), l);\n+            return printer.visit(normalize(type), l);\n@@ -238,0 +239,8 @@\n+            private Type normalize(Type type) {\n+                Type t2 = type.stripMetadata();\n+                if (t2 != type && type.getNullMarker() == NullMarker.NOT_NULL) {\n+                    t2 = t2.asNullMarked(NullMarker.NOT_NULL);\n+                }\n+                return t2;\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/AbstractDiagnosticFormatter.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Collection;\n@@ -45,0 +46,1 @@\n+import com.sun.tools.javac.util.RichDiagnosticFormatter.WhereClauses.Kind;\n@@ -50,0 +52,1 @@\n+import static com.sun.tools.javac.code.TypeTag.TYPEVAR;\n@@ -87,2 +90,15 @@\n-    private static class WhereClauses {\n-        private final Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses;\n+    \/**\n+     * This class models the \"where clauses\" associated to a javac rich diagnostic.\n+     * There are several kinds of where clauses, based on the type they refer to:\n+     * <ul>\n+     *     <li>type-variable where clauses;<\/li>\n+     *     <li>captured type-variable where clauses; and<\/li>\n+     *     <li>intersection type where clauses.<\/li>\n+     * <\/ul>\n+     * This class ensures that the correct amount of where clauses is added for all the\n+     * types mentioned in a javac diagnostic. Note that where clauses must differentiate\n+     * between type-variables with same name, but different symbols.\n+     *\/\n+    class WhereClauses {\n+        private final Map<Kind, Map<Type, JCDiagnostic>> whereClausesByKind;\n+        private final Map<Name, List<Type>> typeVarsByName;\n@@ -91,3 +107,3 @@\n-            Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses = new EnumMap<>(WhereClauseKind.class);\n-            for (WhereClauseKind kind : WhereClauseKind.values()) {\n-                whereClauses.put(kind, new LinkedHashMap<>());\n+            Map<Kind, Map<Type, JCDiagnostic>> whereClausesByType = new EnumMap<>(Kind.class);\n+            for (Kind kind : Kind.values()) {\n+                whereClausesByType.put(kind, new LinkedHashMap<>());\n@@ -95,1 +111,16 @@\n-            this.whereClauses = whereClauses;\n+            this.whereClausesByKind = whereClausesByType;\n+            this.typeVarsByName = new LinkedHashMap<>();\n+        }\n+\n+        int indexOf(Type type, Kind kind) {\n+            Collection<Type> typesToSearch = kind == Kind.TYPEVAR ?\n+                    typeVarsByName.getOrDefault(type.tsym.name, List.nil()) :\n+                    whereClausesByKind.get(kind).keySet();\n+            int index = 1;\n+            for (Type t : typesToSearch) {\n+                if (sameWhereClause(t, type)) {\n+                    return index;\n+                }\n+                index++;\n+            }\n+            return -1;\n@@ -98,2 +129,58 @@\n-        public Map<Type, JCDiagnostic> get(WhereClauseKind kind) {\n-            return whereClauses.get(kind);\n+        private boolean sameWhereClause(Type t, Type s) {\n+            return t.hasTag(TYPEVAR) ?\n+                    t.tsym == s.tsym :\n+                    types.isSameType(t, s);\n+        }\n+\n+        boolean isUniqueTypeVar(TypeVar typevar) {\n+            int found = typeVarsByName\n+                    .getOrDefault(typevar.tsym.name, List.nil())\n+                    .length();\n+            if (found < 1)\n+                throw new AssertionError(\"Missing type variable in where clause: \" + typevar);\n+            return found == 1;\n+        }\n+\n+        void put(Type type, Kind kind, JCDiagnostic diagnostic) {\n+            whereClausesByKind.get(kind).put(type, diagnostic);\n+            if (kind == Kind.TYPEVAR) {\n+                List<Type> tvars = typeVarsByName.getOrDefault(type.tsym.name, List.nil());\n+                typeVarsByName.put(type.tsym.name, tvars.append(type));\n+            }\n+        }\n+\n+        Map<Type, JCDiagnostic> map(Kind kind) {\n+            return whereClausesByKind.get(kind);\n+        }\n+\n+        \/**\n+         * This enum defines all possible kinds of where clauses that can be\n+         * attached by a rich diagnostic formatter to a given diagnostic\n+         *\/\n+        enum Kind {\n+\n+            \/**\n+             * where clause regarding a type variable\n+             *\/\n+            TYPEVAR(\"where.description.typevar\"),\n+            \/**\n+             * where clause regarding a captured type\n+             *\/\n+            CAPTURED(\"where.description.captured\"),\n+            \/**\n+             * where clause regarding an intersection type\n+             *\/\n+            INTERSECTION(\"where.description.intersection\");\n+\n+            \/**\n+             * resource key for this where clause kind\n+             *\/\n+            private final String key;\n+\n+            Kind(String key) {\n+                this.key = key;\n+            }\n+\n+            String key() {\n+                return key;\n+            }\n@@ -238,1 +325,1 @@\n-        for (WhereClauseKind kind : WhereClauseKind.values()) {\n+        for (Kind kind : Kind.values()) {\n@@ -240,1 +327,1 @@\n-            for (Map.Entry<Type, JCDiagnostic> entry : whereClauses.get(kind).entrySet()) {\n+            for (Map.Entry<Type, JCDiagnostic> entry : whereClauses.map(kind).entrySet()) {\n@@ -247,1 +334,1 @@\n-                JCDiagnostic d = diags.fragment(key, whereClauses.get(kind).keySet());\n+                JCDiagnostic d = diags.fragment(key, whereClauses.map(kind).keySet());\n@@ -255,53 +342,0 @@\n-    private int indexOf(Type type, WhereClauseKind kind) {\n-        int index = 1;\n-        for (Type t : whereClauses.get(kind).keySet()) {\n-            if (t.tsym == type.tsym) {\n-                return index;\n-            }\n-            if (kind != WhereClauseKind.TYPEVAR ||\n-                    t.toString().equals(type.toString())) {\n-                index++;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    private boolean unique(TypeVar typevar) {\n-        typevar = (TypeVar) typevar.stripMetadata();\n-\n-        int found = 0;\n-        for (Type t : whereClauses.get(WhereClauseKind.TYPEVAR).keySet()) {\n-            if (t.stripMetadata().toString().equals(typevar.toString())) {\n-                found++;\n-            }\n-        }\n-        if (found < 1)\n-            throw new AssertionError(\"Missing type variable in where clause: \" + typevar);\n-        return found == 1;\n-    }\n-    \/\/where\n-    \/**\n-     * This enum defines all possible kinds of where clauses that can be\n-     * attached by a rich diagnostic formatter to a given diagnostic\n-     *\/\n-    enum WhereClauseKind {\n-\n-        \/** where clause regarding a type variable *\/\n-        TYPEVAR(\"where.description.typevar\"),\n-        \/** where clause regarding a captured type *\/\n-        CAPTURED(\"where.description.captured\"),\n-        \/** where clause regarding an intersection type *\/\n-        INTERSECTION(\"where.description.intersection\");\n-\n-        \/** resource key for this where clause kind *\/\n-        private final String key;\n-\n-        WhereClauseKind(String key) {\n-            this.key = key;\n-        }\n-\n-        String key() {\n-            return key;\n-        }\n-    }\n-\n@@ -381,1 +415,1 @@\n-            return indexOf(t, WhereClauseKind.CAPTURED) + \"\";\n+            return whereClauses.indexOf(t, Kind.CAPTURED) + \"\";\n@@ -397,1 +431,1 @@\n-                    indexOf(t, WhereClauseKind.CAPTURED));\n+                    whereClauses.indexOf(t, Kind.CAPTURED));\n@@ -409,1 +443,1 @@\n-                        indexOf(t, WhereClauseKind.INTERSECTION));\n+                        whereClauses.indexOf(t, Kind.INTERSECTION));\n@@ -430,1 +464,1 @@\n-            if (unique(t) ||\n+            if (whereClauses.isUniqueTypeVar(t) ||\n@@ -437,1 +471,1 @@\n-                        t.toString(), indexOf(t, WhereClauseKind.TYPEVAR));\n+                        t.toString(), whereClauses.indexOf(t, Kind.TYPEVAR));\n@@ -538,1 +572,1 @@\n-            if (indexOf(t, WhereClauseKind.CAPTURED) == -1) {\n+            if (whereClauses.indexOf(t, Kind.CAPTURED) == -1) {\n@@ -541,1 +575,1 @@\n-                whereClauses.get(WhereClauseKind.CAPTURED).put(t, d);\n+                whereClauses.put(t, Kind.CAPTURED, d);\n@@ -552,1 +586,1 @@\n-                if (indexOf(t, WhereClauseKind.INTERSECTION) == -1) {\n+                if (whereClauses.indexOf(t, Kind.INTERSECTION) == -1) {\n@@ -556,1 +590,1 @@\n-                    whereClauses.get(WhereClauseKind.INTERSECTION).put(t, d);\n+                    whereClauses.put(t, Kind.INTERSECTION, d);\n@@ -587,1 +621,1 @@\n-            if (indexOf(t, WhereClauseKind.TYPEVAR) == -1) {\n+            if (whereClauses.indexOf(t, Kind.TYPEVAR) == -1) {\n@@ -610,1 +644,1 @@\n-                    whereClauses.get(WhereClauseKind.TYPEVAR).put(t, d);\n+                    whereClauses.put(t, Kind.TYPEVAR, d);\n@@ -617,1 +651,1 @@\n-                    whereClauses.get(WhereClauseKind.TYPEVAR).put(t, d);\n+                    whereClauses.put(t, Kind.TYPEVAR, d);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":110,"deletions":76,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Check that type annotations in intersection types do not lead to duplicated where clauses\n+ * @compile\/fail\/ref=TestDuplicatedIntersection.out -XDrawDiagnostics -XDrawDiagnostics --diags=formatterOptions=where TestDuplicatedIntersection.java\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+import java.util.List;\n+\n+class TestDuplicatedIntersection {\n+    @Target(ElementType.TYPE_USE)\n+    @interface A { }\n+\n+    interface S1 { }\n+    interface S2 { }\n+\n+    interface B extends @A S1, @A S2 { }\n+    interface C extends @A S1, @A S2 { }\n+\n+    interface D extends S1, S2 { }\n+    interface E extends S1, S2 { }\n+\n+    <X> X pick(X a, X b) { return null; }\n+\n+    void test1(List<B> b, List<C> c, List<D> d, List<E> e) {\n+        var x = pick(b, c);\n+        var y = pick(d, e);\n+        g(x, y);\n+    }\n+\n+    void g(String s) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/TestDuplicatedIntersection.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+TestDuplicatedIntersection.java:29:9: compiler.err.cant.apply.symbol: kindname.method, g, java.lang.String, java.util.List<compiler.misc.captured.type: 1>,java.util.List<compiler.misc.captured.type: 2>, kindname.class, TestDuplicatedIntersection, (compiler.misc.arg.length.mismatch)\n+- compiler.misc.where.description.captured.1: compiler.misc.captured.type: 1,compiler.misc.captured.type: 2,{(compiler.misc.where.captured.1: compiler.misc.captured.type: 1, compiler.misc.intersection.type: 1, compiler.misc.type.null, ? extends compiler.misc.intersection.type: 1),(compiler.misc.where.captured.1: compiler.misc.captured.type: 2, compiler.misc.intersection.type: 1, compiler.misc.type.null, ? extends compiler.misc.intersection.type: 1)}\n+- compiler.misc.where.description.intersection: compiler.misc.intersection.type: 1,{(compiler.misc.where.intersection: compiler.misc.intersection.type: 1, java.lang.Object,TestDuplicatedIntersection.S1,TestDuplicatedIntersection.S2)}\n+1 error\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/TestDuplicatedIntersection.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -1,4 +1,4 @@\n-NullRestrictedArrayCreationTest.java:10:18: compiler.err.restricted.array.missing.init: java.lang.String\n-NullRestrictedArrayCreationTest.java:13:18: compiler.err.restricted.array.missing.init: java.lang.String\n-NullRestrictedArrayCreationTest.java:17:18: compiler.err.restricted.array.missing.init: java.lang.String\n-NullRestrictedArrayCreationTest.java:23:18: compiler.err.restricted.array.missing.init: java.lang.String\n+NullRestrictedArrayCreationTest.java:10:18: compiler.err.restricted.array.missing.init: java.lang.String!\n+NullRestrictedArrayCreationTest.java:13:18: compiler.err.restricted.array.missing.init: java.lang.String!\n+NullRestrictedArrayCreationTest.java:17:18: compiler.err.restricted.array.missing.init: java.lang.String!\n+NullRestrictedArrayCreationTest.java:23:18: compiler.err.restricted.array.missing.init: java.lang.String!\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictedArrayCreationTest.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,5 +1,5 @@\n-SeparateCompilationTest.java:13:17: compiler.warn.suspicious.nullness.conversion: java.lang.String, compiler.misc.type.null\n-SeparateCompilationTest.java:14:21: compiler.warn.suspicious.nullness.conversion: java.lang.String[], compiler.misc.type.null\n-SeparateCompilationTest.java:15:17: compiler.warn.suspicious.nullness.conversion: java.lang.String, compiler.misc.type.null\n-SeparateCompilationTest.java:16:21: compiler.warn.suspicious.nullness.conversion: java.lang.String[], compiler.misc.type.null\n-SeparateCompilationTest.java:17:22: compiler.warn.suspicious.nullness.conversion: java.util.List<java.lang.String>, compiler.misc.type.null\n+SeparateCompilationTest.java:13:17: compiler.warn.suspicious.nullness.conversion: java.lang.String!, compiler.misc.type.null\n+SeparateCompilationTest.java:14:21: compiler.warn.suspicious.nullness.conversion: java.lang.String[]!, compiler.misc.type.null\n+SeparateCompilationTest.java:15:17: compiler.warn.suspicious.nullness.conversion: java.lang.String!, compiler.misc.type.null\n+SeparateCompilationTest.java:16:21: compiler.warn.suspicious.nullness.conversion: java.lang.String[]!, compiler.misc.type.null\n+SeparateCompilationTest.java:17:22: compiler.warn.suspicious.nullness.conversion: java.util.List<java.lang.String>!, compiler.misc.type.null\n","filename":"test\/langtools\/tools\/javac\/nullability\/separate\/SeparateCompilationTest.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}