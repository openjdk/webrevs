{"files":[{"patch":"@@ -41,1 +41,2 @@\n-static LayoutKind field_layout_selection(FieldInfo field_info, Array<InlineLayoutInfo>* inline_layout_info_array) {\n+static LayoutKind field_layout_selection(FieldInfo field_info, Array<InlineLayoutInfo>* inline_layout_info_array,\n+                                         bool use_atomic_flat) {\n@@ -58,2 +59,3 @@\n-    if (vk->must_be_atomic() || field_info.access_flags().is_volatile() ||  AlwaysAtomicAccesses) {\n-      return vk->has_atomic_layout() ? LayoutKind::ATOMIC_FLAT : LayoutKind::REFERENCE;\n+    if (vk->must_be_atomic() || field_info.access_flags().is_volatile() || AlwaysAtomicAccesses) {\n+      if (vk->is_naturally_atomic() && vk->has_non_atomic_layout()) return LayoutKind::NON_ATOMIC_FLAT;\n+      return (vk->has_atomic_layout() && use_atomic_flat) ? LayoutKind::ATOMIC_FLAT : LayoutKind::REFERENCE;\n@@ -65,1 +67,1 @@\n-      return LayoutKind::NULLABLE_ATOMIC_FLAT;\n+      return use_atomic_flat ? LayoutKind::NULLABLE_ATOMIC_FLAT : LayoutKind::REFERENCE;\n@@ -813,1 +815,1 @@\n-      LayoutKind lk = field_layout_selection(fieldinfo, _inline_layout_info_array);\n+      LayoutKind lk = field_layout_selection(fieldinfo, _inline_layout_info_array, true);\n@@ -896,1 +898,2 @@\n-      LayoutKind lk = field_layout_selection(fieldinfo, _inline_layout_info_array);\n+      bool use_atomic_flat = _must_be_atomic; \/\/ flatten atomic fields only if the container is itself atomic\n+      LayoutKind lk = field_layout_selection(fieldinfo, _inline_layout_info_array, use_atomic_flat);\n@@ -922,5 +925,0 @@\n-        \/\/ default is atomic, but class file parsing could have set _must_be_atomic to false (@LooselyConsistentValue + checks)\n-        \/\/ Presence of a must_be_atomic field must revert the _must_be_atomic flag of the holder to true\n-        if (vk->must_be_atomic()) {\n-          _must_be_atomic = true;\n-        }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        case \"NULLABLE_FLAT\"   : return NULLABLE_FLAT;\n+        case \"NULLABLE_ATOMIC_FLAT\"   : return NULLABLE_FLAT;\n@@ -363,1 +363,1 @@\n-      FieldBlock block = getFieldFromName(fieldName, isStatic);\n+      FieldBlock block = getFieldFromNameOrNull(fieldName, isStatic);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldLayoutAnalyzer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-      out.outputTo(System.out);\n+      System.out.print(out.getOutput());\n@@ -345,1 +345,0 @@\n-    System.out.print(out.getOutput());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/NullMarkersTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test id=ValueCompositionTest_no_atomic_flat_and_no_nullable_flat\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java ValueCompositionTest.java\n+ * @run main\/othervm ValueCompositionTest 0\n+ *\/\n+\n+ \/*\n+ * @test id=ValueCompositionTest_atomic_flat_and_nullable_flat\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java ValueCompositionTest.java\n+ * @run main\/othervm ValueCompositionTest 1\n+ *\/\n+\n+ \/* @test id=ValueCompositionTest_no_atomic_flat_and_nullable_flat\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java ValueCompositionTest.java\n+ * @run main\/othervm ValueCompositionTest 2\n+ *\/\n+\n+ \/* @test id=ValueCompositionTest_atomic_flat_and_no_nullable_flat\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java ValueCompositionTest.java\n+ * @run main\/othervm ValueCompositionTest 3\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ValueCompositionTest {\n+\n+  static class TestRunner {\n+    public static void main(String[] args) throws Exception {\n+      Class testClass = Class.forName(\"ValueCompositionTest\");\n+      Asserts.assertNotNull(testClass);\n+      Method[] testMethods = testClass.getMethods();\n+      for (Method test : testMethods) {\n+        if (test.getName().startsWith(\"test_\")) {\n+          Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+          Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+          System.out.println(\"Running \" + test.getName());\n+          test.invoke(null);\n+        }\n+      }\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  static value class Value0 {\n+    byte b0 = 0;\n+    byte b1 = 0;\n+  }\n+\n+  static class Container0 {\n+    @NullRestricted\n+    Value0 val0 = new Value0();\n+    Value0 val1 = new Value0();\n+  }\n+\n+  static public void test_0() {\n+    Container0 c = new Container0();\n+  }\n+\n+  static public void check_0(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container0\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    if (useAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.ATOMIC_FLAT, f0.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f0.layoutKind());\n+    }\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    if (useNullableAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_FLAT, f1.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  static value class Container1 {\n+    @NullRestricted\n+    Value0 val0 = new Value0();\n+    Value0 val1 = new Value0();\n+  }\n+\n+  static public void test_1() {\n+    Container1 c = new Container1();\n+  }\n+\n+  static public void check_1(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container1\");\n+    FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+    if (useAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.ATOMIC_FLAT, f.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    }\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    if (useNullableAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_FLAT, f1.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Container2 {\n+    @NullRestricted\n+    Value0 val0 = new Value0();\n+    Value0 val1 = new Value0();\n+  }\n+\n+  static public void test_2() {\n+    Container2 c = new Container2();\n+  }\n+\n+  \/\/ An atomic value should not be flattened in a non-atomic value\n+  static public void check_2(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container2\");\n+    FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value1 {\n+    byte b0 = 0;\n+    byte b1 = 0;\n+  }\n+\n+  static class Container3 {\n+    @NullRestricted\n+    Value1 val0 = new Value1();\n+    Value1 val1 = new Value1();\n+  }\n+\n+  static public void test_3() {\n+    Container3 c = new Container3();\n+  }\n+\n+  static public void check_3(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container3\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_ATOMIC_FLAT, f0.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    if (useNullableAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_FLAT, f1.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  static value class Container4 {\n+    @NullRestricted\n+    Value1 val0 = new Value1();\n+    Value1 val1 = new Value1();\n+  }\n+\n+  static public void test_4() {\n+    Container4 c = new Container4();\n+  }\n+\n+  static public void check_4(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container4\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_ATOMIC_FLAT, f0.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    if (useNullableAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_FLAT, f1.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Container5 {\n+    @NullRestricted\n+    Value1 val0 = new Value1();\n+    Value1 val1 = new Value1();\n+  }\n+\n+  static public void test_5() {\n+    Container5 c = new Container5();\n+  }\n+\n+  static public void check_5(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container5\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_ATOMIC_FLAT, f0.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+  }\n+\n+  @ImplicitlyConstructible\n+  static value class Value2 {\n+    byte b0 = 0;\n+  }\n+\n+  static class Container6 {\n+    @NullRestricted\n+    Value2 val0 = new Value2();\n+    Value2 val1 = new Value2();\n+  }\n+\n+  static public void test_6() {\n+    Container6 c = new Container6();\n+  }\n+\n+  static public void check_6(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container6\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_ATOMIC_FLAT, f0.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    if (useNullableAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_FLAT, f1.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  static value class Container7 {\n+    @NullRestricted\n+    Value2 val0 = new Value2();\n+    Value2 val1 = new Value2();\n+  }\n+\n+  static public void test_7() {\n+    Container7 c = new Container7();\n+  }\n+\n+  static public void check_7(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container7\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_ATOMIC_FLAT, f0.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    if (useNullableAtomicFlat) {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_FLAT, f1.layoutKind());\n+    } else {\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Container8 {\n+    @NullRestricted\n+    Value2 val0 = new Value2();\n+    Value2 val1 = new Value2();\n+  }\n+\n+  static public void test_8() {\n+    Container8 c = new Container8();\n+  }\n+\n+  static public void check_8(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"ValueCompositionTest$Container8\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_ATOMIC_FLAT, f0.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n+  }\n+\n+\n+  static ProcessBuilder exec(String... args) throws Exception {\n+    List<String> argsList = new ArrayList<>();\n+    Collections.addAll(argsList, \"--enable-preview\");\n+    Collections.addAll(argsList, \"-Xint\");\n+    Collections.addAll(argsList, \"-XX:+UnlockDiagnosticVMOptions\");\n+    Collections.addAll(argsList, \"-XX:+PrintFieldLayout\");\n+    Collections.addAll(argsList, \"-Xshare:off\");\n+    Collections.addAll(argsList, \"-Xmx256m\");\n+    Collections.addAll(argsList, useAtomicFlat ? \"-XX:+AtomicFieldFlattening\" : \"-XX:-AtomicFieldFlattening\");\n+    Collections.addAll(argsList, useNullableAtomicFlat ?  \"-XX:+NullableFieldFlattening\" : \"-XX:-NullableFieldFlattening\");\n+    Collections.addAll(argsList, \"-cp\", System.getProperty(\"java.class.path\") + System.getProperty(\"path.separator\") + \".\");\n+    Collections.addAll(argsList, args);\n+    return ProcessTools.createTestJavaProcessBuilder(argsList);\n+  }\n+\n+  static boolean useAtomicFlat;\n+  static boolean useNullableAtomicFlat;\n+\n+  public static void main(String[] args) throws Exception {\n+\n+    switch(args[0]) {\n+      case \"0\": useAtomicFlat = false;\n+                useNullableAtomicFlat = false;\n+                break;\n+      case \"1\": useAtomicFlat = true;\n+                useNullableAtomicFlat = true;\n+                break;\n+      case \"2\": useAtomicFlat = false;\n+                useNullableAtomicFlat = true;\n+                break;\n+      case \"3\": useAtomicFlat = true;\n+                useNullableAtomicFlat = false;\n+                break;\n+      default: throw new RuntimeException(\"Unrecognized configuration\");\n+    }\n+\n+    \/\/ Generate test classes\n+    ValueCompositionTest vct = new ValueCompositionTest();\n+\n+    \/\/ Execute the test runner in charge of loading all test classes\n+    ProcessBuilder pb = exec(\"ValueCompositionTest$TestRunner\");\n+    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+\n+    if (out.getExitValue() != 0) {\n+      System.out.print(out.getOutput());\n+    }\n+    Asserts.assertEquals(out.getExitValue(), 0, \"Something went wrong while running the tests\");\n+\n+    \/\/ To help during test development\n+    System.out.print(out.getOutput());\n+\n+    \/\/ Get and parse the test output\n+    FieldLayoutAnalyzer.LogOutput lo = new FieldLayoutAnalyzer.LogOutput(out.asLines());\n+    FieldLayoutAnalyzer fla =  FieldLayoutAnalyzer.createFieldLayoutAnalyzer(lo);\n+\n+    \/\/ Running tests verification method (check that tests produced the right configuration)\n+    Class testClass = ValueCompositionTest.class;\n+      Method[] testMethods = testClass.getMethods();\n+      for (Method test : testMethods) {\n+        if (test.getName().startsWith(\"check_\")) {\n+          Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+          Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+          test.invoke(null, fla);\n+        }\n+      }\n+\n+    \/\/ Verify that all layouts are correct\n+    fla.check();\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueCompositionTest.java","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -220,1 +220,1 @@\n-      out.outputTo(System.out);\n+      System.out.print(out.getOutput());\n@@ -225,1 +225,0 @@\n-    System.out.print(out.getOutput());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueFieldInheritanceTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}