{"files":[{"patch":"@@ -2808,2 +2808,1 @@\n-      \/\/ Non-flat inline type arrays are initialized with\n-      \/\/ an init value instead of null. Handle them here.\n+      \/\/ Null-free inline type arrays are initialized with an init value instead of null\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -397,1 +397,2 @@\n-            \/\/ TODO 8350865 Somehow we ended up with root mem and therefore walked past the alloc. Fix this. Triggered by TestGenerated::test15\n+            \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n+            \/\/ Somehow we ended up with root mem and therefore walked past the alloc. Fix this. Triggered by TestGenerated::test15\n@@ -427,1 +428,2 @@\n-          \/\/ TODO 8350865 Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n+          \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n+          \/\/ Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1352,1 +1352,2 @@\n-        \/\/ TODO 8350865 Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n+        \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n+        \/\/ Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n@@ -2394,4 +2395,11 @@\n-      \/\/ TODO 8350865 This is needed for flat array accesses, somehow the memory of the loads bypasses the intrinsic\n-      \/\/ Run TestArrays.test6 in Scenario4, we need more tests for this. TestBasicFunctionality::test20 also needs this.\n-      if (tp->isa_aryptr() && tp->is_aryptr()->is_flat() && !UseFieldFlattening) {\n-        return _type;\n+      \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n+      \/\/ Escape Analysis assumes that arrays are always zeroed during allocation which is not true for null-free arrays\n+      \/\/ ConnectionGraph::split_unique_types will re-wire the memory of loads from such arrays around the allocation\n+      \/\/ TestArrays::test6 and test152 and TestBasicFunctionality::test20 are affected by this.\n+      if (tp->isa_aryptr() && tp->is_aryptr()->is_flat() && tp->is_aryptr()->is_null_free()) {\n+        intptr_t offset = 0;\n+        Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);\n+        AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+        if (alloc != nullptr && alloc->is_AllocateArray() && alloc->in(AllocateNode::InitValue) != nullptr) {\n+          return _type;\n+        }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    public static final String MYVALUE_ARRAY_KLASS = \"\\\\[(precise )?compiler\/valhalla\/inlinetypes\/MyValue\";\n-    public static final String ALLOC = \"(.*precise compiler\/valhalla\/inlinetypes\/MyValue.*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*C2 Runtime new_instance\" + END;\n+    public static final String MYVALUE_ARRAY_KLASS = \"\\\\[(precise )?compiler\/valhalla\/inlinetypes\/.*MyValue\";\n+    public static final String ALLOC = \"(.*precise compiler\/valhalla\/inlinetypes\/.*MyValue.*\\\\R(.*(?i:mov|xorl|nop|spill).*\\\\R)*.*C2 Runtime new_instance\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3654,0 +3654,66 @@\n+\n+    \/\/ Make sure this can't be flattened\n+    static value class MyValue152Inline {\n+        long l1 = rL;\n+        long l2 = rL;\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue152 {\n+        double d = rD;\n+\n+        @Strict\n+        @NullRestricted\n+        MyValue152Inline val = new MyValue152Inline(); \/\/ Not flat\n+    }\n+\n+    \/\/ Test that EA works for null-free arrays\n+    @Test\n+    \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays\n+    \/\/@IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+    \/\/    failOn = {ALLOC, ALLOCA})\n+    public MyValue152 test152() {\n+        MyValue152[] array = (MyValue152[])ValueClass.newNullRestrictedNonAtomicArray(MyValue152.class, 1, new MyValue152());\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test152\")\n+    public void test152_verifier() {\n+        Asserts.assertEquals(test152(), new MyValue152());\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue153 {\n+        @Strict\n+        @NullRestricted\n+        MyValue152Inline val = new MyValue152Inline(); \/\/ Not flat\n+    }\n+\n+    \/\/ Same as test152 but triggers a slightly different asserts\n+    @Test\n+    \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays\n+    \/\/@IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+    \/\/    failOn = {ALLOC, ALLOCA})\n+    public MyValue153 test153() {\n+        MyValue153[] array = (MyValue153[])ValueClass.newNullRestrictedNonAtomicArray(MyValue153.class, 1, new MyValue153());\n+        return array[0];\n+    }\n+\n+    @Run(test = \"test153\")\n+    public void test153_verifier() {\n+        Asserts.assertEquals(test153(), new MyValue153());\n+    }\n+\n+    \/\/ Same as test152 but triggers an incorrect result\n+    @Test\n+    \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays\n+    \/\/@IR(failOn = {ALLOC, ALLOCA_G, LOAD, STORE, TRAP})\n+    public double test154() {\n+        MyValue152[] array = (MyValue152[])ValueClass.newNullRestrictedNonAtomicArray(MyValue152.class, 1, new MyValue152());\n+        return array[0].d;\n+    }\n+\n+    @Run(test = \"test154\")\n+    public void test154_verifier() {\n+        Asserts.assertEquals(test154(), rD);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"}]}