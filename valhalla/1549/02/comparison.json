{"files":[{"patch":"@@ -2828,10 +2828,16 @@\n-      \/\/ Flat array must have an exact type\n-      bool is_null_free = layout != LayoutKind::NULLABLE_ATOMIC_FLAT;\n-      bool is_atomic = layout != LayoutKind::NON_ATOMIC_FLAT;\n-      Node* new_base = cast_to_flat_array(base, value_klass, is_null_free, !is_null_free, is_atomic);\n-      replace_in_map(base, new_base);\n-      base = new_base;\n-      ptr = basic_plus_adr(base, ConvL2X(offset));\n-      const TypeAryPtr* ptr_type = _gvn.type(ptr)->is_aryptr();\n-      if (ptr_type->field_offset().get() != 0) {\n-        ptr = _gvn.transform(new CastPPNode(control(), ptr, ptr_type->with_field_offset(0), ConstraintCastNode::StrongDependency));\n+      if (UseArrayFlattening) {\n+        \/\/ Flat array must have an exact type\n+        bool is_null_free = layout != LayoutKind::NULLABLE_ATOMIC_FLAT;\n+        bool is_atomic = layout != LayoutKind::NON_ATOMIC_FLAT;\n+        Node* new_base = cast_to_flat_array(base, value_klass, is_null_free, !is_null_free, is_atomic);\n+        replace_in_map(base, new_base);\n+        base = new_base;\n+        ptr = basic_plus_adr(base, ConvL2X(offset));\n+        const TypeAryPtr* ptr_type = _gvn.type(ptr)->is_aryptr();\n+        if (ptr_type->field_offset().get() != 0) {\n+          ptr = _gvn.transform(new CastPPNode(control(), ptr, ptr_type->with_field_offset(0), ConstraintCastNode::StrongDependency));\n+        }\n+      } else {\n+        uncommon_trap(Deoptimization::Reason_intrinsic,\n+                      Deoptimization::Action_none);\n+        return true;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365978\n+ * @summary Unsafe::compareAndSetFlatValue crashes with -XX:-UseArrayFlattening\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.PutFlatValueWithoutUseArrayFlattening::test\n+ *                   -XX:-TieredCompilation -Xcomp\n+ *                   -XX:-UseArrayFlattening -XX:+UseFieldFlattening\n+ *                   compiler.valhalla.inlinetypes.PutFlatValueWithoutUseArrayFlattening\n+ * @run main\/othervm -XX:+UseFieldFlattening\n+ *                   compiler.valhalla.inlinetypes.PutFlatValueWithoutUseArrayFlattening\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Field;\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+\n+public class PutFlatValueWithoutUseArrayFlattening {\n+    static public value class SmallValue {\n+        byte a;\n+        byte b;\n+        SmallValue(int a, int b) {\n+            this.a = (byte)a;\n+            this.b = (byte)b;\n+        }\n+    }\n+\n+    SmallValue f;\n+    private static final long OFFSET;\n+    private static final boolean IS_FLATTENED;\n+    private static final int LAYOUT;\n+    static private final Unsafe U = Unsafe.getUnsafe();\n+    static {\n+        try {\n+            Field f = PutFlatValueWithoutUseArrayFlattening.class.getDeclaredField(\"f\");\n+            OFFSET = U.objectFieldOffset(f);\n+            IS_FLATTENED = U.isFlatField(f);\n+            Asserts.assertTrue(IS_FLATTENED, \"Field f should be flat, the test makes no sense otherwise. And why isn't it?!\");\n+            LAYOUT = U.fieldLayout(f);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void test(boolean flag) {\n+        var newVal = new SmallValue(1, 1);\n+        var oldVal = new SmallValue(0, 0);\n+        f = oldVal;\n+        if (flag) {\n+            U.compareAndSetFlatValue(this, OFFSET, LAYOUT, SmallValue.class, oldVal, newVal);\n+        }\n+    }\n+\n+    static public void main(String args[]) {\n+        new SmallValue(0, 0);\n+        new PutFlatValueWithoutUseArrayFlattening().test(false);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/PutFlatValueWithoutUseArrayFlattening.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}