{"files":[{"patch":"@@ -51,1 +51,1 @@\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n@@ -118,3 +118,15 @@\n-          sudo apt-get update\n-          sudo apt-get install --only-upgrade apt\n-          sudo apt-get install gcc-${{ inputs.gcc-major-version }}${{ inputs.gcc-package-suffix }} g++-${{ inputs.gcc-major-version }}${{ inputs.gcc-package-suffix }} libxrandr-dev${{ steps.arch.outputs.suffix }} libxtst-dev${{ steps.arch.outputs.suffix }} libcups2-dev${{ steps.arch.outputs.suffix }} libasound2-dev${{ steps.arch.outputs.suffix }} ${{ inputs.apt-extra-packages }}\n+          sudo apt update\n+          sudo apt install --only-upgrade apt\n+          sudo apt install \\\n+            gcc-${{ inputs.gcc-major-version }}${{ inputs.gcc-package-suffix }} \\\n+            g++-${{ inputs.gcc-major-version }}${{ inputs.gcc-package-suffix }} \\\n+            libasound2-dev${{ steps.arch.outputs.suffix }} \\\n+            libcups2-dev${{ steps.arch.outputs.suffix }} \\\n+            libfontconfig1-dev${{ steps.arch.outputs.suffix }} \\\n+            libx11-dev${{ steps.arch.outputs.suffix }} \\\n+            libxext-dev${{ steps.arch.outputs.suffix }} \\\n+            libxrandr-dev${{ steps.arch.outputs.suffix }} \\\n+            libxrender-dev${{ steps.arch.outputs.suffix }} \\\n+            libxt-dev${{ steps.arch.outputs.suffix }} \\\n+            libxtst-dev${{ steps.arch.outputs.suffix }} \\\n+            ${{ inputs.apt-extra-packages }}\n","filename":".github\/workflows\/build-linux.yml","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n@@ -408,1 +408,1 @@\n-      runs-on: ubuntu-22.04\n+      runs-on: ubuntu-24.04\n@@ -422,1 +422,1 @@\n-      runs-on: ubuntu-22.04\n+      runs-on: ubuntu-24.04\n","filename":".github\/workflows\/main.yml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -288,1 +288,2 @@\n-# Param 1 - either JDK or JRE\n+# Copy debug info files into symbols bundle.\n+# In case of Windows and --with-external-symbols-in-bundles=public, take care to remove *.stripped.pdb files\n@@ -291,0 +292,4 @@\n+      $(eval dbgfiles := $(call FindDebuginfoFiles, $(SUPPORT_OUTPUTDIR)\/modules_libs\/$m)) \\\n+      $(eval dbgfiles := $(if $(filter true+public,$(call isTargetOs,windows)+$(SHIP_DEBUG_SYMBOLS)), \\\n+        $(filter-out %.stripped.pdb,$(dbgfiles)),$(dbgfiles)) \\\n+      ) \\\n@@ -294,2 +299,1 @@\n-          FILES := $(call FindDebuginfoFiles, \\\n-              $(SUPPORT_OUTPUTDIR)\/modules_libs\/$m), \\\n+          FILES := $(dbgfiles), \\\n@@ -298,0 +302,4 @@\n+      $(eval dbgfiles := $(call FindDebuginfoFiles, $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$m)) \\\n+      $(eval dbgfiles := $(if $(filter true+public,$(call isTargetOs,windows)+$(SHIP_DEBUG_SYMBOLS)), \\\n+        $(filter-out %.stripped.pdb,$(dbgfiles)),$(dbgfiles)) \\\n+      ) \\\n@@ -301,2 +309,1 @@\n-          FILES := $(call FindDebuginfoFiles, \\\n-              $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$m), \\\n+          FILES := $(dbgfiles), \\\n@@ -307,4 +314,1 @@\n-# No space before argument to avoid having to put $(strip ) everywhere in\n-# implementation above.\n-$(call SetupCopyDebuginfo,JDK)\n-$(call SetupCopyDebuginfo,JRE)\n+# No space before argument to avoid having to put $(strip ) everywhere in implementation above.\n","filename":"make\/Images.gmk","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -124,0 +124,22 @@\n+\n+RELEASE_FILE_TEMPLATE := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\/resources\/release.txt.template\n+RELEASE_FILE_TARGET := $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\/jdk\/internal\/misc\/resources\/release.txt\n+\n+RELEASE_FILE_VARDEPS := $(COMPANY_NAME) $(VERSION_STRING) $(VERSION_DATE)\n+RELEASE_FILE_VARDEPS_FILE := $(call DependOnVariable, RELEASE_FILE_VARDEPS, \\\n+    $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\/jlink_release_txt.vardeps)\n+\n+$(eval $(call SetupTextFileProcessing, BUILD_RELEASE_FILE, \\\n+    SOURCE_FILES := $(RELEASE_FILE_TEMPLATE), \\\n+    OUTPUT_FILE := $(RELEASE_FILE_TARGET), \\\n+    REPLACEMENTS := \\\n+        @@COMPANY_NAME@@ => $(COMPANY_NAME) ; \\\n+        @@VERSION_STRING@@ => $(VERSION_STRING) ; \\\n+        @@VERSION_DATE@@ => $(VERSION_DATE) , \\\n+))\n+\n+$(BUILD_RELEASE_FILE): $(RELEASE_FILE_VARDEPS_FILE)\n+\n+TARGETS += $(BUILD_RELEASE_FILE)\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-COPY += .icu .dat .spp .nrm content-types.properties \\\n+COPY += .icu .dat .spp .nrm .txt content-types.properties \\\n","filename":"make\/modules\/java.base\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1964,0 +1964,3 @@\n+    DEBUG_ONLY(int algm = MIN2(RegMask::num_registers(ireg), (int)Matcher::stack_alignment_in_slots()) * VMRegImpl::stack_slot_size);\n+    assert((src_lo_rc != rc_stack) || is_aligned(src_offset, algm), \"unaligned vector spill sp offset %d (src)\", src_offset);\n+    assert((dst_lo_rc != rc_stack) || is_aligned(dst_offset, algm), \"unaligned vector spill sp offset %d (dst)\", dst_offset);\n@@ -2450,0 +2453,4 @@\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef, int oper_index) {\n+  return false;\n+}\n+\n@@ -3332,67 +3339,0 @@\n-  enc_class aarch64_enc_cmpxchg(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgw(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgs(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgb(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-\n-  \/\/ The only difference between aarch64_enc_cmpxchg and\n-  \/\/ aarch64_enc_cmpxchg_acq is that we use load-acquire in the\n-  \/\/ CompareAndSwap sequence to serve as a barrier on acquiring a\n-  \/\/ lock.\n-  enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegL oldval, iRegL newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegI oldval, iRegI newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegI oldval, iRegI newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegI oldval, iRegI newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  \/\/ auxiliary used for CompareAndSwapX to set result register\n-  enc_class aarch64_enc_cset_eq(iRegI res) %{\n-    Register res_reg = as_Register($res$$reg);\n-    __ cset(res_reg, Assembler::EQ);\n-  %}\n-\n@@ -8431,965 +8371,0 @@\n-\/\/ ============================================================================\n-\/\/ Atomic operation instructions\n-\/\/\n-\n-\/\/ standard CompareAndSwapX when we are using barriers\n-\/\/ these have higher priority than the rules selected by a predicate\n-\n-\/\/ XXX No flag versions for CompareAndSwap{I,L,P,N} because matcher\n-\/\/ can't match them\n-\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgb $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgb(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgs $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgs(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ alternative CompareAndSwapX when we are eliding barriers\n-\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgb_acq $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgb_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgs_acq $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgs_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw_acq $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg_acq $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg_acq $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw_acq $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\n-\/\/ ---------------------------------------------------------------------\n-\n-\/\/ BEGIN This section of the file is automatically generated. Do not edit --------------\n-\n-\/\/ Sundry CAS operations.  Note that release is always true,\n-\/\/ regardless of the memory ordering of the CAS.  This is because we\n-\/\/ need the volatile case to be sequentially consistent but there is\n-\/\/ no trailing StoreLoad barrier emitted by C2.  Unfortunately we\n-\/\/ can't check the type of memory ordering here, so we always emit a\n-\/\/ STLXR.\n-\n-\/\/ This section is generated from cas.m4\n-\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgb $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxtbw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgs $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxthw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeL(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgb_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxtbw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgs_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxthw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeLAcq(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgb $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgs $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgb_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgs_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ END This section of the file is automatically generated. Do not edit --------------\n-\/\/ ---------------------------------------------------------------------\n-\n-instruct get_and_setI(indirect mem, iRegI newv, iRegINoSp prev) %{\n-  match(Set prev (GetAndSetI mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setL(indirect mem, iRegL newv, iRegLNoSp prev) %{\n-  match(Set prev (GetAndSetL mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setN(indirect mem, iRegN newv, iRegINoSp prev) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set prev (GetAndSetN mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setP(indirect mem, iRegP newv, iRegPNoSp prev) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set prev (GetAndSetP mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setIAcq(indirect mem, iRegI newv, iRegINoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set prev (GetAndSetI mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw_acq  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setLAcq(indirect mem, iRegL newv, iRegLNoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set prev (GetAndSetL mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg_acq  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setNAcq(indirect mem, iRegN newv, iRegINoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set prev (GetAndSetN mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw_acq $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setPAcq(indirect mem, iRegP newv, iRegPNoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set prev (GetAndSetP mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg_acq  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-\n-instruct get_and_addL(indirect mem, iRegLNoSp newval, iRegL incr) %{\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addL_no_res(indirect mem, Universe dummy, iRegL incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addL [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLi(indirect mem, iRegLNoSp newval, immLAddSub incr) %{\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLi_no_res(indirect mem, Universe dummy, immLAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addL [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addI(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addI_no_res(indirect mem, Universe dummy, iRegIorL2I incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addI [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIi(indirect mem, iRegINoSp newval, immIAddSub incr) %{\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIi_no_res(indirect mem, Universe dummy, immIAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addI [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLAcq(indirect mem, iRegLNoSp newval, iRegL incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addL_no_resAcq(indirect mem, Universe dummy, iRegL incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addL_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLiAcq(indirect mem, iRegLNoSp newval, immLAddSub incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLi_no_resAcq(indirect mem, Universe dummy, immLAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addL_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIAcq(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addI_no_resAcq(indirect mem, Universe dummy, iRegIorL2I incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addI_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIiAcq(indirect mem, iRegINoSp newval, immIAddSub incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIi_no_resAcq(indirect mem, Universe dummy, immIAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addI_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":7,"deletions":1032,"binary":false,"changes":1039,"status":"modified"},{"patch":"@@ -2904,1 +2904,1 @@\n-  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg2   - sessionKe (key) in little endian int array\n@@ -2937,1 +2937,1 @@\n-  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg2   - sessionKd (key) in little endian int array\n@@ -2971,1 +2971,1 @@\n-  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg2   - sessionKe (key) in little endian int array\n@@ -3076,1 +3076,1 @@\n-  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg2   - sessionKd (key) in little endian int array\n@@ -3203,1 +3203,1 @@\n-  \/\/   c_rarg2   - K (key) in little endian int array\n+  \/\/   c_rarg2   - sessionKe (key) in little endian int array\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  Label done;\n+  Label L_done;\n@@ -95,1 +95,1 @@\n-  __ jcc(Assembler::zero, done);\n+  __ jccb(Assembler::zero, L_done);\n@@ -114,1 +114,1 @@\n-  Label loop;\n+  Label L_loop;\n@@ -116,1 +116,1 @@\n-  __ bind(loop);\n+  __ bind(L_loop);\n@@ -118,1 +118,1 @@\n-  Label is_clean_card;\n+  Label L_is_clean_card;\n@@ -121,1 +121,1 @@\n-    __ jcc(Assembler::equal, is_clean_card);\n+    __ jccb(Assembler::equal, L_is_clean_card);\n@@ -126,2 +126,2 @@\n-  Label next_card;\n-  __ bind(next_card);\n+  Label L_next_card;\n+  __ bind(L_next_card);\n@@ -130,2 +130,2 @@\n-  __ jcc(Assembler::belowEqual, loop);\n-  __ jmp(done);\n+  __ jccb(Assembler::belowEqual, L_loop);\n+  __ jmpb(L_done);\n@@ -133,2 +133,2 @@\n-  __ bind(is_clean_card);\n-  \/\/ Card was clean. Dirty card and go to next..\n+  __ bind(L_is_clean_card);\n+  \/\/ Card was clean. Dirty card and go to next.\n@@ -136,1 +136,1 @@\n-  __ jmp(next_card);\n+  __ jmpb(L_next_card);\n@@ -138,1 +138,1 @@\n-  __ bind(done);\n+  __ bind(L_done);\n@@ -160,16 +160,0 @@\n-static void generate_queue_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n-                                     const Register thread, const Register value, const Register temp) {\n-  \/\/ This code assumes that buffer index is pointer sized.\n-  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n-  \/\/ Can we store a value in the given thread's buffer?\n-  \/\/ (The index field is typed as size_t.)\n-  __ movptr(temp, Address(thread, in_bytes(index_offset)));   \/\/ temp := *(index address)\n-  __ testptr(temp, temp);                                     \/\/ index == 0?\n-  __ jcc(Assembler::zero, runtime);                           \/\/ jump to runtime if index == 0 (full buffer)\n-  \/\/ The buffer is not full, store value into it.\n-  __ subptr(temp, wordSize);                                  \/\/ temp := next index\n-  __ movptr(Address(thread, in_bytes(index_offset)), temp);   \/\/ *(index address) := next index\n-  __ addptr(temp, Address(thread, in_bytes(buffer_offset)));  \/\/ temp := buffer address + next index\n-  __ movptr(Address(temp, 0), value);                         \/\/ *(buffer address + next index) := value\n-}\n-\n@@ -193,2 +177,9 @@\n-                                           Label& done,\n-                                           Label& runtime) {\n+                                           Label& L_done) {\n+  Address index_addr(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n+  Address buffer_addr(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n+\n+  \/\/ This code assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n+\n+  Label L_runtime;\n+\n@@ -199,0 +190,1 @@\n+\n@@ -200,8 +192,19 @@\n-  __ cmpptr(pre_val, NULL_WORD);\n-  __ jcc(Assembler::equal, done);\n-  generate_queue_insertion(masm,\n-                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n-                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n-                           runtime,\n-                           thread, pre_val, tmp);\n-  __ jmp(done);\n+  __ testptr(pre_val, pre_val);\n+  __ jcc(Assembler::equal, L_done);\n+\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ movptr(tmp, index_addr);             \/\/ temp := *(index address)\n+  __ testptr(tmp, tmp);                   \/\/ index == 0?\n+  __ jccb(Assembler::zero, L_runtime);    \/\/ jump to runtime if index == 0 (full buffer)\n+\n+  \/\/ The buffer is not full, store value into it.\n+  __ subptr(tmp, wordSize);               \/\/ temp := next index\n+  __ movptr(index_addr, tmp);             \/\/ *(index address) := next index\n+  __ addptr(tmp, buffer_addr);            \/\/ temp := buffer address + next index\n+  __ movptr(Address(tmp, 0), pre_val);    \/\/ *(buffer address + next index) := value\n+\n+  \/\/ Jump out if done, or fall-through to runtime.\n+  \/\/ \"L_done\" is far away, so jump cannot be short.\n+  __ jmp(L_done);\n+  __ bind(L_runtime);\n@@ -222,1 +225,0 @@\n-  Label runtime;\n@@ -234,3 +236,1 @@\n-  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done, runtime);\n-\n-  __ bind(runtime);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done);\n@@ -305,1 +305,0 @@\n-                                  Label& done,\n@@ -312,0 +311,1 @@\n+  Label L_done;\n@@ -316,1 +316,1 @@\n-  __ jcc(Assembler::equal, done);\n+  __ jccb(Assembler::equal, L_done);\n@@ -320,2 +320,2 @@\n-    __ cmpptr(new_val, NULL_WORD);                                \/\/ new value == null?\n-    __ jcc(Assembler::equal, done);\n+    __ testptr(new_val, new_val);                                 \/\/ new value == null?\n+    __ jccb(Assembler::equal, L_done);\n@@ -331,1 +331,1 @@\n-    __ jcc(Assembler::notEqual, done);\n+    __ jccb(Assembler::notEqual, L_done);\n@@ -336,0 +336,1 @@\n+  __ bind(L_done);\n@@ -342,3 +343,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp, done, true \/* new_val_may_be_null *\/);\n-  __ bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, true \/* new_val_may_be_null *\/);\n@@ -387,1 +386,0 @@\n-  Label runtime;\n@@ -395,1 +393,1 @@\n-  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation(), runtime);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation());\n@@ -397,1 +395,0 @@\n-  __ bind(runtime);\n@@ -407,3 +404,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp, done, new_val_may_be_null);\n-  __ bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, new_val_may_be_null);\n@@ -483,1 +478,1 @@\n-  __ cmpptr(pre_val_reg, NULL_WORD);\n+  __ testptr(pre_val_reg, pre_val_reg);\n@@ -499,3 +494,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp1, done, true \/* new_val_may_be_null *\/);\n-  masm->bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp1, true \/* new_val_may_be_null *\/);\n@@ -524,2 +517,1 @@\n-  Label done;\n-  Label runtime;\n+  Label L_done, L_runtime;\n@@ -534,1 +526,1 @@\n-  __ jcc(Assembler::equal, done);\n+  __ jcc(Assembler::equal, L_done);\n@@ -540,1 +532,1 @@\n-  __ jcc(Assembler::zero, runtime);\n+  __ jccb(Assembler::zero, L_runtime);\n@@ -548,1 +540,1 @@\n-  __ jmp(done);\n+  __ jmp(L_done);\n@@ -550,1 +542,1 @@\n-  __ bind(runtime);\n+  __ bind(L_runtime);\n@@ -560,1 +552,1 @@\n-  __ bind(done);\n+  __ bind(L_done);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":61,"deletions":69,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2647,0 +2647,64 @@\n+static bool is_ndd_demotable(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0);\n+}\n+\n+static bool is_ndd_demotable_commutative(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n+}\n+\n+static bool is_demotion_candidate(const MachNode* mdef) {\n+  return (is_ndd_demotable(mdef) || is_ndd_demotable_commutative(mdef));\n+}\n+\n+bool Matcher::is_register_biasing_candidate(const MachNode* mdef,\n+                                            int oper_index) {\n+  if (mdef == nullptr) {\n+    return false;\n+  }\n+\n+  if (mdef->num_opnds() <= oper_index || mdef->operand_index(oper_index) < 0 ||\n+      mdef->in(mdef->operand_index(oper_index)) == nullptr) {\n+    assert(oper_index != 1 || !is_demotion_candidate(mdef), \"%s\", mdef->Name());\n+    assert(oper_index != 2 || !is_ndd_demotable_commutative(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  \/\/ Complex memory operand covers multiple incoming edges needed for\n+  \/\/ address computation. Biasing def towards any address component will not\n+  \/\/ result in NDD demotion by assembler.\n+  if (mdef->operand_num_edges(oper_index) != 1) {\n+    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  \/\/ Demotion candidate must be register mask compatible with definition.\n+  const RegMask& oper_mask = mdef->in_RegMask(mdef->operand_index(oper_index));\n+  if (!oper_mask.overlap(mdef->out_RegMask())) {\n+    assert(!is_demotion_candidate(mdef), \"%s\", mdef->Name());\n+    return false;\n+  }\n+\n+  switch (oper_index) {\n+  \/\/ First operand of MachNode corresponding to Intel APX NDD selection\n+  \/\/ pattern can share its assigned register with definition operand if\n+  \/\/ their live ranges do not overlap. In such a scenario we can demote\n+  \/\/ it to legacy map0\/map1 instruction by replacing its 4-byte extended\n+  \/\/ EVEX prefix with shorter REX\/REX2 encoding. Demotion candidates\n+  \/\/ are decorated with a special flag by instruction selector.\n+  case 1:\n+    return is_demotion_candidate(mdef);\n+\n+  \/\/ Definition operand of commutative operation can be biased towards second\n+  \/\/ operand.\n+  case 2:\n+    return is_ndd_demotable_commutative(mdef);\n+\n+  \/\/ Current scheme only selects up to two biasing candidates\n+  default:\n+    assert(false, \"unhandled operand index: %s\", mdef->Name());\n+    break;\n+  }\n+\n+  return false;\n+}\n+\n@@ -2826,1 +2890,1 @@\n-  enum NodeFlags {\n+  enum NodeFlags : uint64_t {\n@@ -2838,1 +2902,3 @@\n-    _last_flag                = Flag_clears_sign_flag\n+    Flag_ndd_demotable        = Node::_last_flag << 12,\n+    Flag_ndd_demotable_commutative = Node::_last_flag << 13,\n+    _last_flag                = Flag_ndd_demotable_commutative\n@@ -3334,0 +3400,5 @@\n+    case Op_VectorBlend:\n+      if (UseAVX == 0 && size_in_bits < 128) {\n+        return false;\n+      }\n+      break;\n@@ -9890,1 +9961,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -9918,1 +9989,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -9961,1 +10032,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -10018,0 +10089,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -10072,0 +10144,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -10178,1 +10251,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -10206,1 +10279,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -10249,1 +10322,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n@@ -10305,0 +10378,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -10359,0 +10433,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -11073,1 +11148,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11087,1 +11162,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11130,1 +11205,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11188,1 +11263,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11202,1 +11277,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11245,1 +11320,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11317,1 +11392,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11345,1 +11420,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11386,1 +11461,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11414,1 +11489,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n@@ -11459,0 +11534,1 @@\n+  flag(PD::Flag_ndd_demotable_commutative);\n@@ -11500,0 +11576,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -11551,0 +11628,1 @@\n+  flag(PD::Flag_ndd_demotable_commutative);\n@@ -11592,0 +11670,1 @@\n+  flag(PD::Flag_ndd_demotable_commutative);\n@@ -11866,0 +11945,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -11894,0 +11974,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12000,0 +12081,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12106,0 +12188,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12213,0 +12296,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12241,0 +12325,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12347,0 +12432,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12453,0 +12539,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12624,0 +12711,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12688,0 +12776,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12740,0 +12829,1 @@\n+\n@@ -12753,0 +12843,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12817,0 +12908,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -12894,1 +12986,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -12987,1 +13079,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13031,1 +13123,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13231,1 +13323,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13260,1 +13352,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13274,1 +13366,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13318,1 +13410,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13394,1 +13486,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13420,0 +13512,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -13450,1 +13543,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13496,1 +13589,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13575,1 +13668,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13631,1 +13724,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13675,1 +13768,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13878,1 +13971,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -13933,1 +14026,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13947,1 +14040,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -13992,1 +14085,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -14071,1 +14164,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -14097,0 +14190,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -14127,1 +14221,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n@@ -14173,1 +14267,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n@@ -16841,0 +16935,1 @@\n+  flag(PD::Flag_ndd_demotable);\n@@ -16892,0 +16987,1 @@\n+  flag(PD::Flag_ndd_demotable);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":134,"deletions":38,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-  CodeBuffer(CodeBlob* blob);\n+  CodeBuffer(const CodeBlob* blob);\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    _buffer_offset_to_source_obj_table = new BufferOffsetToSourceObjectTable(\/*size (prime)*\/36137, \/*max size*\/1 * M);\n+    _buffer_offset_to_source_obj_table = new (mtClassShared) BufferOffsetToSourceObjectTable(\/*size (prime)*\/36137, \/*max size*\/1 * M);\n@@ -91,1 +91,1 @@\n-    _fillers = new FillersTable();\n+    _fillers = new (mtClassShared) FillersTable();\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapWriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,3 +95,0 @@\n-#if INCLUDE_JFR\n-#include \"jfr\/support\/jfrTraceIdExtension.hpp\"\n-#endif\n@@ -5600,2 +5597,0 @@\n-  JFR_ONLY(INIT_ID(ik);)\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -551,0 +551,2 @@\n+  const ClassFileStream& stream() const { return *_stream; }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1722,2 +1722,2 @@\n-int java_lang_Thread::_jvmti_VTMS_transition_disable_count_offset;\n-int java_lang_Thread::_jvmti_is_in_VTMS_transition_offset;\n+int java_lang_Thread::_vthread_transition_disable_count_offset;\n+int java_lang_Thread::_is_in_vthread_transition_offset;\n@@ -1783,2 +1783,3 @@\n-int java_lang_Thread::VTMS_transition_disable_count(oop java_thread) {\n-  return java_thread->int_field(_jvmti_VTMS_transition_disable_count_offset);\n+int java_lang_Thread::vthread_transition_disable_count(oop java_thread) {\n+  jint* addr = java_thread->field_addr<jint>(_vthread_transition_disable_count_offset);\n+  return AtomicAccess::load(addr);\n@@ -1787,4 +1788,5 @@\n-void java_lang_Thread::inc_VTMS_transition_disable_count(oop java_thread) {\n-  assert(JvmtiVTMSTransition_lock->owned_by_self(), \"Must be locked\");\n-  int val = VTMS_transition_disable_count(java_thread);\n-  java_thread->int_field_put(_jvmti_VTMS_transition_disable_count_offset, val + 1);\n+void java_lang_Thread::inc_vthread_transition_disable_count(oop java_thread) {\n+  assert(VThreadTransition_lock->owned_by_self(), \"Must be locked\");\n+  jint* addr = java_thread->field_addr<jint>(_vthread_transition_disable_count_offset);\n+  int val = AtomicAccess::load(addr);\n+  AtomicAccess::store(addr, val + 1);\n@@ -1793,5 +1795,5 @@\n-void java_lang_Thread::dec_VTMS_transition_disable_count(oop java_thread) {\n-  assert(JvmtiVTMSTransition_lock->owned_by_self(), \"Must be locked\");\n-  int val = VTMS_transition_disable_count(java_thread);\n-  assert(val > 0, \"VTMS_transition_disable_count should never be negative\");\n-  java_thread->int_field_put(_jvmti_VTMS_transition_disable_count_offset, val - 1);\n+void java_lang_Thread::dec_vthread_transition_disable_count(oop java_thread) {\n+  assert(VThreadTransition_lock->owned_by_self(), \"Must be locked\");\n+  jint* addr = java_thread->field_addr<jint>(_vthread_transition_disable_count_offset);\n+  int val = AtomicAccess::load(addr);\n+  AtomicAccess::store(addr, val - 1);\n@@ -1800,2 +1802,3 @@\n-bool java_lang_Thread::is_in_VTMS_transition(oop java_thread) {\n-  return java_thread->bool_field_volatile(_jvmti_is_in_VTMS_transition_offset);\n+bool java_lang_Thread::is_in_vthread_transition(oop java_thread) {\n+  jboolean* addr = java_thread->field_addr<jboolean>(_is_in_vthread_transition_offset);\n+  return AtomicAccess::load(addr);\n@@ -1804,7 +1807,4 @@\n-void java_lang_Thread::set_is_in_VTMS_transition(oop java_thread, bool val) {\n-  assert(is_in_VTMS_transition(java_thread) != val, \"already %s transition\", val ? \"inside\" : \"outside\");\n-  java_thread->bool_field_put_volatile(_jvmti_is_in_VTMS_transition_offset, val);\n-}\n-\n-int java_lang_Thread::is_in_VTMS_transition_offset() {\n-  return _jvmti_is_in_VTMS_transition_offset;\n+void java_lang_Thread::set_is_in_vthread_transition(oop java_thread, bool val) {\n+  assert(is_in_vthread_transition(java_thread) != val, \"already %s transition\", val ? \"inside\" : \"outside\");\n+  jboolean* addr = java_thread->field_addr<jboolean>(_is_in_vthread_transition_offset);\n+  AtomicAccess::store(addr, (jboolean)val);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -383,2 +383,2 @@\n-  macro(java_lang_Thread, jvmti_VTMS_transition_disable_count, int_signature, false) \\\n-  macro(java_lang_Thread, jvmti_is_in_VTMS_transition, bool_signature, false) \\\n+  macro(java_lang_Thread, vthread_transition_disable_count, int_signature, false) \\\n+  macro(java_lang_Thread, is_in_vthread_transition, bool_signature, false) \\\n@@ -398,2 +398,2 @@\n-  static int _jvmti_VTMS_transition_disable_count_offset;\n-  static int _jvmti_is_in_VTMS_transition_offset;\n+  static int _vthread_transition_disable_count_offset;\n+  static int _is_in_vthread_transition_offset;\n@@ -452,6 +452,9 @@\n-  static int  VTMS_transition_disable_count(oop java_thread);\n-  static void inc_VTMS_transition_disable_count(oop java_thread);\n-  static void dec_VTMS_transition_disable_count(oop java_thread);\n-  static bool is_in_VTMS_transition(oop java_thread);\n-  static void set_is_in_VTMS_transition(oop java_thread, bool val);\n-  static int  is_in_VTMS_transition_offset();\n+\n+  static int  vthread_transition_disable_count(oop java_thread);\n+  static void inc_vthread_transition_disable_count(oop java_thread);\n+  static void dec_vthread_transition_disable_count(oop java_thread);\n+  static int  vthread_transition_disable_count_offset() { return _vthread_transition_disable_count_offset; }\n+\n+  static bool is_in_vthread_transition(oop java_thread);\n+  static void set_is_in_vthread_transition(oop java_thread, bool val);\n+  static int  is_in_vthread_transition_offset() { return _is_in_vthread_transition_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -592,9 +592,0 @@\n-void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {\n-  assert(event != nullptr, \"invariant\");\n-  assert(k != nullptr, \"invariant\");\n-  event->set_loadedClass(k);\n-  event->set_definingClassLoader(k->class_loader_data());\n-  event->set_initiatingClassLoader(init_cld);\n-  event->commit();\n-}\n-\n@@ -614,1 +605,1 @@\n-  EventClassLoad class_load_start_event;\n+  EventClassLoad class_load_event;\n@@ -745,2 +736,2 @@\n-  if (class_load_start_event.should_commit()) {\n-    post_class_load_event(&class_load_start_event, loaded_class, loader_data);\n+  if (class_load_event.should_commit()) {\n+    JFR_ONLY(post_class_load_event(&class_load_event, loaded_class, loader_data);)\n@@ -821,1 +812,1 @@\n-  EventClassLoad class_load_start_event;\n+  EventClassLoad class_load_event;\n@@ -851,0 +842,4 @@\n+  if (class_load_event.should_commit()) {\n+    JFR_ONLY(post_class_load_event(&class_load_event, k, loader_data);)\n+  }\n+\n@@ -857,3 +852,0 @@\n-  if (class_load_start_event.should_commit()) {\n-    post_class_load_event(&class_load_start_event, k, loader_data);\n-  }\n@@ -1304,0 +1296,2 @@\n+  EventClassLoad class_load_event;\n+\n@@ -1325,0 +1319,4 @@\n+  if (class_load_event.should_commit()) {\n+    JFR_ONLY(post_class_load_event(&class_load_event, ik, loader_data);)\n+  }\n+\n@@ -1330,0 +1328,11 @@\n+#if INCLUDE_JFR\n+void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {\n+  assert(event != nullptr, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n+  event->set_loadedClass(k);\n+  event->set_definingClassLoader(k->class_loader_data());\n+  event->set_initiatingClassLoader(init_cld);\n+  event->commit();\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1502,9 +1511,0 @@\n-static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {\n-  EventClassDefine event;\n-  if (event.should_commit()) {\n-    event.set_definedClass(k);\n-    event.set_definingClassLoader(def_cld);\n-    event.commit();\n-  }\n-}\n-\n@@ -1562,1 +1562,0 @@\n-  post_class_define_event(k, loader_data);\n@@ -1986,1 +1985,7 @@\n-    if (entry != nullptr && entry->nest_host_error() == nullptr) {\n+    if (entry == nullptr) {\n+      \/\/ Only add a new entry to the resolution error table if one hasn't been found for this\n+      \/\/ constant pool index. In this case resolution succeeded but there's an error in this nest host\n+      \/\/ that we use the table to record.\n+      assert(pool->resolved_klass_at(which) != nullptr, \"klass should be resolved if there is no entry\");\n+      ResolutionErrorTable::add_entry(pool, which, message);\n+    } else {\n@@ -1990,1 +1995,2 @@\n-      \/\/ the message. If we see it is already set then we can ignore it.\n+      \/\/ the message, and set it again.\n+      assert(entry->nest_host_error() == nullptr || strcmp(entry->nest_host_error(), message) == 0, \"should be the same message\");\n@@ -1992,2 +1998,0 @@\n-    } else {\n-      ResolutionErrorTable::add_entry(pool, which, message);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":34,"deletions":30,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-  \/\/ Used by AOTLinkedClassBulkLoader, LambdaProxyClassDictionary, and SystemDictionaryShared\n+  \/\/ Used by AOTLinkedClassBulkLoader, LambdaProxyClassDictionary, VMClasses and SystemDictionaryShared\n@@ -334,1 +334,0 @@\n-  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n@@ -348,0 +347,3 @@\n+  JFR_ONLY(static void post_class_load_event(EventClassLoad* event,\n+                                             const InstanceKlass* k,\n+                                             const ClassLoaderData* init_cld);)\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -666,4 +666,4 @@\n-  do_intrinsic(_notifyJvmtiVThreadStart, java_lang_VirtualThread, notifyJvmtiStart_name, void_method_signature, F_RN)   \\\n-  do_intrinsic(_notifyJvmtiVThreadEnd, java_lang_VirtualThread, notifyJvmtiEnd_name, void_method_signature, F_RN)       \\\n-  do_intrinsic(_notifyJvmtiVThreadMount, java_lang_VirtualThread, notifyJvmtiMount_name, bool_void_signature, F_RN)     \\\n-  do_intrinsic(_notifyJvmtiVThreadUnmount, java_lang_VirtualThread, notifyJvmtiUnmount_name, bool_void_signature, F_RN) \\\n+  do_intrinsic(_vthreadEndFirstTransition, java_lang_VirtualThread, endFirstTransition_name, void_method_signature, F_RN) \\\n+  do_intrinsic(_vthreadStartFinalTransition, java_lang_VirtualThread, startFinalTransition_name, void_method_signature, F_RN) \\\n+  do_intrinsic(_vthreadStartTransition, java_lang_VirtualThread, startTransition_name, bool_void_signature, F_RN)       \\\n+  do_intrinsic(_vthreadEndTransition, java_lang_VirtualThread, endTransition_name, bool_void_signature, F_RN)           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -425,4 +425,4 @@\n-  template(notifyJvmtiStart_name,                     \"notifyJvmtiStart\")                         \\\n-  template(notifyJvmtiEnd_name,                       \"notifyJvmtiEnd\")                           \\\n-  template(notifyJvmtiMount_name,                     \"notifyJvmtiMount\")                         \\\n-  template(notifyJvmtiUnmount_name,                   \"notifyJvmtiUnmount\")                       \\\n+  template(startTransition_name,                      \"startTransition\")                          \\\n+  template(endTransition_name,                        \"endTransition\")                            \\\n+  template(startFinalTransition_name,                 \"startFinalTransition\")                     \\\n+  template(endFirstTransition_name,                   \"endFirstTransition\")                       \\\n@@ -527,2 +527,2 @@\n-  template(jvmti_VTMS_transition_disable_count_name,  \"jvmti_VTMS_transition_disable_count\")      \\\n-  template(jvmti_is_in_VTMS_transition_name,          \"jvmti_is_in_VTMS_transition\")              \\\n+  template(vthread_transition_disable_count_name,     \"vthread_transition_disable_count\")         \\\n+  template(is_in_vthread_transition_name,             \"is_in_vthread_transition\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1358,6 +1358,0 @@\n-#if INCLUDE_JVMTI\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_start);\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_end);\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_mount);\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_unmount);\n-#endif\n@@ -1372,0 +1366,4 @@\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_end_first_transition_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_start_final_transition_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_start_transition_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_end_transition_C);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1516,0 +1516,34 @@\n+  \/\/ Fix relocation\n+  RelocIterator iter(this);\n+  CodeBuffer src(&nm);\n+  CodeBuffer dst(this);\n+  while (iter.next()) {\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+    \/\/ After an nmethod is moved, some direct call sites may end up out of range.\n+    \/\/ CallRelocation::fix_relocation_after_move() assumes the target is always\n+    \/\/ reachable and does not check branch range. Calling it without range checks\n+    \/\/ could cause us to write an offset too large for the instruction.\n+    \/\/\n+    \/\/ If a call site has a trampoline, we skip the normal call relocation. The\n+    \/\/ associated trampoline_stub_Relocation will handle the call and the\n+    \/\/ trampoline, including range checks and updating the branch as needed.\n+    \/\/\n+    \/\/ If no trampoline exists, we can assume the call target is always\n+    \/\/ reachable and therefore within direct branch range, so calling\n+    \/\/ CallRelocation::fix_relocation_after_move() is safe.\n+    if (iter.reloc()->is_call()) {\n+      address trampoline = trampoline_stub_Relocation::get_trampoline_for(iter.reloc()->addr(), this);\n+      if (trampoline != nullptr) {\n+        continue;\n+      }\n+    }\n+#endif\n+\n+    iter.reloc()->fix_relocation_after_move(&src, &dst);\n+  }\n+\n+  {\n+    MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+    clear_inline_caches();\n+  }\n+\n@@ -1539,19 +1573,0 @@\n-  \/\/ Fix relocation\n-  RelocIterator iter(nm_copy);\n-  CodeBuffer src(this);\n-  CodeBuffer dst(nm_copy);\n-  while (iter.next()) {\n-#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n-    \/\/ Direct calls may no longer be in range and the use of a trampoline may now be required.\n-    \/\/ Instead, allow trampoline relocations to update their owners and perform the necessary checks.\n-    if (iter.reloc()->is_call()) {\n-      address trampoline = trampoline_stub_Relocation::get_trampoline_for(iter.reloc()->addr(), nm_copy);\n-      if (trampoline != nullptr) {\n-        continue;\n-      }\n-    }\n-#endif\n-\n-    iter.reloc()->fix_relocation_after_move(&src, &dst);\n-  }\n-\n@@ -1587,2 +1602,0 @@\n-    nm_copy->clear_inline_caches();\n-\n@@ -1596,1 +1609,1 @@\n-      make_not_used();\n+      make_not_entrant(InvalidationReason::RELOCATED);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":35,"deletions":22,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -507,0 +507,1 @@\n+    RELOCATED,\n@@ -551,0 +552,2 @@\n+      case InvalidationReason::RELOCATED:\n+        return \"relocated\";\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1130,1 +1130,1 @@\n-JVM_VirtualThreadStart(JNIEnv* env, jobject vthread);\n+JVM_VirtualThreadEndFirstTransition(JNIEnv* env, jobject vthread);\n@@ -1133,1 +1133,1 @@\n-JVM_VirtualThreadEnd(JNIEnv* env, jobject vthread);\n+JVM_VirtualThreadStartFinalTransition(JNIEnv* env, jobject vthread);\n@@ -1136,1 +1136,1 @@\n-JVM_VirtualThreadMount(JNIEnv* env, jobject vthread, jboolean hide);\n+JVM_VirtualThreadStartTransition(JNIEnv* env, jobject vthread, jboolean is_mount);\n@@ -1139,1 +1139,1 @@\n-JVM_VirtualThreadUnmount(JNIEnv* env, jobject vthread, jboolean hide);\n+JVM_VirtualThreadEndTransition(JNIEnv* env, jobject vthread, jboolean is_mount);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -222,1 +222,2 @@\n-            top_frame = frame(synthetic_sp, synthetic_sp, sender_sp - 2, pc_desc->real_pc(sampled_nm), sampled_nm);\n+            intptr_t* const synthetic_fp = sender_sp AARCH64_ONLY( - frame::sender_sp_offset);\n+            top_frame = frame(synthetic_sp, synthetic_sp, synthetic_fp, pc_desc->real_pc(sampled_nm), sampled_nm);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -262,1 +263,1 @@\n-  JVMTI_ONLY(nonstatic_field(JavaThread,       _is_in_VTMS_transition,                        bool))                                 \\\n+  nonstatic_field(JavaThread,                  _is_in_vthread_transition,                     bool)                                  \\\n@@ -268,1 +269,1 @@\n-  JVMTI_ONLY(static_field(JvmtiVTMSTransitionDisabler, _VTMS_notify_jvmti_events,             bool))                                 \\\n+  static_field(MountUnmountDisabler,           _notify_jvmti_events,                          bool)                                  \\\n@@ -438,1 +439,1 @@\n-  static_field(java_lang_Thread,            _jvmti_is_in_VTMS_transition_offset,              int)                                   \\\n+  static_field(java_lang_Thread,            _is_in_vthread_transition_offset,                 int)                                   \\\n@@ -588,0 +589,1 @@\n+  declare_constant(nmethod::InvalidationReason::RELOCATED)                                \\\n@@ -883,4 +885,0 @@\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_start)) \\\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_end))   \\\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_mount)) \\\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_unmount)) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n@@ -851,1 +855,0 @@\n-  JFR_ONLY(RESTORE_ID(this);)\n@@ -865,0 +868,1 @@\n+\n@@ -869,0 +873,2 @@\n+  JFR_ONLY(Jfr::on_restoration(this, THREAD);)\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,0 +176,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  }\n@@ -186,0 +189,3 @@\n+  if (is_abstract()) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -877,0 +877,4 @@\n+  case vmIntrinsics::_vthreadEndFirstTransition:\n+  case vmIntrinsics::_vthreadStartFinalTransition:\n+  case vmIntrinsics::_vthreadStartTransition:\n+  case vmIntrinsics::_vthreadEndTransition:\n@@ -878,4 +882,0 @@\n-  case vmIntrinsics::_notifyJvmtiVThreadStart:\n-  case vmIntrinsics::_notifyJvmtiVThreadEnd:\n-  case vmIntrinsics::_notifyJvmtiVThreadMount:\n-  case vmIntrinsics::_notifyJvmtiVThreadUnmount:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -452,1 +452,0 @@\n-    C->dec_number_of_mh_late_inlines();\n@@ -464,1 +463,1 @@\n-  Compile::current()->inc_number_of_mh_late_inlines();\n+  Compile::current()->mark_has_mh_late_inlines();\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1201,1 +1201,0 @@\n-          phase->C->inc_number_of_mh_late_inlines();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -750,3 +750,4 @@\n-  \/\/ use MachConstantBase, it gets modified during matching. So when cloning\n-  \/\/ the node the JVMState must be deep cloned. Default is to shallow clone.\n-  virtual bool needs_deep_clone_jvms(Compile* C) { return C->needs_deep_clone_jvms(); }\n+  \/\/ use MachConstantBase, it gets modified during matching. If the call is\n+  \/\/ late inlined, it also needs the full JVMState. So when cloning the\n+  \/\/ node the JVMState must be deep cloned. Default is to shallow clone.\n+  virtual bool needs_deep_clone_jvms(Compile* C) { return _generator != nullptr || C->needs_deep_clone_jvms(); }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-  if (is_possible_unsafe_loop(phase)) {\n+  if (is_possible_unsafe_loop()) {\n@@ -340,1 +340,1 @@\n-bool RegionNode::is_possible_unsafe_loop(const PhaseGVN* phase) const {\n+bool RegionNode::is_possible_unsafe_loop() const {\n@@ -639,2 +639,2 @@\n-    \/\/ If it is LoopNopde it had 2 (+1 itself) inputs and\n-    \/\/ one of them was cut. The loop is dead if it was EntryContol.\n+    \/\/ If it is LoopNode it had 2 (+1 itself) inputs and\n+    \/\/ one of them was cut. The loop is dead if it was EntryControl.\n@@ -1406,1 +1406,1 @@\n-  const Node* region = in(0);\n+  RegionNode* region = in(0)->as_Region();\n@@ -1414,1 +1414,1 @@\n-      if (other_phi_input != nullptr && other_phi_input == merge_mem->base_memory()) {\n+      if (other_phi_input != nullptr && other_phi_input == merge_mem->base_memory() && !is_data_loop(region, phi_input, igvn)) {\n@@ -1416,0 +1416,1 @@\n+        \/\/ Only proceed if the transformation doesn't create a data loop\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  bool is_possible_unsafe_loop(const PhaseGVN* phase) const;\n+  bool is_possible_unsafe_loop() const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1474,0 +1474,59 @@\n+OptoReg::Name PhaseChaitin::select_bias_lrg_color(LRG& lrg) {\n+  uint bias_lrg1_idx = _lrg_map.find(lrg._copy_bias);\n+  uint bias_lrg2_idx = _lrg_map.find(lrg._copy_bias2);\n+\n+  \/\/ If bias_lrg1 has a color\n+  if (bias_lrg1_idx != 0 && !_ifg->_yanked->test(bias_lrg1_idx)) {\n+    OptoReg::Name reg = lrgs(bias_lrg1_idx).reg();\n+    \/\/  and it is legal for lrg\n+    if (is_legal_reg(lrg, reg)) {\n+      return reg;\n+    }\n+  }\n+\n+  \/\/ If bias_lrg2 has a color\n+  if (bias_lrg2_idx != 0 && !_ifg->_yanked->test(bias_lrg2_idx)) {\n+    OptoReg::Name reg = lrgs(bias_lrg2_idx).reg();\n+    \/\/  and it is legal for lrg\n+    if (is_legal_reg(lrg, reg)) {\n+      return reg;\n+    }\n+  }\n+\n+  uint bias_lrg_idx = 0;\n+  if (bias_lrg1_idx != 0 && bias_lrg2_idx != 0) {\n+    \/\/ Since none of the bias live ranges are part of the IFG yet, constrain the\n+    \/\/ definition mask with the bias live range with the least degrees of\n+    \/\/ freedom. This will increase the chances of register sharing once the bias\n+    \/\/ live range becomes part of the IFG.\n+    lrgs(bias_lrg1_idx).compute_set_mask_size();\n+    lrgs(bias_lrg2_idx).compute_set_mask_size();\n+    bias_lrg_idx = lrgs(bias_lrg1_idx).degrees_of_freedom() >\n+                           lrgs(bias_lrg2_idx).degrees_of_freedom()\n+                       ? bias_lrg2_idx\n+                       : bias_lrg1_idx;\n+  } else if (bias_lrg1_idx != 0) {\n+    bias_lrg_idx = bias_lrg1_idx;\n+  } else if (bias_lrg2_idx != 0) {\n+    bias_lrg_idx = bias_lrg2_idx;\n+  }\n+\n+  \/\/ Register masks with offset excludes all mask bits before the offset.\n+  \/\/ Such masks are mainly used for allocation from stack slots. Constrain the\n+  \/\/ register mask of definition live range using bias mask only if\n+  \/\/ both masks have zero offset.\n+  if (bias_lrg_idx != 0 && !lrg.mask().is_offset() &&\n+      !lrgs(bias_lrg_idx).mask().is_offset()) {\n+    \/\/ Choose a color which is legal for bias_lrg\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask tempmask(lrg.mask(), C->regmask_arena());\n+    tempmask.and_with(lrgs(bias_lrg_idx).mask());\n+    tempmask.clear_to_sets(lrg.num_regs());\n+    OptoReg::Name reg = find_first_set(lrg, tempmask);\n+    if (OptoReg::is_valid(reg)) {\n+      return reg;\n+    }\n+  }\n+  return OptoReg::Bad;\n+}\n+\n@@ -1495,19 +1554,4 @@\n-  uint copy_lrg = _lrg_map.find(lrg._copy_bias);\n-  if (copy_lrg != 0) {\n-    \/\/ If he has a color,\n-    if(!_ifg->_yanked->test(copy_lrg)) {\n-      OptoReg::Name reg = lrgs(copy_lrg).reg();\n-      \/\/  And it is legal for you,\n-      if (is_legal_reg(lrg, reg)) {\n-        return reg;\n-      }\n-    } else if (!lrg.mask().is_offset()) {\n-      \/\/ Choose a color which is legal for him\n-      ResourceMark rm(C->regmask_arena());\n-      RegMask tempmask(lrg.mask(), C->regmask_arena());\n-      tempmask.and_with(lrgs(copy_lrg).mask());\n-      tempmask.clear_to_sets(lrg.num_regs());\n-      OptoReg::Name reg = find_first_set(lrg, tempmask);\n-      if (OptoReg::is_valid(reg))\n-        return reg;\n-    }\n+  \/\/ Try biasing the color with non-interfering bias live range[s].\n+  OptoReg::Name reg = select_bias_lrg_color(lrg);\n+  if (OptoReg::is_valid(reg)) {\n+    return reg;\n@@ -1527,1 +1571,1 @@\n-  OptoReg::Name reg = lrg.mask().find_first_elem();\n+  reg = lrg.mask().find_first_elem();\n@@ -1643,0 +1687,21 @@\n+\n+    Node* def = lrg->_def;\n+    if (lrg->is_singledef() && !lrg->_is_bound && def->is_Mach()) {\n+      MachNode* mdef = def->as_Mach();\n+      if (Matcher::is_register_biasing_candidate(mdef, 1)) {\n+        Node* in1 = mdef->in(mdef->operand_index(1));\n+        if (in1 != nullptr && lrg->_copy_bias == 0) {\n+          lrg->_copy_bias = _lrg_map.find(in1);\n+        }\n+      }\n+\n+      \/\/ For commutative operations, def allocation can also be\n+      \/\/ biased towards LRG of second input's def.\n+      if (Matcher::is_register_biasing_candidate(mdef, 2)) {\n+        Node* in2 = mdef->in(mdef->operand_index(2));\n+        if (in2 != nullptr && lrg->_copy_bias2 == 0) {\n+          lrg->_copy_bias2 = _lrg_map.find(in2);\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":85,"deletions":20,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -710,1 +710,1 @@\n-      _number_of_mh_late_inlines(0),\n+      _has_mh_late_inlines(false),\n@@ -981,1 +981,1 @@\n-      _number_of_mh_late_inlines(0),\n+      _has_mh_late_inlines(false),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -490,1 +490,3 @@\n-  uint                          _number_of_mh_late_inlines; \/\/ number of method handle late inlining still pending\n+  bool                          _has_mh_late_inlines; \/\/ Can there still be a method handle late inlining pending?\n+                                                      \/\/ false: there can't be one\n+                                                      \/\/ true: we've enqueued one at some point so there may still be one\n@@ -1138,3 +1140,2 @@\n-  void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }\n-  void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines > 0, \"_number_of_mh_late_inlines < 0 !\"); _number_of_mh_late_inlines--; }\n-  bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines > 0; }\n+  void mark_has_mh_late_inlines() { _has_mh_late_inlines = true; }\n+  bool has_mh_late_inlines() const { return _has_mh_late_inlines; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1170,1 +1170,0 @@\n-  \/\/ Note:  This call must not deoptimize, since it is not a real at this bci!\n@@ -1173,5 +1172,11 @@\n-  make_runtime_call(RC_NO_LEAF | RC_MUST_THROW,\n-                    OptoRuntime::rethrow_Type(),\n-                    OptoRuntime::rethrow_stub(),\n-                    nullptr, nullptr,\n-                    ex_node);\n+  { PreserveReexecuteState preexecs(this);\n+    \/\/ When throwing an exception, set the reexecute flag for deoptimization.\n+    \/\/ This is mostly needed to pass -XX:+VerifyStack sanity checks.\n+    jvms()->set_should_reexecute(true);\n+\n+    make_runtime_call(RC_NO_LEAF | RC_MUST_THROW,\n+                      OptoRuntime::rethrow_Type(),\n+                      OptoRuntime::rethrow_stub(),\n+                      nullptr, nullptr,\n+                      ex_node);\n+  }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -502,0 +503,8 @@\n+  case vmIntrinsics::_vthreadEndFirstTransition:    return inline_native_vthread_end_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_end_first_transition_Java()),\n+                                                                                                \"endFirstTransition\", true);\n+  case vmIntrinsics::_vthreadStartFinalTransition:  return inline_native_vthread_start_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_start_final_transition_Java()),\n+                                                                                                  \"startFinalTransition\", true);\n+  case vmIntrinsics::_vthreadStartTransition:       return inline_native_vthread_start_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_start_transition_Java()),\n+                                                                                                  \"startTransition\", false);\n+  case vmIntrinsics::_vthreadEndTransition:         return inline_native_vthread_end_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_end_transition_Java()),\n+                                                                                                \"endTransition\", false);\n@@ -503,8 +512,0 @@\n-  case vmIntrinsics::_notifyJvmtiVThreadStart:   return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_start()),\n-                                                                                         \"notifyJvmtiStart\", true, false);\n-  case vmIntrinsics::_notifyJvmtiVThreadEnd:     return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_end()),\n-                                                                                         \"notifyJvmtiEnd\", false, true);\n-  case vmIntrinsics::_notifyJvmtiVThreadMount:   return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_mount()),\n-                                                                                         \"notifyJvmtiMount\", false, false);\n-  case vmIntrinsics::_notifyJvmtiVThreadUnmount: return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_unmount()),\n-                                                                                         \"notifyJvmtiUnmount\", false, false);\n@@ -3473,0 +3474,16 @@\n+\/\/--------------------inline_native_vthread_start_transition--------------------\n+\/\/ inline void startTransition(boolean is_mount);\n+\/\/ inline void startFinalTransition();\n+\/\/ Pseudocode of implementation:\n+\/\/\n+\/\/ java_lang_Thread::set_is_in_vthread_transition(vthread, true);\n+\/\/ carrier->set_is_in_vthread_transition(true);\n+\/\/ OrderAccess::storeload();\n+\/\/ int disable_requests = java_lang_Thread::vthread_transition_disable_count(vthread)\n+\/\/                        + global_vthread_transition_disable_count();\n+\/\/ if (disable_requests > 0) {\n+\/\/   slow path: runtime call\n+\/\/ }\n+bool LibraryCallKit::inline_native_vthread_start_transition(address funcAddr, const char* funcName, bool is_final_transition) {\n+  Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n+  IdealKit ideal(this);\n@@ -3474,7 +3491,20 @@\n-#if INCLUDE_JVMTI\n-\n-\/\/ When notifications are disabled then just update the VTMS transition bit and return.\n-\/\/ Otherwise, the bit is updated in the given function call implementing JVMTI notification protocol.\n-bool LibraryCallKit::inline_native_notify_jvmti_funcs(address funcAddr, const char* funcName, bool is_start, bool is_end) {\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    return true;\n+  Node* thread = ideal.thread();\n+  Node* jt_addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_vthread_transition_offset()));\n+  Node* vt_addr = basic_plus_adr(vt_oop, java_lang_Thread::is_in_vthread_transition_offset());\n+  access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), ideal.ConI(1), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+  access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), ideal.ConI(1), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+  insert_mem_bar(Op_MemBarVolatile);\n+  ideal.sync_kit(this);\n+\n+  Node* global_disable_addr = makecon(TypeRawPtr::make((address)MountUnmountDisabler::global_vthread_transition_disable_count_address()));\n+  Node* global_disable = ideal.load(ideal.ctrl(), global_disable_addr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, true \/*require_atomic_access*\/);\n+  Node* vt_disable_addr = basic_plus_adr(vt_oop, java_lang_Thread::vthread_transition_disable_count_offset());\n+  Node* vt_disable = ideal.load(ideal.ctrl(), vt_disable_addr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, true \/*require_atomic_access*\/);\n+  Node* disabled = _gvn.transform(new AddINode(global_disable, vt_disable));\n+\n+  ideal.if_then(disabled, BoolTest::ne, ideal.ConI(0)); {\n+    sync_kit(ideal);\n+    Node* is_mount = is_final_transition ? ideal.ConI(0) : _gvn.transform(argument(1));\n+    const TypeFunc* tf = OptoRuntime::vthread_transition_Type();\n+    make_runtime_call(RC_NO_LEAF, tf, funcAddr, funcName, TypePtr::BOTTOM, vt_oop, is_mount);\n+    ideal.sync_kit(this);\n@@ -3482,0 +3512,7 @@\n+  ideal.end_if();\n+\n+  final_sync(ideal);\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_native_vthread_end_transition(address funcAddr, const char* funcName, bool is_first_transition) {\n@@ -3485,4 +3522,2 @@\n-  Node* ONE = ideal.ConI(1);\n-  Node* hide = is_start ? ideal.ConI(0) : (is_end ? ideal.ConI(1) : _gvn.transform(argument(1)));\n-  Node* addr = makecon(TypeRawPtr::make((address)&JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events));\n-  Node* notify_jvmti_enabled = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+  Node* _notify_jvmti_addr = makecon(TypeRawPtr::make((address)MountUnmountDisabler::notify_jvmti_events_address()));\n+  Node* _notify_jvmti = ideal.load(ideal.ctrl(), _notify_jvmti_addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n@@ -3490,1 +3525,1 @@\n-  ideal.if_then(notify_jvmti_enabled, BoolTest::eq, ONE); {\n+  ideal.if_then(_notify_jvmti, BoolTest::eq, ideal.ConI(1)); {\n@@ -3492,3 +3527,3 @@\n-    \/\/ if notifyJvmti enabled then make a call to the given SharedRuntime function\n-    const TypeFunc* tf = OptoRuntime::notify_jvmti_vthread_Type();\n-    make_runtime_call(RC_NO_LEAF, tf, funcAddr, funcName, TypePtr::BOTTOM, vt_oop, hide);\n+    Node* is_mount = is_first_transition ? ideal.ConI(1) : _gvn.transform(argument(1));\n+    const TypeFunc* tf = OptoRuntime::vthread_transition_Type();\n+    make_runtime_call(RC_NO_LEAF, tf, funcAddr, funcName, TypePtr::BOTTOM, vt_oop, is_mount);\n@@ -3497,3 +3532,2 @@\n-    \/\/ set hide value to the VTMS transition bit in current JavaThread and VirtualThread object\n-    Node* jt_addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_VTMS_transition_offset()));\n-    Node* vt_addr = basic_plus_adr(vt_oop, java_lang_Thread::is_in_VTMS_transition_offset());\n+    Node* jt_addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_vthread_transition_offset()));\n+    Node* vt_addr = basic_plus_adr(vt_oop, java_lang_Thread::is_in_vthread_transition_offset());\n@@ -3503,3 +3537,2 @@\n-    access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-    access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-\n+    access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), ideal.ConI(0), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), ideal.ConI(0), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n@@ -3508,1 +3541,1 @@\n-  final_sync(ideal);\n+  final_sync(ideal);\n@@ -3513,0 +3546,2 @@\n+#if INCLUDE_JVMTI\n+\n@@ -7895,0 +7930,1 @@\n+  bool is_decrypt = false;\n@@ -7905,0 +7941,1 @@\n+    is_decrypt = true;\n@@ -7938,1 +7975,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, is_decrypt);\n@@ -7953,1 +7990,1 @@\n-\n+  bool is_decrypt = false;\n@@ -7964,0 +8001,1 @@\n+    is_decrypt = true;\n@@ -8017,1 +8055,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, is_decrypt);\n@@ -8041,1 +8079,1 @@\n-\n+  bool is_decrypt = false;\n@@ -8052,0 +8090,1 @@\n+    is_decrypt = true;\n@@ -8103,1 +8142,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, is_decrypt);\n@@ -8171,1 +8210,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, \/* is_decrypt *\/ false);\n@@ -8196,2 +8235,1 @@\n-Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {\n-#if defined(PPC64) || defined(S390) || defined(RISCV64)\n+Node* LibraryCallKit::get_key_start_from_aescrypt_object(Node* aescrypt_object, bool is_decrypt) {\n@@ -8201,7 +8239,3 @@\n-  \/\/ The ppc64 and riscv64 stubs of encryption and decryption use the same round keys (sessionK[0]).\n-  Node* objSessionK = load_field_from_object(aescrypt_object, \"sessionK\", \"[[I\");\n-  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n-  if (objSessionK == nullptr) {\n-    return (Node *) nullptr;\n-  }\n-  Node* objAESCryptKey = load_array_element(objSessionK, intcon(0), TypeAryPtr::OOPS, \/* set_ctrl *\/ true);\n+  \/\/ The following platform specific stubs of encryption and decryption use the same round keys.\n+#if defined(PPC64) || defined(S390) || defined(RISCV64)\n+  bool use_decryption_key = false;\n@@ -8209,3 +8243,4 @@\n-  Node* objAESCryptKey = load_field_from_object(aescrypt_object, \"K\", \"[I\");\n-#endif \/\/ PPC64\n-  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n+  bool use_decryption_key = is_decrypt;\n+#endif\n+  Node* objAESCryptKey = load_field_from_object(aescrypt_object, use_decryption_key ? \"sessionKd\" : \"sessionKe\", \"[I\");\n+  assert(objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n@@ -8214,1 +8249,1 @@\n-  \/\/ now have the array, need to get the start address of the K array\n+  \/\/ now have the array, need to get the start address of the selected key array\n@@ -9350,1 +9385,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, \/* is_decrypt *\/ false);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":85,"deletions":50,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -307,0 +307,4 @@\n+\n+  bool inline_native_vthread_start_transition(address funcAddr, const char* funcName, bool is_final_transition);\n+  bool inline_native_vthread_end_transition(address funcAddr, const char* funcName, bool is_first_transition);\n+\n@@ -308,2 +312,0 @@\n-  bool inline_native_notify_jvmti_funcs(address funcAddr, const char* funcName, bool is_start, bool is_end);\n-  bool inline_native_notify_jvmti_hide();\n@@ -374,1 +376,1 @@\n-  Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);\n+  Node* get_key_start_from_aescrypt_object(Node* aescrypt_object, bool is_decrypt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -479,0 +479,7 @@\n+int MachNode::operand_num_edges(uint oper_index) const {\n+  if (num_opnds() > oper_index) {\n+    return _opnds[oper_index]->num_edges();\n+  }\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -270,0 +270,1 @@\n+  int  operand_num_edges(uint operand) const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -321,7 +321,6 @@\n-  \/\/ Finally, make sure the incoming arguments take up an even number of\n-  \/\/ words, in case the arguments or locals need to contain doubleword stack\n-  \/\/ slots.  The rest of the system assumes that stack slot pairs (in\n-  \/\/ particular, in the spill area) which look aligned will in fact be\n-  \/\/ aligned relative to the stack pointer in the target machine.  Double\n-  \/\/ stack slots will always be allocated aligned.\n-  _new_SP = OptoReg::Name(align_up(_in_arg_limit, (int)RegMask::SlotsPerLong));\n+  \/\/ Allocated register sets are aligned to their size. Offsets to the stack\n+  \/\/ pointer have to be aligned to the size of the access. For this _new_SP is\n+  \/\/ aligned to the size of the largest register set with the stack alignment as\n+  \/\/ limit and a minimum of SlotsPerLong (2).\n+  int vector_aligment = MIN2(C->max_vector_size(), stack_alignment_in_bytes()) \/ VMRegImpl::stack_slot_size;\n+  _new_SP = OptoReg::Name(align_up(_in_arg_limit, MAX2((int)RegMask::SlotsPerLong, vector_aligment)));\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -517,0 +517,2 @@\n+  static bool is_register_biasing_candidate(const MachNode* mdef, int oper_index);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -844,20 +844,20 @@\n-  enum NodeFlags {\n-    Flag_is_Copy                     = 1 << 0, \/\/ should be first bit to avoid shift\n-    Flag_rematerialize               = 1 << 1,\n-    Flag_needs_anti_dependence_check = 1 << 2,\n-    Flag_is_macro                    = 1 << 3,\n-    Flag_is_Con                      = 1 << 4,\n-    Flag_is_cisc_alternate           = 1 << 5,\n-    Flag_is_dead_loop_safe           = 1 << 6,\n-    Flag_may_be_short_branch         = 1 << 7,\n-    Flag_avoid_back_to_back_before   = 1 << 8,\n-    Flag_avoid_back_to_back_after    = 1 << 9,\n-    Flag_has_call                    = 1 << 10,\n-    Flag_has_swapped_edges           = 1 << 11,\n-    Flag_is_scheduled                = 1 << 12,\n-    Flag_is_expensive                = 1 << 13,\n-    Flag_is_predicated_vector        = 1 << 14,\n-    Flag_for_post_loop_opts_igvn     = 1 << 15,\n-    Flag_for_merge_stores_igvn       = 1 << 16,\n-    Flag_is_removed_by_peephole      = 1 << 17,\n-    Flag_is_predicated_using_blend   = 1 << 18,\n+  enum NodeFlags : uint64_t {\n+    Flag_is_Copy                     = 1ULL << 0, \/\/ should be first bit to avoid shift\n+    Flag_rematerialize               = 1ULL << 1,\n+    Flag_needs_anti_dependence_check = 1ULL << 2,\n+    Flag_is_macro                    = 1ULL << 3,\n+    Flag_is_Con                      = 1ULL << 4,\n+    Flag_is_cisc_alternate           = 1ULL << 5,\n+    Flag_is_dead_loop_safe           = 1ULL << 6,\n+    Flag_may_be_short_branch         = 1ULL << 7,\n+    Flag_avoid_back_to_back_before   = 1ULL << 8,\n+    Flag_avoid_back_to_back_after    = 1ULL << 9,\n+    Flag_has_call                    = 1ULL << 10,\n+    Flag_has_swapped_edges           = 1ULL << 11,\n+    Flag_is_scheduled                = 1ULL << 12,\n+    Flag_is_expensive                = 1ULL << 13,\n+    Flag_is_predicated_vector        = 1ULL << 14,\n+    Flag_for_post_loop_opts_igvn     = 1ULL << 15,\n+    Flag_for_merge_stores_igvn       = 1ULL << 16,\n+    Flag_is_removed_by_peephole      = 1ULL << 17,\n+    Flag_is_predicated_using_blend   = 1ULL << 18,\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -97,3 +98,1 @@\n-#define C2_JVMTI_STUB_FIELD_DEFINE(name) \\\n-  address OptoRuntime:: STUB_FIELD_NAME(name) = nullptr;\n-C2_STUBS_DO(C2_BLOB_FIELD_DEFINE, C2_STUB_FIELD_DEFINE, C2_JVMTI_STUB_FIELD_DEFINE)\n+C2_STUBS_DO(C2_BLOB_FIELD_DEFINE, C2_STUB_FIELD_DEFINE)\n@@ -102,1 +101,0 @@\n-#undef C2_JVMTI_STUB_FIELD_DEFINE\n@@ -158,14 +156,0 @@\n-#define C2_JVMTI_STUB_C_FUNC(name) CAST_FROM_FN_PTR(address, SharedRuntime::name)\n-\n-#define GEN_C2_JVMTI_STUB(name)                                       \\\n-  STUB_FIELD_NAME(name) =                                             \\\n-    generate_stub(env,                                                \\\n-                  notify_jvmti_vthread_Type,                          \\\n-                  C2_JVMTI_STUB_C_FUNC(name),                         \\\n-                  C2_STUB_NAME(name),                                 \\\n-                  C2_STUB_ID(name),                                   \\\n-                  0,                                                  \\\n-                  true,                                               \\\n-                  false);                                             \\\n-  if (STUB_FIELD_NAME(name) == nullptr) { return false; }             \\\n-\n@@ -174,1 +158,1 @@\n-  C2_STUBS_DO(GEN_C2_BLOB, GEN_C2_STUB, GEN_C2_JVMTI_STUB)\n+  C2_STUBS_DO(GEN_C2_BLOB, GEN_C2_STUB)\n@@ -187,2 +171,0 @@\n-#undef C2_JVMTI_STUB_C_FUNC\n-#undef GEN_C2_JVMTI_STUB\n@@ -263,0 +245,1 @@\n+const TypeFunc* OptoRuntime::_vthread_transition_Type             = nullptr;\n@@ -266,3 +249,0 @@\n-#if INCLUDE_JVMTI\n-const TypeFunc* OptoRuntime::_notify_jvmti_vthread_Type           = nullptr;\n-#endif \/\/ INCLUDE_JVMTI\n@@ -597,0 +577,20 @@\n+JRT_ENTRY(void, OptoRuntime::vthread_end_first_transition_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  MountUnmountDisabler::end_transition(current, vt, true \/*is_mount*\/, true \/*is_thread_start*\/);\n+JRT_END\n+\n+JRT_ENTRY(void, OptoRuntime::vthread_start_final_transition_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  java_lang_Thread::set_is_in_vthread_transition(vt, false);\n+  current->set_is_in_vthread_transition(false);\n+  MountUnmountDisabler::start_transition(current, vt, false \/*is_mount *\/, true \/*is_thread_end*\/);\n+JRT_END\n+\n+JRT_ENTRY(void, OptoRuntime::vthread_start_transition_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  java_lang_Thread::set_is_in_vthread_transition(vt, false);\n+  current->set_is_in_vthread_transition(false);\n+  MountUnmountDisabler::start_transition(current, vt, is_mount, false \/*is_thread_end*\/);\n+JRT_END\n+\n+JRT_ENTRY(void, OptoRuntime::vthread_end_transition_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  MountUnmountDisabler::end_transition(current, vt, is_mount, false \/*is_thread_start*\/);\n+JRT_END\n+\n@@ -613,2 +613,1 @@\n-#if INCLUDE_JVMTI\n-static const TypeFunc* make_notify_jvmti_vthread_Type() {\n+static const TypeFunc* make_vthread_transition_Type() {\n@@ -628,1 +627,0 @@\n-#endif\n@@ -2380,0 +2378,1 @@\n+  _vthread_transition_Type            = make_vthread_transition_Type();\n@@ -2383,3 +2382,0 @@\n-#if INCLUDE_JVMTI\n-  _notify_jvmti_vthread_Type          = make_notify_jvmti_vthread_Type();\n-#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":26,"deletions":30,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -118,3 +118,1 @@\n-#define C2_JVMTI_STUB_FIELD_DECLARE(name) \\\n-  static address     STUB_FIELD_NAME(name);\n-  C2_STUBS_DO(C2_BLOB_FIELD_DECLARE, C2_STUB_FIELD_DECLARE, C2_JVMTI_STUB_FIELD_DECLARE)\n+  C2_STUBS_DO(C2_BLOB_FIELD_DECLARE, C2_STUB_FIELD_DECLARE)\n@@ -126,1 +124,0 @@\n-#undef C2_JVMTI_STUB_FIELD_DECLARE\n@@ -201,0 +198,1 @@\n+  static const TypeFunc* _vthread_transition_Type;\n@@ -204,3 +202,0 @@\n-#if INCLUDE_JVMTI\n-  static const TypeFunc* _notify_jvmti_vthread_Type;\n-#endif \/\/ INCLUDE_JVMTI\n@@ -243,0 +238,5 @@\n+  static void vthread_end_first_transition_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+  static void vthread_start_final_transition_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+  static void vthread_start_transition_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+  static void vthread_end_transition_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+\n@@ -301,6 +301,5 @@\n-#if INCLUDE_JVMTI\n-  static address notify_jvmti_vthread_start()            { return _notify_jvmti_vthread_start; }\n-  static address notify_jvmti_vthread_end()              { return _notify_jvmti_vthread_end; }\n-  static address notify_jvmti_vthread_mount()            { return _notify_jvmti_vthread_mount; }\n-  static address notify_jvmti_vthread_unmount()          { return _notify_jvmti_vthread_unmount; }\n-#endif\n+\n+  static address vthread_end_first_transition_Java()     { return _vthread_end_first_transition_Java; }\n+  static address vthread_start_final_transition_Java()   { return _vthread_start_final_transition_Java; }\n+  static address vthread_start_transition_Java()         { return _vthread_start_transition_Java; }\n+  static address vthread_end_transition_Java()           { return _vthread_end_transition_Java; }\n@@ -727,0 +726,21 @@\n+  static inline const TypeFunc* vthread_transition_Type() {\n+    assert(_vthread_transition_Type != nullptr, \"should be initialized\");\n+    return _vthread_transition_Type;\n+  }\n+\n+  static inline const TypeFunc* vthread_end_first_transition_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n+  static inline const TypeFunc* vthread_start_final_transition_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n+  static inline const TypeFunc* vthread_start_transition_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n+  static inline const TypeFunc* vthread_end_transition_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n@@ -740,7 +760,0 @@\n-#if INCLUDE_JVMTI\n-  static inline const TypeFunc* notify_jvmti_vthread_Type() {\n-    assert(_notify_jvmti_vthread_Type != nullptr, \"should be initialized\");\n-    return _notify_jvmti_vthread_Type;\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -3834,13 +3835,3 @@\n-JVM_ENTRY(void, JVM_VirtualThreadStart(JNIEnv* env, jobject vthread))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_start(vthread);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, false);\n-  }\n-#endif\n+JVM_ENTRY(void, JVM_VirtualThreadEndFirstTransition(JNIEnv* env, jobject vthread))\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::end_transition(thread, vt, true \/*is_mount*\/, true \/*is_thread_start*\/);\n@@ -3849,13 +3840,3 @@\n-JVM_ENTRY(void, JVM_VirtualThreadEnd(JNIEnv* env, jobject vthread))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_end(vthread);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, true);\n-  }\n-#endif\n+JVM_ENTRY(void, JVM_VirtualThreadStartFinalTransition(JNIEnv* env, jobject vthread))\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::start_transition(thread, vt, false \/*is_mount *\/, true \/*is_thread_end*\/);\n@@ -3864,15 +3845,3 @@\n-\/\/ If notifications are disabled then just update the VTMS transition bit and return.\n-\/\/ Otherwise, the bit is updated in the given jvmtiVTMSTransitionDisabler function call.\n-JVM_ENTRY(void, JVM_VirtualThreadMount(JNIEnv* env, jobject vthread, jboolean hide))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_mount(vthread, hide);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, hide);\n-  }\n-#endif\n+JVM_ENTRY(void, JVM_VirtualThreadStartTransition(JNIEnv* env, jobject vthread, jboolean is_mount))\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::start_transition(thread, vt, is_mount, false \/*is_thread_end*\/);\n@@ -3881,15 +3850,3 @@\n-\/\/ If notifications are disabled then just update the VTMS transition bit and return.\n-\/\/ Otherwise, the bit is updated in the given jvmtiVTMSTransitionDisabler function call below.\n-JVM_ENTRY(void, JVM_VirtualThreadUnmount(JNIEnv* env, jobject vthread, jboolean hide))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount(vthread, hide);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, hide);\n-  }\n-#endif\n+JVM_ENTRY(void, JVM_VirtualThreadEndTransition(JNIEnv* env, jobject vthread, jboolean is_mount))\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::end_transition(thread, vt, is_mount, false \/*is_thread_start*\/);\n@@ -3945,0 +3902,1 @@\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":14,"deletions":56,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -150,1 +151,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -203,1 +204,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(thread);\n+    MountUnmountDisabler disabler(thread);\n@@ -564,1 +565,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -588,1 +589,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -870,1 +871,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -942,1 +943,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(true);\n+    MountUnmountDisabler disabler(true);\n@@ -952,1 +953,1 @@\n-    \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n+    \/\/ Do not use MountUnmountDisabler in context of self suspend to avoid deadlocks.\n@@ -977,1 +978,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(true);\n+    MountUnmountDisabler disabler(true);\n@@ -1010,1 +1011,1 @@\n-  \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n+  \/\/ Do not use MountUnmountDisabler in context of self suspend to avoid deadlocks.\n@@ -1031,1 +1032,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(true);\n+    MountUnmountDisabler disabler(true);\n@@ -1081,1 +1082,1 @@\n-  \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n+  \/\/ Do not use MountUnmountDisabler in context of self suspend to avoid deadlocks.\n@@ -1092,1 +1093,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(true);\n+  MountUnmountDisabler disabler(true);\n@@ -1114,1 +1115,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(true);\n+  MountUnmountDisabler disabler(true);\n@@ -1153,1 +1154,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(true);\n+  MountUnmountDisabler disabler(true);\n@@ -1199,1 +1200,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1237,1 +1238,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1283,1 +1284,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1372,1 +1373,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1427,1 +1428,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1710,1 +1711,1 @@\n-    JvmtiVTMSTransitionDisabler disabler;\n+    MountUnmountDisabler disabler;\n@@ -1743,1 +1744,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1798,1 +1799,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1826,1 +1827,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2087,1 +2088,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2128,1 +2129,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2170,1 +2171,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2212,1 +2213,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2254,1 +2255,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2296,1 +2297,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2337,1 +2338,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2374,1 +2375,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2411,1 +2412,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2448,1 +2449,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2485,1 +2486,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2577,1 +2578,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -2590,1 +2591,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -2603,1 +2604,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -2616,1 +2617,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -3423,1 +3424,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -3453,1 +3454,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -3475,1 +3476,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -515,2 +515,10 @@\n-WB_ENTRY(jboolean, WB_HasExternalSymbolsStripped(JNIEnv* env, jobject o))\n-#if defined(HAS_STRIPPED_DEBUGINFO)\n+WB_ENTRY(jboolean, WB_ShipDebugInfoFull(JNIEnv* env, jobject o))\n+#if defined(SHIP_DEBUGINFO_FULL)\n+  return true;\n+#else\n+  return false;\n+#endif\n+WB_END\n+\n+WB_ENTRY(jboolean, WB_ShipDebugInfoPublic(JNIEnv* env, jobject o))\n+#if defined(SHIP_DEBUGINFO_PUBLIC)\n@@ -1685,1 +1693,1 @@\n-    if (code->is_in_use()) {\n+    if (code->is_in_use() && !code->is_unloading()) {\n@@ -2950,1 +2958,2 @@\n-  {CC\"hasExternalSymbolsStripped\",       CC\"()Z\",                   (void*)&WB_HasExternalSymbolsStripped},\n+  {CC\"shipsFullDebugInfo\",               CC\"()Z\",                   (void*)&WB_ShipDebugInfoFull},\n+  {CC\"shipsPublicDebugInfo\",             CC\"()Z\",                   (void*)&WB_ShipDebugInfoPublic},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1495,1 +1495,1 @@\n-  _conservative_max_heap_alignment = MAX4(heap_alignment,\n+  _conservative_max_heap_alignment = MAX3(heap_alignment,\n@@ -1497,2 +1497,1 @@\n-                                          os::max_page_size(),\n-                                          GCArguments::compute_heap_alignment());\n+                                          os::max_page_size());\n@@ -1607,2 +1606,2 @@\n-      size_t heap_end = HeapBaseMinAddress + MaxHeapSize;\n-      size_t max_coop_heap = max_heap_for_compressed_oops();\n+      uintptr_t heap_end = HeapBaseMinAddress + MaxHeapSize;\n+      uintptr_t max_coop_heap = max_heap_for_compressed_oops();\n@@ -1625,1 +1624,1 @@\n-                            reasonable_max, max_coop_heap, MaxRAMPercentage);\n+                            reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -59,2 +60,1 @@\n-#if INCLUDE_JVMTI\n-class JvmtiUnmountBeginMark : public StackObj {\n+class UnmountBeginMark : public StackObj {\n@@ -67,1 +67,1 @@\n-  JvmtiUnmountBeginMark(JavaThread* t) :\n+  UnmountBeginMark(JavaThread* t) :\n@@ -69,13 +69,3 @@\n-    assert(!_current->is_in_VTMS_transition(), \"must be\");\n-\n-    if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-      JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount((jthread)_vthread.raw_value(), true);\n-\n-      \/\/ Don't preempt if there is a pending popframe or earlyret operation. This can\n-      \/\/ be installed in start_VTMS_transition() so we need to check it here.\n-      if (JvmtiExport::can_pop_frame() || JvmtiExport::can_force_early_return()) {\n-        JvmtiThreadState* state = _current->jvmti_thread_state();\n-        if (_current->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n-          _failed = true;\n-        }\n-      }\n+    assert(!_current->is_in_vthread_transition(), \"must be\");\n+\n+    MountUnmountDisabler::start_transition(_current, _vthread(), false \/*is_mount*\/, false \/*is_thread_start*\/);\n@@ -83,3 +73,5 @@\n-      \/\/ Don't preempt in case there is an async exception installed since\n-      \/\/ we would incorrectly throw it during the unmount logic in the carrier.\n-      if (_current->has_async_exception_condition()) {\n+    \/\/ Don't preempt if there is a pending popframe or earlyret operation. This can\n+    \/\/ be installed in in process_at_transition_start() so we need to check it here.\n+    if (JvmtiExport::can_pop_frame() || JvmtiExport::can_force_early_return()) {\n+      JvmtiThreadState* state = _current->jvmti_thread_state();\n+      if (_current->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n@@ -88,3 +80,6 @@\n-    } else {\n-      _current->set_is_in_VTMS_transition(true);\n-      java_lang_Thread::set_is_in_VTMS_transition(_vthread(), true);\n+    }\n+\n+    \/\/ Don't preempt in case there is an async exception installed since\n+    \/\/ we would incorrectly throw it during the unmount logic in the carrier.\n+    if (_current->has_async_exception_condition()) {\n+      _failed = true;\n@@ -93,1 +88,1 @@\n-  ~JvmtiUnmountBeginMark() {\n+  ~UnmountBeginMark() {\n@@ -95,7 +90,1 @@\n-\n-    assert(_current->is_in_VTMS_transition(), \"must be\");\n-    assert(java_lang_Thread::is_in_VTMS_transition(_vthread()), \"must be\");\n-\n-    \/\/ Read it again since for late binding agents the flag could have\n-    \/\/ been set while blocked in the allocation path during freeze.\n-    bool jvmti_present = JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events();\n+    assert(_current->is_in_vthread_transition(), \"must be\");\n@@ -105,6 +94,1 @@\n-      if (jvmti_present) {\n-        JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)_vthread.raw_value(), false);\n-      } else {\n-        _current->set_is_in_VTMS_transition(false);\n-        java_lang_Thread::set_is_in_VTMS_transition(_vthread(), false);\n-      }\n+      MountUnmountDisabler::end_transition(_current, _vthread(), true \/*is_mount*\/, false \/*is_thread_start*\/);\n@@ -117,0 +101,1 @@\n+#if INCLUDE_JVMTI\n@@ -118,1 +103,1 @@\n-  if (current->is_in_VTMS_transition()) {\n+  if (current->is_in_vthread_transition()) {\n@@ -153,2 +138,2 @@\n-  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(current);)\n-  JVMTI_ONLY(if (jubm.failed()) return freeze_pinned_native;)\n+  UnmountBeginMark ubm(current);\n+  if (ubm.failed()) return freeze_pinned_native;\n@@ -157,1 +142,1 @@\n-  JVMTI_ONLY(jubm.set_result(res);)\n+  ubm.set_result(res);\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":25,"deletions":40,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -1716,1 +1717,1 @@\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)vth.raw_value(), false);\n+    MountUnmountDisabler::end_transition(current, vth(), true \/*is_mount*\/, false \/*is_thread_start*\/);\n@@ -2682,2 +2683,1 @@\n-#if INCLUDE_JVMTI\n-  assert(_thread->is_in_VTMS_transition(), \"must be\");\n+  assert(_thread->is_in_vthread_transition(), \"must be\");\n@@ -2687,1 +2687,2 @@\n-    if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+#if INCLUDE_JVMTI\n+    if (MountUnmountDisabler::notify_jvmti_events()) {\n@@ -2689,3 +2690,6 @@\n-    } else {\n-      _thread->set_is_in_VTMS_transition(false);\n-      java_lang_Thread::set_is_in_VTMS_transition(_thread->vthread(), false);\n+    } else\n+#endif\n+    { \/\/ Faster version of MountUnmountDisabler::end_transition() to avoid\n+      \/\/ unnecessary extra instructions from jvmti_mount_end().\n+      java_lang_Thread::set_is_in_vthread_transition(_thread->vthread(), false);\n+      _thread->set_is_in_vthread_transition(false);\n@@ -2694,1 +2698,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1701,1 +1701,1 @@\n-  develop(intx, MinOopMapAllocation,     8,                                 \\\n+  develop(int, MinOopMapAllocation, 8,                                      \\\n@@ -1703,0 +1703,1 @@\n+          range(0, max_jint)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -452,1 +452,0 @@\n-  _is_in_VTMS_transition(false),\n@@ -455,1 +454,1 @@\n-  _VTMS_transition_mark(false),\n+  _jvmti_events_disabled(0),\n@@ -458,3 +457,0 @@\n-#ifdef ASSERT\n-  _is_VTMS_transition_disabler(false),\n-#endif\n@@ -506,0 +502,4 @@\n+  _is_in_vthread_transition(false),\n+  DEBUG_ONLY(_is_vthread_transition_disabler(false) COMMA)\n+  DEBUG_ONLY(_is_disabler_at_start(false) COMMA)\n+\n@@ -1153,4 +1153,10 @@\n-#if INCLUDE_JVMTI\n-void JavaThread::set_is_in_VTMS_transition(bool val) {\n-  assert(is_in_VTMS_transition() != val, \"already %s transition\", val ? \"inside\" : \"outside\");\n-  _is_in_VTMS_transition = val;\n+bool JavaThread::is_in_vthread_transition() const {\n+  DEBUG_ONLY(Thread* current = Thread::current();)\n+  assert(is_handshake_safe_for(current) || SafepointSynchronize::is_at_safepoint()\n+         || JavaThread::cast(current)->is_disabler_at_start(), \"not safe\");\n+  return AtomicAccess::load(&_is_in_vthread_transition);\n+}\n+\n+void JavaThread::set_is_in_vthread_transition(bool val) {\n+  assert(is_in_vthread_transition() != val, \"already %s transition\", val ? \"inside\" : \"outside\");\n+  AtomicAccess::store(&_is_in_vthread_transition, val);\n@@ -1160,2 +1166,6 @@\n-void JavaThread::set_is_VTMS_transition_disabler(bool val) {\n-  _is_VTMS_transition_disabler = val;\n+void JavaThread::set_is_vthread_transition_disabler(bool val) {\n+  _is_vthread_transition_disabler = val;\n+}\n+\n+void JavaThread::set_is_disabler_at_start(bool val) {\n+  _is_disabler_at_start = val;\n@@ -1163,1 +1173,0 @@\n-#endif\n@@ -1173,5 +1182,2 @@\n-#if INCLUDE_JVMTI\n-  \/\/ Suspending a JavaThread in VTMS transition or disabling VTMS transitions can cause deadlocks.\n-  assert(!is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");\n-  assert(!is_VTMS_transition_disabler(), \"no suspend allowed for VTMS transition disablers\");\n-#endif\n+  \/\/ Suspending a vthread transition disabler can cause deadlocks.\n+  assert(!is_vthread_transition_disabler(), \"no suspend allowed for vthread transition disablers\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -326,1 +326,0 @@\n-  bool                  _is_in_VTMS_transition;          \/\/ thread is in virtual thread mount state transition\n@@ -329,1 +328,1 @@\n-  bool                  _VTMS_transition_mark;           \/\/ used for sync between VTMS transitions and disablers\n+  int                   _jvmti_events_disabled;          \/\/ JVMTI events disabled manually\n@@ -332,3 +331,0 @@\n-#ifdef ASSERT\n-  bool                  _is_VTMS_transition_disabler;    \/\/ thread currently disabled VTMS transitions\n-#endif\n@@ -740,0 +736,14 @@\n+private:\n+  bool _is_in_vthread_transition;                    \/\/ thread is in virtual thread mount state transition\n+  DEBUG_ONLY(bool _is_vthread_transition_disabler;)  \/\/ thread currently disabled vthread transitions\n+  DEBUG_ONLY(bool _is_disabler_at_start;)            \/\/ thread at process of disabling vthread transitions\n+public:\n+  bool is_in_vthread_transition() const;\n+  void set_is_in_vthread_transition(bool val);\n+#ifdef ASSERT\n+  bool is_vthread_transition_disabler() const       { return _is_vthread_transition_disabler; }\n+  void set_is_vthread_transition_disabler(bool val);\n+  bool is_disabler_at_start() const                 { return _is_disabler_at_start; }\n+  void set_is_disabler_at_start(bool val);\n+#endif\n+\n@@ -748,4 +758,1 @@\n-  bool is_in_VTMS_transition() const             { return _is_in_VTMS_transition; }\n-  void set_is_in_VTMS_transition(bool val);\n-\n-  void toggle_is_disable_suspend()               { _is_disable_suspend = !_is_disable_suspend; };\n+  void toggle_is_disable_suspend()               { _is_disable_suspend = !_is_disable_suspend; }\n@@ -755,1 +762,1 @@\n-  void toggle_is_in_java_upcall()                { _is_in_java_upcall = !_is_in_java_upcall; };\n+  void toggle_is_in_java_upcall()                { _is_in_java_upcall = !_is_in_java_upcall; }\n@@ -757,2 +764,2 @@\n-  bool VTMS_transition_mark() const              { return AtomicAccess::load(&_VTMS_transition_mark); }\n-  void set_VTMS_transition_mark(bool val)        { AtomicAccess::store(&_VTMS_transition_mark, val); }\n+  void disable_jvmti_events()                    { _jvmti_events_disabled++; }\n+  void enable_jvmti_events()                     { _jvmti_events_disabled--; }\n@@ -761,1 +768,1 @@\n-  \/\/ - is in a VTMS transition (_is_in_VTMS_transition)\n+  \/\/ - is in a vthread transition (_is_in_vthread_transition)\n@@ -764,1 +771,3 @@\n-  bool should_hide_jvmti_events() const          { return _is_in_VTMS_transition || _is_disable_suspend || _is_in_java_upcall; }\n+  bool should_hide_jvmti_events() const {\n+    return _is_in_vthread_transition || _is_disable_suspend || _is_in_java_upcall || _jvmti_events_disabled != 0;\n+  }\n@@ -771,4 +780,0 @@\n-#ifdef ASSERT\n-  bool is_VTMS_transition_disabler() const       { return _is_VTMS_transition_disabler; }\n-  void set_is_VTMS_transition_disabler(bool val);\n-#endif\n@@ -933,0 +938,1 @@\n+  static ByteSize is_in_vthread_transition_offset()     { return byte_offset_of(JavaThread, _is_in_vthread_transition); }\n@@ -935,1 +941,0 @@\n-  static ByteSize is_in_VTMS_transition_offset()     { return byte_offset_of(JavaThread, _is_in_VTMS_transition); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -746,28 +746,0 @@\n-#if INCLUDE_JVMTI\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_start(oopDesc* vt, jboolean hide, JavaThread* current))\n-  assert(hide == JNI_FALSE, \"must be VTMS transition finish\");\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_start(vthread);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_end(oopDesc* vt, jboolean hide, JavaThread* current))\n-  assert(hide == JNI_TRUE, \"must be VTMS transition start\");\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_end(vthread);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_mount(oopDesc* vt, jboolean hide, JavaThread* current))\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_mount(vthread, hide);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_unmount(oopDesc* vt, jboolean hide, JavaThread* current))\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount(vthread, hide);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-#endif \/\/ INCLUDE_JVMTI\n-\n@@ -818,0 +790,2 @@\n+  Handle orig_exception(THREAD, exception());\n+\n@@ -839,1 +813,1 @@\n-        exception = Handle(THREAD, PENDING_EXCEPTION);\n+        exception.replace(PENDING_EXCEPTION);\n@@ -868,1 +842,2 @@\n-  \/\/ This is rare.  Just deoptimize and let the interpreter handle it.\n+  \/\/ This is rare.  Just deoptimize and let the interpreter rethrow the original\n+  \/\/ exception at the original bci.\n@@ -870,0 +845,1 @@\n+    exception.replace(orig_exception()); \/\/ restore original exception\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -323,8 +323,0 @@\n-#if INCLUDE_JVMTI\n-  \/\/ Functions for JVMTI notifications\n-  static void notify_jvmti_vthread_start(oopDesc* vt, jboolean hide, JavaThread* current);\n-  static void notify_jvmti_vthread_end(oopDesc* vt, jboolean hide, JavaThread* current);\n-  static void notify_jvmti_vthread_mount(oopDesc* vt, jboolean hide, JavaThread* current);\n-  static void notify_jvmti_vthread_unmount(oopDesc* vt, jboolean hide, JavaThread* current);\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -210,12 +210,0 @@\n-\/\/ do_jvmti_stub(name)\n-#if INCLUDE_JVMTI\n-#define C2_JVMTI_STUBS_DO(do_jvmti_stub)                               \\\n-  do_jvmti_stub(notify_jvmti_vthread_start)                            \\\n-  do_jvmti_stub(notify_jvmti_vthread_end)                              \\\n-  do_jvmti_stub(notify_jvmti_vthread_mount)                            \\\n-  do_jvmti_stub(notify_jvmti_vthread_unmount)                          \\\n-\n-#else\n-#define C2_JVMTI_STUBS_DO(do_jvmti_stub)\n-#endif \/\/ INCLUDE_JVMTI\n-\n@@ -226,1 +214,0 @@\n-\/\/ do_jvmti_stub(name)\n@@ -236,3 +223,1 @@\n-\/\/ do_jvmti_stub generates a JVMTI stub as an IR intrinsic which\n-\/\/ employs jump 0, and requires no special access\n-#define C2_STUBS_DO(do_blob, do_stub, do_jvmti_stub)                   \\\n+#define C2_STUBS_DO(do_blob, do_stub)                                  \\\n@@ -250,1 +235,0 @@\n-  C2_JVMTI_STUBS_DO(do_jvmti_stub)                                     \\\n@@ -259,0 +243,4 @@\n+  do_stub(vthread_end_first_transition, 0, false, false)               \\\n+  do_stub(vthread_start_final_transition, 0, false, false)             \\\n+  do_stub(vthread_start_transition, 0, false, false)                   \\\n+  do_stub(vthread_end_transition, 0, false, false)                     \\\n@@ -261,1 +249,1 @@\n-#define C2_STUBS_DO(do_blob, do_stub, do_jvmti_stub)\n+#define C2_STUBS_DO(do_blob, do_stub)\n@@ -1203,3 +1191,0 @@\n-\/\/ ignore do_jvmti_stub(name) declarations\n-#define DO_JVMTI_STUB_EMPTY1(stub_name)\n-\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se26\/html\/index.html\">\n+     * href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/26\/docs\/specs\/jvms\/index.html\">\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-    separated by comma. Precede a key by ''-'' to exclude the specified category.\\n\\\n+    separated by comma.\\n\\\n+    Precede a key by ''-'' to exclude the specified category.\\n\\\n@@ -368,1 +369,2 @@\n-    Enable preview language features. Also disables the ''preview'' lint category.\\n\\\n+    Enable preview language features.\\n\\\n+    Also disables the ''preview'' lint category.\\n\\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.io.BufferedReader;\n@@ -33,0 +34,1 @@\n+import java.io.InputStreamReader;\n@@ -59,0 +61,1 @@\n+import java.util.NoSuchElementException;\n@@ -241,0 +244,21 @@\n+    \/\/ Release information stored in the java.base module\n+    private static final String JDK_RELEASE_RESOURCE = \"jdk\/internal\/misc\/resources\/release.txt\";\n+\n+    \/**\n+     * Read the release.txt from the module.\n+     *\/\n+    private static Optional<String> getReleaseInfo(ModuleReference mref) {\n+        try {\n+            Optional<InputStream> release = mref.open().open(JDK_RELEASE_RESOURCE);\n+\n+            if (release.isEmpty()) {\n+                return Optional.empty();\n+            }\n+\n+            try (var r = new BufferedReader(new InputStreamReader(release.get()))) {\n+                return Optional.of(r.readLine());\n+            }\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n@@ -414,1 +438,2 @@\n-            checkJavaBaseVersion(finder);\n+            assert(finder.find(\"java.base\").isPresent());\n+            checkJavaBaseVersion(finder.find(\"java.base\").get());\n@@ -567,0 +592,10 @@\n+    private static String getCurrentRuntimeVersion() {\n+        ModuleReference current = ModuleLayer.boot()\n+                .configuration()\n+                .findModule(\"java.base\")\n+                .get()\n+                .reference();\n+        \/\/ This jlink runtime should always have the release.txt\n+        return getReleaseInfo(current).get();\n+    }\n+\n@@ -568,2 +603,2 @@\n-     * Checks the version of the module descriptor of java.base for compatibility\n-     * with the current runtime version.\n+     * Checks the release information of the java.base used for target image\n+     * for compatibility with the java.base used by jlink.\n@@ -571,3 +606,2 @@\n-     * @throws IllegalArgumentException the descriptor of java.base has no\n-     * version or the java.base version is not the same as the current runtime's\n-     * version.\n+     * @throws IllegalArgumentException  If  the `java.base` module reference `target`\n+     * is not compatible with this jlink.\n@@ -575,15 +609,8 @@\n-    private static void checkJavaBaseVersion(ModuleFinder finder) {\n-        assert finder.find(\"java.base\").isPresent();\n-\n-        \/\/ use the version of java.base module, if present, as\n-        \/\/ the release version for multi-release JAR files\n-        ModuleDescriptor.Version v = finder.find(\"java.base\").get()\n-                .descriptor().version().orElseThrow(() ->\n-                new IllegalArgumentException(\"No version in java.base descriptor\")\n-                        );\n-\n-        Runtime.Version version = Runtime.Version.parse(v.toString());\n-        if (Runtime.version().feature() != version.feature() ||\n-                Runtime.version().interim() != version.interim()) {\n-            \/\/ jlink version and java.base version do not match.\n-            \/\/ We do not (yet) support this mode.\n+    private static void checkJavaBaseVersion(ModuleReference target) {\n+        String currentRelease = getCurrentRuntimeVersion();\n+\n+        String targetRelease = getReleaseInfo(target).orElseThrow(() -> new IllegalArgumentException(\n+                taskHelper.getMessage(\"err.jlink.version.missing\", currentRelease)));\n+\n+        if (!currentRelease.equals(targetRelease)) {\n+            \/\/ Current runtime image and the target runtime image are not compatible build\n@@ -591,2 +618,2 @@\n-                    Runtime.version().feature(), Runtime.version().interim(),\n-                    version.feature(), version.interim()));\n+                    currentRelease,\n+                    targetRelease));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":50,"deletions":23,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-compiler\/loopopts\/TestUnreachableInnerLoop.java 8288981 linux-s390x\n@@ -125,0 +124,1 @@\n+gc\/cslocker\/TestCSLocker.java 8373025 generic-all\n@@ -187,0 +187,3 @@\n+serviceability\/sa\/ClhsdbScanOops.java#parallel    8373022 generic-all\n+serviceability\/sa\/ClhsdbScanOops.java#serial      8373022 generic-all\n+\n@@ -188,1 +191,0 @@\n-serviceability\/sa\/TestJhsdbJstackMixedWithXComp.java 8371194 linux-x64\n@@ -291,0 +293,6 @@\n+\n+vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded001\/TestDescription.java 8373022 generic-all\n+vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded002\/TestDescription.java 8373022 generic-all\n+vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded003\/TestDescription.java 8373022 generic-all\n+vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded004\/TestDescription.java 8373022 generic-all\n+vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded005\/TestDescription.java 8373022 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*:|.*(?i:mov|mv|or).*precise \\\\[.*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        String regex = \"(((?i:cmp|CLFI|CLR).*aryklassptr:\\\\[.*:Constant|.*(?i:mov|mv|or).*aryklassptr:\\\\[.*:Constant.*\\\\R.*(cmp|CMP|CLR))\" + END;\n@@ -570,1 +570,1 @@\n-        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*\" + IS_REPLACED + \":|.*(?i:mov|mv|or).*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        String regex = \"(((?i:cmp|CLFI|CLR).*aryklassptr:\\\\[.*\" + IS_REPLACED + \":.*:Constant|.*(?i:mov|mv|or).*aryklassptr:\\\\[.*\" + IS_REPLACED + \":.*:Constant.*\\\\R.*(cmp|CMP|CLR))\" + END;\n@@ -1312,0 +1312,6 @@\n+    public static final String MEM_TO_REG_SPILL_COPY_TYPE = COMPOSITE_PREFIX + \"MEM_TO_REG_SPILL_COPY_TYPE\" + POSTFIX;\n+    static {\n+        String regex = START + \"MemToRegSpillCopy\" + MID + IS_REPLACED + \".*\" + END;\n+        machOnly(MEM_TO_REG_SPILL_COPY_TYPE, regex);\n+    }\n+\n@@ -3280,2 +3286,1 @@\n-    \/\/ (\\w\/)* tries to match the pattern 'a\/b\/`\n-    \/\/ (\\w$)* tries to match the pattern 'c$d$'\n+    \/\/ [\\\\w\/\\\\$] tries to match the pattern such as 'a\/b\/', 'a\/b', or '\/b' but also nested class such as '$c' or '$c$d'\n@@ -3283,1 +3288,1 @@\n-    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)+(\\\\w\/)*(\\\\w$)*\\\\b\";\n+    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)+[\\\\w\/\\\\$]*\\\\b\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -258,3 +258,3 @@\n-        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 1, cmp, \"precise\"),\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 2, 1,cmp, \"precise\", \"MyClass\"),\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 2, 2,cmp, \"precise\", \"ir_framework\/tests\/MyClass\"),\n+        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 1, cmp, \"Constant\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 2, 1,cmp, \"Constant\", \"MyClass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 2, 2,cmp, \"Constant\", \"ir_framework\/tests\/MyClass\"),\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -597,1 +597,0 @@\n-java\/nio\/channels\/Channels\/SocketChannelStreams.java            8317838 aix-ppc64\n@@ -727,0 +726,1 @@\n+com\/sun\/jdi\/MethodInvokeWithTraceOnTest.java                    8373022 generic-all\n@@ -766,0 +766,1 @@\n+jdk\/jfr\/jvm\/TestWaste.java                                      8371630 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -802,0 +802,16 @@\n+    @Test\n+    public void testPrivateConstructor(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                \"\"\"\n+                class PrivateConstructor {\n+                    private PrivateConstructor() {}\n+                    void main() {}\n+                }\n+                \"\"\");\n+        testError(base.resolve(\"PrivateConstructor.java\"), \"\",\n+                \"\"\"\n+                error: no non-private zero argument constructor found in class PrivateConstructor\n+                remove private from existing constructor or define as:\n+                   public PrivateConstructor()\"\"\");\n+    }\n+\n@@ -908,8 +924,0 @@\n-    void checkContains(String name, String found, String expect) {\n-        expect = expect.replace(\"\\n\", tb.lineSeparator);\n-        out.println(name + \": \" + found);\n-        if (!found.contains(expect)) {\n-            error(\"Expected output not found: \" + expect);\n-        }\n-    }\n-\n@@ -943,1 +951,0 @@\n-        expect = expect.replace(\"\\n\", tb.lineSeparator);\n@@ -951,2 +958,8 @@\n-            if (!(found.getMessage().equals(expect))) {\n-                error(\"Unexpected detail message; expected: \" + expect);\n+            String actual = found.getMessage();\n+            List<String> actualLines = actual.lines().toList();\n+            List<String> expectLines = expect.lines().toList();\n+            if (!(actualLines.equals(expectLines))) {\n+                error(\"Unexpected detail message; expected: \\n\"\n+                      + expect.indent(2)\n+                      + \"\\nactual:\\n\"\n+                      + actual.indent(2));\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  public           long getObjectAddress(Object o) {\n+  public         long getObjectAddress(Object o) {\n@@ -81,1 +81,6 @@\n-  public native boolean  hasExternalSymbolsStripped();\n+  public native boolean  shipsFullDebugInfo();\n+  public native boolean  shipsPublicDebugInfo();\n+\n+  public        boolean  shipsDebugInfo() {\n+    return shipsFullDebugInfo() || shipsPublicDebugInfo();\n+  }\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}