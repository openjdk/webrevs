{"files":[{"patch":"@@ -40,0 +40,5 @@\n+static bool is_oop_containing_flat_array(Klass* klass) {\n+  return ArrayKlass::cast(klass)->is_flatArray_klass() &&\n+         FlatArrayKlass::cast(klass)->contains_oops();\n+}\n+\n@@ -49,13 +54,0 @@\n-  if (ArrayKlass::cast(_klass)->is_flatArray_klass() &&\n-      FlatArrayKlass::cast(_klass)->contains_oops()) {\n-    \/\/ Flat arrays containing oops are not supported in ZGC without relying on\n-    \/\/ internal-only features such as loose-consistency and null-restriction.\n-    \/\/ A value object that contains an oop and a null-marker will always exceed\n-    \/\/ 64 bits when using ZGC. As a result, such objects will not be flattened\n-    \/\/ in practice due to the 64-bit atomicity limit.\n-    \/\/\n-    \/\/ We only need to support flat arrays containing oops when\/if value objects\n-    \/\/ can be user-declared as loosely consistent and\/or null-restricted.\n-    return ObjArrayAllocator::initialize(mem);\n-  }\n-\n@@ -72,0 +64,12 @@\n+  if (is_oop_containing_flat_array(_klass)) {\n+    \/\/ Flat arrays containing oops are not supported in ZGC without relying on\n+    \/\/ internal-only features such as loose-consistency and null-restriction.\n+    \/\/ A value object that contains an oop and a null-marker will always exceed\n+    \/\/ 64 bits when using ZGC. As a result, such objects will not be flattened\n+    \/\/ in practice due to the 64-bit atomicity limit.\n+    \/\/\n+    \/\/ We only need to support flat arrays containing oops when\/if value objects\n+    \/\/ can be user-declared with loose-consistency and\/or null-restriction.\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"}]}