{"files":[{"patch":"@@ -40,0 +40,5 @@\n+static bool is_oop_containing_flat_array(Klass* klass) {\n+  return ArrayKlass::cast(klass)->is_flatArray_klass() &&\n+         FlatArrayKlass::cast(klass)->contains_oops();\n+}\n+\n@@ -54,2 +59,14 @@\n-  if (_word_size <= segment_max || ArrayKlass::cast(_klass)->is_flatArray_klass()) {\n-    \/\/ To small to use segmented clearing\n+  if (_word_size <= segment_max) {\n+    \/\/ Too small to use segmented clearing\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n+  if (is_oop_containing_flat_array(_klass)) {\n+    \/\/ Flat arrays containing oops are not supported in ZGC without relying on\n+    \/\/ internal-only features such as loose-consistency and null-restriction.\n+    \/\/ A value object that contains an oop and a null-marker will always exceed\n+    \/\/ 64 bits when using ZGC. As a result, such objects will not be flattened\n+    \/\/ in practice due to the 64-bit atomicity limit.\n+    \/\/\n+    \/\/ We only need to support flat arrays containing oops when\/if value objects\n+    \/\/ can be user-declared with loose-consistency and\/or null-restriction.\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"}]}