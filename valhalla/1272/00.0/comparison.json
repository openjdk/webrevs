{"files":[{"patch":"@@ -1187,1 +1187,1 @@\n-            version: \"7.3.1\",\n+            version: \"7.4\",\n@@ -1189,1 +1189,1 @@\n-            file: \"bundles\/jtreg-7.3.1+1.zip\",\n+            file: \"bundles\/jtreg-7.4+1.zip\",\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -55,0 +56,4 @@\n+const char* ClassListParser::CONSTANT_POOL_TAG = \"@cp\";\n+const char* ClassListParser::LAMBDA_FORM_TAG = \"@lambda-form-invoker\";\n+const char* ClassListParser::LAMBDA_PROXY_TAG = \"@lambda-proxy\";\n+\n@@ -302,0 +307,3 @@\n+  } else if (strcmp(_token, CONSTANT_POOL_TAG) == 0) {\n+    _token = _line + offset;\n+    parse_constant_pool_tag();\n@@ -398,1 +406,1 @@\n-void ClassListParser::error(const char* msg, ...) {\n+void ClassListParser::print_diagnostic_info(outputStream* st, const char* msg, ...) {\n@@ -401,0 +409,5 @@\n+  print_diagnostic_info(st, msg, ap);\n+  va_end(ap);\n+}\n+\n+void ClassListParser::print_diagnostic_info(outputStream* st, const char* msg, va_list ap) {\n@@ -415,1 +428,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \"\\n\");\n+    st->print(\"\\n\");\n@@ -417,1 +430,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \":\\n\");\n+    st->print(\":\\n\");\n@@ -421,1 +434,1 @@\n-        jio_fprintf(defaultStream::error_stream(), \"%s\", \" \");\n+        st->print(\"%s\", \" \");\n@@ -423,1 +436,1 @@\n-        jio_fprintf(defaultStream::error_stream(), \"%c\", c);\n+        st->print(\"%c\", c);\n@@ -426,1 +439,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \"\\n\");\n+    st->print(\"\\n\");\n@@ -428,1 +441,1 @@\n-      jio_fprintf(defaultStream::error_stream(), \"%s\", \" \");\n+      st->print(\"%s\", \" \");\n@@ -430,1 +443,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \"^\\n\");\n+    st->print(\"^\\n\");\n@@ -432,1 +445,1 @@\n-  va_end(ap);\n+}\n@@ -434,0 +447,9 @@\n+void ClassListParser::error(const char* msg, ...) {\n+  va_list ap;\n+  va_start(ap, msg);\n+  fileStream fs(defaultStream::error_stream());\n+  \/\/TODO: we should write to UL\/error instead, but that requires fixing some tests cases.\n+  \/\/LogTarget(Error, cds) lt;\n+  \/\/LogStream ls(lt);\n+  print_diagnostic_info(&fs, msg, ap);\n+  va_end(ap);\n@@ -456,0 +478,10 @@\n+void ClassListParser::constant_pool_resolution_warning(const char* msg, ...) {\n+  va_list ap;\n+  va_start(ap, msg);\n+  LogTarget(Warning, cds, resolve) lt;\n+  LogStream ls(lt);\n+  print_diagnostic_info(&ls, msg, ap);\n+  ls.print(\"Your classlist may be out of sync with the JDK or the application.\");\n+  va_end(ap);\n+}\n+\n@@ -734,0 +766,89 @@\n+\n+InstanceKlass* ClassListParser::find_builtin_class_helper(JavaThread* current, Symbol* class_name_symbol, oop class_loader_oop) {\n+  Handle class_loader(current, class_loader_oop);\n+  Handle protection_domain;\n+  return SystemDictionary::find_instance_klass(current, class_name_symbol, class_loader, protection_domain);\n+}\n+\n+InstanceKlass* ClassListParser::find_builtin_class(JavaThread* current, const char* class_name) {\n+  TempNewSymbol class_name_symbol = SymbolTable::new_symbol(class_name);\n+  InstanceKlass* ik;\n+\n+  if ( (ik = find_builtin_class_helper(current, class_name_symbol, nullptr)) != nullptr\n+    || (ik = find_builtin_class_helper(current, class_name_symbol, SystemDictionary::java_platform_loader())) != nullptr\n+    || (ik = find_builtin_class_helper(current, class_name_symbol, SystemDictionary::java_system_loader())) != nullptr) {\n+    return ik;\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+void ClassListParser::parse_constant_pool_tag() {\n+  if (parse_lambda_forms_invokers_only()) {\n+    return;\n+  }\n+\n+  JavaThread* THREAD = JavaThread::current();\n+  skip_whitespaces();\n+  char* class_name = _token;\n+  skip_non_whitespaces();\n+  *_token = '\\0';\n+  _token ++;\n+\n+  InstanceKlass* ik = find_builtin_class(THREAD, class_name);\n+  if (ik == nullptr) {\n+    _token = class_name;\n+    if (strstr(class_name, \"\/$Proxy\") != nullptr ||\n+        strstr(class_name, \"MethodHandle$Species_\") != nullptr) {\n+      \/\/ ignore -- TODO: we should filter these out in classListWriter.cpp\n+    } else {\n+      constant_pool_resolution_warning(\"class %s is not (yet) loaded by one of the built-in loaders\", class_name);\n+    }\n+    return;\n+  }\n+\n+  ResourceMark rm(THREAD);\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  GrowableArray<bool> preresolve_list(cp->length(), cp->length(), false);\n+  bool preresolve_class = false;\n+  bool preresolve_fmi = false;\n+  bool preresolve_indy = false;\n+\n+  while (*_token) {\n+    int cp_index;\n+    skip_whitespaces();\n+    parse_uint(&cp_index);\n+    if (cp_index < 1 || cp_index >= cp->length()) {\n+      constant_pool_resolution_warning(\"Invalid constant pool index %d\", cp_index);\n+      return;\n+    } else {\n+      preresolve_list.at_put(cp_index, true);\n+    }\n+    constantTag cp_tag = cp->tag_at(cp_index);\n+    switch (cp_tag.value()) {\n+    case JVM_CONSTANT_UnresolvedClass:\n+      preresolve_class = true;\n+      break;\n+    case JVM_CONSTANT_UnresolvedClassInError:\n+    case JVM_CONSTANT_Class:\n+      \/\/ ignore\n+      break;\n+    case JVM_CONSTANT_Fieldref:\n+      preresolve_fmi = true;\n+      break;\n+      break;\n+    default:\n+      constant_pool_resolution_warning(\"Unsupported constant pool index %d: %s (type=%d)\",\n+                                       cp_index, cp_tag.internal_name(), cp_tag.value());\n+      return;\n+    }\n+  }\n+\n+  if (preresolve_class) {\n+    ClassPrelinker::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n+  if (preresolve_fmi) {\n+    ClassPrelinker::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":130,"deletions":9,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-  intptr_t _cloned_vtable[1];\n+  intptr_t _cloned_vtable[1]; \/\/ Pseudo flexible array member.\n+  static size_t cloned_vtable_offset() { return offset_of(CppVtableInfo, _cloned_vtable); }\n@@ -77,3 +78,0 @@\n-  static int num_slots(int vtable_size) {\n-    return 1 + vtable_size; \/\/ Need to add the space occupied by _vtable_size;\n-  }\n@@ -82,2 +80,3 @@\n-  intptr_t* cloned_vtable()   { return &_cloned_vtable[0]; }\n-  void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }\n+  \/\/ Using _cloned_vtable[i] for i > 0 causes undefined behavior. We use address calculation instead.\n+  intptr_t* cloned_vtable()   { return (intptr_t*)((char*)this + cloned_vtable_offset()); }\n+  void zero()                 { memset(cloned_vtable(), 0, sizeof(intptr_t) * vtable_size()); }\n@@ -86,2 +85,1 @@\n-    CppVtableInfo i;\n-    return pointer_delta(&i._cloned_vtable[vtable_size], &i, sizeof(u1));\n+    return cloned_vtable_offset() + (sizeof(intptr_t) * vtable_size);\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -755,2 +755,2 @@\n-  BasicType bt = fd->field_type();\n-  switch (bt) {\n+  BasicType field_type = fd->field_type();\n+  switch (field_type) {\n@@ -779,1 +779,4 @@\n-          _out->print_cr(\"null\");\n+          if (field_type == T_ARRAY) {\n+            _out->print(\"%d\", -1);\n+          }\n+          _out->cr();\n@@ -781,1 +784,1 @@\n-          assert(fd->field_type() == T_OBJECT, \"\");\n+          assert(field_type == T_OBJECT, \"\");\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-      if (field_signature[1] == JVM_SIGNATURE_ARRAY) {\n+      if (length != -1) {\n@@ -1147,2 +1147,2 @@\n-          Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));\n-          parse_klass(CHECK_(true)); \/\/ eat up the array class name\n+          Klass* actual_array_klass = parse_klass(CHECK_(true));\n+          Klass* kelem = ObjArrayKlass::cast(actual_array_klass)->element_klass();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -121,0 +122,4 @@\n+PerfCounter*    ClassLoader::_perf_ik_link_methods_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_method_adapters_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_ik_link_methods_count = nullptr;\n+PerfCounter*    ClassLoader::_perf_method_adapters_count = nullptr;\n@@ -124,0 +129,27 @@\n+PerfCounter*    ClassLoader::_perf_resolve_indy_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_resolve_invokehandle_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_resolve_mh_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_resolve_mt_time = nullptr;\n+\n+PerfCounter*    ClassLoader::_perf_resolve_indy_count = nullptr;\n+PerfCounter*    ClassLoader::_perf_resolve_invokehandle_count = nullptr;\n+PerfCounter*    ClassLoader::_perf_resolve_mh_count = nullptr;\n+PerfCounter*    ClassLoader::_perf_resolve_mt_count = nullptr;\n+\n+void ClassLoader::print_counters(outputStream *st) {\n+  \/\/ The counters are only active if the logging is enabled, but\n+  \/\/ we print to the passed in outputStream as requested.\n+  if (log_is_enabled(Info, perf, class, link)) {\n+    st->print_cr(\"ClassLoader:\");\n+    st->print_cr(\"  clinit:               \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", ClassLoader::class_init_time_ms(), ClassLoader::class_init_count());\n+    st->print_cr(\"  link methods:         \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_ik_link_methods_time->get_value())   , _perf_ik_link_methods_count->get_value());\n+    st->print_cr(\"  method adapters:      \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_method_adapters_time->get_value())   , _perf_method_adapters_count->get_value());\n+    st->print_cr(\"  resolve...\");\n+    st->print_cr(\"    invokedynamic:   \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_indy_time->get_value())         , _perf_resolve_indy_count->get_value());\n+    st->print_cr(\"    invokehandle:    \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_invokehandle_time->get_value()) , _perf_resolve_invokehandle_count->get_value());\n+    st->print_cr(\"    CP_MethodHandle: \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_mh_time->get_value())           , _perf_resolve_mh_count->get_value());\n+    st->print_cr(\"    CP_MethodType:   \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_mt_time->get_value())           , _perf_resolve_mt_count->get_value());\n+    st->cr();\n+  }\n+}\n+\n@@ -1364,1 +1396,0 @@\n-\n@@ -1367,0 +1398,17 @@\n+\n+    if (log_is_enabled(Info, perf, class, link)) {\n+      NEWPERFTICKCOUNTER(_perf_ik_link_methods_time, SUN_CLS, \"linkMethodsTime\");\n+      NEWPERFTICKCOUNTER(_perf_method_adapters_time, SUN_CLS, \"makeAdaptersTime\");\n+      NEWPERFEVENTCOUNTER(_perf_ik_link_methods_count, SUN_CLS, \"linkMethodsCount\");\n+      NEWPERFEVENTCOUNTER(_perf_method_adapters_count, SUN_CLS, \"makeAdaptersCount\");\n+\n+      NEWPERFTICKCOUNTER(_perf_resolve_indy_time, SUN_CLS, \"resolve_invokedynamic_time\");\n+      NEWPERFTICKCOUNTER(_perf_resolve_invokehandle_time, SUN_CLS, \"resolve_invokehandle_time\");\n+      NEWPERFTICKCOUNTER(_perf_resolve_mh_time, SUN_CLS, \"resolve_MethodHandle_time\");\n+      NEWPERFTICKCOUNTER(_perf_resolve_mt_time, SUN_CLS, \"resolve_MethodType_time\");\n+\n+      NEWPERFEVENTCOUNTER(_perf_resolve_indy_count, SUN_CLS, \"resolve_invokedynamic_count\");\n+      NEWPERFEVENTCOUNTER(_perf_resolve_invokehandle_count, SUN_CLS, \"resolve_invokehandle_count\");\n+      NEWPERFEVENTCOUNTER(_perf_resolve_mh_count, SUN_CLS, \"resolve_MethodHandle_count\");\n+      NEWPERFEVENTCOUNTER(_perf_resolve_mt_count, SUN_CLS, \"resolve_MethodType_count\");\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -841,2 +841,1 @@\n-  const bool is_interval_ended = gcs_since_max > HeapMaximumCompactionInterval\n-                              || total_invocations == HeapFirstMaximumCompactionCount;\n+  const bool is_interval_ended = gcs_since_max > HeapMaximumCompactionInterval;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1333,0 +1333,8 @@\n+    if (head->is_BaseCountedLoop() && ctrl->is_IfProj() && ctrl->in(0)->is_BaseCountedLoopEnd() &&\n+        head->as_BaseCountedLoop()->loopexit() == ctrl->in(0)) {\n+      Node* entry = head->in(LoopNode::EntryControl);\n+      Node* backedge = head->in(LoopNode::LoopBackControl);\n+      Node* new_head = new LoopNode(entry, backedge);\n+      phase->register_control(new_head, phase->get_loop(entry), entry);\n+      phase->lazy_replace(head, new_head);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -815,2 +815,0 @@\n-  \/\/ resolve field\n-  fieldDescriptor info;\n@@ -820,0 +818,9 @@\n+\n+  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, true \/*initialize_holder*\/, current);\n+}\n+\n+void InterpreterRuntime::resolve_get_put(Bytecodes::Code bytecode, int field_index,\n+                                         methodHandle& m,\n+                                         constantPoolHandle& pool,\n+                                         bool initialize_holder, TRAPS) {\n+  fieldDescriptor info;\n@@ -824,3 +831,1 @@\n-  int field_index = last_frame.get_index_u2(bytecode);\n-    JvmtiHideSingleStepping jhss(current);\n-    JavaThread* THREAD = current; \/\/ For exception macros.\n+    JvmtiHideSingleStepping jhss(THREAD);\n@@ -829,1 +834,1 @@\n-                                       m, bytecode, CHECK);\n+                                       m, bytecode, initialize_holder, CHECK);\n@@ -835,1 +840,0 @@\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,6 @@\n- private:\n+\n+  \/\/ Used by ClassListParser.\n+  static void resolve_get_put(Bytecodes::Code bytecode, int field_index,\n+                              methodHandle& m, constantPoolHandle& pool, bool initialize_holder, TRAPS);\n+\n+private:\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -58,1 +59,2 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/perfData.hpp\"\n@@ -975,1 +977,6 @@\n-void LinkResolver::resolve_field_access(fieldDescriptor& fd, const constantPoolHandle& pool, int index, const methodHandle& method, Bytecodes::Code byte, TRAPS) {\n+void LinkResolver::resolve_field_access(fieldDescriptor& fd,\n+                                        const constantPoolHandle& pool,\n+                                        int index,\n+                                        const methodHandle& method,\n+                                        Bytecodes::Code byte,\n+                                        bool initialize_class, TRAPS) {\n@@ -977,1 +984,1 @@\n-  resolve_field(fd, link_info, byte, true, CHECK);\n+  resolve_field(fd, link_info, byte, initialize_class, CHECK);\n@@ -1735,0 +1742,4 @@\n+\n+  PerfTraceTimedEvent timer(ClassLoader::perf_resolve_invokehandle_time(),\n+                            ClassLoader::perf_resolve_invokehandle_count());\n+\n@@ -1786,0 +1797,3 @@\n+  PerfTraceTimedEvent timer(ClassLoader::perf_resolve_invokedynamic_time(),\n+                            ClassLoader::perf_resolve_invokedynamic_count());\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -296,1 +296,10 @@\n-                                   Bytecodes::Code byte, TRAPS);\n+                                   Bytecodes::Code byte,\n+                                   bool initialize_class, TRAPS);\n+  static void resolve_field_access(fieldDescriptor& result,\n+                                   const constantPoolHandle& pool,\n+                                   int index,\n+                                   const methodHandle& method,\n+                                   Bytecodes::Code byte, TRAPS) {\n+    resolve_field_access(result, pool, index, method, byte,\n+                         \/* initialize_class*\/true, THREAD);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,9 @@\n+bool JVMCICompiler::is_intrinsic_supported(const methodHandle& method) {\n+  vmIntrinsics::ID id = method->intrinsic_id();\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  JavaThread* thread = JavaThread::current();\n+  JVMCIEnv jvmciEnv(thread, __FILE__, __LINE__);\n+  JVMCIRuntime* runtime = JVMCI::compiler_runtime(thread, false);\n+  return runtime->is_intrinsic_supported(&jvmciEnv, (jint) id);\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  LOG_TAG(link) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -66,1 +67,2 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/perfData.hpp\"\n@@ -302,2 +304,3 @@\n-    ConstantPool* orig_pool = ArchiveBuilder::current()->get_source_addr(this);\n-    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(orig_pool);\n+    int rr_len = rr->length();\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(src_cp);\n@@ -306,1 +309,0 @@\n-    int rr_len = rr->length();\n@@ -310,6 +312,8 @@\n-      if (obj != nullptr && i < ref_map_len) {\n-        int index = object_to_cp_index(i);\n-        if (tag_at(index).is_string()) {\n-          assert(java_lang_String::is_instance(obj), \"must be\");\n-          if (!ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n-            scratch_rr->obj_at_put(i, obj);\n+      if (obj != nullptr) {\n+        if (i < ref_map_len) {\n+          int index = object_to_cp_index(i);\n+          if (tag_at(index).is_string()) {\n+            assert(java_lang_String::is_instance(obj), \"must be\");\n+            if (!ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n+              scratch_rr->obj_at_put(i, obj);\n+            }\n@@ -388,2 +392,6 @@\n-  if (!_pool_holder->is_linked() && !_pool_holder->verified_at_dump_time()) {\n-    return;\n+  \/\/ resolved_references(): remember its length. If it cannot be restored\n+  \/\/ from the archived heap objects at run time, we need to dynamically allocate it.\n+  if (cache() != nullptr) {\n+    set_resolved_reference_length(\n+        resolved_references() != nullptr ? resolved_references()->length() : 0);\n+    set_resolved_references(OopHandle());\n@@ -391,10 +399,39 @@\n-  \/\/ Resolved references are not in the shared archive.\n-  \/\/ Save the length for restoration.  It is not necessarily the same length\n-  \/\/ as reference_map.length() if invokedynamic is saved. It is needed when\n-  \/\/ re-creating the resolved reference array if archived heap data cannot be map\n-  \/\/ at runtime.\n-  set_resolved_reference_length(\n-    resolved_references() != nullptr ? resolved_references()->length() : 0);\n-  set_resolved_references(OopHandle());\n-\n-  bool archived = false;\n+  remove_unshareable_entries();\n+}\n+\n+static const char* get_type(Klass* k) {\n+  const char* type;\n+  Klass* src_k;\n+  if (ArchiveBuilder::is_active() && ArchiveBuilder::current()->is_in_buffer_space(k)) {\n+    src_k = ArchiveBuilder::current()->get_source_addr(k);\n+  } else {\n+    src_k = k;\n+  }\n+\n+  if (src_k->is_objArray_klass()) {\n+    src_k = ObjArrayKlass::cast(src_k)->bottom_klass();\n+    assert(!src_k->is_objArray_klass(), \"sanity\");\n+  }\n+\n+  if (src_k->is_typeArray_klass()) {\n+    type = \"prim\";\n+  } else {\n+    InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n+    oop loader = src_ik->class_loader();\n+    if (loader == nullptr) {\n+      type = \"boot\";\n+    } else if (loader == SystemDictionary::java_platform_loader()) {\n+      type = \"plat\";\n+    } else if (loader == SystemDictionary::java_system_loader()) {\n+      type = \"app\";\n+    } else {\n+      type = \"unreg\";\n+    }\n+  }\n+\n+  return type;\n+}\n+\n+void ConstantPool::remove_unshareable_entries() {\n+  ResourceMark rm;\n+  log_info(cds, resolve)(\"Archiving CP entries for %s\", pool_holder()->name()->as_C_string());\n@@ -402,1 +439,5 @@\n-    switch (tag_at(cp_index).value()) {\n+    int cp_tag = tag_at(cp_index).value();\n+    switch (cp_tag) {\n+    case JVM_CONSTANT_UnresolvedClass:\n+      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(false, false);\n+      break;\n@@ -405,0 +446,1 @@\n+      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(false, true);\n@@ -416,2 +458,3 @@\n-      archived = maybe_archive_resolved_klass_at(cp_index);\n-      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(archived);\n+      remove_resolved_klass_if_non_deterministic(cp_index);\n+      break;\n+    default:\n@@ -428,1 +471,1 @@\n-bool ConstantPool::maybe_archive_resolved_klass_at(int cp_index) {\n+void ConstantPool::remove_resolved_klass_if_non_deterministic(int cp_index) {\n@@ -432,5 +475,12 @@\n-  if (pool_holder()->is_hidden() && cp_index == pool_holder()->this_class_index()) {\n-    \/\/ All references to a hidden class's own field\/methods are through this\n-    \/\/ index, which was resolved in ClassFileParser::fill_instance_klass. We\n-    \/\/ must preserve it.\n-    return true;\n+  Klass* k = resolved_klass_at(cp_index);\n+  bool can_archive;\n+\n+  if (k == nullptr) {\n+    \/\/ We'd come here if the referenced class has been excluded via\n+    \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n+    \/\/ has cleared the resolved_klasses()->at(...) pointer to NULL. Thus, we\n+    \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n+    can_archive = false;\n+  } else {\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    can_archive = ClassPrelinker::is_resolution_deterministic(src_cp, cp_index);\n@@ -439,5 +489,5 @@\n-  CPKlassSlot kslot = klass_slot_at(cp_index);\n-  int resolved_klass_index = kslot.resolved_klass_index();\n-  Klass* k = resolved_klasses()->at(resolved_klass_index);\n-  \/\/ k could be null if the referenced class has been excluded via\n-  \/\/ SystemDictionaryShared::is_excluded_class().\n+  if (!can_archive) {\n+    int resolved_klass_index = klass_slot_at(cp_index).resolved_klass_index();\n+    resolved_klasses()->at_put(resolved_klass_index, nullptr);\n+    tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n+  }\n@@ -445,9 +495,12 @@\n-  if (k != nullptr) {\n-    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n-    if (ClassPrelinker::can_archive_resolved_klass(src_cp, cp_index)) {\n-      if (log_is_enabled(Debug, cds, resolve)) {\n-        ResourceMark rm;\n-        log_debug(cds, resolve)(\"Resolved klass CP entry [%d]: %s => %s\", cp_index,\n-                                pool_holder()->external_name(), k->external_name());\n-      }\n-      return true;\n+  LogStreamHandle(Trace, cds, resolve) log;\n+  if (log.is_enabled()) {\n+    ResourceMark rm;\n+    log.print(\"%s klass  CP entry [%3d]: %s %s\",\n+              (can_archive ? \"archived\" : \"reverted\"),\n+              cp_index, pool_holder()->name()->as_C_string(), get_type(pool_holder()));\n+    if (can_archive) {\n+      log.print(\" => %s %s%s\", k->name()->as_C_string(), get_type(k),\n+                (!k->is_instance_klass() || pool_holder()->is_subtype_of(k)) ? \"\" : \" (not supertype)\");\n+    } else {\n+      Symbol* name = klass_name_at(cp_index);\n+      log.print(\"    %s\", name->as_C_string());\n@@ -457,5 +510,1 @@\n-  \/\/ This referenced class cannot be archived. Revert the tag to UnresolvedClass,\n-  \/\/ so that the proper class loading and initialization can happen at runtime.\n-  resolved_klasses()->at_put(resolved_klass_index, nullptr);\n-  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n-  return false;\n+  ArchiveBuilder::alloc_stats()->record_klass_cp_entry(can_archive, \/*reverted=*\/!can_archive);\n@@ -735,0 +784,25 @@\n+bool ConstantPool::is_resolved(int index, Bytecodes::Code code) {\n+  assert(cache() != nullptr, \"'index' is a rewritten index so this class must have been rewritten\");\n+  switch(code) {\n+    case Bytecodes::_invokedynamic:\n+      return resolved_indy_entry_at(index)->is_resolved();\n+\n+    case Bytecodes::_getfield:\n+    case Bytecodes::_getstatic:\n+    case Bytecodes::_putfield:\n+    case Bytecodes::_putstatic:\n+      return resolved_field_entry_at(index)->is_resolved(code);\n+\n+    case Bytecodes::_invokeinterface:\n+    case Bytecodes::_invokehandle:\n+    case Bytecodes::_invokespecial:\n+    case Bytecodes::_invokestatic:\n+    case Bytecodes::_invokevirtual:\n+    case Bytecodes::_fast_invokevfinal: \/\/ Bytecode interpreter uses this\n+      return resolved_method_entry_at(index)->is_resolved(code);\n+\n+    default:\n+      fatal(\"Unexpected bytecode: %s\", Bytecodes::name(code));\n+  }\n+}\n+\n@@ -1044,1 +1118,3 @@\n-    {\n+    { PerfTraceTimedEvent timer(ClassLoader::perf_resolve_invokedynamic_time(),\n+                                ClassLoader::perf_resolve_invokedynamic_count());\n+\n@@ -1102,1 +1178,3 @@\n-    {\n+    { PerfTraceTimedEvent timer(ClassLoader::perf_resolve_method_handle_time(),\n+                                ClassLoader::perf_resolve_method_handle_count());\n+\n@@ -1150,1 +1228,3 @@\n-    {\n+    { PerfTraceTimedEvent timer(ClassLoader::perf_resolve_method_type_time(),\n+                                ClassLoader::perf_resolve_method_type_count());\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":133,"deletions":53,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -664,0 +664,2 @@\n+  bool is_resolved(int which, Bytecodes::Code code);\n+\n@@ -680,1 +682,0 @@\n-  bool maybe_archive_resolved_klass_at(int cp_index);\n@@ -683,0 +684,3 @@\n+private:\n+  void remove_unshareable_entries();\n+  void remove_resolved_klass_if_non_deterministic(int cp_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -392,3 +393,1 @@\n-  \/\/ <this> is the copy to be written into the archive. It's in the ArchiveBuilder's \"buffer space\".\n-  \/\/ However, this->_initial_entries was not copied\/relocated by the ArchiveBuilder, so it's\n-  \/\/ still pointing to the array allocated inside save_for_archive().\n+\n@@ -401,3 +400,1 @@\n-    for (int i = 0; i < _resolved_field_entries->length(); i++) {\n-      resolved_field_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_field_entries_if_non_deterministic();\n@@ -411,0 +408,35 @@\n+\n+void ConstantPoolCache::remove_resolved_field_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_field_entries->length(); i++) {\n+    ResolvedFieldEntry* rfi = _resolved_field_entries->adr_at(i);\n+    int cp_index = rfi->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rfi->is_resolved(Bytecodes::_getfield)  ||\n+                    rfi->is_resolved(Bytecodes::_putfield);\n+    if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+      rfi->mark_and_relocate();\n+      archived = true;\n+    } else {\n+      rfi->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s field  CP entry [%3d]: %s %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  (archived ? \"=>\" : \"  \"),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+      }\n+    }\n+    ArchiveBuilder::alloc_stats()->record_field_cp_entry(archived, resolved && !archived);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1154,0 +1154,2 @@\n+  PerfTraceTime timer(ClassLoader::perf_ik_link_methods_time());\n+\n@@ -2794,1 +2796,3 @@\n-  constants()->remove_unshareable_info();\n+  \/\/ Call remove_unshareable_info() on other objects that belong to this class, except\n+  \/\/ for constants()->remove_unshareable_info(), which is called in a separate pass in\n+  \/\/ ArchiveBuilder::make_klasses_shareable(),\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -66,0 +67,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -72,0 +74,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -1211,0 +1214,4 @@\n+  if (log_is_enabled(Info, perf, class, link)) {\n+    ClassLoader::perf_ik_link_methods_count()->inc();\n+  }\n+\n@@ -1265,0 +1272,2 @@\n+  PerfTraceTime timer(ClassLoader::perf_method_adapters_time());\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"resolvedFieldEntry.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -30,0 +30,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -60,0 +61,1 @@\n+#if INCLUDE_CDS\n@@ -65,0 +67,5 @@\n+\n+void ResolvedFieldEntry::mark_and_relocate() {\n+  ArchiveBuilder::current()->mark_and_relocate_to_buffered_addr(&_field_holder);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,11 @@\n+  void copy_from(const ResolvedFieldEntry& other) {\n+    _field_holder = other._field_holder;\n+    _field_offset = other._field_offset;\n+    _field_index = other._field_index;\n+    _cpool_index = other._cpool_index;\n+    _tos_state = other._tos_state;\n+    _flags = other._flags;\n+    _get_code = other._get_code;\n+    _put_code = other._put_code;\n+  }\n+\n@@ -68,0 +79,1 @@\n+\n@@ -71,0 +83,9 @@\n+  ResolvedFieldEntry(const ResolvedFieldEntry& other) {\n+    copy_from(other);\n+  }\n+\n+  ResolvedFieldEntry& operator=(const ResolvedFieldEntry& other) {\n+    copy_from(other);\n+    return *this;\n+  }\n+\n@@ -153,0 +174,1 @@\n+#if INCLUDE_CDS\n@@ -154,0 +176,2 @@\n+  void mark_and_relocate();\n+#endif\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1019,2 +1019,4 @@\n-  \/\/ true if CFG node d dominates CFG node n\n-  bool is_dominator(Node *d, Node *n);\n+\n+  bool is_dominator(Node* dominator, Node* n);\n+  bool is_strict_dominator(Node* dominator, Node* n);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4477,1 +4477,1 @@\n-    assert(!is_dominator(c, region) || c == region, \"shouldn't go above region\");\n+    assert(!is_strict_dominator(c, region), \"shouldn't go above region\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1130,10 +1130,0 @@\n-#ifdef ASSERT\n-      tty->print_cr(\"# Can't determine return type.\");\n-      tty->print_cr(\"# exit control\");\n-      _exits.control()->dump(2);\n-      tty->print_cr(\"# ret phi type\");\n-      _gvn.type(ret_phi)->dump();\n-      tty->print_cr(\"# ret phi\");\n-      ret_phi->dump(2);\n-#endif \/\/ ASSERT\n-      assert(false, \"Can't determine return type.\");\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -71,3 +71,4 @@\n-  flags(SUPERWORD1_BEFORE_SCHEDULE,     \"Superword 1, Before Schedule\") \\\n-  flags(SUPERWORD2_BEFORE_OUTPUT,       \"Superword 2, Before Output\") \\\n-  flags(SUPERWORD3_AFTER_OUTPUT,        \"Superword 3, After Output\") \\\n+  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,       \"AutoVectorization 1, Before Apply\") \\\n+  flags(AUTO_VECTORIZATION2_AFTER_REORDER,      \"AutoVectorization 2, After Apply Memop Reordering\") \\\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, \"AutoVectorization 3, After Adjusting Pre-Loop Limit\") \\\n+  flags(AUTO_VECTORIZATION4_AFTER_APPLY,        \"AutoVectorization 4, After Apply\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3848,1 +3848,1 @@\n-      w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+      w.stream()->print_cr(\"%s %s\", ClassListParser::lambda_form_tag(), c_line);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"sanitizers\/ub.hpp\"\n@@ -250,0 +251,3 @@\n+  \/\/ we use this method at some places for writing to 0 e.g. to cause a crash;\n+  \/\/ ubsan does not know that this is the desired behavior\n+  ATTRIBUTE_NO_UBSAN\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -2206,1 +2207,4 @@\n-  return true;\n+  \/\/ An exploded build inhibits use of CDS. Therefore, for the\n+  \/\/ purpose of testing, the JVM can be treated as not having CDS\n+  \/\/ built in at all.\n+  return ClassLoader::has_jrt_entry();\n@@ -2744,0 +2748,5 @@\n+\/\/ Reports resident set size (RSS) in bytes\n+WB_ENTRY(jlong, WB_Rss(JNIEnv* env, jobject o))\n+  return os::rss();\n+WB_END\n+\n@@ -3037,0 +3046,1 @@\n+  {CC\"rss\", CC\"()J\",                                  (void*)&WB_Rss},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/genArguments.hpp\"\n@@ -506,1 +507,0 @@\n-  { \"OldSize\",                      JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -517,0 +517,1 @@\n+  { \"OldSize\",                      JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -522,0 +523,2 @@\n+\n+  { \"HeapFirstMaximumCompactionCount\", JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -752,1 +755,1 @@\n-  if (*value == '\\0' || isspace(*value)) {\n+  if (*value == '\\0' || isspace((unsigned char) *value)) {\n@@ -1182,1 +1185,1 @@\n-        else if (!isspace(c)) {\n+        else if (!isspace((unsigned char) c)) {\n@@ -1188,1 +1191,1 @@\n-      if (c == '\\n' || (!in_quote && isspace(c))) {\n+      if (c == '\\n' || (!in_quote && isspace((unsigned char) c))) {\n@@ -3234,1 +3237,1 @@\n-    while (rd < buffer_end && isspace(*rd)) {\n+    while (rd < buffer_end && isspace((unsigned char) *rd)) {\n@@ -3247,1 +3250,1 @@\n-    while (rd < buffer_end && !isspace(*rd)) {\n+    while (rd < buffer_end && !isspace((unsigned char) *rd)) {\n@@ -3829,0 +3832,7 @@\n+  if (log_is_enabled(Info, perf, class, link)) {\n+    if (!UsePerfData) {\n+      warning(\"Disabling -Xlog:perf+class+link since UsePerfData is turned off.\");\n+      LogConfiguration::configure_stdout(LogLevel::Off, false, LOG_TAGS(perf, class, link));\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -63,0 +64,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -71,0 +73,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -2928,0 +2931,3 @@\n+  if (log_is_enabled(Info, perf, class, link)) {\n+    ClassLoader::perf_method_adapters_count()->inc();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -825,0 +825,6 @@\n+  if (log_is_enabled(Info, perf, class, link)) {\n+    LogStreamHandle(Info, perf, class, link) log;\n+    log.print_cr(\"At VM initialization completion:\");\n+    ClassLoader::print_counters(&log);\n+  }\n+\n@@ -1330,2 +1336,5 @@\n-            st->print_cr(\"   Mounted virtual thread \\\"%s\\\" #\" INT64_FORMAT, JavaThread::name_for(vt), (int64_t)java_lang_Thread::thread_id(vt));\n-            p->print_vthread_stack_on(st);\n+            \/\/ JavaThread._vthread can refer to the carrier thread. Print only if _vthread refers to a virtual thread.\n+            if (vt != thread_oop) {\n+              st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, (int64_t)java_lang_Thread::thread_id(vt));\n+              p->print_vthread_stack_on(st);\n+            }\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1230,1 +1230,3 @@\n-  if (::strcmp(default_filename, _filename.value()) == 0) {\n+  if (_filename.is_set()) {\n+    name = _filename.value();\n+  } else {\n@@ -1233,2 +1235,0 @@\n-  } else {\n-    name = _filename.value();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4770,0 +4770,1 @@\n+     * @see Class##hiddenClasses Hidden Classes\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,7 +28,6 @@\n-import jdk.internal.loader.BootLoader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.vm.annotation.Stable;\n-import sun.invoke.util.BytecodeName;\n-\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.LambdaForm.BasicType;\n@@ -45,1 +44,9 @@\n-import static java.lang.invoke.LambdaForm.*;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.loader.BootLoader;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.BytecodeName;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,1 +57,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n@@ -60,0 +66,4 @@\n+\n+    private static final ClassDesc CD_LambdaForm = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_BoundMethodHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n+\n@@ -407,1 +417,1 @@\n-                    end.append(classSig(type));\n+                    end.append(type.descriptorString());\n@@ -575,2 +585,3 @@\n-        private final String SPECIES_DATA = classBCName(metaType);\n-        private final String SPECIES_DATA_SIG = classSig(SPECIES_DATA);\n+\n+        private final ClassDesc CD_SPECIES_DATA = classDesc(metaType);\n+        private final MethodTypeDesc MTD_SPECIES_DATA = MethodTypeDescImpl.ofValidated(CD_SPECIES_DATA);\n@@ -598,0 +609,1 @@\n+        private static final MethodTypeDesc MTD_TRANFORM_HELPER = MethodTypeDescImpl.ofValidated(CD_MethodHandle, CD_int);\n@@ -602,65 +614,61 @@\n-            final String className = classBCName(className0);\n-            final String superClassName = classBCName(speciesData.deriveSuperClass());\n-\n-            final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-            final int NOT_ACC_PUBLIC = 0;  \/\/ not ACC_PUBLIC\n-            cw.visit(CLASSFILE_VERSION, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, superClassName, null);\n-\n-            final String sourceFile = className.substring(className.lastIndexOf('.')+1);\n-            cw.visitSource(sourceFile, null);\n-\n-            \/\/ emit static types and BMH_SPECIES fields\n-            FieldVisitor fw = cw.visitField(NOT_ACC_PUBLIC + ACC_STATIC, sdFieldName, SPECIES_DATA_SIG, null, null);\n-            fw.visitAnnotation(STABLE_SIG, true);\n-            fw.visitEnd();\n-\n-            \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n-            class Var {\n-                final int index;\n-                final String name;\n-                final Class<?> type;\n-                final String desc;\n-                final BasicType basicType;\n-                final int slotIndex;\n-                Var(int index, int slotIndex) {\n-                    this.index = index;\n-                    this.slotIndex = slotIndex;\n-                    name = null; type = null; desc = null;\n-                    basicType = BasicType.V_TYPE;\n-                }\n-                Var(String name, Class<?> type, Var prev) {\n-                    int slotIndex = prev.nextSlotIndex();\n-                    int index = prev.nextIndex();\n-                    if (name == null)  name = \"x\";\n-                    if (name.endsWith(\"#\"))\n-                        name = name.substring(0, name.length()-1) + index;\n-                    assert(!type.equals(void.class));\n-                    String desc = classSig(type);\n-                    BasicType basicType = BasicType.basicType(type);\n-                    this.index = index;\n-                    this.name = name;\n-                    this.type = type;\n-                    this.desc = desc;\n-                    this.basicType = basicType;\n-                    this.slotIndex = slotIndex;\n-                }\n-                Var lastOf(List<Var> vars) {\n-                    int n = vars.size();\n-                    return (n == 0 ? this : vars.get(n-1));\n-                }\n-                <X> List<Var> fromTypes(List<X> types) {\n-                    Var prev = this;\n-                    ArrayList<Var> result = new ArrayList<>(types.size());\n-                    int i = 0;\n-                    for (X x : types) {\n-                        String vn = name;\n-                        Class<?> vt;\n-                        if (x instanceof Class<?> cl) {\n-                            vt = cl;\n-                            \/\/ make the names friendlier if debugging\n-                            assert((vn = vn + \"_\" + (i++)) != null);\n-                        } else {\n-                            @SuppressWarnings(\"unchecked\")\n-                            Var v = (Var) x;\n-                            vn = v.name;\n-                            vt = v.type;\n+            final ClassDesc classDesc = ClassDesc.of(className0);\n+            final ClassDesc superClassDesc = classDesc(speciesData.deriveSuperClass());\n+            return ClassFile.of().build(classDesc, clb -> {\n+                clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                   .withSuperclass(superClassDesc)\n+                   .with(SourceFileAttribute.of(classDesc.displayName()))\n+\n+                \/\/ emit static types and BMH_SPECIES fields\n+                   .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n+\n+                \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n+                class Var {\n+                    final int index;\n+                    final String name;\n+                    final Class<?> type;\n+                    final ClassDesc desc;\n+                    final BasicType basicType;\n+                    final int slotIndex;\n+                    Var(int index, int slotIndex) {\n+                        this.index = index;\n+                        this.slotIndex = slotIndex;\n+                        name = null; type = null; desc = null;\n+                        basicType = BasicType.V_TYPE;\n+                    }\n+                    Var(String name, Class<?> type, Var prev) {\n+                        int slotIndex = prev.nextSlotIndex();\n+                        int index = prev.nextIndex();\n+                        if (name == null)  name = \"x\";\n+                        if (name.endsWith(\"#\"))\n+                            name = name.substring(0, name.length()-1) + index;\n+                        assert(!type.equals(void.class));\n+                        this.index = index;\n+                        this.name = name;\n+                        this.type = type;\n+                        this.desc = classDesc(type);\n+                        this.basicType = BasicType.basicType(type);\n+                        this.slotIndex = slotIndex;\n+                    }\n+                    Var lastOf(List<Var> vars) {\n+                        int n = vars.size();\n+                        return (n == 0 ? this : vars.get(n-1));\n+                    }\n+                    <X> List<Var> fromTypes(List<X> types) {\n+                        Var prev = this;\n+                        ArrayList<Var> result = new ArrayList<>(types.size());\n+                        int i = 0;\n+                        for (X x : types) {\n+                            String vn = name;\n+                            Class<?> vt;\n+                            if (x instanceof Class<?> cl) {\n+                                vt = cl;\n+                                \/\/ make the names friendlier if debugging\n+                                assert((vn = vn + \"_\" + (i++)) != null);\n+                            } else {\n+                                @SuppressWarnings(\"unchecked\")\n+                                Var v = (Var) x;\n+                                vn = v.name;\n+                                vt = v.type;\n+                            }\n+                            prev = new Var(vn, vt, prev);\n+                            result.add(prev);\n@@ -668,2 +676,1 @@\n-                        prev = new Var(vn, vt, prev);\n-                        result.add(prev);\n+                        return result;\n@@ -671,31 +678,7 @@\n-                    return result;\n-                }\n-                int slotSize() { return basicType.basicTypeSlots(); }\n-                int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n-                int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n-                boolean isInHeap() { return slotIndex < 0; }\n-                void emitVarInstruction(int asmop, MethodVisitor mv) {\n-                    if (asmop == ALOAD)\n-                        asmop = typeLoadOp(basicType.basicTypeChar());\n-                    else\n-                        throw new AssertionError(\"bad op=\"+asmop+\" for desc=\"+desc);\n-                    mv.visitVarInsn(asmop, slotIndex);\n-                }\n-                public void emitFieldInsn(int asmop, MethodVisitor mv) {\n-                    mv.visitFieldInsn(asmop, className, name, desc);\n-                }\n-            }\n-\n-            final Var NO_THIS = new Var(0, 0),\n-                    AFTER_THIS = new Var(0, 1),\n-                    IN_HEAP = new Var(0, -1);\n-\n-            \/\/ figure out the field types\n-            final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n-            final List<Var> fields = new ArrayList<>(fieldTypes.size());\n-            {\n-                Var nextF = IN_HEAP;\n-                for (Class<?> ft : fieldTypes) {\n-                    String fn = chooseFieldName(ft, nextF.nextIndex());\n-                    nextF = new Var(fn, ft, nextF);\n-                    fields.add(nextF);\n+                    int slotSize() { return basicType.basicTypeSlots(); }\n+                    int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n+                    int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n+                    boolean isInHeap() { return slotIndex < 0; }\n+                    void emitLoadInstruction(CodeBuilder cob) {\n+                        cob.loadLocal(basicType.btKind, slotIndex);\n+                    }\n@@ -704,31 +687,14 @@\n-            }\n-            \/\/ emit bound argument fields\n-            for (Var field : fields) {\n-                cw.visitField(ACC_FINAL, field.name, field.desc, null, null).visitEnd();\n-            }\n-\n-            MethodVisitor mv;\n-\n-            \/\/ emit implementation of speciesData()\n-            mv = cw.visitMethod((SPECIES_DATA_MODS & ACC_PPP) + ACC_FINAL,\n-                    SPECIES_DATA_NAME, \"()\" + SPECIES_DATA_SIG, null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, className, sdFieldName, SPECIES_DATA_SIG);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-\n-            \/\/ figure out the constructor arguments\n-            MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n-            MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n-\n-            \/\/ emit constructor\n-            {\n-                mv = cw.visitMethod(ACC_PRIVATE,\n-                        \"<init>\", methodSig(thisCtorType), null, null);\n-                mv.visitCode();\n-                mv.visitVarInsn(ALOAD, 0); \/\/ this\n-\n-                final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n-                for (Var ca : ctorArgs) {\n-                    ca.emitVarInstruction(ALOAD, mv);\n+                final Var NO_THIS = new Var(0, 0),\n+                        AFTER_THIS = new Var(0, 1),\n+                        IN_HEAP = new Var(0, -1);\n+\n+                \/\/ figure out the field types\n+                final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n+                final List<Var> fields = new ArrayList<>(fieldTypes.size());\n+                {\n+                    Var nextF = IN_HEAP;\n+                    for (Class<?> ft : fieldTypes) {\n+                        String fn = chooseFieldName(ft, nextF.nextIndex());\n+                        nextF = new Var(fn, ft, nextF);\n+                        fields.add(nextF);\n+                    }\n@@ -738,12 +704,3 @@\n-                \/\/ super(ca...)\n-                mv.visitMethodInsn(INVOKESPECIAL, superClassName,\n-                        \"<init>\", methodSig(superCtorType), false);\n-\n-                \/\/ store down fields\n-                Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n-                for (Var f : fields) {\n-                    \/\/ this.argL1 = argL1\n-                    mv.visitVarInsn(ALOAD, 0);  \/\/ this\n-                    lastFV = new Var(f.name, f.type, lastFV);\n-                    lastFV.emitVarInstruction(ALOAD, mv);\n-                    f.emitFieldInsn(PUTFIELD, mv);\n+                \/\/ emit bound argument fields\n+                for (Var field : fields) {\n+                    clb.withField(field.name, field.desc, ACC_FINAL);\n@@ -752,4 +709,4 @@\n-                mv.visitInsn(RETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            }\n+                \/\/ emit implementation of speciesData()\n+                clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                        cob -> cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                  .areturn());\n@@ -757,13 +714,3 @@\n-            \/\/ emit make()  ...factory method wrapping constructor\n-            {\n-                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n-                mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_STATIC,\n-                        \"make\", methodSig(ftryType), null, null);\n-                mv.visitCode();\n-                \/\/ make instance\n-                mv.visitTypeInsn(NEW, className);\n-                mv.visitInsn(DUP);\n-                \/\/ load factory method arguments:  ctarg... and arg...\n-                for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n-                    v.emitVarInstruction(ALOAD, mv);\n-                }\n+                \/\/ figure out the constructor arguments\n+                MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n+                MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n@@ -771,7 +718,3 @@\n-                \/\/ finally, invoke the constructor and return\n-                mv.visitMethodInsn(INVOKESPECIAL, className,\n-                        \"<init>\", methodSig(thisCtorType), false);\n-                mv.visitInsn(ARETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            }\n+                \/\/ emit constructor\n+                clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE, cob -> {\n+                    cob.aload(0); \/\/ this\n@@ -779,35 +722,3 @@\n-            \/\/ For each transform, emit the customized override of the transform method.\n-            \/\/ This method mixes together some incoming arguments (from the transform's\n-            \/\/ static type signature) with the field types themselves, and passes\n-            \/\/ the resulting mish-mosh of values to a method handle produced by\n-            \/\/ the species itself.  (Typically this method handle is the factory\n-            \/\/ method of this species or a related one.)\n-            for (int whichtm = 0; whichtm < TRANSFORM_NAMES.size(); whichtm++) {\n-                final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n-                final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n-                final int        TMODS = TRANSFORM_MODS.get(whichtm);\n-                mv = cw.visitMethod((TMODS & ACC_PPP) | ACC_FINAL,\n-                        TNAME, TTYPE.toMethodDescriptorString(), null, E_THROWABLE);\n-                mv.visitCode();\n-                \/\/ return a call to the corresponding \"transform helper\", something like this:\n-                \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n-                mv.visitFieldInsn(GETSTATIC, className,\n-                        sdFieldName, SPECIES_DATA_SIG);\n-                emitIntConstant(whichtm, mv);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, SPECIES_DATA,\n-                        \"transformHelper\", \"(I)\" + MH_SIG, false);\n-\n-                List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n-                List<Var> tfields = new ArrayList<>(fields);\n-                \/\/ mix them up and load them for the transform helper:\n-                List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n-                List<Class<?>> helperTypes = new ArrayList<>(helperArgs.size());\n-                for (Var ha : helperArgs) {\n-                    helperTypes.add(ha.basicType.basicTypeClass());\n-                    if (ha.isInHeap()) {\n-                        assert(tfields.contains(ha));\n-                        mv.visitVarInsn(ALOAD, 0);\n-                        ha.emitFieldInsn(GETFIELD, mv);\n-                    } else {\n-                        assert(targs.contains(ha));\n-                        ha.emitVarInstruction(ALOAD, mv);\n+                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n+                    for (Var ca : ctorArgs) {\n+                        ca.emitLoadInstruction(cob);\n@@ -815,21 +726,12 @@\n-                }\n-\n-                \/\/ jump into the helper (which is probably a factory method)\n-                final Class<?> rtype = TTYPE.returnType();\n-                final BasicType rbt = BasicType.basicType(rtype);\n-                MethodType invokeBasicType = MethodType.methodType(rbt.basicTypeClass(), helperTypes);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MH,\n-                        \"invokeBasic\", methodSig(invokeBasicType), false);\n-                if (rbt == BasicType.L_TYPE) {\n-                    mv.visitTypeInsn(CHECKCAST, classBCName(rtype));\n-                    mv.visitInsn(ARETURN);\n-                } else {\n-                    throw newInternalError(\"NYI: transform of type \"+rtype);\n-                }\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n-        }\n+                    \/\/ super(ca...)\n+                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n+\n+                    \/\/ store down fields\n+                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n+                    for (Var f : fields) {\n+                        \/\/ this.argL1 = argL1\n+                        cob.aload(0);  \/\/ this\n+                        lastFV = new Var(f.name, f.type, lastFV);\n+                        lastFV.emitLoadInstruction(cob);\n+                        cob.putfield(classDesc, f.name, f.desc);\n+                    }\n@@ -838,10 +740,2 @@\n-        private int typeLoadOp(char t) {\n-            return switch (t) {\n-                case 'L' -> ALOAD;\n-                case 'I' -> ILOAD;\n-                case 'J' -> LLOAD;\n-                case 'F' -> FLOAD;\n-                case 'D' -> DLOAD;\n-                default -> throw newInternalError(\"unrecognized type \" + t);\n-            };\n-        }\n+                    cob.return_();\n+                });\n@@ -849,10 +743,10 @@\n-        private void emitIntConstant(int con, MethodVisitor mv) {\n-            if (ICONST_M1 - ICONST_0 <= con && con <= ICONST_5 - ICONST_0)\n-                mv.visitInsn(ICONST_0 + con);\n-            else if (con == (byte) con)\n-                mv.visitIntInsn(BIPUSH, con);\n-            else if (con == (short) con)\n-                mv.visitIntInsn(SIPUSH, con);\n-            else {\n-                mv.visitLdcInsn(con);\n-            }\n+                \/\/ emit make()  ...factory method wrapping constructor\n+                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n+                clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC, cob -> {\n+                    \/\/ make instance\n+                    cob.new_(classDesc)\n+                       .dup();\n+                    \/\/ load factory method arguments:  ctarg... and arg...\n+                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n+                        v.emitLoadInstruction(cob);\n+                    }\n@@ -860,0 +754,56 @@\n+                    \/\/ finally, invoke the constructor and return\n+                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n+                       .areturn();\n+                });\n+\n+                \/\/ For each transform, emit the customized override of the transform method.\n+                \/\/ This method mixes together some incoming arguments (from the transform's\n+                \/\/ static type signature) with the field types themselves, and passes\n+                \/\/ the resulting mish-mosh of values to a method handle produced by\n+                \/\/ the species itself.  (Typically this method handle is the factory\n+                \/\/ method of this species or a related one.)\n+                for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n+                    final int whichtm = i;\n+                    final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n+                    final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n+                    final int        TMODS = TRANSFORM_MODS.get(whichtm);\n+                    clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, mb -> {\n+                        mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n+                          .withCode(cob -> {\n+                            \/\/ return a call to the corresponding \"transform helper\", something like this:\n+                            \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n+                            cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                               .loadConstant(whichtm)\n+                               .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n+\n+                            List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n+                            List<Var> tfields = new ArrayList<>(fields);\n+                            \/\/ mix them up and load them for the transform helper:\n+                            List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n+                            ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n+                            for (int hi = 0; hi < helperTypes.length; hi++) {\n+                                Var ha = helperArgs.get(hi);\n+                                helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n+                                if (ha.isInHeap()) {\n+                                    assert(tfields.contains(ha));\n+                                    cob.aload(0);\n+                                    cob.getfield(classDesc, ha.name, ha.desc);\n+                                } else {\n+                                    assert(targs.contains(ha));\n+                                    ha.emitLoadInstruction(cob);\n+                                }\n+                            }\n+\n+                            \/\/ jump into the helper (which is probably a factory method)\n+                            final Class<?> rtype = TTYPE.returnType();\n+                            if (!rtype.isPrimitive()) {\n+                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n+                                   .checkcast(classDesc(rtype))\n+                                   .areturn();\n+                            } else {\n+                                throw newInternalError(\"NYI: transform of type \"+rtype);\n+                            }\n+                        });\n+                    });\n+                }\n+            });\n@@ -993,27 +943,0 @@\n-    private static final String MH = \"java\/lang\/invoke\/MethodHandle\";\n-    private static final String MH_SIG = \"L\" + MH + \";\";\n-    private static final String STABLE = \"jdk\/internal\/vm\/annotation\/Stable\";\n-    private static final String STABLE_SIG = \"L\" + STABLE + \";\";\n-    private static final String[] E_THROWABLE = new String[] { \"java\/lang\/Throwable\" };\n-    static {\n-        assert(MH_SIG.equals(classSig(MethodHandle.class)));\n-        assert(MH.equals(classBCName(MethodHandle.class)));\n-    }\n-\n-    static String methodSig(MethodType mt) {\n-        return mt.toMethodDescriptorString();\n-    }\n-    static String classSig(Class<?> cls) {\n-        if (cls.isPrimitive() || cls.isArray())\n-            return MethodType.methodType(cls).toMethodDescriptorString().substring(2);\n-        return classSig(classBCName(cls));\n-    }\n-    static String classSig(String bcName) {\n-        assert(bcName.indexOf('.') < 0);\n-        assert(!bcName.endsWith(\";\"));\n-        assert(!bcName.startsWith(\"[\"));\n-        return \"L\" + bcName + \";\";\n-    }\n-    static String classBCName(Class<?> cls) {\n-        return classBCName(className(cls));\n-    }\n@@ -1024,3 +947,16 @@\n-    static String className(Class<?> cls) {\n-        assert(!cls.isArray() && !cls.isPrimitive());\n-        return cls.getName();\n+\n+    static ClassDesc classDesc(Class<?> cls) {\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+             : cls == Object.class ? CD_Object\n+             : cls == MethodType.class ? CD_MethodType\n+             : cls == LambdaForm.class ? CD_LambdaForm\n+             : cls == BoundMethodHandle.class ? CD_BoundMethodHandle\n+             : ClassDescImpl.ofValidated(cls.descriptorString());\n+    }\n+\n+    static MethodTypeDesc methodDesc(MethodType mt) {\n+        var params = new ClassDesc[mt.parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            params[i] = classDesc(mt.parameterType(i));\n+        }\n+        return MethodTypeDescImpl.ofValidated(classDesc(mt.returnType()), params);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":219,"deletions":283,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n-import sun.invoke.util.BytecodeDescriptor;\n@@ -37,0 +35,9 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.FieldBuilder;\n+import java.lang.classfile.MethodBuilder;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+\n+import java.lang.constant.ClassDesc;\n@@ -38,0 +45,2 @@\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -39,0 +48,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -40,0 +50,1 @@\n+import java.util.ArrayList;\n@@ -42,0 +53,1 @@\n+import java.util.List;\n@@ -43,2 +55,10 @@\n-\n-import static java.lang.invoke.MethodHandleStatics.CLASSFILE_VERSION;\n+import java.util.function.Consumer;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.attribute.LoadableDescriptorsAttribute;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -48,1 +68,4 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n+import sun.invoke.util.Wrapper;\n@@ -57,25 +80,15 @@\n-    private static final String METHOD_DESCRIPTOR_VOID = Type.getMethodDescriptor(Type.VOID_TYPE);\n-    private static final String JAVA_LANG_OBJECT = \"java\/lang\/Object\";\n-    private static final String NAME_CTOR = \"<init>\";\n-\n-    \/\/Serialization support\n-    private static final String NAME_SERIALIZED_LAMBDA = \"java\/lang\/invoke\/SerializedLambda\";\n-    private static final String NAME_NOT_SERIALIZABLE_EXCEPTION = \"java\/io\/NotSerializableException\";\n-    private static final String DESCR_METHOD_WRITE_REPLACE = \"()Ljava\/lang\/Object;\";\n-    private static final String DESCR_METHOD_WRITE_OBJECT = \"(Ljava\/io\/ObjectOutputStream;)V\";\n-    private static final String DESCR_METHOD_READ_OBJECT = \"(Ljava\/io\/ObjectInputStream;)V\";\n-\n-    private static final String NAME_METHOD_WRITE_REPLACE = \"writeReplace\";\n-    private static final String NAME_METHOD_READ_OBJECT = \"readObject\";\n-    private static final String NAME_METHOD_WRITE_OBJECT = \"writeObject\";\n-\n-    private static final String DESCR_CLASS = \"Ljava\/lang\/Class;\";\n-    private static final String DESCR_STRING = \"Ljava\/lang\/String;\";\n-    private static final String DESCR_OBJECT = \"Ljava\/lang\/Object;\";\n-    private static final String DESCR_CTOR_SERIALIZED_LAMBDA\n-            = \"(\" + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + \"I\"\n-            + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + \"[\" + DESCR_OBJECT + \")V\";\n-\n-    private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = \"(Ljava\/lang\/String;)V\";\n-    private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};\n-\n+    private static final ClassDesc[] EMPTY_CLASSDESC_ARRAY = ConstantUtils.EMPTY_CLASSDESC;\n+\n+    \/\/ Static builders to avoid lambdas\n+    record FieldFlags(int flags) implements Consumer<FieldBuilder> {\n+        @Override\n+        public void accept(FieldBuilder fb) {\n+            fb.withFlags(flags);\n+        }\n+    };\n+    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n+        @Override\n+        public void accept(MethodBuilder mb) {\n+            mb.withCode(code);\n+        }\n+    };\n@@ -90,3 +103,0 @@\n-    \/\/ condy to load implMethod from class data\n-    private static final ConstantDynamic implMethodCondy;\n-\n@@ -102,6 +112,0 @@\n-\n-        \/\/ condy to load implMethod from class data\n-        MethodType classDataMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n-        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n-                                         classDataMType.descriptorString(), false);\n-        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm);\n@@ -111,1 +115,1 @@\n-    private final String implMethodClassName;        \/\/ Name of type containing implementation \"CC\"\n+    private final ClassDesc implMethodClassDesc;     \/\/ Name of type containing implementation \"CC\"\n@@ -113,1 +117,1 @@\n-    private final String implMethodDesc;             \/\/ Type descriptor for implementation methods \"(I)Ljava\/lang\/String;\"\n+    private final MethodTypeDesc implMethodDesc;     \/\/ Type descriptor for implementation methods \"(I)Ljava\/lang\/String;\"\n@@ -115,1 +119,1 @@\n-    private final ClassWriter cw;                    \/\/ ASM class writer\n+    private final MethodTypeDesc constructorTypeDesc;\/\/ Type descriptor for the generated class constructor type \"(CC)void\"\n@@ -117,2 +121,3 @@\n-    private final String[] argDescs;                 \/\/ Type descriptors for the constructor arguments\n-    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda\"\n+    private final ClassDesc[] argDescs;              \/\/ Type descriptors for the constructor arguments\n+    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda$1\"\n+    private final ClassDesc lambdaClassDesc;         \/\/ Type descriptor for the generated class \"X$$Lambda$1\"\n@@ -174,1 +179,1 @@\n-        implMethodClassName = implClass.getName().replace('.', '\/');\n+        implMethodClassDesc = implClassDesc(implClass);\n@@ -176,1 +181,1 @@\n-        implMethodDesc = implInfo.getMethodType().toMethodDescriptorString();\n+        implMethodDesc = methodDesc(implInfo.getMethodType());\n@@ -178,0 +183,1 @@\n+        constructorTypeDesc = methodDesc(constructorType);\n@@ -179,0 +185,1 @@\n+        lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n@@ -188,3 +195,2 @@\n-                               implKind == H_INVOKESPECIAL ||\n-                               implKind == H_INVOKESTATIC && implClass.isHidden();\n-        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+                               implKind == MethodHandleInfo.REF_invokeSpecial ||\n+                               implKind == MethodHandleInfo.REF_invokeStatic && implClass.isHidden();\n@@ -194,1 +200,1 @@\n-            argDescs = new String[parameterCount];\n+            argDescs = new ClassDesc[parameterCount];\n@@ -197,1 +203,1 @@\n-                argDescs[i] = BytecodeDescriptor.unparse(factoryType.parameterType(i));\n+                argDescs[i] = classDesc(factoryType.parameterType(i));\n@@ -200,1 +206,2 @@\n-            argNames = argDescs = EMPTY_STRING_ARRAY;\n+            argNames = EMPTY_STRING_ARRAY;\n+            argDescs = EMPTY_CLASSDESC_ARRAY;\n@@ -306,2 +313,2 @@\n-        String[] interfaceNames;\n-        String interfaceName = interfaceClass.getName().replace('.', '\/');\n+        List<ClassDesc> interfaces;\n+        ClassDesc interfaceDesc = classDesc(interfaceClass);\n@@ -310,1 +317,1 @@\n-            interfaceNames = new String[]{interfaceName};\n+            interfaces = List.of(interfaceDesc);\n@@ -313,2 +320,2 @@\n-            Set<String> itfs = LinkedHashSet.newLinkedHashSet(altInterfaces.length + 1);\n-            itfs.add(interfaceName);\n+            Set<ClassDesc> itfs = LinkedHashSet.newLinkedHashSet(altInterfaces.length + 1);\n+            itfs.add(interfaceDesc);\n@@ -316,1 +323,1 @@\n-                itfs.add(i.getName().replace('.', '\/'));\n+                itfs.add(classDesc(i));\n@@ -319,15 +326,1 @@\n-            interfaceNames = itfs.toArray(new String[itfs.size()]);\n-        }\n-\n-        int version = CLASSFILE_VERSION | (PreviewFeatures.isEnabled() ? Opcodes.V_PREVIEW : 0);\n-        cw.visit(version, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,\n-                 lambdaClassName, null,\n-                 JAVA_LANG_OBJECT, interfaceNames);\n-\n-        \/\/ Generate final fields to be filled in by constructor\n-        for (int i = 0; i < argDescs.length; i++) {\n-            FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL,\n-                                            argNames[i],\n-                                            argDescs[i],\n-                                            null, null);\n-            fv.visitEnd();\n+            interfaces = List.copyOf(itfs);\n@@ -335,0 +328,12 @@\n+        final boolean finalAccidentallySerializable = accidentallySerializable;\n+        final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                clb.withVersion(ClassFileFormatVersion.latest().major(), (PreviewFeatures.isEnabled() ? 0xFFFF0000 : 0))\n+                   .withFlags(ACC_SUPER | ACC_FINAL | ACC_SYNTHETIC)\n+                   .withInterfaceSymbols(interfaces);\n+\n+                \/\/ generate LoadableDescriptors attribute if it references any value class\n+                if (PreviewFeatures.isEnabled()) {\n+                    generateLoadableDescriptors(clb);\n+                }\n@@ -336,1 +341,4 @@\n-        generateConstructor();\n+                \/\/ Generate final fields to be filled in by constructor\n+                for (int i = 0; i < argDescs.length; i++) {\n+                    clb.withField(argNames[i], argDescs[i], new FieldFlags(ACC_PRIVATE | ACC_FINAL));\n+                }\n@@ -338,3 +346,1 @@\n-        if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n-            generateClassInitializer();\n-        }\n+                generateConstructor(clb);\n@@ -342,13 +348,3 @@\n-        \/\/ Forward the SAM method\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n-                                          interfaceMethodType.toMethodDescriptorString(), null, null);\n-        new ForwardingMethodGenerator(mv).generate(interfaceMethodType);\n-\n-        \/\/ Forward the altMethods\n-        if (altMethods != null) {\n-            for (MethodType mt : altMethods) {\n-                mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n-                                    mt.toMethodDescriptorString(), null, null);\n-                new ForwardingMethodGenerator(mv).generate(mt);\n-            }\n-        }\n+                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n+                    generateClassInitializer(clb);\n+                }\n@@ -356,16 +352,15 @@\n-        if (isSerializable)\n-            generateSerializationFriendlyMethods();\n-        else if (accidentallySerializable)\n-            generateSerializationHostileMethods();\n-\n-        \/\/ generate LoadableDescriptors attribute if it references any value class\n-        if (PreviewFeatures.isEnabled()) {\n-            LoadableDescriptorsAttributeBuilder builder = new LoadableDescriptorsAttributeBuilder(targetClass);\n-            builder.add(factoryType)\n-                    .add(interfaceMethodType)\n-                    .add(implMethodType)\n-                    .add(dynamicMethodType)\n-                    .add(altMethods);\n-            if (!builder.isEmpty())\n-                cw.visitAttribute(builder.build());\n-        }\n+                \/\/ Forward the SAM method\n+                clb.withMethod(interfaceMethodName,\n+                        methodDesc(interfaceMethodType),\n+                        ACC_PUBLIC,\n+                        forwardingMethod(interfaceMethodType));\n+\n+                \/\/ Forward the bridges\n+                if (altMethods != null) {\n+                    for (MethodType mt : altMethods) {\n+                        clb.withMethod(interfaceMethodName,\n+                                methodDesc(mt),\n+                                ACC_PUBLIC | ACC_BRIDGE,\n+                                forwardingMethod(mt));\n+                    }\n+                }\n@@ -373,1 +368,6 @@\n-        cw.visitEnd();\n+                if (isSerializable)\n+                    generateSerializationFriendlyMethods(clb);\n+                else if (finalAccidentallySerializable)\n+                    generateSerializationHostileMethods(clb);\n+            }\n+        });\n@@ -377,1 +377,0 @@\n-        final byte[] classBytes = cw.toByteArray();\n@@ -392,2 +391,2 @@\n-    private void generateClassInitializer() {\n-        String lambdaTypeDescriptor = factoryType.returnType().descriptorString();\n+    private void generateClassInitializer(ClassBuilder clb) {\n+        ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n@@ -396,3 +395,1 @@\n-        FieldVisitor fv = cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL,\n-                LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, null, null);\n-        fv.visitEnd();\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, new FieldFlags(ACC_PRIVATE | ACC_STATIC | ACC_FINAL));\n@@ -401,12 +398,11 @@\n-        MethodVisitor clinit = cw.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        clinit.visitCode();\n-\n-        clinit.visitTypeInsn(NEW, lambdaClassName);\n-        clinit.visitInsn(Opcodes.DUP);\n-        assert factoryType.parameterCount() == 0;\n-        clinit.visitMethodInsn(INVOKESPECIAL, lambdaClassName, NAME_CTOR, constructorType.toMethodDescriptorString(), false);\n-        clinit.visitFieldInsn(PUTSTATIC, lambdaClassName, LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor);\n-\n-        clinit.visitInsn(RETURN);\n-        clinit.visitMaxs(-1, -1);\n-        clinit.visitEnd();\n+        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                assert factoryType.parameterCount() == 0;\n+                cob.new_(lambdaClassDesc)\n+                   .dup()\n+                   .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n+                   .putstatic(lambdaClassDesc, LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)\n+                   .return_();\n+            }\n+        }));\n@@ -418,1 +414,1 @@\n-    private void generateConstructor() {\n+    private void generateConstructor(ClassBuilder clb) {\n@@ -420,18 +416,36 @@\n-        MethodVisitor ctor = cw.visitMethod(ACC_PRIVATE, NAME_CTOR,\n-                                            constructorType.toMethodDescriptorString(), null, null);\n-        ctor.visitCode();\n-        ctor.visitVarInsn(ALOAD, 0);\n-        ctor.visitMethodInsn(INVOKESPECIAL, JAVA_LANG_OBJECT, NAME_CTOR,\n-                             METHOD_DESCRIPTOR_VOID, false);\n-        int parameterCount = factoryType.parameterCount();\n-        for (int i = 0, lvIndex = 0; i < parameterCount; i++) {\n-            ctor.visitVarInsn(ALOAD, 0);\n-            Class<?> argType = factoryType.parameterType(i);\n-            ctor.visitVarInsn(getLoadOpcode(argType), lvIndex + 1);\n-            lvIndex += getParameterSize(argType);\n-            ctor.visitFieldInsn(PUTFIELD, lambdaClassName, argNames[i], argDescs[i]);\n-        }\n-        ctor.visitInsn(RETURN);\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored\n-        ctor.visitMaxs(-1, -1);\n-        ctor.visitEnd();\n+        clb.withMethod(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n+                new MethodBody(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        cob.aload(0)\n+                           .invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                        int parameterCount = factoryType.parameterCount();\n+                        for (int i = 0; i < parameterCount; i++) {\n+                            cob.aload(0);\n+                            Class<?> argType = factoryType.parameterType(i);\n+                            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n+                            cob.putfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                        }\n+                        cob.return_();\n+                    }\n+                }));\n+    }\n+\n+    private static class SerializationSupport {\n+        \/\/ Serialization support\n+        private static final ClassDesc CD_SerializedLambda = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final MethodTypeDesc MTD_Object = MethodTypeDescImpl.ofValidated(CD_Object);\n+        private static final MethodTypeDesc MTD_void_ObjectOutputStream = MethodTypeDescImpl.ofValidated(CD_void, CD_ObjectOutputStream);\n+        private static final MethodTypeDesc MTD_void_ObjectInputStream = MethodTypeDescImpl.ofValidated(CD_void, CD_ObjectInputStream);\n+\n+        private static final String NAME_METHOD_WRITE_REPLACE = \"writeReplace\";\n+        private static final String NAME_METHOD_READ_OBJECT = \"readObject\";\n+        private static final String NAME_METHOD_WRITE_OBJECT = \"writeObject\";\n+\n+        static final ClassDesc CD_NotSerializableException = ClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final MethodTypeDesc MTD_CTOR_NOT_SERIALIZABLE_EXCEPTION = MethodTypeDescImpl.ofValidated(CD_void, CD_String);\n+        static final MethodTypeDesc MTD_CTOR_SERIALIZED_LAMBDA = MethodTypeDescImpl.ofValidated(CD_void,\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+\n@@ -443,35 +457,31 @@\n-    private void generateSerializationFriendlyMethods() {\n-        TypeConvertingMethodAdapter mv\n-                = new TypeConvertingMethodAdapter(\n-                    cw.visitMethod(ACC_PRIVATE + ACC_FINAL,\n-                    NAME_METHOD_WRITE_REPLACE, DESCR_METHOD_WRITE_REPLACE,\n-                    null, null));\n-\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, NAME_SERIALIZED_LAMBDA);\n-        mv.visitInsn(DUP);\n-        mv.visitLdcInsn(Type.getType(targetClass));\n-        mv.visitLdcInsn(factoryType.returnType().getName().replace('.', '\/'));\n-        mv.visitLdcInsn(interfaceMethodName);\n-        mv.visitLdcInsn(interfaceMethodType.toMethodDescriptorString());\n-        mv.visitLdcInsn(implInfo.getReferenceKind());\n-        mv.visitLdcInsn(implInfo.getDeclaringClass().getName().replace('.', '\/'));\n-        mv.visitLdcInsn(implInfo.getName());\n-        mv.visitLdcInsn(implInfo.getMethodType().toMethodDescriptorString());\n-        mv.visitLdcInsn(dynamicMethodType.toMethodDescriptorString());\n-        mv.iconst(argDescs.length);\n-        mv.visitTypeInsn(ANEWARRAY, JAVA_LANG_OBJECT);\n-        for (int i = 0; i < argDescs.length; i++) {\n-            mv.visitInsn(DUP);\n-            mv.iconst(i);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);\n-            mv.boxIfTypePrimitive(Type.getType(argDescs[i]));\n-            mv.visitInsn(AASTORE);\n-        }\n-        mv.visitMethodInsn(INVOKESPECIAL, NAME_SERIALIZED_LAMBDA, NAME_CTOR,\n-                DESCR_CTOR_SERIALIZED_LAMBDA, false);\n-        mv.visitInsn(ARETURN);\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateSerializationFriendlyMethods(ClassBuilder clb) {\n+        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n+                new MethodBody(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        cob.new_(SerializationSupport.CD_SerializedLambda)\n+                           .dup()\n+                           .ldc(classDesc(targetClass))\n+                           .ldc(factoryType.returnType().getName().replace('.', '\/'))\n+                           .ldc(interfaceMethodName)\n+                           .ldc(interfaceMethodType.toMethodDescriptorString())\n+                           .ldc(implInfo.getReferenceKind())\n+                           .ldc(implInfo.getDeclaringClass().getName().replace('.', '\/'))\n+                           .ldc(implInfo.getName())\n+                           .ldc(implInfo.getMethodType().toMethodDescriptorString())\n+                           .ldc(dynamicMethodType.toMethodDescriptorString())\n+                           .loadConstant(argDescs.length)\n+                           .anewarray(CD_Object);\n+                        for (int i = 0; i < argDescs.length; i++) {\n+                            cob.dup()\n+                               .loadConstant(i)\n+                               .aload(0)\n+                               .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+                            cob.aastore();\n+                        }\n+                        cob.invokespecial(SerializationSupport.CD_SerializedLambda, INIT_NAME,\n+                                          SerializationSupport.MTD_CTOR_SERIALIZED_LAMBDA)\n+                           .areturn();\n+                    }\n+                }));\n@@ -483,26 +493,24 @@\n-    private void generateSerializationHostileMethods() {\n-        MethodVisitor mv = cw.visitMethod(ACC_PRIVATE + ACC_FINAL,\n-                                          NAME_METHOD_WRITE_OBJECT, DESCR_METHOD_WRITE_OBJECT,\n-                                          null, SER_HOSTILE_EXCEPTIONS);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, NAME_NOT_SERIALIZABLE_EXCEPTION);\n-        mv.visitInsn(DUP);\n-        mv.visitLdcInsn(\"Non-serializable lambda\");\n-        mv.visitMethodInsn(INVOKESPECIAL, NAME_NOT_SERIALIZABLE_EXCEPTION, NAME_CTOR,\n-                           DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION, false);\n-        mv.visitInsn(ATHROW);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PRIVATE + ACC_FINAL,\n-                            NAME_METHOD_READ_OBJECT, DESCR_METHOD_READ_OBJECT,\n-                            null, SER_HOSTILE_EXCEPTIONS);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, NAME_NOT_SERIALIZABLE_EXCEPTION);\n-        mv.visitInsn(DUP);\n-        mv.visitLdcInsn(\"Non-serializable lambda\");\n-        mv.visitMethodInsn(INVOKESPECIAL, NAME_NOT_SERIALIZABLE_EXCEPTION, NAME_CTOR,\n-                           DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION, false);\n-        mv.visitInsn(ATHROW);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateSerializationHostileMethods(ClassBuilder clb) {\n+        var hostileMethod = new Consumer<MethodBuilder>() {\n+            @Override\n+            public void accept(MethodBuilder mb) {\n+                ConstantPoolBuilder cp = mb.constantPool();\n+                ClassEntry nseCE = cp.classEntry(SerializationSupport.CD_NotSerializableException);\n+                mb.with(ExceptionsAttribute.of(nseCE))\n+                        .withCode(new Consumer<CodeBuilder>() {\n+                            @Override\n+                            public void accept(CodeBuilder cob) {\n+                                cob.new_(nseCE)\n+                                        .dup()\n+                                        .ldc(\"Non-serializable lambda\")\n+                                        .invokespecial(cp.methodRefEntry(nseCE, cp.nameAndTypeEntry(INIT_NAME,\n+                                                SerializationSupport.MTD_CTOR_NOT_SERIALIZABLE_EXCEPTION)))\n+                                        .athrow();\n+                            }\n+                        });\n+            }\n+        };\n+        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_OBJECT, SerializationSupport.MTD_void_ObjectOutputStream,\n+                ACC_PRIVATE + ACC_FINAL, hostileMethod);\n+        clb.withMethod(SerializationSupport.NAME_METHOD_READ_OBJECT, SerializationSupport.MTD_void_ObjectInputStream,\n+                ACC_PRIVATE + ACC_FINAL, hostileMethod);\n@@ -512,1 +520,1 @@\n-     * This class generates a method body which calls the lambda implementation\n+     * This method generates a method body which calls the lambda implementation\n@@ -515,20 +523,17 @@\n-    private class ForwardingMethodGenerator extends TypeConvertingMethodAdapter {\n-\n-        ForwardingMethodGenerator(MethodVisitor mv) {\n-            super(mv);\n-        }\n-\n-        void generate(MethodType methodType) {\n-            visitCode();\n-\n-            if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {\n-                visitTypeInsn(NEW, implMethodClassName);\n-                visitInsn(DUP);\n-            }\n-            if (useImplMethodHandle) {\n-                visitLdcInsn(implMethodCondy);\n-            }\n-            for (int i = 0; i < argNames.length; i++) {\n-                visitVarInsn(ALOAD, 0);\n-                visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);\n-            }\n+    Consumer<MethodBuilder> forwardingMethod(MethodType methodType) {\n+        return new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {\n+                    cob.new_(implMethodClassDesc)\n+                       .dup();\n+                }\n+                if (useImplMethodHandle) {\n+                    ConstantPoolBuilder cp = cob.constantPool();\n+                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n+                                                    cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle)));\n+                }\n+                for (int i = 0; i < argNames.length; i++) {\n+                    cob.aload(0)\n+                       .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                }\n@@ -536,1 +541,1 @@\n-            convertArgumentTypes(methodType);\n+                convertArgumentTypes(cob, methodType);\n@@ -538,4 +543,9 @@\n-            if (useImplMethodHandle) {\n-                MethodType mtype = implInfo.getMethodType();\n-                if (implKind != MethodHandleInfo.REF_invokeStatic) {\n-                    mtype = mtype.insertParameterTypes(0, implClass);\n+                if (useImplMethodHandle) {\n+                    MethodType mtype = implInfo.getMethodType();\n+                    if (implKind != MethodHandleInfo.REF_invokeStatic) {\n+                        mtype = mtype.insertParameterTypes(0, implClass);\n+                    }\n+                    cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(mtype));\n+                } else {\n+                    \/\/ Invoke the method we want to forward to\n+                    cob.invoke(invocationOpcode(), implMethodClassDesc, implMethodName, implMethodDesc, implClass.isInterface());\n@@ -543,29 +553,7 @@\n-                visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n-                                \"invokeExact\", mtype.descriptorString(), false);\n-            } else {\n-                \/\/ Invoke the method we want to forward to\n-                visitMethodInsn(invocationOpcode(), implMethodClassName,\n-                                implMethodName, implMethodDesc,\n-                                implClass.isInterface());\n-            }\n-            \/\/ Convert the return value (if any) and return it\n-            \/\/ Note: if adapting from non-void to void, the 'return'\n-            \/\/ instruction will pop the unneeded result\n-            Class<?> implReturnClass = implMethodType.returnType();\n-            Class<?> samReturnClass = methodType.returnType();\n-            convertType(implReturnClass, samReturnClass, samReturnClass);\n-            visitInsn(getReturnOpcode(samReturnClass));\n-            \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS,these arguments ignored\n-            visitMaxs(-1, -1);\n-            visitEnd();\n-        }\n-\n-        private void convertArgumentTypes(MethodType samType) {\n-            int lvIndex = 0;\n-            int samParametersLength = samType.parameterCount();\n-            int captureArity = factoryType.parameterCount();\n-            for (int i = 0; i < samParametersLength; i++) {\n-                Class<?> argType = samType.parameterType(i);\n-                visitVarInsn(getLoadOpcode(argType), lvIndex + 1);\n-                lvIndex += getParameterSize(argType);\n-                convertType(argType, implMethodType.parameterType(captureArity + i), dynamicMethodType.parameterType(i));\n+                \/\/ Convert the return value (if any) and return it\n+                \/\/ Note: if adapting from non-void to void, the 'return'\n+                \/\/ instruction will pop the unneeded result\n+                Class<?> implReturnClass = implMethodType.returnType();\n+                Class<?> samReturnClass = methodType.returnType();\n+                TypeConvertingMethodAdapter.convertType(cob, implReturnClass, samReturnClass, samReturnClass);\n+                cob.return_(TypeKind.from(samReturnClass));\n@@ -573,1 +561,2 @@\n-        }\n+        });\n+    }\n@@ -575,9 +564,7 @@\n-        private int invocationOpcode() throws InternalError {\n-            return switch (implKind) {\n-                case MethodHandleInfo.REF_invokeStatic     -> INVOKESTATIC;\n-                case MethodHandleInfo.REF_newInvokeSpecial -> INVOKESPECIAL;\n-                case MethodHandleInfo.REF_invokeVirtual    -> INVOKEVIRTUAL;\n-                case MethodHandleInfo.REF_invokeInterface  -> INVOKEINTERFACE;\n-                case MethodHandleInfo.REF_invokeSpecial    -> INVOKESPECIAL;\n-                default -> throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n-            };\n+    private void convertArgumentTypes(CodeBuilder cob, MethodType samType) {\n+        int samParametersLength = samType.parameterCount();\n+        int captureArity = factoryType.parameterCount();\n+        for (int i = 0; i < samParametersLength; i++) {\n+            Class<?> argType = samType.parameterType(i);\n+            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n+            TypeConvertingMethodAdapter.convertType(cob, argType, implMethodType.parameterType(captureArity + i), dynamicMethodType.parameterType(i));\n@@ -594,1 +581,1 @@\n-                loadableDescriptors.add(Type.getDescriptor(targetClass));\n+                loadableDescriptors.add(targetClass.descriptorString());\n@@ -605,1 +592,1 @@\n-                    loadableDescriptors.add(Type.getDescriptor(paramType));\n+                    loadableDescriptors.add(paramType.descriptorString());\n@@ -610,1 +597,1 @@\n-                loadableDescriptors.add(Type.getDescriptor(mt.returnType()));\n+                loadableDescriptors.add(mt.returnType().descriptorString());\n@@ -630,14 +617,5 @@\n-        Attribute build() {\n-            return new Attribute(\"LoadableDescriptors\") {\n-                @Override\n-                protected ByteVector write(ClassWriter cw,\n-                                           byte[] code,\n-                                           int len,\n-                                           int maxStack,\n-                                           int maxLocals) {\n-                    ByteVector attr = new ByteVector();\n-                    attr.putShort(loadableDescriptors.size());\n-                    for (String s : loadableDescriptors) {\n-                        attr.putShort(cw.newUTF8(s));\n-                    }\n-                    return attr;\n+        void build(ClassBuilder clb) {\n+            if (!isEmpty()) {\n+                List<Utf8Entry> lds = new ArrayList<Utf8Entry>(loadableDescriptors.size());\n+                for (String ld : loadableDescriptors) {\n+                    lds.add(clb.constantPool().utf8Entry(ld));\n@@ -645,1 +623,2 @@\n-            };\n+                clb.with(LoadableDescriptorsAttribute.of(lds));\n+            }\n@@ -649,7 +628,11 @@\n-    static int getParameterSize(Class<?> c) {\n-        if (c == Void.TYPE) {\n-            return 0;\n-        } else if (c == Long.TYPE || c == Double.TYPE) {\n-            return 2;\n-        }\n-        return 1;\n+    \/**\n+     * Generate LoadableDescriptors attribute if it references any value class\n+     *\/\n+    private void generateLoadableDescriptors(ClassBuilder clb) {\n+        LoadableDescriptorsAttributeBuilder builder = new LoadableDescriptorsAttributeBuilder(targetClass);\n+        builder.add(factoryType)\n+               .add(interfaceMethodType)\n+               .add(implMethodType)\n+               .add(dynamicMethodType)\n+               .add(altMethods)\n+          .build(clb);\n@@ -658,5 +641,9 @@\n-    static int getLoadOpcode(Class<?> c) {\n-        if(c == Void.TYPE) {\n-            throw new InternalError(\"Unexpected void type of load opcode\");\n-        }\n-        return ILOAD + getOpcodeOffset(c);\n+    private Opcode invocationOpcode() throws InternalError {\n+        return switch (implKind) {\n+            case MethodHandleInfo.REF_invokeStatic     -> Opcode.INVOKESTATIC;\n+            case MethodHandleInfo.REF_newInvokeSpecial -> Opcode.INVOKESPECIAL;\n+            case MethodHandleInfo.REF_invokeVirtual    -> Opcode.INVOKEVIRTUAL;\n+            case MethodHandleInfo.REF_invokeInterface  -> Opcode.INVOKEINTERFACE;\n+            case MethodHandleInfo.REF_invokeSpecial    -> Opcode.INVOKESPECIAL;\n+            default -> throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n+        };\n@@ -665,5 +652,2 @@\n-    static int getReturnOpcode(Class<?> c) {\n-        if(c == Void.TYPE) {\n-            return RETURN;\n-        }\n-        return IRETURN + getOpcodeOffset(c);\n+    static ClassDesc implClassDesc(Class<?> cls) {\n+        return cls.isHidden() ? null : ClassDescImpl.ofValidated(cls.descriptorString());\n@@ -672,13 +656,3 @@\n-    private static int getOpcodeOffset(Class<?> c) {\n-        if (c.isPrimitive()) {\n-            if (c == Long.TYPE) {\n-                return 1;\n-            } else if (c == Float.TYPE) {\n-                return 2;\n-            } else if (c == Double.TYPE) {\n-                return 3;\n-            }\n-            return 0;\n-        } else {\n-            return 4;\n-        }\n+    static ClassDesc classDesc(Class<?> cls) {\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+                                 : ClassDescImpl.ofValidated(cls.descriptorString());\n@@ -687,0 +661,7 @@\n+    static MethodTypeDesc methodDesc(MethodType mt) {\n+        var params = new ClassDesc[mt.parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            params[i] = classDesc(mt.parameterType(i));\n+        }\n+        return MethodTypeDescImpl.ofValidated(classDesc(mt.returnType()), params);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":299,"deletions":318,"binary":false,"changes":617,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -38,0 +32,10 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.LambdaForm.BasicType;\n+import java.lang.invoke.LambdaForm.Name;\n+import java.lang.invoke.LambdaForm.NamedFunction;\n@@ -44,0 +48,1 @@\n+import java.util.function.Consumer;\n@@ -45,0 +50,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n@@ -46,2 +53,2 @@\n-import static java.lang.invoke.LambdaForm.BasicType;\n-import static java.lang.invoke.LambdaForm.BasicType.*;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -49,0 +56,1 @@\n+import static java.lang.invoke.LambdaForm.BasicType.*;\n@@ -51,1 +59,1 @@\n-import static java.lang.invoke.MethodHandles.Lookup.*;\n+import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n@@ -60,18 +68,16 @@\n-    private static final String MH      = \"java\/lang\/invoke\/MethodHandle\";\n-    private static final String MHI     = \"java\/lang\/invoke\/MethodHandleImpl\";\n-    private static final String LF      = \"java\/lang\/invoke\/LambdaForm\";\n-    private static final String LFN     = \"java\/lang\/invoke\/LambdaForm$Name\";\n-    private static final String CLS     = \"java\/lang\/Class\";\n-    private static final String OBJ     = \"java\/lang\/Object\";\n-    private static final String OBJARY  = \"[Ljava\/lang\/Object;\";\n-\n-    private static final String LOOP_CLAUSES = MHI + \"$LoopClauses\";\n-    private static final String MHARY2       = \"[[L\" + MH + \";\";\n-    private static final String MH_SIG       = \"L\" + MH + \";\";\n-\n-\n-    private static final String LF_SIG  = \"L\" + LF + \";\";\n-    private static final String LFN_SIG = \"L\" + LFN + \";\";\n-    private static final String LL_SIG  = \"(L\" + OBJ + \";)L\" + OBJ + \";\";\n-    private static final String LLV_SIG = \"(L\" + OBJ + \";L\" + OBJ + \";)V\";\n-    private static final String CLASS_PREFIX = LF + \"$\";\n+    private static final ClassDesc CD_CasesHolder = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n+    private static final ClassDesc CD_DirectMethodHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n+    private static final ClassDesc CD_MethodHandleImpl = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n+    private static final ClassDesc CD_LambdaForm = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_LambdaForm_Name = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n+    private static final ClassDesc CD_LoopClauses = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n+    private static final ClassDesc CD_Object_array  = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+    private static final ClassDesc CD_MethodHandle_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n+    private static final ClassDesc CD_MethodHandle_array2 = ClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n+\n+    private static final MethodTypeDesc MTD_boolean_Object = MethodTypeDescImpl.ofValidated(CD_boolean, CD_Object);\n+    private static final MethodTypeDesc MTD_Object_int = MethodTypeDescImpl.ofValidated(CD_Object, CD_int);\n+    private static final MethodTypeDesc MTD_Object_Class = MethodTypeDescImpl.ofValidated(CD_Object, CD_Class);\n+    private static final MethodTypeDesc MTD_Object_Object = MethodTypeDescImpl.ofValidated(CD_Object, CD_Object);\n+\n+    private static final String CLASS_PREFIX = \"java\/lang\/invoke\/LambdaForm$\";\n@@ -80,0 +86,15 @@\n+    \/\/ Static builders to avoid lambdas\n+    private static final Consumer<FieldBuilder> STATIC_FINAL_FIELD = new Consumer<FieldBuilder>() {\n+        @Override\n+        public void accept(FieldBuilder fb) {\n+            fb.withFlags(ACC_STATIC | ACC_FINAL);\n+        }\n+    };\n+\n+    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n+        @Override\n+        public void accept(MethodBuilder mb) {\n+            mb.withCode(code);\n+        }\n+    };\n+\n@@ -81,1 +102,1 @@\n-    static final String INVOKER_SUPER_NAME = OBJ;\n+    static final ClassDesc INVOKER_SUPER_DESC = CD_Object;\n@@ -86,0 +107,1 @@\n+    private final ClassDesc classDesc;\n@@ -95,3 +117,0 @@\n-    \/** ASM bytecode generation. *\/\n-    private ClassWriter cw;\n-    private MethodVisitor mv;\n@@ -100,4 +119,0 @@\n-    \/** Single element internal class name lookup cache. *\/\n-    private Class<?> lastClass;\n-    private String lastInternalName;\n-\n@@ -129,0 +144,1 @@\n+        this.classDesc = ClassDesc.ofInternalName(className);\n@@ -191,1 +207,1 @@\n-        final String desc;\n+        final ClassDesc desc;\n@@ -194,1 +210,1 @@\n-        ClassData(String name, String desc, Object value) {\n+        ClassData(String name, ClassDesc desc, Object value) {\n@@ -207,1 +223,1 @@\n-        String desc;\n+        ClassDesc desc;\n@@ -209,1 +225,1 @@\n-            desc = \"Ljava\/lang\/Class;\";\n+            desc = CD_Class;\n@@ -211,1 +227,1 @@\n-            desc = MH_SIG;\n+            desc = CD_MethodHandle;\n@@ -213,1 +229,1 @@\n-            desc = LF_SIG;\n+            desc = CD_LambdaForm;\n@@ -215,1 +231,1 @@\n-            desc = \"Ljava\/lang\/Object;\";\n+            desc = CD_Object;\n@@ -234,10 +250,0 @@\n-    private static String debugString(Object arg) {\n-        if (arg instanceof MethodHandle mh) {\n-            MemberName member = mh.internalMemberName();\n-            if (member != null)\n-                return member.toString();\n-            return mh.debugString();\n-        }\n-        return arg.toString();\n-    }\n-\n@@ -268,13 +274,14 @@\n-    private ClassWriter classFilePrologue() {\n-        final int NOT_ACC_PUBLIC = 0;  \/\/ not ACC_PUBLIC\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        setClassWriter(cw);\n-        cw.visit(CLASSFILE_VERSION, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n-                className, null, INVOKER_SUPER_NAME, null);\n-        cw.visitSource(SOURCE_PREFIX + name, null);\n-        return cw;\n-    }\n-\n-    private void methodPrologue() {\n-        String invokerDesc = invokerType.toMethodDescriptorString();\n-        mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);\n+    private byte[] classFileSetup(Consumer<? super ClassBuilder> config) {\n+        try {\n+            return ClassFile.of().build(classDesc, new Consumer<>() {\n+                @Override\n+                public void accept(ClassBuilder clb) {\n+                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                       .withSuperclass(INVOKER_SUPER_DESC)\n+                       .with(SourceFileAttribute.of(clb.constantPool().utf8Entry(SOURCE_PREFIX + name)));\n+                    config.accept(clb);\n+                }\n+            });\n+        } catch (RuntimeException e) {\n+            throw new BytecodeGenerationException(e);\n+        }\n@@ -283,6 +290,3 @@\n-    \/**\n-     * Tear down class file generation.\n-     *\/\n-    private void methodEpilogue() {\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n+    private void methodSetup(ClassBuilder clb, Consumer<? super MethodBuilder> config) {\n+        var invokerDesc = methodDesc(invokerType);\n+        clb.withMethod(invokerName, invokerDesc, ACC_STATIC, config);\n@@ -321,1 +325,1 @@\n-    static void clinit(ClassWriter cw, String className, List<ClassData> classData) {\n+    static void clinit(ClassBuilder clb, ClassDesc classDesc, List<ClassData> classData) {\n@@ -327,75 +331,12 @@\n-            FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);\n-            fv.visitEnd();\n-        }\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitLdcInsn(Type.getType(\"L\" + className + \";\"));\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\",\n-                           \"classData\", \"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", false);\n-        if (classData.size() == 1) {\n-            ClassData p = classData.get(0);\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n-            mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n-        } else {\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, \"java\/util\/List\");\n-            mv.visitVarInsn(Opcodes.ASTORE, 0);\n-            int index = 0;\n-            for (ClassData p : classData) {\n-                \/\/ initialize the static field\n-                mv.visitVarInsn(Opcodes.ALOAD, 0);\n-                emitIconstInsn(mv, index++);\n-                mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java\/util\/List\",\n-                                   \"get\", \"(I)Ljava\/lang\/Object;\", true);\n-                mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n-                mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n-            }\n-        }\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(2, 1);\n-        mv.visitEnd();\n-    }\n-\n-    \/*\n-     * Low-level emit helpers.\n-     *\/\n-    private void emitConst(Object con) {\n-        if (con == null) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-            return;\n-        }\n-        if (con instanceof Integer) {\n-            emitIconstInsn((int) con);\n-            return;\n-        }\n-        if (con instanceof Byte) {\n-            emitIconstInsn((byte)con);\n-            return;\n-        }\n-        if (con instanceof Short) {\n-            emitIconstInsn((short)con);\n-            return;\n-        }\n-        if (con instanceof Character) {\n-            emitIconstInsn((char)con);\n-            return;\n-        }\n-        if (con instanceof Long) {\n-            long x = (long) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2L);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Float) {\n-            float x = (float) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 2) {\n-                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n+            clb.withField(p.name, p.desc, STATIC_FINAL_FIELD);\n+        }\n+\n+        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                cob.loadConstant(classDesc)\n+                   .invokestatic(CD_MethodHandles, \"classData\", MTD_Object_Class);\n+                if (classData.size() == 1) {\n+                    ClassData p = classData.get(0);\n+                    cob.checkcast(p.desc)\n+                       .putstatic(classDesc, p.name, p.desc);\n@@ -403,15 +344,12 @@\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2F);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Double) {\n-            double x = (double) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2D);\n+                    cob.checkcast(CD_List)\n+                       .astore(0);\n+                    int index = 0;\n+                    var listGet = cob.constantPool().interfaceMethodRefEntry(CD_List, \"get\", MTD_Object_int);\n+                    for (ClassData p : classData) {\n+                        \/\/ initialize the static field\n+                        cob.aload(0)\n+                           .loadConstant(index++)\n+                           .invokeinterface(listGet)\n+                           .checkcast(p.desc)\n+                           .putstatic(classDesc, p.name, p.desc);\n+                    }\n@@ -419,1 +357,1 @@\n-                return;\n+                cob.return_();\n@@ -421,31 +359,1 @@\n-        }\n-        if (con instanceof Boolean) {\n-            emitIconstInsn((boolean) con ? 1 : 0);\n-            return;\n-        }\n-        \/\/ fall through:\n-        mv.visitLdcInsn(con);\n-    }\n-\n-    private void emitIconstInsn(final int cst) {\n-        emitIconstInsn(mv, cst);\n-    }\n-\n-    private static void emitIconstInsn(MethodVisitor mv, int cst) {\n-        if (cst >= -1 && cst <= 5) {\n-            mv.visitInsn(Opcodes.ICONST_0 + cst);\n-        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-        } else {\n-            mv.visitLdcInsn(cst);\n-        }\n-    }\n-\n-    \/*\n-     * NOTE: These load\/store methods use the localsMap to find the correct index!\n-     *\/\n-    private void emitLoadInsn(BasicType type, int index) {\n-        int opcode = loadInsnOpcode(type);\n-        mv.visitVarInsn(opcode, localsMap[index]);\n+        }));\n@@ -454,12 +362,2 @@\n-    private int loadInsnOpcode(BasicType type) throws InternalError {\n-        return switch (type) {\n-            case I_TYPE -> Opcodes.ILOAD;\n-            case J_TYPE -> Opcodes.LLOAD;\n-            case F_TYPE -> Opcodes.FLOAD;\n-            case D_TYPE -> Opcodes.DLOAD;\n-            case L_TYPE -> Opcodes.ALOAD;\n-            default -> throw new InternalError(\"unknown type: \" + type);\n-        };\n-    }\n-    private void emitAloadInsn(int index) {\n-        emitLoadInsn(L_TYPE, index);\n+    private void emitLoadInsn(CodeBuilder cob, TypeKind type, int index) {\n+        cob.loadLocal(type, localsMap[index]);\n@@ -468,49 +366,2 @@\n-    private void emitStoreInsn(BasicType type, int index) {\n-        int opcode = storeInsnOpcode(type);\n-        mv.visitVarInsn(opcode, localsMap[index]);\n-    }\n-\n-    private int storeInsnOpcode(BasicType type) throws InternalError {\n-        return switch (type) {\n-            case I_TYPE -> Opcodes.ISTORE;\n-            case J_TYPE -> Opcodes.LSTORE;\n-            case F_TYPE -> Opcodes.FSTORE;\n-            case D_TYPE -> Opcodes.DSTORE;\n-            case L_TYPE -> Opcodes.ASTORE;\n-            default -> throw new InternalError(\"unknown type: \" + type);\n-        };\n-    }\n-    private void emitAstoreInsn(int index) {\n-        emitStoreInsn(L_TYPE, index);\n-    }\n-\n-    private byte arrayTypeCode(Wrapper elementType) {\n-        return (byte) switch (elementType) {\n-            case BOOLEAN -> Opcodes.T_BOOLEAN;\n-            case BYTE    -> Opcodes.T_BYTE;\n-            case CHAR    -> Opcodes.T_CHAR;\n-            case SHORT   -> Opcodes.T_SHORT;\n-            case INT     -> Opcodes.T_INT;\n-            case LONG    -> Opcodes.T_LONG;\n-            case FLOAT   -> Opcodes.T_FLOAT;\n-            case DOUBLE  -> Opcodes.T_DOUBLE;\n-            case OBJECT  -> 0; \/\/ in place of Opcodes.T_OBJECT\n-            default -> throw new InternalError();\n-        };\n-    }\n-\n-    private int arrayInsnOpcode(byte tcode, int aaop) throws InternalError {\n-        assert(aaop == Opcodes.AASTORE || aaop == Opcodes.AALOAD);\n-        int xas = switch (tcode) {\n-            case Opcodes.T_BOOLEAN -> Opcodes.BASTORE;\n-            case Opcodes.T_BYTE    -> Opcodes.BASTORE;\n-            case Opcodes.T_CHAR    -> Opcodes.CASTORE;\n-            case Opcodes.T_SHORT   -> Opcodes.SASTORE;\n-            case Opcodes.T_INT     -> Opcodes.IASTORE;\n-            case Opcodes.T_LONG    -> Opcodes.LASTORE;\n-            case Opcodes.T_FLOAT   -> Opcodes.FASTORE;\n-            case Opcodes.T_DOUBLE  -> Opcodes.DASTORE;\n-            case 0                 -> Opcodes.AASTORE;\n-            default -> throw new InternalError();\n-        };\n-        return xas - Opcodes.AASTORE + aaop;\n+    private void emitStoreInsn(CodeBuilder cob, TypeKind type, int index) {\n+        cob.storeLocal(type, localsMap[index]);\n@@ -524,5 +375,2 @@\n-    private void emitBoxing(Wrapper wrapper) {\n-        String owner = \"java\/lang\/\" + wrapper.wrapperType().getSimpleName();\n-        String name  = \"valueOf\";\n-        String desc  = \"(\" + wrapper.basicTypeChar() + \")L\" + owner + \";\";\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc, false);\n+    private void emitBoxing(CodeBuilder cob, TypeKind tk) {\n+        TypeConvertingMethodAdapter.box(cob, tk);\n@@ -536,6 +384,9 @@\n-    private void emitUnboxing(Wrapper wrapper) {\n-        String owner = \"java\/lang\/\" + wrapper.wrapperType().getSimpleName();\n-        String name  = wrapper.primitiveSimpleName() + \"Value\";\n-        String desc  = \"()\" + wrapper.basicTypeChar();\n-        emitReferenceCast(wrapper.wrapperType(), null);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc, false);\n+    private void emitUnboxing(CodeBuilder cob, TypeKind target) {\n+        switch (target) {\n+            case BooleanType -> emitReferenceCast(cob, Boolean.class, null);\n+            case CharType -> emitReferenceCast(cob, Character.class, null);\n+            case ByteType, DoubleType, FloatType, IntType, LongType, ShortType ->\n+                emitReferenceCast(cob, Number.class, null);\n+            default -> {}\n+        }\n+        TypeConvertingMethodAdapter.unbox(cob, target);\n@@ -552,1 +403,1 @@\n-    private void emitImplicitConversion(BasicType ptype, Class<?> pclass, Object arg) {\n+    private void emitImplicitConversion(CodeBuilder cob, BasicType ptype, Class<?> pclass, Object arg) {\n@@ -560,1 +411,1 @@\n-                        emitReferenceCast(Object.class, arg);\n+                        emitReferenceCast(cob, Object.class, arg);\n@@ -563,1 +414,1 @@\n-                emitReferenceCast(pclass, arg);\n+                emitReferenceCast(cob, pclass, arg);\n@@ -567,1 +418,1 @@\n-                    emitPrimCast(ptype.basicTypeWrapper(), Wrapper.forPrimitiveType(pclass));\n+                    emitPrimCast(cob, ptype.basicTypeKind(), TypeKind.from(pclass));\n@@ -585,1 +436,1 @@\n-    private void emitReferenceCast(Class<?> cls, Object arg) {\n+    private void emitReferenceCast(CodeBuilder cob, Class<?> cls, Object arg) {\n@@ -597,2 +448,2 @@\n-            String sig = getInternalName(cls);\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, sig);\n+            ClassDesc sig = classDesc(cls);\n+            cob.checkcast(sig);\n@@ -600,3 +451,3 @@\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(cls), \"Ljava\/lang\/Class;\");\n-            mv.visitInsn(Opcodes.SWAP);\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, \"cast\", LL_SIG, false);\n+            cob.getstatic(classDesc, classData(cls), CD_Class)\n+               .swap()\n+               .invokevirtual(CD_Class, \"cast\", MTD_Object_Object);\n@@ -604,1 +455,1 @@\n-                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);\n+                cob.checkcast(CD_Object_array);\n@@ -606,1 +457,1 @@\n-                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);\n+                cob.checkcast(CD_Object);\n@@ -609,2 +460,2 @@\n-            mv.visitInsn(Opcodes.DUP);\n-            emitAstoreInsn(writeBack.index());\n+            cob.dup();\n+            emitStoreInsn(cob, TypeKind.ReferenceType, writeBack.index());\n@@ -614,30 +465,0 @@\n-    \/**\n-     * Emits an actual return instruction conforming to the given return type.\n-     *\/\n-    private void emitReturnInsn(BasicType type) {\n-        int opcode = switch (type) {\n-            case I_TYPE -> Opcodes.IRETURN;\n-            case J_TYPE -> Opcodes.LRETURN;\n-            case F_TYPE -> Opcodes.FRETURN;\n-            case D_TYPE -> Opcodes.DRETURN;\n-            case L_TYPE -> Opcodes.ARETURN;\n-            case V_TYPE -> Opcodes.RETURN;\n-            default -> throw new InternalError(\"unknown return type: \" + type);\n-        };\n-        mv.visitInsn(opcode);\n-    }\n-\n-    private String getInternalName(Class<?> c) {\n-        if (c == Object.class)             return OBJ;\n-        else if (c == Object[].class)      return OBJARY;\n-        else if (c == Class.class)         return CLS;\n-        else if (c == MethodHandle.class)  return MH;\n-        assert(VerifyAccess.ensureTypeVisible(c, Object.class)) : c.getName();\n-\n-        if (c == lastClass) {\n-            return lastInternalName;\n-        }\n-        lastClass = c;\n-        return lastInternalName = c.getName().replace('.', '\/');\n-    }\n-\n@@ -716,1 +537,1 @@\n-    private boolean checkActualReceiver() {\n+    private boolean checkActualReceiver(CodeBuilder cob) {\n@@ -718,3 +539,3 @@\n-        mv.visitInsn(Opcodes.DUP);\n-        mv.visitVarInsn(Opcodes.ALOAD, localsMap[0]);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, MHI, \"assertSame\", LLV_SIG, false);\n+        cob.dup()\n+           .aload(0)\n+           .invokestatic(CD_MethodHandleImpl, \"assertSame\", MethodTypeDescImpl.ofValidated(CD_void, CD_Object, CD_Object));\n@@ -724,24 +545,5 @@\n-    static String className(String cn) {\n-        assert checkClassName(cn): \"Class not found: \" + cn;\n-        return cn;\n-    }\n-\n-    static boolean checkClassName(String cn) {\n-        Type tp = Type.getType(cn);\n-        \/\/ additional sanity so only valid \"L;\" descriptors work\n-        if (tp.getSort() != Type.OBJECT) {\n-            return false;\n-        }\n-        try {\n-            Class<?> c = Class.forName(tp.getClassName(), false, null);\n-            return true;\n-        } catch (ClassNotFoundException e) {\n-            return false;\n-        }\n-    }\n-\n-    static final String      DONTINLINE_SIG = className(\"Ljdk\/internal\/vm\/annotation\/DontInline;\");\n-    static final String     FORCEINLINE_SIG = className(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\");\n-    static final String          HIDDEN_SIG = className(\"Ljdk\/internal\/vm\/annotation\/Hidden;\");\n-    static final String INJECTEDPROFILE_SIG = className(\"Ljava\/lang\/invoke\/InjectedProfile;\");\n-    static final String     LF_COMPILED_SIG = className(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\");\n+    static final Annotation DONTINLINE      = Annotation.of(ClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n+    static final Annotation FORCEINLINE     = Annotation.of(ClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n+    static final Annotation HIDDEN          = Annotation.of(ClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n+    static final Annotation INJECTEDPROFILE = Annotation.of(ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n+    static final Annotation LF_COMPILED     = Annotation.of(ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n@@ -753,6 +555,9 @@\n-        classFilePrologue();\n-        addMethod();\n-        clinit(cw, className, classData);\n-        bogusMethod(lambdaForm);\n-\n-        return toByteArray();\n+        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                addMethod(clb);\n+                clinit(clb, classDesc, classData);\n+                bogusMethod(clb, lambdaForm);\n+            }\n+        });\n+        return classFile;\n@@ -761,3 +566,4 @@\n-    void setClassWriter(ClassWriter cw) {\n-        this.cw = cw;\n-    }\n+    void addMethod(ClassBuilder clb) {\n+        methodSetup(clb, new Consumer<MethodBuilder>() {\n+            @Override\n+            public void accept(MethodBuilder mb) {\n@@ -765,2 +571,1 @@\n-    void addMethod() {\n-        methodPrologue();\n+                List<Annotation> annotations = new ArrayList<>(3);\n@@ -768,2 +573,2 @@\n-        \/\/ Suppress this method in backtraces displayed to the user.\n-        mv.visitAnnotation(HIDDEN_SIG, true);\n+                \/\/ Suppress this method in backtraces displayed to the user.\n+                annotations.add(HIDDEN);\n@@ -771,2 +576,2 @@\n-        \/\/ Mark this method as a compiled LambdaForm\n-        mv.visitAnnotation(LF_COMPILED_SIG, true);\n+                \/\/ Mark this method as a compiled LambdaForm\n+                annotations.add(LF_COMPILED);\n@@ -774,6 +579,23 @@\n-        if (lambdaForm.forceInline) {\n-            \/\/ Force inlining of this invoker method.\n-            mv.visitAnnotation(FORCEINLINE_SIG, true);\n-        } else {\n-            mv.visitAnnotation(DONTINLINE_SIG, true);\n-        }\n+                if (lambdaForm.forceInline) {\n+                    \/\/ Force inlining of this invoker method.\n+                    annotations.add(FORCEINLINE);\n+                } else {\n+                    annotations.add(DONTINLINE);\n+                }\n+                mb.accept(RuntimeVisibleAnnotationsAttribute.of(annotations));\n+\n+                classData(lambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n+\n+                mb.withCode(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        if (lambdaForm.customized != null) {\n+                            \/\/ Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute\n+                            \/\/ receiver MethodHandle (at slot #0) with an embedded constant and use it instead.\n+                            \/\/ It enables more efficient code generation in some situations, since embedded constants\n+                            \/\/ are compile-time constants for JIT compiler.\n+                            cob.getstatic(classDesc, classData(lambdaForm.customized), CD_MethodHandle)\n+                               .checkcast(CD_MethodHandle);\n+                            assert(checkActualReceiver(cob)); \/\/ expects MethodHandle on top of the stack\n+                            cob.astore(0);\n+                        }\n@@ -781,12 +603,72 @@\n-        classData(lambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n-\n-        if (lambdaForm.customized != null) {\n-            \/\/ Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute\n-            \/\/ receiver MethodHandle (at slot #0) with an embedded constant and use it instead.\n-            \/\/ It enables more efficient code generation in some situations, since embedded constants\n-            \/\/ are compile-time constants for JIT compiler.\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(lambdaForm.customized), MH_SIG);\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, MH);\n-            assert(checkActualReceiver()); \/\/ expects MethodHandle on top of the stack\n-            mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);\n-        }\n+                        \/\/ iterate over the form's names, generating bytecode instructions for each\n+                        \/\/ start iterating at the first name following the arguments\n+                        Name onStack = null;\n+                        for (int i = lambdaForm.arity; i < lambdaForm.names.length; i++) {\n+                            Name name = lambdaForm.names[i];\n+\n+                            emitStoreResult(cob, onStack);\n+                            onStack = name;  \/\/ unless otherwise modified below\n+                            MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();\n+                            switch (intr) {\n+                                case SELECT_ALTERNATIVE:\n+                                    assert lambdaForm.isSelectAlternative(i);\n+                                    if (PROFILE_GWT) {\n+                                        assert(name.arguments[0] instanceof Name n &&\n+                                                n.refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n+                                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(INJECTEDPROFILE)));\n+                                    }\n+                                    onStack = emitSelectAlternative(cob, name, lambdaForm.names[i+1]);\n+                                    i++;  \/\/ skip MH.invokeBasic of the selectAlternative result\n+                                    continue;\n+                                case GUARD_WITH_CATCH:\n+                                    assert lambdaForm.isGuardWithCatch(i);\n+                                    onStack = emitGuardWithCatch(cob, i);\n+                                    i += 2; \/\/ jump to the end of GWC idiom\n+                                    continue;\n+                                case TRY_FINALLY:\n+                                    assert lambdaForm.isTryFinally(i);\n+                                    onStack = emitTryFinally(cob, i);\n+                                    i += 2; \/\/ jump to the end of the TF idiom\n+                                    continue;\n+                                case TABLE_SWITCH:\n+                                    assert lambdaForm.isTableSwitch(i);\n+                                    int numCases = (Integer) name.function.intrinsicData();\n+                                    onStack = emitTableSwitch(cob, i, numCases);\n+                                    i += 2; \/\/ jump to the end of the TS idiom\n+                                    continue;\n+                                case LOOP:\n+                                    assert lambdaForm.isLoop(i);\n+                                    onStack = emitLoop(cob, i);\n+                                    i += 2; \/\/ jump to the end of the LOOP idiom\n+                                    continue;\n+                                case ARRAY_LOAD:\n+                                    emitArrayLoad(cob, name);\n+                                    continue;\n+                                case ARRAY_STORE:\n+                                    emitArrayStore(cob, name);\n+                                    continue;\n+                                case ARRAY_LENGTH:\n+                                    emitArrayLength(cob, name);\n+                                    continue;\n+                                case IDENTITY:\n+                                    assert(name.arguments.length == 1);\n+                                    emitPushArguments(cob, name, 0);\n+                                    continue;\n+                                case ZERO:\n+                                    assert(name.arguments.length == 0);\n+                                    cob.loadConstant((ConstantDesc)name.type.basicTypeWrapper().zero());\n+                                    continue;\n+                                case NONE:\n+                                    \/\/ no intrinsic associated\n+                                    break;\n+                                default:\n+                                    throw newInternalError(\"Unknown intrinsic: \"+intr);\n+                            }\n+\n+                            MemberName member = name.function.member();\n+                            if (isStaticallyInvocable(member)) {\n+                                emitStaticInvoke(cob, member, name);\n+                            } else {\n+                                emitInvoke(cob, name);\n+                            }\n+                        }\n@@ -794,16 +676,2 @@\n-        \/\/ iterate over the form's names, generating bytecode instructions for each\n-        \/\/ start iterating at the first name following the arguments\n-        Name onStack = null;\n-        for (int i = lambdaForm.arity; i < lambdaForm.names.length; i++) {\n-            Name name = lambdaForm.names[i];\n-\n-            emitStoreResult(onStack);\n-            onStack = name;  \/\/ unless otherwise modified below\n-            MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();\n-            switch (intr) {\n-                case SELECT_ALTERNATIVE:\n-                    assert lambdaForm.isSelectAlternative(i);\n-                    if (PROFILE_GWT) {\n-                        assert(name.arguments[0] instanceof Name n &&\n-                                n.refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n-                        mv.visitAnnotation(INJECTEDPROFILE_SIG, true);\n+                        \/\/ return statement\n+                        emitReturn(cob, onStack);\n@@ -811,53 +679,1 @@\n-                    onStack = emitSelectAlternative(name, lambdaForm.names[i+1]);\n-                    i++;  \/\/ skip MH.invokeBasic of the selectAlternative result\n-                    continue;\n-                case GUARD_WITH_CATCH:\n-                    assert lambdaForm.isGuardWithCatch(i);\n-                    onStack = emitGuardWithCatch(i);\n-                    i += 2; \/\/ jump to the end of GWC idiom\n-                    continue;\n-                case TRY_FINALLY:\n-                    assert lambdaForm.isTryFinally(i);\n-                    onStack = emitTryFinally(i);\n-                    i += 2; \/\/ jump to the end of the TF idiom\n-                    continue;\n-                case TABLE_SWITCH:\n-                    assert lambdaForm.isTableSwitch(i);\n-                    int numCases = (Integer) name.function.intrinsicData();\n-                    onStack = emitTableSwitch(i, numCases);\n-                    i += 2; \/\/ jump to the end of the TS idiom\n-                    continue;\n-                case LOOP:\n-                    assert lambdaForm.isLoop(i);\n-                    onStack = emitLoop(i);\n-                    i += 2; \/\/ jump to the end of the LOOP idiom\n-                    continue;\n-                case ARRAY_LOAD:\n-                    emitArrayLoad(name);\n-                    continue;\n-                case ARRAY_STORE:\n-                    emitArrayStore(name);\n-                    continue;\n-                case ARRAY_LENGTH:\n-                    emitArrayLength(name);\n-                    continue;\n-                case IDENTITY:\n-                    assert(name.arguments.length == 1);\n-                    emitPushArguments(name, 0);\n-                    continue;\n-                case ZERO:\n-                    assert(name.arguments.length == 0);\n-                    emitConst(name.type.basicTypeWrapper().zero());\n-                    continue;\n-                case NONE:\n-                    \/\/ no intrinsic associated\n-                    break;\n-                default:\n-                    throw newInternalError(\"Unknown intrinsic: \"+intr);\n-            }\n-\n-            MemberName member = name.function.member();\n-            if (isStaticallyInvocable(member)) {\n-                emitStaticInvoke(member, name);\n-            } else {\n-                emitInvoke(name);\n+                });\n@@ -865,18 +681,1 @@\n-        }\n-\n-        \/\/ return statement\n-        emitReturn(onStack);\n-\n-        methodEpilogue();\n-    }\n-\n-    \/*\n-     * @throws BytecodeGenerationException if something goes wrong when\n-     *         generating the byte code\n-     *\/\n-    private byte[] toByteArray() {\n-        try {\n-            return cw.toByteArray();\n-        } catch (RuntimeException e) {\n-            throw new BytecodeGenerationException(e);\n-        }\n+        });\n@@ -895,3 +694,10 @@\n-    void emitArrayLoad(Name name)   { emitArrayOp(name, Opcodes.AALOAD);      }\n-    void emitArrayStore(Name name)  { emitArrayOp(name, Opcodes.AASTORE);     }\n-    void emitArrayLength(Name name) { emitArrayOp(name, Opcodes.ARRAYLENGTH); }\n+    void emitArrayLoad(CodeBuilder cob, Name name)   {\n+        Class<?> elementType = name.function.methodType().parameterType(0).getComponentType();\n+        assert elementType != null;\n+        emitPushArguments(cob, name, 0);\n+        if (elementType.isPrimitive()) {\n+            cob.arrayLoad(TypeKind.from(elementType));\n+        } else {\n+            cob.aaload();\n+        }\n+    }\n@@ -899,2 +705,1 @@\n-    void emitArrayOp(Name name, int arrayOpcode) {\n-        assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;\n+    void emitArrayStore(CodeBuilder cob, Name name)  {\n@@ -903,4 +708,5 @@\n-        emitPushArguments(name, 0);\n-        if (arrayOpcode != Opcodes.ARRAYLENGTH && elementType.isPrimitive()) {\n-            Wrapper w = Wrapper.forPrimitiveType(elementType);\n-            arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);\n+        emitPushArguments(cob, name, 0);\n+        if (elementType.isPrimitive()) {\n+            cob.arrayStore(TypeKind.from(elementType));\n+        } else {\n+            cob.aastore();\n@@ -908,1 +714,6 @@\n-        mv.visitInsn(arrayOpcode);\n+    }\n+\n+    void emitArrayLength(CodeBuilder cob, Name name) {\n+        assert name.function.methodType().parameterType(0).isArray();\n+        emitPushArguments(cob, name, 0);\n+        cob.arraylength();\n@@ -914,1 +725,1 @@\n-    void emitInvoke(Name name) {\n+    void emitInvoke(CodeBuilder cob, Name name) {\n@@ -920,2 +731,2 @@\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(target), MH_SIG);\n-            emitReferenceCast(MethodHandle.class, target);\n+            cob.getstatic(classDesc, classData(target), CD_MethodHandle);\n+            emitReferenceCast(cob, MethodHandle.class, target);\n@@ -924,4 +735,4 @@\n-            emitAloadInsn(0);\n-            emitReferenceCast(MethodHandle.class, null);\n-            mv.visitFieldInsn(Opcodes.GETFIELD, MH, \"form\", LF_SIG);\n-            mv.visitFieldInsn(Opcodes.GETFIELD, LF, \"names\", LFN_SIG);\n+            cob.aload(0);\n+            emitReferenceCast(cob, MethodHandle.class, null);\n+            cob.getfield(CD_MethodHandle, \"form\", CD_LambdaForm)\n+               .getfield(CD_LambdaForm, \"names\", CD_LambdaForm_Name);\n@@ -932,1 +743,1 @@\n-        emitPushArguments(name, 0);\n+        emitPushArguments(cob, name, 0);\n@@ -936,1 +747,1 @@\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n@@ -1023,2 +834,2 @@\n-    void emitStaticInvoke(Name name) {\n-        emitStaticInvoke(name.function.member(), name);\n+    void emitStaticInvoke(CodeBuilder cob, Name name) {\n+        emitStaticInvoke(cob, name.function.member(), name);\n@@ -1030,1 +841,1 @@\n-    void emitStaticInvoke(MemberName member, Name name) {\n+    void emitStaticInvoke(CodeBuilder cob, MemberName member, Name name) {\n@@ -1033,1 +844,1 @@\n-        String cname = getInternalName(defc);\n+        ClassDesc cdesc = classDesc(defc);\n@@ -1035,1 +846,0 @@\n-        String mtype;\n@@ -1046,1 +856,1 @@\n-        emitPushArguments(name, 0);\n+        emitPushArguments(cob, name, 0);\n@@ -1050,3 +860,3 @@\n-            mtype = member.getMethodType().toMethodDescriptorString();\n-            mv.visitMethodInsn(refKindOpcode(refKind), cname, mname, mtype,\n-                               member.getDeclaringClass().isInterface());\n+            var methodTypeDesc = methodDesc(member.getMethodType());\n+            cob.invoke(refKindOpcode(refKind), cdesc, mname, methodTypeDesc,\n+                                  member.getDeclaringClass().isInterface());\n@@ -1054,2 +864,2 @@\n-            mtype = MethodType.toFieldDescriptorString(member.getFieldType());\n-            mv.visitFieldInsn(refKindOpcode(refKind), cname, mname, mtype);\n+            var fieldTypeDesc = classDesc(member.getFieldType());\n+            cob.fieldAccess(refKindOpcode(refKind), cdesc, mname, fieldTypeDesc);\n@@ -1067,1 +877,1 @@\n-    int refKindOpcode(byte refKind) {\n+    Opcode refKindOpcode(byte refKind) {\n@@ -1069,8 +879,8 @@\n-        case REF_invokeVirtual:      return Opcodes.INVOKEVIRTUAL;\n-        case REF_invokeStatic:       return Opcodes.INVOKESTATIC;\n-        case REF_invokeSpecial:      return Opcodes.INVOKESPECIAL;\n-        case REF_invokeInterface:    return Opcodes.INVOKEINTERFACE;\n-        case REF_getField:           return Opcodes.GETFIELD;\n-        case REF_putField:           return Opcodes.PUTFIELD;\n-        case REF_getStatic:          return Opcodes.GETSTATIC;\n-        case REF_putStatic:          return Opcodes.PUTSTATIC;\n+        case REF_invokeVirtual:      return Opcode.INVOKEVIRTUAL;\n+        case REF_invokeStatic:       return Opcode.INVOKESTATIC;\n+        case REF_invokeSpecial:      return Opcode.INVOKESPECIAL;\n+        case REF_invokeInterface:    return Opcode.INVOKEINTERFACE;\n+        case REF_getField:           return Opcode.GETFIELD;\n+        case REF_putField:           return Opcode.PUTFIELD;\n+        case REF_getStatic:          return Opcode.GETSTATIC;\n+        case REF_putStatic:          return Opcode.PUTSTATIC;\n@@ -1092,1 +902,1 @@\n-    private Name emitSelectAlternative(Name selectAlternativeName, Name invokeBasicName) {\n+    private Name emitSelectAlternative(CodeBuilder cob, Name selectAlternativeName, Name invokeBasicName) {\n@@ -1097,2 +907,2 @@\n-        Label L_fallback = new Label();\n-        Label L_done     = new Label();\n+        Label L_fallback = cob.newLabel();\n+        Label L_done     = cob.newLabel();\n@@ -1101,1 +911,1 @@\n-        emitPushArgument(selectAlternativeName, 0);\n+        emitPushArgument(cob, selectAlternativeName, 0);\n@@ -1104,1 +914,1 @@\n-        mv.visitJumpInsn(Opcodes.IFEQ, L_fallback);\n+        cob.ifeq(L_fallback);\n@@ -1108,3 +918,3 @@\n-        emitPushArgument(selectAlternativeName, 1);  \/\/ get 2nd argument of selectAlternative\n-        emitAstoreInsn(receiver.index());  \/\/ store the MH in the receiver slot\n-        emitStaticInvoke(invokeBasicName);\n+        emitPushArgument(cob, selectAlternativeName, 1);  \/\/ get 2nd argument of selectAlternative\n+        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStaticInvoke(cob, invokeBasicName);\n@@ -1113,1 +923,1 @@\n-        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n+        cob.goto_w(L_done);\n@@ -1116,1 +926,1 @@\n-        mv.visitLabel(L_fallback);\n+        cob.labelBinding(L_fallback);\n@@ -1120,3 +930,3 @@\n-        emitPushArgument(selectAlternativeName, 2);  \/\/ get 3rd argument of selectAlternative\n-        emitAstoreInsn(receiver.index());  \/\/ store the MH in the receiver slot\n-        emitStaticInvoke(invokeBasicName);\n+        emitPushArgument(cob, selectAlternativeName, 2);  \/\/ get 3rd argument of selectAlternative\n+        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStaticInvoke(cob, invokeBasicName);\n@@ -1125,1 +935,1 @@\n-        mv.visitLabel(L_done);\n+        cob.labelBinding(L_done);\n@@ -1152,1 +962,1 @@\n-    private Name emitGuardWithCatch(int pos) {\n+    private Name emitGuardWithCatch(CodeBuilder cob, int pos) {\n@@ -1157,4 +967,4 @@\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_handler = new Label();\n-        Label L_done = new Label();\n+        Label L_startBlock = cob.newLabel();\n+        Label L_endBlock = cob.newLabel();\n+        Label L_handler = cob.newLabel();\n+        Label L_done = cob.newLabel();\n@@ -1167,1 +977,1 @@\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, \"java\/lang\/Throwable\");\n+        cob.exceptionCatch(L_startBlock, L_endBlock, L_handler, CD_Throwable);\n@@ -1170,1 +980,1 @@\n-        mv.visitLabel(L_startBlock);\n+        cob.labelBinding(L_startBlock);\n@@ -1172,5 +982,5 @@\n-        emitPushArgument(invoker, 0);\n-        emitPushArguments(args, 1); \/\/ skip 1st argument: method handle\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n-        mv.visitLabel(L_endBlock);\n-        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n+        emitPushArgument(cob, invoker, 0);\n+        emitPushArguments(cob, args, 1); \/\/ skip 1st argument: method handle\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n+        cob.labelBinding(L_endBlock);\n+        cob.goto_w(L_done);\n@@ -1179,1 +989,1 @@\n-        mv.visitLabel(L_handler);\n+        cob.labelBinding(L_handler);\n@@ -1182,1 +992,1 @@\n-        mv.visitInsn(Opcodes.DUP);\n+        cob.dup();\n@@ -1184,5 +994,5 @@\n-        emitPushArgument(invoker, 1);\n-        mv.visitInsn(Opcodes.SWAP);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java\/lang\/Class\", \"isInstance\", \"(Ljava\/lang\/Object;)Z\", false);\n-        Label L_rethrow = new Label();\n-        mv.visitJumpInsn(Opcodes.IFEQ, L_rethrow);\n+        emitPushArgument(cob, invoker, 1);\n+        cob.swap();\n+        cob.invokevirtual(CD_Class, \"isInstance\", MTD_boolean_Object);\n+        Label L_rethrow = cob.newLabel();\n+        cob.ifeq(L_rethrow);\n@@ -1192,3 +1002,3 @@\n-        emitPushArgument(invoker, 2);\n-        mv.visitInsn(Opcodes.SWAP);\n-        emitPushArguments(args, 1); \/\/ skip 1st argument: method handle\n+        emitPushArgument(cob, invoker, 2);\n+        cob.swap();\n+        emitPushArguments(cob, args, 1); \/\/ skip 1st argument: method handle\n@@ -1196,2 +1006,2 @@\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", catcherType.basicType().toMethodDescriptorString(), false);\n-        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(catcherType.basicType()));\n+        cob.goto_w(L_done);\n@@ -1199,2 +1009,2 @@\n-        mv.visitLabel(L_rethrow);\n-        mv.visitInsn(Opcodes.ATHROW);\n+        cob.labelBinding(L_rethrow);\n+        cob.athrow();\n@@ -1202,1 +1012,1 @@\n-        mv.visitLabel(L_done);\n+        cob.labelBinding(L_done);\n@@ -1267,1 +1077,1 @@\n-    private Name emitTryFinally(int pos) {\n+    private Name emitTryFinally(CodeBuilder cob, int pos) {\n@@ -1272,4 +1082,4 @@\n-        Label lFrom = new Label();\n-        Label lTo = new Label();\n-        Label lCatch = new Label();\n-        Label lDone = new Label();\n+        Label lFrom = cob.newLabel();\n+        Label lTo = cob.newLabel();\n+        Label lCatch = cob.newLabel();\n+        Label lDone = cob.newLabel();\n@@ -1288,1 +1098,1 @@\n-        String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();\n+        MethodTypeDesc cleanupDesc = methodDesc(cleanupType.basicType());\n@@ -1291,1 +1101,1 @@\n-        mv.visitTryCatchBlock(lFrom, lTo, lCatch, \"java\/lang\/Throwable\");\n+        cob.exceptionCatch(lFrom, lTo, lCatch, CD_Throwable);\n@@ -1294,5 +1104,5 @@\n-        mv.visitLabel(lFrom);\n-        emitPushArgument(invoker, 0); \/\/ load target\n-        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n-        mv.visitLabel(lTo);\n+        cob.labelBinding(lFrom);\n+        emitPushArgument(cob, invoker, 0); \/\/ load target\n+        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n+        cob.labelBinding(lTo);\n@@ -1303,1 +1113,1 @@\n-            emitStoreInsn(basicReturnType, index);\n+            emitStoreInsn(cob, basicReturnType.basicTypeKind(), index);\n@@ -1305,2 +1115,2 @@\n-        emitPushArgument(invoker, 1); \/\/ load cleanup\n-        mv.visitInsn(Opcodes.ACONST_NULL);\n+        emitPushArgument(cob, invoker, 1); \/\/ load cleanup\n+        cob.loadConstant(null);\n@@ -1308,1 +1118,1 @@\n-            emitLoadInsn(basicReturnType, index);\n+            emitLoadInsn(cob, basicReturnType.basicTypeKind(), index);\n@@ -1310,3 +1120,3 @@\n-        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", cleanupDesc, false);\n-        mv.visitJumpInsn(Opcodes.GOTO, lDone);\n+        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc);\n+        cob.goto_w(lDone);\n@@ -1315,2 +1125,2 @@\n-        mv.visitLabel(lCatch);\n-        mv.visitInsn(Opcodes.DUP);\n+        cob.labelBinding(lCatch);\n+        cob.dup();\n@@ -1319,2 +1129,2 @@\n-        emitPushArgument(invoker, 1); \/\/ load cleanup\n-        mv.visitInsn(Opcodes.SWAP);\n+        emitPushArgument(cob, invoker, 1); \/\/ load cleanup\n+        cob.swap();\n@@ -1322,1 +1132,1 @@\n-            emitZero(BasicType.basicType(returnType)); \/\/ load default for result\n+            emitZero(cob, BasicType.basicType(returnType)); \/\/ load default for result\n@@ -1324,2 +1134,2 @@\n-        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", cleanupDesc, false);\n+        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc);\n@@ -1327,1 +1137,1 @@\n-            emitPopInsn(basicReturnType);\n+            emitPopInsn(cob, basicReturnType);\n@@ -1329,1 +1139,1 @@\n-        mv.visitInsn(Opcodes.ATHROW);\n+        cob.athrow();\n@@ -1332,1 +1142,1 @@\n-        mv.visitLabel(lDone);\n+        cob.labelBinding(lDone);\n@@ -1337,8 +1147,4 @@\n-    private void emitPopInsn(BasicType type) {\n-        mv.visitInsn(popInsnOpcode(type));\n-    }\n-\n-    private static int popInsnOpcode(BasicType type) {\n-        return switch (type) {\n-            case I_TYPE, F_TYPE, L_TYPE -> Opcodes.POP;\n-            case J_TYPE, D_TYPE         -> Opcodes.POP2;\n+    private void emitPopInsn(CodeBuilder cob, BasicType type) {\n+        switch (type) {\n+            case I_TYPE, F_TYPE, L_TYPE -> cob.pop();\n+            case J_TYPE, D_TYPE -> cob.pop2();\n@@ -1346,1 +1152,1 @@\n-        };\n+        }\n@@ -1349,1 +1155,1 @@\n-    private Name emitTableSwitch(int pos, int numCases) {\n+    private Name emitTableSwitch(CodeBuilder cob, int pos, int numCases) {\n@@ -1358,1 +1164,1 @@\n-        String caseDescriptor = caseType.basicType().toMethodDescriptorString();\n+        MethodTypeDesc caseDescriptor = methodDesc(caseType.basicType());\n@@ -1360,3 +1166,2 @@\n-        emitPushArgument(invoker, 2); \/\/ push cases\n-        mv.visitFieldInsn(Opcodes.GETFIELD, \"java\/lang\/invoke\/MethodHandleImpl$CasesHolder\", \"cases\",\n-            \"[Ljava\/lang\/invoke\/MethodHandle;\");\n+        emitPushArgument(cob, invoker, 2); \/\/ push cases\n+        cob.getfield(CD_CasesHolder, \"cases\", CD_MethodHandle_array);\n@@ -1364,1 +1169,1 @@\n-        emitStoreInsn(L_TYPE, casesLocal);\n+        emitStoreInsn(cob, TypeKind.ReferenceType, casesLocal);\n@@ -1366,5 +1171,5 @@\n-        Label endLabel = new Label();\n-        Label defaultLabel = new Label();\n-        Label[] caseLabels = new Label[numCases];\n-        for (int i = 0; i < caseLabels.length; i++) {\n-            caseLabels[i] = new Label();\n+        Label endLabel = cob.newLabel();\n+        Label defaultLabel = cob.newLabel();\n+        List<SwitchCase> cases = new ArrayList<>(numCases);\n+        for (int i = 0; i < numCases; i++) {\n+            cases.add(SwitchCase.of(i, cob.newLabel()));\n@@ -1373,2 +1178,2 @@\n-        emitPushArgument(invoker, 0); \/\/ push switch input\n-        mv.visitTableSwitchInsn(0, numCases - 1, defaultLabel, caseLabels);\n+        emitPushArgument(cob, invoker, 0); \/\/ push switch input\n+        cob.tableswitch(0, numCases - 1, defaultLabel, cases);\n@@ -1376,5 +1181,5 @@\n-        mv.visitLabel(defaultLabel);\n-        emitPushArgument(invoker, 1); \/\/ push default handle\n-        emitPushArguments(args, 1); \/\/ again, skip collector\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n-        mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n+        cob.labelBinding(defaultLabel);\n+        emitPushArgument(cob, invoker, 1); \/\/ push default handle\n+        emitPushArguments(cob, args, 1); \/\/ again, skip collector\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n+        cob.goto_(endLabel);\n@@ -1383,1 +1188,1 @@\n-            mv.visitLabel(caseLabels[i]);\n+            cob.labelBinding(cases.get(i).target());\n@@ -1385,3 +1190,3 @@\n-            emitLoadInsn(L_TYPE, casesLocal);\n-            emitIconstInsn(i);\n-            mv.visitInsn(Opcodes.AALOAD);\n+            emitLoadInsn(cob, TypeKind.ReferenceType, casesLocal);\n+            cob.loadConstant(i);\n+            cob.aaload();\n@@ -1390,2 +1195,2 @@\n-            emitPushArguments(args, 1); \/\/ again, skip collector\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n+            emitPushArguments(cob, args, 1); \/\/ again, skip collector\n+            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n@@ -1393,1 +1198,1 @@\n-            mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n+            cob.goto_(endLabel);\n@@ -1396,1 +1201,1 @@\n-        mv.visitLabel(endLabel);\n+        cob.labelBinding(endLabel);\n@@ -1483,1 +1288,1 @@\n-    private Name emitLoop(int pos) {\n+    private Name emitLoop(CodeBuilder cob, int pos) {\n@@ -1491,2 +1296,3 @@\n-        Class<?>[] loopLocalStateTypes = Stream.of(loopClauseTypes).\n-                filter(bt -> bt != BasicType.V_TYPE).map(BasicType::basicTypeClass).toArray(Class<?>[]::new);\n+        Class<?>[] loopLocalStateTypes = Stream.of(loopClauseTypes)\n+                .filter(bt -> bt != BasicType.V_TYPE)\n+                .map(BasicType::basicTypeClass).toArray(Class<?>[]::new);\n@@ -1516,2 +1322,2 @@\n-        Label lLoop = new Label();\n-        Label lDone = new Label();\n+        Label lLoop = cob.newLabel();\n+        Label lDone = cob.newLabel();\n@@ -1521,3 +1327,3 @@\n-        emitPushArgument(MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, LOOP_CLAUSES, \"clauses\", MHARY2);\n-        emitAstoreInsn(clauseDataIndex);\n+        emitPushArgument(cob, MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);\n+        cob.getfield(CD_LoopClauses, \"clauses\", CD_MethodHandle_array2);\n+        emitStoreInsn(cob, TypeKind.ReferenceType, clauseDataIndex);\n@@ -1528,1 +1334,1 @@\n-            emitLoopHandleInvoke(invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,\n@@ -1531,1 +1337,1 @@\n-                emitStoreInsn(BasicType.basicType(cInitType.returnType()), firstLoopStateIndex + state);\n+                emitStoreInsn(cob, BasicType.basicType(cInitType.returnType()).basicTypeKind(), firstLoopStateIndex + state);\n@@ -1537,1 +1343,1 @@\n-        mv.visitLabel(lLoop);\n+        cob.labelBinding(lLoop);\n@@ -1540,1 +1346,1 @@\n-            lNext = new Label();\n+            lNext = cob.newLabel();\n@@ -1546,1 +1352,1 @@\n-            emitLoopHandleInvoke(invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,\n@@ -1549,1 +1355,1 @@\n-                emitStoreInsn(BasicType.basicType(stepType.returnType()), firstLoopStateIndex + state);\n+                emitStoreInsn(cob, BasicType.basicType(stepType.returnType()).basicTypeKind(), firstLoopStateIndex + state);\n@@ -1554,1 +1360,1 @@\n-            emitLoopHandleInvoke(invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,\n@@ -1556,1 +1362,1 @@\n-            mv.visitJumpInsn(Opcodes.IFNE, lNext);\n+            cob.ifne(lNext);\n@@ -1559,1 +1365,1 @@\n-            emitLoopHandleInvoke(invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,\n@@ -1561,1 +1367,1 @@\n-            mv.visitJumpInsn(Opcodes.GOTO, lDone);\n+            cob.goto_w(lDone);\n@@ -1564,1 +1370,1 @@\n-            mv.visitLabel(lNext);\n+            cob.labelBinding(lNext);\n@@ -1567,1 +1373,1 @@\n-        mv.visitJumpInsn(Opcodes.GOTO, lLoop);\n+        cob.goto_w(lLoop);\n@@ -1570,1 +1376,1 @@\n-        mv.visitLabel(lDone);\n+        cob.labelBinding(lDone);\n@@ -1591,1 +1397,1 @@\n-    private void emitLoopHandleInvoke(Name holder, int handles, int clause, Name args, boolean pushLocalState,\n+    private void emitLoopHandleInvoke(CodeBuilder cob, Name holder, int handles, int clause, Name args, boolean pushLocalState,\n@@ -1595,3 +1401,3 @@\n-        emitPushClauseArray(clauseDataSlot, handles);\n-        emitIconstInsn(clause);\n-        mv.visitInsn(Opcodes.AALOAD);\n+        emitPushClauseArray(cob, clauseDataSlot, handles);\n+        cob.loadConstant(clause);\n+        cob.aaload();\n@@ -1601,1 +1407,1 @@\n-                emitLoadInsn(BasicType.basicType(loopLocalStateTypes[s]), firstLoopStateSlot + s);\n+                emitLoadInsn(cob, BasicType.basicType(loopLocalStateTypes[s]).basicTypeKind(), firstLoopStateSlot + s);\n@@ -1605,2 +1411,2 @@\n-        emitPushArguments(args, 1);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.toMethodDescriptorString(), false);\n+        emitPushArguments(cob, args, 1);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type));\n@@ -1609,4 +1415,4 @@\n-    private void emitPushClauseArray(int clauseDataSlot, int which) {\n-        emitAloadInsn(clauseDataSlot);\n-        emitIconstInsn(which - 1);\n-        mv.visitInsn(Opcodes.AALOAD);\n+    private void emitPushClauseArray(CodeBuilder cob, int clauseDataSlot, int which) {\n+        emitLoadInsn(cob, TypeKind.ReferenceType, clauseDataSlot);\n+        cob.loadConstant(which - 1);\n+        cob.aaload();\n@@ -1615,7 +1421,7 @@\n-    private void emitZero(BasicType type) {\n-        mv.visitInsn(switch (type) {\n-            case I_TYPE -> Opcodes.ICONST_0;\n-            case J_TYPE -> Opcodes.LCONST_0;\n-            case F_TYPE -> Opcodes.FCONST_0;\n-            case D_TYPE -> Opcodes.DCONST_0;\n-            case L_TYPE -> Opcodes.ACONST_NULL;\n+    private void emitZero(CodeBuilder cob, BasicType type) {\n+        switch (type) {\n+            case I_TYPE -> cob.iconst_0();\n+            case J_TYPE -> cob.lconst_0();\n+            case F_TYPE -> cob.fconst_0();\n+            case D_TYPE -> cob.dconst_0();\n+            case L_TYPE -> cob.aconst_null();\n@@ -1623,1 +1429,1 @@\n-        });\n+        };\n@@ -1626,1 +1432,1 @@\n-    private void emitPushArguments(Name args, int start) {\n+    private void emitPushArguments(CodeBuilder cob, Name args, int start) {\n@@ -1629,1 +1435,1 @@\n-            emitPushArgument(type.parameterType(i), args.arguments[i]);\n+            emitPushArgument(cob, type.parameterType(i), args.arguments[i]);\n@@ -1633,1 +1439,1 @@\n-    private void emitPushArgument(Name name, int paramIndex) {\n+    private void emitPushArgument(CodeBuilder cob, Name name, int paramIndex) {\n@@ -1636,1 +1442,1 @@\n-        emitPushArgument(ptype, arg);\n+        emitPushArgument(cob, ptype, arg);\n@@ -1639,1 +1445,1 @@\n-    private void emitPushArgument(Class<?> ptype, Object arg) {\n+    private void emitPushArgument(CodeBuilder cob, Class<?> ptype, Object arg) {\n@@ -1642,6 +1448,4 @@\n-            emitLoadInsn(n.type, n.index());\n-            emitImplicitConversion(n.type, ptype, n);\n-        } else if (arg == null && bptype == L_TYPE) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-        } else if (arg instanceof String && bptype == L_TYPE) {\n-            mv.visitLdcInsn(arg);\n+            emitLoadInsn(cob, n.type.basicTypeKind(), n.index());\n+            emitImplicitConversion(cob, n.type, ptype, n);\n+        } else if ((arg == null || arg instanceof String) && bptype == L_TYPE) {\n+            cob.loadConstant((ConstantDesc)arg);\n@@ -1650,1 +1454,1 @@\n-                emitConst(arg);\n+                cob.loadConstant((ConstantDesc)arg);\n@@ -1652,2 +1456,2 @@\n-                mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(arg), \"Ljava\/lang\/Object;\");\n-                emitImplicitConversion(L_TYPE, ptype, arg);\n+                cob.getstatic(classDesc, classData(arg), CD_Object);\n+                emitImplicitConversion(cob, L_TYPE, ptype, arg);\n@@ -1661,1 +1465,1 @@\n-    private void emitStoreResult(Name name) {\n+    private void emitStoreResult(CodeBuilder cob, Name name) {\n@@ -1664,1 +1468,1 @@\n-            emitStoreInsn(name.type, name.index());\n+            emitStoreInsn(cob, name.type.basicTypeKind(), name.index());\n@@ -1671,1 +1475,1 @@\n-    private void emitReturn(Name onStack) {\n+    private void emitReturn(CodeBuilder cob, Name onStack) {\n@@ -1678,1 +1482,1 @@\n-            mv.visitInsn(Opcodes.RETURN);\n+            cob.return_();\n@@ -1685,1 +1489,1 @@\n-                emitLoadInsn(rtype, lambdaForm.result);\n+                emitLoadInsn(cob, rtype.basicTypeKind(), lambdaForm.result);\n@@ -1688,1 +1492,1 @@\n-            emitImplicitConversion(rtype, rclass, rn);\n+            emitImplicitConversion(cob, rtype, rclass, rn);\n@@ -1691,1 +1495,1 @@\n-            emitReturnInsn(rtype);\n+            cob.return_(rtype.basicTypeKind());\n@@ -1698,1 +1502,1 @@\n-    private void emitPrimCast(Wrapper from, Wrapper to) {\n+    private void emitPrimCast(CodeBuilder cob, TypeKind from, TypeKind to) {\n@@ -1711,74 +1515,4 @@\n-        if (from == to) {\n-            \/\/ no cast required, should be dead code anyway\n-            return;\n-        }\n-        if (from.isSubwordOrInt()) {\n-            \/\/ cast from {byte,short,char,int} to anything\n-            emitI2X(to);\n-        } else {\n-            \/\/ cast from {long,float,double} to anything\n-            if (to.isSubwordOrInt()) {\n-                \/\/ cast to {byte,short,char,int}\n-                emitX2I(from);\n-                if (to.bitWidth() < 32) {\n-                    \/\/ targets other than int require another conversion\n-                    emitI2X(to);\n-                }\n-            } else {\n-                \/\/ cast to {long,float,double} - this is verbose\n-                boolean error = false;\n-                switch (from) {\n-                    case LONG -> {\n-                        switch (to) {\n-                            case FLOAT  -> mv.visitInsn(Opcodes.L2F);\n-                            case DOUBLE -> mv.visitInsn(Opcodes.L2D);\n-                            default -> error = true;\n-                        }\n-                    }\n-                    case FLOAT -> {\n-                        switch (to) {\n-                            case LONG   -> mv.visitInsn(Opcodes.F2L);\n-                            case DOUBLE -> mv.visitInsn(Opcodes.F2D);\n-                            default -> error = true;\n-                        }\n-                    }\n-                    case DOUBLE -> {\n-                        switch (to) {\n-                            case LONG  -> mv.visitInsn(Opcodes.D2L);\n-                            case FLOAT -> mv.visitInsn(Opcodes.D2F);\n-                            default -> error = true;\n-                        }\n-                    }\n-                    default -> error = true;\n-                }\n-                if (error) {\n-                    throw new IllegalStateException(\"unhandled prim cast: \" + from + \"2\" + to);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void emitI2X(Wrapper type) {\n-        switch (type) {\n-        case BYTE:    mv.visitInsn(Opcodes.I2B);  break;\n-        case SHORT:   mv.visitInsn(Opcodes.I2S);  break;\n-        case CHAR:    mv.visitInsn(Opcodes.I2C);  break;\n-        case INT:     \/* naught *\/                break;\n-        case LONG:    mv.visitInsn(Opcodes.I2L);  break;\n-        case FLOAT:   mv.visitInsn(Opcodes.I2F);  break;\n-        case DOUBLE:  mv.visitInsn(Opcodes.I2D);  break;\n-        case BOOLEAN:\n-            \/\/ For compatibility with ValueConversions and explicitCastArguments:\n-            mv.visitInsn(Opcodes.ICONST_1);\n-            mv.visitInsn(Opcodes.IAND);\n-            break;\n-        default:   throw new InternalError(\"unknown type: \" + type);\n-        }\n-    }\n-\n-    private void emitX2I(Wrapper type) {\n-        switch (type) {\n-            case LONG -> mv.visitInsn(Opcodes.L2I);\n-            case FLOAT -> mv.visitInsn(Opcodes.F2I);\n-            case DOUBLE -> mv.visitInsn(Opcodes.D2I);\n-            default -> throw new InternalError(\"unknown type: \" + type);\n+        if (from != to && from != TypeKind.BooleanType) try {\n+            cob.conversion(from, to);\n+        } catch (IllegalArgumentException e) {\n+            throw new IllegalStateException(\"unhandled prim cast: \" + from + \"2\" + to);\n@@ -1801,22 +1535,52 @@\n-        classFilePrologue();\n-        methodPrologue();\n-\n-        \/\/ Suppress this method in backtraces displayed to the user.\n-        mv.visitAnnotation(HIDDEN_SIG, true);\n-\n-        \/\/ Don't inline the interpreter entry.\n-        mv.visitAnnotation(DONTINLINE_SIG, true);\n-\n-        \/\/ create parameter array\n-        emitIconstInsn(invokerType.parameterCount());\n-        mv.visitTypeInsn(Opcodes.ANEWARRAY, \"java\/lang\/Object\");\n-\n-        \/\/ fill parameter array\n-        for (int i = 0; i < invokerType.parameterCount(); i++) {\n-            Class<?> ptype = invokerType.parameterType(i);\n-            mv.visitInsn(Opcodes.DUP);\n-            emitIconstInsn(i);\n-            emitLoadInsn(basicType(ptype), i);\n-            \/\/ box if primitive type\n-            if (ptype.isPrimitive()) {\n-                emitBoxing(Wrapper.forPrimitiveType(ptype));\n+        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                methodSetup(clb, new Consumer<MethodBuilder>() {\n+                    @Override\n+                    public void accept(MethodBuilder mb) {\n+\n+                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(\n+                                HIDDEN,    \/\/ Suppress this method in backtraces displayed to the user.\n+                                DONTINLINE \/\/ Don't inline the interpreter entry.\n+                        )));\n+\n+                        mb.withCode(new Consumer<CodeBuilder>() {\n+                            @Override\n+                            public void accept(CodeBuilder cob) {\n+                                \/\/ create parameter array\n+                                cob.loadConstant(invokerType.parameterCount());\n+                                cob.anewarray(CD_Object);\n+\n+                                \/\/ fill parameter array\n+                                for (int i = 0; i < invokerType.parameterCount(); i++) {\n+                                    Class<?> ptype = invokerType.parameterType(i);\n+                                    cob.dup();\n+                                    cob.loadConstant(i);\n+                                    emitLoadInsn(cob, basicType(ptype).basicTypeKind(), i);\n+                                    \/\/ box if primitive type\n+                                    if (ptype.isPrimitive()) {\n+                                        emitBoxing(cob, TypeKind.from(ptype));\n+                                    }\n+                                    cob.aastore();\n+                                }\n+                                \/\/ invoke\n+                                cob.aload(0);\n+                                cob.getfield(CD_MethodHandle, \"form\", CD_LambdaForm);\n+                                cob.swap();  \/\/ swap form and array; avoid local variable\n+                                cob.invokevirtual(CD_LambdaForm, \"interpretWithArguments\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object_array));\n+\n+                                \/\/ maybe unbox\n+                                Class<?> rtype = invokerType.returnType();\n+                                TypeKind rtypeK = TypeKind.from(rtype);\n+                                if (rtype.isPrimitive() && rtype != void.class) {\n+                                    emitUnboxing(cob, rtypeK);\n+                                }\n+\n+                                \/\/ return statement\n+                                cob.return_(rtypeK);\n+                            }\n+                        });\n+                    }\n+                });\n+                clinit(clb, classDesc, classData);\n+                bogusMethod(clb, invokerType);\n@@ -1824,22 +1588,2 @@\n-            mv.visitInsn(Opcodes.AASTORE);\n-        }\n-        \/\/ invoke\n-        emitAloadInsn(0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, MH, \"form\", \"Ljava\/lang\/invoke\/LambdaForm;\");\n-        mv.visitInsn(Opcodes.SWAP);  \/\/ swap form and array; avoid local variable\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, \"interpretWithArguments\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-\n-        \/\/ maybe unbox\n-        Class<?> rtype = invokerType.returnType();\n-        if (rtype.isPrimitive() && rtype != void.class) {\n-            emitUnboxing(Wrapper.forPrimitiveType(rtype));\n-        }\n-\n-        \/\/ return statement\n-        emitReturnInsn(basicType(rtype));\n-\n-        methodEpilogue();\n-        clinit(cw, className, classData);\n-        bogusMethod(invokerType);\n-\n-        return cw.toByteArray();\n+        });\n+        return classFile;\n@@ -1860,25 +1604,59 @@\n-        classFilePrologue();\n-        methodPrologue();\n-\n-        \/\/ Suppress this method in backtraces displayed to the user.\n-        mv.visitAnnotation(HIDDEN_SIG, true);\n-\n-        \/\/ Force inlining of this invoker method.\n-        mv.visitAnnotation(FORCEINLINE_SIG, true);\n-\n-        \/\/ Load receiver\n-        emitAloadInsn(0);\n-\n-        \/\/ Load arguments from array\n-        for (int i = 0; i < dstType.parameterCount(); i++) {\n-            emitAloadInsn(1);\n-            emitIconstInsn(i);\n-            mv.visitInsn(Opcodes.AALOAD);\n-\n-            \/\/ Maybe unbox\n-            Class<?> dptype = dstType.parameterType(i);\n-            if (dptype.isPrimitive()) {\n-                Wrapper dstWrapper = Wrapper.forBasicType(dptype);\n-                Wrapper srcWrapper = dstWrapper.isSubwordOrInt() ? Wrapper.INT : dstWrapper;  \/\/ narrow subword from int\n-                emitUnboxing(srcWrapper);\n-                emitPrimCast(srcWrapper, dstWrapper);\n+        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                methodSetup(clb, new Consumer<MethodBuilder>() {\n+                    @Override\n+                    public void accept(MethodBuilder mb) {\n+\n+                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(\n+                                HIDDEN,    \/\/ Suppress this method in backtraces displayed to the user.\n+                                FORCEINLINE \/\/ Force inlining of this invoker method.\n+                        )));\n+\n+                        mb.withCode(new Consumer<CodeBuilder>() {\n+                            @Override\n+                            public void accept(CodeBuilder cob) {\n+                                \/\/ Load receiver\n+                                cob.aload(0);\n+\n+                                \/\/ Load arguments from array\n+                                for (int i = 0; i < dstType.parameterCount(); i++) {\n+                                    cob.aload(1);\n+                                    cob.loadConstant(i);\n+                                    cob.aaload();\n+\n+                                    \/\/ Maybe unbox\n+                                    Class<?> dptype = dstType.parameterType(i);\n+                                    if (dptype.isPrimitive()) {\n+                                        TypeKind dstTK = TypeKind.from(dptype);\n+                                        TypeKind srcTK = dstTK.asLoadable();\n+                                        emitUnboxing(cob, srcTK);\n+                                        emitPrimCast(cob, srcTK, dstTK);\n+                                    }\n+                                }\n+\n+                                \/\/ Invoke\n+                                MethodTypeDesc targetDesc = methodDesc(dstType.basicType());\n+                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", targetDesc);\n+\n+                                \/\/ Box primitive types\n+                                Class<?> rtype = dstType.returnType();\n+                                if (rtype != void.class && rtype.isPrimitive()) {\n+                                    TypeKind srcTK = TypeKind.from(rtype);\n+                                    TypeKind dstTK = srcTK.asLoadable();\n+                                    \/\/ boolean casts not allowed\n+                                    emitPrimCast(cob, srcTK, dstTK);\n+                                    emitBoxing(cob, dstTK);\n+                                }\n+\n+                                \/\/ If the return type is void we return a null reference.\n+                                if (rtype == void.class) {\n+                                    cob.aconst_null();\n+                                }\n+                               cob.areturn();  \/\/ NOTE: NamedFunction invokers always return a reference value.\n+                            }\n+                        });\n+                    }\n+                });\n+                clinit(clb, classDesc, classData);\n+                bogusMethod(clb, dstType);\n@@ -1886,27 +1664,2 @@\n-        }\n-\n-        \/\/ Invoke\n-        String targetDesc = dstType.basicType().toMethodDescriptorString();\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", targetDesc, false);\n-\n-        \/\/ Box primitive types\n-        Class<?> rtype = dstType.returnType();\n-        if (rtype != void.class && rtype.isPrimitive()) {\n-            Wrapper srcWrapper = Wrapper.forBasicType(rtype);\n-            Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  \/\/ widen subword to int\n-            \/\/ boolean casts not allowed\n-            emitPrimCast(srcWrapper, dstWrapper);\n-            emitBoxing(dstWrapper);\n-        }\n-\n-        \/\/ If the return type is void we return a null reference.\n-        if (rtype == void.class) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-        }\n-        emitReturnInsn(L_TYPE);  \/\/ NOTE: NamedFunction invokers always return a reference value.\n-\n-        methodEpilogue();\n-        clinit(cw, className, classData);\n-        bogusMethod(dstType);\n-\n-        return cw.toByteArray();\n+        });\n+        return classFile;\n@@ -1919,1 +1672,1 @@\n-    private void bogusMethod(Object os) {\n+    private void bogusMethod(ClassBuilder clb, Object os) {\n@@ -1921,6 +1674,24 @@\n-            mv = cw.visitMethod(Opcodes.ACC_STATIC, \"dummy\", \"()V\", null, null);\n-            mv.visitLdcInsn(os.toString());\n-            mv.visitInsn(Opcodes.POP);\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            clb.withMethod(\"dummy\", MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cob) {\n+                    cob.loadConstant(os.toString());\n+                    cob.pop();\n+                    cob.return_();\n+                }\n+            }));\n+        }\n+    }\n+\n+    static ClassDesc classDesc(Class<?> cls) {\n+\/\/        assert(VerifyAccess.isTypeVisible(cls, Object.class)) : cls.getName();\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+             : cls == MethodHandle.class ? CD_MethodHandle\n+             : cls == DirectMethodHandle.class ? CD_DirectMethodHandle\n+             : cls == Object.class ? CD_Object\n+             : ClassDescImpl.ofValidated(cls.descriptorString());\n+    }\n+\n+    static MethodTypeDesc methodDesc(MethodType mt) {\n+        var params = new ClassDesc[mt.parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            params[i] = classDesc(mt.parameterType(i));\n@@ -1928,0 +1699,1 @@\n+        return MethodTypeDescImpl.ofValidated(classDesc(mt.returnType()), params);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":613,"deletions":841,"binary":false,"changes":1454,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.TypeKind;\n@@ -140,6 +141,6 @@\n-        L_TYPE('L', Object.class, Wrapper.OBJECT),  \/\/ all reference types\n-        I_TYPE('I', int.class,    Wrapper.INT),\n-        J_TYPE('J', long.class,   Wrapper.LONG),\n-        F_TYPE('F', float.class,  Wrapper.FLOAT),\n-        D_TYPE('D', double.class, Wrapper.DOUBLE),  \/\/ all primitive types\n-        V_TYPE('V', void.class,   Wrapper.VOID);    \/\/ not valid in all contexts\n+        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.ReferenceType), \/\/ all reference types\n+        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.IntType),\n+        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LongType),\n+        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FloatType),\n+        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DoubleType),  \/\/ all primitive types\n+        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VoidType);    \/\/ not valid in all contexts\n@@ -156,0 +157,1 @@\n+        final TypeKind btKind;\n@@ -157,1 +159,1 @@\n-        private BasicType(char btChar, Class<?> btClass, Wrapper wrapper) {\n+        private BasicType(char btChar, Class<?> btClass, Wrapper wrapper, TypeKind typeKind) {\n@@ -161,0 +163,1 @@\n+            this.btKind = typeKind;\n@@ -172,0 +175,3 @@\n+        TypeKind basicTypeKind() {\n+            return btKind;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n@@ -31,1 +33,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n@@ -42,0 +43,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n@@ -59,0 +62,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -65,1 +70,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n@@ -1038,2 +1042,4 @@\n-        private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);\n-        private static MethodType REFLECT_INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object.class, Object[].class);\n+\n+        private static final ClassDesc CD_Object_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+        private static final MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);\n+        private static final MethodType REFLECT_INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object.class, Object[].class);\n@@ -1253,2 +1259,0 @@\n-            ClassWriter cw = new ClassWriter(0);\n-\n@@ -1268,33 +1272,19 @@\n-            cw.visit(CLASSFILE_VERSION, ACC_PRIVATE | ACC_SUPER, \"InjectedInvoker\", null, \"java\/lang\/Object\", null);\n-            {\n-                var mv = cw.visitMethod(ACC_STATIC, \"invoke_V\",\n-                        \"(Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n-                        null, null);\n-\n-                mv.visitCode();\n-                mv.visitVarInsn(ALOAD, 0);\n-                mv.visitVarInsn(ALOAD, 1);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n-                        \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-                mv.visitInsn(ARETURN);\n-                mv.visitMaxs(2, 2);\n-                mv.visitEnd();\n-\n-                cw.visitEnd();\n-            }\n-\n-            {\n-                var mv = cw.visitMethod(ACC_STATIC, \"reflect_invoke_V\",\n-                        \"(Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n-                        null, null);\n-                mv.visitCode();\n-                mv.visitVarInsn(ALOAD, 0);\n-                mv.visitVarInsn(ALOAD, 1);\n-                mv.visitVarInsn(ALOAD, 2);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n-                        \"(Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-                mv.visitInsn(ARETURN);\n-                mv.visitMaxs(3, 3);\n-                mv.visitEnd();\n-            }\n-            return cw.toByteArray();\n+            return ClassFile.of().build(ClassDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n+                    .withFlags(ACC_PRIVATE | ACC_SUPER)\n+                    .withMethodBody(\n+                        \"invoke_V\",\n+                        MethodTypeDescImpl.ofValidated(CD_Object, CD_MethodHandle, CD_Object_array),\n+                        ACC_STATIC,\n+                        cob -> cob.aload(0)\n+                                  .aload(1)\n+                                  .invokevirtual(CD_MethodHandle, \"invokeExact\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object_array))\n+                                  .areturn())\n+                    .withMethodBody(\n+                        \"reflect_invoke_V\",\n+                        MethodTypeDescImpl.ofValidated(CD_Object, CD_MethodHandle, CD_Object, CD_Object_array),\n+                        ACC_STATIC,\n+                        cob -> cob.aload(0)\n+                                  .aload(1)\n+                                  .aload(2)\n+                                  .invokevirtual(CD_MethodHandle, \"invokeExact\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object, CD_Object_array))\n+                                  .areturn()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":29,"deletions":39,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -45,0 +42,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -47,0 +45,1 @@\n+import java.lang.invoke.MethodHandleImpl.Intrinsic;\n@@ -65,0 +64,1 @@\n+import static java.lang.classfile.ClassFile.*;\n@@ -66,1 +66,0 @@\n-import static java.lang.invoke.MethodHandleImpl.Intrinsic;\n@@ -2291,15 +2290,4 @@\n-                    ClassReader reader = new ClassReader(bytes);\n-                    \/\/ ClassReader does not check if `this_class` is CONSTANT_Class_info\n-                    \/\/ workaround to read `this_class` using readConst and validate the value\n-                    int thisClass = reader.readUnsignedShort(reader.header + 2);\n-                    Object constant = reader.readConst(thisClass, new char[reader.getMaxStringLength()]);\n-                    if (!(constant instanceof Type type)) {\n-                        throw new ClassFormatError(\"this_class item: #\" + thisClass + \" not a CONSTANT_Class_info\");\n-                    }\n-                    if (!type.getDescriptor().startsWith(\"L\")) {\n-                        throw new ClassFormatError(\"this_class item: #\" + thisClass + \" not a CONSTANT_Class_info\");\n-                    }\n-                    name = type.getInternalName();\n-                    accessFlags = reader.readUnsignedShort(reader.header);\n-                } catch (RuntimeException e) {\n-                    \/\/ ASM exceptions are poorly specified\n+                    ClassModel cm = java.lang.classfile.ClassFile.of().parse(bytes);\n+                    name = cm.thisClass().asInternalName();\n+                    accessFlags = cm.flags().flagsMask();\n+                } catch (IllegalArgumentException e) {\n@@ -2311,1 +2299,1 @@\n-                if ((accessFlags & Opcodes.ACC_MODULE) != 0) {\n+                if ((accessFlags & ACC_MODULE) != 0) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1290,7 +1290,2 @@\n-        try {\n-            return Optional.of(MethodTypeDesc.of(returnType().describeConstable().orElseThrow(),\n-                                                 Stream.of(parameterArray())\n-                                                      .map(p -> p.describeConstable().orElseThrow())\n-                                                      .toArray(ClassDesc[]::new)));\n-        }\n-        catch (NoSuchElementException e) {\n+        var retDesc = returnType().describeConstable();\n+        if (retDesc.isEmpty())\n@@ -1298,0 +1293,10 @@\n+\n+        if (parameterCount() == 0)\n+            return Optional.of(MethodTypeDesc.of(retDesc.get()));\n+\n+        var params = new ClassDesc[parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            var paramDesc = parameterType(i).describeConstable();\n+            if (paramDesc.isEmpty())\n+                return Optional.empty();\n+            params[i] = paramDesc.get();\n@@ -1299,0 +1304,1 @@\n+        return Optional.of(MethodTypeDesc.of(retDesc.get(), params));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,4 +28,7 @@\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import sun.invoke.util.BytecodeDescriptor;\n+import java.lang.constant.ClassDesc;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n@@ -33,2 +36,1 @@\n-import static sun.invoke.util.Wrapper.*;\n-class TypeConvertingMethodAdapter extends MethodVisitor {\n+import static java.lang.constant.ConstantDescs.*;\n@@ -37,31 +39,1 @@\n-    TypeConvertingMethodAdapter(MethodVisitor mv) {\n-        super(Opcodes.ASM7, mv);\n-    }\n-\n-    private static final int NUM_WRAPPERS = Wrapper.COUNT;\n-\n-    private static final String NAME_OBJECT = \"java\/lang\/Object\";\n-    private static final String WRAPPER_PREFIX = \"Ljava\/lang\/\";\n-\n-    \/\/ Same for all primitives; name of the boxing method\n-    private static final String NAME_BOX_METHOD = \"valueOf\";\n-\n-    \/\/ Table of opcodes for widening primitive conversions; NOP = no conversion\n-    private static final int[][] wideningOpcodes = new int[NUM_WRAPPERS][NUM_WRAPPERS];\n-\n-    private static final Wrapper[] FROM_WRAPPER_NAME = new Wrapper[16];\n-\n-    \/\/ Table of wrappers for primitives, indexed by ASM type sorts\n-    private static final Wrapper[] FROM_TYPE_SORT = new Wrapper[12];\n-\n-    static {\n-        for (Wrapper w : Wrapper.values()) {\n-            if (w.basicTypeChar() != 'L') {\n-                int wi = hashWrapperName(w.wrapperSimpleName());\n-                assert (FROM_WRAPPER_NAME[wi] == null);\n-                FROM_WRAPPER_NAME[wi] = w;\n-            }\n-        }\n-\n-        \/\/ wideningOpcodes[][] will be NOP-initialized by default\n-        assert(Opcodes.NOP == 0);\n+class TypeConvertingMethodAdapter {\n@@ -69,7 +41,2 @@\n-        initWidening(LONG,   Opcodes.I2L, BYTE, SHORT, INT, CHAR);\n-        initWidening(LONG,   Opcodes.F2L, FLOAT);\n-        initWidening(FLOAT,  Opcodes.I2F, BYTE, SHORT, INT, CHAR);\n-        initWidening(FLOAT,  Opcodes.L2F, LONG);\n-        initWidening(DOUBLE, Opcodes.I2D, BYTE, SHORT, INT, CHAR);\n-        initWidening(DOUBLE, Opcodes.F2D, FLOAT);\n-        initWidening(DOUBLE, Opcodes.L2D, LONG);\n+    private static class BoxHolder {\n+        private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -77,13 +44,2 @@\n-        FROM_TYPE_SORT[Type.BYTE] = Wrapper.BYTE;\n-        FROM_TYPE_SORT[Type.SHORT] = Wrapper.SHORT;\n-        FROM_TYPE_SORT[Type.INT] = Wrapper.INT;\n-        FROM_TYPE_SORT[Type.LONG] = Wrapper.LONG;\n-        FROM_TYPE_SORT[Type.CHAR] = Wrapper.CHAR;\n-        FROM_TYPE_SORT[Type.FLOAT] = Wrapper.FLOAT;\n-        FROM_TYPE_SORT[Type.DOUBLE] = Wrapper.DOUBLE;\n-        FROM_TYPE_SORT[Type.BOOLEAN] = Wrapper.BOOLEAN;\n-    }\n-\n-    private static void initWidening(Wrapper to, int opcode, Wrapper... from) {\n-        for (Wrapper f : from) {\n-            wideningOpcodes[f.ordinal()][to.ordinal()] = opcode;\n+        private static MethodRefEntry box(ClassDesc primitive, ClassDesc target) {\n+            return CP.methodRefEntry(target, \"valueOf\", MethodTypeDescImpl.ofValidated(target, primitive));\n@@ -91,9 +47,11 @@\n-    }\n-    \/**\n-     * Class name to Wrapper hash, derived from Wrapper.hashWrap()\n-     * @param xn\n-     * @return The hash code 0-15\n-     *\/\n-    private static int hashWrapperName(String xn) {\n-        if (xn.length() < 3) {\n-            return 0;\n+        private static final MethodRefEntry BOX_BOOLEAN = box(CD_boolean, CD_Boolean),\n+                                            BOX_BYTE    = box(CD_byte, CD_Byte),\n+                                            BOX_SHORT   = box(CD_short, CD_Short),\n+                                            BOX_CHAR    = box(CD_char, CD_Character),\n+                                            BOX_INT     = box(CD_int, CD_Integer),\n+                                            BOX_LONG    = box(CD_long, CD_Long),\n+                                            BOX_FLOAT   = box(CD_float, CD_Float),\n+                                            BOX_DOUBLE  = box(CD_double, CD_Double);\n+\n+        private static MethodRefEntry unbox(ClassDesc owner, String methodName, ClassDesc primitiveTarget) {\n+            return CP.methodRefEntry(owner, methodName, MethodTypeDescImpl.ofValidated(primitiveTarget));\n@@ -102,21 +60,8 @@\n-        return (3 * xn.charAt(1) + xn.charAt(2)) % 16;\n-    }\n-\n-    private Wrapper wrapperOrNullFromDescriptor(String desc) {\n-        if (!desc.startsWith(WRAPPER_PREFIX)) {\n-            \/\/ Not a class type (array or method), so not a boxed type\n-            \/\/ or not in the right package\n-            return null;\n-        }\n-        \/\/ Pare it down to the simple class name\n-        String cname = desc.substring(WRAPPER_PREFIX.length(), desc.length() - 1);\n-        \/\/ Hash to a Wrapper\n-        Wrapper w = FROM_WRAPPER_NAME[hashWrapperName(cname)];\n-        if (w == null || w.wrapperSimpleName().equals(cname)) {\n-            return w;\n-        } else {\n-            return null;\n-        }\n-    }\n-    private static String wrapperName(Wrapper w) {\n-        return \"java\/lang\/\" + w.wrapperSimpleName();\n+        private static final MethodRefEntry UNBOX_BOOLEAN = unbox(CD_Boolean, \"booleanValue\", CD_boolean),\n+                                            UNBOX_BYTE    = unbox(CD_Number, \"byteValue\", CD_byte),\n+                                            UNBOX_SHORT   = unbox(CD_Number, \"shortValue\", CD_short),\n+                                            UNBOX_CHAR    = unbox(CD_Character, \"charValue\", CD_char),\n+                                            UNBOX_INT     = unbox(CD_Number, \"intValue\", CD_int),\n+                                            UNBOX_LONG    = unbox(CD_Number, \"longValue\", CD_long),\n+                                            UNBOX_FLOAT   = unbox(CD_Number, \"floatValue\", CD_float),\n+                                            UNBOX_DOUBLE  = unbox(CD_Number, \"doubleValue\", CD_double);\n@@ -126,2 +71,10 @@\n-    private static String unboxMethod(Wrapper w) {\n-        return w.primitiveSimpleName() + \"Value\";\n+    private static TypeKind primitiveTypeKindFromClass(Class<?> type) {\n+        if (type == int.class)     return TypeKind.IntType;\n+        if (type == long.class)    return TypeKind.LongType;\n+        if (type == boolean.class) return TypeKind.BooleanType;\n+        if (type == short.class)   return TypeKind.ShortType;\n+        if (type == byte.class)    return TypeKind.ByteType;\n+        if (type == char.class)    return TypeKind.CharType;\n+        if (type == float.class)   return TypeKind.FloatType;\n+        if (type == double.class)  return TypeKind.DoubleType;\n+        return null;\n@@ -130,2 +83,2 @@\n-    private static String boxingDescriptor(Wrapper w) {\n-        return \"(\" + w.basicTypeChar() + \")L\" + wrapperName(w) + \";\";\n+    static void boxIfTypePrimitive(CodeBuilder cob, TypeKind tk) {\n+        box(cob, tk);\n@@ -134,12 +87,3 @@\n-    private static String unboxingDescriptor(Wrapper w) {\n-        return \"()\" + w.basicTypeChar();\n-    }\n-\n-    void boxIfTypePrimitive(Type t) {\n-        Wrapper w = FROM_TYPE_SORT[t.getSort()];\n-        if (w != null) {\n-            box(w);\n-        }\n-    }\n-\n-    void widen(Wrapper ws, Wrapper wt) {\n+    static void widen(CodeBuilder cob, TypeKind ws, TypeKind wt) {\n+        ws = ws.asLoadable();\n+        wt = wt.asLoadable();\n@@ -147,4 +91,1 @@\n-            int opcode = wideningOpcodes[ws.ordinal()][wt.ordinal()];\n-            if (opcode != Opcodes.NOP) {\n-                visitInsn(opcode);\n-            }\n+            cob.conversion(ws, wt);\n@@ -154,27 +95,10 @@\n-    void box(Wrapper w) {\n-        visitMethodInsn(Opcodes.INVOKESTATIC,\n-                wrapperName(w),\n-                NAME_BOX_METHOD,\n-                boxingDescriptor(w), false);\n-    }\n-\n-    \/**\n-     * Convert types by unboxing. The source type is known to be a primitive wrapper.\n-     * @param sname A primitive wrapper corresponding to wrapped reference source type\n-     * @param wt A primitive wrapper being converted to\n-     *\/\n-    void unbox(String sname, Wrapper wt) {\n-        visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n-                sname,\n-                unboxMethod(wt),\n-                unboxingDescriptor(wt), false);\n-    }\n-\n-    private String descriptorToName(String desc) {\n-        int last = desc.length() - 1;\n-        if (desc.charAt(0) == 'L' && desc.charAt(last) == ';') {\n-            \/\/ In descriptor form\n-            return desc.substring(1, last);\n-        } else {\n-            \/\/ Already in internal name form\n-            return desc;\n+    static void box(CodeBuilder cob, TypeKind tk) {\n+        switch (tk) {\n+            case BooleanType -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n+            case ByteType    -> cob.invokestatic(BoxHolder.BOX_BYTE);\n+            case CharType    -> cob.invokestatic(BoxHolder.BOX_CHAR);\n+            case DoubleType  -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n+            case FloatType   -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n+            case IntType     -> cob.invokestatic(BoxHolder.BOX_INT);\n+            case LongType    -> cob.invokestatic(BoxHolder.BOX_LONG);\n+            case ShortType   -> cob.invokestatic(BoxHolder.BOX_SHORT);\n@@ -184,5 +108,10 @@\n-    void cast(String ds, String dt) {\n-        String ns = descriptorToName(ds);\n-        String nt = descriptorToName(dt);\n-        if (!nt.equals(ns) && !nt.equals(NAME_OBJECT)) {\n-            visitTypeInsn(Opcodes.CHECKCAST, nt);\n+    static void unbox(CodeBuilder cob, TypeKind to) {\n+        switch (to) {\n+            case BooleanType -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n+            case ByteType    -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n+            case CharType    -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n+            case DoubleType  -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n+            case FloatType   -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n+            case IntType     -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n+            case LongType    -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n+            case ShortType   -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n@@ -192,4 +121,3 @@\n-    private Wrapper toWrapper(String desc) {\n-        char first = desc.charAt(0);\n-        if (first == '[' || first == '(') {\n-            first = 'L';\n+    static void cast(CodeBuilder cob, ClassDesc dt) {\n+        if (!dt.equals(CD_Object)) {\n+            cob.checkcast(dt);\n@@ -197,1 +125,0 @@\n-        return Wrapper.forBasicType(first);\n@@ -207,1 +134,1 @@\n-    void convertType(Class<?> arg, Class<?> target, Class<?> functional) {\n+    static void convertType(CodeBuilder cob, Class<?> arg, Class<?> target, Class<?> functional) {\n@@ -215,1 +142,0 @@\n-            Wrapper wArg = Wrapper.forPrimitiveType(arg);\n@@ -218,1 +144,1 @@\n-                widen(wArg, Wrapper.forPrimitiveType(target));\n+                widen(cob, TypeKind.from(arg), TypeKind.from(target));\n@@ -221,3 +147,2 @@\n-                String dTarget = BytecodeDescriptor.unparse(target);\n-                Wrapper wPrimTarget = wrapperOrNullFromDescriptor(dTarget);\n-                if (wPrimTarget != null) {\n+                TypeKind wPrimTk = primitiveTypeKindFromClass(target);\n+                if (wPrimTk != null) {\n@@ -225,2 +150,2 @@\n-                    widen(wArg, wPrimTarget);\n-                    box(wPrimTarget);\n+                    widen(cob, TypeKind.from(arg), wPrimTk);\n+                    box(cob, wPrimTk);\n@@ -229,2 +154,2 @@\n-                    box(wArg);\n-                    cast(wrapperName(wArg), dTarget);\n+                    box(cob, TypeKind.from(arg));\n+                    cast(cob, classDesc(target));\n@@ -234,4 +159,3 @@\n-            String dArg = BytecodeDescriptor.unparse(arg);\n-            String dSrc;\n-            if (functional.isPrimitive()) {\n-                dSrc = dArg;\n+            Class<?> src;\n+            if (arg == functional || functional.isPrimitive()) {\n+                src = arg;\n@@ -240,2 +164,2 @@\n-                dSrc = BytecodeDescriptor.unparse(functional);\n-                cast(dArg, dSrc);\n+                src = functional;\n+                cast(cob, classDesc(functional));\n@@ -243,3 +167,1 @@\n-            String dTarget = BytecodeDescriptor.unparse(target);\n-                Wrapper wTarget = toWrapper(dTarget);\n-                Wrapper wps = wrapperOrNullFromDescriptor(dSrc);\n+                TypeKind wps = primitiveTypeKindFromClass(src);\n@@ -249,1 +171,1 @@\n-                    if (wps.isSigned() || wps.isFloating()) {\n+                    if (src != Character.class && src != Boolean.class) {\n@@ -251,1 +173,1 @@\n-                        unbox(wrapperName(wps), wTarget);\n+                        unbox(cob, TypeKind.from(target));\n@@ -254,2 +176,2 @@\n-                        unbox(wrapperName(wps), wps);\n-                        widen(wps, wTarget);\n+                        unbox(cob, wps);\n+                        widen(cob, wps, TypeKind.from(target));\n@@ -260,4 +182,4 @@\n-                    String intermediate;\n-                    if (wTarget.isSigned() || wTarget.isFloating()) {\n-                        \/\/ Boxed number to primitive\n-                        intermediate = \"java\/lang\/Number\";\n+                    if (target == char.class) {\n+                        cast(cob, CD_Character);\n+                    } else if (target == boolean.class) {\n+                        cast(cob, CD_Boolean);\n@@ -265,2 +187,2 @@\n-                        \/\/ Character or Boolean\n-                        intermediate = wrapperName(wTarget);\n+                        \/\/ Boxed number to primitive\n+                        cast(cob, CD_Number);\n@@ -268,2 +190,1 @@\n-                    cast(dSrc, intermediate);\n-                    unbox(intermediate, wTarget);\n+                    unbox(cob, TypeKind.from(target));\n@@ -273,1 +194,3 @@\n-                cast(dSrc, dTarget);\n+                if (src != target) {\n+                    cast(cob, classDesc(target));\n+                }\n@@ -278,16 +201,5 @@\n-    \/**\n-     * The following method is copied from\n-     * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small\n-     * and fast Java bytecode manipulation framework.\n-     * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.\n-     *\/\n-    void iconst(final int cst) {\n-        if (cst >= -1 && cst <= 5) {\n-            mv.visitInsn(Opcodes.ICONST_0 + cst);\n-        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-        } else {\n-            mv.visitLdcInsn(cst);\n-        }\n+    static ClassDesc classDesc(Class<?> cls) {\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+             : cls == Object.class ? CD_Object\n+             : cls == String.class ? CD_String\n+             : ClassDescImpl.ofValidated(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":104,"deletions":192,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-import java.lang.constant.ConstantDescs;\n+\n@@ -54,3 +54,0 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-\n@@ -70,0 +67,1 @@\n+            CD_ClassLoader = ClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n@@ -71,0 +69,2 @@\n+            CD_ClassNotFoundException = ClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n@@ -86,2 +86,3 @@\n-            MTD_Class_array = MethodTypeDescImpl.ofValidated(CD_Class_array),\n-            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, ConstantDescs.CD_String, CD_Class_array),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDescImpl.ofValidated(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDescImpl.ofValidated(CD_ClassLoader),\n+            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, CD_String, CD_Class_array),\n@@ -112,3 +113,3 @@\n-    private static final ProxyMethod HASH_CODE_METHOD;\n-    private static final ProxyMethod EQUALS_METHOD;\n-    private static final ProxyMethod TO_STRING_METHOD;\n+    private static final Method OBJECT_HASH_CODE_METHOD;\n+    private static final Method OBJECT_EQUALS_METHOD;\n+    private static final Method OBJECT_TO_STRING_METHOD;\n@@ -118,3 +119,3 @@\n-            HASH_CODE_METHOD = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n-            EQUALS_METHOD = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n-            TO_STRING_METHOD = new ProxyMethod(Object.class.getMethod(\"toString\"));\n+            OBJECT_HASH_CODE_METHOD = Object.class.getMethod(\"hashCode\");\n+            OBJECT_EQUALS_METHOD = Object.class.getMethod(\"equals\", Object.class);\n+            OBJECT_TO_STRING_METHOD = Object.class.getMethod(\"toString\");\n@@ -127,1 +128,1 @@\n-    private final List<StackMapFrameInfo.VerificationTypeInfo> throwableStack;\n+    private final List<StackMapFrameInfo.VerificationTypeInfo> classLoaderLocal, throwableStack;\n@@ -129,1 +130,1 @@\n-    private final ClassEntry object, proxy, ute;\n+    private final ClassEntry objectCE, proxyCE, uteCE, classCE;\n@@ -131,3 +132,2 @@\n-    private final InterfaceMethodRefEntry invoke;\n-    private final MethodRefEntry uteInit;\n-    private final DirectMethodHandleDesc bsm;\n+    private final InterfaceMethodRefEntry invocationHandlerInvoke;\n+    private final MethodRefEntry uteInit, classGetMethod, classForName, throwableGetMessage;\n@@ -137,1 +137,1 @@\n-     * Name of proxy class\n+     * ClassEntry for this proxy class\n@@ -139,1 +139,1 @@\n-    private final ClassEntry classEntry;\n+    private final ClassEntry thisClassCE;\n@@ -158,0 +158,6 @@\n+    \/**\n+     * Ordinal of next ProxyMethod object added to proxyMethods.\n+     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n+     *\/\n+    private int proxyMethodCount = 3;\n+\n@@ -168,1 +174,1 @@\n-        this.classEntry = cp.classEntry(ConstantUtils.binaryNameToDesc(className));\n+        this.thisClassCE = cp.classEntry(ConstantUtils.binaryNameToDesc(className));\n@@ -171,1 +177,3 @@\n-        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_Throwable)));\n+        var throwable = cp.classEntry(CD_Throwable);\n+        this.classLoaderLocal = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_ClassLoader)));\n+        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(throwable));\n@@ -173,7 +181,10 @@\n-        this.object = cp.classEntry(CD_Object);\n-        this.proxy = cp.classEntry(CD_Proxy);\n-        this.handlerField = cp.fieldRefEntry(proxy, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n-        this.invoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n-        this.ute = cp.classEntry(CD_UndeclaredThrowableException);\n-        this.uteInit = cp.methodRefEntry(ute, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n-        this.bsm = ConstantDescs.ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String, CD_MethodType);\n+        this.objectCE = cp.classEntry(CD_Object);\n+        this.proxyCE = cp.classEntry(CD_Proxy);\n+        this.classCE = cp.classEntry(CD_Class);\n+        this.handlerField = cp.fieldRefEntry(proxyCE, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n+        this.invocationHandlerInvoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+        this.uteCE = cp.classEntry(CD_UndeclaredThrowableException);\n+        this.uteInit = cp.methodRefEntry(uteCE, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n+        this.classGetMethod = cp.methodRefEntry(classCE, cp.nameAndTypeEntry(\"getMethod\", MTD_Method_String_Class_array));\n+        this.classForName = cp.methodRefEntry(classCE, cp.nameAndTypeEntry(\"forName\", MTD_Class_String_boolean_ClassLoader));\n+        this.throwableGetMessage = cp.methodRefEntry(throwable, cp.nameAndTypeEntry(\"getMessage\", MTD_String));\n@@ -444,3 +455,3 @@\n-        addProxyMethod(HASH_CODE_METHOD);\n-        addProxyMethod(EQUALS_METHOD);\n-        addProxyMethod(TO_STRING_METHOD);\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n@@ -467,2 +478,2 @@\n-        return CF_CONTEXT.build(classEntry, cp, clb -> {\n-            clb.withSuperclass(proxy);\n+        return CF_CONTEXT.build(thisClassCE, cp, clb -> {\n+            clb.withSuperclass(proxyCE);\n@@ -475,0 +486,3 @@\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n@@ -476,1 +490,1 @@\n-                    pm.generateMethod(this, clb);\n+                    pm.generateMethod(clb);\n@@ -480,1 +494,1 @@\n-            generateBootstrapMethod(clb);\n+            generateStaticInitializer(clb);\n@@ -523,1 +537,1 @@\n-                exceptionTypes, fromClass));\n+                exceptionTypes, fromClass, \"m\" + proxyMethodCount++));\n@@ -545,1 +559,2 @@\n-               .invokespecial(cp.methodRefEntry(proxy, cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n+               .invokespecial(cp.methodRefEntry(proxyCE,\n+                   cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n@@ -550,1 +565,6 @@\n-     * Generate CONDY bootstrap method for the proxy class to retrieve {@link Method} instances.\n+     * Generate the class initializer.\n+     * Discussion: Currently, for Proxy to work with SecurityManager,\n+     * we rely on the parameter classes of the methods to be computed\n+     * from Proxy instead of via user code paths like bootstrap method\n+     * lazy evaluation. That might change if we can pass in the live\n+     * Method objects directly..\n@@ -552,12 +572,28 @@\n-    private void generateBootstrapMethod(ClassBuilder clb) {\n-        clb.withMethodBody(bsm.methodName(), bsm.invocationType(), ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC, cob -> {\n-            cob.aload(3) \/\/interface Class\n-               .aload(4) \/\/interface method name String\n-               .aload(5) \/\/interface MethodType\n-               .invokevirtual(CD_MethodType, \"parameterArray\", MTD_Class_array)\n-               .invokevirtual(ConstantDescs.CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n-               .areturn();\n-            Label failLabel = cob.newBoundLabel();\n-            ClassEntry nsme = cp.classEntry(CD_NoSuchMethodError);\n-            cob.exceptionCatch(cob.startLabel(), failLabel, failLabel, CD_NoSuchMethodException)\n-               .new_(nsme)\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(thisClassCE)\n+               .invokevirtual(cp.methodRefEntry(classCE,\n+                       cp.nameAndTypeEntry(\"getClassLoader\", MTD_ClassLoader)))\n+               .astore(0);\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob);\n+                }\n+            }\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            var nsmError = cp.classEntry(CD_NoSuchMethodError);\n+            cob.exceptionCatch(ts, c1, c1, CD_NoSuchMethodException)\n+               .new_(nsmError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(nsmError, exInit))\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            var ncdfError = cp.classEntry(CD_NoClassDefFoundError);\n+            cob.exceptionCatch(ts, c1, c2, CD_ClassNotFoundException)\n+               .new_(ncdfError)\n@@ -566,5 +602,7 @@\n-               .invokevirtual(cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String))\n-               .invokespecial(cp.methodRefEntry(nsme, exInit))\n-               .athrow()\n-               .with(StackMapTableAttribute.of(List.of(\n-                       StackMapFrameInfo.of(failLabel, List.of(), throwableStack))));\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(ncdfError, exInit))\n+               .athrow();\n+            cob.with(StackMapTableAttribute.of(List.of(\n+                       StackMapFrameInfo.of(c1, classLoaderLocal, throwableStack),\n+                       StackMapFrameInfo.of(c2, classLoaderLocal, throwableStack))));\n+\n@@ -590,1 +628,1 @@\n-                               .ldc(proxy)\n+                               .ldc(proxyCE)\n@@ -616,1 +654,1 @@\n-    private static class ProxyMethod {\n+    private class ProxyMethod {\n@@ -623,0 +661,1 @@\n+        private final String methodFieldName;\n@@ -624,0 +663,1 @@\n+        private final FieldRefEntry methodField;\n@@ -627,1 +667,1 @@\n-                            Class<?> fromClass) {\n+                            Class<?> fromClass, String methodFieldName) {\n@@ -634,0 +674,3 @@\n+            this.methodFieldName = methodFieldName;\n+            this.methodField = cp.fieldRefEntry(thisClassCE,\n+                cp.nameAndTypeEntry(methodFieldName, CD_Method));\n@@ -641,1 +684,1 @@\n-        private ProxyMethod(Method method) {\n+        private ProxyMethod(Method method, String methodFieldName) {\n@@ -644,1 +687,1 @@\n-                 method.getSharedExceptionTypes(), method.getDeclaringClass());\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -650,2 +693,1 @@\n-        private void generateMethod(ProxyGenerator pg, ClassBuilder clb) {\n-            var cp = pg.cp;\n+        private void generateMethod(ClassBuilder clb) {\n@@ -659,7 +701,4 @@\n-                        cob.aload(0)\n-                           .getfield(pg.handlerField)\n-                           .aload(0)\n-                           .ldc(DynamicConstantDesc.of(pg.bsm,\n-                                referenceClassDesc(fromClass),\n-                                method.getName(),\n-                                desc));\n+                        cob.aload(cob.receiverSlot())\n+                           .getfield(handlerField)\n+                           .aload(cob.receiverSlot())\n+                           .getstatic(methodField);\n@@ -669,1 +708,1 @@\n-                               .anewarray(pg.object);\n+                               .anewarray(objectCE);\n@@ -680,1 +719,1 @@\n-                        cob.invokeinterface(pg.invoke);\n+                        cob.invokeinterface(invocationHandlerInvoke);\n@@ -696,1 +735,1 @@\n-                               .new_(pg.ute)\n+                               .new_(uteCE)\n@@ -699,1 +738,1 @@\n-                               .invokespecial(pg.uteInit)\n+                               .invokespecial(uteInit)\n@@ -702,2 +741,2 @@\n-                                       StackMapFrameInfo.of(c1, List.of(), pg.throwableStack),\n-                                       StackMapFrameInfo.of(c2, List.of(), pg.throwableStack))));\n+                                    StackMapFrameInfo.of(c1, List.of(), throwableStack),\n+                                    StackMapFrameInfo.of(c2, List.of(), throwableStack))));\n@@ -718,1 +757,1 @@\n-                cob.invokestatic(prim.wrapperMethodRef(cob.constantPool()));\n+                cob.invokestatic(prim.wrapperMethodRef(cp));\n@@ -734,1 +773,1 @@\n-                   .invokevirtual(prim.unwrapMethodRef(cob.constantPool()))\n+                   .invokevirtual(prim.unwrapMethodRef(cp))\n@@ -742,0 +781,51 @@\n+        \/**\n+         * Generate code for initializing the static field that stores\n+         * the Method object for this proxy method. A class loader is\n+         * anticipated at local variable index 0.\n+         * The generated code must be run in an AccessController.doPrivileged\n+         * block if a SecurityManager is present, as otherwise the code\n+         * cannot pass {@code null} ClassLoader to forName.\n+         *\/\n+        private void codeFieldInitialization(CodeBuilder cob) {\n+            var cp = cob.constantPool();\n+            codeClassForName(cob, fromClass);\n+\n+            cob.ldc(method.getName())\n+               .loadConstant(parameterTypes.length)\n+               .anewarray(classCE);\n+\n+            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                cob.dup()\n+                   .loadConstant(i);\n+                if (parameterTypes[i].isPrimitive()) {\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.typeFieldRef(cp));\n+                } else {\n+                    codeClassForName(cob, parameterTypes[i]);\n+                }\n+                cob.aastore();\n+            }\n+            \/\/ lookup the method\n+            cob.invokevirtual(classGetMethod)\n+               .putstatic(methodField);\n+        }\n+\n+        \/*\n+         * =============== Code Generation Utility Methods ===============\n+         *\/\n+\n+        \/**\n+         * Generate code to invoke the Class.forName with the name of the given\n+         * class to get its Class object at runtime.  The code is written to\n+         * the supplied stream.  Note that the code generated by this method\n+         * may cause the checked ClassNotFoundException to be thrown. A class\n+         * loader is anticipated at local variable index 0.\n+         *\/\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.ldc(cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(classForName);\n+        }\n+\n@@ -808,0 +898,4 @@\n+\n+        public FieldRefEntry typeFieldRef(ConstantPoolBuilder cp) {\n+            return cp.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":171,"deletions":77,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -28,4 +28,3 @@\n-import java.lang.classfile.constantpool.InvokeDynamicEntry;\n-import java.lang.constant.ClassDesc;\n-import static java.lang.constant.ConstantDescs.*;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BufWriter;\n@@ -33,0 +32,2 @@\n+import java.lang.classfile.Label;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -35,1 +36,4 @@\n-import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.classfile.constantpool.InvokeDynamicEntry;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -44,1 +48,1 @@\n-import java.lang.classfile.Attribute;\n+import jdk.internal.constant.ClassDescImpl;\n@@ -47,6 +51,1 @@\n-import static jdk.internal.constant.ConstantUtils.binaryNameToDesc;\n-\n-import java.lang.classfile.BufWriter;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.Attributes;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -1252,8 +1251,8 @@\n-            INT_ARRAY_TYPE = referenceType(CD_int.arrayType()),\n-            BOOLEAN_ARRAY_TYPE = referenceType(CD_boolean.arrayType()),\n-            BYTE_ARRAY_TYPE = referenceType(CD_byte.arrayType()),\n-            CHAR_ARRAY_TYPE = referenceType(CD_char.arrayType()),\n-            SHORT_ARRAY_TYPE = referenceType(CD_short.arrayType()),\n-            LONG_ARRAY_TYPE = referenceType(CD_long.arrayType()),\n-            DOUBLE_ARRAY_TYPE = referenceType(CD_double.arrayType()),\n-            FLOAT_ARRAY_TYPE = referenceType(CD_float.arrayType()),\n+            INT_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[I\")),\n+            BOOLEAN_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[Z\")),\n+            BYTE_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[B\")),\n+            CHAR_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[C\")),\n+            SHORT_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[S\")),\n+            LONG_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[J\")),\n+            DOUBLE_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[D\")),\n+            FLOAT_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[F\")),\n@@ -1324,2 +1323,2 @@\n-        private static final ClassDesc CD_Cloneable = binaryNameToDesc(\"java.lang.Cloneable\");\n-        private static final ClassDesc CD_Serializable = binaryNameToDesc(\"java.io.Serializable\");\n+        private static final ClassDesc CD_Cloneable = ClassDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n+        private static final ClassDesc CD_Serializable = ClassDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+        java.management.rmi,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -963,1 +963,0 @@\n-        env.info.ctorPrologue = false;\n@@ -1008,1 +1007,1 @@\n-        env.info.ctorPrologue = false;\n+        Assert.check(!env.info.ctorPrologue);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+    Preview preview;\n@@ -138,1 +139,1 @@\n-        Preview preview = Preview.instance(context);\n+        preview = Preview.instance(context);\n@@ -1488,0 +1489,1 @@\n+     *  @param pos       The position to use for error reporting.\n@@ -1491,1 +1493,1 @@\n-    Symbol findVar(Env<AttrContext> env, Name name) {\n+    Symbol findVar(DiagnosticPosition pos, Env<AttrContext> env, Name name) {\n@@ -1516,1 +1518,1 @@\n-                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym)) {\n+                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n@@ -2432,1 +2434,1 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(env, name, kind), name));\n+        return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n@@ -2435,1 +2437,1 @@\n-    Symbol findIdentInternal(Env<AttrContext> env, Name name, KindSelector kind) {\n+    Symbol findIdentInternal(DiagnosticPosition pos, Env<AttrContext> env, Name name, KindSelector kind) {\n@@ -2440,1 +2442,1 @@\n-            sym = findVar(env, name);\n+            sym = findVar(pos, env, name);\n@@ -3787,1 +3789,1 @@\n-                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym))\n+                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n@@ -3856,1 +3858,1 @@\n-    private boolean isAllowedEarlyReference(Env<AttrContext> env, VarSymbol v) {\n+    private boolean isAllowedEarlyReference(DiagnosticPosition pos, Env<AttrContext> env, VarSymbol v) {\n@@ -3872,1 +3874,14 @@\n-        JCExpression base = lhs instanceof JCFieldAccess select ? select.selected : null;\n+        JCExpression base;\n+        switch (lhs.getTag()) {\n+        case IDENT:\n+            base = null;\n+            break;\n+        case SELECT:\n+            JCFieldAccess select = (JCFieldAccess)lhs;\n+            base = select.selected;\n+            if (!TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))\n+                return false;\n+            break;\n+        default:\n+            return false;\n+        }\n@@ -3878,0 +3893,3 @@\n+        \/\/ The flexible constructors feature must be enabled\n+        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -120,0 +120,18 @@\n+\n+\n+# Valhalla...\n+compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java      8341844   generic-all\n+compiler\/valhalla\/inlinetypes\/TestCallingConvention.java      8341844   generic-all\n+compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java    8341844   generic-all\n+runtime\/valhalla\/inlinetypes\/InlineTypesTest.java             8341844   generic-all\n+\n+compiler\/valhalla\/inlinetypes\/TestStressReturnBuffering.java  8341846   generic-all\n+\n+compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeArray.java   8341848 generic-all\n+compiler\/valhalla\/inlinetypes\/TestArrays.java                 8341848   generic-all\n+compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java     8341848   generic-all\n+compiler\/valhalla\/inlinetypes\/TestLWorld.java                 8341848   generic-all\n+\n+compiler\/valhalla\/inlinetypes\/TestIntrinsics.java             8341849   generic-all\n+\n+compiler\/valhalla\/inlinetypes\/TestNullableArrays.java         8341850   generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-gc\/parallel\/TestAlwaysPreTouchBehavior.java 8325218 linux-all\n@@ -88,0 +87,7 @@\n+gc\/TestAlwaysPreTouchBehavior.java#ParallelCollector 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#SerialCollector 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#Shenandoah 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#G1 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#ZGenerational 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#ZSinglegen 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#Epsilon 8334513 generic-all\n@@ -108,1 +114,1 @@\n-runtime\/Thread\/TestAlwaysPreTouchStacks.java 8324781 linux-all\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8334545 generic-all\n@@ -112,0 +118,1 @@\n+containers\/cgroup\/PlainRead.java 8333967,8261242 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+ -runtime\/cds\/appcds\/resolvedConstants \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -489,1 +489,0 @@\n-java\/lang\/ProcessHandle\/InfoTest.java                           8211847 aix-ppc64\n@@ -558,2 +557,0 @@\n-java\/net\/ServerSocket\/AcceptInheritHandle.java                  8211854 aix-ppc64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -815,0 +815,1 @@\n+  public native long rss();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}