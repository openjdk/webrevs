{"files":[{"patch":"@@ -1,333 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test Object methods on value classes\n- * @enablePreview\n- * @run junit\/othervm -Dvalue.bsm.salt=1 -XX:-UseAtomicValueFlattening ObjectMethods\n- * @run junit\/othervm -Dvalue.bsm.salt=1 -XX:-UseFieldFlattening ObjectMethods\n- *\/\n-import java.util.Optional;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-import java.lang.reflect.AccessFlag;\n-import java.lang.reflect.Modifier;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-public class ObjectMethods {\n-    static value class Point {\n-        public int x;\n-        public int y;\n-        Point(int x, int y) {\n-            this.x = x;\n-            this.y = y;\n-        }\n-    }\n-\n-    static value class Line {\n-        @NullRestricted  @Strict\n-        Point p1;\n-        @NullRestricted  @Strict\n-        Point p2;\n-\n-        Line(int x1, int y1, int x2, int y2) {\n-            this.p1 = new Point(x1, y1);\n-            this.p2 = new Point(x2, y2);\n-        }\n-    }\n-\n-    static class Ref {\n-        @NullRestricted  @Strict\n-        Point p;\n-        Line l;\n-        Ref(Point p, Line l) {\n-            this.p = p;\n-            this.l = l;\n-        }\n-    }\n-\n-    static value class Value {\n-        @NullRestricted  @Strict\n-        Point p;\n-        @NullRestricted  @Strict\n-        Line l;\n-        Ref r;\n-        String s;\n-        Value(Point p, Line l, Ref r, String s) {\n-            this.p = p;\n-            this.l = l;\n-            this.r = r;\n-            this.s = s;\n-        }\n-    }\n-\n-    static value class ValueOptional {\n-        private Object o;\n-        public ValueOptional(Object o) {\n-            this.o = o;\n-        }\n-    }\n-\n-    static value record ValueRecord(int i, String name) {}\n-\n-    static final int SALT = 1;\n-    static final Point P1 = new Point(1, 2);\n-    static final Point P2 = new Point(30, 40);\n-    static final Line L1 = new Line(1, 2, 3, 4);\n-    static final Line L2 = new Line(10, 20, 3, 4);\n-    static final Ref R1 = new Ref(P1, L1);\n-    static final Ref R2 = new Ref(P2, null);\n-    static final Value V = new Value(P1, L1, R1, \"value\");\n-\n-    \/\/ Instances to test, classes of each instance are tested too\n-    static Stream<Arguments> identitiesData() {\n-        Function<String, String> lambda1 = (a) -> \"xyz\";\n-        return Stream.of(\n-                Arguments.of(lambda1, true, false),         \/\/ a lambda (Identity for now)\n-                Arguments.of(new Object(), true, false),    \/\/ java.lang.Object\n-                Arguments.of(\"String\", true, false),\n-                Arguments.of(L1, false, true),\n-                Arguments.of(V, false, true),\n-                Arguments.of(new ValueRecord(1, \"B\"), false, true),\n-                Arguments.of(new int[0], true, false),     \/\/ arrays of primitive type are identity objects\n-                Arguments.of(new Object[0], true, false),  \/\/ arrays of identity classes are identity objects\n-                Arguments.of(new String[0], true, false),  \/\/ arrays of identity classes are identity objects\n-                Arguments.of(new Value[0], true, false)    \/\/ arrays of value classes are identity objects\n-        );\n-    }\n-\n-    \/\/ Classes to test\n-    static Stream<Arguments> classesData() {\n-        return Stream.of(\n-                Arguments.of(int.class, false, true),       \/\/ Fabricated primitive classes\n-                Arguments.of(long.class, false, true),\n-                Arguments.of(short.class, false, true),\n-                Arguments.of(byte.class, false, true),\n-                Arguments.of(float.class, false, true),\n-                Arguments.of(double.class, false, true),\n-                Arguments.of(char.class, false, true),\n-                Arguments.of(void.class, false, true),\n-                Arguments.of(String.class, true, false),\n-                Arguments.of(Object.class, true, false),\n-                Arguments.of(Function.class, false, true),  \/\/ Interface\n-                Arguments.of(Optional.class, false, true),  \/\/ Concrete value classes...\n-                Arguments.of(Character.class, false, true)\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"identitiesData\")\n-    public void identityTests(Object obj, boolean identityClass, boolean valueClass) {\n-        Class<?> clazz = obj.getClass();\n-        assertEquals(identityClass, Objects.hasIdentity(obj), \"Objects.hasIdentity(\" + obj + \")\");\n-\n-        \/\/ Run tests on the class\n-        classTests(clazz, identityClass, valueClass);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"classesData\")\n-    public void classTests(Class<?> clazz, boolean identityClass, boolean valueClass) {\n-        assertEquals(identityClass, clazz.isIdentity(), \"Class.isIdentity(): \" + clazz);\n-\n-        assertEquals(valueClass, clazz.isValue(), \"Class.isValue(): \" + clazz);\n-\n-        assertEquals(clazz.accessFlags().contains(AccessFlag.IDENTITY),\n-                identityClass, \"AccessFlag.IDENTITY: \" + clazz);\n-\n-        int modifiers = clazz.getModifiers();\n-        assertEquals(clazz.isIdentity(), (modifiers & Modifier.IDENTITY) != 0, \"Class.getModifiers() & IDENTITY != 0\");\n-        assertEquals(clazz.isValue(), (modifiers & Modifier.IDENTITY) == 0, \"Class.getModifiers() & IDENTITY == 0\");\n-    }\n-\n-    @Test\n-    public void identityTestNull() {\n-        assertFalse(Objects.hasIdentity(null), \"Objects.hasIdentity(null)\");\n-        assertFalse(Objects.isValueObject(null), \"Objects.isValueObject(null)\");\n-    }\n-\n-    static Stream<Arguments> equalsTests() {\n-        return Stream.of(\n-                Arguments.of(P1, P1, true),\n-                Arguments.of(P1, new Point(1, 2), true),\n-                Arguments.of(P1, P2, false),\n-                Arguments.of(P1, L1, false),\n-                Arguments.of(L1, new Line(1, 2, 3, 4), true),\n-                Arguments.of(L1, L2, false),\n-                Arguments.of(L1, L1, true),\n-                Arguments.of(V, new Value(P1, L1, R1, \"value\"), true),\n-                Arguments.of(V, new Value(new Point(1, 2), new Line(1, 2, 3, 4), R1, \"value\"), true),\n-                Arguments.of(V, new Value(P1, L1, new Ref(P1, L1), \"value\"), false),\n-                Arguments.of(new Value(P1, L1, R2, \"value2\"), new Value(P1, L1, new Ref(P2, null), \"value2\"), false),\n-                Arguments.of(new ValueRecord(50, \"fifty\"), new ValueRecord(50, \"fifty\"), true),\n-\n-                \/\/ reference classes containing fields of value class\n-                Arguments.of(R1, new Ref(P1, L1), false),   \/\/ identity object\n-\n-                \/\/ uninitialized default value\n-                Arguments.of(new ValueOptional(L1), new ValueOptional(L1), true),\n-                Arguments.of(new ValueOptional(List.of(P1)), new ValueOptional(List.of(P1)), false)\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"equalsTests\")\n-    public void testEquals(Object o1, Object o2, boolean expected) {\n-        assertTrue(o1.equals(o2) == expected);\n-    }\n-\n-    static Stream<Arguments> toStringTests() {\n-        return Stream.of(\n-                Arguments.of(new Point(100, 200)),\n-                Arguments.of(new Line(1, 2, 3, 4)),\n-                Arguments.of(V),\n-                Arguments.of(R1),\n-                \/\/ enclosing instance field `this$0` should be filtered\n-                Arguments.of(new Value(P1, L1, null, null)),\n-                Arguments.of(new Value(P2, L2, new Ref(P1, null), \"value\")),\n-                Arguments.of(new ValueOptional(P1))\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"toStringTests\")\n-    public void testToString(Object o) {\n-        String expected = String.format(\"%s@%s\", o.getClass().getName(), Integer.toHexString(o.hashCode()));\n-        assertEquals(o.toString(), expected);\n-    }\n-\n-    @Test\n-    public void testValueRecordToString() {\n-        ValueRecord o = new ValueRecord(30, \"thirty\");\n-        assertEquals(o.toString(), \"ValueRecord[i=30, name=thirty]\");\n-    }\n-\n-    static Stream<Arguments> hashcodeTests() {\n-        Point p = new Point(0, 0);\n-        Line l = new Line(0, 0, 0, 0);\n-        \/\/ this is sensitive to the order of the returned fields from Class::getDeclaredFields\n-        return Stream.of(\n-                Arguments.of(P1, hash(Point.class, 1, 2)),\n-                Arguments.of(L1, hash(Line.class, new Point(1, 2), new Point(3, 4))),\n-                Arguments.of(V, hash(Value.class, P1, L1, V.r, V.s)),\n-                Arguments.of(new Point(0, 0), hash(Point.class, 0, 0)),\n-                Arguments.of(p, hash(Point.class, 0, 0)),\n-                Arguments.of(new ValueOptional(P1), hash(ValueOptional.class, P1))\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"hashcodeTests\")\n-    public void testHashCode(Object o, int hash) {\n-        assertEquals(o.hashCode(), hash);\n-        assertEquals(System.identityHashCode(o), hash);\n-    }\n-\n-    private static int hash(Object... values) {\n-        int hc = SALT;\n-        for (Object o : values) {\n-            hc = 31 * hc + (o != null ? o.hashCode() : 0);\n-        }\n-        return hc;\n-    }\n-\n-    interface Number {\n-        int value();\n-    }\n-\n-    static class ReferenceType implements Number {\n-        int i;\n-        public ReferenceType(int i) {\n-            this.i = i;\n-        }\n-        public int value() {\n-            return i;\n-        }\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o != null && o instanceof Number) {\n-                return this.value() == ((Number)o).value();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static value class ValueType1 implements Number {\n-        int i;\n-        public ValueType1(int i) {\n-            this.i = i;\n-        }\n-        public int value() {\n-            return i;\n-        }\n-    }\n-\n-    static value class ValueType2 implements Number {\n-        int i;\n-        public ValueType2(int i) {\n-            this.i = i;\n-        }\n-        public int value() {\n-            return i;\n-        }\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o != null && o instanceof Number) {\n-                return this.value() == ((Number)o).value();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static Stream<Arguments> interfaceEqualsTests() {\n-        return Stream.of(\n-                Arguments.of(new ReferenceType(10), new ReferenceType(10), false, true),\n-                Arguments.of(new ValueType1(10),    new ValueType1(10),    true,  true),\n-                Arguments.of(new ValueType2(10),    new ValueType2(10),    true,  true),\n-                Arguments.of(new ValueType1(20),    new ValueType2(20),    false, false),\n-                Arguments.of(new ValueType2(20),    new ValueType1(20),    false, true),\n-                Arguments.of(new ReferenceType(30), new ValueType1(30),    false, true),\n-                Arguments.of(new ReferenceType(30), new ValueType2(30),    false, true)\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"interfaceEqualsTests\")\n-    public void testNumber(Number n1, Number n2, boolean isSubstitutable, boolean isEquals) {\n-        assertTrue((n1 == n2) == isSubstitutable);\n-        assertTrue(n1.equals(n2) == isEquals);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":0,"deletions":333,"binary":false,"changes":333,"status":"deleted"},{"patch":"@@ -0,0 +1,354 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary test Object methods on value classes\n+ * @enablePreview\n+ * @run junit\/othervm -XX:-UseFieldFlattening ValueObjectMethodsTest\n+ * @run junit\/othervm -XX:-UseAtomicValueFlattening ValueObjectMethodsTest\n+ * @run junit\/othervm -XX:+UseFieldFlattening ValueObjectMethodsTest\n+ * @run junit\/othervm -XX:+UseAtomicValueFlattening ValueObjectMethodsTest\n+ *\/\n+import java.util.Optional;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ValueObjectMethodsTest {\n+    static value class Point {\n+        public int x;\n+        public int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    static value class Line {\n+        @NullRestricted  @Strict\n+        Point p1;\n+        @NullRestricted  @Strict\n+        Point p2;\n+\n+        Line(int x1, int y1, int x2, int y2) {\n+            this.p1 = new Point(x1, y1);\n+            this.p2 = new Point(x2, y2);\n+        }\n+    }\n+\n+    static class Ref {\n+        @NullRestricted  @Strict\n+        Point p;\n+        Line l;\n+        Ref(Point p, Line l) {\n+            this.p = p;\n+            this.l = l;\n+        }\n+    }\n+\n+    static value class Value {\n+        @NullRestricted  @Strict\n+        Point p;\n+        @NullRestricted  @Strict\n+        Line l;\n+        Ref r;\n+        String s;\n+        Value(Point p, Line l, Ref r, String s) {\n+            this.p = p;\n+            this.l = l;\n+            this.r = r;\n+            this.s = s;\n+        }\n+    }\n+\n+    static value class ValueOptional {\n+        private Object o;\n+        public ValueOptional(Object o) {\n+            this.o = o;\n+        }\n+    }\n+\n+    value record ValueRecord(int i, String name) {}\n+\n+    static final Point P1 = new Point(1, 2);\n+    static final Point P2 = new Point(30, 40);\n+    static final Line L1 = new Line(1, 2, 3, 4);\n+    static final Line L2 = new Line(10, 20, 3, 4);\n+    static final Ref R1 = new Ref(P1, L1);\n+    static final Ref R2 = new Ref(P2, null);\n+    static final Value V = new Value(P1, L1, R1, \"value\");\n+\n+    \/\/ Instances to test, classes of each instance are tested too\n+    static Stream<Arguments> identitiesData() {\n+        Function<String, String> lambda1 = (a) -> \"xyz\";\n+        return Stream.of(\n+                Arguments.of(lambda1, true, false),         \/\/ a lambda (Identity for now)\n+                Arguments.of(new Object(), true, false),    \/\/ java.lang.Object\n+                Arguments.of(\"String\", true, false),\n+                Arguments.of(L1, false, true),\n+                Arguments.of(V, false, true),\n+                Arguments.of(new ValueRecord(1, \"B\"), false, true),\n+                Arguments.of(new int[0], true, false),     \/\/ arrays of primitive type are identity objects\n+                Arguments.of(new Object[0], true, false),  \/\/ arrays of identity classes are identity objects\n+                Arguments.of(new String[0], true, false),  \/\/ arrays of identity classes are identity objects\n+                Arguments.of(new Value[0], true, false)    \/\/ arrays of value classes are identity objects\n+        );\n+    }\n+\n+    \/\/ Classes to test\n+    static Stream<Arguments> classesData() {\n+        return Stream.of(\n+                Arguments.of(int.class, false, true),       \/\/ Fabricated primitive classes\n+                Arguments.of(long.class, false, true),\n+                Arguments.of(short.class, false, true),\n+                Arguments.of(byte.class, false, true),\n+                Arguments.of(float.class, false, true),\n+                Arguments.of(double.class, false, true),\n+                Arguments.of(char.class, false, true),\n+                Arguments.of(void.class, false, true),\n+                Arguments.of(String.class, true, false),\n+                Arguments.of(Object.class, true, false),\n+                Arguments.of(Function.class, false, true),  \/\/ Interface\n+                Arguments.of(Optional.class, false, true),  \/\/ Concrete value classes...\n+                Arguments.of(Character.class, false, true)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"identitiesData\")\n+    public void identityTests(Object obj, boolean identityClass, boolean valueClass) {\n+        Class<?> clazz = obj.getClass();\n+        assertEquals(identityClass, Objects.hasIdentity(obj), \"Objects.hasIdentity(\" + obj + \")\");\n+\n+        \/\/ Run tests on the class\n+        classTests(clazz, identityClass, valueClass);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"classesData\")\n+    public void classTests(Class<?> clazz, boolean identityClass, boolean valueClass) {\n+        assertEquals(identityClass, clazz.isIdentity(), \"Class.isIdentity(): \" + clazz);\n+\n+        assertEquals(valueClass, clazz.isValue(), \"Class.isValue(): \" + clazz);\n+\n+        assertEquals(clazz.accessFlags().contains(AccessFlag.IDENTITY),\n+                identityClass, \"AccessFlag.IDENTITY: \" + clazz);\n+\n+        int modifiers = clazz.getModifiers();\n+        assertEquals(clazz.isIdentity(), (modifiers & Modifier.IDENTITY) != 0, \"Class.getModifiers() & IDENTITY != 0\");\n+        assertEquals(clazz.isValue(), (modifiers & Modifier.IDENTITY) == 0, \"Class.getModifiers() & IDENTITY == 0\");\n+    }\n+\n+    @Test\n+    public void identityTestNull() {\n+        assertFalse(Objects.hasIdentity(null), \"Objects.hasIdentity(null)\");\n+        assertFalse(Objects.isValueObject(null), \"Objects.isValueObject(null)\");\n+    }\n+\n+    static Stream<Arguments> equalsTests() {\n+        return Stream.of(\n+                Arguments.of(P1, P1, true),\n+                Arguments.of(P1, new Point(1, 2), true),\n+                Arguments.of(P1, P2, false),\n+                Arguments.of(P1, L1, false),\n+                Arguments.of(L1, new Line(1, 2, 3, 4), true),\n+                Arguments.of(L1, L2, false),\n+                Arguments.of(L1, L1, true),\n+                Arguments.of(V, new Value(P1, L1, R1, \"value\"), true),\n+                Arguments.of(V, new Value(new Point(1, 2), new Line(1, 2, 3, 4), R1, \"value\"), true),\n+                Arguments.of(V, new Value(P1, L1, new Ref(P1, L1), \"value\"), false),\n+                Arguments.of(new Value(P1, L1, R2, \"value2\"), new Value(P1, L1, new Ref(P2, null), \"value2\"), false),\n+                Arguments.of(new ValueRecord(50, \"fifty\"), new ValueRecord(50, \"fifty\"), true),\n+\n+                \/\/ reference classes containing fields of value class\n+                Arguments.of(R1, new Ref(P1, L1), false),   \/\/ identity object\n+\n+                \/\/ uninitialized default value\n+                Arguments.of(new ValueOptional(L1), new ValueOptional(L1), true),\n+                Arguments.of(new ValueOptional(List.of(P1)), new ValueOptional(List.of(P1)), false)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalsTests\")\n+    public void testEquals(Object o1, Object o2, boolean expected) {\n+        assertEquals(expected, o1.equals(o2), \"equality\");\n+        if (expected) {\n+            \/\/ If the values are equals, then the hashcode should equal\n+            assertEquals(o1.hashCode(), o2.hashCode(), \"obj.hashCode\");\n+            assertEquals(System.identityHashCode(o1), System.identityHashCode(o2), \"System.identityHashCode\");\n+        }\n+    }\n+\n+    static Stream<Arguments> toStringTests() {\n+        return Stream.of(\n+                Arguments.of(new Point(100, 200)),\n+                Arguments.of(new Line(1, 2, 3, 4)),\n+                Arguments.of(V),\n+                Arguments.of(R1),\n+                \/\/ enclosing instance field `this$0` should be filtered\n+                Arguments.of(new Value(P1, L1, null, null)),\n+                Arguments.of(new Value(P2, L2, new Ref(P1, null), \"value\")),\n+                Arguments.of(new ValueOptional(P1))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"toStringTests\")\n+    public void testToString(Object o) {\n+        String expected = String.format(\"%s@%s\", o.getClass().getName(), Integer.toHexString(o.hashCode()));\n+        assertEquals(o.toString(), expected);\n+    }\n+\n+    @Test\n+    public void testValueRecordToString() {\n+        ValueRecord o = new ValueRecord(30, \"thirty\");\n+        assertEquals(\"ValueRecord[i=30, name=thirty]\", o.toString());\n+    }\n+\n+    static Stream<List<Object>> hashcodeTests() {\n+        Point p1 = new Point(0, 1);\n+        Point p2 = new Point(0, 2);\n+        Point p3 = new Point(1, 1);\n+        Point p4 = new Point(2, 2);\n+\n+        Line l1 = new Line(0, 1, 2, 3);\n+        Line l2 = new Line(9, 1, 2, 3);\n+        Line l3 = new Line(0, 9, 2, 3);\n+        Line l4 = new Line(0, 1, 9, 3);\n+        Line l5 = new Line(0, 1, 2, 9);\n+\n+        Ref r1 = new Ref(p1, l1);\n+        Ref r2 = new Ref(p1, l2);\n+        Ref r3 = new Ref(p2, l1);\n+        Ref r4 = new Ref(p2, l2);\n+        Value v1 = new Value(p1, l1, r1, \"s1\");\n+        Value v2 = new Value(p2, l1, r1, \"s1\");\n+        Value v3 = new Value(p1, l2, r1, \"s1\");\n+        Value v4 = new Value(p1, l1, r2, \"s1\");\n+        Value v5 = new Value(p1, l1, r1, \"s2\");\n+        ValueOptional vo1 = new ValueOptional(p1);\n+        ValueOptional vo2 = new ValueOptional(p2);\n+\n+        \/\/ Each list has objects that differ from each other so the hashCodes must differ too\n+        return Stream.of(\n+                List.of(p1, p2, p3, p4),\n+                List.of(l1, l2, l3, l4, l5),\n+                List.of(r1, r2, r3, r4),\n+                List.of(v1, v2, v3, v4, v5),\n+                List.of(vo1, vo2)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"hashcodeTests\")\n+    public void testHashCode(List<Object> objects) {\n+        assertTrue(objects.size() > 1, \"More than one object is required: \" + objects);\n+\n+        long count = objects.stream().map(Object::hashCode).distinct().count();\n+        assertEquals(objects.size(), count, \"System.identityHashCode must not repeat: \" + objects);\n+        count = objects.stream().map(Object::hashCode).distinct().count();\n+        assertEquals(objects.size(), count, \"Object.hashCode must not repeat: \"  + objects);\n+    }\n+\n+    interface Number {\n+        int value();\n+    }\n+\n+    static class ReferenceType implements Number {\n+        int i;\n+        public ReferenceType(int i) {\n+            this.i = i;\n+        }\n+        public int value() {\n+            return i;\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o instanceof Number) {\n+                return this.value() == ((Number)o).value();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static value class ValueType1 implements Number {\n+        int i;\n+        public ValueType1(int i) {\n+            this.i = i;\n+        }\n+        public int value() {\n+            return i;\n+        }\n+    }\n+\n+    static value class ValueType2 implements Number {\n+        int i;\n+        public ValueType2(int i) {\n+            this.i = i;\n+        }\n+        public int value() {\n+            return i;\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o instanceof Number) {\n+                return this.value() == ((Number)o).value();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static Stream<Arguments> interfaceEqualsTests() {\n+        return Stream.of(\n+                Arguments.of(new ReferenceType(10), new ReferenceType(10), false, true),\n+                Arguments.of(new ValueType1(10),    new ValueType1(10),    true,  true),\n+                Arguments.of(new ValueType2(10),    new ValueType2(10),    true,  true),\n+                Arguments.of(new ValueType1(20),    new ValueType2(20),    false, false),\n+                Arguments.of(new ValueType2(20),    new ValueType1(20),    false, true),\n+                Arguments.of(new ReferenceType(30), new ValueType1(30),    false, true),\n+                Arguments.of(new ReferenceType(30), new ValueType2(30),    false, true)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"interfaceEqualsTests\")\n+    public void testNumber(Number n1, Number n2, boolean isSubstitutable, boolean isEquals) {\n+        assertEquals(isSubstitutable, (n1 == n2));\n+        assertEquals(isEquals, n1.equals(n2));\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueObjectMethodsTest.java","additions":354,"deletions":0,"binary":false,"changes":354,"status":"added"}]}