{"files":[{"patch":"@@ -1545,1 +1545,0 @@\n-  const bool is_optimized = false;\n@@ -1553,1 +1552,1 @@\n-  return get_resolved_entry(current, callee_method, false, is_optimized, caller_does_not_scalarize);\n+  return get_resolved_entry(current, callee_method, false, false, caller_does_not_scalarize);\n@@ -1609,1 +1608,1 @@\n-    callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_does_not_scalarize, CHECK_NULL);\n+    callee_method = SharedRuntime::reresolve_call_site(is_optimized, caller_does_not_scalarize, CHECK_NULL);\n@@ -1613,1 +1612,1 @@\n-  return get_resolved_entry(current, callee_method, is_static_call, is_optimized, caller_does_not_scalarize);\n+  return get_resolved_entry(current, callee_method, callee_method->is_static(), is_optimized, caller_does_not_scalarize);\n@@ -1781,1 +1780,1 @@\n-methodHandle SharedRuntime::reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_does_not_scalarize, TRAPS) {\n+methodHandle SharedRuntime::reresolve_call_site(bool& is_optimized, bool& caller_does_not_scalarize, TRAPS) {\n@@ -1794,0 +1793,1 @@\n+  assert(!caller.is_interpreted_frame(), \"must be compiled\");\n@@ -1795,3 +1795,9 @@\n-  \/\/ Do nothing if the frame isn't a live compiled frame.\n-  \/\/ nmethod could be deoptimized by the time we get here\n-  \/\/ so no update to the caller is needed.\n+  \/\/ If the frame isn't a live compiled frame (i.e. deoptimized by the time we get here), no IC clearing must be done\n+  \/\/ for the caller. However, when the caller is C2 compiled and the callee a C1 or C2 compiled method, then we still\n+  \/\/ need to figure out whether it was an optimized virtual call with an inline type receiver. Otherwise, we end up\n+  \/\/ using the wrong method entry point and accidentally skip the buffering of the receiver.\n+  methodHandle callee_method = find_callee_method(caller_does_not_scalarize, CHECK_(methodHandle()));\n+  const bool caller_is_compiled_and_not_deoptimized = caller.is_compiled_frame() && !caller.is_deoptimized_frame();\n+  const bool caller_is_continuation_enter_intrinsic =\n+    caller.is_native_frame() && caller.cb()->as_nmethod()->method()->is_continuation_enter_intrinsic();\n+  const bool do_IC_clearing = caller_is_compiled_and_not_deoptimized || caller_is_continuation_enter_intrinsic;\n@@ -1799,2 +1805,4 @@\n-  if ((caller.is_compiled_frame() && !caller.is_deoptimized_frame()) ||\n-      (caller.is_native_frame() && caller.cb()->as_nmethod()->method()->is_continuation_enter_intrinsic())) {\n+  const bool callee_compiled_with_scalarized_receiver = callee_method->has_compiled_code() &&\n+                                                        !callee_method()->is_static() &&\n+                                                        callee_method()->is_scalarized_arg(0);\n+  const bool compute_is_optimized = !caller_does_not_scalarize && callee_compiled_with_scalarized_receiver;\n@@ -1802,0 +1810,1 @@\n+  if (do_IC_clearing || compute_is_optimized) {\n@@ -1834,1 +1843,0 @@\n-        is_static_call = false;\n@@ -1838,1 +1846,1 @@\n-            is_static_call = true;\n+            assert(callee_method->is_static(), \"must be\");\n@@ -1841,2 +1849,4 @@\n-            CompiledDirectCall* cdc = CompiledDirectCall::at(call_addr);\n-            cdc->set_to_clean();\n+            if (do_IC_clearing) {\n+              CompiledDirectCall* cdc = CompiledDirectCall::at(call_addr);\n+              cdc->set_to_clean();\n+            }\n@@ -1846,3 +1856,5 @@\n-            \/\/ compiled, dispatched call (which used to call an interpreted method)\n-            CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);\n-            inline_cache->set_to_clean();\n+            if (do_IC_clearing) {\n+              \/\/ compiled, dispatched call (which used to call an interpreted method)\n+              CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);\n+              inline_cache->set_to_clean();\n+            }\n@@ -1858,2 +1870,0 @@\n-  methodHandle callee_method = find_callee_method(caller_does_not_scalarize, CHECK_(methodHandle()));\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, bool& caller_is_c1, TRAPS);\n+  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, bool& caller_does_not_scalarize, TRAPS);\n@@ -396,1 +396,1 @@\n-  static methodHandle reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS);\n+  static methodHandle reresolve_call_site(bool& is_optimized, bool& caller_does_not_scalarize, TRAPS);\n@@ -400,1 +400,1 @@\n-  static methodHandle handle_ic_miss_helper(bool& caller_is_c1, TRAPS);\n+  static methodHandle handle_ic_miss_helper(bool& caller_does_not_scalarize, TRAPS);\n@@ -403,1 +403,1 @@\n-  static methodHandle find_callee_method(bool& caller_is_c1, TRAPS);\n+  static methodHandle find_callee_method(bool& caller_does_not_scalarize, TRAPS);\n@@ -572,1 +572,1 @@\n-                                            bool is_static_call, bool is_optimized, bool caller_is_c1);\n+                                            bool is_static_call, bool is_optimized, bool caller_does_not_scalarize);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -820,1 +820,2 @@\n-        startTest(cdlVirtual, Thread.ofVirtual(), iterations);\n+        \/\/ TODO: Disabling virtual threads until JDK-8370177 is fixed.\n+\/\/        startTest(cdlVirtual, Thread.ofVirtual(), iterations);\n@@ -822,1 +823,1 @@\n-        cdlVirtual.await();\n+\/\/        cdlVirtual.await();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestVirtualThreads.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}