{"files":[{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-\/**\n- * A tree node for a {@code default} instance initializion expression.\n- *\n- * For example:\n- * <pre>{@code\n- *   Optional<String>.default\n- * }<\/pre>\n- *\n- * @jls todo\n- *\n- * @since valhalla\n- *\/\n-public interface DefaultValueTree extends ExpressionTree {\n-\n-    \/**\n-     * Returns the name of the class of the instance being initialized.\n-     * @return the name\n-     *\/\n-    ExpressionTree getType();\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultValueTree.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -300,7 +300,0 @@\n-        \/**\n-         * Used for instances of {@link DefaultValueTree}.\n-         *\n-         * @since valhalla\n-         *\/\n-        DEFAULT_VALUE(DefaultValueTree.class),\n-\n@@ -357,5 +350,0 @@\n-        \/**\n-         * Used for instances of {@link WithFieldTree}.\n-         *\/\n-        WITH_FIELD(WithFieldTree.class),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -174,8 +174,0 @@\n-    \/**\n-     * Visits a {@code DefaultValue} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     *\/\n-    R visitDefaultValue(DefaultValueTree node, P p);\n-\n@@ -559,8 +551,0 @@\n-\n-    \/**\n-     * Visits a {@code WithFieldTree} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     *\/\n-    R visitWithField(WithFieldTree node, P p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-\/**\n- * A tree node for a {@code withfield} expression.\n- *\n- * For example:\n- * <pre>\n- *   x = __WithField(x.x, val)\n- * <\/pre>\n- *\n- * @since 1.11\n- *\/\n-public interface WithFieldTree extends ExpressionTree {\n-    \/**\n-     * Returns the field being updated.\n-     * @return the field\n-     *\/\n-    ExpressionTree getField();\n-\n-    \/**\n-     * Returns the value to which the field is updated.\n-     * @return the value\n-     *\/\n-    ExpressionTree getValue();\n-}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/WithFieldTree.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -239,14 +239,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     *\/\n-    @Override\n-    public R visitWithField(WithFieldTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n@@ -345,12 +331,0 @@\n-    public R visitDefaultValue(DefaultValueTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     *\/\n-    @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -307,16 +307,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     *\/\n-    @Override\n-    public R visitWithField(WithFieldTree node, P p) {\n-        R r = scan(node.getField(), p);\n-        r = scanAndReduce(node.getValue(), p, r);\n-        return r;\n-    }\n-\n@@ -432,12 +416,0 @@\n-    public R visitDefaultValue(DefaultValueTree node, P p) {\n-        return scan(node.getType(), p);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     *\/\n-    @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -604,2 +604,1 @@\n-        Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+        for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n@@ -625,1 +624,1 @@\n-        if (names.isInitOrVNew(methodName))\n+        if (methodName == names.init)\n@@ -1141,1 +1140,1 @@\n-                                  classType.tsym, classType.getMetadata(), classType.getFlavor()) {\n+                                  classType.tsym, classType.getMetadata()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -102,7 +102,0 @@\n-    \/** Marks a type as a primitive class. We can't reuse the class file encoding (ACC_PRIMITIVE)\n-     * since the latter shares its value (0x800) with ACC_STRICT (javac speak: STRICT_FP) and while\n-     * STRICT_FP is not a valid flag for a class in the class file level, javac's ASTs flag a class\n-     * as being STRICT_FP so as to propagate the FP strictness to methods of the class thereby causing\n-     * a clash *\/\n-    public static final int PRIMITIVE_CLASS  = 1<<16;\n-\n@@ -119,1 +112,0 @@\n-    public static final int ACC_PRIMITIVE = 0x0800;\n@@ -463,1 +455,1 @@\n-        AdjustedClassFlags                = ClassFlags | ACC_PRIMITIVE | ACC_VALUE;\n+        AdjustedClassFlags                = ClassFlags | ACC_VALUE;\n@@ -465,7 +457,7 @@\n-        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedLocalClassFlags           = (long) LocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedLocalClassFlags           = (long) LocalClassFlags | VALUE_CLASS,\n+        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n@@ -497,1 +489,0 @@\n-            if (0 != (flags & PRIMITIVE_CLASS))     modifiers.add(Modifier.PRIMITIVE);\n@@ -499,0 +490,1 @@\n+            if (0 != (flags & IDENTITY_TYPE))   modifiers.add(Modifier.IDENTITY);\n@@ -520,1 +512,0 @@\n-\n@@ -553,1 +544,0 @@\n-        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -237,10 +237,0 @@\n-        boolean isReferenceProjection;\n-        try {\n-            isReferenceProjection = t.isReferenceProjection();\n-        } catch (CompletionFailure cf) {\n-            isReferenceProjection = false; \/\/ handle missing types gracefully.\n-        }\n-        if (isReferenceProjection) {\n-            buf.append('.');\n-            buf.append(t.tsym.name.table.names.ref);\n-        }\n@@ -384,1 +374,3 @@\n-            String ms = s.isInitOrVNew() ? s.owner.name.toString() : s.name.toString();\n+            String ms = (s.name == s.name.table.names.init)\n+                    ? s.owner.name.toString()\n+                    : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-        PRIMITIVE_CLASSES(JDK21, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n@@ -308,3 +307,0 @@\n-            if (this == PRIMITIVE_CLASSES) {\n-                return Errors.PrimitiveClassesNotSupported(minLevel.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.HashMap;\n@@ -55,1 +54,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -360,1 +358,1 @@\n-        if (isInitOrVNew() && owner.hasOuterInstance()) {\n+        if (name == name.table.names.init && owner.hasOuterInstance()) {\n@@ -408,1 +406,1 @@\n-        return (flags() & INTERFACE) != 0;\n+        return (flags_field & INTERFACE) != 0;\n@@ -419,4 +417,0 @@\n-    public boolean isPrimitiveClass() {\n-        return (flags() & PRIMITIVE_CLASS) != 0;\n-    }\n-\n@@ -424,1 +418,1 @@\n-        return !isInterface() && (flags() & VALUE_CLASS) != 0;\n+        return !isInterface() && (flags_field & VALUE_CLASS) != 0;\n@@ -432,1 +426,1 @@\n-        return !isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+        return !isInterface() && (flags_field & IDENTITY_TYPE) != 0;\n@@ -436,1 +430,1 @@\n-        return isInterface() && (flags() & VALUE_CLASS) != 0;\n+        return isInterface() && (flags_field & VALUE_CLASS) != 0;\n@@ -440,1 +434,1 @@\n-        return isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+        return isInterface() && (flags_field & IDENTITY_TYPE) != 0;\n@@ -484,13 +478,1 @@\n-        return name == name.table.names.init && (flags() & STATIC) == 0;\n-    }\n-\n-    \/** Is this symbol a value object factory?\n-     *\/\n-    public boolean isValueObjectFactory() {\n-        return name == name.table.names.vnew && this.type.getReturnType().tsym == this.owner;\n-    }\n-\n-    \/** Is this symbol a constructor or value factory?\n-     *\/\n-    public boolean isInitOrVNew() {\n-        return name.table.names.isInitOrVNew(name);\n+        return name == name.table.names.init;\n@@ -1359,1 +1341,1 @@\n-                new ClassType(Type.noType, null, null, List.nil(), Flavor.X_Typeof_X),\n+                new ClassType(Type.noType, null, null, List.nil()),\n@@ -1396,2 +1378,1 @@\n-                                              type.getMetadata(),\n-                                              type.getFlavor());\n+                                              type.getMetadata());\n@@ -1463,8 +1444,0 @@\n-            } finally {\n-                if (this.type != null && this.type.hasTag(CLASS)) {\n-                    ClassType ct = (ClassType) this.type;\n-                    ct.flavor = ct.flavor.metamorphose((this.flags_field & PRIMITIVE_CLASS) != 0);\n-                    if (!this.type.isIntersection() && this.erasure_field != null && this.erasure_field.hasTag(CLASS)) {\n-                        ((ClassType) this.erasure_field).flavor = ct.flavor;\n-                    }\n-                }\n@@ -1658,1 +1631,0 @@\n-                classType.flavor = Flavor.X_Typeof_X;\n@@ -2022,1 +1994,1 @@\n-                String s = isInitOrVNew()\n+                String s = (name == name.table.names.init)\n@@ -2084,1 +2056,1 @@\n-            if (isInitOrVNew() || _other.kind != MTH) return false;\n+            if (isConstructor() || _other.kind != MTH) return false;\n@@ -2091,1 +2063,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null &&\n+                types.asSuper(owner.type, other.owner) != null &&\n@@ -2153,1 +2125,1 @@\n-            if (isInitOrVNew() || _other.kind != MTH) return false;\n+            if (isConstructor() || _other.kind != MTH) return false;\n@@ -2160,1 +2132,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n+                types.asSuper(owner.type, other.owner) != null) {\n@@ -2277,1 +2249,1 @@\n-            if (isInitOrVNew())\n+            if (name == name.table.names.init)\n@@ -2450,1 +2422,1 @@\n-                if (refSym.isInitOrVNew()) {\n+                if (refSym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":16,"deletions":44,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.WildcardType;\n@@ -69,1 +68,0 @@\n-import com.sun.tools.javac.util.Options;\n@@ -98,2 +96,0 @@\n-    private final boolean allowPrimitiveClasses;\n-\n@@ -294,12 +290,3 @@\n-                Type arg = null;\n-                if (type.getTag() == ARRAY || type.getTag() == CLASS) {\n-                    \/* Temporary treatment for primitive class: Given a primitive class V that implements\n-                       I1, I2, ... In, V.class is typed to be Class<? extends Object & I1 & I2 .. & In>\n-                    *\/\n-                    if (allowPrimitiveClasses && type.isPrimitiveClass()) {\n-                        List<Type> bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());\n-                        arg = new WildcardType(bounds.size() > 1 ? types.makeIntersectionType(bounds) : objectType, BoundKind.EXTENDS, boundClass);\n-                    } else {\n-                        arg = types.erasure(type);\n-                    }\n-                }\n+                Type arg;\n+                if (type.getTag() == ARRAY || type.getTag() == CLASS)\n+                    arg = types.erasure(type);\n@@ -695,2 +682,0 @@\n-        Options options = Options.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -235,4 +234,0 @@\n-    public boolean isPrimitiveClass() {\n-        return false;\n-    }\n-\n@@ -259,43 +254,1 @@\n-        if (this.isReferenceProjection())\n-            return true;\n-        return this.isValueClass() && !this.isPrimitiveClass();\n-    }\n-\n-    \/**\n-     * Return the `flavor' associated with a ClassType.\n-     * @see ClassType.Flavor\n-     *\/\n-    public Flavor getFlavor() {\n-        throw new AssertionError(\"Unexpected call to getFlavor() on a Type that is not a ClassType: \" + this);\n-    }\n-\n-    \/**\n-     * @return true IFF the receiver is a reference projection of a primitive class type and false\n-     * for primitives or plain references\n-     *\/\n-    public boolean isReferenceProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type valueProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type referenceProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n-     *\/\n-    public Type referenceProjectionOrSelf() {\n-        Type projection = referenceProjection();\n-        return projection != null ? projection : this;\n+        return this.isValueClass();\n@@ -318,1 +271,1 @@\n-            else return new ClassType(outer1, typarams1, t.tsym, t.metadata, t.getFlavor()) {\n+            else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {\n@@ -1056,34 +1009,0 @@\n-    public static class ConstantPoolQType implements PoolConstant {\n-\n-        public final Type type;\n-        final Types types;\n-\n-        public ConstantPoolQType(Type type, Types types) {\n-            this.type = type;\n-            this.types = types;\n-        }\n-\n-        @Override\n-        public Object poolKey(Types types) {\n-            return this;\n-        }\n-\n-        @Override\n-        public int poolTag() {\n-            return ClassFile.CONSTANT_Class;\n-        }\n-\n-        public int hashCode() {\n-            return types.hashCode(type);\n-        }\n-\n-        public boolean equals(Object obj) {\n-            return (obj instanceof ConstantPoolQType) &&\n-                    types.isSameType(type, ((ConstantPoolQType)obj).type);\n-        }\n-\n-        public String toString() {\n-            return type.toString();\n-        }\n-    }\n-\n@@ -1092,79 +1011,0 @@\n-\n-        \/**\n-         * The 'flavor' of a ClassType indicates its reference\/primitive projectionness\n-         * viewed against the default nature of the associated class.\n-         *\/\n-        public enum Flavor {\n-\n-            \/**\n-             * Classic reference type. Also reference projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            L_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            L_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            Q_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            Q_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            L_TypeOf_X,\n-\n-            \/**\n-             * Value projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            Q_TypeOf_X,\n-\n-            \/**\n-             *  As yet unknown projection type of an as yet unknown default provenance class.\n-             *\/\n-            X_Typeof_X,\n-\n-            \/**\n-             *  An error type - we don't care to discriminate them any further.\n-             *\/\n-             E_Typeof_X;\n-\n-            \/\/ We don't seem to need X_Typeof_L or X_Typeof_Q so far.\n-\n-            \/\/ Transform a larval form into a more evolved form\n-            public Flavor metamorphose(boolean isPrimtiveClass) {\n-\n-                switch (this) {\n-\n-                    case E_Typeof_X:  \/\/ stunted form\n-                    case L_TypeOf_L:\n-                    case L_TypeOf_Q:\n-                    case Q_TypeOf_L:\n-                    case Q_TypeOf_Q:\n-                            \/\/ These are fully evolved sealed forms or stunted - no futher transformation\n-                            return this;\n-                    case L_TypeOf_X:\n-                            return isPrimtiveClass ? L_TypeOf_Q : L_TypeOf_L;\n-                    case Q_TypeOf_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n-                    case X_Typeof_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n-                    default:\n-                            throw new AssertionError(\"Unexpected class type flavor\");\n-                }\n-            }\n-        }\n-\n@@ -1199,9 +1039,0 @@\n-        \/** The 'other' projection: If 'this' is type of a primitive class, then 'projection' is the\n-         *  reference projection type and vice versa. Lazily initialized, not to be accessed directly.\n-        *\/\n-        public ClassType projection;\n-\n-        \/** Is this L of default {L, Q, X} or Q of default {L, Q, X} ?\n-         *\/\n-        public Flavor flavor;\n-\n@@ -1213,5 +1044,1 @@\n-            this(outer, typarams, tsym, List.nil(), Flavor.L_TypeOf_L);\n-        }\n-\n-        public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym, Flavor flavor) {\n-            this(outer, typarams, tsym, List.nil(), flavor);\n+            this(outer, typarams, tsym, List.nil());\n@@ -1221,1 +1048,1 @@\n-                         List<TypeMetadata> metadata, Flavor flavor) {\n+                         List<TypeMetadata> metadata) {\n@@ -1228,1 +1055,0 @@\n-            this.flavor = flavor;\n@@ -1237,1 +1063,1 @@\n-            return new ClassType(outer_field, typarams_field, tsym, md, flavor) {\n+            return new ClassType(outer_field, typarams_field, tsym, md) {\n@@ -1288,11 +1114,0 @@\n-            boolean isReferenceProjection;\n-            try {\n-                isReferenceProjection = isReferenceProjection();\n-            } catch (CompletionFailure cf) {\n-                isReferenceProjection = false; \/\/ handle missing types gracefully.\n-            }\n-            if (isReferenceProjection) {\n-                buf.append('.');\n-                buf.append(tsym.name.table.names.ref);\n-            }\n-\n@@ -1337,4 +1152,0 @@\n-        public Flavor getFlavor() {\n-            return flavor;\n-        }\n-\n@@ -1357,3 +1168,0 @@\n-            if (outer_field != null && outer_field.isReferenceProjection()) {\n-                outer_field = outer_field.valueProjection();\n-            }\n@@ -1391,5 +1199,0 @@\n-        @Override\n-        public boolean isPrimitiveClass() {\n-            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n-        }\n-\n@@ -1398,1 +1201,1 @@\n-            return !isReferenceProjection() && tsym != null && tsym.isValueClass();\n+            return tsym != null && tsym.isValueClass();\n@@ -1408,1 +1211,1 @@\n-            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n+            return tsym != null && tsym.isIdentityClass();\n@@ -1416,49 +1219,0 @@\n-        @Override\n-        public boolean isReferenceProjection() {\n-            \/\/ gaurd against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n-                }\n-            }\n-            return flavor == Flavor.L_TypeOf_Q;\n-        }\n-\n-        @Override\n-        public Type valueProjection() {\n-            if (!isReferenceProjection())\n-                return null;\n-\n-            if (projection !=  null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n-        }\n-\n-        \/\/ return the reference projection type preserving parameterizations\n-        @Override\n-        public ClassType referenceProjection() {\n-\n-            if (!isPrimitiveClass())\n-                return null;\n-\n-            if (projection != null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.L_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n-        }\n-\n@@ -1513,1 +1267,1 @@\n-            super(outer, List.nil(), tsym, metadata, tsym.type.getFlavor());\n+            super(outer, List.nil(), tsym, metadata);\n@@ -2624,1 +2378,1 @@\n-            super(noType, List.nil(), tsym, List.nil(), Flavor.E_Typeof_X);\n+            super(noType, List.nil(), tsym, List.nil());\n@@ -2629,2 +2383,2 @@\n-                          List<TypeMetadata> metadata, Flavor flavor) {\n-            super(noType, List.nil(), null, metadata, flavor);\n+                          List<TypeMetadata> metadata) {\n+            super(noType, List.nil(), null, metadata);\n@@ -2637,1 +2391,1 @@\n-            return new ErrorType(originalType, tsym, md, getFlavor()) {\n+            return new ErrorType(originalType, tsym, md) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":12,"deletions":258,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-                    !s.isInitOrVNew())\n+                    !s.isConstructor())\n@@ -245,1 +245,1 @@\n-                    (s.kind == MTH && !s.isInitOrVNew() &&\n+                    (s.kind == MTH && !s.isConstructor() &&\n@@ -247,1 +247,1 @@\n-                    (s.kind == MTH && s.isInitOrVNew()))\n+                    (s.kind == MTH && s.isConstructor()))\n@@ -607,1 +607,1 @@\n-                                                      t.getMetadata(), t.getFlavor());\n+                                                      t.getMetadata());\n@@ -1025,1 +1025,1 @@\n-                    } else if (exsym.isInitOrVNew()) {\n+                    } else if (exsym.isConstructor()) {\n@@ -1132,1 +1132,1 @@\n-                    if (tree.sym.isInitOrVNew()) {\n+                    if (tree.sym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -94,1 +95,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -122,3 +122,6 @@\n-        noWarnings = new Warner(null);\n-        Options options = Options.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        noWarnings = new Warner(null) {\n+            @Override\n+            public String toString() {\n+                return \"NO_WARNINGS\";\n+            }\n+        };\n@@ -273,1 +276,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.getFlavor()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {\n@@ -604,11 +607,0 @@\n-\n-        if (allowPrimitiveClasses) {\n-            boolean tValue = t.isPrimitiveClass();\n-            boolean sValue = s.isPrimitiveClass();\n-            if (tValue != sValue) {\n-                return tValue ?\n-                        isSubtype(t.referenceProjection(), s) :\n-                        !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n-            }\n-        }\n-\n@@ -981,1 +973,1 @@\n-                        !names.isInitOrVNew(t.name) &&\n+                        t.name != names.init &&\n@@ -1048,27 +1040,5 @@\n-            if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n-                if (((ArrayType)t).elemtype.isPrimitive()) {\n-                    return isSameType(elemtype(t), elemtype(s));\n-                } else {\n-                    \/\/ if T.ref <: S, then T[] <: S[]\n-                    Type es = elemtype(s);\n-                    Type et = elemtype(t);\n-                    if (allowPrimitiveClasses) {\n-                        if (et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n-                    }\n-                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n-                        return false;\n-                    return true;\n-                }\n-            } else if (isSubtype(t, s, capture)) {\n-                return true;\n-            } else if (t.hasTag(TYPEVAR)) {\n-                return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n-            } else if (!s.isRaw()) {\n-                Type t2 = asSuper(t, s.tsym);\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+            try {\n+                warnStack = warnStack.prepend(warn);\n+                if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n+                    if (((ArrayType)t).elemtype.isPrimitive()) {\n+                        return isSameType(elemtype(t), elemtype(s));\n@@ -1076,1 +1046,6 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        \/\/ if T.ref <: S, then T[] <: S[]\n+                        Type es = elemtype(s);\n+                        Type et = elemtype(t);\n+                        if (!isSubtypeUncheckedInternal(et, es, false, warn))\n+                            return false;\n+                        return true;\n@@ -1078,0 +1053,1 @@\n+                } else if (isSubtype(t, s, capture)) {\n@@ -1079,0 +1055,12 @@\n+                } else if (t.hasTag(TYPEVAR)) {\n+                    return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n+                } else if (!s.isRaw()) {\n+                    Type t2 = asSuper(t, s.tsym);\n+                    if (t2 != null && t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n+                    }\n@@ -1080,0 +1068,3 @@\n+                return false;\n+            } finally {\n+                warnStack = warnStack.tail;\n@@ -1081,1 +1072,0 @@\n-            return false;\n@@ -1139,1 +1129,0 @@\n-\n@@ -1143,2 +1132,2 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        private IsSubtype isSubtype = new IsSubtype();\n+        class IsSubtype extends TypeRelation {\n@@ -1161,2 +1150,2 @@\n-                         s.hasTag(BOT) || (s.hasTag(CLASS) && (!allowPrimitiveClasses || !s.isPrimitiveClass())) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n@@ -1228,1 +1217,0 @@\n-                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1240,11 +1228,2 @@\n-                    else {\n-                        \/\/ if T.ref <: S, then T[] <: S[]\n-                        Type es = elemtype(s);\n-                        Type et = elemtype(t);\n-                        if (allowPrimitiveClasses && et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n-                        return isSubtypeNoCapture(et, es);\n-                    }\n+                    else\n+                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n@@ -1282,1 +1261,1 @@\n-        };\n+        }\n@@ -1470,12 +1449,3 @@\n-                    && t.isReferenceProjection() == s.isReferenceProjection()\n-                    && visit(getEnclosingType(t), getEnclosingType(s))\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n-            }\n-                \/\/ where\n-                private Type getEnclosingType(Type t) {\n-                    Type et = t.getEnclosingType();\n-                    if (et.isReferenceProjection()) {\n-                        et = et.valueProjection();\n-                    }\n-                    return et;\n-                }\n+                        && visit(t.getEnclosingType(), s.getEnclosingType())\n+                        && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+            }\n@@ -1641,9 +1611,0 @@\n-\n-                    \/\/ -----------------------------------  Unspecified behavior ----------------\n-\n-                    \/* If a primitive class V implements an interface I, then does \"? extends I\" contain V?\n-                       It seems widening must be applied here to answer yes to compile some common code\n-                       patterns.\n-                    *\/\n-\n-                    \/\/ ---------------------------------------------------------------------------\n@@ -1739,1 +1700,1 @@\n-            if (isSubtype(erasure(ts.type.referenceProjectionOrSelf()), erasure(ss.type))) {\n+            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n@@ -1794,1 +1755,1 @@\n-                if (s.hasTag(ERROR) || (s.hasTag(BOT) && (!allowPrimitiveClasses || !t.isPrimitiveClass())))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT))\n@@ -1813,10 +1774,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        if (t.isPrimitiveClass()) {\n-                            \/\/ (s) Value ? == (s) Value.ref\n-                            t = t.referenceProjection();\n-                        }\n-                        if (s.isPrimitiveClass()) {\n-                            \/\/ (Value) t ? == (Value.ref) t\n-                            s = s.referenceProjection();\n-                        }\n-                    }\n@@ -2199,0 +2150,4 @@\n+        return makeArrayType(t, 1);\n+    }\n+\n+    public ArrayType makeArrayType(Type t, int dimensions) {\n@@ -2202,1 +2157,15 @@\n-        return new ArrayType(t, syms.arrayClass);\n+        ArrayType result = new ArrayType(t, syms.arrayClass);\n+        for (int i = 1; i < dimensions; i++) {\n+            result = new ArrayType(result, syms.arrayClass);\n+        }\n+        return result;\n+    }\n+    \/\/ <\/editor-fold>\n+\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n@@ -2216,29 +2185,0 @@\n-     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n-     * this method.\n-     *\n-     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n-     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This MAY NOT BE correct\n-     *    depending on the call site. Foo.val is NOT a super type of Foo.ref either in the language\n-     *    model or in the VM's world view. An example of such an hazardous call used to exist in\n-     *    Gen.visitTypeCast. When we emit code for  (Foo) Foo.ref.instance a check for whether we\n-     *    really need the cast cannot\/shouldn't be gated on\n-     *\n-     *        asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n-     *\n-     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n-     *    types. When we operate in terms of symbols, there is a loss of type information leading\n-     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n-     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n-     *    may be required at the call site. Also where the concerned symbol corresponds to a\n-     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n-     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n-     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n-     *\n-     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n-     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n-     *    that is NOT what we want. An example of such a hazardous call used to occur in\n-     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n-     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n-     *    These hazardous calls should be rewritten as\n-     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n-     *\n@@ -2257,6 +2197,0 @@\n-\n-        if (allowPrimitiveClasses && t.isPrimitiveClass()) {\n-            \/\/ No man may be an island, but the bell tolls for a value.\n-            return t.tsym == sym ? t : null;\n-        }\n-\n@@ -2393,12 +2327,3 @@\n-\n-        if ((sym.flags() & STATIC) != 0)\n-            return sym.type;\n-\n-        \/* If any primitive class types are involved, switch over to the reference universe,\n-           where the hierarchy is navigable. V and V.ref have identical membership\n-           with no bridging needs.\n-        *\/\n-        if (allowPrimitiveClasses && t.isPrimitiveClass())\n-            t = t.referenceProjection();\n-\n-        return memberType.visit(t, sym);\n+        return (sym.flags() & STATIC) != 0\n+            ? sym.type\n+            : memberType.visit(t, sym);\n@@ -2533,1 +2458,1 @@\n-                        default: return s.dropMetadata(Annotations.class);\n+                        default: return s.cloneWithMetadata(t.getMetadata()).dropMetadata(Annotations.class);\n@@ -2557,19 +2482,7 @@\n-                \/\/ erasure(projection(primitive)) = projection(erasure(primitive))\n-                Type erased = eraseClassType(t, recurse);\n-                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n-                    erased = new ClassType(erased.getEnclosingType(),\n-                            List.nil(), erased.tsym,\n-                            erased.getMetadata(), t.flavor);\n-                }\n-                return erased;\n-            }\n-                \/\/ where\n-                private Type eraseClassType(ClassType t, Boolean recurse) {\n-                    Type erased = t.tsym.erasure(Types.this);\n-                    if (recurse) {\n-                        erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n-                                                     t.dropMetadata(Annotations.class).getMetadata());\n-                        return erased;\n-                    } else {\n-                        return combineMetadata(erased, t);\n-                    }\n+                Type erased = t.tsym.erasure(Types.this);\n+                if (recurse) {\n+                    erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n+                            t.dropMetadata(Annotations.class).getMetadata());\n+                    return erased;\n+                } else {\n+                    return combineMetadata(erased, t);\n@@ -2577,0 +2490,1 @@\n+            }\n@@ -2896,1 +2810,1 @@\n-                                         t.getMetadata(), t.getFlavor());\n+                                         t.getMetadata());\n@@ -2926,1 +2840,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -4017,1 +3940,1 @@\n-                                 class1.tsym, List.nil(), class1.getFlavor());\n+                                 class1.tsym, List.nil());\n@@ -4397,4 +4320,6 @@\n-        if (isSameType(r1.getReturnType(), r2res))\n-            return true;\n-        if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n-            return false;\n+        try {\n+            warnStack = warnStack.prepend(warner);\n+            if (isSameType(r1.getReturnType(), r2res))\n+                return true;\n+            if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n+                return false;\n@@ -4402,3 +4327,7 @@\n-        if (hasSameArgs(r1, r2))\n-            return covariantReturnType(r1.getReturnType(), r2res, warner);\n-        if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n+            if (hasSameArgs(r1, r2))\n+                return covariantReturnType(r1.getReturnType(), r2res, warner);\n+            if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n+                return true;\n+            if (!isSubtype(r1.getReturnType(), erasure(r2res), false))\n+                return false;\n+            warner.warn(LintCategory.UNCHECKED);\n@@ -4406,4 +4335,3 @@\n-        if (!isSubtype(r1.getReturnType(), erasure(r2res)))\n-            return false;\n-        warner.warn(LintCategory.UNCHECKED);\n-        return true;\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -4577,1 +4505,1 @@\n-                                 cls.getMetadata(), cls.getFlavor());\n+                                 cls.getMetadata());\n@@ -5251,4 +5179,1 @@\n-                    if (types.allowPrimitiveClasses && type.isPrimitiveClass())\n-                        append('Q');\n-                    else\n-                        append('L');\n+                    append('L');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":109,"deletions":184,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -559,1 +559,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -170,1 +169,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -191,1 +190,1 @@\n-    boolean allowPrimitiveClasses;\n+    boolean allowValueClasses;\n@@ -281,1 +280,1 @@\n-            ((names.isInitOrVNew(owner.name) ||    \/\/ i.e. we are in a constructor\n+            ((owner.name == names.init ||    \/\/ i.e. we are in a constructor\n@@ -808,1 +807,1 @@\n-                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n+                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env)));\n@@ -810,1 +809,1 @@\n-                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n+                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env)));\n@@ -1080,1 +1079,1 @@\n-                if (names.isInitOrVNew(tree.name)) {\n+                if (names.isInit(tree.name)) {\n@@ -1195,1 +1194,1 @@\n-                if (names.isInitOrVNew(tree.name) && owner.type != syms.objectType) {\n+                if (names.isInit(tree.name) && owner.type != syms.objectType) {\n@@ -1566,1 +1565,1 @@\n-                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n@@ -1582,1 +1581,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n@@ -2019,1 +2018,1 @@\n-            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n@@ -2208,2 +2207,1 @@\n-            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n-            \/\/ value conversions bring about a convergence.\n+            \/\/ Those were all the cases that could result in a primitive\n@@ -2211,2 +2209,1 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n-                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n@@ -2223,1 +2220,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n@@ -2226,1 +2223,1 @@\n-            \/\/ both are known to be reference types (or projections).  The result is\n+            \/\/ both are known to be reference types.  The result is\n@@ -2664,4 +2661,0 @@\n-                \/\/ Special treatment for primitive classes: Given an expression v of type V where\n-                \/\/ V is a primitive class, v.getClass() is typed to be Class<? extends |V.ref|>\n-                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n-                                         qualifierType.referenceProjection() : qualifierType.baseType());\n@@ -2669,1 +2662,1 @@\n-                        List.of(new WildcardType(wcb,\n+                        List.of(new WildcardType(types.erasure(qualifierType.baseType()),\n@@ -2673,2 +2666,1 @@\n-                        restype.getMetadata(),\n-                        restype.getFlavor());\n+                        restype.getMetadata());\n@@ -2694,1 +2686,1 @@\n-            if (enclMethod != null && names.isInitOrVNew(enclMethod.name)) {\n+            if (enclMethod != null && names.isInit(enclMethod.name)) {\n@@ -2843,10 +2835,0 @@\n-            \/\/ Check that it is an instantiation of a class and not a projection type\n-            if (allowPrimitiveClasses) {\n-                if (clazz.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n-                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n-                    }\n-                }\n-            }\n@@ -2877,2 +2859,1 @@\n-                                               clazztype.getMetadata(),\n-                                               clazztype.getFlavor());\n+                                               clazztype.getMetadata());\n@@ -2939,1 +2920,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -2941,0 +2922,1 @@\n+            }\n@@ -3032,3 +3014,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n-                    }\n@@ -3107,3 +3086,0 @@\n-        \/\/ Likewise arg can't be null if it is a primitive class instance.\n-        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n-            return arg;\n@@ -3599,2 +3575,1 @@\n-                    Name constructorName = owner.isConcreteValueClass() ? names.vnew : names.init;\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(constructorName)) {\n+                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n@@ -3665,4 +3640,0 @@\n-                \/\/ TODO - a bit hacky but...\n-                if (lhsSym != null && lhsSym.isConcreteValueClass() && that.name == names.init) {\n-                    that.name = names.vnew;\n-                }\n@@ -3757,1 +3728,1 @@\n-            that.sym = refSym.isInitOrVNew() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;\n@@ -4447,9 +4418,0 @@\n-        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n-            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-             * always matching the behavior of Object::getClass\n-             *\/\n-             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n-                 tree.selected.setType(site = site.referenceProjection());\n-             }\n-        }\n@@ -4572,1 +4534,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n@@ -4615,2 +4577,0 @@\n-                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n-                    return site.tsym;\n@@ -4723,3 +4683,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n-                    }\n@@ -4729,8 +4686,1 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference projection\n-                    \/\/ is requested via the .ref notation, then adjust the computed type to\n-                    \/\/ reflect this.\n-                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n-                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                    }\n-\n-                    \/\/ (b) If the symbol's type is parameterized, erase it\n+                    \/\/ If the symbol's type is parameterized, erase it\n@@ -4763,1 +4713,1 @@\n-                                owntype.getMetadata(), owntype.getFlavor());\n+                                owntype.getMetadata());\n@@ -4827,1 +4777,1 @@\n-            if (!names.isInitOrVNew(sym.name) || tree.hasTag(REFERENCE)) {\n+            if (sym.name != names.init || tree.hasTag(REFERENCE)) {\n@@ -5081,31 +5031,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        if (!allowPrimitiveClasses) {\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n-        }\n-\n-        \/\/ Attribute the qualifier expression, and determine its symbol (if any).\n-        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n-        if (!pkind().contains(KindSelector.TYP_PCK))\n-            site = capture(site); \/\/ Capture field access\n-        if (!allowPrimitiveClasses) {\n-            result = types.createErrorType(names._default, site.tsym, site);\n-        } else {\n-            Symbol sym = switch (site.getTag()) {\n-                case WILDCARD -> throw new AssertionError(tree);\n-                case PACKAGE -> {\n-                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                    yield syms.errSymbol;\n-                }\n-                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n-            };\n-\n-            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-                site = types.skipTypeVars(site, true);\n-            }\n-            result = checkId(tree, site, sym, env, resultInfo);\n-        }\n-    }\n-\n@@ -5199,1 +5118,1 @@\n-                                        clazztype.getMetadata(), clazztype.getFlavor());\n+                                        clazztype.getMetadata());\n@@ -5326,1 +5245,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n+                make.Modifiers(PUBLIC | ABSTRACT),\n@@ -5349,1 +5268,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n@@ -5467,1 +5386,1 @@\n-            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n+            if (c.type.isValueClass()) {\n@@ -5649,1 +5568,1 @@\n-                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                    chk.checkConstraintsOfValueClass((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":31,"deletions":112,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -187,1 +188,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -231,1 +232,1 @@\n-    \/** Are primitive classes allowed\n+    \/** Are value classes allowed\n@@ -233,1 +234,1 @@\n-    private final boolean allowPrimitiveClasses;\n+    private final boolean allowValueClasses;\n@@ -646,5 +647,0 @@\n-        } else {\n-            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n-            }\n@@ -724,1 +720,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -729,1 +725,1 @@\n-             return types.isSubtype(a, bound);\n+             return types.isSubtype(a, bound, true);\n@@ -781,1 +777,2 @@\n-    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+    void checkConstraintsOfValueClass(JCClassDecl tree, ClassSymbol c) {\n+        DiagnosticPosition pos = tree.pos();\n@@ -812,1 +809,1 @@\n-                    } else if (s.isInitOrVNew()) {\n+                    } else if (s.isConstructor()) {\n@@ -844,9 +841,0 @@\n-                \/\/ Projection types may not be mentioned in constructor references\n-                if (expr.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n-                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n-                        t = types.createErrorType(t);\n-                    }\n-                }\n@@ -888,1 +876,0 @@\n-     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -890,2 +877,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n-        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        if (t.isReference())\n@@ -899,3 +886,3 @@\n-    \/** Check that type is an identity type, i.e. not a primitive\/value type\n-     *  nor its reference projection. When not discernible statically,\n-     *  give it the benefit of doubt and defer to runtime.\n+    \/** Check that type is an identity type, i.e. not a value type.\n+     *  When not discernible statically, give it the benefit of doubt\n+     *  and defer to runtime.\n@@ -917,1 +904,1 @@\n-        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface())\n@@ -921,9 +908,0 @@\n-    \/** Check that type is a reference type, i.e. a class, interface or array type\n-     *  or a type variable.\n-     *  @param pos           Position to be used for error reporting.\n-     *  @param t             The type to be checked.\n-     *\/\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        return checkRefType(pos, t, true);\n-    }\n-\n@@ -938,1 +916,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head, false);\n+            l.head = checkRefType(tl.head.pos(), l.head);\n@@ -974,49 +952,0 @@\n-    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n-    }\n-\n-    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n-     *  being used as type arguments and issues error against those usages.\n-     *\/\n-    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n-            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n-\n-        @Override\n-        public Void visitType(Type t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n-            for (Type targ : t.allparams()) {\n-                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n-                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n-                }\n-                visit(targ, pos);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n-             return null;\n-        }\n-\n-        @Override\n-        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n-            return visit(t.elemtype, pos);\n-        }\n-\n-        @Override\n-        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n-            return visit(t.type, pos);\n-        }\n-    };\n-\n-\n-\n@@ -1155,1 +1084,1 @@\n-                (s.isInitOrVNew() ||\n+                (s.isConstructor() ||\n@@ -1171,5 +1100,1 @@\n-        Type varType = types.upward(t, types.captures(t)).baseType();\n-        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n-            checkParameterizationByPrimitiveClass(pos, varType);\n-        }\n-        return varType;\n+        return types.upward(t, types.captures(t)).baseType();\n@@ -1198,1 +1123,0 @@\n-        \/\/ TODO - is enum so <init>\n@@ -1266,1 +1190,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1269,1 +1197,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1306,1 +1234,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1382,1 +1310,1 @@\n-            if (names.isInitOrVNew(sym.name)) {\n+            if (sym.name == names.init) {\n@@ -1447,2 +1375,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE_CLASS);\n@@ -1462,4 +1390,0 @@\n-            \/\/ primitive classes are implicitly final value classes.\n-            if ((flags & PRIMITIVE_CLASS) != 0)\n-                implicit |= VALUE_CLASS | FINAL;\n-\n@@ -1506,1 +1430,1 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED)\n@@ -1510,1 +1434,1 @@\n-                        PRIMITIVE_CLASS | VALUE_CLASS)\n+                        VALUE_CLASS)\n@@ -1656,1 +1580,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1715,2 +1639,1 @@\n-                tree.selected.type.isParameterized() &&\n-                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n+                tree.selected.type.isParameterized()) {\n@@ -1720,2 +1643,0 @@\n-                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n-                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -1785,1 +1706,1 @@\n-                    env.enclMethod != null && names.isInitOrVNew(env.enclMethod.name);\n+                    env.enclMethod != null && env.enclMethod.name == names.init;\n@@ -2386,1 +2307,1 @@\n-                (env.info.isAnonymousDiamond && !m.isInitOrVNew() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isConstructor() && !m.isPrivate());\n@@ -2544,1 +2465,1 @@\n-        if (allowPrimitiveClasses) {\n+        if (allowValueClasses) {\n@@ -2578,1 +2499,1 @@\n-            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n+            return false; \/\/ (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n@@ -2946,1 +2867,1 @@\n-                     !s.isInitOrVNew();\n+                     !s.isConstructor();\n@@ -3005,1 +2926,1 @@\n-                     !s.isInitOrVNew();\n+                     !s.isConstructor();\n@@ -3888,1 +3809,1 @@\n-                if (s.kind == MTH && !s.isInitOrVNew())\n+                if (s.kind == MTH && !s.isConstructor())\n@@ -3896,1 +3817,1 @@\n-                if (s.kind == MTH && s.isInitOrVNew())\n+                if (s.kind == MTH && s.isConstructor())\n@@ -3915,1 +3836,1 @@\n-                        (s.kind == MTH && !s.isInitOrVNew() &&\n+                        (s.kind == MTH && !s.isConstructor() &&\n@@ -3917,1 +3838,1 @@\n-                        (s.kind == MTH && s.isInitOrVNew())) {\n+                        (s.kind == MTH && s.isConstructor())) {\n@@ -4507,0 +4428,1 @@\n+            this.warned = true;\n@@ -5258,1 +5180,1 @@\n-                    if (sym.isInitOrVNew() &&\n+                    if (sym.isConstructor() &&\n@@ -5286,1 +5208,1 @@\n-                        if (sym.isInitOrVNew()) {\n+                        if (sym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":45,"deletions":123,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -108,1 +107,0 @@\n-    boolean allowPrimitiveClasses;\n@@ -149,2 +147,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -512,4 +508,0 @@\n-        if (allowPrimitiveClasses) {\n-            ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n-        }\n-\n@@ -534,6 +526,0 @@\n-        if (allowPrimitiveClasses && ct.isPrimitiveClass()) {\n-            if (ct.projection != null) {\n-                ct.projection.typarams_field = ct.typarams_field;\n-                ct.projection.allparams_field = ct.allparams_field;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1601,1 +1601,1 @@\n-                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n+                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-                Name name = msym.name.table.names.isInitOrVNew(msym.name) ?\n+                Name name = msym.name == msym.name.table.names.init ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,2 +356,1 @@\n-            \/\/ TODO - can <vnew> exist in this context?\n-            if ((init = names.isInitOrVNew(owner.name)) || owner.name == names.clinit) {\n+            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {\n@@ -1672,2 +1671,1 @@\n-                Name constructorName = csym.isConcreteValueClass() ? names.vnew : names.init;\n-                for (Symbol s : csym.members_field.getSymbolsByName(constructorName)) {\n+                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n@@ -1777,1 +1775,1 @@\n-                    && !names.isInitOrVNew(sym.name);\n+                    && sym.name != names.init;\n@@ -1875,1 +1873,1 @@\n-                return types.asSuper(tree.target.referenceProjectionOrSelf(), syms.serializableType.tsym) != null;\n+                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n@@ -1899,2 +1897,0 @@\n-                } else if (methodName.equals(\"<vnew>\")) {\n-                    methodName = \"vnew\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-    private final boolean allowPrimitiveClasses;\n@@ -134,1 +133,0 @@\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -1148,1 +1146,1 @@\n-        } else if (names.isInitOrVNew(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n+        } else if (sym.name == names.init && sym.owner.isDirectlyOrIndirectlyLocal()) {\n@@ -1237,3 +1235,0 @@\n-                \/\/ Make sure not to lose type fidelity due to symbol sharing between projections\n-                boolean requireReferenceProjection = allowPrimitiveClasses &&\n-                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref && tree.type.isReferenceProjection();\n@@ -1255,3 +1250,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1261,3 +1253,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1361,1 +1350,0 @@\n-                Name constructorName = accOwner.isConcreteValueClass() ? names.vnew : names.init;\n@@ -1364,1 +1352,1 @@\n-                    constructorName,\n+                    names.init,\n@@ -1408,1 +1396,1 @@\n-        if (names.isInitOrVNew(sym.name)) {\n+        if (sym.name == names.init) {\n@@ -1621,1 +1609,1 @@\n-            (owner.isInitOrVNew() && owner.isAnonymous()) ||\n+            (owner.isConstructor() && owner.isAnonymous()) ||\n@@ -1623,1 +1611,1 @@\n-            (owner.isInitOrVNew() && c.isInner() &&\n+            (owner.isConstructor() && c.isInner() &&\n@@ -1820,1 +1808,1 @@\n-        if (types.asSuper(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) == null) {\n+        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {\n@@ -2204,2 +2192,1 @@\n-        return (tree == null) ? null :\n-                applyPrimitiveConversionsAsNeeded(boxIfNeeded(translate(tree), type), type);\n+        return (tree == null) ? null : boxIfNeeded(translate(tree), type);\n@@ -2796,1 +2783,1 @@\n-        if (names.isInitOrVNew(tree.name) &&\n+        if (tree.name == names.init &&\n@@ -2877,1 +2864,1 @@\n-        if (names.isInitOrVNew(tree.name) && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+        if (tree.name == names.init && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n@@ -3119,2 +3106,1 @@\n-        \/\/ TODO - is enum so always <init>.\n-        if (names.isInitOrVNew(meth.name) && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym)\n@@ -3125,1 +3111,1 @@\n-        if (names.isInitOrVNew(meth.name)) {\n+        if (meth.name==names.init) {\n@@ -3233,11 +3219,0 @@\n-    \/** Apply primitive value\/reference conversions as needed *\/\n-    @SuppressWarnings(\"unchecked\")\n-    <T extends JCExpression> T applyPrimitiveConversionsAsNeeded(T tree, Type type) {\n-        boolean haveValue = tree.type.isPrimitiveClass();\n-        if (haveValue == type.isPrimitiveClass())\n-            return tree;\n-        \/\/ For narrowing conversion, insert a cast which should trigger a null check\n-        \/\/ For widening conversions, insert a cast if emitting a unified class file.\n-        return (T) make.TypeCast(type, tree);\n-    }\n-\n@@ -3642,1 +3617,1 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n@@ -3652,1 +3627,1 @@\n-            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n+            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n@@ -3731,17 +3706,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        Type fieldType = tree.field.type;\n-        tree.field = translate(tree.field, tree);\n-        tree.value = translate(tree.value, fieldType); \/\/ important to use pre-translation type.\n-\n-        \/\/ If translated field is an Apply, we are\n-        \/\/ seeing an access method invocation. In this case, append\n-        \/\/ right hand side as last argument of the access method.\n-        if (tree.field.hasTag(APPLY)) {\n-            JCMethodInvocation app = (JCMethodInvocation) tree.field;\n-            app.args = List.of(tree.value).prependList(app.args);\n-            result = app;\n-        } else {\n-            result = tree;\n-        }\n-    }\n-\n@@ -4244,5 +4202,0 @@\n-        \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-         * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-         * always matching the behavior of Object::getClass\n-         *\/\n-        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isReferenceProjection();\n@@ -4250,3 +4203,0 @@\n-        if (needPrimaryMirror && allowPrimitiveClasses && tree.selected.type.isPrimitiveClass()) {\n-            tree.selected.setType(tree.selected.type.referenceProjection());\n-        }\n@@ -4260,1 +4210,1 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n+            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":14,"deletions":64,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -190,3 +190,0 @@\n-        if (tree.name == tree.name.table.names.init && allowValueClasses && enclScope.owner.isConcreteValueClass()) {\n-            tree.name = tree.name.table.names.vnew;\n-        }\n@@ -246,1 +243,1 @@\n-        if (m.isInitOrVNew() && m.type.getParameterTypes().size() == 0) {\n+        if (m.isConstructor() && m.type.getParameterTypes().size() == 0) {\n@@ -364,1 +361,1 @@\n-        if (m.isInitOrVNew()) {\n+        if (m.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1059,2 +1059,1 @@\n-            Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n-            for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+            for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -154,1 +153,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -224,1 +222,1 @@\n-        if (names.isInitOrVNew(bestSoFar.name) &&\n+        if (bestSoFar.name == names.init &&\n@@ -297,1 +295,1 @@\n-        return owner.isInitOrVNew() ||\n+        return owner.isConstructor() ||\n@@ -409,1 +407,1 @@\n-        if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) return false;\n+        if (sym.name == names.init && sym.owner != site.tsym) return false;\n@@ -423,14 +421,0 @@\n-        if (allowPrimitiveClasses) {\n-            if (sym.kind == MTH || sym.kind == VAR) {\n-                \/* If any primitive class types are involved, ask the same question in the reference universe,\n-                   where the hierarchy is navigable\n-                *\/\n-                if (site.isPrimitiveClass())\n-                    site = site.referenceProjection();\n-            } else if (sym.kind == TYP) {\n-                \/\/ A type is accessible in a reference projection if it was\n-                \/\/ accessible in the value projection.\n-                if (site.isReferenceProjection())\n-                    site = site.valueProjection();\n-            }\n-        }\n@@ -488,1 +472,1 @@\n-        if (sym.kind != MTH || sym.isInitOrVNew() || sym.isStatic())\n+        if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())\n@@ -491,7 +475,0 @@\n-        \/* If any primitive class types are involved, ask the same question in the reference universe,\n-           where the hierarchy is navigable\n-        *\/\n-        if (allowPrimitiveClasses && site.isPrimitiveClass()) {\n-            site = site.referenceProjection();\n-        }\n-\n@@ -1720,1 +1697,1 @@\n-                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n@@ -1725,1 +1702,1 @@\n-                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n@@ -1892,1 +1869,1 @@\n-            if (names.isInitOrVNew(name)) return bestSoFar;\n+            if (name == names.init) return bestSoFar;\n@@ -2936,2 +2913,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -2971,1 +2947,0 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2973,1 +2948,1 @@\n-                                    constructorName, argtypes,\n+                                    names.init, argtypes,\n@@ -2996,1 +2971,0 @@\n-        Name constructorName = allowValueClasses && site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2998,1 +2972,1 @@\n-                new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -3013,1 +2987,1 @@\n-                                sym = accessMethod(sym, pos, site, constructorName, true, argtypes, typeargtypes);\n+                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);\n@@ -3060,2 +3034,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        for (final Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n@@ -3070,1 +3043,1 @@\n-                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), constructorName, constrType, site.tsym) {\n+                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {\n@@ -3112,1 +3085,1 @@\n-        if (!names.isInitOrVNew(name)) {\n+        if (!name.equals(names.init)) {\n@@ -3627,1 +3600,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n@@ -3680,1 +3653,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n@@ -3706,1 +3679,1 @@\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3738,1 +3711,1 @@\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3742,1 +3715,1 @@\n-                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata(), site.getFlavor());\n+                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata());\n@@ -3832,1 +3805,1 @@\n-                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n@@ -4145,1 +4118,1 @@\n-            boolean isConstructor = names.isInitOrVNew(name);\n+            boolean isConstructor = name == names.init;\n@@ -4244,1 +4217,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n@@ -4261,1 +4234,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n@@ -4318,1 +4291,1 @@\n-                boolean isConstructor = names.isInitOrVNew(name);\n+                boolean isConstructor = names.isInit(name);\n@@ -4327,2 +4300,2 @@\n-                        isConstructor ? KindName.CONSTRUCTOR : kind.absentKind(),\n-                        isConstructor ? site.tsym.name : name,\n+                        name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),\n+                        name == names.init ? site.tsym.name : name,\n@@ -4488,1 +4461,1 @@\n-            if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) {\n+            if (sym.name == names.init && sym.owner != site.tsym) {\n@@ -4701,1 +4674,1 @@\n-            if (names.isInitOrVNew(sname)) sname = s1.owner.name;\n+            if (sname == names.init) sname = s1.owner.name;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":28,"deletions":55,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -325,1 +324,1 @@\n-                !names.isInitOrVNew(sym.name) &&\n+                sym.name != names.init &&\n@@ -505,7 +504,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        tree.field = translate(tree.field, null);\n-        tree.value = translate(tree.value, erasure(tree.field.type));\n-        tree.type = erasure(tree.type);\n-        result = retype(tree, tree.type, pt);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -43,1 +42,0 @@\n-import com.sun.tools.javac.jvm.Target;\n@@ -62,1 +60,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -1185,1 +1182,1 @@\n-                            } else if (s.isInitOrVNew()) {\n+                            } else if (s.isConstructor()) {\n@@ -1395,2 +1392,1 @@\n-                Name constructorName = owner().isConcreteValueClass() ? names.vnew : names.init;\n-                constructorSymbol = new MethodSymbol(flags, constructorName,\n+                constructorSymbol = new MethodSymbol(flags, names.init,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -245,6 +245,1 @@\n-\n-        \/\/ value classes related bytecodes\n-        aconst_init     = 203,\n-        withfield       = 204,\n-\n-        ByteCodeCount   = 205;\n+        ByteCodeCount   = 203;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ByteCodes.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -284,7 +284,0 @@\n-        public void visitWithField(JCWithField tree) {\n-            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n-            sr.mergeWith(csp(tree.field));\n-            sr.mergeWith(csp(tree.value));\n-            result = sr;\n-        }\n-\n@@ -387,7 +380,0 @@\n-        @Override\n-        public void visitDefaultValue(JCDefaultValue tree) {\n-            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n-            sr.mergeWith(csp(tree.clazz));\n-            result = sr;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *     classig    ::= 'L' name [typeargs] ';' | 'Q' name [typeargs] ';'\n+ *     classig    ::= 'L' name [typeargs] ';'\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -64,0 +63,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -77,0 +78,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n@@ -112,4 +114,0 @@\n-    \/** Switch: allow primitive classes.\n-     *\/\n-    boolean allowPrimitiveClasses;\n-\n@@ -294,1 +292,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -514,1 +511,0 @@\n-        case 'Q':\n@@ -518,4 +514,0 @@\n-                if ((char) signature[sigp] == 'Q' && !allowPrimitiveClasses) {\n-                    throw badClassFile(\"bad.class.signature\",\n-                                       quoteBadSignature());\n-                }\n@@ -579,2 +571,1 @@\n-        byte prefix = signature[sigp];\n-        if (prefix != 'L' && (!allowPrimitiveClasses || prefix != 'Q'))\n+        if (signature[sigp] != 'L')\n@@ -585,1 +576,0 @@\n-        ClassType.Flavor flavor;\n@@ -597,2 +587,0 @@\n-                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -602,2 +590,1 @@\n-                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n@@ -605,1 +592,1 @@\n-                    return new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    return new ClassType(outer, List.nil(), t, List.nil());\n@@ -615,3 +602,1 @@\n-                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                outer = new ClassType(outer, sigToTypes('>'), t, List.nil(), flavor) {\n+                outer = new ClassType(outer, sigToTypes('>'), t, List.nil()) {\n@@ -680,3 +665,1 @@\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    outer = new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    outer = new ClassType(outer, List.nil(), t, List.nil());\n@@ -874,1 +857,1 @@\n-                    if (sym.isInitOrVNew() && sym.type.getParameterTypes().size() == 0) {\n+                    if (sym.isConstructor() && sym.type.getParameterTypes().size() == 0) {\n@@ -1066,8 +1049,0 @@\n-                        \/\/ Map value class factory methods back to constructors for the benefit of earlier pipeline stages\n-                        if (sym.kind == MTH && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n-                            sym.type = new MethodType(sym.type.getParameterTypes(),\n-                                    syms.voidType,\n-                                    sym.type.getThrownTypes(),\n-                                    syms.methodClass);\n-                        }\n-\n@@ -1426,1 +1401,1 @@\n-        if (!names.isInitOrVNew(nt.name))\n+        if (nt.name != names.init)\n@@ -2360,7 +2335,0 @@\n-        if (names.isInitOrVNew(name) && ((flags & STATIC) != 0)) {\n-            flags &= ~STATIC;\n-            type = new MethodType(type.getParameterTypes(),\n-                    syms.voidType,\n-                    type.getThrownTypes(),\n-                    syms.methodClass);\n-        }\n@@ -2368,1 +2336,1 @@\n-        if (names.isInitOrVNew(name) && currentOwner.hasOuterInstance()) {\n+        if (name == names.init && currentOwner.hasOuterInstance()) {\n@@ -2413,1 +2381,1 @@\n-            ((name == names.init || name == names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            (name == names.init && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2477,1 +2445,1 @@\n-        if (names.isInitOrVNew(sym.name) && currentOwner.hasOuterInstance()) {\n+        if (sym.name == names.init && currentOwner.hasOuterInstance()) {\n@@ -2644,5 +2612,0 @@\n-        if ((flags & PRIMITIVE_CLASS) != 0) {\n-            if (!allowPrimitiveClasses || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n-                throw badClassFile(\"bad.access.flags\", Flags.toString(flags));\n-            }\n-        }\n@@ -2877,0 +2840,2 @@\n+        \/\/ we need to do some checks now that the class has been loaded\n+        checkNonCyclicMembership(c);\n@@ -2913,6 +2878,0 @@\n-        if ((flags & ACC_PRIMITIVE) != 0) {\n-            flags &= ~ACC_PRIMITIVE;\n-            if (allowPrimitiveClasses) {\n-                flags |= PRIMITIVE_CLASS;\n-            }\n-        }\n@@ -3159,0 +3118,51 @@\n+\n+    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n+    void checkNonCyclicMembership(ClassSymbol csym) {\n+        if (!allowValueClasses) {\n+            \/\/ nothing to see here\n+            return;\n+        }\n+        Assert.check((csym.flags_field & LOCKED) == 0);\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(field);\n+            }\n+            csym.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            csym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            JavaFileObject prevSource = log.useSource(currentClassFile);\n+            try {\n+                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n+                return;\n+            } finally {\n+                log.useSource(prevSource);\n+            }\n+        }\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(fld);\n+            }\n+            c.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private boolean cyclePossible(VarSymbol symbol) {\n+        return false; \/\/(symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":66,"deletions":56,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-import com.sun.tools.javac.code.Scope.WriteableScope;\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -113,2 +111,0 @@\n-    private boolean allowPrimitiveClasses;\n-\n@@ -200,2 +196,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -846,1 +840,1 @@\n-            int flags = adjustFlags(inner.flags_field);\n+            int flags = adjustFlags(inner, inner.flags_field);\n@@ -987,1 +981,1 @@\n-        int flags = adjustFlags(v.flags());\n+        int flags = adjustFlags(v, v.flags());\n@@ -1016,1 +1010,1 @@\n-        int flags = adjustFlags(m.flags());\n+        int flags = adjustFlags(m, m.flags());\n@@ -1076,1 +1070,1 @@\n-        if ((m.isInitOrVNew() || m.isValueObjectFactory()) && (m.flags_field & RECORD) != 0)\n+        if (m.isConstructor() && (m.flags_field & RECORD) != 0)\n@@ -1303,1 +1297,1 @@\n-                databuf.appendChar(allowPrimitiveClasses && t.isPrimitiveClass() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n@@ -1616,1 +1610,1 @@\n-            flags = adjustFlags(c.flags() & ~(DEFAULT | STRICTFP));\n+            flags = adjustFlags(c, c.flags() & ~(DEFAULT | STRICTFP));\n@@ -1779,1 +1773,1 @@\n-    int adjustFlags(final long flags) {\n+    int adjustFlags(Symbol sym, final long flags) {\n@@ -1792,2 +1786,0 @@\n-        if ((flags & PRIMITIVE_CLASS) != 0)\n-            result |= ACC_PRIMITIVE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-    private boolean allowPrimitiveClasses;\n@@ -199,2 +198,1 @@\n-                PoolWriter poolWriter,\n-                boolean allowPrimitiveClasses) {\n+                PoolWriter poolWriter) {\n@@ -222,1 +220,0 @@\n-        this.allowPrimitiveClasses = allowPrimitiveClasses;\n@@ -466,1 +463,1 @@\n-        if (member.isInitOrVNew())\n+        if (member.isConstructor())\n@@ -1025,6 +1022,1 @@\n-            state.push(uninitializedObject(t.tsym.erasure(types), cp - 3));\n-            break;\n-        }\n-        case aconst_init: {\n-            Type t = (Type)data;\n-            state.push(t.tsym.erasure(types));\n+            state.push(uninitializedObject(t.tsym.erasure(types), cp-3));\n@@ -1059,3 +1051,0 @@\n-        case withfield:\n-            state.pop(((Symbol)data).erasure(types));\n-            break;\n@@ -1072,1 +1061,1 @@\n-            Type t = types.erasure(data instanceof  ConstantPoolQType ? ((ConstantPoolQType)data).type: (Type)data);\n+            Type t = types.erasure((Type)data);\n@@ -1075,0 +1064,1 @@\n+        case ldc2:\n@@ -1082,3 +1072,0 @@\n-        case ldc2:\n-            state.push(types.constantType((LoadableConstant)data));\n-            break;\n@@ -1388,1 +1375,1 @@\n-            if (meth.isInitOrVNew() && thisType != syms.objectType) {\n+            if (meth.isConstructor() && thisType != syms.objectType) {\n@@ -1786,6 +1773,2 @@\n-                if (!allowPrimitiveClasses) {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)));\n-                } else {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n-                            (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n-                }\n+                Assert.check(types.isSubtype(types.erasure(old),\n+                                       types.erasure(t)));\n@@ -2467,2 +2450,0 @@\n-            mnem[aconst_init] = \"aconst_init\";\n-            mnem[withfield] = \"withfield\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":8,"deletions":27,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-    private final TransValues transValues;\n@@ -119,1 +118,0 @@\n-        transValues = TransValues.instance(context);\n@@ -137,2 +135,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -183,2 +179,0 @@\n-    boolean allowPrimitiveClasses;\n-\n@@ -274,14 +268,0 @@\n-    \/** Insert a reference to given type in the constant pool,\n-     *  checking for an array with too many dimensions;\n-     *  return the reference's index.\n-     *  @param type   The type for which a reference is inserted.\n-     *\/\n-    int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {\n-        checkDimension(pos, type);\n-        if (emitQtype) {\n-            return poolWriter.putClass(new ConstantPoolQType(type, types));\n-        } else {\n-            return poolWriter.putClass(type);\n-        }\n-    }\n-\n@@ -294,1 +274,1 @@\n-        return makeRef(pos, type, false);\n+        return poolWriter.putClass(checkDimension(pos, type));\n@@ -348,1 +328,1 @@\n-        else items.makeMemberItem(msym, names.isInitOrVNew(name)).invoke();\n+        else items.makeMemberItem(msym, name == names.init).invoke();\n@@ -572,1 +552,1 @@\n-        if (names.isInitOrVNew(md.name) && TreeInfo.isInitialConstructor(md)) {\n+        if (names.isInit(md.name) && TreeInfo.isInitialConstructor(md)) {\n@@ -975,1 +955,1 @@\n-            if (meth.isInitOrVNew()) {\n+            if (meth.isConstructor()) {\n@@ -1015,3 +995,0 @@\n-                    } else if (env.enclMethod.sym.isValueObjectFactory()) {\n-                        items.makeLocalItem(env.enclMethod.factoryProduct).load();\n-                        code.emitop0(areturn);\n@@ -1072,2 +1049,1 @@\n-                                        poolWriter,\n-                                        allowPrimitiveClasses);\n+                                        poolWriter);\n@@ -1083,1 +1059,1 @@\n-                if (meth.isInitOrVNew() && selfType != syms.objectType)\n+                if (meth.isConstructor() && selfType != syms.objectType)\n@@ -1174,31 +1150,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        switch(tree.field.getTag()) {\n-            case IDENT:\n-                Symbol sym = ((JCIdent) tree.field).sym;\n-                items.makeThisItem().load();\n-                genExpr(tree.value, tree.field.type).load();\n-                sym = binaryQualifier(sym, env.enclClass.type);\n-                code.emitop2(withfield, sym, PoolWriter::putMember);\n-                result = items.makeStackItem(tree.type);\n-                break;\n-            case SELECT:\n-                JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;\n-                sym = TreeInfo.symbol(fieldAccess);\n-                \/\/ JDK-8207332: To maintain the order of side effects, must compute value ahead of field\n-                genExpr(tree.value, tree.field.type).load();\n-                genExpr(fieldAccess.selected, fieldAccess.selected.type).load();\n-                if (Code.width(tree.field.type) == 2) {\n-                    code.emitop0(dup_x2);\n-                    code.emitop0(pop);\n-                } else {\n-                    code.emitop0(swap);\n-                }\n-                sym = binaryQualifier(sym, fieldAccess.selected.type);\n-                code.emitop2(withfield, sym, PoolWriter::putMember);\n-                result = items.makeStackItem(tree.type);\n-                break;\n-            default:\n-                Assert.check(false);\n-        }\n-    }\n-\n@@ -2130,1 +2075,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype, elemtype.isPrimitiveClass()), type);\n+                code.emitAnewarray(makeRef(pos, elemtype), type);\n@@ -2356,1 +2301,0 @@\n-        \/\/ primitive reference conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2359,2 +2303,1 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n-           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n+           types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {\n@@ -2362,6 +2305,1 @@\n-            if (tree.clazz.type.isPrimitiveClass()) {\n-                code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);\n-            } else {\n-                code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n-            }\n-\n+            code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n@@ -2429,1 +2367,1 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type));\n@@ -2488,12 +2426,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        if (tree.type.isValueClass()) {\n-            code.emitop2(aconst_init, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n-        } else if (tree.type.isReference()) {\n-            code.emitop0(aconst_null);\n-        } else {\n-            code.emitop0(zero(Code.typecode(tree.type)));\n-        }\n-        result = items.makeStackItem(tree.type);\n-        return;\n-    }\n-\n@@ -2556,1 +2482,0 @@\n-            cdef = transValues.translateTopLevelClass(cdef, make);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":10,"deletions":85,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-            MethodType mtype = (MethodType)member.externalType(types); \/\/ static factories\n+            MethodType mtype = (MethodType)member.erasure(types);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.tools.javac.code.Type.ConstantPoolQType;\n@@ -124,6 +123,0 @@\n-        \/* Their is nothing to be gained by having the pair of class types Foo.ref and Foo.val\n-           result in two different CONSTANT_Class_info strucures in the pool. These are\n-           indistinguishable at the class file level. Hence we coalesce them here.\n-        *\/\n-        if (t.isReferenceProjection())\n-            t = t.valueProjection();\n@@ -133,8 +126,0 @@\n-    \/**\n-     * Puts a type into the pool and return its index. The type could be either a class, a type variable\n-     * or an array type.\n-     *\/\n-    int putClass(ConstantPoolQType t) {\n-        return pool.writeIfNeeded(t);\n-    }\n-\n@@ -399,1 +384,1 @@\n-                    Type ct = c instanceof ConstantPoolQType ? ((ConstantPoolQType)c).type : (Type)c;\n+                    Type ct = (Type)c;\n@@ -402,1 +387,1 @@\n-                      c instanceof ConstantPoolQType ? names.fromString(\"Q\" + externalize(ct.tsym.flatName()) + \";\") : externalize(ct.tsym.flatName());\n+                            externalize(ct.tsym.flatName());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -214,0 +214,6 @@\n+    \/** Does the target VM support value classes\n+     *\/\n+    public boolean hasValueClasses() {\n+        return compareTo(JDK1_19) >= 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,432 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.jvm;\n-\n-import com.sun.tools.javac.code.Flags;\n-import com.sun.tools.javac.code.Scope.LookupKind;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.MethodSymbol;\n-import com.sun.tools.javac.code.Symbol.VarSymbol;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.code.Type.MethodType;\n-import com.sun.tools.javac.code.Types;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.JCAssign;\n-import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n-import com.sun.tools.javac.tree.JCTree.JCExpression;\n-import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n-import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n-import com.sun.tools.javac.tree.JCTree.JCIdent;\n-import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n-import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n-import com.sun.tools.javac.tree.JCTree.JCNewClass;\n-import com.sun.tools.javac.tree.JCTree.JCReturn;\n-import com.sun.tools.javac.tree.JCTree.JCStatement;\n-import com.sun.tools.javac.tree.TreeInfo;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeTranslator;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static com.sun.tools.javac.code.Flags.RECORD;\n-import static com.sun.tools.javac.code.Flags.STATIC;\n-import static com.sun.tools.javac.code.Flags.ABSTRACT;\n-import static com.sun.tools.javac.code.Flags.VALUE_CLASS;\n-import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n-import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n-import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n-import static com.sun.tools.javac.tree.JCTree.Tag.APPLY;\n-import static com.sun.tools.javac.tree.JCTree.Tag.EXEC;\n-import static com.sun.tools.javac.tree.JCTree.Tag.IDENT;\n-\n-\/**\n- * This pass translates value class constructors into static factory methods and patches up constructor\n- * calls to become invocations of those static factory methods.\n- *\n- * We get commissioned as a subpass of Gen. Constructor trees undergo plenty of change in Lower\n- * (enclosing instance injection, captured locals ...) and in Gen (instance field initialization,\n- * see normalizeDefs) and so it is most effective to wait until things reach a quiescent state\n- * before undertaking the tinkering that we do.\n- *\n- * See https:\/\/bugs.openjdk.java.net\/browse\/JDK-8198749 for the kind of transformations we do.\n- *\n- *\/\n-public class TransValues extends TreeTranslator {\n-\n-    protected static final Context.Key<TransValues> transValueClass = new Context.Key<>();\n-\n-    private Symtab syms;\n-    private TreeMaker make;\n-    private Types types;\n-    private Names names;\n-\n-    \/* Is an assignment undergoing translation just an assignment statement ?\n-       Or is also a value ??\n-    *\/\n-    private boolean requireRVal;\n-\n-    \/\/ class currently undergoing translation.\n-    private JCClassDecl currentClass;\n-\n-    \/\/ method currently undergoing translation.\n-    private JCMethodDecl currentMethod;\n-\n-    \/\/ list of factories synthesized so far.\n-    private List<JCTree> staticFactories;\n-\n-    \/\/ Map from constructor symbols to factory symbols.\n-    private Map<MethodSymbol, MethodSymbol> init2factory = new HashMap<>();\n-\n-    public static TransValues instance(Context context) {\n-        TransValues instance = context.get(transValueClass);\n-        if (instance == null) {\n-            instance = new TransValues(context);\n-            context.put(transValueClass, instance);\n-        }\n-        return instance;\n-    }\n-\n-    protected TransValues(Context context) {\n-        syms = Symtab.instance(context);\n-        make = TreeMaker.instance(context);\n-        types = Types.instance(context);\n-        names = Names.instance(context);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T extends JCTree> T translate(T tree, boolean requireRVal) {\n-        boolean priorRequireRVal = this.requireRVal;\n-        try {\n-            this.requireRVal = requireRVal;\n-            if (tree == null) {\n-                return null;\n-            } else {\n-                tree.accept(this);\n-                JCTree tmpResult = this.result;\n-                this.result = null;\n-                return (T)tmpResult; \/\/ XXX cast\n-            }\n-        } finally {\n-             this.requireRVal = priorRequireRVal;\n-        }\n-    }\n-\n-    @Override\n-    public <T extends JCTree> T translate(T tree) {\n-        return translate(tree, true);\n-    }\n-\n-    public JCClassDecl translateTopLevelClass(JCClassDecl classDecl, TreeMaker make) {\n-        try {\n-            this.make = make;\n-            translate(classDecl);\n-        } finally {\n-            \/\/ note that recursive invocations of this method fail hard\n-            this.make = null;\n-        }\n-        init2factory = new HashMap<>();\n-        return classDecl;\n-    }\n-\n-    @Override\n-    public void visitClassDef(JCClassDecl classDecl) {\n-        JCClassDecl previousClass = currentClass;\n-        List<JCTree> previousFactories = staticFactories;\n-        staticFactories = List.nil();\n-        currentClass = classDecl;\n-        try {\n-            super.visitClassDef(classDecl);\n-            classDecl.defs = classDecl.defs.appendList(staticFactories);\n-            staticFactories = List.nil();\n-        }\n-        finally {\n-            currentClass = previousClass;\n-            staticFactories = previousFactories;\n-        }\n-    }\n-\n-    @Override\n-    public void visitMethodDef(JCMethodDecl tree) {\n-        JCMethodDecl previousMethod = currentMethod;\n-        currentMethod = tree;\n-        try {\n-            if (transformToValueFactory()) {\n-\n-                \/\/ Mutate this value class constructor into an equivalent static factory\n-                make.at(tree.pos());\n-                JCExpressionStatement exec = chainedConstructorCall(tree);\n-                Assert.check(exec != null && TreeInfo.isSelfCall(exec));\n-                JCMethodInvocation call = (JCMethodInvocation) exec.expr;\n-\n-                \/* Unlike the reference construction sequence where `this' is allocated ahead of time and\n-                   is passed as an argument into the <init> method, the value static factory must allocate the\n-                   instance that forms the `product' by itself. We do that by injecting a prologue here.\n-                *\/\n-                VarSymbol product = currentMethod.factoryProduct = new VarSymbol(0, names.dollarValue, currentClass.sym.type, currentMethod.sym); \/\/ TODO: owner needs rewiring\n-                JCExpression rhs;\n-\n-                final Name name = TreeInfo.name(call.meth);\n-                MethodSymbol symbol = (MethodSymbol)TreeInfo.symbol(call.meth);\n-                if (names._super.equals(name)) { \/\/ \"initial\" constructor.\n-                    \/\/ Synthesize code to allocate factory \"product\" via: V $this = V.default;\n-                    Assert.check(symbol.type.getParameterTypes().size() == 0);\n-                    final JCExpression type = make.Type(currentClass.type);\n-                    rhs = make.DefaultValue(type);\n-                    rhs.type = currentClass.type;\n-                } else {\n-                    \/\/ This must be a chained call of form `this(args)'; Mutate it into a factory invocation i.e V $this = V.init(args);\n-                    Assert.check(TreeInfo.name(TreeInfo.firstConstructorCall(tree).meth) == names._this);\n-                    MethodSymbol factory = getValueObjectFactory(symbol);\n-                    final JCIdent ident = make.Ident(factory);\n-                    rhs = make.App(ident, call.args);\n-                    ((JCMethodInvocation)rhs).varargsElement = call.varargsElement;\n-                }\n-\n-                \/* The static factory product allocation prologue must precede any synthetic inits !!!\n-                   as these may reference `this' which gets pre-allocated for references but\n-                   not for value objects.\n-                *\/\n-                JCStatement prologue = make.VarDef(product, rhs);\n-                tree.body.stats = tree.body.stats.prepend(prologue).diff(List.of(exec));\n-                tree.body = translate(tree.body);\n-\n-                MethodSymbol factorySym = getValueObjectFactory(tree.sym);\n-                currentMethod.setType(factorySym.type);\n-                currentMethod.factoryProduct = product;\n-                currentClass.sym.members().remove(tree.sym);\n-                tree.sym = factorySym;\n-                currentClass.sym.members().enter(factorySym);\n-                tree.mods.flags |= STATIC;\n-\n-                \/* We may need an epilogue that returns the factory product, but we can't eagerly insert\n-                   a return here, since we don't know much about control flow here. Gen#genMethod\n-                   will insert a return of the factory product if control does reach the end and would\n-                   \"fall off the cliff\" otherwise.\n-                *\/\n-\n-                result = tree;\n-                return;\n-            }\n-            super.visitMethodDef(tree);\n-        } finally {\n-            currentMethod = previousMethod;\n-        }\n-    }\n-\n-    @Override\n-    public void visitReturn(JCReturn tree) {\n-        if (transformToValueFactory()) {\n-            result = make.Return(make.Ident(currentMethod.factoryProduct));\n-        } else {\n-            super.visitReturn(tree);\n-        }\n-    }\n-\n-    \/* Note: 1. Assignop does not call for any translation, since value class instance fields are final and\n-       so cannot be AssignedOped. 2. Any redundantly qualified this would have been lowered already.\n-    *\/\n-    @Override\n-    public void visitAssign(JCAssign tree) {\n-        if (transformToValueFactory()) {\n-            Symbol symbol = null;\n-            switch(tree.lhs.getTag()) {\n-                case IDENT:\n-                    symbol = ((JCIdent)tree.lhs).sym;\n-                    break;\n-                case SELECT:\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) tree.lhs;\n-                    if (fieldAccess.selected.hasTag(IDENT) && ((JCIdent)fieldAccess.selected).name == names._this) {\n-                        symbol = fieldAccess.sym;\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-            if (isInstanceMemberAccess(symbol)) {\n-                final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                result = make.Assign(facHandle, make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type)).setType(currentClass.type);\n-                if (requireRVal) {\n-                    result = make.Select(make.Parens((JCExpression) result).setType(currentClass.type), symbol);\n-                }\n-                return;\n-            }\n-        }\n-        super.visitAssign(tree);\n-    }\n-\n-    @Override\n-    public void visitExec(JCExpressionStatement tree) {\n-        if (transformToValueFactory()) {\n-            tree.expr = translate(tree.expr, false);\n-            result = tree;\n-        } else {\n-            super.visitExec(tree);\n-        }\n-    }\n-\n-    @Override\n-    public void visitIdent(JCIdent ident) {\n-        if (transformToValueFactory()) {\n-            Symbol symbol = ident.sym;\n-            if (isInstanceMemberAccess(symbol)) {\n-                final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                result = make.Select(facHandle, symbol);\n-                return;\n-            } else if (symbol.name == names._this) {\n-                result = make.Ident(currentMethod.factoryProduct);\n-                return;\n-            }\n-        }\n-        super.visitIdent(ident);\n-    }\n-\n-    @Override\n-    public void visitSelect(JCFieldAccess fieldAccess) {\n-        if (transformToValueFactory()) { \/\/ Qualified this would have been lowered already.\n-            if (fieldAccess.selected.hasTag(IDENT) && ((JCIdent)fieldAccess.selected).name == names._this) {\n-                Symbol symbol = fieldAccess.sym;\n-                if (isInstanceMemberAccess(symbol)) {\n-                    final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                    result = make.Select(facHandle, symbol);\n-                    return;\n-                }\n-            }\n-        }\n-        \/* If a static member is being selected via a V.ref as a TYP, rewrite\n-           V.ref.member to V.member\n-        *\/\n-        fieldAccess.selected = translate(fieldAccess.selected);\n-        if (fieldAccess.name != names._class) {  \/\/ TODO: this and super ??\n-            Symbol sym = TreeInfo.symbol(fieldAccess);\n-            Symbol sitesym = TreeInfo.symbol(fieldAccess.selected);\n-            Type selectedType = fieldAccess.selected.type;\n-            if (selectedType.isReferenceProjection()) {\n-                switch (sym.kind) {\n-                    case MTH:\n-                    case VAR:\n-                        if (sym.isStatic() && sitesym != null && sitesym.kind == TYP) {\n-                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        }\n-                        break;\n-                    case TYP:\n-                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        break;\n-                }\n-            }\n-        }\n-        result = fieldAccess;\n-    }\n-\n-    \/\/ Translate a reference style instance creation attempt on a value class to a static factory call.\n-    @Override\n-    public void visitNewClass(JCNewClass tree) {\n-        if (tree.clazz.type.isValueClass()) {\n-            \/\/ Enclosing instances or anonymous classes should have been eliminated by now.\n-            Assert.check(tree.encl == null && tree.def == null);\n-            tree.args = translate(tree.args);\n-            Assert.check(tree.def == null);\n-            MethodSymbol sFactory = getValueObjectFactory((MethodSymbol) tree.constructor);\n-            make.at(tree.pos());\n-            JCExpression declClass = make.Type(tree.constructor.owner.type);\n-            JCExpression meth = make.Select(declClass, sFactory);\n-            meth.type = types.erasure(meth.type);\n-            final JCMethodInvocation apply = make.Apply(tree.typeargs, meth, tree.args);\n-            apply.varargsElement = tree.varargsElement;\n-            apply.type = meth.type.getReturnType();\n-            result = apply;\n-            return;\n-        }\n-        super.visitNewClass(tree);\n-    }\n-\n-    \/\/ Utility methods ...\n-    private boolean transformToValueFactory() {\n-        \/\/ We lower any constructors in abstract value classes to <init> methods while a\n-        \/\/ constructor in a concrete value class is lowered into a static value factory method\n-        return currentClass != null && (currentClass.sym.flags() & (ABSTRACT | VALUE_CLASS)) == VALUE_CLASS && currentMethod != null && currentMethod.sym.name == names.vnew;\n-    }\n-\n-    private boolean isInstanceMemberAccess(Symbol symbol) {\n-        return symbol != null\n-                && (symbol.name != names._this && symbol.name != names._super)\n-                && (symbol.kind == VAR || symbol.kind == MTH)\n-                && symbol.owner == currentClass.sym && !symbol.isStatic();\n-    }\n-\n-    private MethodSymbol getValueObjectFactory(MethodSymbol init) {\n-        Assert.check(init.name.equals(names.vnew));\n-        Assert.check(init.owner.type.isValueClass());\n-        MethodSymbol factory = init2factory.get(init);\n-        if (factory != null)\n-            return factory;\n-\n-        MethodType factoryType = new MethodType(init.type.getParameterTypes(),\n-                                                init.owner.type,\n-                                                init.type.getThrownTypes(),\n-                                                init.owner.type.tsym);\n-        factory = new MethodSymbol(init.flags_field | STATIC,\n-                                        names.vnew,\n-                                        factoryType,\n-                                        init.owner);\n-        factory.params = init.params;\n-        \/\/ Re-patch the return type on the erased method type, or code generation will fail\n-        factory.erasure_field = new MethodType(init.erasure(types).getParameterTypes(),\n-                init.owner.type,\n-                init.type.getThrownTypes(),\n-                init.owner.type.tsym);\n-        factory.setAttributes(init);\n-        init2factory.put(init, factory);\n-        return factory;\n-    }\n-\n-    \/** Return the *statement* in the constructor that `chains' to another constructor call either\n-     *  in the same class or its superclass. One MUST exist except for jlO, though may be buried\n-     *  under synthetic initializations.\n-     *\/\n-    private JCExpressionStatement chainedConstructorCall(JCMethodDecl md) {\n-        if (names.isInitOrVNew(md.name) && md.body != null) {\n-            for (JCStatement statement : md.body.stats) {\n-                if (statement.hasTag(EXEC)) {\n-                    JCExpressionStatement exec = (JCExpressionStatement)statement;\n-                    if (exec.expr.hasTag(APPLY)) {\n-                        JCMethodInvocation apply = (JCMethodInvocation)exec.expr;\n-                        Name name = TreeInfo.name(apply.meth);\n-                        if (name == names._super || name == names._this)\n-                            return exec;\n-                    }\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":0,"deletions":432,"binary":false,"changes":432,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Collections;\n@@ -87,2 +86,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -1784,1 +1781,1 @@\n-                                names.isInitOrVNew(((JCMethodDecl) t).sym.name) ||\n+                                ((JCMethodDecl) t).sym.name == names.init ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym, sym.type.getFlavor());\n+            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym);\n@@ -301,1 +301,1 @@\n-        if (types.asSuper(site.referenceProjectionOrSelf(), sym.getEnclosingElement()) == null)\n+        if (types.asSuper(site, sym.getEnclosingElement()) == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;\n@@ -197,1 +198,0 @@\n-        this.allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && fac.options.isSet(\"enablePrimitiveClasses\");\n@@ -222,1 +222,0 @@\n-        this.allowPrimitiveClasses = parser.allowPrimitiveClasses;\n@@ -261,4 +260,0 @@\n-    \/** Switch: are primitive classes allowed in this source level?\n-     *\/\n-     boolean allowPrimitiveClasses;\n-\n@@ -1539,6 +1534,0 @@\n-                            case DEFAULT:\n-                                if (typeArgs != null) return illegal();\n-                                selectExprMode();\n-                                t = to(F.at(pos).DefaultValue(t));\n-                                nextToken();\n-                                break loop;\n@@ -1624,6 +1613,0 @@\n-                                if (token.kind == DEFAULT) {\n-                                    t =  toP(F.at(token.pos).DefaultValue(t));\n-                                    nextToken();\n-                                    selectExprMode();\n-                                    return term3Rest(t, typeArgs);\n-                                }\n@@ -1860,2 +1843,1 @@\n-     * method reference or a default value creation that uses a parameterized type\n-     * or a binary expression. To disambiguate, look for a\n+     * method reference or a binary expression. To disambiguate, look for a\n@@ -2472,1 +2454,1 @@\n-            TokenKind selector = accept2(CLASS, DEFAULT);\n+            accept(CLASS);\n@@ -2490,5 +2472,1 @@\n-                if (selector == CLASS) {\n-                    t = toP(F.at(pos).Select(t, names._class));\n-                } else {\n-                    t = toP(F.at(pos).DefaultValue(t));\n-                }\n+                t = toP(F.at(pos).Select(t, names._class));\n@@ -2526,1 +2504,0 @@\n-            \/\/ TODO - will be converted in Attr\n@@ -2615,1 +2592,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            long badModifiers = mods.flags & ~(Flags.VALUE_CLASS | Flags.FINAL);\n@@ -2972,1 +2949,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+        if ((isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n@@ -3569,4 +3546,0 @@\n-                if (isPrimitiveModifier()) {\n-                    flag = Flags.PRIMITIVE_CLASS;\n-                    break;\n-                }\n@@ -3847,5 +3820,0 @@\n-        if (name == names.primitive) {\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            }\n-        }\n@@ -3860,3 +3828,1 @@\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            } else if (shouldWarn) {\n+            if (shouldWarn) {\n@@ -4392,2 +4358,1 @@\n-                \/\/ TODO - specifically for record.\n-                if (names.isInitOrVNew(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                if (methDef.name == names.init && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -4934,26 +4899,0 @@\n-    protected boolean isPrimitiveModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n-            boolean isPrimitiveModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isPrimitiveModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isPrimitiveModifier = true;\n-                    break;\n-            }\n-            if (isPrimitiveModifier) {\n-                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -4972,1 +4911,1 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || new value Comparable() {} ??\n@@ -4974,1 +4913,1 @@\n-                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                            || (mode & EXPR) != 0)\n@@ -4999,1 +4938,1 @@\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                    if (next.name() == names.record || next.name() == names.identity\n@@ -5073,1 +5012,1 @@\n-            if (!isRecord || !names.isInitOrVNew(name) || token.kind == LPAREN) {\n+            if (!isRecord || name != names.init || token.kind == LPAREN) {\n@@ -5529,4 +5468,1 @@\n-        if (feature == Feature.PRIMITIVE_CLASSES && !allowPrimitiveClasses) {\n-            \/\/ primitive classes are special\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n-        } else if (preview.isPreview(feature) && !preview.isEnabled()) {\n+        if (preview.isPreview(feature) && !preview.isEnabled()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":13,"deletions":77,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -1344,1 +1343,1 @@\n-                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil(), Flavor.X_Typeof_X);\n+                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -493,0 +493,4 @@\n+            case CLASS:\n+                modifiers.remove(Modifier.IDENTITY);\n+                break;\n+\n@@ -496,0 +500,1 @@\n+                modifiers.remove(Modifier.IDENTITY);\n@@ -502,0 +507,1 @@\n+                modifiers.remove(Modifier.IDENTITY);\n@@ -506,0 +512,1 @@\n+                modifiers.remove(Modifier.IDENTITY);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4048,3 +4048,0 @@\n-compiler.misc.feature.primitive.classes=\\\n-    primitive classes\n-\n@@ -4056,6 +4053,1 @@\n-    cyclic primitive class membership involving {0}\n-\n-# 0: string (expected version)\n-compiler.err.primitive.classes.not.supported=\\\n-    primitive classes are not supported\\n\\\n-     (use -source {0} or higher to enable primitive classes and pass compiler option: -XDenablePrimitiveClasses)\n+    cyclic value class membership involving {0}\n@@ -4130,3 +4122,0 @@\n-compiler.err.projection.cant.be.instantiated=\\\n-    Illegal attempt to instantiate a projection type\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -136,4 +136,0 @@\n-        \/** Withfields, of type WithField.\n-         *\/\n-        WITHFIELD,\n-\n@@ -264,4 +260,0 @@\n-        \/** Default values, of type DefaultValueTree.\n-         *\/\n-        DEFAULT_VALUE,\n-\n@@ -896,3 +888,0 @@\n-        \/** nascent value that evolves into the return value for a value factory *\/\n-        public VarSymbol factoryProduct;\n-\n@@ -967,2 +956,2 @@\n-        public boolean isInitOrVNew() {\n-            return name.table.names.isInitOrVNew(name);\n+        public boolean isInit() {\n+            return name.table.names.isInit(name);\n@@ -1190,30 +1179,0 @@\n-    \/**\n-     * A withfield expression\n-     *\/\n-    public static class JCWithField extends JCExpression implements WithFieldTree {\n-        public JCExpression field;\n-        public JCExpression value;\n-        protected JCWithField(JCExpression field, JCExpression value) {\n-            this.field = field;\n-            this.value = value;\n-        }\n-        @Override\n-        public void accept(Visitor v) { v.visitWithField(this); }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() { return Kind.WITH_FIELD; }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getField() { return field; }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getValue() { return value; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n-            return v.visitWithField(this, d);\n-        }\n-\n-        @Override\n-        public Tag getTag() {\n-            return WITHFIELD;\n-        }\n-    }\n-\n@@ -1427,26 +1386,0 @@\n-    \/**\n-     * A \"Identifier<TA1, TA2>.default\" construction.\n-     *\/\n-    public static class JCDefaultValue extends JCPolyExpression implements DefaultValueTree {\n-        public JCExpression clazz;\n-\n-        protected JCDefaultValue(JCExpression clazz) {\n-            this.clazz = clazz;\n-        }\n-        @Override\n-        public void accept(Visitor v) { v.visitDefaultValue(this); }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() { return Kind.DEFAULT_VALUE; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getType() { return clazz; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n-            return v.visitDefaultValue(this, d);\n-        }\n-        @Override\n-        public Tag getTag() {\n-            return DEFAULT_VALUE;\n-        }\n-    }\n-\n@@ -3545,1 +3478,0 @@\n-        JCDefaultValue DefaultValue(JCExpression type);\n@@ -3621,1 +3553,0 @@\n-        public void visitWithField(JCWithField that)         { visitTree(that); }\n@@ -3627,1 +3558,0 @@\n-        public void visitDefaultValue(JCDefaultValue that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":72,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-            if (tree.isInitOrVNew() &&\n+            if (tree.name == tree.name.table.names.init &&\n@@ -612,1 +612,1 @@\n-            if (tree.isInitOrVNew()) {\n+            if (tree.name == tree.name.table.names.init) {\n@@ -752,9 +752,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        try {\n-            printExpr(tree.clazz, TreeInfo.postfixPrec);\n-            print(\".default\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n@@ -797,12 +788,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        try {\n-            print(\"__WithField(\");\n-            printExpr(tree.field);\n-            print(\", \");\n-            printExpr(tree.value);\n-            print(\")\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -202,7 +202,0 @@\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitDefaultValue(DefaultValueTree node, P p) {\n-        JCDefaultValue t = (JCDefaultValue) node;\n-        JCExpression clazz = copy(t.clazz, p);\n-        return M.at(t.pos).DefaultValue(clazz);\n-    }\n-\n@@ -253,2 +246,1 @@\n-        JCIdent ident = M.at(t.pos).Ident(t.name);\n-        return ident;\n+        return M.at(t.pos).Ident(t.name);\n@@ -378,2 +370,1 @@\n-        JCFieldAccess select = M.at(t.pos).Select(selected, t.name);\n-        return select;\n+        return M.at(t.pos).Select(selected, t.name);\n@@ -581,8 +572,0 @@\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitWithField(WithFieldTree node, P p) {\n-        JCWithField t = (JCWithField) node;\n-        JCExpression field = copy(t.field, p);\n-        JCExpression value = copy(t.value, p);\n-        return M.at(t.pos).WithField(field, value);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -84,12 +84,1 @@\n-            return name == name.table.names.init || name == name.table.names.vnew;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Is tree a value factory declaration?\n-     *\/\n-    public static boolean isValueFactory(JCTree tree) {\n-        if (tree.hasTag(METHODDEF)) {\n-            Name name = ((JCMethodDecl) tree).name;\n-            return name == name.table.names.vnew;\n+            return name == name.table.names.init;\n@@ -123,1 +112,1 @@\n-            if (isConstructor(l.head) || isValueFactory(l.head)) return true;\n+            if (isConstructor(l.head)) return true;\n@@ -269,1 +258,1 @@\n-        if (!md.isInitOrVNew()) return null;\n+        if (!md.isInit()) return null;\n@@ -505,2 +494,0 @@\n-            case DEFAULT_VALUE:\n-                return getStartPos(((JCDefaultValue) tree).clazz);\n@@ -662,2 +649,0 @@\n-            case WITHFIELD:\n-                return getEndPos(((JCWithField) tree).value, endPosTable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -269,6 +269,0 @@\n-    public JCWithField WithField(JCExpression field, JCExpression value) {\n-        JCWithField tree = new JCWithField(field, value);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n@@ -310,6 +304,0 @@\n-    public JCDefaultValue DefaultValue(JCExpression type) {\n-        JCDefaultValue tree = new JCDefaultValue(type);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n@@ -877,22 +865,7 @@\n-                if (t.isReferenceProjection()) {\n-                    \/\/ For parameterized types, we want V.ref<A1 ... An> not V<A1 ... An>.ref\n-                    JCExpression vp = Type(t.valueProjection());\n-                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n-                        \/\/ vp now is V<A1 ... An>, build V.ref<A1 ... An>\n-                        JCFieldAccess f = Select(((JCTypeApply) vp).clazz, t.tsym);\n-                        f.name = names.ref;\n-                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n-                    } else {\n-                        JCFieldAccess f = Select(vp, t.tsym);\n-                        f.name = names.ref;\n-                        tp = f;\n-                    }\n-                } else {\n-                    Type outer = t.getEnclosingType();\n-                    JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n-                            ? Select(Type(outer), t.tsym)\n-                            : QualIdent(t.tsym);\n-                    tp = t.getTypeArguments().isEmpty()\n-                            ? clazz\n-                            : TypeApply(clazz, Types(t.getTypeArguments()));\n-                }\n+                Type outer = t.getEnclosingType();\n+                JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n+                        ? Select(Type(outer), t.tsym)\n+                        : QualIdent(t.tsym);\n+                tp = t.getTypeArguments().isEmpty()\n+                        ? clazz\n+                        : TypeApply(clazz, Types(t.getTypeArguments()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -158,5 +158,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        scan(tree.field);\n-        scan(tree.value);\n-    }\n-\n@@ -191,4 +186,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        scan(tree.clazz);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,6 +183,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        tree.field = translate(tree.field);\n-        tree.value = translate(tree.value);\n-        result = tree;\n-    }\n-\n@@ -405,5 +399,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        tree.clazz = translate(tree.clazz);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    public final Name _default;\n@@ -96,1 +95,0 @@\n-    public final Name vnew;\n@@ -108,1 +106,0 @@\n-    public final Name primitive;\n@@ -217,2 +214,0 @@\n-    public final Name ref;\n-    public final Name val;\n@@ -268,1 +263,0 @@\n-        _default = fromString(\"default\");\n@@ -304,1 +298,0 @@\n-        vnew = fromString(\"<vnew>\");\n@@ -316,1 +309,0 @@\n-        primitive = fromString(\"primitive\");\n@@ -423,1 +415,0 @@\n-        \/\/ primitive classes\n@@ -425,2 +416,0 @@\n-        ref = fromString(\"ref\");\n-        val = fromString(\"val\");\n@@ -478,2 +467,2 @@\n-    public boolean isInitOrVNew(Name name) {\n-        return name == init || name == vnew;\n+    public boolean isInit(Name name) {\n+        return name == init;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -432,1 +432,3 @@\n-                String ms = (s.isInitOrVNew()) ? ownerName : s.name.toString();\n+                String ms = (s.name == s.name.table.names.init)\n+                    ? ownerName\n+                    : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+    public void remove(LintCategory lint) {\n+        nonSilentLintSet.remove(lint);\n+        silentLintSet.remove(lint);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">DeprecatedClassByAnnotation<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">DeprecatedClassByAnnotation<\/span>\n@@ -140,1 +140,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestClass<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestClass<\/span>\n@@ -238,1 +238,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestError<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestError<\/span>\n@@ -249,1 +249,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestException<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestException<\/span>\n@@ -260,1 +260,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestInterface<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestInterface<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public static class <\/span><\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public static identity class <\/span><\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/TestHiddenTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">C1<\/span>\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">C1<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -185,1 +185,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlTag\/TestHtmlTag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public static class <\/span><\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public static identity class <\/span><\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -191,1 +191,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestLinkOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1363,1 +1363,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -543,1 +543,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-l\\\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-l\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/TestNewLanguageFeatures.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -269,1 +269,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -239,1 +239,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -244,1 +244,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\"> class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -97,1 +97,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -118,1 +118,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -143,1 +143,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -174,1 +174,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R&lt;T&gt;<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R&lt;T&gt;<\/span>\"\"\",\n@@ -472,1 +472,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public record <\/span><span c\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity record <\/span><span c\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -97,1 +97,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -102,1 +102,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public non-sealed class <\/span><span class=\"element-name type-name-label\">B<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public non-sealed identity class <\/span><span class=\"element-name type-name-label\">B<\/span>\n@@ -144,1 +144,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -192,1 +192,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -215,1 +215,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -238,1 +238,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -263,1 +263,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -288,1 +288,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -312,1 +312,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -336,1 +336,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSealedTypes\/TestSealedTypes.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -95,1 +95,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -469,1 +469,1 @@\n-                    <\/span><span class=\"modifiers\">class <\/span><span class=\"element-name type-name-\\\n+                    <\/span><span class=\"modifiers\">identity class <\/span><span class=\"element-name type-name-\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeAnnotations\/TestTypeAnnotations.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                    public class <\/span><span class=\"element-name\"><a href=\"..\/src-html\/pkg\/ClassUse\\\n+                    public identity class <\/span><span class=\"element-name\"><a href=\"..\/src-html\/pkg\/ClassUse\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/TestTypeParameters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8308590\n+ * @summary  value classes\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestValueClasses\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestValueClasses extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestValueClasses();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testValueClassModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public value class ValueClass {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueClass.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public value final class <\/span><span class=\"element-name type-name-label\">ValueClass<\/span>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testIdentityClassModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public identity class IdentityClass {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/IdentityClass.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">IdentityClass<\/span>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testValueInterfaceModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public value interface ValueInterface {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueInterface.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public value interface <\/span><span class=\"element-name type-name-label\">ValueInterface<\/span><\/div>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testIdentityInterfaceModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public identity interface IdentityInterface {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/IdentityInterface.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public interface <\/span><span class=\"element-name type-name-label\">IdentityInterface<\/span><\/div>\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueClasses\/TestValueClasses.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/jdk\/jshell\/Test8294583.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/jdk\/jshell\/Test8296012.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnablePreviewTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,0 +115,4 @@\n+    protected void assertOKWithWarning(String warning, int numberOfTimes, String... constructs) {\n+        assertCompile(expandMarkers(constructs), () -> assertCompileSucceededWithWarning(warning, numberOfTimes), false);\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,6 @@\n+    public boolean containsWarningKey(String key, int numberOfWarnings) {\n+        return diags.stream()\n+                .filter(d -> d.getKind() == Diagnostic.Kind.WARNING || d.getKind() == Diagnostic.Kind.MANDATORY_WARNING)\n+                .filter(d -> d.getCode().equals(key)).count() == numberOfWarnings;\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/Diagnostics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,0 +157,8 @@\n+    protected void assertCompileSucceededWithWarning(String warning, int numberOfWarnings) {\n+        if (diags.errorsFound())\n+            fail(\"Expected successful compilation\");\n+        if (!diags.containsWarningKey(warning, numberOfWarnings)) {\n+            fail(String.format(\"Expected compilation warning with %s, found %s\", warning, diags.keys()));\n+        }\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-            \"0: #118(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n-            \"1: #118(): LOCAL_VARIABLE, {start_pc=2, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n+            \"1: #120(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n@@ -84,1 +84,1 @@\n-            \"0: #118(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/BridgeShouldHaveNoInteriorAnnotationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        return \"void eqtestObject() { if (null == new @TA String()); }\";\n+        return \"void eqtestObject(String s) { if (s == new @TA String()); }\";\n@@ -76,1 +76,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @TA ArrayList<@TB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList<String> as) { if (as == new @TA ArrayList<@TB String >()); }\";\n@@ -173,1 +173,1 @@\n-        return \"void eqtestObject() { if (null == new @RTA @RTA String()); }\";\n+        return \"void eqtestObject(String s) { if (s == new @RTA @RTA String()); }\";\n@@ -180,1 +180,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList<String> as) { if (as == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NewObjects.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/api\/TestApisWithProjections.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-compiler.misc.feature.primitive.classes\n@@ -235,1 +234,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.primitive.classes.not.supported\n-\n-public primitive class PrimitiveClassesNotSupported {\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveClassesNotSupported.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.projection.cant.be.instantiated\n-\/\/ options: -XDenablePrimitiveClasses\n-\n-public primitive class ProjectionCantBeInstantiated {\n-    int x = 42;\n-    public static void main(String[] args) {\n-        new ProjectionCantBeInstantiated();\n-        new ProjectionCantBeInstantiated.ref();\n-        new ProjectionCantBeInstantiated.val();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProjectionCantBeInstantiated.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -25,1 +25,0 @@\n-\/\/ options: -XDenablePrimitiveClasses\n@@ -27,3 +26,2 @@\n-primitive class SuperNotAllowedInPrimitiveCtor {\n-\n-    SuperNotAllowedInPrimitiveCtor() {\n+value class SuperNotAllowedInValueClassCtor {\n+    SuperNotAllowedInValueClassCtor() {\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SuperNotAllowedInPrimitiveCtor.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-\/\/ options: -XDenablePrimitiveClasses\n@@ -28,1 +27,1 @@\n-primitive class TypeReqIdentity {\n+value class TypeReqIdentity {\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqIdentity.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInDeconstructionPatterns2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314226.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/Unnamed.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                \"- compiler.note.proc.messager: visiting: NonSealedClass1 Modifiers: [non-sealed]\",\n+                \"- compiler.note.proc.messager: visiting: NonSealedClass1 Modifiers: [non-sealed, identity]\",\n@@ -121,1 +121,1 @@\n-                \"- compiler.note.proc.messager: visiting: SealedClass Modifiers: [sealed]\",\n+                \"- compiler.note.proc.messager: visiting: SealedClass Modifiers: [sealed, identity]\",\n@@ -125,1 +125,1 @@\n-                \"- compiler.note.proc.messager: visiting: FinalClass Modifiers: [final]\",\n+                \"- compiler.note.proc.messager: visiting: FinalClass Modifiers: [identity, final]\",\n@@ -127,1 +127,1 @@\n-                \"- compiler.note.proc.messager: visiting: NonSealedClass2 Modifiers: [non-sealed]\",\n+                \"- compiler.note.proc.messager: visiting: NonSealedClass2 Modifiers: [non-sealed, identity]\",\n@@ -129,1 +129,1 @@\n-                \"- compiler.note.proc.messager: visiting: ClassOutOfSealedHierarchy Modifiers: []\",\n+                \"- compiler.note.proc.messager: visiting: ClassOutOfSealedHierarchy Modifiers: [identity]\",\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestSealed.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308590\n+ * @summary Test basic modeling for value classes\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask JavacTestingAbstractProcessor\n+ * @run main TestValueClasses\n+ *\/\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+import java.time.*;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestValueClasses extends TestRunner {\n+\n+    protected ToolBox tb;\n+\n+    TestValueClasses() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestValueClasses().runTests();\n+    }\n+\n+    \/**\n+     * Run all methods annotated with @Test, and throw an exception if any\n+     * errors are reported..\n+     *\n+     * @throws Exception if any errors occurred\n+     *\/\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    void checkOutputContains(String log, String... expect) throws Exception {\n+        for (String e : expect) {\n+            if (!log.contains(e)) {\n+                throw new Exception(\"expected output not found: \" + e);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testValueClassesProcessor(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path r = src.resolve(\"Test\");\n+\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(r,\n+                \"\"\"\n+                value interface ValueInterface {}\n+\n+                identity interface IdentityInterface {}\n+\n+                value class ValueClass {}\n+\n+                identity class IdentityClass {}\n+                \"\"\"\n+        );\n+\n+        List<String> expected = List.of(\n+                \"- compiler.note.proc.messager: visiting: ValueInterface Modifiers: [abstract, value]\",\n+                \"- compiler.note.proc.messager: visiting: IdentityInterface Modifiers: [abstract, identity]\",\n+                \"- compiler.note.proc.messager: visiting: ValueClass Modifiers: [value, final]\",\n+                \"- compiler.note.proc.messager:     constructor modifiers: []\",\n+                \"- compiler.note.proc.messager: visiting: IdentityClass Modifiers: [identity]\",\n+                \"- compiler.note.proc.messager:     constructor modifiers: []\"\n+        );\n+\n+        for (Mode mode : new Mode[] {Mode.API}) {\n+            List<String> log = new JavacTask(tb, mode)\n+                    .options(\"-processor\", ValueClassesProcessor.class.getName(),\n+                            \"-XDrawDiagnostics\")\n+                    .files(findJavaFiles(src))\n+                    .outdir(classes)\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+            System.out.println(\"log:\" +log);\n+\n+            if (!expected.equals(log)) {\n+                if (expected.size() == log.size()) {\n+                    for (int i = 0; i < expected.size(); i++) {\n+                        if (!expected.get(i).equals(log.get(i))) {\n+                            System.err.println(\"failing at line \" + (i + 1));\n+                            System.err.println(\"    expecting \" + expected.get(i));\n+                            System.err.println(\"    found \" + log.get(i));\n+                        }\n+                    }\n+                } else {\n+                    System.err.println(\"expected and log lists differ in length\");\n+                }\n+                throw new AssertionError(\"Unexpected output: \" + log);\n+            }\n+        }\n+    }\n+\n+    public static final class ValueClassesProcessor extends JavacTestingAbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver()) {\n+                Messager messager = processingEnv.getMessager();\n+                ElementScanner scanner = new ValueClassesScanner(messager);\n+                for(Element rootElement : roundEnv.getRootElements()) {\n+                    scanner.visit(rootElement);\n+                }\n+            }\n+            return true;\n+        }\n+\n+        class ValueClassesScanner extends ElementScanner<Void, Void> {\n+\n+            Messager messager;\n+\n+            public ValueClassesScanner(Messager messager) {\n+                this.messager = messager;\n+            }\n+\n+            @Override\n+            public Void visitType(TypeElement element, Void p) {\n+                messager.printNote(\"visiting: \" + element.getSimpleName() + \" Modifiers: \" + element.getModifiers());\n+                List<? extends Element> enclosedElements = element.getEnclosedElements();\n+                for (Element elem : enclosedElements) {\n+                    System.out.println(\"visiting \" + elem.getSimpleName());\n+                    switch (elem.getSimpleName().toString()) {\n+                        case \"<init>\":\n+                            messager.printNote(\"    constructor modifiers: \" + elem.getModifiers());\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                }\n+                return super.visitType(element, p);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestValueClasses.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -129,64 +129,0 @@\n-\n-    @Test\n-    public void testPrimitiveRecordClassFileReading(Path base) throws Exception {\n-        Path src = base.resolve(\"src\");\n-\n-        tb.writeJavaFiles(src,\n-                           \"\"\"\n-                           public primitive record R(int i, @A long j, java.util.List<String> l) {}\n-                           \"\"\",\n-                           \"\"\"\n-                           public @interface A {}\n-                           \"\"\");\n-\n-        Path out = base.resolve(\"out\");\n-        Files.createDirectories(out);\n-\n-        new JavacTask(tb)\n-                .outdir(out)\n-                .options(\"-XDenablePrimitiveClasses\")\n-                .files(findJavaFiles(src))\n-                .run();\n-\n-        \/\/read the class file back, to verify javac's ClassReader\n-        \/\/reads the Record attribute properly:\n-        String output = new JavacTask(tb)\n-                .options(\"-Xprint\", \"-XDenablePrimitiveClasses\")\n-                .classpath(out.toString())\n-                .classes(\"R\")\n-                .run()\n-                .writeAll()\n-                .getOutput(Task.OutputKind.STDOUT)\n-                .replaceAll(\"\\\\R\", \"\\n\");\n-\n-        String expected =\n-                \"\"\"\n-                \\n\\\n-                public primitive value record R(int i, @A long j, java.util.List<java.lang.String> l) {\n-                  private final int i;\n-                  @A\n-                  private final long j;\n-                  private final java.util.List<java.lang.String> l;\n-                \\n\\\n-                  public final java.lang.String toString();\n-                \\n\\\n-                  public final int hashCode();\n-                \\n\\\n-                  public final boolean equals(java.lang.Object arg0);\n-                \\n\\\n-                  public int i();\n-                \\n\\\n-                  @A\n-                  public long j();\n-                \\n\\\n-                  public java.util.List<java.lang.String> l();\n-                \\n\\\n-                  public R(int i,\n-                    @A long j,\n-                    java.util.List<java.lang.String> l);\n-                }\n-                \"\"\";\n-        if (!Objects.equals(expected, output)) {\n-            throw new AssertionError(\"Unexpected output: \" + output);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/records\/RecordReading.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedLocalVariableTable.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8212175\n- * @summary Trouble creating an anonymous value class with diamond syntax\n- * @compile -XDenablePrimitiveClasses AnonymousValue.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses AnonymousValue\n- *\/\n-\n-import java.util.function.Function;\n-\n-public class AnonymousValue {\n-\t static Function<String, String> capitalizer() {\n-        return new primitive Function<>() {\n-            int x = 10;\n-\t\t\t@Override\n-\t\t\tpublic String apply(String t) {\n-\t\t\t\treturn t.toUpperCase();\n-\t\t\t}\n-        };\n-\t }\n-     public static void main(String[] args) {\n-\t\t if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n-            throw new AssertionError(\"Failed\");\n-\t }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValue.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile -XDenablePrimitiveClasses AnonymousValueType.java\n+ * @compile AnonymousValueType.java\n@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -35,1 +36,1 @@\n-        Object o = new primitive Comparable<String>() {\n+        Object o = new value Comparable<String>() {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValueType.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @compile -XDenablePrimitiveClasses ArrayCreationWithQuestion.java\n+ * @compile ArrayCreationWithQuestion.java\n@@ -40,5 +40,8 @@\n-    static primitive class VT {\n-        VT.ref[] a1 = new VT.ref[42];\n-        VT.ref[] a2 = new VT.ref[42];\n-        VT[] a3 = new VT[42];\n-        VT[] a4 = new VT[42];\n+    static value class VT {\n+        VT[] a1;\n+        VT[] a2;\n+\n+        VT(boolean non_implicit) {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+        }\n@@ -58,2 +61,0 @@\n-        \"        28: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n-        \"        39: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayCreationWithQuestion.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses ArrayRelationsTest.java\n+ * @compile ArrayRelationsTest.java\n@@ -32,0 +32,1 @@\n+ * @ignore\n@@ -34,1 +35,1 @@\n-public primitive class ArrayRelationsTest {\n+public value class ArrayRelationsTest {\n@@ -36,1 +37,1 @@\n-    int x = 42;\n+    int x;\n@@ -39,1 +40,1 @@\n-        ArrayRelationsTest.ref [] la = new ArrayRelationsTest.ref[10];\n+        ArrayRelationsTest [] la = new ArrayRelationsTest[10];\n@@ -51,1 +52,1 @@\n-        ArrayRelationsTest.ref[] la2 = qa;\n+        ArrayRelationsTest[] la2 = qa;\n@@ -75,1 +76,1 @@\n-        qa = (ArrayRelationsTest[]) (la = (ArrayRelationsTest.ref []) (oa = (Object []) o));\n+        qa = (ArrayRelationsTest[]) (la = (ArrayRelationsTest []) (oa = (Object []) o));\n@@ -87,12 +88,0 @@\n-\n-        la = new ArrayRelationsTest.ref [10];\n-\n-        cce = false;\n-        try {\n-            qa = (ArrayRelationsTest[]) la;\n-        } catch (ClassCastException c) {\n-            cce = true;\n-        }\n-        if (!cce) {\n-            throw new AssertionError(\"Unexpected CCE behavior\");\n-        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayRelationsTest.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses AsSuperTests.java\n+ * @compile AsSuperTests.java\n@@ -61,1 +61,1 @@\n-    static primitive class Foo<X> extends Base {}\n+    static value class Foo<X> extends Base {}\n@@ -64,1 +64,1 @@\n-primitive class X extends Base implements I {\n+value class X extends Base implements I {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AsSuperTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AssortedTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AttributesTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AutoCloseableTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8214299\n- * @summary Strange errors from javac when mixing box and val types.\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n- *\/\n-\n-public class BogusIncompatibility {\n-  MyValue.ref field = MyValue.create();\n-  MyValue.ref field2 = MyValue.create();\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BogusIncompatibility.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CanonicalCtorTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNoNullCheckTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNullCheckTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ChainedAssignmentTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237067\n- * @summary [lworld] Check good and bad selectors on a type name\n- * @compile\/fail\/ref=CheckBadSelector.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckBadSelector.java\n- *\/\n-\n-primitive final class Point {\n-\n-    void badSelector() {\n-        Class<?> c = int.class;\n-        int i = int.default;\n-        int x = int.whatever;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckBadSelector.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -5,0 +5,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckCyclicMembership.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,11 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check that a concrete class is not allowed to be the super class of a primitive class\n- *\n- * @compile\/fail\/ref=CheckExtends.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckExtends.java\n- *\/\n-\n-final primitive class CheckExtends extends Object {\n-    static class NestedConcrete {}\n-    static primitive class NestedPrimitive extends NestedConcrete {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CheckExtends.java:10:22: compiler.err.concrete.supertype.for.value.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237067\n- * @summary Check that feature gated constructs are not allowed in previous versions.\n- * @compile\/fail\/ref=CheckFeatureGate1.out --release=13 -XDrawDiagnostics CheckFeatureGate1.java\n- *\/\n-\n-public class CheckFeatureGate1 {\n-\n-    static primitive class Val {\n-        public int v = 42;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CheckFeatureGate1.java:10:12: compiler.err.primitive.classes.not.supported: 21\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237067\n- * @summary Check that .default is not allowed in previous versions.\n- * @compile\/fail\/ref=CheckFeatureGate2.out --release=13 -XDrawDiagnostics CheckFeatureGate2.java\n- *\/\n-\n-public class CheckFeatureGate2 {\n-\n-    static <T> void checkDefaultT(Class<T> clazz) throws Exception {\n-        while (T.default != null)\n-            throw new AssertionError(\"Generic object should default to null\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        int a = int.default;\n-        String s = String.default;\n-        int[] ia = int[].default;\n-        checkDefaultT(Object.class);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CheckFeatureGate2.java:11:17: compiler.err.primitive.classes.not.supported: 21\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFieldDescriptors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlags.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableCycles.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableFlagFromClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableSyntheticFields.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash01.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckLocalClasses.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various semantic constraints on value creation via default\n- *\n- * @compile\/fail\/ref=CheckMakeDefault.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckMakeDefault.java\n- *\/\n-primitive final class Point {\n-\n-    primitive interface I { int x = 10; } \/\/ Error\n-    primitive abstract class A { int x = 10; } \/\/ Error\n-    static final class Sinner {\n-        static Sinner make() {\n-            return Sinner.default;\n-        }\n-    }\n-\n-    primitive static final class SinnerValue {\n-        static SinnerValue make() {\n-            return SinnerValue.default;\n-        } int x = 10;\n-    }\n-\n-    final int x;\n-    final int y;\n-\n-    final int nonbool = boolean.default;\n-    final boolean nonbyte = byte.default;\n-    final boolean nonchar = char.default;\n-    final boolean nonint = int.default;\n-    final boolean nonshort = short.default;\n-    final boolean nonlong = long.default;\n-    final boolean nonfloat = float.default;\n-    final boolean nondouble = double.default;\n-    final int nonString = String.default;\n-    final int nonbyteArray = byte[].default;\n-\n-    Point() {}\n-    Point (int x, int y) {}\n-\n-    static Point make(int x, int y) {\n-       Point p = Point.default;\n-       String s = String.default;\n-       Object o = SinnerValue.default;\n-       return new Point(x, y);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -5,0 +5,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullAssign.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullCastable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullWithQuestion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckStaticFinalAssign.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSuperCompileOnly.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n@@ -10,1 +11,1 @@\n-\tprivate final int x, ymx;\n+    private final int x, ymx;\n@@ -12,1 +13,1 @@\n-\tV(int x, int y) {\n+    V(int x, int y) {\n@@ -14,2 +15,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -17,3 +18,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n+        validate();                 \/\/ BAD to call instance method DU = {x, ymx}\n+        this.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n@@ -21,2 +22,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n@@ -24,2 +25,2 @@\n-\t\tV v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        V v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n@@ -27,2 +28,2 @@\n-\t\tymx = y - x;                \/\/ OK, implicit this for field write.\n-\t\tint l = this.ymx;           \/\/ OK, explicit this for DA field read.\n+        ymx = y - x;                \/\/ OK, implicit this for field write.\n+        int l = this.ymx;           \/\/ OK, explicit this for DA field read.\n@@ -30,2 +31,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -33,3 +34,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x}\n+        validate();                 \/\/ BAD to call instance method DU = {x}\n+        this.validate();            \/\/ BAD to call instance method DU = {x}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x}\n@@ -37,2 +38,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n@@ -40,2 +41,2 @@\n-\t\tv = this;                   \/\/ BAD to create alias  DU = {x}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x}\n+        v = this;                   \/\/ BAD to create alias  DU = {x}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x}\n@@ -43,1 +44,1 @@\n-\t\tthis.x = x;\n+        this.x = x;\n@@ -47,2 +48,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -50,3 +51,3 @@\n-\t\tvalidate();                 \/\/ OK: DU = {}\n-\t\tthis.validate();            \/\/ OK: DU = {}\n-\t\tV.this.validate();          \/\/ OK: DU = {}\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        V.this.validate();          \/\/ OK: DU = {}\n@@ -54,2 +55,2 @@\n-\t\tSystem.out.println(this);   \/\/ OK: DU = {}\n-\t\tSystem.out.println(V.this); \/\/ OK: DU = {}\n+        System.out.println(this);   \/\/ OK: DU = {}\n+        System.out.println(V.this); \/\/ OK: DU = {}\n@@ -57,5 +58,5 @@\n-\t\tv = this;                   \/\/ OK: DU = {}\n-\t\tv = V.this;                 \/\/ OK: DU = {}\n-\t\tassert (this.x > 0);        \/\/ OK: DU = {}\n-\t\tassert (this.y() > 0);      \/\/ OK: DU = {}\n-\t}\n+        v = this;                   \/\/ OK: DU = {}\n+        v = V.this;                 \/\/ OK: DU = {}\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n@@ -63,1 +64,1 @@\n-\tV() { \/\/ non-initial constructor. All, statements below are OK.\n+    V() { \/\/ non-initial constructor. All, statements below are OK.\n@@ -65,2 +66,2 @@\n-\t\tOK();                       \n-\t\tthis.OK();                  \n+        OK();\n+        this.OK();\n@@ -68,3 +69,3 @@\n-\t\tvalidate();                 \n-\t\tthis.validate();            \n-\t\tV.this.validate();          \n+        validate();\n+        this.validate();\n+        V.this.validate();\n@@ -72,2 +73,2 @@\n-\t\tSystem.out.println(this);   \n-\t\tSystem.out.println(V.this); \n+        System.out.println(this);\n+        System.out.println(V.this);\n@@ -75,2 +76,2 @@\n-\t\tV v = this;                 \n-\t\tv = V.this;                 \n+        V v = this;\n+        v = V.this;\n@@ -78,1 +79,1 @@\n-\t\tint l = this.ymx;           \n+        int l = this.ymx;\n@@ -80,3 +81,3 @@\n-\t\tassert (this.x > 0);        \n-\t\tassert (this.y() > 0);      \n-\t}\n+        assert (this.x > 0);\n+        assert (this.y() > 0);\n+    }\n@@ -84,2 +85,2 @@\n-\tstatic void OK() {\n-\t}\n+    static void OK() {\n+    }\n@@ -87,3 +88,3 @@\n-\tint x() {\n-\t\treturn x;\n-\t}\n+    int x() {\n+        return x;\n+    }\n@@ -91,3 +92,3 @@\n-\tint y() {\n-\t\treturn ymx + x;\n-\t}\n+    int y() {\n+        return ymx + x;\n+    }\n@@ -95,3 +96,3 @@\n-\tvoid validate() {\n-\t\tassert (x() > 0 && y() > 0);\n-\t}\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n@@ -99,5 +100,5 @@\n-\tpublic static void main(String... av) {\n-\t\tV z = new V(1, 10);\n-\t\tassert (z.x() == 1);\n-\t\tassert (z.y() == 10);\n-\t}\n+    public static void main(String... av) {\n+        V z = new V(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.java","additions":66,"deletions":65,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckValueModifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralNegativeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilerNoBogusAssert.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilesJustFine.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalInlineTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConstantPropagationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CtorChain.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultNonInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultOfPrimitiveReference.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n@@ -42,1 +43,1 @@\n- \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DocLintSyntheticsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DualNonDuplicateErrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EmptyValueTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EnhancedForLoopTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes3.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayRegression.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -35,1 +36,1 @@\n-  \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues1.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -37,1 +38,1 @@\n-  \n+\n@@ -41,1 +42,1 @@\n-  \n+\n@@ -45,1 +46,1 @@\n-  \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues2.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -37,1 +38,1 @@\n-  \n+\n@@ -41,1 +42,1 @@\n-  \n+\n@@ -44,1 +45,1 @@\n-    \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues3.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues4.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues5.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GetClassTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InferredValueParameterizationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineClassTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineDiamondTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerClassAttributeValuenessTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InstanceofProjectionArray.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LocalValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LubWithInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoCrashTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoUnnecessaryCast.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ParameterizedDefault.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Point.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PreloadAttributeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectedArrayDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProperTypeApplySelectTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QPointConsumer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -34,1 +35,1 @@\n-    class Inner { \n+    class Inner {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedSuperCtor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedThisTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/RefDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileGenerics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest01.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -46,1 +47,1 @@\n-            int l = 1234; \n+            int l = 1234;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SignatureTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SmallSetTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StaticSelectedThroughProjection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StreamsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperHashCodeEqualsToStringTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/T8279655.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestQualifierOnInit.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestReflectiveMirrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ThisIsNotAnInstanceField.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnannotatedProjection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassInnerClassesTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassNestHostTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnrelatedThisLeak.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAsEnclosingClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueBootstrapMethodsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -43,2 +44,2 @@\n-    \n-    public static void main(String [] args) {   \n+\n+    public static void main(String [] args) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueConstructorRef.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueCreationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueNewReadWrite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValuesAsRefs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8205686 8215109\n- * @summary __WithField seems to have trouble if the value type is a generic type.\n- * @compile -XDenablePrimitiveClasses WithFieldOfGenericType.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses WithFieldOfGenericType\n- *\/\n-\n-public final primitive class WithFieldOfGenericType<E> {\n-  private final boolean value;\n-\n-  public static <E> WithFieldOfGenericType<E> create() {\n-    return new WithFieldOfGenericType<>(true);\n-  }\n-\n-  private WithFieldOfGenericType(boolean value) {\n-    this.value = value;\n-  }\n-\n-  public static void main(String[] args) {\n-     WithFieldOfGenericType<String> w = create();\n-     if (w.value != true)\n-        throw new AssertionError(\"Withfield didn't work!\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldOfGenericType.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldRuntimeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n@@ -54,1 +55,1 @@\n-public primitive record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n+public value record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8212175\n+ * @summary Trouble creating an anonymous value class with diamond syntax\n+ * @ignore 8316628\n+ *\/\n+\n+import java.util.function.Function;\n+\n+public class AnonymousValue {\n+    static Function<String, String> capitalizer() {\n+        return new value Function<>() {\n+            int x = 10;\n+            @Override\n+            public String apply(String t) {\n+                return t.toUpperCase();\n+            }\n+        };\n+    }\n+    public static void main(String[] args) {\n+        if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n+            throw new AssertionError(\"Failed\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValue.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8209400 8215246\n+ * @summary Allow anonymous classes to be value types\n+ * @ignore 8316628\n+ *\/\n+\n+public class AnonymousValueType {\n+    public static void main(String[] args) {\n+        Object o = new value Comparable<String>() {\n+            int x = 10;\n+            @Override\n+            public int compareTo(String o) {\n+                return 0;\n+            }\n+        };\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n+            throw new AssertionError(\"Broken\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValueType.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8222634\n+ * @summary Check array creation with V and V.ref\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @modules jdk.compiler\n+ * @compile ArrayCreationWithQuestion.java\n+ * @run main ArrayCreationWithQuestion\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+public class ArrayCreationWithQuestion {\n+\n+    static value class VT {\n+        VT[] a1;\n+        VT[] a2;\n+\n+        VT() {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new ArrayCreationWithQuestion().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                Paths.get(System.getProperty(\"test.classes\"),\n+                        \"ArrayCreationWithQuestion$VT.class\").toString() };\n+        runCheck(params, new String [] {\n+                \"         7: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        16: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        });\n+\n+    }\n+\n+    void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+        if (errors > 0) {\n+            throw new AssertionError(\"Unexpected javap output: \" + out);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8208067\n+ * @summary Verify that instance methods are callable from ctor after all instance fields are DA.\n+ * @ignore\n+ *\/\n+\n+\/\/ see JDK-8316628\n+public value class CanonicalCtorTest {\n+\n+    private final int x, ymx;\n+\n+    CanonicalCtorTest(int x, int y) {\n+\n+        ymx = y - x;\n+        this.x = x;\n+\n+        \/\/ ALL fields are assigned now.\n+\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        CanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n+\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n+\n+    int x() {\n+        return x;\n+    }\n+\n+    int y() {\n+        return ymx + x;\n+    }\n+\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n+\n+    public static void main(String... av) {\n+        CanonicalCtorTest z = new CanonicalCtorTest(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various semantic constraints on value creation via default\n- *\n- * @compile\/fail\/ref=CheckMakeDefault.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckMakeDefault.java\n- *\/\n-value final class Point {\n-\n-    value interface I { int x = 10; }\n-    value abstract class A { int x = 10; }\n-    static final class Sinner {\n-        static Sinner make() {\n-            return Sinner.default;\n-        }\n-    }\n-\n-    value static final class SinnerValue {\n-        static SinnerValue make() {\n-            return SinnerValue.default;\n-        } int x = 10;\n-    }\n-\n-    final int x;\n-    final int y;\n-\n-    final int nonbool = boolean.default;\n-    final boolean nonbyte = byte.default;\n-    final boolean nonchar = char.default;\n-    final boolean nonint = int.default;\n-    final boolean nonshort = short.default;\n-    final boolean nonlong = long.default;\n-    final boolean nonfloat = float.default;\n-    final boolean nondouble = double.default;\n-    final int nonString = String.default;\n-    final int nonbyteArray = byte[].default;\n-\n-    Point() {}\n-    Point (int x, int y) {}\n-\n-    static Point make(int x, int y) {\n-       Point p = Point.default;\n-       String s = String.default;\n-       Object o = SinnerValue.default;\n-       return new Point(x, y);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckMakeDefault.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore Verifier error\n@@ -49,1 +50,1 @@\n-    public static primitive class P {\n+    public static class P {\n@@ -62,1 +63,1 @@\n-        Supplier<P.ref> sxp = P::new;\n+        Supplier<P> sxp = P::new;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConstructorRefTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * @compile\/fail\/ref=ConsumeValueClassAtLowerLevel.out --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n+ * @compile --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n@@ -12,4 +12,0 @@\n-        \/* GenericPoint was compiled with a source that allows value classes but ConsumeValueClassAtLowerLevel was not\n-         * so GenericPoint has a <vnew> initializer but in a source that doesn't allow value classes we look for <ini>\n-         * thus the compiler error in the second compilation of ConsumeValueClassAtLowerLevel.java\n-         *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConsumeValueClassAtLowerLevel.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,3 +65,1 @@\n-         \/\/ Check that constructor invocation has been lowered into invokestatic\n-         \/\/ of the factory method.\n-         \"4: invokestatic  #10                 \/\/ Method \\\"<vnew>\\\":(II)LValueCreationTest$Point;\",\n+         \"0: new           #8                  \/\/ class ValueCreationTest$Point\",\n@@ -72,17 +70,12 @@\n-         \"static ValueCreationTest$Point ValueCreationTest$Point(int, int);\",\n-         \"descriptor: (II)LValueCreationTest$Point;\",\n-         \"flags: (0x0008) ACC_STATIC\",\n-         \"0: aconst_init   #1                  \/\/ class ValueCreationTest$Point\",\n-         \"3: astore_2\",\n-         \"4: iload_0\",\n-         \"5: aload_2\",\n-         \"6: swap\",\n-         \"7: withfield     #3                  \/\/ Field x:I\",\n-        \"10: astore_2\",\n-        \"11: iload_1\",\n-        \"12: aload_2\",\n-        \"13: swap\",\n-        \"14: withfield     #7                  \/\/ Field y:I\",\n-        \"17: astore_2\",\n-        \"18: aload_2\",\n-        \"19: areturn\"\n+         \"ValueCreationTest$Point(int, int);\",\n+         \"descriptor: (II)V\",\n+         \"flags: (0x0000)\",\n+         \"0: aload_0\",\n+         \"1: invokespecial #1                  \/\/ Method java\/lang\/Object.\\\"<init>\\\":()V\",\n+         \"4: aload_0\",\n+         \"5: iload_1\",\n+         \"6: putfield      #7                  \/\/ Field x:I\",\n+         \"9: aload_0\",\n+        \"10: iload_2\",\n+        \"11: putfield      #13                 \/\/ Field y:I\",\n+        \"14: return\"\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -45,0 +45,4 @@\n+import com.sun.tools.javac.util.Assert;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.Attributes;\n@@ -190,15 +194,7 @@\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-XDenablePrimitiveClasses\"};\n-            setCompileOptions(testOptions);\n-            String[] sources = new String[] {\n-                    \"static static class StaticTest {}\",\n-                    \"native native class NativeTest {}\",\n-                    \"value value primitive class ValueTest {}\",\n-                    \"primitive primitive value class PrimitiveTest {}\"\n-            };\n-            for (String source : sources) {\n-                assertFail(\"compiler.err.repeated.modifier\", source);\n-            }\n-        } finally {\n-            setCompileOptions(previousOptions);\n+        String[] sources = new String[] {\n+                \"static static class StaticTest {}\",\n+                \"native native class NativeTest {}\",\n+                \"value value class ValueTest {}\"\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.repeated.modifier\", source);\n@@ -749,2 +745,2 @@\n-    public void testCheckVnew() throws Exception {\n-        for (String source : List.of(\n+    public void testSelectors() throws Exception {\n+        assertOK(\n@@ -752,2 +748,5 @@\n-                abstract value class A {}\n-                \"\"\",\n+                value class V {\n+                    void selector() {\n+                        Class<?> c = int.class;\n+                    }\n+                }\n@@ -755,1 +754,2 @@\n-                value class A {}\n+        );\n+        assertFail(\"compiler.err.expected\",\n@@ -757,14 +757,3 @@\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                boolean isAbstract = classFile.access_flags.is(Flags.ABSTRACT);\n-                for (Method method : classFile.methods) {\n-                    if (isAbstract) {\n-                        assertTrue(method.getName(classFile.constant_pool).equals(\"<init>\"));\n-                        assertTrue(!method.access_flags.is(Flags.STATIC));\n-                    } else {\n-                        assertTrue(method.getName(classFile.constant_pool).equals(\"<vnew>\"));\n-                        assertTrue(method.access_flags.is(Flags.STATIC));\n-                        assertTrue(!method.access_flags.is(Flags.ABSTRACT));\n-                        assertTrue(method.descriptor.getReturnType(classFile.constant_pool).equals(\"A\"));\n+                value class V {\n+                    void selector() {\n+                        int i = int.some_selector;\n@@ -773,0 +762,8 @@\n+                \"\"\"\n+        );\n+    }\n+\n+    private File findClassFileOrFail(File dir, String name) {\n+        for (final File fileEntry : dir.listFiles()) {\n+            if (fileEntry.getName().equals(name)) {\n+                return fileEntry;\n@@ -775,0 +772,2 @@\n+        throw new AssertionError(\"file not found\");\n+    }\n@@ -776,28 +775,8 @@\n-        \/\/ check that <vnew> is invoked with invokestatic\n-        for (String source : List.of(\n-                \"\"\"\n-                value class A {\n-                    void FIND_ME() {\n-                        A a = new A();\n-                    }\n-                }\n-                \"\"\"\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"FIND_ME\")) {\n-                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n-                        boolean firstInst = true;\n-                        for (Instruction inst: code_attribute.getInstructions()) {\n-                            if (firstInst) {\n-                                assertTrue(inst.getMnemonic().equals(\"invokestatic\"));\n-                                CONSTANT_Methodref_info methodInfo =\n-                                        (CONSTANT_Methodref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(methodInfo.getClassInfo().getName().equals(\"A\"));\n-                                assertTrue(methodInfo.getNameAndTypeInfo().getName().equals(\"<vnew>\"));\n-                                break;\n-                            }\n-                        }\n-                    }\n+    private Attribute findAttributeOrFail(Attributes attributes, Class<? extends Attribute> attrClass, int numberOfAttributes) {\n+        int attrCount = 0;\n+        Attribute result = null;\n+        for (Attribute attribute : attributes) {\n+            if (attribute.getClass() == attrClass) {\n+                attrCount++;\n+                if (result == null) {\n+                    result = attribute;\n@@ -807,0 +786,4 @@\n+        if (attrCount == 0) throw new AssertionError(\"attribute not found\");\n+        if (attrCount != numberOfAttributes) throw new AssertionError(\"incorrect number of attributes found\");\n+        return result;\n+    }\n@@ -808,38 +791,4 @@\n-        \/\/ checking the aconst_init and withfield instructions\n-        for (String source : List.of(\n-                \"\"\"\n-                value class A {\n-                    int i;\n-                    String s;\n-\n-                    A(int i, String s) {\n-                        this.i = i;\n-                        this.s = s;\n-                    }\n-                }\n-                \"\"\"\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"<vnew>\")) {\n-                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n-                        for (Instruction inst: code_attribute.getInstructions()) {\n-                            if (inst.getMnemonic().equals(\"aconst_init\")) {\n-                                CONSTANT_Class_info classInfo =\n-                                        (CONSTANT_Class_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(classInfo.getName().equals(\"A\"));\n-                            } else if (inst.getMnemonic().equals(\"withfield\")) {\n-                                CONSTANT_Fieldref_info fieldInfo = (CONSTANT_Fieldref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(fieldInfo.getClassName().equals(\"A\"));\n-                                ConstantPool.CONSTANT_NameAndType_info nameAndType = fieldInfo.getNameAndTypeInfo();\n-                                if (nameAndType.getName().equals(\"i\")) {\n-                                    assertTrue(nameAndType.getType().equals(\"I\"));\n-                                } else if (nameAndType.getName().equals(\"s\")) {\n-                                    assertTrue(nameAndType.getType().equals(\"Ljava\/lang\/String;\"));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+    private void checkAttributeNotPresent(Attributes attributes, Class<? extends Attribute> attrClass) {\n+        for (Attribute attribute : attributes) {\n+            if (attribute.getClass() == attrClass) {\n+                throw new AssertionError(\"attribute found\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":49,"deletions":100,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectsBinaryCompatibilityTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various withfield constrains\n- * @compile\/fail\/ref=WithFieldNegativeTests.out -XDrawDiagnostics -XDenablePrimitiveClasses WithFieldNegativeTests.java\n- *\/\n-\n-value final class A {\n-    final int x = 10;\n-    static final int sx = 10;\n-\n-    value final class B {\n-\n-        final A a = A.default;\n-\n-        void foo(A a) {\n-            a.x = 100;\n-            a.sx = 100;\n-        }\n-    }\n-\n-    void withfield(B b) {\n-            b.a.x = 11;\n-    }\n-\n-    void foo(A a, final A fa) {\n-        a.x = 100;\n-        (a).x = 100;\n-        fa.x = 100;\n-        x = 100;\n-        this.x = 100;\n-        A.this.x = 100;\n-    }\n-}\n-\n-class C {\n-    void foo(A a) {\n-        a.x = 100;\n-        a.sx = 100;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldNegativeTests.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-WithFieldNegativeTests.java:16:14: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:17:14: compiler.err.cant.assign.val.to.var: static final, sx\n-WithFieldNegativeTests.java:22:16: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:26:10: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:27:12: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:28:11: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:29:9: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:30:13: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:31:15: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:37:10: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:38:10: compiler.err.cant.assign.val.to.var: static final, sx\n-11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldNegativeTests.out","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8205686 8215109\n- * @summary __WithField seems to have trouble if the value type is a generic type.\n- * @compile -XDrawDiagnostics -XDdev WithFieldOfGenericType.java\n- * @run main\/othervm WithFieldOfGenericType\n- *\/\n-\n-public final value class WithFieldOfGenericType<E> {\n-  private final boolean value;\n-\n-  public static <E> WithFieldOfGenericType<E> create() {\n-    return new WithFieldOfGenericType<>(true);\n-  }\n-\n-  private WithFieldOfGenericType(boolean value) {\n-    this.value = value;\n-  }\n-\n-  public static void main(String[] args) {\n-     WithFieldOfGenericType<String> w = create();\n-     if (w.value != true)\n-        throw new AssertionError(\"Withfield didn't work!\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldOfGenericType.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/class_flags\/CheckClassfileFlagsTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,2 @@\n+CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.signature: \"QValueWithInvalidFlags;\"))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/class_flags\/CheckClassfileFlagsTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/class_flags\/ValueWithInvalidFlags.jcod","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/ValueWithInvalidFlags.jcod","status":"renamed"},{"patch":"@@ -1,2 +0,0 @@\n-CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.class.signature: \"QValueWithInvalidFlags;\"))\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/separate_compilation\/ConcreteValue.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}