{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -1864,1 +1865,7 @@\n-        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n+        AllocateNode* alloc = AllocateNode::Ideal_allocation(arg);\n+        \/\/ Transitioning a value object to larval state disables it scalarization, this will make such\n+        \/\/ argument non-compliant with pre-computed domain calling convention.\n+        if (alloc && alloc->_larval) {\n+          env()->record_method_not_compilable(\"Passing non-scalarized value object in larval state will\"\n+                                              \" break domain calling convention\", false);\n+        }\n@@ -1957,0 +1964,9 @@\n+      Node* receiver = !call->method()->is_static() ? call->in(TypeFunc::Parms) : nullptr;\n+      if (ret->is_InlineType() &&\n+          receiver && receiver->bottom_type()->isa_instptr() &&\n+          receiver->bottom_type()->is_instptr()->instance_klass()->name()->get_symbol() == vmSymbols::jdk_internal_misc_Unsafe() &&\n+          call->method()->name()->get_symbol() == vmSymbols::makePrivateBuffer_name()) {\n+        \/\/ Re-buffer scalarized InlineTypeNodes returned from makePrivateBuffer\n+        \/\/ and transition the allocation into larval state.\n+        ret = ret->as_InlineType()->make_larval(this);\n+      }\n@@ -3458,1 +3474,1 @@\n-        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType() || obj->bottom_type()->is_inlinetypeptr(), \"should have been scalarized\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -724,1 +724,1 @@\n-        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n@@ -922,1 +922,1 @@\n-InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {\n+Node* InlineTypeNode::make_larval(GraphKit* kit) const {\n@@ -924,4 +924,0 @@\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n@@ -929,8 +925,7 @@\n-  if (allocate) {\n-    \/\/ Re-execute if buffering triggers deoptimization\n-    PreserveReexecuteState preexecs(kit);\n-    kit->jvms()->set_should_reexecute(true);\n-    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n-    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-    alloc->_larval = true;\n+  \/\/ Re-execute if buffering triggers deoptimization\n+  PreserveReexecuteState preexecs(kit);\n+  kit->jvms()->set_should_reexecute(true);\n+  Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+  Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+  alloc->_larval = true;\n@@ -938,8 +933,2 @@\n-    store(kit, alloc_oop, alloc_oop, vk);\n-    res->set_oop(alloc_oop);\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, true));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  assert(!allocate || res->is_allocated(&kit->gvn()), \"must be allocated\");\n-  return res;\n+  store(kit, alloc_oop, alloc_oop, vk);\n+  return alloc_oop;\n@@ -948,2 +937,1 @@\n-InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {\n-  Node* obj = get_oop();\n+InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk) {\n@@ -961,9 +949,1 @@\n-  ciInlineKlass* vk = inline_klass();\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, false));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  return res;\n+  return InlineTypeNode::make_from_oop(kit, obj, vk->inline_klass(), !vk->maybe_null());\n@@ -1175,1 +1155,1 @@\n-    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":14,"deletions":34,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -150,2 +150,2 @@\n-  InlineTypeNode* make_larval(GraphKit* kit, bool allocate) const;\n-  InlineTypeNode* finish_larval(GraphKit* kit) const;\n+  Node* make_larval(GraphKit* kit) const;\n+  static InlineTypeNode* finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2334,0 +2334,11 @@\n+  if (_gvn.type(base)->is_inlinetypeptr() && is_store) {\n+    \/\/ FIXME: Larval bit check is needed to preserve the semantics of value\n+    \/\/ objects which can be mutated only if its _larval bit is set. Since\n+    \/\/ the oop is not always an AllocateNode, we have to find an utility way\n+    \/\/ to check the larval state for all kind of oops.\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+    if (alloc != nullptr) {\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+    }\n+  }\n+\n@@ -2611,6 +2622,0 @@\n-  if (argument(1)->is_InlineType() && is_store) {\n-    InlineTypeNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(argument(1))->inline_klass());\n-    value = value->make_larval(this, false);\n-    replace_in_map(argument(1), value);\n-  }\n-\n@@ -2632,1 +2637,1 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  set_result(value->as_InlineType()->make_larval(this));\n@@ -2639,10 +2644,4 @@\n-  if (!buffer->is_InlineType()) {\n-    return false;\n-  }\n-  InlineTypeNode* vt = buffer->as_InlineType();\n-  if (!vt->is_allocated(&_gvn)) {\n-    return false;\n-  }\n-  \/\/ TODO 8239003 Why is this needed?\n-  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n-    return false;\n+\n+  \/\/ Incoming value should be a buffer with inline type and not InlineTypeNode.\n+  if (buffer->is_InlineType() || !buffer->bottom_type()->is_inlinetypeptr()) {\n+     return false;\n@@ -2651,3 +2650,6 @@\n-  receiver = null_check(receiver);\n-  if (stopped()) {\n-    return true;\n+  \/\/ Allocation node must exist to generate IR for transitioning allocation out\n+  \/\/ of larval state. Disable the intrinsic and take unsafe slow path if allocation\n+  \/\/ is not reachable,  oop returned by Unsafe_finishPrivateBuffer native method\n+  \/\/ will automatically rematerialize InlineTypeNode.\n+  if (AllocateNode::Ideal_allocation(buffer) == nullptr) {\n+     return false;\n@@ -2656,1 +2658,2 @@\n-  set_result(vt->finish_larval(this));\n+  const TypeInstPtr* ptr = buffer->bottom_type()->isa_instptr();\n+  set_result(InlineTypeNode::finish_larval(this, buffer, ptr));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -962,0 +962,5 @@\n+  \/\/ Bufferes in larval state should not be scalarized.\n+  if (alloc->_larval) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -613,3 +613,9 @@\n-      \/\/ Create InlineTypeNode from the oop and replace the parameter\n-      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n-      set_local(i, vt);\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(parm);\n+      if (alloc && alloc->_larval) {\n+        \/\/ Pass the larval state value parameter as it is to downstream graph.\n+        set_local(i, parm);\n+      } else {\n+        \/\/ Create InlineTypeNode from the oop and replace the parameter\n+        Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n+        set_local(i, vt);\n+      }\n@@ -1772,3 +1778,6 @@\n-          \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n-          assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n-          map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(n);\n+          if (alloc == nullptr || !alloc->_larval) {\n+            \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n+            assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n+            map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          }\n@@ -1879,1 +1888,1 @@\n-      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n+      } else if (m->is_InlineType() && n->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n@@ -1918,1 +1927,1 @@\n-      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr()) {\n+      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr() && m->is_InlineType() && n->is_InlineType()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8239003\n+ * @summary C2 should respect larval state when scalarizing\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/testlibrary \/test\/lib\n+ * @compile TestDeoptInLarvalState.java\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:CompileThresholdScaling=0.3 -XX:+UnlockDiagnosticVMOptions -XX:+PrintDeoptimizationDetails -XX:CompileOnly=compiler.valhalla.inlinetypes.TestDeoptInLarvalState::test1 --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED  compiler.valhalla.inlinetypes.TestDeoptInLarvalState\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:CompileThresholdScaling=0.3 -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:CompileOnly=compiler.valhalla.inlinetypes.TestDeoptInLarvalState::test2 -XX:CompileCommand=DontInline,compiler.valhalla.inlinetypes.TestDeoptInLarvalState::cleanup --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED  compiler.valhalla.inlinetypes.TestDeoptInLarvalState\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:CompileThresholdScaling=0.3 -XX:+UnlockDiagnosticVMOptions -XX:+PrintDeoptimizationDetails -XX:CompileOnly=compiler.valhalla.inlinetypes.TestDeoptInLarvalState::test2 --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED  compiler.valhalla.inlinetypes.TestDeoptInLarvalState\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+value class Pair {\n+    public double d1, d2;\n+    public Pair(double d1, double d2) {\n+        this.d1 = d1;\n+        this.d2 = d2;\n+    }\n+}\n+\n+public class TestDeoptInLarvalState {\n+    static final long OFFSET = 16;\n+\n+    public static Pair cleanup(Pair p) {\n+        return Unsafe.getUnsafe().finishPrivateBuffer(p);\n+    }\n+\n+    public static double test1(double value, int iter) {\n+        Pair p = Unsafe.getUnsafe().makePrivateBuffer(new Pair(10.0, 20.0));\n+        Unsafe.getUnsafe().putDouble(p, OFFSET, value);\n+        if (iter == 5000) {\n+           throw new RuntimeException(\"test1 : Failed to update p with value = \" + p.d1);\n+        }\n+        p = Unsafe.getUnsafe().finishPrivateBuffer(p);\n+        return p.d1 + p.d2;\n+    }\n+\n+    public static double test2(double value, int iter) {\n+        Pair p = Unsafe.getUnsafe().makePrivateBuffer(new Pair(10.0, 20.0));\n+        Unsafe.getUnsafe().putDouble(p, OFFSET, value);\n+        if (iter == 5000) {\n+           throw new RuntimeException(\"test2 : Failed to update p with value = \" + p.d1);\n+        }\n+        p = cleanup(p);\n+        return p.d1 + p.d2;\n+    }\n+\n+    public static void main(String[] args) {\n+        double res = 0.0;\n+        try {\n+            for (int i = 0; i < 10000; i++) {\n+                res += test1((double)i, i);\n+            }\n+            System.out.println(\"[res]\" + res);\n+        } catch (Exception e) {\n+            System.out.println(\"Caught Exception: \" + e);\n+        }\n+        try {\n+            for (int i = 0; i < 10000; i++) {\n+                res += test2((double)i, i);\n+            }\n+            System.out.println(\"[res]\" + res);\n+        } catch (Exception e) {\n+            System.out.println(\"Caught Exception: \" + e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptInLarvalState.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -408,1 +408,1 @@\n-    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    @IR(failOn = {CALL_UNSAFE})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8239003\n+ * @summary C2 should respect larval state when scalarizing\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/testlibrary \/test\/lib\n+ * @compile -XDenablePrimitiveClasses TestMaskedUnsafePutInLoop.java\n+ * @run main\/othervm\/timeout=300 -XX:-TieredCompilation -Xbatch -XX:+EnablePrimitiveClasses --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                               -XX:+UnlockDiagnosticVMOptions compiler.valhalla.inlinetypes.TestMaskedUnsafePutInLoop\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestMaskedUnsafePutInLoop {\n+     primitive class Pair {\n+         double d1, d2;\n+         public Pair(double d1, double d2) {\n+             this.d1 = d1;\n+             this.d2 = d2;\n+         }\n+     }\n+\n+     static final long[] OFFSETS = new long[] { 16, 24 };\n+\n+     public static Pair helper(double[] values, boolean[] mask) {\n+         Pair p = Unsafe.getUnsafe().makePrivateBuffer(Pair.default);\n+\n+         for (int i = 0; i < OFFSETS.length; i++) {\n+             if (mask[i]) {\n+                 Unsafe.getUnsafe().putDouble(p, OFFSETS[i], values[i]);\n+             }\n+         }\n+         return Unsafe.getUnsafe().finishPrivateBuffer(p);\n+    }\n+\n+\n+    public static double test(double[] values, boolean[] mask) {\n+         Pair p = helper(values, mask);\n+         return p.d1 + p.d2;\n+    }\n+\n+    public static void main(String[] args) {\n+        double[] values = new double[] { 1.0, 2.0 };\n+        boolean[] mask = new boolean[] { true, false };\n+\n+        double d = 0.0;\n+        for (int i = 0; i < 10000; i++) {\n+            d += test(values, mask);\n+        }\n+        if (d != 10000.0) {\n+            throw new AssertionError(\"Incorrect Result expected(10000.0) != actual(\" + d + \")\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMaskedUnsafePutInLoop.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}