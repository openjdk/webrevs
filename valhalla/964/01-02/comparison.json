{"files":[{"patch":"@@ -1865,1 +1865,7 @@\n-        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n+        AllocateNode* alloc = AllocateNode::Ideal_allocation(arg);\n+        \/\/ Transitioning a value object to larval state disables it scalarization, this will make such\n+        \/\/ argument non-compliant with pre-computed domain calling convention.\n+        if (alloc && alloc->_larval) {\n+          env()->record_method_not_compilable(\"Passing non-scalarized value object in larval state will\"\n+                                              \" break domain calling convention\", false);\n+        }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -613,3 +613,9 @@\n-      \/\/ Create InlineTypeNode from the oop and replace the parameter\n-      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n-      set_local(i, vt);\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(parm);\n+      if (alloc && alloc->_larval) {\n+        \/\/ Pass the larval state value parameter as it is to downstream graph.\n+        set_local(i, parm);\n+      } else {\n+        \/\/ Create InlineTypeNode from the oop and replace the parameter\n+        Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n+        set_local(i, vt);\n+      }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8239003\n+ * @summary C2 should respect larval state when scalarizing\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/testlibrary \/test\/lib\n+ * @compile TestDeoptInLarvalState.java\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:CompileThresholdScaling=0.3 -XX:+UnlockDiagnosticVMOptions -XX:+PrintDeoptimizationDetails -XX:CompileOnly=compiler.valhalla.inlinetypes.TestDeoptInLarvalState::test1 --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED  compiler.valhalla.inlinetypes.TestDeoptInLarvalState\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:CompileThresholdScaling=0.3 -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:CompileOnly=compiler.valhalla.inlinetypes.TestDeoptInLarvalState::test2 -XX:CompileCommand=DontInline,compiler.valhalla.inlinetypes.TestDeoptInLarvalState::cleanup --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED  compiler.valhalla.inlinetypes.TestDeoptInLarvalState\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:CompileThresholdScaling=0.3 -XX:+UnlockDiagnosticVMOptions -XX:+PrintDeoptimizationDetails -XX:CompileOnly=compiler.valhalla.inlinetypes.TestDeoptInLarvalState::test2 --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED  compiler.valhalla.inlinetypes.TestDeoptInLarvalState\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+value class Pair {\n+    public double d1, d2;\n+    public Pair(double d1, double d2) {\n+        this.d1 = d1;\n+        this.d2 = d2;\n+    }\n+}\n+\n+public class TestDeoptInLarvalState {\n+    static final long OFFSET = 16;\n+\n+    public static Pair cleanup(Pair p) {\n+        return Unsafe.getUnsafe().finishPrivateBuffer(p);\n+    }\n+\n+    public static double test1(double value, int iter) {\n+        Pair p = Unsafe.getUnsafe().makePrivateBuffer(new Pair(10.0, 20.0));\n+        Unsafe.getUnsafe().putDouble(p, OFFSET, value);\n+        if (iter == 5000) {\n+           throw new RuntimeException(\"test1 : Failed to update p with value = \" + p.d1);\n+        }\n+        p = Unsafe.getUnsafe().finishPrivateBuffer(p);\n+        return p.d1 + p.d2;\n+    }\n+\n+    public static double test2(double value, int iter) {\n+        Pair p = Unsafe.getUnsafe().makePrivateBuffer(new Pair(10.0, 20.0));\n+        Unsafe.getUnsafe().putDouble(p, OFFSET, value);\n+        if (iter == 5000) {\n+           throw new RuntimeException(\"test2 : Failed to update p with value = \" + p.d1);\n+        }\n+        p = cleanup(p);\n+        return p.d1 + p.d2;\n+    }\n+\n+    public static void main(String[] args) {\n+        double res = 0.0;\n+        try {\n+            for (int i = 0; i < 10000; i++) {\n+                res += test1((double)i, i);\n+            }\n+            System.out.println(\"[res]\" + res);\n+        } catch (Exception e) {\n+            System.out.println(\"Caught Exception: \" + e);\n+        }\n+        try {\n+            for (int i = 0; i < 10000; i++) {\n+                res += test2((double)i, i);\n+            }\n+            System.out.println(\"[res]\" + res);\n+        } catch (Exception e) {\n+            System.out.println(\"Caught Exception: \" + e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptInLarvalState.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}