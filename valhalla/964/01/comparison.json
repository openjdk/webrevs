{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -1957,0 +1958,9 @@\n+      Node* receiver = !call->method()->is_static() ? call->in(TypeFunc::Parms) : nullptr;\n+      if (ret->is_InlineType() &&\n+          receiver && receiver->bottom_type()->isa_instptr() &&\n+          receiver->bottom_type()->is_instptr()->instance_klass()->name()->get_symbol() == vmSymbols::jdk_internal_misc_Unsafe() &&\n+          call->method()->name()->get_symbol() == vmSymbols::makePrivateBuffer_name()) {\n+        \/\/ Re-buffer scalarized InlineTypeNodes returned from makePrivateBuffer\n+        \/\/ and transition the allocation into larval state.\n+        ret = ret->as_InlineType()->make_larval(this);\n+      }\n@@ -3458,1 +3468,1 @@\n-        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType() || obj->bottom_type()->is_inlinetypeptr(), \"should have been scalarized\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -724,1 +724,1 @@\n-        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n@@ -922,1 +922,1 @@\n-InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {\n+Node* InlineTypeNode::make_larval(GraphKit* kit) const {\n@@ -924,4 +924,0 @@\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n@@ -929,8 +925,7 @@\n-  if (allocate) {\n-    \/\/ Re-execute if buffering triggers deoptimization\n-    PreserveReexecuteState preexecs(kit);\n-    kit->jvms()->set_should_reexecute(true);\n-    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n-    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-    alloc->_larval = true;\n+  \/\/ Re-execute if buffering triggers deoptimization\n+  PreserveReexecuteState preexecs(kit);\n+  kit->jvms()->set_should_reexecute(true);\n+  Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+  Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+  alloc->_larval = true;\n@@ -938,8 +933,2 @@\n-    store(kit, alloc_oop, alloc_oop, vk);\n-    res->set_oop(alloc_oop);\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, true));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  assert(!allocate || res->is_allocated(&kit->gvn()), \"must be allocated\");\n-  return res;\n+  store(kit, alloc_oop, alloc_oop, vk);\n+  return alloc_oop;\n@@ -948,2 +937,1 @@\n-InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {\n-  Node* obj = get_oop();\n+InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk) {\n@@ -961,9 +949,1 @@\n-  ciInlineKlass* vk = inline_klass();\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, false));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  return res;\n+  return InlineTypeNode::make_from_oop(kit, obj, vk->inline_klass(), !vk->maybe_null());\n@@ -1175,1 +1155,1 @@\n-    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":14,"deletions":34,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -150,2 +150,2 @@\n-  InlineTypeNode* make_larval(GraphKit* kit, bool allocate) const;\n-  InlineTypeNode* finish_larval(GraphKit* kit) const;\n+  Node* make_larval(GraphKit* kit) const;\n+  static InlineTypeNode* finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2334,0 +2334,11 @@\n+  if (_gvn.type(base)->is_inlinetypeptr() && is_store) {\n+    \/\/ FIXME: Larval bit check is needed to preserve the semantics of value\n+    \/\/ objects which can be mutated only if its _larval bit is set. Since\n+    \/\/ the oop is not always an AllocateNode, we have to find an utility way\n+    \/\/ to check the larval state for all kind of oops.\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+    if (alloc != nullptr) {\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+    }\n+  }\n+\n@@ -2611,6 +2622,0 @@\n-  if (argument(1)->is_InlineType() && is_store) {\n-    InlineTypeNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(argument(1))->inline_klass());\n-    value = value->make_larval(this, false);\n-    replace_in_map(argument(1), value);\n-  }\n-\n@@ -2632,1 +2637,1 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  set_result(value->as_InlineType()->make_larval(this));\n@@ -2639,10 +2644,4 @@\n-  if (!buffer->is_InlineType()) {\n-    return false;\n-  }\n-  InlineTypeNode* vt = buffer->as_InlineType();\n-  if (!vt->is_allocated(&_gvn)) {\n-    return false;\n-  }\n-  \/\/ TODO 8239003 Why is this needed?\n-  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n-    return false;\n+\n+  \/\/ Incoming value should be a buffer with inline type and not InlineTypeNode.\n+  if (buffer->is_InlineType() || !buffer->bottom_type()->is_inlinetypeptr()) {\n+     return false;\n@@ -2651,3 +2650,6 @@\n-  receiver = null_check(receiver);\n-  if (stopped()) {\n-    return true;\n+  \/\/ Allocation node must exist to generate IR for transitioning allocation out\n+  \/\/ of larval state. Disable the intrinsic and take unsafe slow path if allocation\n+  \/\/ is not reachable,  oop returned by Unsafe_finishPrivateBuffer native method\n+  \/\/ will automatically rematerialize InlineTypeNode.\n+  if (AllocateNode::Ideal_allocation(buffer) == nullptr) {\n+     return false;\n@@ -2656,1 +2658,2 @@\n-  set_result(vt->finish_larval(this));\n+  const TypeInstPtr* ptr = buffer->bottom_type()->isa_instptr();\n+  set_result(InlineTypeNode::finish_larval(this, buffer, ptr));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -962,0 +962,5 @@\n+  \/\/ Bufferes in larval state should not be scalarized.\n+  if (alloc->_larval) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1772,3 +1772,6 @@\n-          \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n-          assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n-          map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(n);\n+          if (alloc == nullptr || !alloc->_larval) {\n+            \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n+            assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n+            map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          }\n@@ -1879,1 +1882,1 @@\n-      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n+      } else if (m->is_InlineType() && n->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n@@ -1918,1 +1921,1 @@\n-      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr()) {\n+      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr() && m->is_InlineType() && n->is_InlineType()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    @IR(failOn = {CALL_UNSAFE})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8239003\n+ * @summary C2 should respect larval state when scalarizing\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/testlibrary \/test\/lib\n+ * @compile -XDenablePrimitiveClasses TestMaskedUnsafePutInLoop.java\n+ * @run main\/othervm\/timeout=300 -XX:-TieredCompilation -Xbatch -XX:+EnablePrimitiveClasses --add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                               -XX:+UnlockDiagnosticVMOptions compiler.valhalla.inlinetypes.TestMaskedUnsafePutInLoop\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestMaskedUnsafePutInLoop {\n+     primitive class Pair {\n+         double d1, d2;\n+         public Pair(double d1, double d2) {\n+             this.d1 = d1;\n+             this.d2 = d2;\n+         }\n+     }\n+\n+     static final long[] OFFSETS = new long[] { 16, 24 };\n+\n+     public static Pair helper(double[] values, boolean[] mask) {\n+         Pair p = Unsafe.getUnsafe().makePrivateBuffer(Pair.default);\n+\n+         for (int i = 0; i < OFFSETS.length; i++) {\n+             if (mask[i]) {\n+                 Unsafe.getUnsafe().putDouble(p, OFFSETS[i], values[i]);\n+             }\n+         }\n+         return Unsafe.getUnsafe().finishPrivateBuffer(p);\n+    }\n+\n+\n+    public static double test(double[] values, boolean[] mask) {\n+         Pair p = helper(values, mask);\n+         return p.d1 + p.d2;\n+    }\n+\n+    public static void main(String[] args) {\n+        double[] values = new double[] { 1.0, 2.0 };\n+        boolean[] mask = new boolean[] { true, false };\n+\n+        double d = 0.0;\n+        for (int i = 0; i < 10000; i++) {\n+            d += test(values, mask);\n+        }\n+        if (d != 10000.0) {\n+            throw new AssertionError(\"Incorrect Result expected(10000.0) != actual(\" + d + \")\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMaskedUnsafePutInLoop.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}