{"files":[{"patch":"@@ -95,4 +95,0 @@\n-# Allow overriding on the command line\n-# (intentionally sharing name with the javac option)\n-JAVA_WARNINGS_ARE_ERRORS ?= -Werror\n-\n@@ -269,1 +265,1 @@\n-\t$$(PRINTF) > $$@ '$$($1_OVERVIEW_TEXT)'\n+\t$$(ECHO) -n '$$($1_OVERVIEW_TEXT)' > $$@\n@@ -327,1 +323,3 @@\n-  $1_OPTIONS += $$(JAVA_WARNINGS_ARE_ERRORS)\n+  ifeq ($$(JAVA_WARNINGS_AS_ERRORS), true)\n+    $1_OPTIONS += -Werror\n+  endif\n","filename":"make\/Docs.gmk","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -993,0 +993,12 @@\n+################################################################################\n+#\n+# Setup how javac should handle warnings.\n+#\n+AC_DEFUN([JDKOPT_SETUP_JAVA_WARNINGS],\n+[\n+  UTIL_ARG_ENABLE(NAME: java-warnings-as-errors, DEFAULT: true,\n+      RESULT: JAVA_WARNINGS_AS_ERRORS,\n+      DESC: [consider java warnings to be an error])\n+  AC_SUBST(JAVA_WARNINGS_AS_ERRORS)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t    ( $(ECHO) -n \"DEPS_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n@@ -213,1 +213,1 @@\n-\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(ECHO) -n \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n","filename":"make\/common\/Modules.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,12 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.ConstantValueEntry;\n+import java.lang.classfile.constantpool.IntegerEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -91,57 +103,0 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Annotation;\n-import com.sun.tools.classfile.Annotation.Annotation_element_value;\n-import com.sun.tools.classfile.Annotation.Array_element_value;\n-import com.sun.tools.classfile.Annotation.Class_element_value;\n-import com.sun.tools.classfile.Annotation.Enum_element_value;\n-import com.sun.tools.classfile.Annotation.Primitive_element_value;\n-import com.sun.tools.classfile.Annotation.element_value;\n-import com.sun.tools.classfile.Annotation.element_value_pair;\n-import com.sun.tools.classfile.AnnotationDefault_attribute;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Double_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Float_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Integer_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Long_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Module_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Package_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_String_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPool.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantValue_attribute;\n-import com.sun.tools.classfile.Deprecated_attribute;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Exceptions_attribute;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.InnerClasses_attribute;\n-import com.sun.tools.classfile.InnerClasses_attribute.Info;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n-import com.sun.tools.classfile.MethodParameters_attribute;\n-import com.sun.tools.classfile.ModuleMainClass_attribute;\n-import com.sun.tools.classfile.ModuleResolution_attribute;\n-import com.sun.tools.classfile.ModuleTarget_attribute;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.Module_attribute.ExportsEntry;\n-import com.sun.tools.classfile.Module_attribute.OpensEntry;\n-import com.sun.tools.classfile.Module_attribute.ProvidesEntry;\n-import com.sun.tools.classfile.Module_attribute.RequiresEntry;\n-import com.sun.tools.classfile.NestHost_attribute;\n-import com.sun.tools.classfile.NestMembers_attribute;\n-import com.sun.tools.classfile.PermittedSubclasses_attribute;\n-import com.sun.tools.classfile.Record_attribute;\n-import com.sun.tools.classfile.Record_attribute.ComponentInfo;\n-import com.sun.tools.classfile.RuntimeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.Signature_attribute;\n@@ -157,0 +112,3 @@\n+import static java.lang.classfile.ClassFile.ACC_PROTECTED;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+\n@@ -162,2 +120,1 @@\n- *  * <jdk-N>\/bin\/java --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n- *                     --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+ *  * <jdk-N>\/bin\/java --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n@@ -417,1 +374,1 @@\n-                            throw new IllegalStateException(\"Unknown key: \" + reader.lineKey);\n+                            throw new IllegalArgumentException(\"Unknown key: \" + reader.lineKey);\n@@ -440,1 +397,1 @@\n-                        throw new IllegalStateException(\"Unknown key: \" + reader.lineKey);\n+                        throw new IllegalArgumentException(\"Unknown key: \" + reader.lineKey);\n@@ -838,24 +795,4 @@\n-        List<CPInfo> constantPool = new ArrayList<>();\n-        constantPool.add(null);\n-        int currentClass = addClass(constantPool, \"module-info\");\n-        int superclass = 0;\n-        int[] interfaces = new int[0];\n-        AccessFlags flags = new AccessFlags(header.flags);\n-        Map<String, Attribute> attributesMap = new HashMap<>();\n-        String versionString = Character.toString(version);\n-        addAttributes(moduleDescription, header, constantPool, attributesMap,\n-                      version2ModuleVersion.apply(version));\n-        Attributes attributes = new Attributes(attributesMap);\n-        CPInfo[] cpData = constantPool.toArray(new CPInfo[constantPool.size()]);\n-        ConstantPool cp = new ConstantPool(cpData);\n-        ClassFile classFile = new ClassFile(0xCAFEBABE,\n-                Target.DEFAULT.minorVersion,\n-                Target.DEFAULT.majorVersion,\n-                cp,\n-                flags,\n-                currentClass,\n-                superclass,\n-                interfaces,\n-                new Field[0],\n-                new Method[0],\n-                attributes);\n+        var classFile = ClassFile.of().build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(header.flags);\n+            addAttributes(moduleDescription, header, clb, version2ModuleVersion.apply(version));\n+        });\n@@ -863,0 +800,1 @@\n+        String versionString = Character.toString(version);\n@@ -871,51 +809,20 @@\n-        List<CPInfo> constantPool = new ArrayList<>();\n-        constantPool.add(null);\n-        List<Method> methods = new ArrayList<>();\n-        for (MethodDescription methDesc : classDescription.methods) {\n-            if (disjoint(methDesc.versions, version))\n-                continue;\n-            Descriptor descriptor = new Descriptor(addString(constantPool, methDesc.descriptor));\n-            \/\/TODO: LinkedHashMap to avoid param annotations vs. Signature problem in javac's ClassReader:\n-            Map<String, Attribute> attributesMap = new LinkedHashMap<>();\n-            addAttributes(methDesc, constantPool, attributesMap);\n-            Attributes attributes = new Attributes(attributesMap);\n-            AccessFlags flags = new AccessFlags(methDesc.flags);\n-            int nameString = addString(constantPool, methDesc.name);\n-            methods.add(new Method(flags, nameString, descriptor, attributes));\n-        }\n-        List<Field> fields = new ArrayList<>();\n-        for (FieldDescription fieldDesc : classDescription.fields) {\n-            if (disjoint(fieldDesc.versions, version))\n-                continue;\n-            Descriptor descriptor = new Descriptor(addString(constantPool, fieldDesc.descriptor));\n-            Map<String, Attribute> attributesMap = new HashMap<>();\n-            addAttributes(fieldDesc, constantPool, attributesMap);\n-            Attributes attributes = new Attributes(attributesMap);\n-            AccessFlags flags = new AccessFlags(fieldDesc.flags);\n-            int nameString = addString(constantPool, fieldDesc.name);\n-            fields.add(new Field(flags, nameString, descriptor, attributes));\n-        }\n-        int currentClass = addClass(constantPool, classDescription.name);\n-        int superclass = header.extendsAttr != null ? addClass(constantPool, header.extendsAttr) : 0;\n-        int[] interfaces = new int[header.implementsAttr.size()];\n-        int i = 0;\n-        for (String intf : header.implementsAttr) {\n-            interfaces[i++] = addClass(constantPool, intf);\n-        }\n-        AccessFlags flags = new AccessFlags(header.flags);\n-        Map<String, Attribute> attributesMap = new HashMap<>();\n-        addAttributes(header, constantPool, attributesMap);\n-        Attributes attributes = new Attributes(attributesMap);\n-        ConstantPool cp = new ConstantPool(constantPool.toArray(new CPInfo[constantPool.size()]));\n-        ClassFile classFile = new ClassFile(0xCAFEBABE,\n-                Target.DEFAULT.minorVersion,\n-                Target.DEFAULT.majorVersion,\n-                cp,\n-                flags,\n-                currentClass,\n-                superclass,\n-                interfaces,\n-                fields.toArray(new Field[0]),\n-                methods.toArray(new Method[0]),\n-                attributes);\n-\n+        var classFile = ClassFile.of().build(ClassDesc.ofInternalName(classDescription.name), clb -> {\n+            if (header.extendsAttr != null)\n+                clb.withSuperclass(ClassDesc.ofInternalName(header.extendsAttr));\n+            clb.withInterfaceSymbols(header.implementsAttr.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList()))\n+                    .withFlags(header.flags);\n+            for (FieldDescription fieldDesc : classDescription.fields) {\n+                if (disjoint(fieldDesc.versions, version))\n+                    continue;\n+                clb.withField(fieldDesc.name, ClassDesc.ofDescriptor(fieldDesc.descriptor), fb -> {\n+                    addAttributes(fieldDesc, fb);\n+                    fb.withFlags(fieldDesc.flags);\n+                });\n+            }\n+            for (MethodDescription methDesc : classDescription.methods) {\n+                if (disjoint(methDesc.versions, version))\n+                    continue;\n+                clb.withMethod(methDesc.name, MethodTypeDesc.ofDescriptor(methDesc.descriptor), methDesc.flags, mb -> addAttributes(methDesc, mb));\n+            }\n+            addAttributes(header, clb);\n+        });\n@@ -929,1 +836,1 @@\n-                         ClassFile classFile) throws IOException {\n+                         byte[] classFile) throws IOException {\n@@ -934,8 +841,2 @@\n-        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n-            ClassWriter w = new ClassWriter();\n-\n-            w.write(classFile, out);\n-\n-            openDirectory(directory2FileData, directory)\n-                .add(new FileData(fullFileName, out.toByteArray()));\n-        }\n+        openDirectory(directory2FileData, directory)\n+                .add(new FileData(fullFileName, classFile));\n@@ -963,2 +864,1 @@\n-                               List<CPInfo> cp,\n-                               Map<String, Attribute> attributes,\n+                               ClassBuilder builder,\n@@ -966,1 +866,1 @@\n-        addGenericAttributes(header, cp, attributes);\n+        addGenericAttributes(header, builder);\n@@ -968,5 +868,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleResolution);\n-            final ModuleResolution_attribute resIdx =\n-                    new ModuleResolution_attribute(attrIdx,\n-                                                   header.moduleResolution);\n-            attributes.put(Attribute.ModuleResolution, resIdx);\n+            builder.with(ModuleResolutionAttribute.of(header.moduleResolution));\n@@ -975,4 +871,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleTarget);\n-            int targetIdx = addString(cp, header.moduleTarget);\n-            attributes.put(Attribute.ModuleTarget,\n-                           new ModuleTarget_attribute(attrIdx, targetIdx));\n+            builder.with(ModuleTargetAttribute.of(header.moduleTarget));\n@@ -981,58 +874,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleMainClass);\n-            int targetIdx = addClassName(cp, header.moduleMainClass);\n-            attributes.put(Attribute.ModuleMainClass,\n-                           new ModuleMainClass_attribute(attrIdx, targetIdx));\n-        }\n-        int versionIdx = addString(cp, moduleVersion);\n-        int attrIdx = addString(cp, Attribute.Module);\n-        attributes.put(Attribute.Module,\n-                       new Module_attribute(attrIdx,\n-                             addModuleName(cp, md.name),\n-                             0,\n-                             versionIdx,\n-                             header.requires\n-                                   .stream()\n-                                   .map(r -> createRequiresEntry(cp, r))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new RequiresEntry[0]),\n-                             header.exports\n-                                   .stream()\n-                                   .map(e -> createExportsEntry(cp, e))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new ExportsEntry[0]),\n-                             header.opens\n-                                   .stream()\n-                                   .map(e -> createOpensEntry(cp, e))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new OpensEntry[0]),\n-                             header.uses\n-                                   .stream()\n-                                   .mapToInt(u -> addClassName(cp, u))\n-                                   .toArray(),\n-                             header.provides\n-                                   .stream()\n-                                   .map(p -> createProvidesEntry(cp, p))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new ProvidesEntry[0])));\n-        addInnerClassesAttribute(header, cp, attributes);\n-    }\n-\n-    private static RequiresEntry createRequiresEntry(List<CPInfo> cp,\n-            RequiresDescription r) {\n-        final int idx = addModuleName(cp, r.moduleName);\n-        return new RequiresEntry(idx,\n-                                 r.flags,\n-                                 r.version != null\n-                                         ? addString(cp, r.version)\n-                                         : 0);\n-    }\n-\n-    private static ExportsEntry createExportsEntry(List<CPInfo> cp,\n-                                                   ExportsDescription export) {\n-        int[] to;\n-        if (export.isQualified()) {\n-            to = export.to.stream()\n-                          .mapToInt(module -> addModuleName(cp, module))\n-                          .toArray();\n-        } else {\n-            to = new int[0];\n+            builder.with(ModuleMainClassAttribute.of(ClassDesc.ofInternalName(header.moduleMainClass)));\n@@ -1040,14 +876,24 @@\n-        return new ExportsEntry(addPackageName(cp, export.packageName()), 0, to);\n-    }\n-\n-    private static OpensEntry createOpensEntry(List<CPInfo> cp, String e) {\n-        return new OpensEntry(addPackageName(cp, e), 0, new int[0]);\n-    }\n-\n-    private static ProvidesEntry createProvidesEntry(List<CPInfo> cp,\n-            ModuleHeaderDescription.ProvidesDescription p) {\n-        final int idx = addClassName(cp, p.interfaceName);\n-        return new ProvidesEntry(idx, p.implNames\n-                                       .stream()\n-                                       .mapToInt(i -> addClassName(cp, i))\n-                                       .toArray());\n+        builder.with(ModuleAttribute.of(ModuleDesc.of(md.name), mb -> {\n+            mb.moduleVersion(moduleVersion);\n+            for (var req : header.requires) {\n+                mb.requires(ModuleDesc.of(req.moduleName), req.flags, req.version); \/\/ nullable version\n+            }\n+            for (var exp : header.exports) {\n+                if (exp.isQualified()) {\n+                    mb.exports(PackageDesc.ofInternalName(exp.packageName()), 0, exp.to.stream().map(ModuleDesc::of).toArray(ModuleDesc[]::new));\n+                } else {\n+                    mb.exports(PackageDesc.ofInternalName(exp.packageName()), 0);\n+                }\n+            }\n+            for (var open : header.opens) {\n+                mb.opens(PackageDesc.ofInternalName(open), 0);\n+            }\n+            for (var use : header.uses) {\n+                mb.uses(ClassDesc.ofInternalName(use));\n+            }\n+            for (var provide : header.provides) {\n+                mb.provides(ClassDesc.ofInternalName(provide.interfaceName),\n+                        provide.implNames.stream().map(ClassDesc::ofInternalName).toArray(ClassDesc[]::new));\n+            }\n+        }));\n+        addInnerClassesAttribute(header, builder);\n@@ -1056,3 +902,2 @@\n-    private void addAttributes(ClassHeaderDescription header,\n-            List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(header, constantPool, attributes);\n+    private void addAttributes(ClassHeaderDescription header, ClassBuilder builder) {\n+        addGenericAttributes(header, builder);\n@@ -1060,4 +905,1 @@\n-            int attributeString = addString(constantPool, Attribute.NestHost);\n-            int nestHost = addClass(constantPool, header.nestHost);\n-            attributes.put(Attribute.NestHost,\n-                           new NestHost_attribute(attributeString, nestHost));\n+            builder.with(NestHostAttribute.of(ClassDesc.ofInternalName(header.nestHost)));\n@@ -1066,8 +908,1 @@\n-            int attributeString = addString(constantPool, Attribute.NestMembers);\n-            int[] nestMembers = new int[header.nestMembers.size()];\n-            int i = 0;\n-            for (String intf : header.nestMembers) {\n-                nestMembers[i++] = addClass(constantPool, intf);\n-            }\n-            attributes.put(Attribute.NestMembers,\n-                           new NestMembers_attribute(attributeString, nestMembers));\n+            builder.with(NestMembersAttribute.ofSymbols(header.nestMembers.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1076,14 +911,5 @@\n-            assert header.recordComponents != null;\n-            int attributeString = addString(constantPool, Attribute.Record);\n-            ComponentInfo[] recordComponents = new ComponentInfo[header.recordComponents.size()];\n-            int i = 0;\n-            for (RecordComponentDescription rcd : header.recordComponents) {\n-                int name = addString(constantPool, rcd.name);\n-                Descriptor desc = new Descriptor(addString(constantPool, rcd.descriptor));\n-                Map<String, Attribute> nestedAttrs = new HashMap<>();\n-                addGenericAttributes(rcd, constantPool, nestedAttrs);\n-                Attributes attrs = new Attributes(nestedAttrs);\n-                recordComponents[i++] = new ComponentInfo(name, desc, attrs);\n-            }\n-            attributes.put(Attribute.Record,\n-                           new Record_attribute(attributeString, recordComponents));\n+            builder.with(RecordAttribute.of(header.recordComponents.stream().map(desc -> {\n+                List<Attribute<?>> attributes = new ArrayList<>();\n+                addGenericAttributes(desc, attributes::add, builder.constantPool());\n+                return RecordComponentInfo.of(desc.name, ClassDesc.ofDescriptor(desc.descriptor), attributes);\n+            }).collect(Collectors.toList())));\n@@ -1092,8 +918,1 @@\n-            int attributeString = addString(constantPool, Attribute.PermittedSubclasses);\n-            int[] subclasses = new int[header.permittedSubclasses.size()];\n-            int i = 0;\n-            for (String intf : header.permittedSubclasses) {\n-                subclasses[i++] = addClass(constantPool, intf);\n-            }\n-            attributes.put(Attribute.PermittedSubclasses,\n-                    new PermittedSubclasses_attribute(attributeString, subclasses));\n+            builder.with(PermittedSubclassesAttribute.ofSymbols(header.permittedSubclasses.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1101,1 +920,1 @@\n-        addInnerClassesAttribute(header, constantPool, attributes);\n+        addInnerClassesAttribute(header, builder);\n@@ -1104,2 +923,1 @@\n-    private void addInnerClassesAttribute(HeaderDescription header,\n-            List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n+    private void addInnerClassesAttribute(HeaderDescription header, ClassBuilder builder) {\n@@ -1107,12 +925,7 @@\n-            Info[] innerClasses = new Info[header.innerClasses.size()];\n-            int i = 0;\n-            for (InnerClassInfo info : header.innerClasses) {\n-                innerClasses[i++] =\n-                        new Info(info.innerClass == null ? 0 : addClass(constantPool, info.innerClass),\n-                                 info.outerClass == null ? 0 : addClass(constantPool, info.outerClass),\n-                                 info.innerClassName == null ? 0 : addString(constantPool, info.innerClassName),\n-                                 new AccessFlags(info.innerClassFlags));\n-            }\n-            int attributeString = addString(constantPool, Attribute.InnerClasses);\n-            attributes.put(Attribute.InnerClasses,\n-                           new InnerClasses_attribute(attributeString, innerClasses));\n+            builder.with(InnerClassesAttribute.of(header.innerClasses.stream()\n+                    .map(info -> java.lang.classfile.attribute.InnerClassInfo.of(\n+                            ClassDesc.ofInternalName(info.innerClass),\n+                            Optional.ofNullable(info.outerClass).map(ClassDesc::ofInternalName),\n+                            Optional.ofNullable(info.innerClassName),\n+                            info.innerClassFlags\n+                    )).collect(Collectors.toList())));\n@@ -1122,2 +935,2 @@\n-    private void addAttributes(MethodDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(desc, constantPool, attributes);\n+    private void addAttributes(MethodDescription desc, MethodBuilder builder) {\n+        addGenericAttributes(desc, builder);\n@@ -1125,8 +938,2 @@\n-            int[] exceptions = new int[desc.thrownTypes.size()];\n-            int i = 0;\n-            for (String exc : desc.thrownTypes) {\n-                exceptions[i++] = addClass(constantPool, exc);\n-            }\n-            int attributeString = addString(constantPool, Attribute.Exceptions);\n-            attributes.put(Attribute.Exceptions,\n-                           new Exceptions_attribute(attributeString, exceptions));\n+            builder.with(ExceptionsAttribute.ofSymbols(desc.thrownTypes.stream()\n+                    .map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1135,5 +942,1 @@\n-            int attributeString = addString(constantPool, Attribute.AnnotationDefault);\n-            element_value attributeValue = createAttributeValue(constantPool,\n-                                                                desc.annotationDefaultValue);\n-            attributes.put(Attribute.AnnotationDefault,\n-                           new AnnotationDefault_attribute(attributeString, attributeValue));\n+            builder.with(AnnotationDefaultAttribute.of(createAttributeValue(desc.annotationDefaultValue)));\n@@ -1142,7 +945,1 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.RuntimeInvisibleParameterAnnotations);\n-            Annotation[][] annotations =\n-                    createParameterAnnotations(constantPool, desc.classParameterAnnotations);\n-            attributes.put(Attribute.RuntimeInvisibleParameterAnnotations,\n-                           new RuntimeInvisibleParameterAnnotations_attribute(attributeString,\n-                                   annotations));\n+            builder.with(RuntimeInvisibleParameterAnnotationsAttribute.of(createParameterAnnotations(desc.classParameterAnnotations)));\n@@ -1151,7 +948,1 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.RuntimeVisibleParameterAnnotations);\n-            Annotation[][] annotations =\n-                    createParameterAnnotations(constantPool, desc.runtimeParameterAnnotations);\n-            attributes.put(Attribute.RuntimeVisibleParameterAnnotations,\n-                           new RuntimeVisibleParameterAnnotations_attribute(attributeString,\n-                                   annotations));\n+            builder.with(RuntimeVisibleParameterAnnotationsAttribute.of(createParameterAnnotations(desc.runtimeParameterAnnotations)));\n@@ -1160,11 +951,2 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.MethodParameters);\n-            MethodParameters_attribute.Entry[] entries =\n-                    desc.methodParameters\n-                        .stream()\n-                        .map(p -> new MethodParameters_attribute.Entry(p.name == null || p.name.isEmpty() ? 0\n-                                                                                                          : addString(constantPool, p.name),\n-                                                                       p.flags))\n-                        .toArray(s -> new MethodParameters_attribute.Entry[s]);\n-            attributes.put(Attribute.MethodParameters,\n-                           new MethodParameters_attribute(attributeString, entries));\n+            builder.with(MethodParametersAttribute.of(desc.methodParameters.stream()\n+                    .map(mp -> MethodParameterInfo.ofParameter(Optional.ofNullable(mp.name), mp.flags)).collect(Collectors.toList())));\n@@ -1174,2 +956,2 @@\n-    private void addAttributes(FieldDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(desc, constantPool, attributes);\n+    private void addAttributes(FieldDescription desc, FieldBuilder builder) {\n+        addGenericAttributes(desc, builder);\n@@ -1177,6 +959,12 @@\n-            Pair<Integer, Character> constantPoolEntry =\n-                    addConstant(constantPool, desc.constantValue, false);\n-            Assert.checkNonNull(constantPoolEntry);\n-            int constantValueString = addString(constantPool, Attribute.ConstantValue);\n-            attributes.put(Attribute.ConstantValue,\n-                           new ConstantValue_attribute(constantValueString, constantPoolEntry.fst));\n+            var cp = builder.constantPool();\n+            ConstantValueEntry entry = switch (desc.constantValue) {\n+                case Boolean v -> cp.intEntry(v ? 1 : 0);\n+                case Character v -> cp.intEntry(v);\n+                case Integer v -> cp.intEntry(v);\n+                case Long v -> cp.longEntry(v);\n+                case Float v -> cp.floatEntry(v);\n+                case Double v -> cp.doubleEntry(v);\n+                case String v -> cp.stringEntry(v);\n+                default -> throw new IllegalArgumentException(desc.constantValue.getClass().toString());\n+            };\n+            builder.with(ConstantValueAttribute.of(entry));\n@@ -1186,1 +974,8 @@\n-    private void addGenericAttributes(FeatureDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n+    @SuppressWarnings(\"unchecked\")\n+    private void addGenericAttributes(FeatureDescription desc, ClassFileBuilder<?, ?> builder) {\n+        addGenericAttributes(desc, (Consumer<? super Attribute<?>>) builder, builder.constantPool());\n+    }\n+\n+    private void addGenericAttributes(FeatureDescription desc, Consumer<? super Attribute<?>> sink, ConstantPoolBuilder cpb) {\n+        @SuppressWarnings(\"unchecked\")\n+        var builder = (Consumer<Attribute<?>>) sink;\n@@ -1188,3 +983,1 @@\n-            int attributeString = addString(constantPool, Attribute.Deprecated);\n-            attributes.put(Attribute.Deprecated,\n-                           new Deprecated_attribute(attributeString));\n+            builder.accept(DeprecatedAttribute.of());\n@@ -1193,4 +986,1 @@\n-            int attributeString = addString(constantPool, Attribute.Signature);\n-            int signatureString = addString(constantPool, desc.signature);\n-            attributes.put(Attribute.Signature,\n-                           new Signature_attribute(attributeString, signatureString));\n+            builder.accept(SignatureAttribute.of(cpb.utf8Entry(desc.signature)));\n@@ -1199,4 +989,1 @@\n-            int attributeString = addString(constantPool, Attribute.RuntimeInvisibleAnnotations);\n-            Annotation[] annotations = createAnnotations(constantPool, desc.classAnnotations);\n-            attributes.put(Attribute.RuntimeInvisibleAnnotations,\n-                           new RuntimeInvisibleAnnotations_attribute(attributeString, annotations));\n+            builder.accept(RuntimeInvisibleAnnotationsAttribute.of(createAnnotations(desc.classAnnotations)));\n@@ -1205,4 +992,1 @@\n-            int attributeString = addString(constantPool, Attribute.RuntimeVisibleAnnotations);\n-            Annotation[] annotations = createAnnotations(constantPool, desc.runtimeAnnotations);\n-            attributes.put(Attribute.RuntimeVisibleAnnotations,\n-                           new RuntimeVisibleAnnotations_attribute(attributeString, annotations));\n+            builder.accept(RuntimeVisibleAnnotationsAttribute.of(createAnnotations(desc.runtimeAnnotations)));\n@@ -1212,9 +996,2 @@\n-    private Annotation[] createAnnotations(List<CPInfo> constantPool, List<AnnotationDescription> desc) {\n-        Annotation[] result = new Annotation[desc.size()];\n-        int i = 0;\n-\n-        for (AnnotationDescription ad : desc) {\n-            result[i++] = createAnnotation(constantPool, ad);\n-        }\n-\n-        return result;\n+    private List<Annotation> createAnnotations(List<AnnotationDescription> desc) {\n+        return desc.stream().map(this::createAnnotation).collect(Collectors.toList());\n@@ -1223,9 +1000,2 @@\n-    private Annotation[][] createParameterAnnotations(List<CPInfo> constantPool, List<List<AnnotationDescription>> desc) {\n-        Annotation[][] result = new Annotation[desc.size()][];\n-        int i = 0;\n-\n-        for (List<AnnotationDescription> paramAnnos : desc) {\n-            result[i++] = createAnnotations(constantPool, paramAnnos);\n-        }\n-\n-        return result;\n+    private List<List<Annotation>> createParameterAnnotations(List<List<AnnotationDescription>> desc) {\n+        return desc.stream().map(this::createAnnotations).collect(Collectors.toList());\n@@ -1234,1 +1004,1 @@\n-    private Annotation createAnnotation(List<CPInfo> constantPool, AnnotationDescription desc) {\n+    private Annotation createAnnotation(AnnotationDescription desc) {\n@@ -1271,178 +1041,27 @@\n-        return new Annotation(null,\n-                              addString(constantPool, annotationType),\n-                              createElementPairs(constantPool, values));\n-    }\n-\n-    private element_value_pair[] createElementPairs(List<CPInfo> constantPool, Map<String, Object> annotationAttributes) {\n-        element_value_pair[] pairs = new element_value_pair[annotationAttributes.size()];\n-        int i = 0;\n-\n-        for (Entry<String, Object> e : annotationAttributes.entrySet()) {\n-            int elementNameString = addString(constantPool, e.getKey());\n-            element_value value = createAttributeValue(constantPool, e.getValue());\n-            pairs[i++] = new element_value_pair(elementNameString, value);\n-        }\n-\n-        return pairs;\n-    }\n-\n-    private element_value createAttributeValue(List<CPInfo> constantPool, Object value) {\n-        Pair<Integer, Character> constantPoolEntry = addConstant(constantPool, value, true);\n-        if (constantPoolEntry != null) {\n-            return new Primitive_element_value(constantPoolEntry.fst, constantPoolEntry.snd);\n-        } else if (value instanceof EnumConstant) {\n-            EnumConstant ec = (EnumConstant) value;\n-            return new Enum_element_value(addString(constantPool, ec.type),\n-                                          addString(constantPool, ec.constant),\n-                                          'e');\n-        } else if (value instanceof ClassConstant) {\n-            ClassConstant cc = (ClassConstant) value;\n-            return new Class_element_value(addString(constantPool, cc.type), 'c');\n-        } else if (value instanceof AnnotationDescription) {\n-            Annotation annotation = createAnnotation(constantPool, ((AnnotationDescription) value));\n-            return new Annotation_element_value(annotation, '@');\n-        } else if (value instanceof Collection) {\n-            @SuppressWarnings(\"unchecked\")\n-                    Collection<Object> array = (Collection<Object>) value;\n-            element_value[] values = new element_value[array.size()];\n-            int i = 0;\n-\n-            for (Object elem : array) {\n-                values[i++] = createAttributeValue(constantPool, elem);\n-            }\n-\n-            return new Array_element_value(values, '[');\n-        }\n-        throw new IllegalStateException(value.getClass().getName());\n-    }\n-\n-    private static Pair<Integer, Character> addConstant(List<CPInfo> constantPool, Object value, boolean annotation) {\n-        if (value instanceof Boolean) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info(((Boolean) value) ? 1 : 0)), 'Z');\n-        } else if (value instanceof Byte) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((byte) value)), 'B');\n-        } else if (value instanceof Character) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((char) value)), 'C');\n-        } else if (value instanceof Short) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((short) value)), 'S');\n-        } else if (value instanceof Integer) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((int) value)), 'I');\n-        } else if (value instanceof Long) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Long_info((long) value)), 'J');\n-        } else if (value instanceof Float) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Float_info((float) value)), 'F');\n-        } else if (value instanceof Double) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Double_info((double) value)), 'D');\n-        } else if (value instanceof String) {\n-            int stringIndex = addString(constantPool, (String) value);\n-            if (annotation) {\n-                return Pair.of(stringIndex, 's');\n-            } else {\n-                return Pair.of(addToCP(constantPool, new CONSTANT_String_info(null, stringIndex)), 's');\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    private static int addString(List<CPInfo> constantPool, String string) {\n-        Assert.checkNonNull(string);\n-\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Utf8_info) {\n-                if (((CONSTANT_Utf8_info) info).value.equals(string)) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Utf8_info(string));\n-    }\n-\n-    private static int addInt(List<CPInfo> constantPool, int value) {\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Integer_info) {\n-                if (((CONSTANT_Integer_info) info).value == value) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Integer_info(value));\n-    }\n-\n-    private static int addModuleName(List<CPInfo> constantPool, String moduleName) {\n-        int nameIdx = addString(constantPool, moduleName);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Module_info) {\n-                if (((CONSTANT_Module_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Module_info(null, nameIdx));\n-    }\n-\n-    private static int addPackageName(List<CPInfo> constantPool, String packageName) {\n-        int nameIdx = addString(constantPool, packageName);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Package_info) {\n-                if (((CONSTANT_Package_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Package_info(null, nameIdx));\n-    }\n-\n-    private static int addClassName(List<CPInfo> constantPool, String className) {\n-        int nameIdx = addString(constantPool, className);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Class_info) {\n-                if (((CONSTANT_Class_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Class_info(null, nameIdx));\n-    }\n-\n-    private static int addToCP(List<CPInfo> constantPool, CPInfo entry) {\n-        int result = constantPool.size();\n-\n-        constantPool.add(entry);\n-\n-        if (entry.size() > 1) {\n-            constantPool.add(null);\n-        }\n-\n-        return result;\n-    }\n-\n-    private static int addClass(List<CPInfo> constantPool, String className) {\n-        int classNameIndex = addString(constantPool, className);\n-\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Class_info) {\n-                if (((CONSTANT_Class_info) info).name_index == classNameIndex) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Class_info(null, classNameIndex));\n+        return Annotation.of(ClassDesc.ofDescriptor(annotationType),\n+                createElementPairs(values));\n+    }\n+\n+    private List<AnnotationElement> createElementPairs(Map<String, Object> annotationAttributes) {\n+        return annotationAttributes.entrySet().stream()\n+                .map(e -> AnnotationElement.of(e.getKey(), createAttributeValue(e.getValue())))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private AnnotationValue createAttributeValue(Object value) {\n+        return switch (value) {\n+            case Boolean v -> AnnotationValue.ofBoolean(v);\n+            case Byte v -> AnnotationValue.ofByte(v);\n+            case Character v -> AnnotationValue.ofChar(v);\n+            case Short v -> AnnotationValue.ofShort(v);\n+            case Integer v -> AnnotationValue.ofInt(v);\n+            case Long v -> AnnotationValue.ofLong(v);\n+            case Float v -> AnnotationValue.ofFloat(v);\n+            case Double v -> AnnotationValue.ofDouble(v);\n+            case String v -> AnnotationValue.ofString(v);\n+            case EnumConstant v -> AnnotationValue.ofEnum(ClassDesc.ofDescriptor(v.type), v.constant);\n+            case ClassConstant v -> AnnotationValue.ofClass(ClassDesc.ofDescriptor(v.type));\n+            case AnnotationDescription v -> AnnotationValue.ofAnnotation(createAnnotation(v));\n+            case Collection<?> v -> AnnotationValue.ofArray(v.stream().map(this::createAttributeValue).collect(Collectors.toList()));\n+            default -> throw new IllegalArgumentException(value.getClass().getName());\n+        };\n@@ -1523,1 +1142,1 @@\n-                throw new IllegalStateException(ex);\n+                throw new IllegalArgumentException(ex);\n@@ -1539,6 +1158,2 @@\n-            try (InputStream in = new ByteArrayInputStream(classFileData)) {\n-                inspectModuleInfoClassFile(in,\n-                                           currentVersionModules, version);\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            inspectModuleInfoClassFile(classFileData,\n+                    currentVersionModules, version);\n@@ -1575,2 +1190,2 @@\n-                                 cf -> {\n-                                     PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+                                 cm -> {\n+                                     var permitted = cm.findAttribute(Attributes.permittedSubclasses()).orElse(null);\n@@ -1578,2 +1193,2 @@\n-                                         try {\n-                                             String currentPack = cf.getName().substring(0, cf.getName().lastIndexOf('\/'));\n+                                         var name = cm.thisClass().asInternalName();\n+                                         String currentPack = name.substring(0, name.lastIndexOf('\/'));\n@@ -1581,4 +1196,4 @@\n-                                             for (int i = 0; i < permitted.subtypes.length; i++) {\n-                                                 String permittedClassName = cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName();\n-                                                 if (!currentEIList.accepts(permittedClassName, false)) {\n-                                                     String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n+                                         for (var sub : permitted.permittedSubclasses()) {\n+                                             String permittedClassName = sub.asInternalName();\n+                                             if (!currentEIList.accepts(permittedClassName, false)) {\n+                                                 String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n@@ -1586,3 +1201,2 @@\n-                                                     extraModulesPackagesToDerive.computeIfAbsent(permittedPack, x -> new HashSet<>())\n-                                                                                 .add(currentPack);\n-                                                 }\n+                                                 extraModulesPackagesToDerive.computeIfAbsent(permittedPack, x -> new HashSet<>())\n+                                                                             .add(currentPack);\n@@ -1590,2 +1204,0 @@\n-                                         } catch (ConstantPoolException ex) {\n-                                             throw new IllegalStateException(ex);\n@@ -1595,2 +1207,2 @@\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n+            } catch (IOException ex) {\n+                throw new IllegalArgumentException(ex);\n@@ -1662,4 +1274,1 @@\n-                        ModuleDescription md;\n-\n-                        try (InputStream in = Files.newInputStream(moduleInfo)) {\n-                            md = inspectModuleInfoClassFile(in,\n+                        ModuleDescription md = inspectModuleInfoClassFile(Files.readAllBytes(moduleInfo),\n@@ -1667,1 +1276,0 @@\n-                        }\n@@ -1729,2 +1337,2 @@\n-        } catch (IOException | ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n+        } catch (IOException ex) {\n+            throw new IllegalArgumentException(ex);\n@@ -1738,1 +1346,1 @@\n-                                                  List<String> todo) throws IOException, ConstantPoolException {\n+                                                  List<String> todo) throws IOException {\n@@ -2258,1 +1866,1 @@\n-    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version) throws IOException, ConstantPoolException {\n+    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version) throws IOException {\n@@ -2263,2 +1871,2 @@\n-                                  Consumer<ClassFile> extraTask) throws IOException, ConstantPoolException {\n-        ClassFile cf = ClassFile.read(in);\n+                                  Consumer<ClassModel> extraTask) throws IOException {\n+        ClassModel cm = ClassFile.of().parse(in.readAllBytes());\n@@ -2266,1 +1874,1 @@\n-        if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+        if (cm.isModuleInfo()) {\n@@ -2270,1 +1878,1 @@\n-        if (!excludesIncludes.accepts(cf.getName(), true)) {\n+        if (!excludesIncludes.accepts(cm.thisClass().asInternalName(), true)) {\n@@ -2274,1 +1882,1 @@\n-        extraTask.accept(cf);\n+        extraTask.accept(cm);\n@@ -2278,1 +1886,1 @@\n-        headerDesc.flags = cf.access_flags.flags;\n+        headerDesc.flags = cm.flags().flagsMask();\n@@ -2280,6 +1888,2 @@\n-        if (cf.super_class != 0) {\n-            headerDesc.extendsAttr = cf.getSuperclassName();\n-        }\n-        List<String> interfaces = new ArrayList<>();\n-        for (int i = 0; i < cf.interfaces.length; i++) {\n-            interfaces.add(cf.getInterfaceName(i));\n+        if (cm.superclass().isPresent()) {\n+            headerDesc.extendsAttr = cm.superclass().get().asInternalName();\n@@ -2287,3 +1891,3 @@\n-        headerDesc.implementsAttr = interfaces;\n-        for (Attribute attr : cf.attributes) {\n-            if (!readAttribute(cf, headerDesc, attr))\n+        headerDesc.implementsAttr = cm.interfaces().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+        for (var attr : cm.attributes()) {\n+            if (!readAttribute(headerDesc, attr))\n@@ -2296,1 +1900,1 @@\n-            if (cd.name.equals(cf.getName())) {\n+            if (cd.name.equals(cm.thisClass().asInternalName())) {\n@@ -2304,1 +1908,1 @@\n-            clazzDesc.name = cf.getName();\n+            clazzDesc.name = cm.thisClass().asInternalName();\n@@ -2310,2 +1914,2 @@\n-        for (Method m : cf.methods) {\n-            if (!include(m.access_flags.flags))\n+        for (var m : cm.methods()) {\n+            if (!include(m.flags().flagsMask()))\n@@ -2314,5 +1918,5 @@\n-            methDesc.flags = m.access_flags.flags;\n-            methDesc.name = m.getName(cf.constant_pool);\n-            methDesc.descriptor = m.descriptor.getValue(cf.constant_pool);\n-            for (Attribute attr : m.attributes) {\n-                readAttribute(cf, methDesc, attr);\n+            methDesc.flags = m.flags().flagsMask();\n+            methDesc.name = m.methodName().stringValue();\n+            methDesc.descriptor = m.methodType().stringValue();\n+            for (var attr : m.attributes()) {\n+                readAttribute(methDesc, attr);\n@@ -2322,2 +1926,2 @@\n-        for (Field f : cf.fields) {\n-            if (!include(f.access_flags.flags))\n+        for (var f : cm.fields()) {\n+            if (!include(f.flags().flagsMask()))\n@@ -2326,5 +1930,5 @@\n-            fieldDesc.flags = f.access_flags.flags;\n-            fieldDesc.name = f.getName(cf.constant_pool);\n-            fieldDesc.descriptor = f.descriptor.getValue(cf.constant_pool);\n-            for (Attribute attr : f.attributes) {\n-                readAttribute(cf, fieldDesc, attr);\n+            fieldDesc.flags = f.flags().flagsMask();\n+            fieldDesc.name = f.fieldName().stringValue();\n+            fieldDesc.descriptor = f.fieldType().stringValue();\n+            for (var attr : f.attributes()) {\n+                readAttribute(fieldDesc, attr);\n@@ -2336,1 +1940,1 @@\n-    private ModuleDescription inspectModuleInfoClassFile(InputStream in,\n+    private ModuleDescription inspectModuleInfoClassFile(byte[] data,\n@@ -2338,2 +1942,2 @@\n-            String version) throws IOException, ConstantPoolException {\n-        ClassFile cf = ClassFile.read(in);\n+            String version) {\n+        ClassModel cm = ClassFile.of().parse(data);\n@@ -2341,1 +1945,1 @@\n-        if (!cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+        if (!cm.flags().has(AccessFlag.MODULE)) {\n@@ -2348,1 +1952,1 @@\n-        headerDesc.flags = cf.access_flags.flags;\n+        headerDesc.flags = cm.flags().flagsMask();\n@@ -2350,2 +1954,2 @@\n-        for (Attribute attr : cf.attributes) {\n-            if (!readAttribute(cf, headerDesc, attr))\n+        for (var attr : cm.attributes()) {\n+            if (!readAttribute(headerDesc, attr))\n@@ -2375,7 +1979,1 @@\n-            try (InputStream in = new ByteArrayInputStream(classFileData)) {\n-                ClassFile cf = ClassFile.read(in);\n-\n-                additionalIncludes.addAll(otherRelevantTypesWithOwners(cf));\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            additionalIncludes.addAll(otherRelevantTypesWithOwners(ClassFile.of().parse(classFileData)));\n@@ -2387,1 +1985,1 @@\n-    private Set<String> otherRelevantTypesWithOwners(ClassFile cf) {\n+    private Set<String> otherRelevantTypesWithOwners(ClassModel cm) {\n@@ -2390,4 +1988,3 @@\n-        try {\n-            if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n-                return supertypes;\n-            }\n+        if (cm.flags().has(AccessFlag.MODULE)) {\n+            return supertypes;\n+        }\n@@ -2395,1 +1992,1 @@\n-            Set<String> additionalClasses = new HashSet<>();\n+        Set<String> additionalClasses = new HashSet<>();\n@@ -2397,11 +1994,10 @@\n-            if (cf.super_class != 0) {\n-                additionalClasses.add(cf.getSuperclassName());\n-            }\n-            for (int i = 0; i < cf.interfaces.length; i++) {\n-                additionalClasses.add(cf.getInterfaceName(i));\n-            }\n-            PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n-            if (permitted != null) {\n-                for (int i = 0; i < permitted.subtypes.length; i++) {\n-                    additionalClasses.add(cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName());\n-                }\n+        if (cm.superclass().isPresent()) {\n+            additionalClasses.add(cm.superclass().get().asInternalName());\n+        }\n+        for (var iface : cm.interfaces()) {\n+            additionalClasses.add(iface.asInternalName());\n+        }\n+        var permitted = cm.findAttribute(Attributes.permittedSubclasses()).orElse(null);\n+        if (permitted != null) {\n+            for (var sub : permitted.permittedSubclasses()) {\n+                additionalClasses.add(sub.asInternalName());\n@@ -2409,0 +2005,1 @@\n+        }\n@@ -2410,2 +2007,2 @@\n-            for (String additional : additionalClasses) {\n-                int dollar;\n+        for (String additional : additionalClasses) {\n+            int dollar;\n@@ -2413,1 +2010,1 @@\n-                supertypes.add(additional);\n+            supertypes.add(additional);\n@@ -2415,4 +2012,3 @@\n-                while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n-                    additional = additional.substring(0, dollar);\n-                    supertypes.add(additional);\n-                }\n+            while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n+                additional = additional.substring(0, dollar);\n+                supertypes.add(additional);\n@@ -2420,4 +2016,2 @@\n-\n-            return supertypes;\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n+\n+        return supertypes;\n@@ -2449,1 +2043,1 @@\n-        return (accessFlags & (AccessFlags.ACC_PUBLIC | AccessFlags.ACC_PROTECTED)) != 0;\n+        return (accessFlags & (ACC_PUBLIC | ACC_PROTECTED)) != 0;\n@@ -2545,22 +2139,7 @@\n-    private boolean readAttribute(ClassFile cf, FeatureDescription feature, Attribute attr) throws ConstantPoolException {\n-        String attrName = attr.getName(cf.constant_pool);\n-        switch (attrName) {\n-            case Attribute.AnnotationDefault:\n-                assert feature instanceof MethodDescription;\n-                element_value defaultValue = ((AnnotationDefault_attribute) attr).default_value;\n-                ((MethodDescription) feature).annotationDefaultValue =\n-                        convertElementValue(cf.constant_pool, defaultValue);\n-                break;\n-            case \"Deprecated\":\n-                feature.deprecated = true;\n-                break;\n-            case \"Exceptions\":\n-                assert feature instanceof MethodDescription;\n-                List<String> thrownTypes = new ArrayList<>();\n-                Exceptions_attribute exceptionAttr = (Exceptions_attribute) attr;\n-                for (int i = 0; i < exceptionAttr.exception_index_table.length; i++) {\n-                    thrownTypes.add(exceptionAttr.getException(i, cf.constant_pool));\n-                }\n-                ((MethodDescription) feature).thrownTypes = thrownTypes;\n-                break;\n-            case Attribute.InnerClasses:\n+    private boolean readAttribute(FeatureDescription feature, Attribute<?> attr) {\n+        switch (attr) {\n+            case AnnotationDefaultAttribute a ->\n+                    ((MethodDescription) feature).annotationDefaultValue = convertElementValue(a.defaultValue());\n+            case DeprecatedAttribute _ -> feature.deprecated = true;\n+            case ExceptionsAttribute a -> ((MethodDescription) feature).thrownTypes = a.exceptions().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+            case InnerClassesAttribute a -> {\n@@ -2569,72 +2148,26 @@\n-                assert feature instanceof ClassHeaderDescription;\n-                List<InnerClassInfo> innerClasses = new ArrayList<>();\n-                InnerClasses_attribute innerClassesAttr = (InnerClasses_attribute) attr;\n-                for (int i = 0; i < innerClassesAttr.number_of_classes; i++) {\n-                    CONSTANT_Class_info outerClassInfo =\n-                            innerClassesAttr.classes[i].getOuterClassInfo(cf.constant_pool);\n-                    InnerClassInfo info = new InnerClassInfo();\n-                    CONSTANT_Class_info innerClassInfo =\n-                            innerClassesAttr.classes[i].getInnerClassInfo(cf.constant_pool);\n-                    info.innerClass = innerClassInfo != null ? innerClassInfo.getName() : null;\n-                    info.outerClass = outerClassInfo != null ? outerClassInfo.getName() : null;\n-                    info.innerClassName = innerClassesAttr.classes[i].getInnerName(cf.constant_pool);\n-                    info.innerClassFlags = innerClassesAttr.classes[i].inner_class_access_flags.flags;\n-                    innerClasses.add(info);\n-                }\n-                ((ClassHeaderDescription) feature).innerClasses = innerClasses;\n-                break;\n-            case \"RuntimeInvisibleAnnotations\":\n-                feature.classAnnotations = annotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"RuntimeVisibleAnnotations\":\n-                feature.runtimeAnnotations = annotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"Signature\":\n-                feature.signature = ((Signature_attribute) attr).getSignature(cf.constant_pool);\n-                break;\n-            case \"ConstantValue\":\n-                assert feature instanceof FieldDescription;\n-                Object value = convertConstantValue(cf.constant_pool.get(((ConstantValue_attribute) attr).constantvalue_index), ((FieldDescription) feature).descriptor);\n-                if (((FieldDescription) feature).descriptor.equals(\"C\")) {\n-                    value = (char) (int) value;\n-                }\n-                ((FieldDescription) feature).constantValue = value;\n-                break;\n-            case \"Preload\":\n-            case \"SourceFile\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"BootstrapMethods\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"Code\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"EnclosingMethod\":\n-                return false;\n-            case \"Synthetic\":\n-                break;\n-            case \"RuntimeVisibleParameterAnnotations\":\n-                assert feature instanceof MethodDescription;\n-                ((MethodDescription) feature).runtimeParameterAnnotations =\n-                        parameterAnnotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"RuntimeInvisibleParameterAnnotations\":\n-                assert feature instanceof MethodDescription;\n-                ((MethodDescription) feature).classParameterAnnotations =\n-                        parameterAnnotations2Description(cf.constant_pool, attr);\n-                break;\n-            case Attribute.Module: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                Module_attribute mod = (Module_attribute) attr;\n-\n-                header.name = cf.constant_pool\n-                                .getModuleInfo(mod.module_name)\n-                                .getName();\n-\n-                header.exports =\n-                        Arrays.stream(mod.exports)\n-                              .map(ee -> ExportsDescription.create(cf, ee))\n-                              .collect(Collectors.toList());\n+                ((ClassHeaderDescription) feature).innerClasses = a.classes().stream().map(cfi -> {\n+                    var info = new InnerClassInfo();\n+                    info.innerClass = cfi.innerClass().asInternalName();\n+                    info.outerClass = cfi.outerClass().map(ClassEntry::asInternalName).orElse(null);\n+                    info.innerClassName = cfi.innerName().map(Utf8Entry::stringValue).orElse(null);\n+                    info.innerClassFlags = cfi.flagsMask();\n+                    return info;\n+                }).collect(Collectors.toList());\n+            }\n+            case RuntimeInvisibleAnnotationsAttribute a -> feature.classAnnotations = annotations2Description(a.annotations());\n+            case RuntimeVisibleAnnotationsAttribute a -> feature.runtimeAnnotations = annotations2Description(a.annotations());\n+            case SignatureAttribute a -> feature.signature = a.signature().stringValue();\n+            case ConstantValueAttribute a -> {\n+                var f = (FieldDescription) feature;\n+                f.constantValue = convertConstantValue(a.constant(), f.descriptor);\n+            }\n+            case SourceFileAttribute _, BootstrapMethodsAttribute _, CodeAttribute _, SyntheticAttribute _ -> {}\n+            case EnclosingMethodAttribute _ -> {\n+                return false;\n+            }\n+            case RuntimeVisibleParameterAnnotationsAttribute a -> ((MethodDescription) feature).runtimeParameterAnnotations = parameterAnnotations2Description(a.parameterAnnotations());\n+            case RuntimeInvisibleParameterAnnotationsAttribute a -> ((MethodDescription) feature).classParameterAnnotations = parameterAnnotations2Description(a.parameterAnnotations());\n+            case ModuleAttribute a -> {\n+                ModuleHeaderDescription header = (ModuleHeaderDescription) feature;\n+                header.name = a.moduleName().name().stringValue();\n+                header.exports = a.exports().stream().map(ExportsDescription::create).collect(Collectors.toList());\n@@ -2644,24 +2177,3 @@\n-                header.requires =\n-                        Arrays.stream(mod.requires)\n-                              .map(r -> RequiresDescription.create(cf, r))\n-                              .collect(Collectors.toList());\n-                header.uses = Arrays.stream(mod.uses_index)\n-                                    .mapToObj(use -> getClassName(cf, use))\n-                                    .collect(Collectors.toList());\n-                header.provides =\n-                        Arrays.stream(mod.provides)\n-                              .map(p -> ProvidesDescription.create(cf, p))\n-                              .collect(Collectors.toList());\n-                break;\n-            }\n-            case Attribute.ModuleTarget: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModuleTarget_attribute mod = (ModuleTarget_attribute) attr;\n-                if (mod.target_platform_index != 0) {\n-                    header.moduleTarget =\n-                            cf.constant_pool\n-                              .getUTF8Value(mod.target_platform_index);\n-                }\n-                break;\n+                header.requires = a.requires().stream().map(RequiresDescription::create).collect(Collectors.toList());\n+                header.uses = a.uses().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+                header.provides = a.provides().stream().map(ProvidesDescription::create).collect(Collectors.toList());\n@@ -2669,18 +2181,6 @@\n-            case Attribute.ModuleResolution: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModuleResolution_attribute mod =\n-                        (ModuleResolution_attribute) attr;\n-                header.moduleResolution = mod.resolution_flags;\n-                break;\n-            }\n-            case Attribute.ModulePackages:\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModulePackages_attribute mod =\n-                        (ModulePackages_attribute) attr;\n-                header.extraModulePackages = new ArrayList<>();\n-                for (int i = 0; i < mod.packages_count; i++) {\n-                    String packageName = getPackageName(cf, mod.packages_index[i]);\n+            case ModuleTargetAttribute a -> ((ModuleHeaderDescription) feature).moduleTarget = a.targetPlatform().stringValue();\n+            case ModuleResolutionAttribute a -> ((ModuleHeaderDescription) feature).moduleResolution = a.resolutionFlags();\n+            case ModulePackagesAttribute a -> {\n+                var header = (ModuleHeaderDescription) feature;\n+                header.extraModulePackages = a.packages().stream().<String>mapMulti((packageItem, sink) -> {\n+                    var packageName = packageItem.name().stringValue();\n@@ -2688,2 +2188,2 @@\n-                        header.exports.stream().noneMatch(ed -> ed.packageName().equals(packageName))) {\n-                        header.extraModulePackages.add(packageName);\n+                            header.exports.stream().noneMatch(ed -> ed.packageName().equals(packageName))) {\n+                        sink.accept(packageName);\n@@ -2691,19 +2191,1 @@\n-                }\n-                break;\n-            case Attribute.ModuleHashes:\n-                break;\n-            case Attribute.NestHost: {\n-                assert feature instanceof ClassHeaderDescription;\n-                NestHost_attribute nestHost = (NestHost_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.nestHost = nestHost.getNestTop(cf.constant_pool).getName();\n-                break;\n-            }\n-            case Attribute.NestMembers: {\n-                assert feature instanceof ClassHeaderDescription;\n-                NestMembers_attribute nestMembers = (NestMembers_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.nestMembers = Arrays.stream(nestMembers.members_indexes)\n-                                        .mapToObj(i -> getClassName(cf, i))\n-                                        .collect(Collectors.toList());\n-                break;\n+                }).collect(Collectors.toList());\n@@ -2711,14 +2193,5 @@\n-            case Attribute.Record: {\n-                assert feature instanceof ClassHeaderDescription;\n-                Record_attribute record = (Record_attribute) attr;\n-                List<RecordComponentDescription> components = new ArrayList<>();\n-                for (ComponentInfo info : record.component_info_arr) {\n-                    RecordComponentDescription rcd = new RecordComponentDescription();\n-                    rcd.name = info.getName(cf.constant_pool);\n-                    rcd.descriptor = info.descriptor.getValue(cf.constant_pool);\n-                    for (Attribute nestedAttr : info.attributes) {\n-                        readAttribute(cf, rcd, nestedAttr);\n-                    }\n-                    components.add(rcd);\n-                }\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n+            case ModuleHashesAttribute _ -> {}\n+            case NestHostAttribute a -> ((ClassHeaderDescription) feature).nestHost = a.nestHost().asInternalName();\n+            case NestMembersAttribute a -> ((ClassHeaderDescription) feature).nestMembers = a.nestMembers().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+            case RecordAttribute a -> {\n+                var chd = (ClassHeaderDescription) feature;\n@@ -2726,24 +2199,13 @@\n-                chd.recordComponents = components;\n-                break;\n-            }\n-            case Attribute.MethodParameters: {\n-                assert feature instanceof MethodDescription;\n-                MethodParameters_attribute params = (MethodParameters_attribute) attr;\n-                MethodDescription method = (MethodDescription) feature;\n-                method.methodParameters = new ArrayList<>();\n-                for (MethodParameters_attribute.Entry e : params.method_parameter_table) {\n-                    String name = e.name_index == 0 ? null\n-                            : cf.constant_pool.getUTF8Value(e.name_index);\n-                    MethodDescription.MethodParam param =\n-                            new MethodDescription.MethodParam(e.flags, name);\n-                    method.methodParameters.add(param);\n-                }\n-                break;\n-            }\n-            case Attribute.PermittedSubclasses: {\n-                assert feature instanceof ClassHeaderDescription;\n-                PermittedSubclasses_attribute permittedSubclasses = (PermittedSubclasses_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.permittedSubclasses = Arrays.stream(permittedSubclasses.subtypes)\n-                        .mapToObj(i -> getClassName(cf, i))\n-                        .collect(Collectors.toList());\n+                chd.recordComponents = a.components().stream().map(rci -> {\n+                    var rcd = new RecordComponentDescription();\n+                    rcd.name = rci.name().stringValue();\n+                    rcd.descriptor = rci.descriptor().stringValue();\n+                    rci.attributes().forEach(child -> readAttribute(rcd, child));\n+                    return rcd;\n+                }).collect(Collectors.toList());\n+            }\n+            case MethodParametersAttribute a -> ((MethodDescription) feature).methodParameters = a.parameters().stream()\n+                    .map(mpi -> new MethodDescription.MethodParam(mpi.flagsMask(), mpi.name().map(Utf8Entry::stringValue).orElse(null)))\n+                    .collect(Collectors.toList());\n+            case PermittedSubclassesAttribute a -> {\n+                var chd = (ClassHeaderDescription) feature;\n@@ -2751,1 +2213,1 @@\n-                break;\n+                chd.permittedSubclasses = a.permittedSubclasses().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n@@ -2753,10 +2215,2 @@\n-            case Attribute.ModuleMainClass: {\n-                ModuleMainClass_attribute moduleMainClass = (ModuleMainClass_attribute) attr;\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription mhd = (ModuleHeaderDescription) feature;\n-                mhd.moduleMainClass = moduleMainClass.getMainClassName(cf.constant_pool);\n-                break;\n-            }\n-            default:\n-                throw new IllegalStateException(\"Unhandled attribute: \" +\n-                                                attrName);\n+            case ModuleMainClassAttribute a -> ((ModuleHeaderDescription) feature).moduleMainClass = a.mainClass().asInternalName();\n+            default -> throw new IllegalArgumentException(\"Unhandled attribute: \" + attr.attributeName()); \/\/ Do nothing\n@@ -2768,36 +2222,0 @@\n-    private static String getClassName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getClassInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    private static String getPackageName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getPackageInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    private static String getModuleName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getModuleInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n@@ -2806,1 +2224,1 @@\n-    private static String getVersion(ClassFile cf, int idx) {\n+    private static String getVersion(Optional<Utf8Entry> version) {\n@@ -2810,7 +2228,1 @@\n-        if (idx == 0)\n-            return null;\n-        try {\n-            return ((CONSTANT_Utf8_info) cf.constant_pool.get(idx)).value;\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        }\n+        return version.map(Utf8Entry::stringValue).orElse(null);\n@@ -2819,16 +2231,11 @@\n-    Object convertConstantValue(CPInfo info, String descriptor) throws ConstantPoolException {\n-        if (info instanceof CONSTANT_Integer_info) {\n-            if (\"Z\".equals(descriptor))\n-                return ((CONSTANT_Integer_info) info).value == 1;\n-            else\n-                return ((CONSTANT_Integer_info) info).value;\n-        } else if (info instanceof CONSTANT_Long_info) {\n-            return ((CONSTANT_Long_info) info).value;\n-        } else if (info instanceof CONSTANT_Float_info) {\n-            return ((CONSTANT_Float_info) info).value;\n-        } else if (info instanceof CONSTANT_Double_info) {\n-            return ((CONSTANT_Double_info) info).value;\n-        } else if (info instanceof CONSTANT_String_info) {\n-            return ((CONSTANT_String_info) info).getString();\n-        }\n-        throw new IllegalStateException(info.getClass().getName());\n+    Object convertConstantValue(ConstantValueEntry info, String descriptor) {\n+        if (descriptor.length() == 1 && info instanceof IntegerEntry ie) {\n+            var i = ie.intValue();\n+            return switch (descriptor.charAt(0)) {\n+                case 'I', 'B', 'S' -> i;\n+                case 'C' -> (char) i;\n+                case 'Z' -> i == 1;\n+                default -> throw new IllegalArgumentException(descriptor);\n+            };\n+        }\n+        return info.constantValue();\n@@ -2837,39 +2244,8 @@\n-    Object convertElementValue(ConstantPool cp, element_value val) throws InvalidIndex, ConstantPoolException {\n-        switch (val.tag) {\n-            case 'Z':\n-                return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value != 0;\n-            case 'B':\n-                return (byte) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'C':\n-                return (char) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'S':\n-                return (short) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'I':\n-                return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'J':\n-                return ((CONSTANT_Long_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'F':\n-                return ((CONSTANT_Float_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'D':\n-                return ((CONSTANT_Double_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 's':\n-                return ((CONSTANT_Utf8_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-\n-            case 'e':\n-                return new EnumConstant(cp.getUTF8Value(((Enum_element_value) val).type_name_index),\n-                        cp.getUTF8Value(((Enum_element_value) val).const_name_index));\n-            case 'c':\n-                return new ClassConstant(cp.getUTF8Value(((Class_element_value) val).class_info_index));\n-\n-            case '@':\n-                return annotation2Description(cp, ((Annotation_element_value) val).annotation_value);\n-\n-            case '[':\n-                List<Object> values = new ArrayList<>();\n-                for (element_value elem : ((Array_element_value) val).values) {\n-                    values.add(convertElementValue(cp, elem));\n-                }\n-                return values;\n-            default:\n-                throw new IllegalStateException(\"Currently unhandled tag: \" + val.tag);\n-        }\n+    Object convertElementValue(AnnotationValue val) {\n+        return switch (val) {\n+            case AnnotationValue.OfConstant oc -> oc.resolvedValue();\n+            case AnnotationValue.OfEnum oe -> new EnumConstant(oe.className().stringValue(), oe.constantName().stringValue());\n+            case AnnotationValue.OfClass oc -> new ClassConstant(oc.className().stringValue());\n+            case AnnotationValue.OfArray oa -> oa.values().stream().map(this::convertElementValue).collect(Collectors.toList());\n+            case AnnotationValue.OfAnnotation oa -> annotation2Description(oa.annotation());\n+        };\n@@ -2878,7 +2254,2 @@\n-    private List<AnnotationDescription> annotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {\n-        RuntimeAnnotations_attribute annotationsAttr = (RuntimeAnnotations_attribute) attr;\n-        List<AnnotationDescription> descs = new ArrayList<>();\n-        for (Annotation a : annotationsAttr.annotations) {\n-            descs.add(annotation2Description(cp, a));\n-        }\n-        return descs;\n+    private List<AnnotationDescription> annotations2Description(List<java.lang.classfile.Annotation> annos) {\n+        return annos.stream().map(this::annotation2Description).collect(Collectors.toList());\n@@ -2887,12 +2258,2 @@\n-    private List<List<AnnotationDescription>> parameterAnnotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {\n-        RuntimeParameterAnnotations_attribute annotationsAttr =\n-                (RuntimeParameterAnnotations_attribute) attr;\n-        List<List<AnnotationDescription>> descs = new ArrayList<>();\n-        for (Annotation[] attrAnnos : annotationsAttr.parameter_annotations) {\n-            List<AnnotationDescription> paramDescs = new ArrayList<>();\n-            for (Annotation ann : attrAnnos) {\n-                paramDescs.add(annotation2Description(cp, ann));\n-            }\n-            descs.add(paramDescs);\n-        }\n-        return descs;\n+    private List<List<AnnotationDescription>> parameterAnnotations2Description(List<List<java.lang.classfile.Annotation>> annos) {\n+        return annos.stream().map(this::annotations2Description).collect(Collectors.toList());\n@@ -2901,2 +2262,2 @@\n-    private AnnotationDescription annotation2Description(ConstantPool cp, Annotation a) throws ConstantPoolException {\n-        String annotationType = cp.getUTF8Value(a.type_index);\n+    private AnnotationDescription annotation2Description(java.lang.classfile.Annotation a) {\n+        String annotationType = a.className().stringValue();\n@@ -2905,2 +2266,2 @@\n-        for (element_value_pair e : a.element_value_pairs) {\n-            values.put(cp.getUTF8Value(e.element_name_index), convertElementValue(cp, e.value));\n+        for (var e : a.elements()) {\n+            values.put(e.name().stringValue(), convertElementValue(e.value()));\n@@ -3196,1 +2557,1 @@\n-                        throw new IllegalStateException(reader.lineKey);\n+                        throw new IllegalArgumentException(reader.lineKey);\n@@ -3411,3 +2772,2 @@\n-            public static ExportsDescription create(ClassFile cf,\n-                                                    ExportsEntry ee) {\n-                String packageName = getPackageName(cf, ee.exports_index);\n+            public static ExportsDescription create(ModuleExportInfo ee) {\n+                String packageName = ee.exportedPackage().name().stringValue();\n@@ -3415,5 +2775,2 @@\n-                if (ee.exports_to_count > 0) {\n-                    to = new ArrayList<>();\n-                    for (int moduleIndex : ee.exports_to_index) {\n-                        to.add(getModuleName(cf, moduleIndex));\n-                    }\n+                if (!ee.exportsTo().isEmpty()) {\n+                    to = ee.exportsTo().stream().map(m -> m.name().stringValue()).collect(Collectors.toList());\n@@ -3462,4 +2819,3 @@\n-            public static RequiresDescription create(ClassFile cf,\n-                                                     RequiresEntry req) {\n-                String mod = getModuleName(cf, req.requires_index);\n-                String ver = getVersion(cf, req.requires_version_index);\n+            public static RequiresDescription create(ModuleRequireInfo req) {\n+                String mod = req.requires().name().stringValue();\n+                String ver = getVersion(req.requiresVersion());\n@@ -3467,1 +2823,1 @@\n-                                               req.requires_flags,\n+                                               req.requiresFlagsMask(),\n@@ -3530,7 +2886,3 @@\n-            public static ProvidesDescription create(ClassFile cf,\n-                                                     ProvidesEntry prov) {\n-                String api = getClassName(cf, prov.provides_index);\n-                List<String> impls =\n-                        Arrays.stream(prov.with_index)\n-                              .mapToObj(wi -> getClassName(cf, wi))\n-                              .collect(Collectors.toList());\n+            public static ProvidesDescription create(ModuleProvideInfo prov) {\n+                String api = prov.provides().asInternalName();\n+                List<String> impls = prov.providesWith().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n@@ -3691,1 +3043,1 @@\n-                        throw new IllegalStateException(reader.lineKey);\n+                        throw new IllegalArgumentException(reader.lineKey);\n@@ -4088,1 +3440,1 @@\n-        Object constantValue;\n+        Object constantValue; \/\/ Uses (unsigned) Integer for byte\/short\n@@ -4164,1 +3516,1 @@\n-                        throw new IllegalStateException(\"Unrecognized field type: \" + descriptor);\n+                        throw new IllegalArgumentException(\"Unrecognized field type: \" + descriptor);\n@@ -4431,1 +3783,1 @@\n-            throw new IllegalStateException(\"Cannot find: \" + name);\n+            throw new IllegalArgumentException(\"Cannot find: \" + name);\n@@ -4580,1 +3932,1 @@\n-                    throw new IllegalStateException(\"Unrecognized boolean structure: \" + value);\n+                    throw new IllegalArgumentException(\"Unrecognized boolean structure: \" + value);\n@@ -4608,1 +3960,1 @@\n-                throw new IllegalStateException(\"Unrecognized signature type: \" + value.charAt(valuePointer[0] - 1) + \"; value=\" + value);\n+                throw new IllegalArgumentException(\"Unrecognized signature type: \" + value.charAt(valuePointer[0] - 1) + \"; value=\" + value);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":355,"deletions":1003,"binary":false,"changes":1358,"status":"modified"},{"patch":"@@ -16392,1 +16392,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,41 +41,0 @@\n-#ifndef _LP64\n-float ConversionStub::float_zero = 0.0;\n-double ConversionStub::double_zero = 0.0;\n-\n-void ConversionStub::emit_code(LIR_Assembler* ce) {\n-  __ bind(_entry);\n-  assert(bytecode() == Bytecodes::_f2i || bytecode() == Bytecodes::_d2i, \"other conversions do not require stub\");\n-\n-\n-  if (input()->is_single_xmm()) {\n-    __ comiss(input()->as_xmm_float_reg(),\n-              ExternalAddress((address)&float_zero));\n-  } else if (input()->is_double_xmm()) {\n-    __ comisd(input()->as_xmm_double_reg(),\n-              ExternalAddress((address)&double_zero));\n-  } else {\n-    __ push(rax);\n-    __ ftst();\n-    __ fnstsw_ax();\n-    __ sahf();\n-    __ pop(rax);\n-  }\n-\n-  Label NaN, do_return;\n-  __ jccb(Assembler::parity, NaN);\n-  __ jccb(Assembler::below, do_return);\n-\n-  \/\/ input is > 0 -> return maxInt\n-  \/\/ result register already contains 0x80000000, so subtracting 1 gives 0x7fffffff\n-  __ decrement(result()->as_register());\n-  __ jmpb(do_return);\n-\n-  \/\/ input is NaN -> return 0\n-  __ bind(NaN);\n-  __ xorptr(result()->as_register(), result()->as_register());\n-\n-  __ bind(do_return);\n-  __ jmp(_continuation);\n-}\n-#endif \/\/ !_LP64\n-\n@@ -85,1 +44,0 @@\n-#ifdef _LP64\n@@ -88,12 +46,0 @@\n-#else\n-  const Register tmp1 = rcx;\n-  const Register tmp2 = rdx;\n-  __ push(tmp1);\n-  __ push(tmp2);\n-\n-  __ lea(tmp1, safepoint_pc);\n-  __ get_thread(tmp2);\n-  __ movptr(Address(tmp2, JavaThread::saved_exception_pc_offset()), tmp1);\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif \/* _LP64 *\/\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -174,1 +174,0 @@\n-    NOT_LP64(__ push_reg(opr->as_register_hi()));\n@@ -330,2 +329,0 @@\n-  Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );\n-  assert(thread != noreg, \"x86_32 not implemented\");\n@@ -334,1 +331,1 @@\n-  __ clinit_barrier(klass, thread, &L_skip_barrier \/*L_fast_path*\/);\n+  __ clinit_barrier(klass, &L_skip_barrier \/*L_fast_path*\/);\n@@ -406,5 +403,3 @@\n-  Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);\n-  NOT_LP64(__ get_thread(thread));\n-  __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));\n-  __ movptr(Address(thread, JavaThread::exception_oop_offset()), NULL_WORD);\n-  __ movptr(Address(thread, JavaThread::exception_pc_offset()), NULL_WORD);\n+  __ movptr(rax, Address(r15_thread, JavaThread::exception_oop_offset()));\n+  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -432,1 +427,0 @@\n-#ifdef _LP64\n@@ -435,5 +429,0 @@\n-#else\n-    __ get_thread(rax);\n-    __ movptr(Address(rsp, 0), rax);\n-    __ mov_metadata(Address(rsp, sizeof(void*)), method()->constant_encoding(), noreg);\n-#endif\n@@ -527,6 +516,0 @@\n-#ifdef _LP64\n-  const Register thread = r15_thread;\n-#else\n-  const Register thread = rbx;\n-  __ get_thread(thread);\n-#endif\n@@ -535,1 +518,1 @@\n-  __ safepoint_poll(*code_stub->entry(), thread, true \/* at_return *\/, true \/* in_nmethod *\/);\n+  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, true \/* in_nmethod *\/);\n@@ -547,1 +530,0 @@\n-#ifdef _LP64\n@@ -550,6 +532,0 @@\n-#else\n-  assert(tmp->is_cpu_register(), \"needed\");\n-  const Register poll_addr = tmp->as_register();\n-  __ get_thread(poll_addr);\n-  __ movptr(poll_addr, Address(poll_addr, in_bytes(JavaThread::polling_page_offset())));\n-#endif\n@@ -561,1 +537,1 @@\n-  guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), \"must be exact length\");\n+  guarantee(pointer_delta(post_pc, pre_pc, 1) == 3, \"must be exact length\");\n@@ -595,5 +571,0 @@\n-#ifdef _LP64\n-#else\n-      __ movptr(dest->as_register_lo(), c->as_jint_lo());\n-      __ movptr(dest->as_register_hi(), c->as_jint_hi());\n-#endif \/\/ _LP64\n@@ -676,1 +647,0 @@\n-#ifdef _LP64\n@@ -681,6 +651,0 @@\n-#else\n-      __ movptr(frame_map()->address_for_slot(dest->double_stack_ix(),\n-                                              lo_word_offset_in_bytes), c->as_jint_lo_bits());\n-      __ movptr(frame_map()->address_for_slot(dest->double_stack_ix(),\n-                                              hi_word_offset_in_bytes), c->as_jint_hi_bits());\n-#endif \/\/ _LP64\n@@ -717,1 +681,0 @@\n-#ifdef _LP64\n@@ -721,3 +684,0 @@\n-#else\n-          __ movptr(as_Address(addr), NULL_WORD);\n-#endif\n@@ -730,1 +690,0 @@\n-#ifdef _LP64\n@@ -740,3 +699,0 @@\n-#else\n-          __ movoop(as_Address(addr), c->as_jobject(), noreg);\n-#endif\n@@ -749,1 +705,0 @@\n-#ifdef _LP64\n@@ -758,5 +713,0 @@\n-#else\n-      \/\/ Always reachable in 32bit so this doesn't produce useless move literal\n-      __ movptr(as_Address_hi(addr), c->as_jint_hi_bits());\n-      __ movptr(as_Address_lo(addr), c->as_jint_lo_bits());\n-#endif \/\/ _LP64\n@@ -791,1 +741,0 @@\n-#ifdef _LP64\n@@ -797,1 +746,0 @@\n-#endif\n@@ -805,1 +753,0 @@\n-#ifdef _LP64\n@@ -812,1 +759,0 @@\n-#endif\n@@ -818,1 +764,0 @@\n-#ifdef _LP64\n@@ -822,16 +767,0 @@\n-#else\n-    assert(f_lo != f_hi && t_lo != t_hi, \"invalid register allocation\");\n-\n-\n-    if (f_lo == t_hi && f_hi == t_lo) {\n-      swap_reg(f_lo, f_hi);\n-    } else if (f_hi == t_lo) {\n-      assert(f_lo != t_hi, \"overwriting register\");\n-      move_regs(f_hi, t_hi);\n-      move_regs(f_lo, t_lo);\n-    } else {\n-      assert(f_hi != t_lo, \"overwriting register\");\n-      move_regs(f_lo, t_lo);\n-      move_regs(f_hi, t_hi);\n-    }\n-#endif \/\/ LP64\n@@ -871,1 +800,0 @@\n-    NOT_LP64(__ movptr (dstHI, src->as_register_hi()));\n@@ -894,1 +822,0 @@\n-#ifdef _LP64\n@@ -902,1 +829,0 @@\n-#endif\n@@ -933,8 +859,0 @@\n-    case T_METADATA:\n-      \/\/ We get here to store a method pointer to the stack to pass to\n-      \/\/ a dtrace runtime call. This can't work on 64 bit with\n-      \/\/ compressed klass ptrs: T_METADATA can be a compressed klass\n-      \/\/ ptr or a 64 bit method pointer.\n-      LP64_ONLY(ShouldNotReachHere());\n-      __ movptr(as_Address(to_addr), src->as_register());\n-      break;\n@@ -951,28 +869,0 @@\n-#ifdef _LP64\n-#else\n-      Register base = to_addr->base()->as_register();\n-      Register index = noreg;\n-      if (to_addr->index()->is_register()) {\n-        index = to_addr->index()->as_register();\n-      }\n-      if (base == from_lo || index == from_lo) {\n-        assert(base != from_hi, \"can't be\");\n-        assert(index == noreg || (index != base && index != from_hi), \"can't handle this\");\n-        __ movl(as_Address_hi(to_addr), from_hi);\n-        if (patch != nullptr) {\n-          patching_epilog(patch, lir_patch_high, base, info);\n-          patch = new PatchingStub(_masm, PatchingStub::access_field_id);\n-          patch_code = lir_patch_low;\n-        }\n-        __ movl(as_Address_lo(to_addr), from_lo);\n-      } else {\n-        assert(index == noreg || (index != base && index != from_lo), \"can't handle this\");\n-        __ movl(as_Address_lo(to_addr), from_lo);\n-        if (patch != nullptr) {\n-          patching_epilog(patch, lir_patch_low, base, info);\n-          patch = new PatchingStub(_masm, PatchingStub::access_field_id);\n-          patch_code = lir_patch_high;\n-        }\n-        __ movl(as_Address_hi(to_addr), from_hi);\n-      }\n-#endif \/\/ _LP64\n@@ -1028,1 +918,0 @@\n-    NOT_LP64(__ movptr(dest->as_register_hi(), src_addr_HI));\n@@ -1050,4 +939,0 @@\n-#ifndef _LP64\n-      __ pushl(frame_map()->address_for_slot(src ->single_stack_ix()));\n-      __ popl (frame_map()->address_for_slot(dest->single_stack_ix()));\n-#else\n@@ -1057,1 +942,0 @@\n-#endif\n@@ -1061,1 +945,0 @@\n-#ifdef _LP64\n@@ -1064,7 +947,0 @@\n-#else\n-    __ pushl(frame_map()->address_for_slot(src ->double_stack_ix(), 0));\n-    \/\/ push and pop the part at src + wordSize, adding wordSize for the previous push\n-    __ pushl(frame_map()->address_for_slot(src ->double_stack_ix(), 2 * wordSize));\n-    __ popl (frame_map()->address_for_slot(dest->double_stack_ix(), 2 * wordSize));\n-    __ popl (frame_map()->address_for_slot(dest->double_stack_ix(), 0));\n-#endif \/\/ _LP64\n@@ -1153,37 +1029,0 @@\n-#ifdef _LP64\n-#else\n-      Register base = addr->base()->as_register();\n-      Register index = noreg;\n-      if (addr->index()->is_register()) {\n-        index = addr->index()->as_register();\n-      }\n-      if ((base == to_lo && index == to_hi) ||\n-          (base == to_hi && index == to_lo)) {\n-        \/\/ addresses with 2 registers are only formed as a result of\n-        \/\/ array access so this code will never have to deal with\n-        \/\/ patches or null checks.\n-        assert(info == nullptr && patch == nullptr, \"must be\");\n-        __ lea(to_hi, as_Address(addr));\n-        __ movl(to_lo, Address(to_hi, 0));\n-        __ movl(to_hi, Address(to_hi, BytesPerWord));\n-      } else if (base == to_lo || index == to_lo) {\n-        assert(base != to_hi, \"can't be\");\n-        assert(index == noreg || (index != base && index != to_hi), \"can't handle this\");\n-        __ movl(to_hi, as_Address_hi(addr));\n-        if (patch != nullptr) {\n-          patching_epilog(patch, lir_patch_high, base, info);\n-          patch = new PatchingStub(_masm, PatchingStub::access_field_id);\n-          patch_code = lir_patch_low;\n-        }\n-        __ movl(to_lo, as_Address_lo(addr));\n-      } else {\n-        assert(index == noreg || (index != base && index != to_lo), \"can't handle this\");\n-        __ movl(to_lo, as_Address_lo(addr));\n-        if (patch != nullptr) {\n-          patching_epilog(patch, lir_patch_low, base, info);\n-          patch = new PatchingStub(_masm, PatchingStub::access_field_id);\n-          patch_code = lir_patch_high;\n-        }\n-        __ movl(to_hi, as_Address_hi(addr));\n-      }\n-#endif \/\/ _LP64\n@@ -1240,1 +1079,0 @@\n-#ifdef _LP64\n@@ -1244,1 +1082,0 @@\n-#endif\n@@ -1339,6 +1176,0 @@\n-#ifdef _LP64\n-#else\n-      move_regs(src->as_register(), dest->as_register_lo());\n-      move_regs(src->as_register(), dest->as_register_hi());\n-      __ sarl(dest->as_register_hi(), 31);\n-#endif \/\/ LP64\n@@ -1349,4 +1180,0 @@\n-#ifdef _LP64\n-#else\n-      move_regs(src->as_register_lo(), dest->as_register());\n-#endif\n@@ -1436,1 +1263,1 @@\n-  LP64_ONLY( __ movslq(len, len); )\n+  __ movslq(len, len);\n@@ -1504,1 +1331,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  Register tmp_load_klass = rscratch1;\n@@ -1568,2 +1395,0 @@\n-#ifdef _LP64\n-#endif \/\/ _LP64\n@@ -1577,1 +1402,0 @@\n-#ifdef _LP64\n@@ -1584,7 +1408,0 @@\n-#else\n-    if (k->is_loaded()) {\n-      __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k->constant_encoding());\n-    } else {\n-      __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));\n-    }\n-#endif\n@@ -1599,4 +1416,0 @@\n-#ifdef _LP64\n-#else\n-      __ cmpklass(Address(klass_RInfo, k->super_check_offset()), k->constant_encoding());\n-#endif \/\/ _LP64\n@@ -1611,4 +1424,0 @@\n-#ifdef _LP64\n-#else\n-        __ cmpklass(klass_RInfo, k->constant_encoding());\n-#endif \/\/ _LP64\n@@ -1619,4 +1428,0 @@\n-#ifdef _LP64\n-#else\n-        __ pushklass(k->constant_encoding(), noreg);\n-#endif \/\/ _LP64\n@@ -1652,1 +1457,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  Register tmp_load_klass = rscratch1;\n@@ -1859,11 +1664,1 @@\n-  if (LP64_ONLY(false &&) op->code() == lir_cas_long) {\n-    assert(op->cmp_value()->as_register_lo() == rax, \"wrong register\");\n-    assert(op->cmp_value()->as_register_hi() == rdx, \"wrong register\");\n-    assert(op->new_value()->as_register_lo() == rbx, \"wrong register\");\n-    assert(op->new_value()->as_register_hi() == rcx, \"wrong register\");\n-    Register addr = op->addr()->as_register();\n-    __ lock();\n-    NOT_LP64(__ cmpxchg8(Address(addr, 0)));\n-\n-  } else if (op->code() == lir_cas_int || op->code() == lir_cas_obj ) {\n-    NOT_LP64(assert(op->addr()->is_single_cpu(), \"must be single\");)\n+  if (op->code() == lir_cas_int || op->code() == lir_cas_obj) {\n@@ -1879,2 +1674,1 @@\n-    if ( op->code() == lir_cas_obj) {\n-#ifdef _LP64\n+    if (op->code() == lir_cas_obj) {\n@@ -1888,3 +1682,1 @@\n-      } else\n-#endif\n-      {\n+      } else {\n@@ -1899,1 +1691,0 @@\n-#ifdef _LP64\n@@ -1911,1 +1702,0 @@\n-#endif \/\/ _LP64\n@@ -1969,1 +1759,0 @@\n-      NOT_LP64(__ cmovptr(ncond, result->as_register_hi(), opr2->as_register_hi());)\n@@ -1974,1 +1763,0 @@\n-      NOT_LP64(__ cmovptr(ncond, result->as_register_hi(), frame_map()->address_for_slot(opr2->double_stack_ix(), hi_word_offset_in_bytes));)\n@@ -2050,2 +1838,1 @@\n-      NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));\n-      LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));\n+      assert_different_registers(lreg_lo, rreg_lo);\n@@ -2055,1 +1842,0 @@\n-          NOT_LP64(__ adcl(lreg_hi, rreg_hi));\n@@ -2059,1 +1845,0 @@\n-          NOT_LP64(__ sbbl(lreg_hi, rreg_hi));\n@@ -2062,9 +1847,0 @@\n-#ifdef _LP64\n-#else\n-          assert(lreg_lo == rax && lreg_hi == rdx, \"must be\");\n-          __ imull(lreg_hi, rreg_lo);\n-          __ imull(rreg_hi, lreg_lo);\n-          __ addl (rreg_hi, lreg_hi);\n-          __ mull (rreg_lo);\n-          __ addl (lreg_hi, rreg_hi);\n-#endif \/\/ _LP64\n@@ -2079,1 +1855,0 @@\n-#ifdef _LP64\n@@ -2092,16 +1867,0 @@\n-#else\n-      jint c_lo = right->as_constant_ptr()->as_jint_lo();\n-      jint c_hi = right->as_constant_ptr()->as_jint_hi();\n-      switch (code) {\n-        case lir_add:\n-          __ addptr(lreg_lo, c_lo);\n-          __ adcl(lreg_hi, c_hi);\n-          break;\n-        case lir_sub:\n-          __ subptr(lreg_lo, c_lo);\n-          __ sbbl(lreg_hi, c_hi);\n-          break;\n-        default:\n-          ShouldNotReachHere();\n-      }\n-#endif \/\/ _LP64\n@@ -2283,1 +2042,0 @@\n-#ifdef _LP64\n@@ -2297,20 +2055,0 @@\n-#else\n-      int r_lo = right->as_constant_ptr()->as_jint_lo();\n-      int r_hi = right->as_constant_ptr()->as_jint_hi();\n-      switch (code) {\n-        case lir_logic_and:\n-          __ andl(l_lo, r_lo);\n-          __ andl(l_hi, r_hi);\n-          break;\n-        case lir_logic_or:\n-          __ orl(l_lo, r_lo);\n-          __ orl(l_hi, r_hi);\n-          break;\n-        case lir_logic_xor:\n-          __ xorl(l_lo, r_lo);\n-          __ xorl(l_hi, r_hi);\n-          break;\n-        default: ShouldNotReachHere();\n-      }\n-#endif \/\/ _LP64\n-#ifdef _LP64\n@@ -2324,5 +2062,0 @@\n-#else\n-      Register r_lo = right->as_register_lo();\n-      Register r_hi = right->as_register_hi();\n-      assert(l_lo != r_hi, \"overwriting registers\");\n-#endif\n@@ -2332,1 +2065,0 @@\n-          NOT_LP64(__ andptr(l_hi, r_hi);)\n@@ -2336,1 +2068,0 @@\n-          NOT_LP64(__ orptr(l_hi, r_hi);)\n@@ -2340,1 +2071,0 @@\n-          NOT_LP64(__ xorptr(l_hi, r_hi);)\n@@ -2349,12 +2079,0 @@\n-#ifdef _LP64\n-#else\n-    if (dst_lo == l_hi) {\n-      assert(dst_hi != l_lo, \"overwriting registers\");\n-      move_regs(l_hi, dst_hi);\n-      move_regs(l_lo, dst_lo);\n-    } else {\n-      assert(dst_lo != l_hi, \"overwriting registers\");\n-      move_regs(l_lo, dst_lo);\n-      move_regs(l_hi, dst_hi);\n-    }\n-#endif \/\/ _LP64\n@@ -2489,11 +2207,0 @@\n-#ifdef _LP64\n-#else\n-      \/\/ cpu register - cpu register\n-      Register ylo = opr2->as_register_lo();\n-      Register yhi = opr2->as_register_hi();\n-      __ subl(xlo, ylo);\n-      __ sbbl(xhi, yhi);\n-      if (condition == lir_cond_equal || condition == lir_cond_notEqual) {\n-        __ orl(xhi, xlo);\n-      }\n-#endif \/\/ _LP64\n@@ -2504,5 +2211,0 @@\n-#ifdef _LP64\n-#else\n-      assert(condition == lir_cond_equal || condition == lir_cond_notEqual, \"only handles equals case\");\n-      __ orl(xhi, xlo);\n-#endif \/\/ _LP64\n@@ -2558,1 +2260,0 @@\n-#ifdef _LP64\n@@ -2563,1 +2264,0 @@\n-#endif \/\/ LP64\n@@ -2572,1 +2272,0 @@\n-#ifdef _LP64\n@@ -2576,3 +2275,0 @@\n-#else\n-      __ cmpoop(as_Address(addr), c->as_jobject());\n-#endif \/\/ _LP64\n@@ -2602,1 +2298,0 @@\n-#ifdef _LP64\n@@ -2611,7 +2306,0 @@\n-#else\n-    __ lcmp2int(left->as_register_hi(),\n-                left->as_register_lo(),\n-                right->as_register_hi(),\n-                right->as_register_lo());\n-    move_regs(left->as_register_hi(), dst->as_register());\n-#endif \/\/ _LP64\n@@ -2743,1 +2431,0 @@\n-#ifdef _LP64\n@@ -2750,9 +2437,0 @@\n-#else\n-\n-    switch (code) {\n-      case lir_shl:  __ lshl(hi, lo);        break;\n-      case lir_shr:  __ lshr(hi, lo, true);  break;\n-      case lir_ushr: __ lshr(hi, lo, false); break;\n-      default: ShouldNotReachHere();\n-    }\n-#endif \/\/ LP64\n@@ -2779,3 +2457,0 @@\n-#ifndef _LP64\n-    Unimplemented();\n-#else\n@@ -2793,1 +2468,0 @@\n-#endif \/\/ _LP64\n@@ -2858,1 +2532,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  Register tmp_load_klass = rscratch1;\n@@ -2889,1 +2563,0 @@\n-    NOT_LP64(assert(src == rcx && src_pos == rdx, \"mismatch in calling convention\");)\n@@ -2895,1 +2568,0 @@\n-#ifdef _LP64\n@@ -2926,15 +2598,0 @@\n-#else\n-    __ push(length);\n-    __ push(dst_pos);\n-    __ push(dst);\n-    __ push(src_pos);\n-    __ push(src);\n-\n-#ifndef PRODUCT\n-    if (PrintC1Statistics) {\n-      __ incrementl(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt), rscratch1);\n-    }\n-#endif\n-    __ call_VM_leaf(copyfunc_addr, 5); \/\/ removes pushed parameter from the stack\n-\n-#endif \/\/ _LP64\n@@ -3054,1 +2711,0 @@\n-#ifdef _LP64\n@@ -3057,1 +2713,0 @@\n-#endif\n@@ -3121,15 +2776,0 @@\n-#ifndef _LP64\n-       Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n-        __ movptr(tmp, dst_klass_addr);\n-        __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));\n-        __ push(tmp);\n-        __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));\n-        __ push(tmp);\n-        __ push(length);\n-        __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));\n-        __ push(tmp);\n-        __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));\n-        __ push(tmp);\n-\n-        __ call_VM_leaf(copyfunc_addr, 5);\n-#else\n@@ -3162,2 +2802,0 @@\n-#endif\n-\n@@ -3219,1 +2857,0 @@\n-#ifdef _LP64\n@@ -3223,1 +2860,0 @@\n-#endif\n@@ -3248,1 +2884,0 @@\n-#ifdef _LP64\n@@ -3255,8 +2890,0 @@\n-#else\n-  __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));\n-  store_parameter(tmp, 0);\n-  __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));\n-  store_parameter(tmp, 1);\n-  store_parameter(length, 2);\n-#endif \/\/ _LP64\n-\n@@ -3335,1 +2962,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  Register tmp_load_klass = rscratch1;\n@@ -3406,1 +3033,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  Register tmp_load_klass = rscratch1;\n@@ -3426,8 +3053,0 @@\n-#ifdef _LP64\n-#else\n-    assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n-#endif\n-#ifdef _LP64\n-#else\n-    assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());\n-#endif\n@@ -3490,2 +3109,0 @@\n-#ifdef _LP64\n-#endif\n@@ -3505,1 +3122,0 @@\n-#ifdef _LP64\n@@ -3513,1 +3129,0 @@\n-#endif\n@@ -3627,1 +3242,0 @@\n-#ifdef _LP64\n@@ -3631,12 +3245,0 @@\n-#else\n-    Register hi = left->as_register_hi();\n-    __ lneg(hi, lo);\n-    if (dest->as_register_lo() == hi) {\n-      assert(dest->as_register_hi() != lo, \"destroying register\");\n-      move_regs(hi, dest->as_register_hi());\n-      move_regs(lo, dest->as_register_lo());\n-    } else {\n-      move_regs(lo, dest->as_register_lo());\n-      move_regs(hi, dest->as_register_hi());\n-    }\n-#endif \/\/ _LP64\n@@ -3705,6 +3307,0 @@\n-#ifdef _LP64\n-#else\n-      __ movdl(dest->as_register_lo(), src->as_xmm_double_reg());\n-      __ psrlq(src->as_xmm_double_reg(), 32);\n-      __ movdl(dest->as_register_hi(), src->as_xmm_double_reg());\n-#endif \/\/ _LP64\n@@ -3728,0 +3324,1 @@\n+\n@@ -3810,5 +3407,0 @@\n-#ifdef _LP64\n-  \/\/ __ get_thread(result_reg->as_register_lo());\n-#else\n-  __ get_thread(result_reg->as_register());\n-#endif \/\/ _LP64\n@@ -3839,1 +3431,0 @@\n-#ifdef _LP64\n@@ -3847,4 +3438,0 @@\n-#else\n-    __ xchgl(obj, as_Address(src->as_address_ptr()));\n-#endif\n-#ifdef _LP64\n@@ -3859,3 +3446,0 @@\n-#else\n-    ShouldNotReachHere();\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":17,"deletions":433,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    _call_stub_size = NOT_LP64(15) LP64_ONLY(28),\n+    _call_stub_size = 28,\n@@ -51,1 +51,1 @@\n-    _deopt_handler_size = NOT_LP64(10) LP64_ONLY(17)\n+    _deopt_handler_size = 17\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,1 +159,0 @@\n-  NOT_LP64( return new_register(T_ADDRESS); )\n@@ -169,1 +168,0 @@\n-#ifdef _LP64\n@@ -184,5 +182,0 @@\n-#else\n-    return new LIR_Address(base,\n-                           ((intx)(constant->as_jint()) << shift) + disp,\n-                           type);\n-#endif\n@@ -202,1 +195,0 @@\n-#ifdef _LP64\n@@ -214,15 +206,0 @@\n-#else\n-    \/\/ A displacement overflow can also occur for x86 but that is not a problem due to the 32-bit address range!\n-    \/\/ Let's assume an array 'a' and an access with displacement 'disp'. When disp overflows, then \"a + disp\" will\n-    \/\/ always be negative (i.e. underflows the 32-bit address range):\n-    \/\/ Let N = 2^32: a + signed_overflow(disp) = a + disp - N.\n-    \/\/ \"a + disp\" is always smaller than N. If an index was chosen which would point to an address beyond N, then\n-    \/\/ range checks would catch that and throw an exception. Thus, a + disp < 0 holds which means that it always\n-    \/\/ underflows the 32-bit address range:\n-    \/\/ unsigned_underflow(a + signed_overflow(disp)) = unsigned_underflow(a + disp - N)\n-    \/\/                                              = (a + disp - N) + N = a + disp\n-    \/\/ This shows that we still end up at the correct address with a displacement overflow due to the 32-bit address\n-    \/\/ range limitation. This overflow only needs to be handled if addresses can be larger as on 64-bit platforms.\n-    addr = new LIR_Address(array_opr, offset_in_bytes + (intx)(index_opr->as_jint()) * elem_size, type);\n-#endif \/\/ _LP64\n-#ifdef _LP64\n@@ -235,1 +212,0 @@\n-#endif \/\/ _LP64\n@@ -386,18 +362,0 @@\n-#ifndef _LP64\n-  \/\/ do not load right operand if it is a constant.  only 0 and 1 are\n-  \/\/ loaded because there are special instructions for loading them\n-  \/\/ without memory access (not needed for SSE2 instructions)\n-  bool must_load_right = false;\n-  if (right.is_constant()) {\n-    LIR_Const* c = right.result()->as_constant_ptr();\n-    assert(c != nullptr, \"invalid constant\");\n-    assert(c->type() == T_FLOAT || c->type() == T_DOUBLE, \"invalid type\");\n-\n-    if (c->type() == T_FLOAT) {\n-      must_load_right = UseSSE < 1 && (c->is_one_float() || c->is_zero_float());\n-    } else {\n-      must_load_right = UseSSE < 2 && (c->is_one_double() || c->is_zero_double());\n-    }\n-  }\n-#endif \/\/ !LP64\n-\n@@ -410,4 +368,0 @@\n-#ifndef _LP64\n-  } else if (must_load_right) {\n-    right.load_item();\n-#endif \/\/ !LP64\n@@ -423,1 +377,0 @@\n-#ifdef _LP64\n@@ -458,21 +411,0 @@\n-#else\n-  if ((UseSSE >= 1 && x->op() == Bytecodes::_frem) || (UseSSE >= 2 && x->op() == Bytecodes::_drem)) {\n-    \/\/ special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots\n-    LIR_Opr fpu0, fpu1;\n-    if (x->op() == Bytecodes::_frem) {\n-      fpu0 = LIR_OprFact::single_fpu(0);\n-      fpu1 = LIR_OprFact::single_fpu(1);\n-    } else {\n-      fpu0 = LIR_OprFact::double_fpu(0);\n-      fpu1 = LIR_OprFact::double_fpu(1);\n-    }\n-    __ move(right.result(), fpu1); \/\/ order of left and right operand is important!\n-    __ move(left.result(), fpu0);\n-    __ rem (fpu0, fpu1, fpu0);\n-    __ move(fpu0, reg);\n-\n-  } else {\n-    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), tmp);\n-  }\n-  set_result(x, reg);\n-#endif \/\/ _LP64\n@@ -768,1 +700,1 @@\n-  assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), \"unexpected type\");\n+  assert(type == T_INT || is_oop || type == T_LONG, \"unexpected type\");\n@@ -778,1 +710,1 @@\n-  assert(type == T_INT LP64_ONLY( || type == T_LONG ), \"unexpected type\");\n+  assert(type == T_INT || type == T_LONG, \"unexpected type\");\n@@ -816,4 +748,1 @@\n-      x->id() == vmIntrinsics::_dlog10\n-#ifdef _LP64\n-      || x->id() == vmIntrinsics::_dtanh\n-#endif\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh\n@@ -827,6 +756,0 @@\n-  bool use_fpu = false;\n-#ifndef _LP64\n-  if (UseSSE < 2) {\n-    value.set_destroys_register();\n-  }\n-#endif \/\/ !LP64\n@@ -860,4 +783,0 @@\n-\n-  if (use_fpu) {\n-    __ move(calc_result, x->operand());\n-  }\n@@ -984,14 +903,0 @@\n-#ifndef _LP64\n-  src.load_item_force     (FrameMap::rcx_oop_opr);\n-  src_pos.load_item_force (FrameMap::rdx_opr);\n-  dst.load_item_force     (FrameMap::rax_oop_opr);\n-  dst_pos.load_item_force (FrameMap::rbx_opr);\n-  length.load_item_force  (FrameMap::rdi_opr);\n-  LIR_Opr tmp =           (FrameMap::rsi_opr);\n-\n-  if (expected_type != nullptr && flags == 0) {\n-    FrameMap* f = Compilation::current()->frame_map();\n-    f->update_reserved_argument_area_size(3 * BytesPerWord);\n-  }\n-#else\n-\n@@ -1013,1 +918,0 @@\n-#endif \/\/ LP64\n@@ -1055,6 +959,0 @@\n-#ifndef _LP64\n-      if (!is_updateBytes) { \/\/ long b raw address\n-         base_op = new_register(T_INT);\n-         __ convert(Bytecodes::_l2i, buf.result(), base_op);\n-      }\n-#else\n@@ -1066,1 +964,0 @@\n-#endif\n@@ -1200,8 +1097,0 @@\n-#ifndef _LP64\n-  result_a = new_register(T_INT);\n-  __ convert(Bytecodes::_l2i, a.result(), result_a);\n-  result_b = new_register(T_INT);\n-  __ convert(Bytecodes::_l2i, b.result(), result_b);\n-#endif\n-\n-\n@@ -1242,1 +1131,0 @@\n-#ifdef _LP64\n@@ -1250,60 +1138,0 @@\n-#else\n-  \/\/ flags that vary for the different operations and different SSE-settings\n-  bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;\n-\n-  switch (x->op()) {\n-    case Bytecodes::_i2l: \/\/ fall through\n-    case Bytecodes::_l2i: \/\/ fall through\n-    case Bytecodes::_i2b: \/\/ fall through\n-    case Bytecodes::_i2c: \/\/ fall through\n-    case Bytecodes::_i2s: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;\n-\n-    case Bytecodes::_f2d: fixed_input = UseSSE == 1; fixed_result = false;       round_result = false;      needs_stub = false; break;\n-    case Bytecodes::_d2f: fixed_input = false;       fixed_result = UseSSE == 1; round_result = UseSSE < 1; needs_stub = false; break;\n-    case Bytecodes::_i2f: fixed_input = false;       fixed_result = false;       round_result = UseSSE < 1; needs_stub = false; break;\n-    case Bytecodes::_i2d: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;\n-    case Bytecodes::_f2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;\n-    case Bytecodes::_d2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;\n-    case Bytecodes::_l2f: fixed_input = false;       fixed_result = UseSSE >= 1; round_result = UseSSE < 1; needs_stub = false; break;\n-    case Bytecodes::_l2d: fixed_input = false;       fixed_result = UseSSE >= 2; round_result = UseSSE < 2; needs_stub = false; break;\n-    case Bytecodes::_f2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;\n-    case Bytecodes::_d2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;\n-    default: ShouldNotReachHere();\n-  }\n-\n-  LIRItem value(x->value(), this);\n-  value.load_item();\n-  LIR_Opr input = value.result();\n-  LIR_Opr result = rlock(x);\n-\n-  \/\/ arguments of lir_convert\n-  LIR_Opr conv_input = input;\n-  LIR_Opr conv_result = result;\n-  ConversionStub* stub = nullptr;\n-\n-  if (fixed_input) {\n-    conv_input = fixed_register_for(input->type());\n-    __ move(input, conv_input);\n-  }\n-\n-  assert(fixed_result == false || round_result == false, \"cannot set both\");\n-  if (fixed_result) {\n-    conv_result = fixed_register_for(result->type());\n-  } else if (round_result) {\n-    result = new_register(result->type());\n-    set_vreg_flag(result, must_start_in_memory);\n-  }\n-\n-  if (needs_stub) {\n-    stub = new ConversionStub(x->op(), conv_input, conv_result);\n-  }\n-\n-  __ convert(x->op(), conv_input, conv_result, stub);\n-\n-  if (result != conv_result) {\n-    __ move(conv_result, result);\n-  }\n-\n-  assert(result->is_virtual(), \"result must be virtual register\");\n-  set_result(x, result);\n-#endif \/\/ _LP64\n@@ -1583,6 +1411,0 @@\n-#ifdef _LP64\n-#else\n-  LIR_Opr result = new_register(T_INT);\n-  __ get_thread(result);\n-  return result;\n-#endif \/\/\n@@ -1634,6 +1456,0 @@\n-#ifndef _LP64\n-    if (UseSSE < 2) {\n-      \/\/ no spill slot needed in SSE2 mode because xmm->cpu register move is possible\n-      set_vreg_flag(result, must_start_in_memory);\n-    }\n-#endif \/\/ !LP64\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":3,"deletions":187,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -66,9 +66,1 @@\n-#ifdef _LP64\n-    const Register thread = r15_thread;\n-    lightweight_lock(disp_hdr, obj, hdr, thread, tmp, slow_case);\n-#else\n-    \/\/ Implicit null check.\n-    movptr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n-    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n-    jmp(slow_case);\n-#endif\n+    lightweight_lock(disp_hdr, obj, hdr, tmp, slow_case);\n@@ -143,6 +135,1 @@\n-#ifdef _LP64\n-    lightweight_unlock(obj, disp_hdr, r15_thread, hdr, slow_case);\n-#else\n-    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n-    jmp(slow_case);\n-#endif\n+    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n@@ -183,1 +170,0 @@\n-#ifdef _LP64\n@@ -188,3 +174,1 @@\n-  } else if (!UseCompactObjectHeaders)\n-#endif\n-  {\n+  } else if (!UseCompactObjectHeaders) {\n@@ -196,1 +180,0 @@\n-#ifdef _LP64\n@@ -204,4 +187,1 @@\n-#endif\n-  }\n-#ifdef _LP64\n-  else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n@@ -211,1 +191,0 @@\n-#endif\n@@ -274,2 +253,0 @@\n-        NOT_LP64(movptr(Address(obj, index, Address::times_8, hdr_size_in_bytes - (2*BytesPerWord)),\n-               t1_zero);)\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread); \/\/ is callee-saved register (Visual C++ calling conventions)\n+  const Register thread = r15_thread;\n@@ -59,1 +59,1 @@\n-#ifdef _LP64\n+\n@@ -63,2 +63,0 @@\n-#endif\n-#ifdef _LP64\n@@ -68,7 +66,0 @@\n-#else\n-  set_num_rt_args(1 + args_size);\n-\n-  \/\/ push java thread (becomes first argument of C function)\n-  get_thread(thread);\n-  push(thread);\n-#endif \/\/ _LP64\n@@ -78,1 +69,1 @@\n-    set_last_Java_frame(thread, noreg, rbp, nullptr, rscratch1);\n+    set_last_Java_frame(noreg, rbp, nullptr, rscratch1);\n@@ -82,1 +73,1 @@\n-    set_last_Java_frame(thread, noreg, rbp, the_pc, rscratch1);\n+    set_last_Java_frame(noreg, rbp, the_pc, rscratch1);\n@@ -96,1 +87,1 @@\n-    get_thread(rax);\n+    get_thread_slow(rax);\n@@ -105,4 +96,1 @@\n-  reset_last_Java_frame(thread, true);\n-\n-  \/\/ discard thread and arguments\n-  NOT_LP64(addptr(rsp, num_rt_args()*BytesPerWord));\n+  reset_last_Java_frame(true);\n@@ -135,1 +123,1 @@\n-    get_vm_result(oop_result1, thread);\n+    get_vm_result(oop_result1);\n@@ -138,1 +126,1 @@\n-    get_vm_result_2(metadata_result, thread);\n+    get_vm_result_2(metadata_result);\n@@ -147,4 +135,0 @@\n-#ifdef _LP64\n-#else\n-  push(arg1);\n-#endif \/\/ _LP64\n@@ -157,1 +141,0 @@\n-#ifdef _LP64\n@@ -169,4 +152,0 @@\n-#else\n-  push(arg2);\n-  push(arg1);\n-#endif \/\/ _LP64\n@@ -178,1 +157,0 @@\n-#ifdef _LP64\n@@ -194,5 +172,0 @@\n-#else\n-  push(arg3);\n-  push(arg2);\n-  push(arg1);\n-#endif \/\/ _LP64\n@@ -265,7 +238,2 @@\n-#ifdef _LP64\n-  #define SLOT2(x) x,\n-  #define SLOT_PER_WORD 2\n-#else\n-  #define SLOT2(x)\n-  #define SLOT_PER_WORD 1\n-#endif \/\/ _LP64\n+#define SLOT2(x) x,\n+#define SLOT_PER_WORD 2\n@@ -276,2 +244,0 @@\n-#ifdef _LP64\n-#endif \/\/ _LP64\n@@ -294,1 +260,0 @@\n-#ifdef _LP64\n@@ -304,3 +269,0 @@\n-#else\n-  rdi_off = extra_space_offset,\n-#endif \/\/ _LP64\n@@ -332,2 +294,2 @@\n-  LP64_ONLY(num_rt_args = 0);\n-  LP64_ONLY(assert((reg_save_frame_size * VMRegImpl::stack_slot_size) % 16 == 0, \"must be 16 byte aligned\");)\n+  num_rt_args = 0;\n+  assert((reg_save_frame_size * VMRegImpl::stack_slot_size) % 16 == 0, \"must be 16 byte aligned\");\n@@ -346,1 +308,0 @@\n-#ifdef _LP64\n@@ -372,1 +333,0 @@\n-#endif \/\/ _LP64\n@@ -377,26 +337,0 @@\n-#ifndef _LP64\n-    if (UseSSE < 2) {\n-      int fpu_off = float_regs_as_doubles_off;\n-      for (int n = 0; n < FrameMap::nof_fpu_regs; n++) {\n-        VMReg fpu_name_0 = FrameMap::fpu_regname(n);\n-        map->set_callee_saved(VMRegImpl::stack2reg(fpu_off +     num_rt_args), fpu_name_0);\n-        \/\/ %%% This is really a waste but we'll keep things as they were for now\n-        if (true) {\n-          map->set_callee_saved(VMRegImpl::stack2reg(fpu_off + 1 + num_rt_args), fpu_name_0->next());\n-        }\n-        fpu_off += 2;\n-      }\n-      assert(fpu_off == fpu_state_off, \"incorrect number of fpu stack slots\");\n-\n-      if (UseSSE == 1) {\n-        int xmm_off = xmm_regs_as_doubles_off;\n-        for (int n = 0; n < FrameMap::nof_fpu_regs; n++) {\n-          VMReg xmm_name_0 = as_XMMRegister(n)->as_VMReg();\n-          map->set_callee_saved(VMRegImpl::stack2reg(xmm_off + num_rt_args), xmm_name_0);\n-          xmm_off += 2;\n-        }\n-        assert(xmm_off == float_regs_as_doubles_off, \"incorrect number of xmm registers\");\n-      }\n-    }\n-#endif \/\/ !LP64\n-\n@@ -429,7 +363,0 @@\n-#ifdef _LP64\n-#else\n-  __ pusha();\n-#endif\n-\n-  \/\/ assert(float_regs_as_doubles_off % 2 == 0, \"misaligned offset\");\n-  \/\/ assert(xmm_regs_as_doubles_off % 2 == 0, \"misaligned offset\");\n@@ -445,40 +372,0 @@\n-#ifndef _LP64\n-    if (UseSSE < 2) {\n-      \/\/ save FPU stack\n-      __ fnsave(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));\n-      __ fwait();\n-\n-#ifdef ASSERT\n-      Label ok;\n-      __ cmpw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::x86::fpu_cntrl_wrd_std());\n-      __ jccb(Assembler::equal, ok);\n-      __ stop(\"corrupted control word detected\");\n-      __ bind(ok);\n-#endif\n-\n-      \/\/ Reset the control word to guard against exceptions being unmasked\n-      \/\/ since fstp_d can cause FPU stack underflow exceptions.  Write it\n-      \/\/ into the on stack copy and then reload that to make sure that the\n-      \/\/ current and future values are correct.\n-      __ movw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::x86::fpu_cntrl_wrd_std());\n-      __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));\n-\n-      \/\/ Save the FPU registers in de-opt-able form\n-      int offset = 0;\n-      for (int n = 0; n < FrameMap::nof_fpu_regs; n++) {\n-        __ fstp_d(Address(rsp, float_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));\n-        offset += 8;\n-      }\n-\n-      if (UseSSE == 1) {\n-        \/\/ save XMM registers as float because double not supported without SSE2(num MMX == num fpu)\n-        int offset = 0;\n-        for (int n = 0; n < FrameMap::nof_fpu_regs; n++) {\n-          XMMRegister xmm_name = as_XMMRegister(n);\n-          __ movflt(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);\n-          offset += 8;\n-        }\n-      }\n-    }\n-#endif \/\/ !_LP64\n-\n@@ -500,3 +387,0 @@\n-\n-  \/\/ FPU stack must be empty now\n-  NOT_LP64( __ verify_FPU(0, \"save_live_registers\"); )\n@@ -509,1 +393,0 @@\n-#ifdef _LP64\n@@ -520,32 +403,0 @@\n-#else\n-  if (restore_fpu_registers) {\n-    if (UseSSE >= 2) {\n-      \/\/ restore XMM registers\n-      int xmm_bypass_limit = FrameMap::nof_xmm_regs;\n-      int offset = 0;\n-      for (int n = 0; n < xmm_bypass_limit; n++) {\n-        XMMRegister xmm_name = as_XMMRegister(n);\n-        __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));\n-        offset += 8;\n-      }\n-    } else if (UseSSE == 1) {\n-      \/\/ restore XMM registers(num MMX == num fpu)\n-      int offset = 0;\n-      for (int n = 0; n < FrameMap::nof_fpu_regs; n++) {\n-        XMMRegister xmm_name = as_XMMRegister(n);\n-        __ movflt(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));\n-        offset += 8;\n-      }\n-    }\n-\n-    if (UseSSE < 2) {\n-      __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));\n-    } else {\n-      \/\/ check that FPU stack is really empty\n-      __ verify_FPU(0, \"restore_live_registers\");\n-    }\n-  } else {\n-    \/\/ check that FPU stack is really empty\n-    __ verify_FPU(0, \"restore_live_registers\");\n-  }\n-#endif \/\/ _LP64\n@@ -573,5 +424,0 @@\n-#ifdef _LP64\n-#else\n-  __ popa();\n-#endif\n-\n@@ -587,1 +433,0 @@\n-#ifdef _LP64\n@@ -605,11 +450,0 @@\n-#else\n-\n-  __ pop(rdi);\n-  __ pop(rsi);\n-  __ pop(rbp);\n-  __ pop(rbx); \/\/ skip this value\n-  __ pop(rbx);\n-  __ pop(rdx);\n-  __ pop(rcx);\n-  __ addptr(rsp, BytesPerWord);\n-#endif \/\/ _LP64\n@@ -642,5 +476,0 @@\n-#ifdef _LP64\n-#else\n-  Unimplemented();\n-  return 0;\n-#endif\n@@ -667,1 +496,0 @@\n-#ifdef _LP64\n@@ -670,6 +498,0 @@\n-#else\n-    __ movptr(temp_reg, Address(rbp, 3*BytesPerWord));\n-    __ push(temp_reg);\n-    __ movptr(temp_reg, Address(rbp, 2*BytesPerWord));\n-    __ push(temp_reg);\n-#endif \/\/ _LP64\n@@ -695,1 +517,1 @@\n-  const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);\n+  const Register thread = r15_thread;\n@@ -728,1 +550,1 @@\n-    const int frame_size = 2 \/*BP, return address*\/ NOT_LP64(+ 1 \/*thread*\/) WIN64_ONLY(+ frame::arg_reg_save_area_bytes \/ BytesPerWord);\n+    const int frame_size = 2 \/*BP, return address*\/ WIN64_ONLY(+ frame::arg_reg_save_area_bytes \/ BytesPerWord);\n@@ -737,7 +559,0 @@\n-#if !defined(_LP64) && defined(COMPILER2)\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n-    \/\/ C2 can leave the fpu stack dirty\n-    __ empty_FPU_stack();\n-  }\n-#endif \/\/ !_LP64 && COMPILER2\n-\n@@ -749,3 +564,0 @@\n-  \/\/ load address of JavaThread object for thread-local data\n-  NOT_LP64(__ get_thread(thread);)\n-\n@@ -818,1 +630,1 @@\n-  const Register exception_oop_callee_saved = NOT_LP64(rsi) LP64_ONLY(r14);\n+  const Register exception_oop_callee_saved = r14;\n@@ -822,1 +634,1 @@\n-  const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);\n+  const Register thread = r15_thread;\n@@ -837,1 +649,0 @@\n-  NOT_LP64(__ get_thread(thread);)\n@@ -851,3 +662,0 @@\n-  \/\/ clear the FPU stack in case any FPU results are left behind\n-  NOT_LP64( __ empty_FPU_stack(); )\n-\n@@ -858,1 +666,0 @@\n-  NOT_LP64(__ get_thread(thread);)\n@@ -908,1 +715,0 @@\n-#ifdef _LP64\n@@ -912,9 +718,1 @@\n-#else\n-  __ push(rax); \/\/ push dummy\n-\n-  const Register thread = rdi; \/\/ is callee-saved register (Visual C++ calling conventions)\n-  \/\/ push java thread (becomes first argument of C function)\n-  __ get_thread(thread);\n-  __ push(thread);\n-#endif \/\/ _LP64\n-  __ set_last_Java_frame(thread, noreg, rbp, nullptr, rscratch1);\n+  __ set_last_Java_frame(noreg, rbp, nullptr, rscratch1);\n@@ -930,1 +728,1 @@\n-    __ get_thread(rax);\n+    __ get_thread_slow(rax);\n@@ -938,5 +736,1 @@\n-  __ reset_last_Java_frame(thread, true);\n-#ifndef _LP64\n-  __ pop(rcx); \/\/ discard thread arg\n-  __ pop(rcx); \/\/ discard dummy\n-#endif \/\/ _LP64\n+  __ reset_last_Java_frame(true);\n@@ -1269,1 +1063,0 @@\n-#ifdef _LP64\n@@ -1272,6 +1065,0 @@\n-#else\n-        \/\/ The object is passed on the stack and we haven't pushed a\n-        \/\/ frame yet so it's one work away from top of stack.\n-        __ movptr(rax, Address(rsp, 1 * BytesPerWord));\n-        __ verify_oop(rax);\n-#endif \/\/ _LP64\n@@ -1582,1 +1369,1 @@\n-        __ NOT_LP64(push(rax)) LP64_ONLY(mov(c_rarg0, rax));\n+        __ mov(c_rarg0, rax);\n@@ -1584,1 +1371,0 @@\n-        NOT_LP64(__ pop(rax));\n@@ -1592,1 +1378,0 @@\n-#ifdef _LP64\n@@ -1604,72 +1389,0 @@\n-#else\n-        \/\/ rax, and rdx are destroyed, but should be free since the result is returned there\n-        \/\/ preserve rsi,ecx\n-        __ push(rsi);\n-        __ push(rcx);\n-\n-        \/\/ check for NaN\n-        Label return0, do_return, return_min_jlong, do_convert;\n-\n-        Address value_high_word(rsp, wordSize + 4);\n-        Address value_low_word(rsp, wordSize);\n-        Address result_high_word(rsp, 3*wordSize + 4);\n-        Address result_low_word(rsp, 3*wordSize);\n-\n-        __ subptr(rsp, 32);                    \/\/ more than enough on 32bit\n-        __ fst_d(value_low_word);\n-        __ movl(rax, value_high_word);\n-        __ andl(rax, 0x7ff00000);\n-        __ cmpl(rax, 0x7ff00000);\n-        __ jcc(Assembler::notEqual, do_convert);\n-        __ movl(rax, value_high_word);\n-        __ andl(rax, 0xfffff);\n-        __ orl(rax, value_low_word);\n-        __ jcc(Assembler::notZero, return0);\n-\n-        __ bind(do_convert);\n-        __ fnstcw(Address(rsp, 0));\n-        __ movzwl(rax, Address(rsp, 0));\n-        __ orl(rax, 0xc00);\n-        __ movw(Address(rsp, 2), rax);\n-        __ fldcw(Address(rsp, 2));\n-        __ fwait();\n-        __ fistp_d(result_low_word);\n-        __ fldcw(Address(rsp, 0));\n-        __ fwait();\n-        \/\/ This gets the entire long in rax on 64bit\n-        __ movptr(rax, result_low_word);\n-        \/\/ testing of high bits\n-        __ movl(rdx, result_high_word);\n-        __ mov(rcx, rax);\n-        \/\/ What the heck is the point of the next instruction???\n-        __ xorl(rcx, 0x0);\n-        __ movl(rsi, 0x80000000);\n-        __ xorl(rsi, rdx);\n-        __ orl(rcx, rsi);\n-        __ jcc(Assembler::notEqual, do_return);\n-        __ fldz();\n-        __ fcomp_d(value_low_word);\n-        __ fnstsw_ax();\n-        __ sahf();\n-        __ jcc(Assembler::above, return_min_jlong);\n-        \/\/ return max_jlong\n-        __ movl(rdx, 0x7fffffff);\n-        __ movl(rax, 0xffffffff);\n-        __ jmp(do_return);\n-\n-        __ bind(return_min_jlong);\n-        __ movl(rdx, 0x80000000);\n-        __ xorl(rax, rax);\n-        __ jmp(do_return);\n-\n-        __ bind(return0);\n-        __ fpop();\n-        __ xorptr(rdx,rdx);\n-        __ xorptr(rax,rax);\n-\n-        __ bind(do_return);\n-        __ addptr(rsp, 32);\n-        __ pop(rcx);\n-        __ pop(rsi);\n-        __ ret(0);\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":20,"deletions":307,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+    clinit_barrier(klass, &L_skip_barrier \/*L_fast_path*\/);\n@@ -135,10 +135,0 @@\n-#ifndef _LP64\n-  \/\/ If method sets FPU control word do it now\n-  if (fp_mode_24b) {\n-    fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n-  }\n-  if (UseSSE >= 2 && VerifyFPU) {\n-    verify_FPU(0, \"FPU stack must be clean on entry\");\n-  }\n-#endif\n-\n@@ -162,1 +152,0 @@\n-#ifdef _LP64\n@@ -176,4 +165,0 @@\n-#else\n-  \/\/ Don't bother with out-of-line nmethod entry barrier stub for x86_32.\n-  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n-#endif\n@@ -331,1 +316,1 @@\n-    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - (int)os::vm_page_size())) );\n+    andptr(tmpReg, (int32_t) (7 - (int)os::vm_page_size()) );\n@@ -339,4 +324,0 @@\n-#ifndef _LP64\n-  \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n-  orl(boxReg, 1);  \/\/ set ICC.ZF=0 to indicate failure\n-#else\n@@ -361,1 +342,0 @@\n-#endif \/\/ _LP64\n@@ -370,1 +350,0 @@\n-#ifdef _LP64\n@@ -373,1 +352,0 @@\n-#endif\n@@ -436,5 +414,0 @@\n-#ifndef _LP64\n-  \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n-  orl(boxReg, 1);  \/\/ set ICC.ZF=0 to indicate failure\n-  jmpb(DONE_LABEL);\n-#else\n@@ -494,1 +467,0 @@\n-#endif  \/\/ _LP64\n@@ -514,2 +486,0 @@\n-#ifdef _LP64\n-#endif\n@@ -595,5 +565,0 @@\n-#ifndef _LP64\n-    \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n-    orl(box, 1);  \/\/ set ICC.ZF=0 to indicate failure\n-    jmpb(slow_path);\n-#else\n@@ -665,1 +630,0 @@\n-#endif  \/\/ _LP64\n@@ -778,5 +742,0 @@\n-#ifndef _LP64\n-    \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n-    orl(t, 1);  \/\/ set ICC.ZF=0 to indicate failure\n-    jmpb(slow_path);\n-#else\n@@ -832,1 +791,0 @@\n-#endif  \/\/ _LP64\n@@ -1554,1 +1512,0 @@\n-#ifdef _LP64\n@@ -1593,1 +1550,0 @@\n-#endif \/\/ _LP64\n@@ -1665,1 +1621,1 @@\n-      LP64_ONLY(vgather8b_masked_offset(elem_ty, temp_dst, base, idx_base, offset, mask, mask_idx, rtmp, vlen_enc));\n+      vgather8b_masked_offset(elem_ty, temp_dst, base, idx_base, offset, mask, mask_idx, rtmp, vlen_enc);\n@@ -2069,1 +2025,0 @@\n-#ifdef _LP64\n@@ -2081,1 +2036,0 @@\n-#endif \/\/ _LP64\n@@ -2331,1 +2285,0 @@\n-#ifdef _LP64\n@@ -2357,1 +2310,0 @@\n-#endif \/\/ _LP64\n@@ -2773,1 +2725,0 @@\n-#ifdef _LP64\n@@ -2802,1 +2753,0 @@\n-#endif\n@@ -3730,1 +3680,1 @@\n-  Label COMPARE_WIDE_VECTORS_LOOP_FAILED;  \/\/ used only _LP64 && AVX3\n+  Label COMPARE_WIDE_VECTORS_LOOP_FAILED;  \/\/ used only AVX3\n@@ -3800,1 +3750,1 @@\n-    Label COMPARE_WIDE_VECTORS_LOOP_AVX3;  \/\/ used only _LP64 && AVX3\n+    Label COMPARE_WIDE_VECTORS_LOOP_AVX3;  \/\/ used only AVX3\n@@ -3870,1 +3820,0 @@\n-#ifdef _LP64\n@@ -3894,2 +3843,0 @@\n-#endif \/\/ _LP64\n-\n@@ -4064,1 +4011,0 @@\n-#ifdef _LP64\n@@ -4090,1 +4036,0 @@\n-#endif \/\/ _LP64\n@@ -4165,1 +4110,0 @@\n-#ifdef _LP64\n@@ -4173,26 +4117,0 @@\n-#else\n-    Label k_init;\n-    jmp(k_init);\n-\n-    \/\/ We could not read 64-bits from a general purpose register thus we move\n-    \/\/ data required to compose 64 1's to the instruction stream\n-    \/\/ We emit 64 byte wide series of elements from 0..63 which later on would\n-    \/\/ be used as a compare targets with tail count contained in tmp1 register.\n-    \/\/ Result would be a k register having tmp1 consecutive number or 1\n-    \/\/ counting from least significant bit.\n-    address tmp = pc();\n-    emit_int64(0x0706050403020100);\n-    emit_int64(0x0F0E0D0C0B0A0908);\n-    emit_int64(0x1716151413121110);\n-    emit_int64(0x1F1E1D1C1B1A1918);\n-    emit_int64(0x2726252423222120);\n-    emit_int64(0x2F2E2D2C2B2A2928);\n-    emit_int64(0x3736353433323130);\n-    emit_int64(0x3F3E3D3C3B3A3938);\n-\n-    bind(k_init);\n-    lea(len, InternalAddress(tmp));\n-    \/\/ create mask to test for negative byte inside a vector\n-    evpbroadcastb(vec1, tmp1, Assembler::AVX_512bit);\n-    evpcmpgtb(mask2, vec1, Address(len, 0), Assembler::AVX_512bit);\n-#endif\n@@ -4446,1 +4364,0 @@\n-#ifdef _LP64\n@@ -4483,1 +4400,1 @@\n-#endif \/\/_LP64\n+\n@@ -4650,2 +4567,0 @@\n-#ifdef _LP64\n-\n@@ -4698,2 +4613,0 @@\n-#endif \/\/ _LP64\n-\n@@ -5359,1 +5272,0 @@\n-#ifdef _LP64\n@@ -5411,1 +5323,0 @@\n-#endif \/\/ _LP64\n@@ -5542,1 +5453,0 @@\n-#ifdef _LP64\n@@ -5800,1 +5710,0 @@\n-#endif\n@@ -5865,4 +5774,2 @@\n-  bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n-  if ((is_LP64 || lane_size < 8) &&\n-      ((is_non_subword_integral_type(bt) && VM_Version::supports_avx512vl()) ||\n-       (is_subword_type(bt) && VM_Version::supports_avx512vlbw()))) {\n+  if ((is_non_subword_integral_type(bt) && VM_Version::supports_avx512vl()) ||\n+      (is_subword_type(bt) && VM_Version::supports_avx512vlbw())) {\n@@ -5880,1 +5787,1 @@\n-    LP64_ONLY(movq(dst, rtmp)) NOT_LP64(movdl(dst, rtmp));\n+    movq(dst, rtmp);\n@@ -6015,8 +5922,0 @@\n-#ifndef _LP64\n-void C2_MacroAssembler::vector_maskall_operation32(KRegister dst, Register src, KRegister tmp, int mask_len) {\n-  assert(VM_Version::supports_avx512bw(), \"\");\n-  kmovdl(tmp, src);\n-  kunpckdql(dst, tmp, tmp);\n-}\n-#endif\n-\n@@ -6482,1 +6381,0 @@\n-#ifdef _LP64\n@@ -6646,1 +6544,0 @@\n-#endif\n@@ -6712,2 +6609,0 @@\n-    case Op_MaxHF: vmaxsh(dst, src1, src2); break;\n-    case Op_MinHF: vminsh(dst, src1, src2); break;\n@@ -7123,0 +7018,45 @@\n+\n+void C2_MacroAssembler::scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  if (opcode == Op_MaxHF) {\n+    \/\/ Move sign bits of src2 to mask register.\n+    evpmovw2m(ktmp, src2, vlen_enc);\n+    \/\/ xtmp1 = src2 < 0 ? src2 : src1\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    \/\/ xtmp2 = src2 < 0 ? ? src1 : src2\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    \/\/ Idea behind above swapping is to make seconds source operand a +ve value.\n+    \/\/ As per instruction semantic, if the values being compared are both 0.0s (of either sign), the value in\n+    \/\/ the second source operand is returned. If only one value is a NaN (SNaN or QNaN) for this instruction,\n+    \/\/ the second source operand, either a NaN or a valid floating-point value, is returned\n+    \/\/ dst = max(xtmp1, xtmp2)\n+    vmaxsh(dst, xtmp1, xtmp2);\n+    \/\/ isNaN = is_unordered_quiet(xtmp1)\n+    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n+    \/\/ Final result is same as first source if its a NaN value,\n+    \/\/ in case second operand holds a NaN value then as per above semantics\n+    \/\/ result is same as second operand.\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  } else {\n+    assert(opcode == Op_MinHF, \"\");\n+    \/\/ Move sign bits of src1 to mask register.\n+    evpmovw2m(ktmp, src1, vlen_enc);\n+    \/\/ xtmp1 = src1 < 0 ? src2 : src1\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    \/\/ xtmp2 = src1 < 0 ? src1 : src2\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    \/\/ Idea behind above swapping is to make seconds source operand a -ve value.\n+    \/\/ As per instruction semantics, if the values being compared are both 0.0s (of either sign), the value in\n+    \/\/ the second source operand is returned.\n+    \/\/ If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN\n+    \/\/ or a valid floating-point value, is written to the result.\n+    \/\/ dst = min(xtmp1, xtmp2)\n+    vminsh(dst, xtmp1, xtmp2);\n+    \/\/ isNaN = is_unordered_quiet(xtmp1)\n+    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n+    \/\/ Final result is same as first source if its a NaN value,\n+    \/\/ in case second operand holds a NaN value then as per above semantics\n+    \/\/ result is same as second operand.\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":54,"deletions":114,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -134,2 +134,0 @@\n-#ifdef _LP64\n-#endif\n@@ -156,1 +154,0 @@\n-#ifdef _LP64\n@@ -159,1 +156,0 @@\n-#endif \/\/ _LP64\n@@ -206,1 +202,0 @@\n-#ifdef _LP64\n@@ -210,1 +205,0 @@\n-#endif \/\/ _LP64\n@@ -241,1 +235,0 @@\n-#ifdef _LP64\n@@ -250,1 +243,0 @@\n-#endif\n@@ -254,4 +246,0 @@\n-#ifndef _LP64\n-  void vector_maskall_operation32(KRegister dst, Register src, KRegister ktmp, int mask_len);\n-#endif\n-\n@@ -317,2 +305,0 @@\n-#ifdef _LP64\n-#endif\n@@ -394,1 +380,0 @@\n-#ifdef _LP64\n@@ -407,1 +392,0 @@\n-#endif \/\/ _LP64\n@@ -413,1 +397,0 @@\n-#ifdef _LP64\n@@ -421,1 +404,0 @@\n-#endif\n@@ -515,1 +497,0 @@\n-#ifdef _LP64\n@@ -518,1 +499,1 @@\n-#endif\n+\n@@ -588,0 +569,2 @@\n+  void scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                           KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -301,1 +301,0 @@\n-                                             Register java_thread,\n@@ -324,1 +323,1 @@\n-  MacroAssembler::call_VM_base(oop_result, noreg, last_java_sp,\n+  MacroAssembler::call_VM_base(oop_result, last_java_sp,\n@@ -384,1 +383,1 @@\n-void InterpreterMacroAssembler::check_and_handle_popframe(Register java_thread) {\n+void InterpreterMacroAssembler::check_and_handle_popframe() {\n@@ -394,1 +393,1 @@\n-    movl(pop_cond, Address(java_thread, JavaThread::popframe_condition_offset()));\n+    movl(pop_cond, Address(r15_thread, JavaThread::popframe_condition_offset()));\n@@ -435,1 +434,1 @@\n-void InterpreterMacroAssembler::check_and_handle_earlyret(Register java_thread) {\n+void InterpreterMacroAssembler::check_and_handle_earlyret() {\n@@ -818,1 +817,1 @@\n-  safepoint_poll(slow_path, rthread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -822,1 +821,1 @@\n-  set_last_Java_frame(rthread, noreg, rbp, (address)pc(), rscratch1);\n+  set_last_Java_frame(noreg, rbp, (address)pc(), rscratch1);\n@@ -824,1 +823,1 @@\n-  reset_last_Java_frame(rthread, true);\n+  reset_last_Java_frame(true);\n@@ -1090,1 +1089,1 @@\n-  get_vm_result(obj, r15_thread);\n+  get_vm_result(obj);\n@@ -1131,2 +1130,1 @@\n-      const Register thread = r15_thread;\n-      lightweight_lock(lock_reg, obj_reg, swap_reg, thread, tmp_reg, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, swap_reg, tmp_reg, slow_case);\n@@ -1245,1 +1243,1 @@\n-      lightweight_unlock(obj_reg, swap_reg, r15_thread, header_reg, slow_case);\n+      lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-                            Register java_thread,\n@@ -61,2 +60,2 @@\n- virtual void check_and_handle_popframe(Register java_thread);\n- virtual void check_and_handle_earlyret(Register java_thread);\n+ virtual void check_and_handle_popframe();\n+ virtual void check_and_handle_earlyret();\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -734,11 +734,0 @@\n-void MacroAssembler::reset_last_Java_frame(bool clear_fp) {\n-  reset_last_Java_frame(r15_thread, clear_fp);\n-}\n-\n-void MacroAssembler::set_last_Java_frame(Register last_java_sp,\n-                                         Register last_java_fp,\n-                                         address  last_java_pc,\n-                                         Register rscratch) {\n-  set_last_Java_frame(r15_thread, last_java_sp, last_java_fp, last_java_pc, rscratch);\n-}\n-\n@@ -1497,2 +1486,1 @@\n-  Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);\n-  call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n@@ -1543,2 +1531,1 @@\n-  Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);\n-  MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n+  MacroAssembler::call_VM_base(oop_result, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n@@ -1585,1 +1572,0 @@\n-                                  Register java_thread,\n@@ -1590,9 +1576,2 @@\n-  \/\/ determine java_thread register\n-  if (!java_thread->is_valid()) {\n-#ifdef _LP64\n-    java_thread = r15_thread;\n-#else\n-    java_thread = rdi;\n-    get_thread(java_thread);\n-#endif \/\/ LP64\n-  }\n+  Register java_thread = r15_thread;\n+\n@@ -1605,1 +1584,0 @@\n-  LP64_ONLY(assert(java_thread == r15_thread, \"unexpected register\"));\n@@ -1609,1 +1587,1 @@\n-  LP64_ONLY(if (UseCompressedOops && !TraceBytecodes) verify_heapbase(\"call_VM_base: heap base corrupted?\");)\n+  if (UseCompressedOops && !TraceBytecodes) verify_heapbase(\"call_VM_base: heap base corrupted?\");\n@@ -1617,2 +1595,1 @@\n-  NOT_LP64(push(java_thread); number_of_arguments++);\n-  LP64_ONLY(mov(c_rarg0, r15_thread));\n+  mov(c_rarg0, r15_thread);\n@@ -1624,1 +1601,1 @@\n-  set_last_Java_frame(java_thread, last_java_sp, rbp, nullptr, rscratch1);\n+  set_last_Java_frame(last_java_sp, rbp, nullptr, rscratch1);\n@@ -1629,18 +1606,9 @@\n-  \/\/ restore the thread (cannot use the pushed argument since arguments\n-  \/\/ may be overwritten by C code generated by an optimizing compiler);\n-  \/\/ however can use the register value directly if it is callee saved.\n-  if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {\n-    \/\/ rdi & rsi (also r15) are callee saved -> nothing to do\n-    guarantee(java_thread != rax, \"change this code\");\n-    push(rax);\n-    { Label L;\n-      get_thread(rax);\n-      cmpptr(java_thread, rax);\n-      jcc(Assembler::equal, L);\n-      STOP(\"MacroAssembler::call_VM_base: rdi not callee saved?\");\n-      bind(L);\n-    }\n-    pop(rax);\n-#endif\n-  } else {\n-    get_thread(java_thread);\n+  \/\/ Check that thread register is not clobbered.\n+  guarantee(java_thread != rax, \"change this code\");\n+  push(rax);\n+  { Label L;\n+    get_thread_slow(rax);\n+    cmpptr(java_thread, rax);\n+    jcc(Assembler::equal, L);\n+    STOP(\"MacroAssembler::call_VM_base: java_thread not callee saved?\");\n+    bind(L);\n@@ -1649,0 +1617,3 @@\n+  pop(rax);\n+#endif\n+\n@@ -1651,1 +1622,1 @@\n-  reset_last_Java_frame(java_thread, true);\n+  reset_last_Java_frame(true);\n@@ -1654,2 +1625,2 @@\n-  check_and_handle_popframe(java_thread);\n-  check_and_handle_earlyret(java_thread);\n+  check_and_handle_popframe();\n+  check_and_handle_earlyret();\n@@ -1659,5 +1630,1 @@\n-    cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n-#ifndef _LP64\n-    jump_cc(Assembler::notEqual,\n-            RuntimeAddress(StubRoutines::forward_exception_entry()));\n-#else\n+    cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -1672,1 +1639,0 @@\n-#endif \/\/ LP64\n@@ -1677,1 +1643,1 @@\n-    get_vm_result(oop_result, java_thread);\n+    get_vm_result(oop_result);\n@@ -1682,0 +1648,4 @@\n+  \/\/ Calculate the value for last_Java_sp somewhat subtle.\n+  \/\/ call_VM does an intermediate call which places a return address on\n+  \/\/ the stack just under the stack pointer as the user finished with it.\n+  \/\/ This allows use to retrieve last_Java_pc from last_Java_sp[-1].\n@@ -1683,11 +1653,0 @@\n-  \/\/ Calculate the value for last_Java_sp\n-  \/\/ somewhat subtle. call_VM does an intermediate call\n-  \/\/ which places a return address on the stack just under the\n-  \/\/ stack pointer as the user finished with it. This allows\n-  \/\/ use to retrieve last_Java_pc from last_Java_sp[-1].\n-  \/\/ On 32bit we then have to push additional args on the stack to accomplish\n-  \/\/ the actual requested call. On 64bit call_VM only can use register args\n-  \/\/ so the only extra space is the return address that call_VM created.\n-  \/\/ This hopefully explains the calculations here.\n-\n-#ifdef _LP64\n@@ -1696,5 +1655,1 @@\n-#else\n-  lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));\n-#endif \/\/ LP64\n-\n-  call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, rax, entry_point, number_of_arguments, check_exceptions);\n@@ -1782,3 +1737,3 @@\n-void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {\n-  movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));\n-  movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);\n+void MacroAssembler::get_vm_result(Register oop_result) {\n+  movptr(oop_result, Address(r15_thread, JavaThread::vm_result_offset()));\n+  movptr(Address(r15_thread, JavaThread::vm_result_offset()), NULL_WORD);\n@@ -1788,3 +1743,3 @@\n-void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {\n-  movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));\n-  movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);\n+void MacroAssembler::get_vm_result_2(Register metadata_result) {\n+  movptr(metadata_result, Address(r15_thread, JavaThread::vm_result_2_offset()));\n+  movptr(Address(r15_thread, JavaThread::vm_result_2_offset()), NULL_WORD);\n@@ -1793,1 +1748,1 @@\n-void MacroAssembler::check_and_handle_earlyret(Register java_thread) {\n+void MacroAssembler::check_and_handle_earlyret() {\n@@ -1796,1 +1751,1 @@\n-void MacroAssembler::check_and_handle_popframe(Register java_thread) {\n+void MacroAssembler::check_and_handle_popframe() {\n@@ -3295,5 +3250,1 @@\n-void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { \/\/ determine java_thread register\n-  if (!java_thread->is_valid()) {\n-    java_thread = rdi;\n-    get_thread(java_thread);\n-  }\n+void MacroAssembler::reset_last_Java_frame(bool clear_fp) { \/\/ determine java_thread register\n@@ -3301,1 +3252,1 @@\n-  movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n+  movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n@@ -3305,1 +3256,1 @@\n-    movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);\n+    movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);\n@@ -3308,1 +3259,1 @@\n-  movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);\n+  movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);\n@@ -3327,1 +3278,1 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, Register thread_reg, bool at_return, bool in_nmethod) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod) {\n@@ -3331,1 +3282,1 @@\n-    cmpptr(in_nmethod ? rsp : rbp, Address(thread_reg, JavaThread::polling_word_offset()));\n+    cmpptr(in_nmethod ? rsp : rbp, Address(r15_thread, JavaThread::polling_word_offset()));\n@@ -3335,1 +3286,1 @@\n-  testb(Address(thread_reg, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n+  testb(Address(r15_thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n@@ -3344,2 +3295,1 @@\n-void MacroAssembler::set_last_Java_frame(Register java_thread,\n-                                         Register last_java_sp,\n+void MacroAssembler::set_last_Java_frame(Register last_java_sp,\n@@ -3350,5 +3300,0 @@\n-  \/\/ determine java_thread register\n-  if (!java_thread->is_valid()) {\n-    java_thread = rdi;\n-    get_thread(java_thread);\n-  }\n@@ -3361,1 +3306,1 @@\n-    movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);\n+    movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), last_java_fp);\n@@ -3365,1 +3310,1 @@\n-    Address java_pc(java_thread,\n+    Address java_pc(r15_thread,\n@@ -3369,1 +3314,1 @@\n-  movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);\n+  movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);\n@@ -3372,1 +3317,0 @@\n-#ifdef _LP64\n@@ -3379,1 +3323,1 @@\n-  set_last_Java_frame(r15_thread, last_java_sp, last_java_fp, nullptr, scratch);\n+  set_last_Java_frame(last_java_sp, last_java_fp, nullptr, scratch);\n@@ -3381,1 +3325,0 @@\n-#endif\n@@ -4236,1 +4179,1 @@\n-                                     Register thread,\n+  Register thread = r15_thread;\n@@ -4269,1 +4212,1 @@\n-                                            Register thread,\n+  Register thread = r15_thread;\n@@ -5748,1 +5691,1 @@\n-void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {\n+void MacroAssembler::clinit_barrier(Register klass, Label* L_fast_path, Label* L_slow_path) {\n@@ -5764,1 +5707,1 @@\n-  cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));\n+  cmpptr(r15_thread, Address(klass, InstanceKlass::init_thread_offset()));\n@@ -11490,1 +11433,1 @@\n-void MacroAssembler::get_thread(Register thread) {\n+void MacroAssembler::get_thread_slow(Register thread) {\n@@ -11494,2 +11437,2 @@\n-  LP64_ONLY(push(rdi);)\n-  LP64_ONLY(push(rsi);)\n+  push(rdi);\n+  push(rsi);\n@@ -11498,1 +11441,0 @@\n-#ifdef _LP64\n@@ -11503,1 +11445,0 @@\n-#endif\n@@ -11507,1 +11448,0 @@\n-#ifdef _LP64\n@@ -11512,1 +11452,0 @@\n-#endif\n@@ -11515,2 +11454,2 @@\n-  LP64_ONLY(pop(rsi);)\n-  LP64_ONLY(pop(rdi);)\n+  pop(rsi);\n+  pop(rdi);\n@@ -11545,1 +11484,3 @@\n-void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register tmp, Label& slow) {\n+  Register thread = r15_thread;\n+\n@@ -11603,1 +11544,3 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register reg_rax, Register tmp, Label& slow) {\n+  Register thread = r15_thread;\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":64,"deletions":121,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -65,4 +65,2 @@\n-  \/\/ If no java_thread register is specified (noreg) than rdi will be used instead. call_VM_base\n-  \/\/ returns the register which contains the thread upon return. If a thread register has been\n-  \/\/ specified, the return value will correspond to that register. If no last_java_sp is specified\n-  \/\/ (noreg) than rsp will be used instead.\n+  \/\/ call_VM_base returns the register which contains the thread upon return.\n+  \/\/ If no last_java_sp is specified (noreg) than rsp will be used instead.\n@@ -71,1 +69,0 @@\n-    Register java_thread,              \/\/ the thread if computed before     ; use noreg otherwise\n@@ -91,2 +88,2 @@\n- virtual void check_and_handle_popframe(Register java_thread);\n- virtual void check_and_handle_earlyret(Register java_thread);\n+ virtual void check_and_handle_popframe();\n+ virtual void check_and_handle_earlyret();\n@@ -253,3 +250,4 @@\n-  \/\/ Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)\n-  \/\/ The pointer will be loaded into the thread register.\n-  void get_thread(Register thread);\n+  \/\/ Support for getting the JavaThread pointer (i.e.; a reference to thread-local information).\n+  \/\/ The pointer will be loaded into the thread register. This is a slow version that does native call.\n+  \/\/ Normally, JavaThread pointer is available in r15_thread, use that where possible.\n+  void get_thread_slow(Register thread);\n@@ -320,2 +318,2 @@\n-  void get_vm_result  (Register oop_result, Register thread);\n-  void get_vm_result_2(Register metadata_result, Register thread);\n+  void get_vm_result  (Register oop_result);\n+  void get_vm_result_2(Register metadata_result);\n@@ -352,8 +350,0 @@\n-  \/\/ last Java Frame (fills frame anchor)\n-  void set_last_Java_frame(Register thread,\n-                           Register last_java_sp,\n-                           Register last_java_fp,\n-                           address  last_java_pc,\n-                           Register rscratch);\n-\n-  \/\/ thread in the default location (r15_thread on 64bit)\n@@ -365,1 +355,0 @@\n-#ifdef _LP64\n@@ -370,4 +359,0 @@\n-#endif\n-\n-  void reset_last_Java_frame(Register thread, bool clear_fp);\n-  \/\/ thread in the default location (r15_thread on 64bit)\n@@ -379,2 +364,2 @@\n-  void resolve_jobject(Register value, Register thread, Register tmp);\n-  void resolve_global_jobject(Register value, Register thread, Register tmp);\n+  void resolve_jobject(Register value, Register tmp);\n+  void resolve_global_jobject(Register value, Register tmp);\n@@ -819,1 +804,0 @@\n-                      Register thread,\n@@ -894,1 +878,1 @@\n-  void safepoint_poll(Label& slow_path, Register thread_reg, bool at_return, bool in_nmethod);\n+  void safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod);\n@@ -2320,2 +2304,2 @@\n-  void lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n-  void lightweight_unlock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register tmp, Label& slow);\n+  void lightweight_unlock(Register obj, Register reg_rax, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":15,"deletions":31,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -890,1 +890,1 @@\n-    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+    __ clinit_barrier(klass, &L_skip_barrier \/*L_fast_path*\/);\n@@ -947,2 +947,2 @@\n-      __ get_vm_result(rscratch2, r15_thread); \/\/ Use rscratch2 (r11) as temporary because rscratch1 (r10) is trashed by movptr()\n-      __ get_vm_result_2(rbx, r15_thread); \/\/ TODO: required to keep the callee Method live?\n+      __ get_vm_result(rscratch2); \/\/ Use rscratch2 (r11) as temporary because rscratch1 (r10) is trashed by movptr()\n+      __ get_vm_result_2(rbx); \/\/ TODO: required to keep the callee Method live?\n@@ -2276,1 +2276,1 @@\n-    __ clinit_barrier(klass, r15_thread, &L_skip_barrier \/*L_fast_path*\/);\n+    __ clinit_barrier(klass, &L_skip_barrier \/*L_fast_path*\/);\n@@ -2557,1 +2557,1 @@\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, rscratch1, slow_path_lock);\n@@ -2617,1 +2617,1 @@\n-    __ safepoint_poll(slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -2708,1 +2708,1 @@\n-      __ lightweight_unlock(obj_reg, swap_reg, r15_thread, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n@@ -2733,1 +2733,0 @@\n-                       r15_thread \/* thread *\/,\n@@ -3511,1 +3510,1 @@\n-  __ get_vm_result_2(rbx, r15_thread);\n+  __ get_vm_result_2(rbx);\n@@ -3925,1 +3924,0 @@\n-                     r15_thread \/* thread *\/,\n@@ -4052,1 +4050,1 @@\n-  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n+  __ resolve_global_jobject(rax, c_rarg0);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-    __ get_thread(rbx);\n+    __ get_thread_slow(rbx);\n@@ -445,1 +445,1 @@\n-    __ get_thread(rbx);\n+    __ get_thread_slow(rbx);\n@@ -1332,1 +1332,1 @@\n-  __ get_thread(r15_thread);\n+  __ get_thread_slow(r15_thread);\n@@ -1356,1 +1356,1 @@\n-  __ get_thread(r15_thread);\n+  __ get_thread_slow(r15_thread);\n@@ -3993,1 +3993,1 @@\n-  __ resolve_global_jobject(j_rarg0, r15_thread, rscratch1);\n+  __ resolve_global_jobject(j_rarg0, rscratch1);\n@@ -4272,1 +4272,1 @@\n-    __ get_vm_result(rax, r15_thread);\n+    __ get_vm_result(rax);\n@@ -4377,0 +4377,2 @@\n+  generate_dilithium_stubs();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -492,1 +492,2 @@\n-  address generate_sha3_implCompress(StubGenStubId stub_id);\n+  \/\/ Dilithium stubs and helper functions\n+  void generate_dilithium_stubs();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2479,1 +2479,1 @@\n-    __ get_thread(r14);\n+    __ get_thread_slow(r14);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-     __ check_and_handle_popframe(r15_thread);\n+     __ check_and_handle_popframe();\n@@ -215,1 +215,1 @@\n-     __ check_and_handle_earlyret(r15_thread);\n+     __ check_and_handle_earlyret();\n@@ -999,1 +999,1 @@\n-    __ safepoint_poll(slow_path, thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1042,1 +1042,1 @@\n-  __ reset_last_Java_frame(thread, true);\n+  __ reset_last_Java_frame(true);\n@@ -1065,1 +1065,0 @@\n-                       thread \/* thread *\/,\n@@ -1503,1 +1502,1 @@\n-  __ reset_last_Java_frame(thread, true);\n+  __ reset_last_Java_frame(true);\n@@ -1556,1 +1555,1 @@\n-  __ get_vm_result(rax, thread);\n+  __ get_vm_result(rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-  __ get_vm_result_2(flags, r15_thread);\n+  __ get_vm_result_2(flags);\n@@ -2373,2 +2373,0 @@\n-    const Register thread = r15_thread;\n-    assert(thread != noreg, \"x86_32 not supported\");\n@@ -2378,1 +2376,1 @@\n-    __ clinit_barrier(klass, thread, nullptr \/*L_fast_path*\/, &L_clinit_barrier_slow);\n+    __ clinit_barrier(klass, nullptr \/*L_fast_path*\/, &L_clinit_barrier_slow);\n@@ -2762,1 +2760,1 @@\n-        __ get_vm_result(rax, r15_thread);\n+        __ get_vm_result(rax);\n@@ -3411,1 +3409,1 @@\n-        __ get_vm_result(rax, r15_thread);\n+        __ get_vm_result(rax);\n@@ -3857,1 +3855,1 @@\n-  __ clinit_barrier(rcx, r15_thread, nullptr \/*L_fast_path*\/, &slow_case);\n+  __ clinit_barrier(rcx, nullptr \/*L_fast_path*\/, &slow_case);\n@@ -3921,1 +3919,1 @@\n-  __ get_vm_result_2(rax, r15_thread);\n+  __ get_vm_result_2(rax);\n@@ -3976,2 +3974,2 @@\n-  \/\/ vm_result_2 has metadata result\n-  __ get_vm_result_2(rax, r15_thread);\n+  \/\/ vm_result_2 has metadata result\n+  __ get_vm_result_2(rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1249,0 +1249,14 @@\n+  \/\/ Dilithium Intrinsics\n+  \/\/ Currently we only have them for AVX512\n+#ifdef _LP64\n+  if (supports_evex() && supports_avx512bw()) {\n+      if (FLAG_IS_DEFAULT(UseDilithiumIntrinsics)) {\n+          UseDilithiumIntrinsics = true;\n+      }\n+  } else\n+#endif\n+   if (UseDilithiumIntrinsics) {\n+      warning(\"Intrinsics for ML-DSA are not available on this CPU.\");\n+      FLAG_SET_DEFAULT(UseDilithiumIntrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -213,2 +213,0 @@\n-#ifdef _LP64\n-\n@@ -623,6 +621,0 @@\n-#endif \/\/ _LP64\n-\n-#ifdef _LP64\n-#else\n-reg_def RFLAGS(SOC, SOC, 0, 8, VMRegImpl::Bad());\n-#endif \/\/ _LP64\n@@ -661,3 +653,2 @@\n-                   XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,  XMM7i,  XMM7j,  XMM7k,  XMM7l,  XMM7m,  XMM7n,  XMM7o,  XMM7p\n-#ifdef _LP64\n-                  ,XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,  XMM8i,  XMM8j,  XMM8k,  XMM8l,  XMM8m,  XMM8n,  XMM8o,  XMM8p,\n+                   XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,  XMM7i,  XMM7j,  XMM7k,  XMM7l,  XMM7m,  XMM7n,  XMM7o,  XMM7p,\n+                   XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,  XMM8i,  XMM8j,  XMM8k,  XMM8l,  XMM8m,  XMM8n,  XMM8o,  XMM8p,\n@@ -670,2 +661,2 @@\n-                   XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p\n-                  ,XMM16, XMM16b, XMM16c, XMM16d, XMM16e, XMM16f, XMM16g, XMM16h, XMM16i, XMM16j, XMM16k, XMM16l, XMM16m, XMM16n, XMM16o, XMM16p,\n+                   XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p,\n+                   XMM16, XMM16b, XMM16c, XMM16d, XMM16e, XMM16f, XMM16g, XMM16h, XMM16i, XMM16j, XMM16k, XMM16l, XMM16m, XMM16n, XMM16o, XMM16p,\n@@ -686,3 +677,1 @@\n-                   XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h, XMM31i, XMM31j, XMM31k, XMM31l, XMM31m, XMM31n, XMM31o, XMM31p\n-#endif\n-                      );\n+                   XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h, XMM31i, XMM31j, XMM31k, XMM31l, XMM31m, XMM31n, XMM31o, XMM31p);\n@@ -729,3 +718,2 @@\n-                    XMM7\n-#ifdef _LP64\n-                   ,XMM8,\n+                    XMM7,\n+                    XMM8,\n@@ -738,3 +726,1 @@\n-                    XMM15\n-#endif\n-                    );\n+                    XMM15);\n@@ -750,3 +736,2 @@\n-                    XMM7\n-#ifdef _LP64\n-                   ,XMM8,\n+                    XMM7,\n+                    XMM8,\n@@ -775,3 +760,1 @@\n-                    XMM31\n-#endif\n-                    );\n+                    XMM31);\n@@ -790,3 +773,2 @@\n-                     XMM7,  XMM7b\n-#ifdef _LP64\n-                    ,XMM8,  XMM8b,\n+                     XMM7,  XMM7b,\n+                     XMM8,  XMM8b,\n@@ -799,3 +781,1 @@\n-                     XMM15, XMM15b\n-#endif\n-                     );\n+                     XMM15, XMM15b);\n@@ -811,3 +791,2 @@\n-                     XMM7,  XMM7b\n-#ifdef _LP64\n-                    ,XMM8,  XMM8b,\n+                     XMM7,  XMM7b,\n+                     XMM8,  XMM8b,\n@@ -836,3 +815,1 @@\n-                     XMM31, XMM31b\n-#endif\n-                     );\n+                     XMM31, XMM31b);\n@@ -851,3 +828,2 @@\n-                      XMM7\n-#ifdef _LP64\n-                     ,XMM8,\n+                      XMM7,\n+                      XMM8,\n@@ -860,3 +836,1 @@\n-                      XMM15\n-#endif\n-                      );\n+                      XMM15);\n@@ -872,3 +846,2 @@\n-                      XMM7\n-#ifdef _LP64\n-                     ,XMM8,\n+                      XMM7,\n+                      XMM8,\n@@ -897,3 +870,1 @@\n-                      XMM31\n-#endif\n-                      );\n+                      XMM31);\n@@ -912,3 +883,2 @@\n-                      XMM7,  XMM7b\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,\n+                      XMM7,  XMM7b,\n+                      XMM8,  XMM8b,\n@@ -921,3 +891,1 @@\n-                      XMM15, XMM15b\n-#endif\n-                      );\n+                      XMM15, XMM15b);\n@@ -933,3 +901,2 @@\n-                      XMM7,  XMM7b\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,\n+                      XMM7,  XMM7b,\n+                      XMM8,  XMM8b,\n@@ -958,3 +925,1 @@\n-                      XMM31, XMM31b\n-#endif\n-                      );\n+                      XMM31, XMM31b);\n@@ -973,3 +938,2 @@\n-                      XMM7,  XMM7b,  XMM7c,  XMM7d\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,  XMM8c,  XMM8d,\n+                      XMM7,  XMM7b,  XMM7c,  XMM7d,\n+                      XMM8,  XMM8b,  XMM8c,  XMM8d,\n@@ -982,3 +946,1 @@\n-                      XMM15, XMM15b, XMM15c, XMM15d\n-#endif\n-                      );\n+                      XMM15, XMM15b, XMM15c, XMM15d);\n@@ -994,3 +956,2 @@\n-                      XMM7,  XMM7b,  XMM7c,  XMM7d\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,  XMM8c,  XMM8d,\n+                      XMM7,  XMM7b,  XMM7c,  XMM7d,\n+                      XMM8,  XMM8b,  XMM8c,  XMM8d,\n@@ -1019,3 +980,1 @@\n-                      XMM31, XMM31b, XMM31c, XMM31d\n-#endif\n-                      );\n+                      XMM31, XMM31b, XMM31c, XMM31d);\n@@ -1034,3 +993,2 @@\n-                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,\n+                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,\n+                      XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,\n@@ -1043,3 +1001,1 @@\n-                      XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h\n-#endif\n-                      );\n+                      XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h);\n@@ -1055,3 +1011,2 @@\n-                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,\n+                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,\n+                      XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,\n@@ -1080,3 +1035,1 @@\n-                      XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h\n-#endif\n-                      );\n+                      XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h);\n@@ -1095,3 +1048,2 @@\n-                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,  XMM7i,  XMM7j,  XMM7k,  XMM7l,  XMM7m,  XMM7n,  XMM7o,  XMM7p\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,  XMM8i,  XMM8j,  XMM8k,  XMM8l,  XMM8m,  XMM8n,  XMM8o,  XMM8p,\n+                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,  XMM7i,  XMM7j,  XMM7k,  XMM7l,  XMM7m,  XMM7n,  XMM7o,  XMM7p,\n+                      XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,  XMM8i,  XMM8j,  XMM8k,  XMM8l,  XMM8m,  XMM8n,  XMM8o,  XMM8p,\n@@ -1104,2 +1056,2 @@\n-                      XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p\n-                     ,XMM16, XMM16b, XMM16c, XMM16d, XMM16e, XMM16f, XMM16g, XMM16h, XMM16i, XMM16j, XMM16k, XMM16l, XMM16m, XMM16n, XMM16o, XMM16p,\n+                      XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p,\n+                      XMM16, XMM16b, XMM16c, XMM16d, XMM16e, XMM16f, XMM16g, XMM16h, XMM16i, XMM16j, XMM16k, XMM16l, XMM16m, XMM16n, XMM16o, XMM16p,\n@@ -1120,3 +1072,1 @@\n-                      XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h, XMM31i, XMM31j, XMM31k, XMM31l, XMM31m, XMM31n, XMM31o, XMM31p\n-#endif\n-                      );\n+                      XMM31, XMM31b, XMM31c, XMM31d, XMM31e, XMM31f, XMM31g, XMM31h, XMM31i, XMM31j, XMM31k, XMM31l, XMM31m, XMM31n, XMM31o, XMM31p);\n@@ -1132,3 +1082,2 @@\n-                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,  XMM7i,  XMM7j,  XMM7k,  XMM7l,  XMM7m,  XMM7n,  XMM7o,  XMM7p\n-#ifdef _LP64\n-                     ,XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,  XMM8i,  XMM8j,  XMM8k,  XMM8l,  XMM8m,  XMM8n,  XMM8o,  XMM8p,\n+                      XMM7,  XMM7b,  XMM7c,  XMM7d,  XMM7e,  XMM7f,  XMM7g,  XMM7h,  XMM7i,  XMM7j,  XMM7k,  XMM7l,  XMM7m,  XMM7n,  XMM7o,  XMM7p,\n+                      XMM8,  XMM8b,  XMM8c,  XMM8d,  XMM8e,  XMM8f,  XMM8g,  XMM8h,  XMM8i,  XMM8j,  XMM8k,  XMM8l,  XMM8m,  XMM8n,  XMM8o,  XMM8p,\n@@ -1141,3 +1090,1 @@\n-                      XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p\n-#endif\n-                      );\n+                      XMM15, XMM15b, XMM15c, XMM15d, XMM15e, XMM15f, XMM15g, XMM15h, XMM15i, XMM15j, XMM15k, XMM15l, XMM15m, XMM15n, XMM15o, XMM15p);\n@@ -1202,1 +1149,0 @@\n-#ifdef _LP64\n@@ -1207,10 +1153,0 @@\n-#else\n-  static uint size_deopt_handler() {\n-    \/\/ NativeCall instruction size is the same as NativeJump.\n-    \/\/ exception handler starts out as jump and can be patched to\n-    \/\/ a call be deoptimization.  (4932387)\n-    \/\/ Note that this value is also credited (in output.cpp) to\n-    \/\/ the size of the code section.\n-    return 5 + NativeJump::instruction_size; \/\/ pushl(); jmp;\n-  }\n-#endif\n@@ -1337,1 +1273,0 @@\n-#ifdef _LP64\n@@ -1348,4 +1283,0 @@\n-#else\n-  InternalAddress here(__ pc());\n-  __ pushptr(here.addr(), noreg);\n-#endif\n@@ -1375,1 +1306,0 @@\n-#ifdef _LP64\n@@ -1380,6 +1310,0 @@\n-#else\n-  static address float_signmask()  { return (address)float_signmask_pool; }\n-  static address float_signflip()  { return (address)float_signflip_pool; }\n-  static address double_signmask() { return (address)double_signmask_pool; }\n-  static address double_signflip() { return (address)double_signflip_pool; }\n-#endif\n@@ -1407,1 +1331,0 @@\n-  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n@@ -1464,0 +1387,5 @@\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      if (!VM_Version::supports_avx512vlbw()) {\n+        return false;\n+      }  \/\/ fallthrough\n@@ -1467,2 +1395,0 @@\n-    case Op_MaxHF:\n-    case Op_MinHF:\n@@ -1509,1 +1435,1 @@\n-      if (!is_LP64 || (UseAVX < 2)) {\n+      if (UseAVX < 2) {\n@@ -1524,2 +1450,0 @@\n-#ifdef _LP64\n-#endif\n@@ -1555,1 +1479,0 @@\n-#ifdef _LP64\n@@ -1564,1 +1487,0 @@\n-#endif\n@@ -1607,1 +1529,1 @@\n-      if (!is_LP64  || UseAVX < 3 || !VM_Version::supports_bmi2()) {\n+      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n@@ -1615,1 +1537,1 @@\n-      if (!is_LP64 || UseAVX < 1) {\n+      if (UseAVX < 1) {\n@@ -1621,3 +1543,0 @@\n-      if (!is_LP64) {\n-        return false;\n-      }\n@@ -1627,1 +1546,1 @@\n-      if (UseAVX < 3 || !is_LP64)  {\n+      if (UseAVX < 3)  {\n@@ -1634,23 +1553,1 @@\n-#ifndef _LP64\n-    case Op_AddReductionVF:\n-    case Op_AddReductionVD:\n-    case Op_MulReductionVF:\n-    case Op_MulReductionVD:\n-      if (UseSSE < 1) { \/\/ requires at least SSE\n-        return false;\n-      }\n-      break;\n-    case Op_MulAddVS2VI:\n-    case Op_RShiftVL:\n-    case Op_AbsVD:\n-    case Op_NegVD:\n-      if (UseSSE < 2) {\n-        return false;\n-      }\n-      break;\n-#endif \/\/ !LP64\n-      if (!VM_Version::supports_bmi2() || (!is_LP64 && UseSSE < 2)) {\n-        return false;\n-      }\n-      break;\n-      if (!VM_Version::supports_bmi2() || (!is_LP64 && (UseSSE < 2 || !VM_Version::supports_bmi1()))) {\n+      if (!VM_Version::supports_bmi2()) {\n@@ -1683,1 +1580,0 @@\n-#ifdef _LP64\n@@ -1687,4 +1583,0 @@\n-#else\n-      \/\/ x86_32.ad has a special match rule for SqrtD.\n-      \/\/ Together with common x86 rules, this handles all UseSSE cases.\n-#endif\n@@ -1722,1 +1614,0 @@\n-  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n@@ -1769,1 +1660,1 @@\n-      if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n+      if (!VM_Version::supports_avx512bw()) {\n@@ -1819,12 +1710,0 @@\n-#ifndef _LP64\n-      if (bt == T_BYTE || bt == T_LONG) {\n-        return false;\n-      }\n-#endif\n-#ifndef _LP64\n-    case Op_VectorInsert:\n-      if (bt == T_LONG || bt == T_DOUBLE) {\n-        return false;\n-      }\n-      break;\n-#endif\n@@ -1846,5 +1725,0 @@\n-#ifndef _LP64\n-      if (bt == T_BYTE || bt == T_LONG) {\n-        return false;\n-      }\n-#endif\n@@ -1935,4 +1809,3 @@\n-         (!is_LP64                                                ||\n-         (size_in_bits > 256 && !VM_Version::supports_avx512bw()) ||\n-         (size_in_bits < 64)                                      ||\n-         (bt == T_SHORT && !VM_Version::supports_bmi2()))) {\n+         ((size_in_bits > 256 && !VM_Version::supports_avx512bw()) ||\n+          (size_in_bits < 64)                                      ||\n+          (bt == T_SHORT && !VM_Version::supports_bmi2()))) {\n@@ -2007,3 +1880,0 @@\n-      if (!is_LP64 && !VM_Version::supports_avx512vl() && size_in_bits < 512) {\n-        return false;\n-      }\n@@ -2014,1 +1884,1 @@\n-      if (UseAVX < 1 || !is_LP64) {\n+      if (UseAVX < 1) {\n@@ -2062,1 +1932,0 @@\n-  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n@@ -2398,1 +2267,0 @@\n-#ifdef _LP64\n@@ -2408,2 +2276,1 @@\n-    } else\n-#endif\n+    } else {\n@@ -2411,0 +2278,1 @@\n+    }\n@@ -2548,1 +2416,1 @@\n-        LP64_ONLY( off->get_long() == (int) (off->get_long()) && ) \/\/ immL32\n+        off->get_long() == (int) (off->get_long()) && \/\/ immL32\n@@ -2622,3 +2490,0 @@\n-#ifndef _LP64\n-      __ movdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));\n-#else\n@@ -2630,1 +2495,0 @@\n-#endif\n@@ -2633,3 +2497,0 @@\n-#ifndef _LP64\n-      __ vmovdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));\n-#else\n@@ -2641,1 +2502,0 @@\n-#endif\n@@ -2680,3 +2540,0 @@\n-#ifndef _LP64\n-        __ movdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n-#else\n@@ -2689,1 +2546,0 @@\n-#endif\n@@ -2692,3 +2548,0 @@\n-#ifndef _LP64\n-        __ vmovdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n-#else\n@@ -2701,1 +2554,0 @@\n-#endif\n@@ -2718,3 +2570,0 @@\n-#ifndef _LP64\n-        __ movdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n-#else\n@@ -2727,1 +2576,0 @@\n-#endif\n@@ -2730,3 +2578,0 @@\n-#ifndef _LP64\n-        __ vmovdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n-#else\n@@ -2739,1 +2584,0 @@\n-#endif\n@@ -3066,1 +2910,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n@@ -4003,1 +3848,0 @@\n-#ifdef _LP64\n@@ -4074,1 +3918,0 @@\n-#endif \/\/ _LP64\n@@ -4292,1 +4135,0 @@\n-#ifdef _LP64\n@@ -4455,1 +4297,0 @@\n-#endif\n@@ -4571,1 +4412,0 @@\n-#ifdef _LP64\n@@ -4598,1 +4438,0 @@\n-#endif\n@@ -4695,1 +4534,0 @@\n-#ifdef _LP64\n@@ -4716,55 +4554,0 @@\n-#else \/\/ _LP64\n-\/\/ Replicate long (8 byte) scalar to be vector\n-instruct ReplL_reg(vec dst, eRegL src, vec tmp) %{\n-  predicate(Matcher::vector_length(n) <= 4 && Matcher::vector_element_basic_type(n) == T_LONG);\n-  match(Set dst (Replicate src));\n-  effect(TEMP dst, USE src, TEMP tmp);\n-  format %{ \"replicateL $dst,$src\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));\n-      __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else if (VM_Version::supports_avx512vl()) { \/\/ AVX512VL for <512bit operands\n-      int vlen_enc = Assembler::AVX_256bit;\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));\n-      __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);\n-      __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    } else {\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));\n-      __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-      __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct ReplL_reg_leg(legVec dst, eRegL src, legVec tmp) %{\n-  predicate(Matcher::vector_length(n) == 8 && Matcher::vector_element_basic_type(n) == T_LONG);\n-  match(Set dst (Replicate src));\n-  effect(TEMP dst, USE src, TEMP tmp);\n-  format %{ \"replicateL $dst,$src\" %}\n-  ins_encode %{\n-    if (VM_Version::supports_avx512vl()) {\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));\n-      __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-      __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-      __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);\n-    } else {\n-      int vlen_enc = Assembler::AVX_512bit;\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));\n-      __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);\n-      __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-#endif \/\/ _LP64\n@@ -5044,1 +4827,0 @@\n-#ifdef _LP64\n@@ -5095,1 +4877,0 @@\n-#endif\n@@ -5141,1 +4922,0 @@\n-#ifdef _LP64\n@@ -5196,1 +4976,0 @@\n-#endif\n@@ -5223,1 +5002,0 @@\n-#ifdef _LP64\n@@ -5261,1 +5039,0 @@\n-#endif \/\/ _LP64\n@@ -5473,1 +5250,0 @@\n-#ifdef _LP64\n@@ -5509,1 +5285,0 @@\n-#endif\n@@ -6810,1 +6585,0 @@\n-#ifdef _LP64\n@@ -6836,2 +6610,0 @@\n-#endif \/\/ _LP64\n-\n@@ -8010,1 +7782,0 @@\n-#ifdef _LP64\n@@ -8060,2 +7831,0 @@\n-#endif \/\/ _LP64\n-\n@@ -8271,2 +8040,0 @@\n-#ifdef _LP64\n-#endif\n@@ -8289,2 +8056,0 @@\n-#ifdef _LP64\n-#endif\n@@ -8304,1 +8069,0 @@\n-#ifdef _LP64\n@@ -8332,1 +8096,0 @@\n-#endif\n@@ -8597,1 +8360,0 @@\n-#ifdef _LP64\n@@ -8665,1 +8427,0 @@\n-#endif\n@@ -8916,1 +8677,0 @@\n-#ifdef _LP64\n@@ -8948,1 +8708,1 @@\n-#endif\n+\n@@ -9529,1 +9289,0 @@\n-#ifdef _LP64\n@@ -9743,1 +9502,0 @@\n-#ifdef _LP64\n@@ -9759,1 +9517,0 @@\n-#endif\n@@ -9787,2 +9544,0 @@\n-#endif \/\/ _LP64\n-\n@@ -10509,1 +10264,0 @@\n-#ifdef _LP64\n@@ -10574,1 +10328,0 @@\n-#endif\n@@ -10971,2 +10724,0 @@\n-  match(Set dst (MaxHF src1 src2));\n-  match(Set dst (MinHF src1 src2));\n@@ -10983,0 +10734,14 @@\n+instruct scalar_minmax_HF_reg(regF dst, regF src1, regF src2, kReg ktmp, regF xtmp1, regF xtmp2)\n+%{\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  effect(TEMP_DEF dst, TEMP ktmp, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"scalar_min_max_fp16 $dst, $src1, $src2\\t using $ktmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ scalar_max_min_fp16(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $ktmp$$KRegister,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":84,"deletions":319,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-    __ safepoint_poll(*code_stub, r15_thread, true \/* at_return *\/, true \/* in_nmethod *\/);\n+    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,3 +63,4 @@\n-char* CDSConfig::_default_archive_path = nullptr;\n-char* CDSConfig::_static_archive_path = nullptr;\n-char* CDSConfig::_dynamic_archive_path = nullptr;\n+const char* CDSConfig::_default_archive_path = nullptr;\n+const char* CDSConfig::_input_static_archive_path = nullptr;\n+const char* CDSConfig::_input_dynamic_archive_path = nullptr;\n+const char* CDSConfig::_output_archive_path = nullptr;\n@@ -78,1 +79,5 @@\n-void CDSConfig::initialize() {\n+DEBUG_ONLY(static bool _cds_ergo_initialize_started = false);\n+\n+void CDSConfig::ergo_initialize() {\n+  DEBUG_ONLY(_cds_ergo_initialize_started = true);\n+\n@@ -95,3 +100,5 @@\n-  \/\/\n-  \/\/ UseSharedSpaces may be disabled if -XX:SharedArchiveFile is invalid.\n-    init_shared_archive_paths();\n+    if (new_aot_flags_used()) {\n+      ergo_init_aot_paths();\n+    } else {\n+      ergo_init_classic_archive_paths();\n+    }\n@@ -106,1 +113,4 @@\n-char* CDSConfig::default_archive_path() {\n+const char* CDSConfig::default_archive_path() {\n+  \/\/ The path depends on UseCompressedOops, etc, which are set by GC ergonomics just\n+  \/\/ before CDSConfig::ergo_initialize() is called.\n+  assert(_cds_ergo_initialize_started, \"sanity\");\n@@ -131,2 +141,2 @@\n-int CDSConfig::num_archives(const char* archive_path) {\n-  if (archive_path == nullptr) {\n+int CDSConfig::num_archive_paths(const char* path_spec) {\n+  if (path_spec == nullptr) {\n@@ -136,1 +146,1 @@\n-  char* p = (char*)archive_path;\n+  char* p = (char*)path_spec;\n@@ -146,3 +156,3 @@\n-void CDSConfig::extract_shared_archive_paths(const char* archive_path,\n-                                             char** base_archive_path,\n-                                             char** top_archive_path) {\n+void CDSConfig::extract_archive_paths(const char* archive_path,\n+                                      const char** base_archive_path,\n+                                      const char** top_archive_path) {\n@@ -172,1 +182,2 @@\n-void CDSConfig::init_shared_archive_paths() {\n+void CDSConfig::ergo_init_classic_archive_paths() {\n+  assert(_cds_ergo_initialize_started, \"sanity\");\n@@ -187,1 +198,4 @@\n-    _static_archive_path = default_archive_path();\n+    _input_static_archive_path = default_archive_path();\n+    if (is_dumping_static_archive()) {\n+      _output_archive_path = _input_static_archive_path;\n+    }\n@@ -189,2 +203,2 @@\n-    int archives = num_archives(SharedArchiveFile);\n-    assert(archives > 0, \"must be\");\n+    int num_archives = num_archive_paths(SharedArchiveFile);\n+    assert(num_archives > 0, \"must be\");\n@@ -192,1 +206,1 @@\n-    if (is_dumping_archive() && archives > 1) {\n+    if (is_dumping_archive() && num_archives > 1) {\n@@ -198,1 +212,1 @@\n-      assert(archives == 1, \"must be\");\n+      assert(num_archives == 1, \"just checked above\");\n@@ -200,2 +214,2 @@\n-      \/\/ will be overwritten no matter regardless of its contents\n-      _static_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+      \/\/ will be overwritten regardless of its contents\n+      _output_archive_path = SharedArchiveFile;\n@@ -212,1 +226,1 @@\n-      if (archives > 2) {\n+      if (num_archives > 2) {\n@@ -216,2 +230,3 @@\n-      if (archives == 1) {\n-        char* base_archive_path = nullptr;\n+\n+      if (num_archives == 1) {\n+        const char* base_archive_path = nullptr;\n@@ -224,5 +239,5 @@\n-            enable_dumping_dynamic_archive();\n-            ArchiveClassesAtExit = const_cast<char *>(SharedArchiveFile);\n-            _static_archive_path = default_archive_path();\n-            SharedArchiveFile = nullptr;\n-          } else {\n+            enable_dumping_dynamic_archive(SharedArchiveFile);\n+            FLAG_SET_ERGO(ArchiveClassesAtExit, SharedArchiveFile);\n+            _input_static_archive_path = default_archive_path();\n+            FLAG_SET_ERGO(SharedArchiveFile, nullptr);\n+         } else {\n@@ -233,1 +248,1 @@\n-            log_error(cds)(\"Not a valid %s (%s)\", new_aot_flags_used() ? \"AOT cache\" : \"archive\", SharedArchiveFile);\n+            log_error(cds)(\"Not a valid archive (%s)\", SharedArchiveFile);\n@@ -238,1 +253,1 @@\n-          _static_archive_path = const_cast<char *>(SharedArchiveFile);\n+          _input_static_archive_path = SharedArchiveFile;\n@@ -241,2 +256,2 @@\n-          _dynamic_archive_path = const_cast<char *>(SharedArchiveFile);\n-          _static_archive_path = base_archive_path; \/\/ has been c-heap allocated.\n+          _input_dynamic_archive_path = SharedArchiveFile;\n+          _input_static_archive_path = base_archive_path; \/\/ has been c-heap allocated.\n@@ -245,4 +260,4 @@\n-        extract_shared_archive_paths((const char*)SharedArchiveFile,\n-                                      &_static_archive_path, &_dynamic_archive_path);\n-        if (_static_archive_path == nullptr) {\n-          assert(_dynamic_archive_path == nullptr, \"must be\");\n+        extract_archive_paths(SharedArchiveFile,\n+                              &_input_static_archive_path, &_input_dynamic_archive_path);\n+        if (_input_static_archive_path == nullptr) {\n+          assert(_input_dynamic_archive_path == nullptr, \"must be\");\n@@ -253,1 +268,1 @@\n-      if (_dynamic_archive_path != nullptr) {\n+      if (_input_dynamic_archive_path != nullptr) {\n@@ -382,1 +397,1 @@\n-#define CHECK_ALIAS(f) check_flag_alias(FLAG_IS_DEFAULT(f), #f)\n+#define CHECK_NEW_FLAG(f) check_new_flag(FLAG_IS_DEFAULT(f), #f)\n@@ -384,2 +399,2 @@\n-void CDSConfig::check_flag_alias(bool alias_is_default, const char* alias_name) {\n-  if (old_cds_flags_used() && !alias_is_default) {\n+void CDSConfig::check_new_flag(bool new_flag_is_default, const char* new_flag_name) {\n+  if (old_cds_flags_used() && !new_flag_is_default) {\n@@ -389,1 +404,9 @@\n-                                          alias_name));\n+                                          new_flag_name));\n+  }\n+}\n+\n+#define CHECK_SINGLE_PATH(f) check_flag_single_path(#f, f)\n+\n+void CDSConfig::check_flag_single_path(const char* flag_name, const char* value) {\n+  if (value != nullptr && num_archive_paths(value) != 1) {\n+    vm_exit_during_initialization(err_msg(\"Option %s must specify a single file name\", flag_name));\n@@ -400,3 +423,7 @@\n-  CHECK_ALIAS(AOTCache);\n-  CHECK_ALIAS(AOTConfiguration);\n-  CHECK_ALIAS(AOTMode);\n+  \/\/ \"New\" AOT flags must not be mixed with \"classic\" flags such as -Xshare:dump\n+  CHECK_NEW_FLAG(AOTCache);\n+  CHECK_NEW_FLAG(AOTConfiguration);\n+  CHECK_NEW_FLAG(AOTMode);\n+\n+  CHECK_SINGLE_PATH(AOTCache);\n+  CHECK_SINGLE_PATH(AOTConfiguration);\n@@ -440,5 +467,0 @@\n-  if (!FLAG_IS_DEFAULT(AOTCache)) {\n-    assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n-    FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n-  }\n-\n@@ -459,4 +481,0 @@\n-  assert(FLAG_IS_DEFAULT(DumpLoadedClassList), \"already checked\");\n-  assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n-  FLAG_SET_ERGO(SharedArchiveFile, AOTConfiguration);\n-  FLAG_SET_ERGO(DumpLoadedClassList, nullptr);\n@@ -478,3 +496,0 @@\n-  assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n-\n-  FLAG_SET_ERGO(SharedArchiveFile, AOTConfiguration);\n@@ -492,0 +507,20 @@\n+void CDSConfig::ergo_init_aot_paths() {\n+  assert(_cds_ergo_initialize_started, \"sanity\");\n+  if (is_dumping_static_archive()) {\n+    if (is_dumping_preimage_static_archive()) {\n+      _output_archive_path = AOTConfiguration;\n+    } else {\n+      assert(is_dumping_final_static_archive(), \"must be\");\n+      _input_static_archive_path = AOTConfiguration;\n+      _output_archive_path = AOTCache;\n+    }\n+  } else if (is_using_archive()) {\n+    if (FLAG_IS_DEFAULT(AOTCache)) {\n+      \/\/ Only -XX:AOTMode={auto,on} is specified\n+      _input_static_archive_path = default_archive_path();\n+    } else {\n+      _input_static_archive_path = AOTCache;\n+    }\n+  }\n+}\n+\n@@ -493,0 +528,2 @@\n+  assert(!_cds_ergo_initialize_started, \"This is called earlier than CDSConfig::ergo_initialize()\");\n+\n@@ -543,1 +580,1 @@\n-    enable_dumping_dynamic_archive();\n+    enable_dumping_dynamic_archive(ArchiveClassesAtExit);\n@@ -575,0 +612,28 @@\n+void CDSConfig::prepare_for_dumping() {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+\n+  if (is_dumping_dynamic_archive() && !is_using_archive()) {\n+    assert(!is_dumping_static_archive(), \"cannot be dumping both static and dynamic archives\");\n+\n+    \/\/ This could happen if SharedArchiveFile has failed to load:\n+    \/\/ - -Xshare:off was specified\n+    \/\/ - SharedArchiveFile points to an non-existent file.\n+    \/\/ - SharedArchiveFile points to an archive that has failed CRC check\n+    \/\/ - SharedArchiveFile is not specified and the VM doesn't have a compatible default archive\n+\n+#define __THEMSG \" is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\"\n+    if (RecordDynamicDumpInfo) {\n+      log_error(cds)(\"-XX:+RecordDynamicDumpInfo%s\", __THEMSG);\n+      MetaspaceShared::unrecoverable_loading_error();\n+    } else {\n+      assert(ArchiveClassesAtExit != nullptr, \"sanity\");\n+      log_warning(cds)(\"-XX:ArchiveClassesAtExit\" __THEMSG);\n+    }\n+#undef __THEMSG\n+    disable_dumping_dynamic_archive();\n+    return;\n+  }\n+\n+  check_unsupported_dumping_module_options();\n+}\n+\n@@ -589,0 +654,12 @@\n+void CDSConfig::enable_dumping_dynamic_archive(const char* output_path) {\n+  _is_dumping_dynamic_archive = true;\n+  if (output_path == nullptr) {\n+    \/\/ output_path can be null when the VM is started with -XX:+RecordDynamicDumpInfo\n+    \/\/ in anticipation of \"jcmd VM.cds dynamic_dump\", which will provide the actual\n+    \/\/ output path.\n+    _output_archive_path = nullptr;\n+  } else {\n+    _output_archive_path = os::strdup_check_oom(output_path, mtArguments);\n+  }\n+}\n+\n@@ -602,0 +679,18 @@\n+bool CDSConfig::is_dumping_regenerated_lambdaform_invokers() {\n+  if (is_dumping_final_static_archive()) {\n+    \/\/ No need to regenerate -- the lambda form invokers should have been regenerated\n+    \/\/ in the preimage archive (if allowed)\n+    return false;\n+  } else if (is_dumping_dynamic_archive() && is_using_aot_linked_classes()) {\n+    \/\/ The base archive has aot-linked classes that may have AOT-resolved CP references\n+    \/\/ that point to the lambda form invokers in the base archive. Such pointers will\n+    \/\/ be invalid if lambda form invokers are regenerated in the dynamic archive.\n+    return false;\n+  } else if (CDSConfig::is_dumping_method_handles()) {\n+    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n+    return false;\n+  } else {\n+    return is_dumping_archive();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":154,"deletions":59,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -48,3 +48,4 @@\n-  static char* _default_archive_path;\n-  static char* _static_archive_path;\n-  static char* _dynamic_archive_path;\n+  const static char* _default_archive_path;\n+  const static char* _input_static_archive_path;\n+  const static char* _input_dynamic_archive_path;\n+  const static char* _output_archive_path;\n@@ -59,4 +60,5 @@\n-  static void extract_shared_archive_paths(const char* archive_path,\n-                                           char** base_archive_path,\n-                                           char** top_archive_path);\n-  static void init_shared_archive_paths();\n+  static void extract_archive_paths(const char* archive_path,\n+                                    const char** base_archive_path,\n+                                    const char** top_archive_path);\n+  static int num_archive_paths(const char* path_spec);\n+  static void check_flag_single_path(const char* flag_name, const char* value);\n@@ -64,1 +66,2 @@\n-  static void check_flag_alias(bool alias_is_default, const char* alias_name);\n+  \/\/ Checks before Arguments::apply_ergo()\n+  static void check_new_flag(bool new_flag_is_default, const char* new_flag_name);\n@@ -70,0 +73,5 @@\n+  static void check_unsupported_dumping_module_options();\n+\n+  \/\/ Called after Arguments::apply_ergo() has started\n+  static void ergo_init_classic_archive_paths();\n+  static void ergo_init_aot_paths();\n@@ -82,1 +90,1 @@\n-  static void initialize() NOT_CDS_RETURN;\n+  static void ergo_initialize() NOT_CDS_RETURN;\n@@ -88,1 +96,0 @@\n-  static void check_unsupported_dumping_module_options() NOT_CDS_RETURN;\n@@ -98,0 +105,1 @@\n+  static void prepare_for_dumping();\n@@ -103,0 +111,2 @@\n+\n+  \/\/ input archive(s)\n@@ -104,1 +114,0 @@\n-  static int num_archives(const char* archive_path)          NOT_CDS_RETURN_(0);\n@@ -136,1 +145,1 @@\n-  static void enable_dumping_dynamic_archive()               { CDS_ONLY(_is_dumping_dynamic_archive = true); }\n+  static void enable_dumping_dynamic_archive(const char* output_path) NOT_CDS_RETURN;\n@@ -150,0 +159,1 @@\n+  static bool is_dumping_regenerated_lambdaform_invokers()   NOT_CDS_RETURN_(false);\n@@ -157,6 +167,5 @@\n-  \/\/ Points to the classes.jsa in $JAVA_HOME\n-  static char* default_archive_path()                        NOT_CDS_RETURN_(nullptr);\n-  \/\/ The actual static archive  (if any) selected at runtime\n-  static const char* static_archive_path()                   { return CDS_ONLY(_static_archive_path) NOT_CDS(nullptr); }\n-  \/\/ The actual dynamic archive  (if any) selected at runtime\n-  static const char* dynamic_archive_path()                  { return CDS_ONLY(_dynamic_archive_path) NOT_CDS(nullptr); }\n+  \/\/ Points to the classes.jsa in $JAVA_HOME (could be input or output)\n+  static const char* default_archive_path()                  NOT_CDS_RETURN_(nullptr);\n+  static const char* input_static_archive_path()             { return CDS_ONLY(_input_static_archive_path) NOT_CDS(nullptr); }\n+  static const char* input_dynamic_archive_path()            { return CDS_ONLY(_input_dynamic_archive_path) NOT_CDS(nullptr); }\n+  static const char* output_archive_path()                   { return CDS_ONLY(_output_archive_path) NOT_CDS(nullptr); }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-    const char* current_base_archive_name = CDSConfig::static_archive_path();\n+    const char* current_base_archive_name = CDSConfig::input_static_archive_path();\n@@ -277,1 +277,1 @@\n-    copy_base_archive_name(CDSConfig::static_archive_path());\n+    copy_base_archive_name(CDSConfig::input_static_archive_path());\n@@ -635,1 +635,1 @@\n-                                                    char** base_archive_name) {\n+                                                    const char** base_archive_name) {\n@@ -691,1 +691,1 @@\n-        log_warning(cds)(\"Not a valid %s %s\", file_type, _full_path);\n+        log_warning(cds)(\"Not a valid %s (%s)\", file_type, _full_path);\n@@ -805,1 +805,1 @@\n-void FileMapInfo::open_for_write() {\n+void FileMapInfo::open_as_output() {\n@@ -1835,1 +1835,1 @@\n-bool FileMapInfo::initialize() {\n+bool FileMapInfo::open_as_input() {\n@@ -1850,1 +1850,1 @@\n-      log_info(cds)(\"Initialize static archive failed.\");\n+      log_info(cds)(\"Loading static archive failed.\");\n@@ -1853,1 +1853,1 @@\n-      log_info(cds)(\"Initialize dynamic archive failed.\");\n+      log_info(cds)(\"Loading dynamic archive failed.\");\n@@ -1855,2 +1855,1 @@\n-        CDSConfig::enable_dumping_dynamic_archive();\n-        ArchiveClassesAtExit = CDSConfig::dynamic_archive_path();\n+        CDSConfig::enable_dumping_dynamic_archive(_full_path);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-                                                char** base_archive_name);\n+                                                const char** base_archive_name);\n@@ -387,3 +387,2 @@\n-  bool  initialize() NOT_CDS_RETURN_(false);\n-  bool  open_for_read();\n-  void  open_for_write();\n+  bool  open_as_input() NOT_CDS_RETURN_(false);\n+  void  open_as_output();\n@@ -466,0 +465,1 @@\n+  bool  open_for_read();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+#include <sys\/stat.h>\n+\n@@ -681,5 +683,1 @@\n-  const char* static_archive;\n-    static_archive = AOTCache;\n-    FileMapInfo::free_current_info();\n-  } else {\n-    static_archive = CDSConfig::static_archive_path();\n+    FileMapInfo::free_current_info(); \/\/ FIXME: should not free current info\n@@ -688,1 +686,2 @@\n-  assert(static_archive != nullptr, \"SharedArchiveFile not set?\");\n+  const char* static_archive = CDSConfig::output_archive_path();\n+  assert(static_archive != nullptr, \"sanity\");\n@@ -701,0 +700,10 @@\n+   CollectClassesForLinking() : _mirrors() {\n+     \/\/ ClassLoaderDataGraph::loaded_classes_do_keepalive() requires ClassLoaderDataGraph_lock.\n+     \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n+     \/\/ Therefore, we need to first collect all the classes, keeping them alive by\n+     \/\/ holding onto their java_mirrors in global OopHandles. We then link the classes after\n+     \/\/ releasing the lock.\n+     MutexLocker lock(ClassLoaderDataGraph_lock);\n+     ClassLoaderDataGraph::loaded_classes_do_keepalive(this);\n+   }\n+\n@@ -741,10 +750,1 @@\n-bool MetaspaceShared::link_class_for_cds(InstanceKlass* ik, TRAPS) {\n-  \/\/ Link the class to cause the bytecodes to be rewritten and the\n-  \/\/ cpcache to be created. Class verification is done according\n-  \/\/ to -Xverify setting.\n-  bool res = MetaspaceShared::try_link_class(THREAD, ik);\n-  AOTConstantPoolResolver::dumptime_resolve_constants(ik, CHECK_(false));\n-  return res;\n-}\n-\n-void MetaspaceShared::link_shared_classes(bool jcmd_request, TRAPS) {\n+void MetaspaceShared::link_shared_classes(TRAPS) {\n@@ -754,5 +754,1 @@\n-  if (!jcmd_request && !CDSConfig::is_dumping_final_static_archive()) {\n-    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n-  }\n-\n-\n+    ResourceMark rm(THREAD);\n@@ -761,10 +757,0 @@\n-    {\n-      \/\/ ClassLoaderDataGraph::loaded_classes_do_keepalive() requires ClassLoaderDataGraph_lock.\n-      \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n-      \/\/ Therefore, we need to first collect all the classes, keeping them alive by\n-      \/\/ holding onto their java_mirrors in global OopHandles. We then link the classes after\n-      \/\/ releasing the lock.\n-      MutexLocker lock(ClassLoaderDataGraph_lock);\n-      ClassLoaderDataGraph::loaded_classes_do_keepalive(&collect_classes);\n-    }\n-\n@@ -777,1 +763,1 @@\n-        has_linked |= link_class_for_cds(ik, CHECK);\n+        has_linked |= try_link_class(THREAD, ik);\n@@ -788,0 +774,12 @@\n+  \/\/ Resolve constant pool entries -- we don't load any new classes during this stage\n+  {\n+    ResourceMark rm(THREAD);\n+    CollectClassesForLinking collect_classes;\n+    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n+    for (int i = 0; i < mirrors->length(); i++) {\n+      OopHandle mirror = mirrors->at(i);\n+      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      AOTConstantPoolResolver::dumptime_resolve_constants(ik, CHECK);\n+    }\n+  }\n+\n@@ -793,5 +791,0 @@\n-void MetaspaceShared::prepare_for_dumping() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  CDSConfig::check_unsupported_dumping_module_options();\n-}\n-\n@@ -828,2 +821,8 @@\n-      tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n-      vm_exit(0);\n+      struct stat st;\n+      if (os::stat(AOTCache, &st) != 0) {\n+        tty->print_cr(\"AOTCache creation failed: %s\", AOTCache);\n+        vm_exit(0);\n+      } else {\n+        tty->print_cr(\"AOTCache creation is complete: %s \" INT64_FORMAT \" bytes\", AOTCache, (int64_t)(st.st_size));\n+        vm_exit(0);\n+      }\n@@ -931,0 +930,12 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap()) {\n+    assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+    if (!HeapShared::is_archived_boot_layer_available(THREAD)) {\n+      log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n+      CDSConfig::stop_dumping_full_module_graph();\n+    }\n+    \/\/ Do this before link_shared_classes(), as the following line may load new classes.\n+    HeapShared::init_for_dumping(CHECK);\n+  }\n+#endif\n+\n@@ -946,1 +957,1 @@\n-  link_shared_classes(false\/*not from jcmd*\/, CHECK);\n+  link_shared_classes(CHECK);\n@@ -949,0 +960,4 @@\n+  if (CDSConfig::is_dumping_regenerated_lambdaform_invokers()) {\n+    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n+  }\n+\n@@ -951,5 +966,0 @@\n-    if (!HeapShared::is_archived_boot_layer_available(THREAD)) {\n-      log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n-      CDSConfig::stop_dumping_full_module_graph();\n-    }\n-    HeapShared::init_for_dumping(CHECK);\n@@ -1010,1 +1020,1 @@\n-  map_info->open_for_write();\n+  map_info->open_as_output();\n@@ -1206,1 +1216,1 @@\n-  const char* static_archive = CDSConfig::static_archive_path();\n+  const char* static_archive = CDSConfig::input_static_archive_path();\n@@ -1209,1 +1219,1 @@\n-  if (!mapinfo->initialize()) {\n+  if (!mapinfo->open_as_input()) {\n@@ -1220,1 +1230,1 @@\n-  const char* dynamic_archive = CDSConfig::dynamic_archive_path();\n+  const char* dynamic_archive = CDSConfig::input_dynamic_archive_path();\n@@ -1226,1 +1236,1 @@\n-  if (!mapinfo->initialize()) {\n+  if (!mapinfo->open_as_input()) {\n@@ -1809,1 +1819,1 @@\n-      tty->print_cr(\"\\n\\nBase archive name: %s\", CDSConfig::static_archive_path());\n+      tty->print_cr(\"\\n\\nBase archive name: %s\", CDSConfig::input_static_archive_path());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":61,"deletions":51,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  static void prepare_for_dumping() NOT_CDS_RETURN;\n@@ -134,2 +133,1 @@\n-  static void link_shared_classes(bool jcmd_request, TRAPS) NOT_CDS_RETURN;\n-  static bool link_class_for_cds(InstanceKlass* ik, TRAPS) NOT_CDS_RETURN_(false);\n+  static void link_shared_classes(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  bool equals(ciMetadata* obj) const { return (this == obj); }\n+  bool equals(const ciMetadata* obj) const { return (this == obj); }\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5622,1 +5622,2 @@\n-  _need_verify = Verifier::should_verify_for(_loader_data->class_loader());\n+  \/\/ Always verify CFLH bytes from the user agents.\n+  _need_verify = stream->from_class_file_load_hook() ? true : Verifier::should_verify_for(_loader_data->class_loader());\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-void FieldLayout::initialize_instance_layout(const InstanceKlass* super_klass) {\n+void FieldLayout::initialize_instance_layout(const InstanceKlass* super_klass, bool& super_ends_with_oop) {\n@@ -232,0 +232,1 @@\n+    super_ends_with_oop = false;\n@@ -238,1 +239,1 @@\n-    _super_has_fields = reconstruct_layout(super_klass);\n+    reconstruct_layout(super_klass, _super_has_fields, super_ends_with_oop);\n@@ -413,2 +414,2 @@\n-bool FieldLayout::reconstruct_layout(const InstanceKlass* ik) {\n-  bool has_instance_fields = false;\n+void FieldLayout::reconstruct_layout(const InstanceKlass* ik, bool& has_instance_fields, bool& ends_with_oop) {\n+  has_instance_fields = ends_with_oop = false;\n@@ -419,0 +420,2 @@\n+  BasicType last_type;\n+  int last_offset = -1;\n@@ -426,1 +429,3 @@\n-      if (_super_first_field_offset == -1 || fs.offset() < _super_first_field_offset) _super_first_field_offset = fs.offset();\n+      if (_super_first_field_offset == -1 || fs.offset() < _super_first_field_offset) {\n+        _super_first_field_offset = fs.offset();\n+      }\n@@ -444,0 +449,4 @@\n+      if (fs.offset() > last_offset) {\n+        last_offset = fs.offset();\n+        last_type = type;\n+      }\n@@ -449,0 +458,6 @@\n+  assert(last_offset == -1 || last_offset > 0, \"Sanity\");\n+  if (last_offset > 0 &&\n+      (last_type == BasicType::T_ARRAY || last_type == BasicType::T_OBJECT)) {\n+    ends_with_oop = true;\n+  }\n+\n@@ -460,1 +475,0 @@\n-  return has_instance_fields;\n@@ -765,1 +779,1 @@\n-  _layout->initialize_instance_layout(super_klass);\n+  _layout->initialize_instance_layout(super_klass, _super_ends_with_oop);\n@@ -948,7 +962,12 @@\n-\/* Computation of regular classes layout is an evolution of the previous default layout\n- * (FieldAllocationStyle 1):\n- *   - primitive fields (both primitive types and flat inline types) are allocated\n- *     first, from the biggest to the smallest\n- *   - then oop fields are allocated (to increase chances to have contiguous oops and\n- *     a simpler oopmap).\n- *\/\n+\/\/ Computation of regular classes layout is an evolution of the previous default layout\n+\/\/ (FieldAllocationStyle 1):\n+\/\/   - primitive fields (both primitive types and flat inline types) are allocated\n+\/\/     first (from the biggest to the smallest)\n+\/\/   - oop fields are allocated, either in existing gaps or at the end of\n+\/\/     the layout. We allocate oops in a single block to have a single oop map entry.\n+\/\/   - if the super class ended with an oop, we lead with oops. That will cause the\n+\/\/     trailing oop map entry of the super class and the oop map entry of this class\n+\/\/     to be folded into a single entry later. Correspondingly, if the super class\n+\/\/     ends with a primitive field, we gain nothing by leading with oops; therefore\n+\/\/     we let oop fields trail, thus giving future derived classes the chance to apply\n+\/\/     the same trick.\n@@ -966,3 +985,10 @@\n-  _layout->add(_root_group->big_primitive_fields());\n-  _layout->add(_root_group->small_primitive_fields());\n-  _layout->add(_root_group->oop_fields());\n+\n+  if (_super_ends_with_oop) {\n+    _layout->add(_root_group->oop_fields());\n+    _layout->add(_root_group->big_primitive_fields());\n+    _layout->add(_root_group->small_primitive_fields());\n+  } else {\n+    _layout->add(_root_group->big_primitive_fields());\n+    _layout->add(_root_group->small_primitive_fields());\n+    _layout->add(_root_group->oop_fields());\n+  }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":43,"deletions":17,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  void initialize_instance_layout(const InstanceKlass* ik);\n+  void initialize_instance_layout(const InstanceKlass* ik, bool& super_ends_with_oop);\n@@ -238,1 +238,1 @@\n-  bool reconstruct_layout(const InstanceKlass* ik);\n+  void reconstruct_layout(const InstanceKlass* ik, bool& has_instance_fields, bool& ends_with_oop);\n@@ -304,0 +304,1 @@\n+  bool _super_ends_with_oop;\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n- do_class(sun_security_provider_ML_DSA,      \"sun\/security\/provider\/ML_DSA\")                                            \\\n+  do_class(sun_security_provider_ML_DSA,      \"sun\/security\/provider\/ML_DSA\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,2 +241,1 @@\n-void G1ParScanThreadState::start_partial_objarray(G1HeapRegionAttr dest_attr,\n-                                                  oop from_obj,\n+void G1ParScanThreadState::start_partial_objarray(oop from_obj,\n@@ -254,6 +253,1 @@\n-  \/\/ Skip the card enqueue iff the object (to_array) is in survivor region.\n-  \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n-  \/\/ Instead, we use dest_attr.is_young() because the two values are always\n-  \/\/ equal: successfully allocated young regions must be survivor regions.\n-  assert(dest_attr.is_young() == _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n-  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n+  assert(_scanner.skip_card_enqueue_set(), \"must be\");\n@@ -425,0 +419,39 @@\n+ALWAYSINLINE\n+void G1ParScanThreadState::do_iterate_object(oop const obj,\n+                                             oop const old,\n+                                             Klass* const klass,\n+                                             G1HeapRegionAttr const region_attr,\n+                                             G1HeapRegionAttr const dest_attr,\n+                                             uint age) {\n+    \/\/ Most objects are not arrays, so do one array check rather than\n+    \/\/ checking for each array category for each object.\n+    if (klass->is_array_klass() && !klass->is_flatArray_klass()) {\n+      assert(!klass->is_stack_chunk_instance_klass(), \"must be\");\n+\n+      if (klass->is_objArray_klass()) {\n+        start_partial_objarray(old, obj);\n+      } else {\n+        \/\/ Nothing needs to be done for typeArrays.  Body doesn't contain\n+        \/\/ any oops to scan, and the type in the klass will already be handled\n+        \/\/ by processing the built-in module.\n+        assert(klass->is_typeArray_klass(), \"invariant\");\n+      }\n+      return;\n+    }\n+\n+    ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+    \/\/ Check for deduplicating young Strings.\n+    if (G1StringDedup::is_candidate_from_evacuation(klass,\n+                                                    region_attr,\n+                                                    dest_attr,\n+                                                    age)) {\n+      \/\/ Record old; request adds a new weak reference, which reference\n+      \/\/ processing expects to refer to a from-space object.\n+      _string_dedup_requests.add(old);\n+    }\n+\n+    assert(_scanner.skip_card_enqueue_set(), \"must be\");\n+    obj->oop_iterate_backwards(&_scanner, klass);\n+}\n+\n@@ -449,1 +482,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz, true \/* cause_pinned *\/);\n+    return handle_evacuation_failure_par(old, old_mark, klass, region_attr, word_sz, true \/* cause_pinned *\/);\n@@ -466,1 +499,1 @@\n-      return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n+      return handle_evacuation_failure_par(old, old_mark, klass, region_attr, word_sz, false \/* cause_pinned *\/);\n@@ -478,1 +511,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n+    return handle_evacuation_failure_par(old, old_mark, klass, region_attr, word_sz, false \/* cause_pinned *\/);\n@@ -510,25 +543,8 @@\n-    \/\/ Most objects are not arrays, so do one array check rather than\n-    \/\/ checking for each array category for each object.\n-    \/\/ CMH: Valhalla flat arrays can split this work up, but for now, doesn't\n-    if (klass->is_array_klass() && !klass->is_flatArray_klass()) {\n-      if (klass->is_objArray_klass()) {\n-        start_partial_objarray(dest_attr, old, obj);\n-      } else {\n-        \/\/ Nothing needs to be done for typeArrays.  Body doesn't contain\n-        \/\/ any oops to scan, and the type in the klass will already be handled\n-        \/\/ by processing the built-in module.\n-        assert(klass->is_typeArray_klass(), \"invariant\");\n-      }\n-      return obj;\n-    }\n-\n-    ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-    \/\/ Check for deduplicating young Strings.\n-    if (G1StringDedup::is_candidate_from_evacuation(klass,\n-                                                    region_attr,\n-                                                    dest_attr,\n-                                                    age)) {\n-      \/\/ Record old; request adds a new weak reference, which reference\n-      \/\/ processing expects to refer to a from-space object.\n-      _string_dedup_requests.add(old);\n+    {\n+      \/\/ Skip the card enqueue iff the object (obj) is in survivor region.\n+      \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n+      \/\/ Instead, we use dest_attr.is_young() because the two values are always\n+      \/\/ equal: successfully allocated young regions must be survivor regions.\n+      assert(dest_attr.is_young() == _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n+      G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n+      do_iterate_object(obj, old, klass, region_attr, dest_attr, age);\n@@ -537,7 +553,0 @@\n-    \/\/ Skip the card enqueue iff the object (obj) is in survivor region.\n-    \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n-    \/\/ Instead, we use dest_attr.is_young() because the two values are always\n-    \/\/ equal: successfully allocated young regions must be survivor regions.\n-    assert(dest_attr.is_young() == _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n-    G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n-    obj->oop_iterate_backwards(&_scanner, klass);\n@@ -625,1 +634,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz, bool cause_pinned) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, Klass* klass, G1HeapRegionAttr attr, size_t word_sz, bool cause_pinned) {\n@@ -639,2 +648,0 @@\n-    ContinuationGCSupport::transform_stack_chunk(old);\n-\n@@ -643,6 +650,8 @@\n-    \/\/ For iterating objects that failed evacuation currently we can reuse the\n-    \/\/ existing closure to scan evacuated objects; since we are iterating from a\n-    \/\/ collection set region (i.e. never a Survivor region), we always need to\n-    \/\/ gather cards for this case.\n-    G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_card_enqueue *\/);\n-    old->oop_iterate_backwards(&_scanner);\n+    {\n+      \/\/ For iterating objects that failed evacuation currently we can reuse the\n+      \/\/ existing closure to scan evacuated objects; since we are iterating from a\n+      \/\/ collection set region (i.e. never a Survivor region), we always need to\n+      \/\/ gather cards for this case.\n+      G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_card_enqueue *\/);\n+      do_iterate_object(old, old, klass, attr, attr, m.age());\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":61,"deletions":52,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -444,9 +444,1 @@\n-  \/\/ Print more detailed heap information on the given\n-  \/\/ outputStream. The default behavior is to call print_on(). It is\n-  \/\/ up to each subclass to override it and add any additional output\n-  \/\/ it needs.\n-  virtual void print_extended_on(outputStream* st) const {\n-    print_on(st);\n-  }\n-\n-  virtual void print_on_error(outputStream* st) const;\n+  virtual void print_on_error(outputStream* st) const = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -902,1 +902,0 @@\n-  DynamicArchive::check_for_dynamic_dump();\n@@ -909,1 +908,1 @@\n-    MetaspaceShared::prepare_for_dumping();\n+    CDSConfig::prepare_for_dumping();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -480,0 +480,14 @@\n+  bool update_resolved_reference = true;\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    InstanceKlass* src_holder = src_cp->pool_holder();\n+    if (src_holder->is_shared_unregistered_class()) {\n+      \/\/ Unregistered classes are not loaded in the AOT assembly phase. The resolved reference length\n+      \/\/ is already saved during the training run.\n+      precond(!src_holder->is_loaded());\n+      precond(resolved_reference_length() >= 0);\n+      precond(resolved_references() == nullptr);\n+      update_resolved_reference = false;\n+    }\n+  }\n+\n@@ -482,1 +496,1 @@\n-  if (cache() != nullptr) {\n+  if (update_resolved_reference && cache() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3998,1 +3998,1 @@\n-  st->print(BULLET\"non-static oop maps: \");\n+  st->print(BULLET\"non-static oop maps (%d entries): \", nonstatic_oop_map_count());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -814,3 +814,9 @@\n-    oop scratch_mirror = HeapShared::scratch_java_mirror(orig_mirror);\n-    if (scratch_mirror != nullptr) {\n-      _archived_mirror_index = HeapShared::append_root(scratch_mirror);\n+    if (orig_mirror == nullptr) {\n+      assert(CDSConfig::is_dumping_final_static_archive(), \"sanity\");\n+      assert(is_instance_klass(), \"sanity\");\n+      assert(InstanceKlass::cast(this)->is_shared_unregistered_class(), \"sanity\");\n+    } else {\n+      oop scratch_mirror = HeapShared::scratch_java_mirror(orig_mirror);\n+      if (scratch_mirror != nullptr) {\n+        _archived_mirror_index = HeapShared::append_root(scratch_mirror);\n+      }\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -446,1 +446,1 @@\n-    return; \/\/ dont write into the shared class\n+    return; \/\/ don't write into the shared class\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1327,1 +1327,0 @@\n-  set_creation_mileage(mileage_of(method()));\n@@ -1434,5 +1433,0 @@\n-\/\/ Get a measure of how much mileage the method has on it.\n-int MethodData::mileage_of(Method* method) {\n-  return MAX2(method->invocation_count(), method->backedge_count());\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,2 +59,1 @@\n-\/\/ is marked with its birth-date (\"creation_mileage\") which can be used\n-\/\/ to assess the quality (\"maturity\") of its data.\n+\/\/ can be checked for its \"maturity\" by calling is_mature().\n@@ -2296,2 +2295,0 @@\n-  int               _creation_mileage; \/\/ method mileage at MDO creation\n-\n@@ -2460,3 +2457,0 @@\n-  int      creation_mileage() const { return _creation_mileage; }\n-  void set_creation_mileage(int x)  { _creation_mileage = x; }\n-\n@@ -2515,2 +2509,1 @@\n-  bool is_mature() const;  \/\/ consult mileage and ProfileMaturityPercentage\n-  static int mileage_of(Method* m);\n+  bool is_mature() const;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,5 +57,0 @@\n-\/\/ Forward declarations.\n-class OopClosure;\n-class PSPromotionManager;\n-class ParCompactionManager;\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/utilities\/xor.hpp\"\n@@ -844,1 +845,1 @@\n-  return nullptr;\n+  return AddNode::Ideal(phase, can_reshape);\n@@ -924,1 +925,1 @@\n-  return nullptr;\n+  return AddNode::Ideal(phase, can_reshape);\n@@ -1022,13 +1023,0 @@\n-  \/\/ result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-  const TypeInt* t1i = t1->is_int();\n-  const TypeInt* t2i = t2->is_int();\n-  if ((t1i->_lo >= 0) &&\n-      (t1i->_hi > 0)  &&\n-      (t2i->_lo >= 0) &&\n-      (t2i->_hi > 0)) {\n-    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n-    const TypeInt* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n-    const TypeInt* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n-    return t1x->meet(t2x);\n-  }\n@@ -1038,1 +1026,0 @@\n-\n@@ -1048,4 +1035,4 @@\n-  \/\/ Complementing a boolean?\n-  if( r0 == TypeInt::BOOL && ( r1 == TypeInt::ONE\n-                               || r1 == TypeInt::BOOL))\n-    return TypeInt::BOOL;\n+  if (r0->is_con() && r1->is_con()) {\n+    \/\/ compute constant result\n+    return TypeInt::make(r0->get_con() ^ r1->get_con());\n+  }\n@@ -1053,2 +1040,7 @@\n-  if( !r0->is_con() || !r1->is_con() ) \/\/ Not constants\n-    return TypeInt::INT;        \/\/ Any integer, but still no symbols.\n+  \/\/ At least one of the arguments is not constant\n+\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+      \/\/ Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n+      jint upper_bound = xor_upper_bound_for_ranges<jint, juint>(r0->_hi, r1->_hi);\n+      return TypeInt::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n+  }\n@@ -1056,2 +1048,1 @@\n-  \/\/ Otherwise just XOR them bits.\n-  return TypeInt::make( r0->get_con() ^ r1->get_con() );\n+  return TypeInt::INT;\n@@ -1066,3 +1057,4 @@\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ Any integer, but still no symbols.\n+  if (r0->is_con() && r1->is_con()) {\n+    \/\/ compute constant result\n+    return TypeLong::make(r0->get_con() ^ r1->get_con());\n+  }\n@@ -1070,2 +1062,9 @@\n-  \/\/ Otherwise just OR them bits.\n-  return TypeLong::make( r0->get_con() ^ r1->get_con() );\n+  \/\/ At least one of the arguments is not constant\n+\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+      \/\/ Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n+      julong upper_bound = xor_upper_bound_for_ranges<jlong, julong>(r0->_hi, r1->_hi);\n+      return TypeLong::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n+  }\n+\n+  return TypeLong::LONG;\n@@ -1107,13 +1106,1 @@\n-  \/\/ result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-  const TypeLong* t1l = t1->is_long();\n-  const TypeLong* t2l = t2->is_long();\n-  if ((t1l->_lo >= 0) &&\n-      (t1l->_hi > 0)  &&\n-      (t2l->_lo >= 0) &&\n-      (t2l->_hi > 0)) {\n-    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n-    const TypeLong* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n-    const TypeLong* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n-    return t1x->meet(t2x);\n-  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":29,"deletions":42,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -756,1 +756,1 @@\n-bool ArrayCopyNode::may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode*& call) {\n+bool ArrayCopyNode::may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, ArrayCopyNode*& ac) {\n@@ -758,4 +758,3 @@\n-      n->is_Call() &&\n-      n->as_Call()->may_modify(t_oop, phase) &&\n-      (n->as_Call()->is_ArrayCopy() || n->as_Call()->is_call_to_arraycopystub())) {\n-    call = n->as_Call();\n+      n->is_ArrayCopy() &&\n+      n->as_ArrayCopy()->may_modify(t_oop, phase)) {\n+    ac = n->as_ArrayCopy();\n@@ -768,0 +767,4 @@\n+  if (mb->trailing_expanded_array_copy()) {\n+    return true;\n+  }\n+\n@@ -780,2 +783,1 @@\n-        if (may_modify_helper(t_oop, n, phase, call)) {\n-          ac = call->isa_ArrayCopy();\n+        if (may_modify_helper(t_oop, n, phase, ac)) {\n@@ -787,2 +789,1 @@\n-  } else if (may_modify_helper(t_oop, c->in(0), phase, call)) {\n-    ac = call->isa_ArrayCopy();\n+  } else if (may_modify_helper(t_oop, c->in(0), phase, ac)) {\n@@ -792,1 +793,1 @@\n-    assert(c == mb->in(0) || (ac != nullptr && ac->is_clonebasic() && !use_ReduceInitialCardMarks), \"only for clone\");\n+    assert(c == mb->in(0) || (ac->is_clonebasic() && !use_ReduceInitialCardMarks), \"only for clone\");\n@@ -795,2 +796,0 @@\n-  } else if (mb->trailing_partial_array_copy()) {\n-    return true;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  static bool may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode*& call);\n+  static bool may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, ArrayCopyNode*& ac);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -829,0 +829,6 @@\n+                                                                            \\\n+  develop(bool, KillPathsReachableByDeadTypeNode, true,                     \\\n+          \"When a Type node becomes top, make paths where the node is \"     \\\n+          \"used dead by replacing them with a Halt node. Turning this off \" \\\n+          \"could corrupt the graph in rare cases and should be used with \"  \\\n+          \"care.\")                                                          \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-    assert(_callee == nullptr, \"repeated inlining attempt\");\n+    assert(_callee == nullptr || _callee == m, \"repeated inline attempt with different callee\");\n@@ -1138,2 +1138,2 @@\n-    if (should_delay) {\n-      return CallGenerator::for_late_inline(callee, cg);\n+    if (should_delay && IncrementalInlineMH) {\n+      return CallGenerator::for_mh_late_inline(caller, callee, input_not_const);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1150,0 +1150,9 @@\n+void CallJavaNode::register_for_late_inline() {\n+  if (generator() != nullptr) {\n+    Compile::current()->prepend_late_inline(generator());\n+    set_generator(nullptr);\n+  } else {\n+    assert(false, \"repeated inline attempt\");\n+  }\n+}\n+\n@@ -1170,11 +1179,20 @@\n-    assert(IncrementalInlineMH, \"required\");\n-    assert(cg->call_node() == this, \"mismatch\");\n-    assert(cg->is_mh_late_inline(), \"not virtual\");\n-\n-    \/\/ Check whether this MH handle call becomes a candidate for inlining.\n-    ciMethod* callee = cg->method();\n-    vmIntrinsics::ID iid = callee->intrinsic_id();\n-    if (iid == vmIntrinsics::_invokeBasic) {\n-      if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(nullptr);\n+    if (cg->is_mh_late_inline()) {\n+      assert(IncrementalInlineMH, \"required\");\n+      assert(cg->call_node() == this, \"mismatch\");\n+      assert(cg->method()->is_method_handle_intrinsic(), \"required\");\n+\n+      \/\/ Check whether this MH handle call becomes a candidate for inlining.\n+      ciMethod* callee = cg->method();\n+      vmIntrinsics::ID iid = callee->intrinsic_id();\n+      if (iid == vmIntrinsics::_invokeBasic) {\n+        if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n+          register_for_late_inline();\n+        }\n+      } else if (iid == vmIntrinsics::_linkToNative) {\n+        \/\/ never retry\n+      } else {\n+        assert(callee->has_member_arg(), \"wrong type of call?\");\n+        if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n+          register_for_late_inline();\n+          phase->C->inc_number_of_mh_late_inlines();\n+        }\n@@ -1182,6 +1200,5 @@\n-    } else if (iid == vmIntrinsics::_linkToNative) {\n-      \/\/ never retry\n-      assert(callee->has_member_arg(), \"wrong type of call?\");\n-      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(nullptr);\n+      assert(IncrementalInline, \"required\");\n+      assert(!cg->method()->is_method_handle_intrinsic(), \"required\");\n+      if (phase->C->print_inlining()) {\n+        phase->C->inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE,\n+          \"static call node changed: trying again\");\n@@ -1190,0 +1207,1 @@\n+      register_for_late_inline();\n@@ -1380,18 +1398,18 @@\n-    assert(IncrementalInlineVirtual, \"required\");\n-    assert(cg->call_node() == this, \"mismatch\");\n-    assert(cg->is_virtual_late_inline(), \"not virtual\");\n-\n-    \/\/ Recover symbolic info for method resolution.\n-    ciMethod* caller = jvms()->method();\n-    ciBytecodeStream iter(caller);\n-    iter.force_bci(jvms()->bci());\n-\n-    bool             not_used1;\n-    ciSignature*     not_used2;\n-    ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-    ciKlass*         holder       = iter.get_declared_method_holder();\n-    if (orig_callee->is_method_handle_intrinsic()) {\n-      assert(_override_symbolic_info, \"required\");\n-      orig_callee = method();\n-      holder = method()->holder();\n-    }\n+    if (cg->is_virtual_late_inline()) {\n+      assert(IncrementalInlineVirtual, \"required\");\n+      assert(cg->call_node() == this, \"mismatch\");\n+\n+      \/\/ Recover symbolic info for method resolution.\n+      ciMethod* caller = jvms()->method();\n+      ciBytecodeStream iter(caller);\n+      iter.force_bci(jvms()->bci());\n+\n+      bool             not_used1;\n+      ciSignature*     not_used2;\n+      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+      ciKlass*         holder       = iter.get_declared_method_holder();\n+      if (orig_callee->is_method_handle_intrinsic()) {\n+        assert(_override_symbolic_info, \"required\");\n+        orig_callee = method();\n+        holder = method()->holder();\n+      }\n@@ -1399,1 +1417,1 @@\n-    ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1401,2 +1419,2 @@\n-    Node* receiver_node = in(TypeFunc::Parms);\n-    const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+      Node* receiver_node = in(TypeFunc::Parms);\n+      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1404,9 +1422,16 @@\n-    int  not_used3;\n-    bool call_does_dispatch;\n-    ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                       call_does_dispatch, not_used3);  \/\/ out-parameters\n-    if (!call_does_dispatch) {\n-      \/\/ Register for late inlining.\n-      cg->set_callee_method(callee);\n-      phase->C->prepend_late_inline(cg); \/\/ MH late inlining prepends to the list, so do the same\n-      set_generator(nullptr);\n+      int  not_used3;\n+      bool call_does_dispatch;\n+      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                         call_does_dispatch, not_used3);  \/\/ out-parameters\n+      if (!call_does_dispatch) {\n+        \/\/ Register for late inlining.\n+        cg->set_callee_method(callee);\n+        register_for_late_inline(); \/\/ MH late inlining prepends to the list, so do the same\n+      }\n+    } else {\n+      assert(IncrementalInline, \"required\");\n+      if (phase->C->print_inlining()) {\n+        phase->C->inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE,\n+          \"dynamic call node changed: trying again\");\n+      }\n+      register_for_late_inline();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":72,"deletions":47,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -812,0 +812,1 @@\n+  void register_for_late_inline();\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  if (in(0) && remove_dead_region(phase, can_reshape)) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -120,0 +120,4 @@\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    return TypeNode::Ideal(phase, can_reshape);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2556,0 +2556,1 @@\n+    bool is_scheduled_for_igvn_before = C->igvn_worklist()->member(cg->call_node());\n@@ -2566,0 +2567,10 @@\n+      } else {\n+        bool is_scheduled_for_igvn_after = C->igvn_worklist()->member(cg->call_node());\n+        if (!is_scheduled_for_igvn_before && is_scheduled_for_igvn_after) {\n+          \/\/ Avoid potential infinite loop if node already in the IGVN list\n+          assert(false, \"scheduled for IGVN during inlining attempt\");\n+        } else {\n+          \/\/ Ensure call node has not disappeared from IGVN worklist during a failed inlining attempt\n+          assert(!is_scheduled_for_igvn_before || is_scheduled_for_igvn_after, \"call node removed from IGVN list during inlining pass\");\n+          cg->call_node()->set_generator(cg);\n+        }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -700,1 +700,8 @@\n-Node *ConvI2LNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* ConvI2LNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    Node* progress = TypeNode::Ideal(phase, can_reshape);\n+    if (progress != nullptr) {\n+      return progress;\n+    }\n+  }\n+\n@@ -802,1 +809,8 @@\n-Node *ConvL2INode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* ConvL2INode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    Node* progress = TypeNode::Ideal(phase, can_reshape);\n+    if (progress != nullptr) {\n+      return progress;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1521,1 +1521,2 @@\n-  if (result_is_unused) {\n+  bool not_dead = proj_out_or_null(TypeFunc::Control) != nullptr;\n+  if (result_is_unused && not_dead) {\n@@ -1572,1 +1573,2 @@\n-  if (result_is_unused) {\n+  bool not_dead = proj_out_or_null(TypeFunc::Control) != nullptr;\n+  if (result_is_unused && not_dead) {\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2166,1 +2166,5 @@\n-  case Op_NeverBranch:\n+  case Op_NeverBranch: {\n+    Node* succ = n->as_NeverBranch()->proj_out(0)->unique_ctrl_out();\n+    if (_succs[i]->head() == succ) {\n+      return 1.0f;\n+    }\n@@ -2168,0 +2172,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -543,26 +543,2 @@\n-  bool must_throw = true;\n-\n-  \/\/ If this particular condition has not yet happened at this\n-  \/\/ bytecode, then use the uncommon trap mechanism, and allow for\n-  \/\/ a future recompilation if several traps occur here.\n-  \/\/ If the throw is hot, try to use a more complicated inline mechanism\n-  \/\/ which keeps execution inside the compiled code.\n-  bool treat_throw_as_hot = false;\n-  ciMethodData* md = method()->method_data();\n-\n-  if (ProfileTraps) {\n-    if (too_many_traps(reason)) {\n-      treat_throw_as_hot = true;\n-    }\n-    \/\/ (If there is no MDO at all, assume it is early in\n-    \/\/ execution, and that any deopts are part of the\n-    \/\/ startup transient, and don't need to be remembered.)\n-\n-    \/\/ Also, if there is a local exception handler, treat all throws\n-    \/\/ as hot if there has been at least one in this method.\n-    if (C->trap_count(reason) != 0\n-        && method()->method_data()->trap_count(reason) != 0\n-        && has_exception_handler()) {\n-        treat_throw_as_hot = true;\n-    }\n-  }\n+  builtin_throw(reason, builtin_throw_exception(reason), \/*allow_too_many_traps*\/ true);\n+}\n@@ -570,0 +546,3 @@\n+void GraphKit::builtin_throw(Deoptimization::DeoptReason reason,\n+                             ciInstance* ex_obj,\n+                             bool allow_too_many_traps) {\n@@ -576,29 +555,8 @@\n-  if (treat_throw_as_hot && method()->can_omit_stack_trace()) {\n-    \/\/ If the throw is local, we use a pre-existing instance and\n-    \/\/ punt on the backtrace.  This would lead to a missing backtrace\n-    \/\/ (a repeat of 4292742) if the backtrace object is ever asked\n-    \/\/ for its backtrace.\n-    \/\/ Fixing this remaining case of 4292742 requires some flavor of\n-    \/\/ escape analysis.  Leave that for the future.\n-    ciInstance* ex_obj = nullptr;\n-    switch (reason) {\n-    case Deoptimization::Reason_null_check:\n-      ex_obj = env()->NullPointerException_instance();\n-      break;\n-    case Deoptimization::Reason_div0_check:\n-      ex_obj = env()->ArithmeticException_instance();\n-      break;\n-    case Deoptimization::Reason_range_check:\n-      ex_obj = env()->ArrayIndexOutOfBoundsException_instance();\n-      break;\n-    case Deoptimization::Reason_class_check:\n-      ex_obj = env()->ClassCastException_instance();\n-      break;\n-    case Deoptimization::Reason_array_check:\n-      ex_obj = env()->ArrayStoreException_instance();\n-      break;\n-    default:\n-      break;\n-    }\n-    \/\/ If we have a preconstructed exception object, use it.\n-    if (ex_obj != nullptr) {\n+  if (is_builtin_throw_hot(reason)) {\n+    if (method()->can_omit_stack_trace() && ex_obj != nullptr) {\n+      \/\/ If the throw is local, we use a pre-existing instance and\n+      \/\/ punt on the backtrace.  This would lead to a missing backtrace\n+      \/\/ (a repeat of 4292742) if the backtrace object is ever asked\n+      \/\/ for its backtrace.\n+      \/\/ Fixing this remaining case of 4292742 requires some flavor of\n+      \/\/ escape analysis.  Leave that for the future.\n@@ -607,1 +565,1 @@\n-        uncommon_trap_if_should_post_on_exceptions(reason, must_throw);\n+        uncommon_trap_if_should_post_on_exceptions(reason, true \/*must_throw*\/);\n@@ -638,0 +596,12 @@\n+    } else if (builtin_throw_too_many_traps(reason, ex_obj)) {\n+      \/\/ We cannot afford to take too many traps here. Suffer in the interpreter instead.\n+      assert(allow_too_many_traps, \"not allowed\");\n+      if (C->log() != nullptr) {\n+        C->log()->elem(\"hot_throw preallocated='0' reason='%s' mcount='%d'\",\n+                       Deoptimization::trap_reason_name(reason),\n+                       C->trap_count(reason));\n+      }\n+      uncommon_trap(reason, Deoptimization::Action_none,\n+                    (ciKlass*) nullptr, (char*) nullptr,\n+                    true \/*must_throw*\/);\n+      return;\n@@ -649,13 +619,0 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n-  Deoptimization::DeoptAction action = Deoptimization::Action_maybe_recompile;\n-  if (treat_throw_as_hot\n-      && (method()->method_data()->trap_recompiled_at(bci(), m)\n-          || C->too_many_traps(reason))) {\n-    \/\/ We cannot afford to take more traps here.  Suffer in the interpreter.\n-    if (C->log() != nullptr)\n-      C->log()->elem(\"hot_throw preallocated='0' reason='%s' mcount='%d'\",\n-                     Deoptimization::trap_reason_name(reason),\n-                     C->trap_count(reason));\n-    action = Deoptimization::Action_none;\n-  }\n-\n@@ -666,0 +623,18 @@\n+  uncommon_trap(reason, Deoptimization::Action_maybe_recompile,\n+                (ciKlass*) nullptr, (char*) nullptr,\n+                true \/*must_throw*\/);\n+}\n+\n+bool GraphKit::is_builtin_throw_hot(Deoptimization::DeoptReason reason) {\n+  \/\/ If this particular condition has not yet happened at this\n+  \/\/ bytecode, then use the uncommon trap mechanism, and allow for\n+  \/\/ a future recompilation if several traps occur here.\n+  \/\/ If the throw is hot, try to use a more complicated inline mechanism\n+  \/\/ which keeps execution inside the compiled code.\n+  if (ProfileTraps) {\n+    if (too_many_traps(reason)) {\n+      return true;\n+    }\n+    \/\/ (If there is no MDO at all, assume it is early in\n+    \/\/ execution, and that any deopts are part of the\n+    \/\/ startup transient, and don't need to be remembered.)\n@@ -667,1 +642,9 @@\n-  uncommon_trap(reason, action, (ciKlass*)nullptr, (char*)nullptr, must_throw);\n+    \/\/ Also, if there is a local exception handler, treat all throws\n+    \/\/ as hot if there has been at least one in this method.\n+    if (C->trap_count(reason) != 0 &&\n+        method()->method_data()->trap_count(reason) != 0 &&\n+        has_exception_handler()) {\n+      return true;\n+    }\n+  }\n+  return false;\n@@ -670,0 +653,32 @@\n+bool GraphKit::builtin_throw_too_many_traps(Deoptimization::DeoptReason reason,\n+                                            ciInstance* ex_obj) {\n+  if (is_builtin_throw_hot(reason)) {\n+    if (method()->can_omit_stack_trace() && ex_obj != nullptr) {\n+      return false; \/\/ no traps; throws preallocated exception instead\n+    }\n+    ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n+    if (method()->method_data()->trap_recompiled_at(bci(), m) ||\n+        C->too_many_traps(reason)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+ciInstance* GraphKit::builtin_throw_exception(Deoptimization::DeoptReason reason) const {\n+  \/\/ Preallocated exception objects to use when we don't need the backtrace.\n+  switch (reason) {\n+  case Deoptimization::Reason_null_check:\n+    return env()->NullPointerException_instance();\n+  case Deoptimization::Reason_div0_check:\n+    return env()->ArithmeticException_instance();\n+  case Deoptimization::Reason_range_check:\n+    return env()->ArrayIndexOutOfBoundsException_instance();\n+  case Deoptimization::Reason_class_check:\n+    return env()->ClassCastException_instance();\n+  case Deoptimization::Reason_array_check:\n+    return env()->ArrayStoreException_instance();\n+  default:\n+    return nullptr;\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":85,"deletions":70,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -290,0 +290,10 @@\n+  void builtin_throw(Deoptimization::DeoptReason reason,\n+                     ciInstance* exception_object,\n+                     bool allow_too_many_traps);\n+  bool builtin_throw_too_many_traps(Deoptimization::DeoptReason reason,\n+                                    ciInstance* exception_object);\n+ private:\n+  bool is_builtin_throw_hot(Deoptimization::DeoptReason reason);\n+  ciInstance* builtin_throw_exception(Deoptimization::DeoptReason reason) const;\n+\n+ public:\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2015,1 +2015,8 @@\n-void LibraryCallKit::inline_math_mathExact(Node* math, Node *test) {\n+bool LibraryCallKit::inline_math_mathExact(Node* math, Node* test) {\n+  if (builtin_throw_too_many_traps(Deoptimization::Reason_intrinsic,\n+                                   env()->ArithmeticException_instance())) {\n+    \/\/ It has been already too many times, but we cannot use builtin_throw (e.g. we care about backtraces),\n+    \/\/ so let's bail out intrinsic rather than risking deopting again.\n+    return false;\n+  }\n+\n@@ -2029,2 +2036,3 @@\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_none);\n+    builtin_throw(Deoptimization::Reason_intrinsic,\n+                  env()->ArithmeticException_instance(),\n+                  \/*allow_too_many_traps*\/ false);\n@@ -2035,0 +2043,1 @@\n+  return true;\n@@ -2044,2 +2053,1 @@\n-  inline_math_mathExact(operation, ofcheck);\n-  return true;\n+  return inline_math_mathExact(operation, ofcheck);\n@@ -4547,6 +4555,1 @@\n-    Node* cast = _gvn.transform(new CastPPNode(is_array_ctrl, *obj, TypeAryPtr::BOTTOM));\n-    \/\/ Check for top because in rare cases, the type system can determine that\n-    \/\/ the object can't be an array but the layout helper check is not folded.\n-    if (!cast->is_top()) {\n-      *obj = cast;\n-    }\n+    *obj = _gvn.transform(new CastPPNode(is_array_ctrl, *obj, TypeAryPtr::BOTTOM));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-  void inline_math_mathExact(Node* math, Node* test);\n+  bool inline_math_mathExact(Node* math, Node* test);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = nullptr);\n+  void insert_mem_bar(Node** ctrl, Node** mem, int opcode, int alias_idx, Node* precedent = nullptr);\n@@ -182,1 +182,1 @@\n-  bool generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,\n+  void generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-void PhaseMacroExpand::insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent) {\n-  MemBarNode* mb = MemBarNode::make(C, opcode, Compile::AliasIdxBot, precedent);\n+void PhaseMacroExpand::insert_mem_bar(Node** ctrl, Node** mem, int opcode, int alias_idx, Node* precedent) {\n+  MemBarNode* mb = MemBarNode::make(C, opcode, alias_idx, precedent);\n@@ -49,1 +49,8 @@\n-  *mem = mem_proj;\n+  if (alias_idx == Compile::AliasIdxBot) {\n+    *mem = mem_proj;\n+  } else {\n+    MergeMemNode* mm = (*mem)->clone()->as_MergeMem();\n+    mm->set_memory_at(alias_idx, mem_proj);\n+    transform_later(mm);\n+    *mem = mm;\n+  }\n@@ -729,1 +736,0 @@\n-  bool is_partial_array_copy = false;\n@@ -735,4 +741,4 @@\n-    is_partial_array_copy = generate_unchecked_arraycopy(&local_ctrl, &local_mem,\n-                                                         adr_type, copy_type, disjoint_bases,\n-                                                         src, src_offset, dest, dest_offset,\n-                                                         ConvI2X(copy_length), acopy_to_uninitialized);\n+    generate_unchecked_arraycopy(&local_ctrl, &local_mem,\n+                                 adr_type, copy_type, disjoint_bases,\n+                                 src, src_offset, dest, dest_offset,\n+                                 ConvI2X(copy_length), acopy_to_uninitialized);\n@@ -882,1 +888,2 @@\n-    insert_mem_bar(ctrl, &out_mem, Op_MemBarStoreStore);\n+    assert(ac->_dest_type == TypeOopPtr::BOTTOM, \"non escaping destination shouldn't have narrow slice\");\n+    insert_mem_bar(ctrl, &out_mem, Op_MemBarStoreStore, Compile::AliasIdxBot);\n@@ -884,1 +891,9 @@\n-    insert_mem_bar(ctrl, &out_mem, Op_MemBarCPUOrder);\n+    int mem_bar_alias_idx = Compile::AliasIdxBot;\n+    if (ac->_dest_type != TypeOopPtr::BOTTOM) {\n+      \/\/ The graph was transformed under the assumption the ArrayCopy node only had an effect on a narrow slice. We can't\n+      \/\/ insert a wide membar now that it's being expanded: a load that uses the input memory state of the ArrayCopy\n+      \/\/ could then become anti dependent on the membar when it was not anti dependent on the ArrayCopy leading to a\n+      \/\/ broken graph.\n+      mem_bar_alias_idx = C->get_alias_index(ac->_dest_type->add_offset(Type::OffsetBot)->is_ptr());\n+    }\n+    insert_mem_bar(ctrl, &out_mem, Op_MemBarCPUOrder, mem_bar_alias_idx);\n@@ -887,5 +902,3 @@\n-  if (is_partial_array_copy) {\n-    assert((*ctrl)->is_Proj(), \"MemBar control projection\");\n-    assert((*ctrl)->in(0)->isa_MemBar(), \"MemBar node\");\n-    (*ctrl)->in(0)->isa_MemBar()->set_trailing_partial_array_copy();\n-  }\n+  assert((*ctrl)->is_Proj(), \"MemBar control projection\");\n+  assert((*ctrl)->in(0)->isa_MemBar(), \"MemBar node\");\n+  (*ctrl)->in(0)->isa_MemBar()->set_trailing_expanded_array_copy();\n@@ -901,1 +914,1 @@\n-  if (dest_t->is_known_instance() && !is_partial_array_copy) {\n+  if (dest_t->is_known_instance()) {\n@@ -1246,1 +1259,1 @@\n-bool PhaseMacroExpand::generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,\n+void PhaseMacroExpand::generate_unchecked_arraycopy(Node** ctrl, MergeMemNode** mem,\n@@ -1253,1 +1266,3 @@\n-  if ((*ctrl)->is_top()) return false;\n+  if ((*ctrl)->is_top()) {\n+    return;\n+  }\n@@ -1298,2 +1313,0 @@\n-    return true;\n-  return false;\n@@ -1387,1 +1400,5 @@\n-      insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n+      int mem_bar_alias_idx = Compile::AliasIdxBot;\n+      if (ac->_dest_type != TypeOopPtr::BOTTOM) {\n+        mem_bar_alias_idx = C->get_alias_index(ac->_dest_type->add_offset(Type::OffsetBot)->is_ptr());\n+      }\n+      insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder, mem_bar_alias_idx);\n@@ -1449,1 +1466,1 @@\n-      insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n+      insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder, Compile::AliasIdxBot);\n@@ -1510,1 +1527,5 @@\n-    insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder);\n+    int mem_bar_alias_idx = Compile::AliasIdxBot;\n+    if (ac->_dest_type != TypeOopPtr::BOTTOM) {\n+      mem_bar_alias_idx = C->get_alias_index(ac->_dest_type->add_offset(Type::OffsetBot)->is_ptr());\n+    }\n+    insert_mem_bar(&ctrl, &mem, Op_MemBarCPUOrder, mem_bar_alias_idx);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -407,4 +407,11 @@\n-    \/\/ compress paths and change unreachable cycles to TOP\n-    \/\/ If not, we can update the input infinitely along a MergeMem cycle\n-    \/\/ Equivalent code in PhiNode::Ideal\n-    Node* m  = phase->transform(mmem);\n+    \/\/ IGVN _delay_transform may be set to true and if that is the case and mmem\n+    \/\/ is already a registered node then the validation inside transform will\n+    \/\/ complain.\n+    Node* m = mmem;\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    if (igvn == nullptr || !igvn->delay_transform()) {\n+      \/\/ compress paths and change unreachable cycles to TOP\n+      \/\/ If not, we can update the input infinitely along a MergeMem cycle\n+      \/\/ Equivalent code in PhiNode::Ideal\n+      m = phase->transform(mmem);\n+    }\n@@ -2367,4 +2374,2 @@\n-        !tkls->is_instklassptr()->instance_klass()->is_java_lang_Object() \/\/ not the supertype of all T[] and specifically not Serializable & Cloneable\n-        ) {\n-      \/\/ Note:  When interfaces are reliable, we can narrow the interface\n-      \/\/ test to (klass != Serializable && klass != Cloneable).\n+        !tkls->is_instklassptr()->might_be_an_array() \/\/ not the supertype of all T[] (java.lang.Object) or has an interface that is not Serializable or Cloneable\n+    ) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1182,1 +1182,1 @@\n-    TrailingPartialArrayCopy\n+    TrailingExpandedArrayCopy\n@@ -1219,2 +1219,2 @@\n-  void set_trailing_partial_array_copy() { _kind = TrailingPartialArrayCopy; }\n-  bool trailing_partial_array_copy() const { return _kind == TrailingPartialArrayCopy; }\n+  void set_trailing_expanded_array_copy() { _kind = TrailingExpandedArrayCopy; }\n+  bool trailing_expanded_array_copy() const { return _kind == TrailingExpandedArrayCopy; }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1006,4 +1006,3 @@\n-\/\/=============================================================================\n-\n-static bool const_shift_count(PhaseGVN* phase, Node* shiftNode, int* count) {\n-  const TypeInt* tcount = phase->type(shiftNode->in(2))->isa_int();\n+\/\/ Returns whether the shift amount is constant. If so, sets count.\n+static bool const_shift_count(PhaseGVN* phase, const Node* shift_node, int* count) {\n+  const TypeInt* tcount = phase->type(shift_node->in(2))->isa_int();\n@@ -1017,5 +1016,22 @@\n-static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, uint nBits) {\n-  int count = 0;\n-  if (const_shift_count(phase, shiftNode, &count)) {\n-    int maskedShift = count & (nBits - 1);\n-    if (maskedShift == 0) {\n+\/\/ Returns whether the shift amount is constant. If so, sets real_shift and masked_shift.\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, int& masked_shift) {\n+  if (const_shift_count(phase, shift_node, &real_shift)) {\n+    masked_shift = real_shift & (nBits - 1);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ Convenience for when we don't care about the real amount\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& masked_shift) {\n+  int real_shift;\n+  return mask_shift_amount(phase, shift_node, nBits, real_shift, masked_shift);\n+}\n+\n+\/\/ Use this in ::Ideal only with shiftNode == this!\n+\/\/ Returns the masked shift amount if constant or 0 if not constant.\n+static int mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n+  int real_shift;\n+  int masked_shift;\n+  if (mask_shift_amount(phase, shift_node, nBits, real_shift, masked_shift)) {\n+    if (masked_shift == 0) {\n@@ -1026,2 +1042,1 @@\n-    if (count != maskedShift) {\n-      shiftNode->set_req(2, phase->intcon(maskedShift)); \/\/ Replace shift count with masked value.\n+    if (real_shift != masked_shift) {\n@@ -1029,2 +1044,2 @@\n-      if (igvn) {\n-        igvn->rehash_node_delayed(shiftNode);\n+      if (igvn != nullptr) {\n+        igvn->_worklist.push(shift_node);\n@@ -1032,0 +1047,1 @@\n+      shift_node->set_req(2, phase->intcon(masked_shift)); \/\/ Replace shift count with masked value.\n@@ -1033,1 +1049,1 @@\n-    return maskedShift;\n+    return masked_shift;\n@@ -1035,0 +1051,1 @@\n+  \/\/ Not a shift by a constant.\n@@ -1039,1 +1056,1 @@\n-\/\/    outer_shift = (_ << con0)\n+\/\/   outer_shift = (_ << rhs_outer)\n@@ -1041,4 +1058,5 @@\n-\/\/   outer_shift = ((X << con1) << con0)\n-\/\/   we denote inner_shift the nested expression (X << con1)\n-\/\/\n-\/\/ con0 and con1 are both in [0..nbits), as they are computed by maskShiftAmount.\n+\/\/   outer_shift = ((X << rhs_inner) << rhs_outer)\n+\/\/   where rhs_outer and rhs_inner are constant\n+\/\/   we denote inner_shift the nested expression (X << rhs_inner)\n+\/\/   con_inner = rhs_inner % nbits and con_outer = rhs_outer % nbits\n+\/\/   where nbits is the number of bits of the shifts\n@@ -1047,3 +1065,3 @@\n-\/\/ if con0 + con1 >= nbits => 0\n-\/\/ if con0 + con1 < nbits => X << (con1 + con0)\n-static Node* collapse_nested_shift_left(PhaseGVN* phase, Node* outer_shift, int con0, BasicType bt) {\n+\/\/ if con_outer + con_inner >= nbits => 0\n+\/\/ if con_outer + con_inner < nbits => X << (con_outer + con_inner)\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, int con_outer, BasicType bt) {\n@@ -1051,2 +1069,1 @@\n-  int nbits = static_cast<int>(bits_per_java_integer(bt));\n-  Node* inner_shift = outer_shift->in(1);\n+  const Node* inner_shift = outer_shift->in(1);\n@@ -1057,2 +1074,8 @@\n-  int con1 = maskShiftAmount(phase, inner_shift, nbits);\n-  if (con1 == 0) { \/\/ Either non-const, or actually 0 (up to mask) and then delegated to Identity()\n+  int nbits = static_cast<int>(bits_per_java_integer(bt));\n+  int con_inner;\n+  if (!mask_shift_amount(phase, inner_shift, nbits, con_inner)) {\n+    return nullptr;\n+  }\n+\n+  if (con_inner == 0) {\n+    \/\/ We let the Identity() of the inner shift do its job.\n@@ -1062,1 +1085,1 @@\n-  if (con0 + con1 >= nbits) {\n+  if (con_outer + con_inner >= nbits) {\n@@ -1071,1 +1094,1 @@\n-  Node* con0_plus_con1 = phase->intcon(con0 + con1);\n+  Node* con0_plus_con1 = phase->intcon(con_outer + con_inner);\n@@ -1092,1 +1115,1 @@\n-  int con = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaInteger);\n@@ -1278,1 +1301,1 @@\n-  int con = maskShiftAmount(phase, this, BitsPerJavaLong);\n+  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaLong);\n@@ -1499,1 +1522,1 @@\n-  int shift = maskShiftAmount(phase, this, bits_per_java_integer(bt));\n+  int shift = mask_and_replace_shift_amount(phase, this, bits_per_java_integer(bt));\n@@ -1529,1 +1552,1 @@\n-  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  int shift = mask_and_replace_shift_amount(phase, this, BitsPerJavaInteger);\n@@ -1716,1 +1739,1 @@\n-  int con = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaInteger);\n@@ -1880,1 +1903,1 @@\n-  int con = maskShiftAmount(phase, this, BitsPerJavaLong);\n+  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaLong);\n@@ -2234,1 +2257,0 @@\n-  expr = expr->uncast();\n@@ -2240,0 +2262,6 @@\n+  expr = expr->uncast();\n+  type = phase->type(expr)->isa_integer(bt);\n+  if (type == nullptr) {\n+    return 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":63,"deletions":35,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -3086,0 +3086,75 @@\n+\n+void TypeNode::make_path_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, Node* ctrl_use, uint j, const char* phase_str) {\n+  Node* c = ctrl_use->in(j);\n+  if (igvn->type(c) != Type::TOP) {\n+    igvn->replace_input_of(ctrl_use, j, igvn->C->top());\n+    create_halt_path(igvn, c, loop, phase_str);\n+  }\n+}\n+\n+\/\/ This Type node is dead. It could be because the type that it captures and the type of the node computed from its\n+\/\/ inputs do not intersect anymore. That node has some uses along some control flow paths. Those control flow paths must\n+\/\/ be unreachable as using a dead value makes no sense. For the Type node to capture a narrowed down type, some control\n+\/\/ flow construct must guard the Type node (an If node usually). When the Type node becomes dead, the guard usually\n+\/\/ constant folds and the control flow that leads to the Type node becomes unreachable. There are cases where that\n+\/\/ doesn't happen, however. They are handled here by following uses of the Type node until a CFG or a Phi to find dead\n+\/\/ paths. The dead paths are then replaced by a Halt node.\n+void TypeNode::make_paths_from_here_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, const char* phase_str) {\n+  Unique_Node_List wq;\n+  wq.push(this);\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (DUIterator_Fast kmax, k = n->fast_outs(kmax); k < kmax; k++) {\n+      Node* u = n->fast_out(k);\n+      if (u->is_CFG()) {\n+        assert(!u->is_Region(), \"Can't reach a Region without going through a Phi\");\n+        make_path_dead(igvn, loop, u, 0, phase_str);\n+      } else if (u->is_Phi()) {\n+        Node* r = u->in(0);\n+        assert(r->is_Region() || r->is_top(), \"unexpected Phi's control\");\n+        if (r->is_Region()) {\n+          for (uint j = 1; j < u->req(); ++j) {\n+            if (u->in(j) == n) {\n+              make_path_dead(igvn, loop, r, j, phase_str);\n+            }\n+          }\n+        }\n+      } else {\n+        wq.push(u);\n+      }\n+    }\n+  }\n+}\n+\n+void TypeNode::create_halt_path(PhaseIterGVN* igvn, Node* c, PhaseIdealLoop* loop, const char* phase_str) const {\n+  Node* frame = new ParmNode(igvn->C->start(), TypeFunc::FramePtr);\n+  if (loop == nullptr) {\n+    igvn->register_new_node_with_optimizer(frame);\n+  } else {\n+    loop->register_new_node(frame, igvn->C->start());\n+  }\n+\n+  stringStream ss;\n+  ss.print(\"dead path discovered by TypeNode during %s\", phase_str);\n+\n+  Node* halt = new HaltNode(c, frame, ss.as_string(igvn->C->comp_arena()));\n+  if (loop == nullptr) {\n+    igvn->register_new_node_with_optimizer(halt);\n+  } else {\n+    loop->register_control(halt, loop->ltree_root(), c);\n+  }\n+  igvn->add_input_to(igvn->C->root(), halt);\n+}\n+\n+Node* TypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (KillPathsReachableByDeadTypeNode && can_reshape && Value(phase) == Type::TOP) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    Node* top = igvn->C->top();\n+    ResourceMark rm;\n+    make_paths_from_here_dead(igvn, nullptr, \"igvn\");\n+    return top;\n+  }\n+\n+  return Node::Ideal(phase, can_reshape);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -161,0 +161,1 @@\n+class PhaseIdealLoop;\n@@ -2061,0 +2062,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -2063,0 +2065,2 @@\n+\n+  void make_path_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, Node* ctrl_use, uint j, const char* phase_str);\n@@ -2067,0 +2071,2 @@\n+  void make_paths_from_here_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, const char* phase_str);\n+  void create_halt_path(PhaseIterGVN* igvn, Node* c, PhaseIdealLoop* loop, const char* phase_str) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1888,0 +1888,5 @@\n+    if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n+      \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+      \/\/ nodes that become dead.\n+      _maybe_top_type_nodes.push(n);\n+    }\n@@ -2059,3 +2064,3 @@\n-\/\/ AndI\/L::Value() optimizes patterns similar to (v << 2) & 3 to zero if they are bitwise disjoint.\n-\/\/ Add the AndI\/L nodes back to the worklist to re-apply Value() in case the shift value changed.\n-\/\/ Pattern: parent -> LShift (use) -> (ConstraintCast | ConvI2L)* -> And\n+\/\/ AndI\/L::Value() optimizes patterns similar to (v << 2) & 3, or CON & 3 to zero if they are bitwise disjoint.\n+\/\/ Add the AndI\/L nodes back to the worklist to re-apply Value() in case the value is now a constant or shift\n+\/\/ value changed.\n@@ -2063,0 +2068,1 @@\n+  const TypeInteger* parent_type = type(parent)->isa_integer(type(parent)->basic_type());\n@@ -2064,3 +2070,7 @@\n-  if ((use_op == Op_LShiftI || use_op == Op_LShiftL)\n-      && use->in(2) == parent) { \/\/ is shift value (right-hand side of LShift)\n-    auto push_and_uses_to_worklist = [&](Node* n){\n+  if (\n+    \/\/ Pattern: parent (now constant) -> (ConstraintCast | ConvI2L)* -> And\n+    (parent_type != nullptr && parent_type->is_con()) ||\n+    \/\/ Pattern: parent -> LShift (use) -> (ConstraintCast | ConvI2L)* -> And\n+    ((use_op == Op_LShiftI || use_op == Op_LShiftL) && use->in(2) == parent)) {\n+\n+    auto push_and_uses_to_worklist = [&](Node* n) {\n@@ -2126,0 +2136,12 @@\n+  if (KillPathsReachableByDeadTypeNode) {\n+    for (uint i = 0; i < _maybe_top_type_nodes.size(); ++i) {\n+      Node* type_node = _maybe_top_type_nodes.at(i);\n+      if (type(type_node) == Type::TOP) {\n+        ResourceMark rm;\n+        type_node->as_Type()->make_paths_from_here_dead(this, nullptr, \"ccp\");\n+      }\n+    }\n+  } else {\n+    assert(_maybe_top_type_nodes.size() == 0, \"we don't need type nodes\");\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -613,0 +613,1 @@\n+  Unique_Node_List _maybe_top_type_nodes;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3821,0 +3821,6 @@\n+bool TypeInterfaces::has_non_array_interface() const {\n+  assert(TypeAryPtr::_array_interfaces != nullptr, \"How come Type::Initialize_shared wasn't called yet?\");\n+\n+  return !TypeAryPtr::_array_interfaces->contains(this);\n+}\n+\n@@ -6690,0 +6696,13 @@\n+bool TypeInstKlassPtr::might_be_an_array() const {\n+  if (!instance_klass()->is_java_lang_Object()) {\n+    \/\/ TypeInstKlassPtr can be an array only if it is java.lang.Object: the only supertype of array types.\n+    return false;\n+  }\n+  if (interfaces()->has_non_array_interface()) {\n+    \/\/ Arrays only implement Cloneable and Serializable. If we see any other interface, [this] cannot be an array.\n+    return false;\n+  }\n+  \/\/ Cannot prove it's not an array.\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -982,0 +982,1 @@\n+  bool has_non_array_interface() const;\n@@ -1484,0 +1485,1 @@\n+  friend class TypeInterfaces;\n@@ -1799,0 +1801,2 @@\n+  bool might_be_an_array() const;\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1093,1 +1093,2 @@\n-bool WhiteBox::validate_cgroup(const char* proc_cgroups,\n+bool WhiteBox::validate_cgroup(bool cgroups_v2_enabled,\n+                               const char* controllers_file,\n@@ -1098,1 +1099,1 @@\n-  return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,\n+  return CgroupSubsystemFactory::determine_type(cg_infos, cgroups_v2_enabled, controllers_file,\n@@ -2629,1 +2630,2 @@\n-                                    jstring proc_cgroups,\n+                                    jboolean cgroups_v2_enabled,\n+                                    jstring controllers_file,\n@@ -2635,1 +2637,1 @@\n-  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, nullptr);\n+  const char* c_file = env->GetStringUTFChars(controllers_file, nullptr);\n@@ -2643,1 +2645,1 @@\n-  WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &cg_type_flags);\n+  WhiteBox::validate_cgroup(cgroups_v2_enabled, c_file, p_s_cgroup, p_s_mountinfo, &cg_type_flags);\n@@ -2645,1 +2647,1 @@\n-  env->ReleaseStringUTFChars(proc_cgroups, p_cgroups);\n+  env->ReleaseStringUTFChars(controllers_file, c_file);\n@@ -3091,1 +3093,1 @@\n-      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)I\",\n+      CC\"(ZLjava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)I\",\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3792,1 +3792,1 @@\n-  CDSConfig::initialize();\n+  CDSConfig::ergo_initialize();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1784,0 +1784,3 @@\n+          if (UseObjectMonitorTable) {\n+            lock->clear_object_monitor_cache();\n+          }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -753,0 +753,2 @@\n+  do_stub(compiler, double_keccak)                                      \\\n+  do_entry(compiler, double_keccak, double_keccak, double_keccak)       \\\n@@ -756,2 +758,0 @@\n-  do_stub(compiler, double_keccak)                                      \\\n-  do_entry(compiler, double_keccak, double_keccak, double_keccak)       \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -388,2 +388,1 @@\n-      \/\/ that we own, we can transfer one or more threads from the waitset\n-      \/\/ to the entry_list here and now, avoiding the slow-path.\n+      \/\/ that we own, we quickly notify them here and now, avoiding the slow-path.\n@@ -391,1 +390,1 @@\n-        DTRACE_MONITOR_PROBE(notifyAll, mon, obj, current);\n+        mon->quick_notifyAll(current);\n@@ -393,1 +392,1 @@\n-        DTRACE_MONITOR_PROBE(notify, mon, obj, current);\n+        mon->quick_notify(current);\n@@ -395,3 +394,0 @@\n-      do {\n-        mon->notify_internal(current);\n-      } while (mon->first_waiter() != nullptr && all);\n@@ -716,1 +712,2 @@\n-      entered = LightweightSynchronizer::inflate_and_enter(obj(), inflate_cause_jni_enter, current, current) != nullptr;\n+      BasicLock lock;\n+      entered = LightweightSynchronizer::inflate_and_enter(obj(), &lock, inflate_cause_jni_enter, current, current) != nullptr;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -3270,1 +3271,1 @@\n-  char* my_path;\n+  char my_path[JVM_MAXPATHLEN];\n@@ -3272,3 +3273,1 @@\n-\n-  const char* dump_file_name = \"java_pid\";\n-  const char* dump_file_ext  = HeapDumpGzipLevel > 0 ? \".hprof.gz\" : \".hprof\";\n+  const char* dump_file_name = HeapDumpGzipLevel > 0 ? \"java_pid%p.hprof.gz\" : \"java_pid%p.hprof\";\n@@ -3280,7 +3279,3 @@\n-    \/\/ Calculate potentially longest base path and check if we have enough\n-    \/\/ allocated statically.\n-    const size_t total_length =\n-                      (HeapDumpPath == nullptr ? 0 : strlen(HeapDumpPath)) +\n-                      strlen(os::file_separator()) + max_digit_chars +\n-                      strlen(dump_file_name) + strlen(dump_file_ext) + 1;\n-    if (total_length > sizeof(base_path)) {\n+    \/\/ Set base path (name or directory, default or custom, without seq no), doing %p substitution.\n+    const char *path_src = (HeapDumpPath != nullptr && HeapDumpPath[0] != '\\0') ? HeapDumpPath : dump_file_name;\n+    if (!Arguments::copy_expand_pid(path_src, strlen(path_src), base_path, JVM_MAXPATHLEN - max_digit_chars)) {\n@@ -3290,21 +3285,11 @@\n-\n-    bool use_default_filename = true;\n-    if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n-      \/\/ HeapDumpPath=<file> not specified\n-    } else {\n-      strcpy(base_path, HeapDumpPath);\n-      \/\/ check if the path is a directory (must exist)\n-      DIR* dir = os::opendir(base_path);\n-      if (dir == nullptr) {\n-        use_default_filename = false;\n-      } else {\n-        \/\/ HeapDumpPath specified a directory. We append a file separator\n-        \/\/ (if needed).\n-        os::closedir(dir);\n-        size_t fs_len = strlen(os::file_separator());\n-        if (strlen(base_path) >= fs_len) {\n-          char* end = base_path;\n-          end += (strlen(base_path) - fs_len);\n-          if (strcmp(end, os::file_separator()) != 0) {\n-            strcat(base_path, os::file_separator());\n-          }\n+    \/\/ Check if the path is an existing directory\n+    DIR* dir = os::opendir(base_path);\n+    if (dir != nullptr) {\n+      os::closedir(dir);\n+      \/\/ Path is a directory.  Append a file separator (if needed).\n+      size_t fs_len = strlen(os::file_separator());\n+      if (strlen(base_path) >= fs_len) {\n+        char* end = base_path;\n+        end += (strlen(base_path) - fs_len);\n+        if (strcmp(end, os::file_separator()) != 0) {\n+          strcat(base_path, os::file_separator());\n@@ -3313,0 +3298,7 @@\n+      \/\/ Then add the default name, with %p substitution.  Use my_path temporarily.\n+      if (!Arguments::copy_expand_pid(dump_file_name, strlen(dump_file_name), my_path, JVM_MAXPATHLEN - max_digit_chars)) {\n+        warning(\"Cannot create heap dump file.  HeapDumpPath is too long.\");\n+        return;\n+      }\n+      const size_t dlen = strlen(base_path);\n+      jio_snprintf(&base_path[dlen], sizeof(base_path) - dlen, \"%s\", my_path);\n@@ -3314,13 +3306,1 @@\n-    \/\/ If HeapDumpPath wasn't a file name then we append the default name\n-    if (use_default_filename) {\n-      const size_t dlen = strlen(base_path);  \/\/ if heap dump dir specified\n-      jio_snprintf(&base_path[dlen], sizeof(base_path)-dlen, \"%s%d%s\",\n-                   dump_file_name, os::current_process_id(), dump_file_ext);\n-    }\n-    const size_t len = strlen(base_path) + 1;\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n-    strncpy(my_path, base_path, len);\n+    strncpy(my_path, base_path, JVM_MAXPATHLEN);\n@@ -3330,5 +3310,0 @@\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n@@ -3342,1 +3317,0 @@\n-  os::free(my_path);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":25,"deletions":51,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2293,4 +2293,0 @@\n-\n-            public Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers() {\n-                return VirtualThread.delayedTaskSchedulers();\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -590,5 +589,0 @@\n-    \/**\n-     * Returns a stream of the delayed task schedulers used for virtual threads.\n-     *\/\n-    Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers();\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2515,1 +2515,0 @@\n-                !env.info.isNewClass &&\n@@ -2801,1 +2800,1 @@\n-            env.info.isNewClass = true;\n+            env.info.isAnonymousNewClass = tree.def != null;\n@@ -2806,1 +2805,1 @@\n-            env.info.isNewClass = false;\n+            env.info.isAnonymousNewClass = false;\n@@ -5259,1 +5258,1 @@\n-        if (!env.info.isNewClass)\n+        if (!env.info.isAnonymousNewClass)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-     *  Is this an attribution environment for an instance creation expression?\n+     *  Is this an attribution environment for an anonymous instance creation expression?\n@@ -85,1 +85,1 @@\n-    boolean isNewClass = false;\n+    boolean isAnonymousNewClass = false;\n@@ -154,1 +154,1 @@\n-        info.isNewClass = isNewClass;\n+        info.isAnonymousNewClass = isAnonymousNewClass;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -254,0 +254,7 @@\n+\n+    \/** Releases prior to JDK 23 don't allow primitive types as case labels in\n+     *  SwitchBootstrap.typeSwitch\n+     *\/\n+    public boolean switchBootstrapOnlyAllowsReferenceTypesAsCaseLabels() {\n+        return compareTo(Target.JDK1_23) < 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-compiler\/vectorapi\/VectorLogicalOpIdentityTest.java 8302459 linux-x64,windows-x64\n@@ -159,0 +158,1 @@\n+runtime\/FieldLayout\/TestOopMapSizeMinimal.java#no_coops_ccptr_coh               8348568 generic-all\n@@ -177,2 +177,0 @@\n-serviceability\/attach\/AttachAPIv2\/StreamingOutputTest.java 8352392 aix-ppc64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n@@ -205,1 +205,1 @@\n-        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n@@ -212,2 +212,2 @@\n-        Common.field1VarHandle.getAndSet(o, i);\n-        Common.field2VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field2VarHandle.getAndSet(o, i);\n@@ -401,1 +401,1 @@\n-        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n@@ -409,1 +409,1 @@\n-        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n@@ -418,1 +418,1 @@\n-        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n@@ -427,2 +427,2 @@\n-        Common.field1VarHandle.getAndSet(o, i);\n-        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n+        Common.field1VarHandle.getAndSet(o, i);\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -142,2 +142,0 @@\n-                    \"UseZbb\",\n-                    \"UseRVV\",\n@@ -146,1 +144,6 @@\n-                    \"UseCompactObjectHeaders\"\n+                    \"UseCompactObjectHeaders\",\n+                    \/\/ Riscv\n+                    \"UseRVV\",\n+                    \"UseZbb\",\n+                    \"UseZfh\",\n+                    \"UseZvbb\"\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -792,0 +792,1 @@\n+javax\/swing\/JTabbedPane\/bug4499556.java 8267500 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+tools\/javac\/valhalla\/value-objects\/LoadableDescriptorsAttrTest2.java            8357054    generic-all\n+tools\/javac\/valhalla\/value-objects\/LoadableDescriptorsAttributeTest.java        8357054    generic-all\n+tools\/javac\/valhalla\/value-objects\/NoUnnecessaryLoadableDescriptorsTest.java    8357054    generic-all\n+tools\/javac\/valhalla\/value-objects\/ValueBasedFlagsTest.java                     8357054    generic-all\n+\n","filename":"test\/langtools\/ProblemList.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -776,1 +776,2 @@\n-  public native int validateCgroup(String procCgroups,\n+  public native int validateCgroup(boolean cgroupsV2Enabled,\n+                                   String controllersFile,\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}