{"files":[{"patch":"@@ -40,0 +40,3 @@\n+ * <LI> A {@linkplain Class#isValue()} value class implements {@linkplain Serializable}\n+ *      but does not delegate to a serialization proxy using {@code writeReplace()}.\n+ * <LI> A {@linkplain Class#isValue()} value class implements {@linkplain Externalizable}.\n","filename":"src\/java.base\/share\/classes\/java\/io\/InvalidClassException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-import java.io.ObjectStreamClass.RecordSupport;\n+import java.io.ObjectStreamClass.ConstructorSupport;\n+import java.io.ObjectStreamClass.ClassDataSlot;\n@@ -34,0 +35,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -43,1 +45,2 @@\n-import java.util.Map;\n+import java.util.List;\n+import java.util.Locale;\n@@ -54,0 +57,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -249,4 +253,3 @@\n- * <p>Value objects are deserialized differently than ordinary serializable objects or records.\n- * See <a href=\"{@docRoot}\/..\/specs\/serialization\/serial-arch.html#serialization-of-value-objects\">\n- * <cite>Java Object Serialization Specification,<\/cite> Section 1.14,\n- * \"Serialization of Value Objects\"<\/a> for additional information.\n+ * <p>Value classes are {@linkplain Serializable} through the use of the serialization proxy pattern.\n+ * See {@linkplain ObjectOutputStream##valueclass-serialization value class serialization} for details.\n+ * When the proxy is deserialized it re-constructs and returns the value object.\n@@ -267,0 +270,10 @@\n+    private static final String TRACE_DEST =\n+            GetPropertyAction.privilegedGetProperty(\"TRACE\");\n+\n+    static void TRACE(String format, Object... args) {\n+        if (TRACE_DEST != null) {\n+            var ps = \"OUT\".equals(TRACE_DEST.toUpperCase(Locale.ROOT)) ? System.out : System.err;\n+            ps.println((\"TRACE \" + format).formatted(args));\n+        }\n+    }\n+\n@@ -476,0 +489,8 @@\n+     * <p>Serialization and deserialization of value classes is described in\n+     * {@linkplain ObjectOutputStream##valueclass-serialization value class serialization}.\n+     *\n+     * @implSpec\n+     * When enabled with {@code --enable-preview}, serialization and deserialization of\n+     * Core Library value classes migrated from pre-JEP 401 identity classes is\n+     * implementation specific.\n+     *\n@@ -609,0 +630,3 @@\n+     * <p>Serialization and deserialization of value classes is described in\n+     * {@linkplain ObjectOutputStream##valueclass-serialization value class serialization}.\n+     *\n@@ -2262,8 +2286,0 @@\n-        Object obj;\n-        try {\n-            obj = desc.isInstantiable() ? desc.newInstance() : null;\n-        } catch (Exception ex) {\n-            throw new InvalidClassException(desc.forClass().getName(),\n-                                            \"unable to create instance\", ex);\n-        }\n-\n@@ -2277,30 +2293,12 @@\n-        final boolean isRecord = desc.isRecord();\n-        if (isRecord) {\n-            assert obj == null;\n-            obj = readRecord(desc);\n-            if (!unshared)\n-                handles.setObject(passHandle, obj);\n-        } else if (desc.isExternalizable()) {\n-            if (desc.isValue()) {\n-                throw new InvalidClassException(\"Externalizable not valid for value class \"\n-                        + cl.getName());\n-            }\n-            if (!unshared)\n-                handles.setObject(passHandle, obj);\n-            readExternalData((Externalizable) obj, desc);\n-        } else if (desc.isValue()) {\n-            if (obj == null) {\n-                throw new InvalidClassException(\"Serializable not valid for value class \"\n-                        + cl.getName());\n-            }\n-            \/\/ For value objects, read the fields and finish the buffer before publishing the ref\n-            readSerialData(obj, desc);\n-            obj = desc.finishValue(obj);\n-            if (!unshared)\n-                handles.setObject(passHandle, obj);\n-        } else {\n-            \/\/ For all other objects, publish the ref and then read the data\n-            if (!unshared)\n-                handles.setObject(passHandle, obj);\n-            readSerialData(obj, desc);\n-        }\n+        try {\n+            \/\/ Dispatch on the factory mode to read an object from the stream.\n+            Object obj = switch (desc.factoryMode()) {\n+                case READ_OBJECT_DEFAULT -> readSerialDefaultObject(desc, unshared);\n+                case READ_OBJECT_CUSTOM -> readSerialCustomData(desc, unshared);\n+                case READ_RECORD -> readRecord(desc, unshared);\n+                case READ_EXTERNALIZABLE -> readExternalObject(desc, unshared);\n+                case READ_OBJECT_VALUE -> readObjectValue(desc, unshared);\n+                case READ_NO_LOCAL_CLASS -> readAbsentLocalClass(desc, unshared);\n+                case null -> throw new AssertionError(\"Unknown factoryMode for: \" + desc.getName(),\n+                        resolveEx);\n+            };\n@@ -2308,1 +2306,1 @@\n-        handles.finish(passHandle);\n+            handles.finish(passHandle);\n@@ -2310,15 +2308,16 @@\n-        if (obj != null &&\n-            handles.lookupException(passHandle) == null &&\n-            desc.hasReadResolveMethod())\n-        {\n-            Object rep = desc.invokeReadResolve(obj);\n-            if (unshared && rep.getClass().isArray()) {\n-                rep = cloneArray(rep);\n-            }\n-            if (rep != obj) {\n-                \/\/ Filter the replacement object\n-                if (rep != null) {\n-                    if (rep.getClass().isArray()) {\n-                        filterCheck(rep.getClass(), Array.getLength(rep));\n-                    } else {\n-                        filterCheck(rep.getClass(), -1);\n+            if (obj != null &&\n+                handles.lookupException(passHandle) == null &&\n+                desc.hasReadResolveMethod())\n+            {\n+                Object rep = desc.invokeReadResolve(obj);\n+                if (unshared && rep.getClass().isArray()) {\n+                    rep = cloneArray(rep);\n+                }\n+                if (rep != obj) {\n+                    \/\/ Filter the replacement object\n+                    if (rep != null) {\n+                        if (rep.getClass().isArray()) {\n+                            filterCheck(rep.getClass(), Array.getLength(rep));\n+                        } else {\n+                            filterCheck(rep.getClass(), -1);\n+                        }\n@@ -2326,0 +2325,1 @@\n+                    handles.setObject(passHandle, obj = rep);\n@@ -2327,1 +2327,32 @@\n-                handles.setObject(passHandle, obj = rep);\n+            }\n+\n+            return obj;\n+        } catch (UncheckedIOException uioe) {\n+            \/\/ Consistent re-throw for nested UncheckedIOExceptions\n+            throw uioe.getCause();\n+        }\n+    }\n+\n+    \/**\n+     * {@return a value class instance by invoking its constructor with field values read from the stream.\n+     * The fields of the class in the stream are matched to the local fields and applied to\n+     * the constructor.\n+     * If the stream contains superclasses with serializable fields,\n+     * an InvalidClassException is thrown with an incompatible class change message.\n+     *\n+     * @param desc the class descriptor read from the stream, the local class is a value class\n+     * @param unshared if the object is not to be shared\n+     * @throws InvalidClassException if the stream contains a superclass with serializable fields.\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private Object readObjectValue(ObjectStreamClass desc, boolean unshared) throws IOException {\n+        final ObjectStreamClass localDesc = desc.getLocalDesc();\n+        TRACE(\"readObjectValue: %s, local class: %s\", desc.getName(), localDesc.getName());\n+        \/\/ Check for un-expected fields in superclasses\n+        List<ClassDataSlot> slots = desc.getClassDataLayout();\n+        for (int i = 0; i < slots.size()-1; i++) {\n+            ClassDataSlot slot = slots.get(i);\n+            if (slot.hasData && slot.desc.getFields(false).length > 0) {\n+                throw new InvalidClassException(\"incompatible class change to value class: \" +\n+                        \"stream class has non-empty super type: \" + desc.getName());\n@@ -2330,0 +2361,2 @@\n+        \/\/ Read values for the value class fields\n+        FieldValues fieldValues = new FieldValues(desc, true);\n@@ -2331,1 +2364,15 @@\n-        return obj;\n+        \/\/ Get value object constructor adapted to take primitive value buffer and object array.\n+        MethodHandle consMH = ConstructorSupport.deserializationValueCons(desc);\n+        try {\n+            Object obj = (Object) consMH.invokeExact(fieldValues.primValues, fieldValues.objValues);\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+            return obj;\n+        } catch (Exception e) {\n+            throw new InvalidObjectException(e.getMessage(), e);\n+        } catch (Error e) {\n+            throw e;\n+        } catch (Throwable t) {\n+            throw new InvalidObjectException(\"ReflectiveOperationException \" +\n+                    \"during deserialization\", t);\n+        }\n@@ -2335,1 +2382,3 @@\n-     * If obj is non-null, reads externalizable data by invoking readExternal()\n+     * Creates a new object and invokes its readExternal method to read its contents.\n+     *\n+     * If the class is instantiable, read externalizable data by invoking readExternal()\n@@ -2338,1 +2387,2 @@\n-     * called.\n+     * called.  The new object is entered in the handle table immediately,\n+     * allowing it to leak before it is completely read.\n@@ -2340,1 +2390,1 @@\n-    private void readExternalData(Externalizable obj, ObjectStreamClass desc)\n+    private Object readExternalObject(ObjectStreamClass desc, boolean unshared)\n@@ -2343,0 +2393,17 @@\n+        TRACE(\"readExternalObject: %s\", desc.getName());\n+\n+        \/\/ For Externalizable objects,\n+        \/\/ create the instance, publish the ref, and read the data\n+        Externalizable obj = null;\n+        try {\n+            if (desc.isInstantiable()) {\n+                obj = (Externalizable) desc.newInstance();\n+            }\n+        } catch (Exception ex) {\n+            throw new InvalidClassException(desc.getName(),\n+                    \"unable to create instance\", ex);\n+        }\n+\n+        if (!unshared)\n+            handles.setObject(passHandle, obj);\n+\n@@ -2386,0 +2453,1 @@\n+        return obj;\n@@ -2394,4 +2462,5 @@\n-     **\/\n-    private Object readRecord(ObjectStreamClass desc) throws IOException {\n-        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n-        if (slots.length != 1) {\n+     *\/\n+    private Object readRecord(ObjectStreamClass desc, boolean unshared) throws IOException {\n+        TRACE(\"invoking readRecord: %s\", desc.getName());\n+        List<ClassDataSlot> slots = desc.getClassDataLayout();\n+        if (slots.size() != 1) {\n@@ -2399,3 +2468,3 @@\n-            for (int i = 0; i < slots.length-1; i++) {\n-                if (slots[i].hasData) {\n-                    new FieldValues(slots[i].desc, true);\n+            for (int i = 0; i < slots.size()-1; i++) {\n+                if (slots.get(i).hasData) {\n+                    new FieldValues(slots.get(i).desc, true);\n@@ -2415,1 +2484,1 @@\n-        MethodHandle ctrMH = RecordSupport.deserializationCtr(desc);\n+        MethodHandle ctrMH = ConstructorSupport.deserializationCtr(desc);\n@@ -2418,1 +2487,4 @@\n-            return (Object) ctrMH.invokeExact(fieldValues.primValues, fieldValues.objValues);\n+            Object obj = (Object) ctrMH.invokeExact(fieldValues.primValues, fieldValues.objValues);\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+            return obj;\n@@ -2430,1 +2502,53 @@\n-     * Reads (or attempts to skip, if obj is null or is tagged with a\n+     * Construct an object from the stream for a class that has only default read object behaviors.\n+     * For each object, the fields are read before any are assigned.\n+     * The new instance is entered in the handle table if it is unshared,\n+     * allowing it to escape before it is initialized.\n+     * The `readObject` and `readObjectNoData` methods are not present and are not called.\n+     *\n+     * @param desc the class descriptor\n+     * @param unshared true if the object should be shared\n+     * @return the object constructed from the stream data\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     * @throws InvalidClassException if the instance creation fails\n+     *\/\n+    private Object readSerialDefaultObject(ObjectStreamClass desc, boolean unshared)\n+            throws IOException, InvalidClassException {\n+        if (!desc.isInstantiable()) {\n+            \/\/ No local class to create, read and discard\n+            return readAbsentLocalClass(desc, unshared);\n+        }\n+        TRACE(\"readSerialDefaultObject: %s\", desc.getName());\n+        try {\n+            final Object obj = desc.newInstance();\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+\n+            \/\/ Best effort Failure Atomicity; slotValues will be non-null if field\n+            \/\/ values can be set after reading all field data in the hierarchy.\n+            List<FieldValues> slotValues = desc.getClassDataLayout().stream()\n+                    .filter(s -> s.hasData)\n+                    .map(s1 -> {\n+                        var values = new FieldValues(s1.desc, true);\n+                        finishBlockData(s1.desc);\n+                        return values;\n+                    })\n+                    .toList();\n+\n+            if (handles.lookupException(passHandle) != null) {\n+                return null;    \/\/ some exception for a class, do not return the object\n+            }\n+\n+            \/\/ Check that the types are assignable for all slots before assigning.\n+            slotValues.forEach(v -> v.defaultCheckFieldValues(obj));\n+            slotValues.forEach(v -> v.defaultSetFieldValues(obj));\n+            return obj;\n+        } catch (InstantiationException | InvocationTargetException ex) {\n+            throw new InvalidClassException(desc.forClass().getName(),\n+                    \"unable to create instance\", ex);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Reads (or attempts to skip, if not instantiatable or is tagged with a\n@@ -2432,2 +2556,2 @@\n-     * object in stream, from superclass to subclass.  Expects that passHandle\n-     * is set to obj's handle before this method is called.\n+     * object in stream, from superclass to subclass.\n+     * Expects that passHandle is set to current handle before this method is called.\n@@ -2435,1 +2559,1 @@\n-    private void readSerialData(Object obj, ObjectStreamClass desc)\n+    private Object readSerialCustomData(ObjectStreamClass desc, boolean unshared)\n@@ -2438,16 +2562,3 @@\n-        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n-        \/\/ Best effort Failure Atomicity; slotValues will be non-null if field\n-        \/\/ values can be set after reading all field data in the hierarchy.\n-        \/\/ Field values can only be set after reading all data if there are no\n-        \/\/ user observable methods in the hierarchy, readObject(NoData). The\n-        \/\/ top most Serializable class in the hierarchy can be skipped.\n-        FieldValues[] slotValues = null;\n-\n-        boolean hasSpecialReadMethod = false;\n-        for (int i = 1; i < slots.length; i++) {\n-            ObjectStreamClass slotDesc = slots[i].desc;\n-            if (slotDesc.hasReadObjectMethod()\n-                  || slotDesc.hasReadObjectNoDataMethod()) {\n-                hasSpecialReadMethod = true;\n-                break;\n-            }\n+        if (!desc.isInstantiable()) {\n+            \/\/ No local class to create, read and discard\n+            return readAbsentLocalClass(desc, unshared);\n@@ -2455,6 +2566,0 @@\n-        \/\/ No special read methods, can store values and defer setting.\n-        if (!hasSpecialReadMethod)\n-            slotValues = new FieldValues[slots.length];\n-\n-        for (int i = 0; i < slots.length; i++) {\n-            ObjectStreamClass slotDesc = slots[i].desc;\n@@ -2462,10 +2567,12 @@\n-            if (slots[i].hasData) {\n-                if (obj == null || handles.lookupException(passHandle) != null) {\n-                    \/\/ Read fields of the current descriptor into a new FieldValues and discard\n-                    new FieldValues(slotDesc, true);\n-                } else if (slotDesc.hasReadObjectMethod()) {\n-                    SerialCallbackContext oldContext = curContext;\n-                    if (oldContext != null)\n-                        oldContext.check();\n-                    try {\n-                        curContext = new SerialCallbackContext(obj, slotDesc);\n+        TRACE(\"readSerialCustomData: %s, ex: %s\", desc.getName(), handles.lookupException(passHandle));\n+        try {\n+            Object obj = desc.newInstance();\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+            \/\/ Read data into each of the slots for the class\n+            return readSerialCustomSlots(obj, desc.getClassDataLayout());\n+        } catch (InstantiationException | InvocationTargetException ex) {\n+            throw new InvalidClassException(desc.forClass().getName(),\n+                    \"unable to create instance\", ex);\n+        }\n+    }\n@@ -2473,17 +2580,14 @@\n-                        bin.setBlockDataMode(true);\n-                        slotDesc.invokeReadObject(obj, this);\n-                    } catch (ClassNotFoundException ex) {\n-                        \/*\n-                         * In most cases, the handle table has already\n-                         * propagated a CNFException to passHandle at this\n-                         * point; this mark call is included to address cases\n-                         * where the custom readObject method has cons'ed and\n-                         * thrown a new CNFException of its own.\n-                         *\/\n-                        handles.markException(passHandle, ex);\n-                    } finally {\n-                        curContext.setUsed();\n-                        if (oldContext!= null)\n-                            oldContext.check();\n-                        curContext = oldContext;\n-                    }\n+    \/**\n+     * Reads from the stream using custom or default readObject methods appropriate.\n+     * For each slot, either the custom readObject method or the default reader of fields\n+     * is invoked. Unused slot specific custom data is discarded.\n+     * This function is used by {@link #readSerialCustomData}.\n+     *\n+     * @param obj the object to assign the values to\n+     * @param slots a list of slots to read from the stream\n+     * @return the object being initialized\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private Object readSerialCustomSlots(Object obj, List<ClassDataSlot> slots) throws IOException {\n+        TRACE(\"    readSerialCustomSlots: %s\", slots);\n@@ -2491,6 +2595,7 @@\n-                    \/*\n-                     * defaultDataEnd may have been set indirectly by custom\n-                     * readObject() method when calling defaultReadObject() or\n-                     * readFields(); clear it to restore normal read behavior.\n-                     *\/\n-                    defaultDataEnd = false;\n+        for (ClassDataSlot slot : slots) {\n+            ObjectStreamClass slotDesc = slot.desc;\n+            if (slot.hasData) {\n+                if (slotDesc.hasReadObjectMethod() &&\n+                        handles.lookupException(passHandle) == null) {\n+                    \/\/ Invoke slot custom readObject method\n+                    readSlotViaReadObject(obj, slotDesc);\n@@ -2500,8 +2605,4 @@\n-                    if (slotValues != null) {\n-                        slotValues[i] = values;\n-                    } else if (obj != null) {\n-                        if (handles.lookupException(passHandle) == null) {\n-                            \/\/ passHandle NOT marked with an exception; set field values\n-                            values.defaultCheckFieldValues(obj);\n-                            values.defaultSetFieldValues(obj);\n-                        }\n+                    if (handles.lookupException(passHandle) == null) {\n+                        \/\/ Set the instance fields if no previous exception\n+                        values.defaultCheckFieldValues(obj);\n+                        values.defaultSetFieldValues(obj);\n@@ -2509,6 +2610,1 @@\n-                }\n-\n-                if (slotDesc.hasWriteObjectData()) {\n-                    skipCustomData();\n-                } else {\n-                    bin.setBlockDataMode(false);\n+                    finishBlockData(slotDesc);\n@@ -2517,4 +2613,2 @@\n-                if (obj != null &&\n-                    slotDesc.hasReadObjectNoDataMethod() &&\n-                    handles.lookupException(passHandle) == null)\n-                {\n+                if (slotDesc.hasReadObjectNoDataMethod() &&\n+                        handles.lookupException(passHandle) == null) {\n@@ -2525,0 +2619,2 @@\n+        return obj;\n+    }\n@@ -2526,11 +2622,78 @@\n-        if (obj != null && slotValues != null && handles.lookupException(passHandle) == null) {\n-            \/\/ passHandle NOT marked with an exception\n-            \/\/ Check that the non-primitive types are assignable for all slots\n-            \/\/ before assigning.\n-            for (int i = 0; i < slots.length; i++) {\n-                if (slotValues[i] != null)\n-                    slotValues[i].defaultCheckFieldValues(obj);\n-            }\n-            for (int i = 0; i < slots.length; i++) {\n-                if (slotValues[i] != null)\n-                    slotValues[i].defaultSetFieldValues(obj);\n+    \/**\n+     * Invoke the readObject method of the class to read and store the state from the stream.\n+     *\n+     * @param obj an instance of the class being created, only partially initialized.\n+     * @param slotDesc the ObjectStreamDescriptor for the current class\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private void readSlotViaReadObject(Object obj, ObjectStreamClass slotDesc) throws IOException {\n+        TRACE(\"readSlotViaReadObject: %s\", slotDesc.getName());\n+        assert obj != null : \"readSlotViaReadObject called when obj == null\";\n+\n+        SerialCallbackContext oldContext = curContext;\n+        if (oldContext != null)\n+            oldContext.check();\n+        try {\n+            curContext = new SerialCallbackContext(obj, slotDesc);\n+\n+            bin.setBlockDataMode(true);\n+            slotDesc.invokeReadObject(obj, this);\n+        } catch (ClassNotFoundException ex) {\n+            \/*\n+             * In most cases, the handle table has already\n+             * propagated a CNFException to passHandle at this\n+             * point; this mark call is included to address cases\n+             * where the custom readObject method has cons'ed and\n+             * thrown a new CNFException of its own.\n+             *\/\n+            handles.markException(passHandle, ex);\n+        } finally {\n+            curContext.setUsed();\n+            if (oldContext!= null)\n+                oldContext.check();\n+            curContext = oldContext;\n+        }\n+\n+        \/*\n+         * defaultDataEnd may have been set indirectly by custom\n+         * readObject() method when calling defaultReadObject() or\n+         * readFields(); clear it to restore normal read behavior.\n+         *\/\n+        defaultDataEnd = false;\n+\n+        finishBlockData(slotDesc);\n+    }\n+\n+\n+    \/**\n+     * Read and discard an entire object, leaving a null reference in the HandleTable.\n+     * The descriptor of the class in the stream is used to read the fields from the stream.\n+     * There is no instance in which to store the field values.\n+     * Custom data following the fields of any slot is read and discarded.\n+     * References to nested objects are read and retained in the\n+     * handle table using the regular mechanism.\n+     * Handles later in the stream may refer to the nested objects.\n+     *\n+     * @param desc the stream class descriptor\n+     * @param unshared the unshared flag, ignored since no object is created\n+     * @return null, no object is created\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private Object readAbsentLocalClass(ObjectStreamClass desc, boolean unshared)\n+            throws IOException {\n+        TRACE(\"readAbsentLocalClass: %s\", desc.getName());\n+        desc.getClassDataLayout().stream()\n+                .filter(s -> s.hasData)\n+                .forEach(s2 -> {new FieldValues(s2.desc, true); finishBlockData(s2.desc);});\n+        return null;\n+    }\n+\n+    \/\/ Finish handling of block data by skipping any remaining and setting BlockDataMode = false\n+    private void finishBlockData(ObjectStreamClass slotDesc) throws UncheckedIOException {\n+        try {\n+            if (slotDesc.hasWriteObjectData()) {\n+                skipCustomData();\n+            } else {\n+                bin.setBlockDataMode(false);\n@@ -2538,0 +2701,2 @@\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n@@ -2633,0 +2798,1 @@\n+         * @throws UncheckedIOException if any IOException occurs\n@@ -2634,2 +2800,9 @@\n-        FieldValues(ObjectStreamClass desc, boolean recordDependencies) throws IOException {\n-            this.desc = desc;\n+        FieldValues(ObjectStreamClass desc, boolean recordDependencies) throws UncheckedIOException {\n+            try {\n+                this.desc = desc;\n+                TRACE(\"    reading FieldValues: %s\", desc.getName());\n+                int primDataSize = desc.getPrimDataSize();\n+                primValues = (primDataSize > 0) ? new byte[primDataSize] : null;\n+                if (primDataSize > 0) {\n+                    bin.readFully(primValues, 0, primDataSize, false);\n+                }\n@@ -2637,5 +2810,0 @@\n-            int primDataSize = desc.getPrimDataSize();\n-            primValues = (primDataSize > 0) ? new byte[primDataSize] : null;\n-            if (primDataSize > 0) {\n-                bin.readFully(primValues, 0, primDataSize, false);\n-            }\n@@ -2643,13 +2811,14 @@\n-            int numObjFields = desc.getNumObjFields();\n-            objValues = (numObjFields > 0) ? new Object[numObjFields] : null;\n-            objHandles = (numObjFields > 0) ? new int[numObjFields] : null;\n-            if (numObjFields > 0) {\n-                int objHandle = passHandle;\n-                ObjectStreamField[] fields = desc.getFields(false);\n-                int numPrimFields = fields.length - objValues.length;\n-                for (int i = 0; i < objValues.length; i++) {\n-                    ObjectStreamField f = fields[numPrimFields + i];\n-                    objValues[i] = readObject0(Object.class, f.isUnshared());\n-                    objHandles[i] = passHandle;\n-                    if (recordDependencies && f.getField() != null) {\n-                        handles.markDependency(objHandle, passHandle);\n+                int numObjFields = desc.getNumObjFields();\n+                objValues = (numObjFields > 0) ? new Object[numObjFields] : null;\n+                objHandles = (numObjFields > 0) ? new int[numObjFields] : null;\n+                if (numObjFields > 0) {\n+                    int objHandle = passHandle;\n+                    ObjectStreamField[] fields = desc.getFields(false);\n+                    int numPrimFields = fields.length - objValues.length;\n+                    for (int i = 0; i < objValues.length; i++) {\n+                        ObjectStreamField f = fields[numPrimFields + i];\n+                        objValues[i] = readObject0(Object.class, f.isUnshared());\n+                        objHandles[i] = passHandle;\n+                        if (recordDependencies && f.getField() != null) {\n+                            handles.markDependency(objHandle, passHandle);\n+                        }\n@@ -2657,0 +2826,1 @@\n+                    passHandle = objHandle;\n@@ -2658,1 +2828,2 @@\n-                passHandle = objHandle;\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":354,"deletions":183,"binary":false,"changes":537,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static java.io.ObjectInputStream.TRACE;\n+\n@@ -161,0 +163,1 @@\n+ * <a id=\"record-serialization\"><\/a>\n@@ -164,0 +167,26 @@\n+ * <a id=\"valueclass-serialization\"><\/a>\n+ * <p>Value classes are {@linkplain Serializable} through the use of the serialization proxy pattern.\n+ * The serialization protocol does not support a standard serialized form for value classes.\n+ * The value class delegates to a serialization proxy by supplying an alternate\n+ * record or object to be serialized instead of the value class.\n+ * When the proxy is deserialized it re-constructs the value object and returns the value object.\n+ * For example,\n+ * {@snippet lang=\"java\" :\n+ * value class ZipCode implements Serializable {    \/\/ @highlight substring=\"value class\"\n+ *     private static final long serialVersionUID = 1L;\n+ *     private int zipCode;\n+ *     public ZipCode(int zip) { this.zipCode = zip; }\n+ *     public int zipCode() { return zipCode; }\n+ *\n+ *     public Object writeReplace() {    \/\/ @highlight substring=\"writeReplace\"\n+ *         return new ZipCodeProxy(zipCode);\n+ *     }\n+ *\n+ *     private record ZipCodeProxy(int zipCode) implements Serializable {\n+ *         public Object readResolve() {    \/\/ @highlight substring=\"readResolve\"\n+ *             return new ZipCode(zipCode);\n+ *         }\n+ *     }\n+ * }\n+ * }\n+ *\n@@ -347,0 +376,3 @@\n+     * <p>Serialization and deserialization of value classes is described in\n+     * {@linkplain ObjectOutputStream##valueclass-serialization value class serialization}.\n+     *\n@@ -416,0 +448,3 @@\n+     * <p>Serialization and deserialization of value classes is described in\n+     * {@linkplain ObjectOutputStream##valueclass-serialization value class serialization}.\n+     *\n@@ -1201,3 +1236,0 @@\n-                if (cl.isValue() && !desc.isInstantiable()) {\n-                    throw new NotSerializableException(cl.getName());\n-                }\n@@ -1459,2 +1491,2 @@\n-                if (desc.forClass().isValue())\n-                    throw new NotSerializableException(\"Externalizable not valid for value class \"\n+                if (desc.isValue())\n+                    throw new InvalidClassException(\"Externalizable not valid for value class \"\n@@ -1510,2 +1542,2 @@\n-        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n-        if (slots.length != 1) {\n+        List<ObjectStreamClass.ClassDataSlot> slots = desc.getClassDataLayout();\n+        if (slots.size() != 1) {\n@@ -1513,1 +1545,1 @@\n-                    \"expected a single record slot length, but found: \" + slots.length);\n+                    \"expected a single record slot length, but found: \" + slots.size());\n@@ -1526,3 +1558,3 @@\n-        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n-        for (int i = 0; i < slots.length; i++) {\n-            ObjectStreamClass slotDesc = slots[i].desc;\n+       List<ObjectStreamClass.ClassDataSlot> slots = desc.getClassDataLayout();\n+        for (int i = 0; i < slots.size(); i++) {\n+            ObjectStreamClass slotDesc = slots.get(i).desc;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":43,"deletions":11,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.lang.reflect.AccessFlag;\n@@ -57,0 +56,1 @@\n+import java.util.List;\n@@ -60,0 +60,1 @@\n+import java.util.stream.Stream;\n@@ -70,0 +71,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -72,0 +74,2 @@\n+import static java.io.ObjectInputStream.TRACE;\n+\n@@ -110,0 +114,65 @@\n+    \/**\n+     * The mode of deserialization for a class depending on its type and interfaces.\n+     * The markers used are {@linkplain java.io.Serializable}, {@linkplain java.io.Externalizable},\n+     * Class.isRecord(), Class.isValue(), constructors, and\n+     * the presence of methods `readObject`, `writeObject`, `readObjectNoData`, `writeObject`.\n+     * ObjectInputStream dispatches on the mode to construct objects from the stream.\n+     *\/\n+    enum DeserializationMode {\n+        \/**\n+         * Construct an object from the stream for a class that has only default read object behaviors.\n+         * All classes and superclasses use defaultReadObject; no custom readObject or readObjectNoData.\n+         * The new instance is entered in the handle table if it is unshared,\n+         * allowing it to escape before it is initialized.\n+         * For each object, all the fields are read before any are assigned.\n+         * The `readObject` and `readObjectNoData` methods are not present and are not called.\n+         *\/\n+        READ_OBJECT_DEFAULT,\n+        \/**\n+         * Creates a new object and invokes its readExternal method to read its contents.\n+         * If the class is instantiable, read externalizable data by invoking readExternal()\n+         * method of obj; otherwise, attempts to skip over externalizable data.\n+         * Expects that passHandle is set to obj's handle before this method is\n+         * called.  The new object is entered in the handle table immediately,\n+         * allowing it to leak before it is completely read.\n+         *\/\n+        READ_EXTERNALIZABLE,\n+        \/**\n+         * Read all the record fields and invoke its canonical constructor.\n+         * Construct the record using its canonical constructor.\n+         * The new record is entered in the handle table only after the constructor returns.\n+         *\/\n+        READ_RECORD,\n+        \/**\n+         * Fully custom read from the stream to create an instance.\n+         * If the class is not instantiatable or is tagged with ClassNotFoundException\n+         * the data in the stream for the class is read and discarded. {@link #READ_NO_LOCAL_CLASS}\n+         * The instance is created and set in the handle table, allowing it to leak before it is initialized.\n+         * For each serializable class in the stream, from superclass to subclass the\n+         * stream values are read by the `readObject` method, if present, or defaultReadObject.\n+         * Custom inline data is discarded if not consumed by the class `readObject` method.\n+         *\/\n+        READ_OBJECT_CUSTOM,\n+        \/**\n+         * Construct an object by reading the values of all fields and\n+         * invoking a constructor or static factory method.\n+         * The constructor or static factory method is selected by matching its parameters with the\n+         * sequence of field types of the serializable fields of the local class and superclasses.\n+         * Invoke the constructor with all the values from the stream, inserting\n+         * defaults and dropping extra values as necessary.\n+         * This is very similar to the reading of records, except for the identification of\n+         * the constructor or static factory.\n+         *\/\n+        READ_OBJECT_VALUE,\n+        \/**\n+         * Read and discard an entire object, leaving a null reference in the HandleTable.\n+         * The descriptor of the class in the stream is used to read the fields from the stream.\n+         * There is no instance in which to store the field values.\n+         * Custom data following the fields of any slot is read and discarded.\n+         * References to nested objects are read and retained in the\n+         * handle table using the regular mechanism.\n+         * Handles later in the stream may refer to the nested objects.\n+         *\/\n+        READ_NO_LOCAL_CLASS,\n+    }\n+\n@@ -145,0 +214,2 @@\n+    \/** The DeserializationMode for this class. *\/\n+    private DeserializationMode factoryMode;\n@@ -202,1 +273,1 @@\n-    private volatile ClassDataSlot[] dataLayout;\n+    private volatile List<ClassDataSlot> dataLayout;\n@@ -416,0 +487,1 @@\n+                        factoryMode = DeserializationMode.READ_RECORD;\n@@ -418,3 +490,0 @@\n-                    } else if (isValue) {\n-                        \/\/ Value object instance creation is specialized in newInstance()\n-                        cons = null;\n@@ -422,1 +491,24 @@\n-                        cons = getExternalizableConstructor(cl);\n+                        factoryMode = DeserializationMode.READ_EXTERNALIZABLE;\n+                        if (cl.isIdentity()) {\n+                            cons = getExternalizableConstructor(cl);\n+                        } else {\n+                            serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n+                                    \"Externalizable not valid for value class\");\n+                        }\n+                    } else if (cl.isValue()) {\n+                        factoryMode = DeserializationMode.READ_OBJECT_VALUE;\n+                        if (!cl.isAnnotationPresent(MigratedValueClass.class)) {\n+                            serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n+                                    \"Value class serialization is only supported with `writeReplace`\");\n+                        } else if (Modifier.isAbstract(cl.getModifiers())) {\n+                            serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n+                                    \"value class is abstract\");\n+                        } else {\n+                            \/\/ Value classes should have constructor(s) annotated with {@link DeserializeConstructor}\n+                            canonicalCtr = getDeserializingValueCons(cl, fields);\n+                            deserializationCtrs = new DeserializationConstructorsCache();                            factoryMode = DeserializationMode.READ_OBJECT_VALUE;\n+                            if (canonicalCtr == null) {\n+                                serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n+                                        \"no constructor or factory found for migrated value class\");\n+                            }\n+                        }\n@@ -434,0 +526,4 @@\n+                        factoryMode = ((superDesc == null || superDesc.factoryMode() == DeserializationMode.READ_OBJECT_DEFAULT)\n+                                && readObjectMethod == null && readObjectNoDataMethod == null)\n+                                ? DeserializationMode.READ_OBJECT_DEFAULT\n+                                : DeserializationMode.READ_OBJECT_CUSTOM;\n@@ -578,0 +674,3 @@\n+            factoryMode = localDesc.factoryMode;\n+        } else {\n+            factoryMode = DeserializationMode.READ_OBJECT_DEFAULT;\n@@ -672,0 +771,6 @@\n+            factoryMode = localDesc.factoryMode;\n+        } else {\n+            \/\/ No local class, read data using only the schema from the stream\n+            factoryMode = (externalizable)\n+                    ? DeserializationMode.READ_EXTERNALIZABLE\n+                    : DeserializationMode.READ_NO_LOCAL_CLASS;\n@@ -727,1 +832,1 @@\n-                fields[i] = new ObjectStreamField(fname, signature, false);\n+                fields[i] = new ObjectStreamField(fname, signature, false, -1);\n@@ -946,0 +1051,8 @@\n+    \/**\n+     * {@return the factory mode for deserialization}\n+     *\/\n+    DeserializationMode factoryMode() {\n+        requireInitialized();\n+        return factoryMode;\n+    }\n+\n@@ -970,1 +1083,2 @@\n-     * accessible no-arg constructor, or if the class is a migrated value class.\n+     * accessible no-arg constructor, or if the class is a value class with a @DeserializeConstructor\n+     * constructor or static factory.\n@@ -975,2 +1089,1 @@\n-        return (cons != null |\n-                (isValue && cl != null && cl.isAnnotationPresent(jdk.internal.MigratedValueClass.class)));\n+        return (cons != null || (isValue() && canonicalCtr != null));\n@@ -1087,4 +1200,1 @@\n-        } else if (isValue) {\n-            \/\/ Start with a buffered default value.\n-            return FieldReflector.newValueInstance(cl);\n-        }  else {\n+        } else {\n@@ -1095,9 +1205,0 @@\n-    \/**\n-     * Finish the initialization of a value object.\n-     * @param obj an object (larval if a value object)\n-     * @return the finished object\n-     *\/\n-    Object finishValue(Object obj) {\n-        return (isValue) ? FieldReflector.finishValueInstance(obj) : obj;\n-    }\n-\n@@ -1274,1 +1375,1 @@\n-     * Returns array of ClassDataSlot instances representing the data layout\n+     * Returns a List of ClassDataSlot instances representing the data layout\n@@ -1280,1 +1381,1 @@\n-    ClassDataSlot[] getClassDataLayout() throws InvalidClassException {\n+    List<ClassDataSlot> getClassDataLayout() throws InvalidClassException {\n@@ -1282,5 +1383,3 @@\n-        if (dataLayout == null) {\n-            dataLayout = getClassDataLayout0();\n-        }\n-        return dataLayout;\n-    }\n+        List<ClassDataSlot> layout = dataLayout;\n+        if (layout != null)\n+            return layout;\n@@ -1288,3 +1387,0 @@\n-    private ClassDataSlot[] getClassDataLayout0()\n-        throws InvalidClassException\n-    {\n@@ -1339,1 +1435,2 @@\n-        return slots.toArray(new ClassDataSlot[slots.size()]);\n+        dataLayout = slots;\n+        return slots;\n@@ -1467,0 +1564,60 @@\n+    \/**\n+     * Return a method handle for the static method or constructor(s) that matches the\n+     * serializable fields and annotated with {@link DeserializeConstructor}.\n+     * The descriptor for the class is still being initialized, so is passed the fields needed.\n+     * @param clazz The class to query\n+     * @param fields the serializable fields of the class\n+     * @return a MethodHandle, null if none found\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private static MethodHandle getDeserializingValueCons(Class<?> clazz,\n+                                                          ObjectStreamField[] fields) {\n+        \/\/ Search for annotated static factory in methods or constructors\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh = Stream.concat(\n+                Arrays.stream(clazz.getDeclaredMethods()).filter(m -> Modifier.isStatic(m.getModifiers())),\n+                Arrays.stream(clazz.getDeclaredConstructors()))\n+                .filter(m -> m.isAnnotationPresent(DeserializeConstructor.class))\n+                .map(m -> {\n+                    try {\n+                        m.setAccessible(true);\n+                        return (m instanceof Constructor<?> cons)\n+                                ? lookup.unreflectConstructor(cons)\n+                                : lookup.unreflect(((Method) m));\n+                    } catch (IllegalAccessException iae) {\n+                        throw new InternalError(iae);   \/\/ should not occur after setAccessible\n+                    }})\n+                .filter(m -> matchFactoryParamTypes(clazz, m, fields))\n+                .findFirst().orElse(null);\n+        TRACE(\"DeserializeConstructor for %s, mh: %s\", clazz,  mh);\n+        return mh;\n+    }\n+\n+    \/**\n+     * Check that the parameters of the factory method match the fields of this class.\n+     *\n+     * @param mh a MethodHandle for a constructor or factory\n+     * @return true if all fields match the parameters, false if not\n+     *\/\n+    private static boolean matchFactoryParamTypes(Class<?> clazz,\n+                                                       MethodHandle mh,\n+                                                       ObjectStreamField[] fields) {\n+        TRACE(\"  matchFactoryParams checking class: %s, mh: %s\", clazz, mh);\n+        var params = mh.type().parameterList();\n+        if (params.size() != fields.length) {\n+            TRACE(\"   matchFactoryParams %s, arg count mismatch %d params != %d fields\",\n+                    clazz, params.size(), fields.length);\n+            return false;    \/\/ Mismatch in count of fields and parameters\n+        }\n+        for (ObjectStreamField field : fields) {\n+            int argIndex = field.getArgIndex();\n+            final Class<?> paramtype = params.get(argIndex);\n+            if (!field.getType().equals(paramtype)) {\n+                TRACE(\"   matchFactoryParams %s: argIndex: %d type mismatch field: %s != param: %s\",\n+                        clazz, argIndex, field.getType(), paramtype);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -1713,2 +1870,1 @@\n-                    boundFields[i] =\n-                        new ObjectStreamField(f, spf.isUnshared(), true);\n+                    boundFields[i] = new ObjectStreamField(f, spf.isUnshared(), true, i);\n@@ -1719,2 +1875,1 @@\n-                boundFields[i] = new ObjectStreamField(\n-                    fname, spf.getType(), spf.isUnshared());\n+                boundFields[i] = new ObjectStreamField(fname, spf.getType(), spf.isUnshared(), i);\n@@ -1737,1 +1892,1 @@\n-        for (int i = 0; i < clFields.length; i++) {\n+        for (int i = 0, argIndex = 0; i < clFields.length; i++) {\n@@ -1739,1 +1894,1 @@\n-                list.add(new ObjectStreamField(clFields[i], false, true));\n+                list.add(new ObjectStreamField(clFields[i], false, true, argIndex++));\n@@ -1971,27 +2126,0 @@\n-        \/**\n-         * Return a new instance of the class using Unsafe.uninitializedDefaultValue\n-         * and buffer it.\n-         * @param clazz The value class\n-         * @return a buffered default value\n-         *\/\n-        static Object newValueInstance(Class<?> clazz) throws InstantiationException{\n-            var accessFlags = clazz.accessFlags();\n-            if (accessFlags.contains(AccessFlag.ABSTRACT) ||\n-                    accessFlags.contains(AccessFlag.IDENTITY)) {\n-                throw new InstantiationException(\"Value class not instantiable: \" + clazz.getName());\n-            }\n-            \/\/ may not be implicitly constructible; so allocate with Unsafe\n-            Object obj = UNSAFE.uninitializedDefaultValue(clazz);\n-            return UNSAFE.makePrivateBuffer(obj);\n-        }\n-\n-        \/**\n-         * Finish a value object, clear the larval state and returning the value object.\n-         * @param obj a buffered value object in a larval state\n-         * @return the finished value object\n-         *\/\n-        static Object finishValueInstance(Object obj) {\n-            assert (obj.getClass().isValue()) : \"Should be a value class\";\n-            return UNSAFE.finishPrivateBuffer(obj);\n-        }\n-\n@@ -2150,1 +2278,1 @@\n-            if (obj == null) {\n+            if (obj == null && !dryRun) {\n@@ -2291,1 +2419,1 @@\n-                            lf.getField(), lf.isUnshared(), false);\n+                            lf.getField(), lf.isUnshared(), true, lf.getArgIndex()); \/\/ Don't hide type\n@@ -2294,1 +2422,1 @@\n-                            lf.getName(), lf.getSignature(), lf.isUnshared());\n+                            lf.getName(), lf.getSignature(), lf.isUnshared(), lf.getArgIndex());\n@@ -2300,1 +2428,1 @@\n-                    f.getName(), f.getSignature(), false);\n+                    f.getName(), f.getSignature(), false, -1);\n@@ -2422,1 +2550,1 @@\n-    static final class RecordSupport {\n+    static final class ConstructorSupport {\n@@ -2479,0 +2607,59 @@\n+        \/**\n+         * Returns value object constructor adapted to take two arguments:\n+         * {@code (byte[] primValues, Object[] objValues)} and return {@code Object}\n+         *\/\n+        static MethodHandle deserializationValueCons(ObjectStreamClass desc) {\n+            \/\/ check the cached value 1st\n+            MethodHandle mh = desc.deserializationCtr;\n+            if (mh != null) return mh;\n+            mh = desc.deserializationCtrs.get(desc.getFields(false));\n+            if (mh != null) return desc.deserializationCtr = mh;\n+\n+            \/\/ retrieve the selected constructor\n+            \/\/ (T1, T2, ..., Tn):TR\n+            ObjectStreamClass localDesc = desc.localDesc;\n+            mh = localDesc.canonicalCtr;\n+            MethodType mt = mh.type();\n+\n+            \/\/ change return type to Object\n+            \/\/ (T1, T2, ..., Tn):TR -> (T1, T2, ..., Tn):Object\n+            mh = mh.asType(mh.type().changeReturnType(Object.class));\n+\n+            \/\/ drop last 2 arguments representing primValues and objValues arrays\n+            \/\/ (T1, T2, ..., Tn):Object -> (T1, T2, ..., Tn, byte[], Object[]):Object\n+            mh = MethodHandles.dropArguments(mh, mh.type().parameterCount(), byte[].class, Object[].class);\n+\n+            Class<?>[] params = mt.parameterArray();\n+            for (int i = params.length-1; i >= 0; i--) {\n+                \/\/ Get the name from the local descriptor matching the argIndex\n+                var field = getFieldForArgIndex(localDesc, i);\n+                String name = (field == null) ? \"\" : field.getName();   \/\/ empty string to supply default\n+                Class<?> type = params[i];\n+                \/\/ obtain stream field extractor that extracts argument at\n+                \/\/ position i (Ti+1) from primValues and objValues arrays\n+                \/\/ (byte[], Object[]):Ti+1\n+                MethodHandle combiner = streamFieldExtractor(name, type, desc);\n+                \/\/ fold byte[] privValues and Object[] objValues into argument at position i (Ti+1)\n+                \/\/ (..., Ti, Ti+1, byte[], Object[]):Object -> (..., Ti, byte[], Object[]):Object\n+                mh = MethodHandles.foldArguments(mh, i, combiner);\n+            }\n+            \/\/ what we are left with is a MethodHandle taking just the primValues\n+            \/\/ and objValues arrays and returning the constructed instance\n+            \/\/ (byte[], Object[]):Object\n+\n+            \/\/ store it into cache and return the 1st value stored\n+            return desc.deserializationCtr =\n+                desc.deserializationCtrs.putIfAbsentAndGet(desc.getFields(false), mh);\n+        }\n+\n+        \/\/ Find the ObjectStreamField for the argument index, otherwise null\n+        private static ObjectStreamField getFieldForArgIndex(ObjectStreamClass desc, int argIndex) {\n+            for (var field : desc.fields) {\n+                if (field.getArgIndex() == argIndex)\n+                    return field;\n+            }\n+            TRACE(\"field for ArgIndex is null: %s, index: %d, fields: %s\",\n+                    desc, argIndex, Arrays.toString(desc.fields));\n+            return null;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":260,"deletions":73,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+    \/** index of the field in the class, retain the declaration order of serializable fields *\/\n+    private final int argIndex;\n@@ -90,0 +92,5 @@\n+        this(name, type, unshared, -1);\n+    }\n+\n+    \/* package-private *\/\n+    ObjectStreamField(String name, Class<?> type, boolean unshared, int argIndex) {\n@@ -98,0 +105,1 @@\n+        this.argIndex = argIndex;\n@@ -104,1 +112,1 @@\n-    ObjectStreamField(String name, String signature, boolean unshared) {\n+    ObjectStreamField(String name, String signature, boolean unshared, int argIndex) {\n@@ -112,0 +120,1 @@\n+        this.argIndex = argIndex;\n@@ -135,1 +144,1 @@\n-    ObjectStreamField(Field field, boolean unshared, boolean showType) {\n+    ObjectStreamField(Field field, boolean unshared, boolean showType, int argIndex) {\n@@ -142,0 +151,1 @@\n+        this.argIndex = argIndex;\n@@ -230,0 +240,7 @@\n+    \/**\n+     * {@return Index of the field in the sequence of Serializable fields}\n+     *\/\n+    int getArgIndex() {\n+        return argIndex;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamField.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -31,1 +32,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -36,3 +36,0 @@\n-import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n-import static java.lang.constant.ConstantDescs.CD_Boolean;\n-\n@@ -179,0 +176,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -38,1 +39,0 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n@@ -148,0 +148,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -9017,0 +9018,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -926,0 +927,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -553,0 +554,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -1017,0 +1018,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -1019,0 +1020,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Number.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -37,1 +38,0 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n@@ -277,0 +277,1 @@\n+    @DeserializeConstructor\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-            throw new UnsupportedOperationException(\"newConstructorForSerialization does not support value classes\");\n+            throw new UnsupportedOperationException(\"newConstructorForSerialization does not support value classes: \" + cl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.value;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.CONSTRUCTOR;\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+\/**\n+ * Indicates the constructor or static factory to\n+ * construct a value object during deserialization.\n+ * The annotation is used by java.io.ObjectStreamClass to select the constructor\n+ * or factory method to create objects from a stream.\n+ *\n+ * @since 24\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(value={CONSTRUCTOR, METHOD})\n+public @interface DeserializeConstructor {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/DeserializeConstructor.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal java.base\/jdk.internal.misc\n+ * @run junit\/othervm --enable-preview SerializeAllValueClasses\n+ * @run junit\/othervm SerializeAllValueClasses\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.Month;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.HijrahDate;\n+import java.time.chrono.JapaneseDate;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalUnit;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.misc.PreviewFeatures;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * Scans all classes in the JDK for those recognized as value classes\n+ * or with the annotation jdk.internal.misc.ValueBasedClass.\n+ *\n+ * Scanning is done over the jrt: filesystem. Classes are matched using the\n+ * following criteria:\n+ *\n+ *  - serializable\n+ *  - is a public or protected class\n+ *  - has public or protected constructor\n+ *\n+ * This returns a list of class', which is convenient for the caller.\n+ *\/\n+\n+public class SerializeAllValueClasses {\n+    \/\/ Cache of instances of known classes suitable as arguments to constructors\n+    \/\/ or factory methods.\n+    private static final Map<Class<?>, Object> argumentForType = initInstances();\n+\n+    private static Map<Class<?>, Object> initInstances() {\n+        Map<Class<?>, Object> map = new HashMap<>();\n+        map.put(Integer.class, 12); map.put(int.class, 12);\n+        map.put(Short.class, (short)3); map.put(short.class, (short)3);\n+        map.put(Byte.class, (byte)4); map.put(byte.class, (byte)4);\n+        map.put(Long.class, 5L); map.put(long.class, 5L);\n+        map.put(Character.class, 'C'); map.put(char.class, 'C');\n+        map.put(Float.class, 1.0f); map.put(float.class, 1.0f);\n+        map.put(Double.class, 2.0d); map.put(double.class, 2.0d);\n+        map.put(Duration.class, Duration.ofHours(1));\n+        map.put(TemporalUnit.class, ChronoUnit.SECONDS);\n+        map.put(LocalTime.class, LocalTime.of(12, 1));\n+        map.put(LocalDate.class, LocalDate.of(2024, 1, 1));\n+        map.put(LocalDateTime.class, LocalDateTime.of(2024, 2, 1, 12, 2));\n+        map.put(TemporalAccessor.class, ZonedDateTime.now());\n+        map.put(ZonedDateTime.class, ZonedDateTime.now());\n+        map.put(Clock.class, Clock.systemUTC());\n+        map.put(Month.class, Month.JANUARY);\n+        map.put(Instant.class, Instant.now());\n+        map.put(JapaneseDate.class, JapaneseDate.now());\n+        map.put(HijrahDate.class, HijrahDate.now());\n+        return map;\n+    }\n+\n+\n+    \/\/ Stream the value classes to the test\n+    private static Stream<Arguments> classProvider() throws IOException, URISyntaxException {\n+        return findAll().stream().map(c -> Arguments.of(c));\n+    }\n+\n+    @Test\n+    void info() {\n+        var info = (PreviewFeatures.isEnabled()) ? \"  Checking preview classes declared as `value class`\" :\n+            \"  Checking identity classes with annotation `jdk.internal.ValueBased.class`\";\n+        System.err.println(info);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"classProvider\")\n+    void testValueClass(Class<?> clazz) {\n+        boolean atLeastOne = false;\n+\n+        Object expected = argumentForType.get(clazz);\n+        if (expected != null) {\n+            serializeDeserialize(expected);\n+            atLeastOne = true;\n+        }\n+        var cons = clazz.getConstructors();\n+        for (Constructor<?> c : cons) {\n+            Object[] args = makeArgs(c.getParameterTypes(), clazz);\n+            if (args != null) {\n+                try {\n+                    expected = c.newInstance(args);\n+                    serializeDeserialize(expected);\n+                    atLeastOne = true;\n+                    break;  \/\/ one is enough\n+                } catch (InvocationTargetException | InstantiationException |\n+                         IllegalAccessException e) {\n+                    \/\/ Ignore\n+                    System.err.printf(\"\"\"\n+                                      Ignoring constructor: %s\n+                                        Generated arguments are invalid: %s\n+                                        %s\n+                                    \"\"\",\n+                            c, Arrays.toString(args), e.getCause());\n+                }\n+            }\n+        }\n+\n+        \/\/ Scan for suitable factory methods\n+        for (Method m : clazz.getMethods()) {\n+            if (Modifier.isStatic(m.getModifiers()) &&\n+                m.getReturnType().equals(clazz)) {\n+                \/\/ static method returning itself\n+                Object[] args = makeArgs(m.getParameterTypes(), clazz);\n+                if (args != null) {\n+                    try {\n+                        expected = m.invoke(null, args);\n+                        serializeDeserialize(expected);\n+                        atLeastOne = true;\n+                        break;  \/\/ one is enough\n+                    } catch (IllegalAccessException | InvocationTargetException e) {\n+                        \/\/ Ignore\n+                        System.err.printf(\"\"\"\n+                                          Ignoring factory: %s\n+                                            Generated arguments are invalid: %s\n+                                            %s\n+                                        \"\"\",\n+                                m, Arrays.toString(args), e.getCause());\n+                    }\n+                }\n+            }\n+        }\n+        assertTrue(atLeastOne, \"No constructor or factory found for \" + clazz);\n+    }\n+\n+    \/**\n+     * {@return an array of instances matching the parameter types, or null}\n+     *\n+     * @param paramTypes an array of parameter types\n+     * @param forClazz the owner class for which the parameters are being generated\n+     *\/\n+    private Object[] makeArgs(Class<?>[] paramTypes, Class<?> forClazz) {\n+        Object[] args = Arrays.stream(paramTypes)\n+                .map(t -> makeArg(t, forClazz))\n+                .toArray();\n+        for (Object arg : args) {\n+            if (arg == null)\n+                return null;\n+        }\n+        return args;\n+    }\n+\n+    \/**\n+     * {@return an instance of the class, or null if not available}\n+     * String values are customized by the requesting owner.\n+     * For example, \"true\" is returned as a value when requested for \"Boolean\".\n+     * @param paramType the parameter type\n+     * @param forClass the owner class\n+     *\/\n+    private static Object makeArg(Class<?> paramType, Class<?> forClass) {\n+        return (paramType == String.class || paramType == CharSequence.class)\n+                ? makeStringArg(forClass)\n+                : argumentForType.get(paramType);\n+    }\n+\n+    \/**\n+     * {@return a string representation of an instance of class, or null}\n+     * Mostly special cased for core value classes.\n+     * @param forClass a Class\n+     *\/\n+    private static String makeStringArg(Class<?> forClass) {\n+        if (forClass == Integer.class || forClass == int.class ||\n+                forClass == Byte.class || forClass == byte.class ||\n+                forClass == Short.class || forClass == short.class ||\n+                forClass == Long.class || forClass == long.class) {\n+            return \"0\";\n+        } else if (forClass == Boolean.class || forClass == boolean.class) {\n+            return \"true\";\n+        } else if (forClass == Float.class || forClass == float.class ||\n+                forClass == Double.class || forClass == double.class) {\n+            return \"1.0\";\n+        } else if (forClass == Duration.class) {\n+            return \"PT4H\";\n+        } else if (forClass == LocalDate.class) {\n+            return LocalDate.of(2024, 1, 1).toString();\n+        } else if (forClass == LocalDateTime.class) {\n+            return LocalDateTime.of(2024, 1, 1, 12, 1).toString();\n+        } else if (forClass == LocalTime.class) {\n+            return LocalTime.of(12, 1).toString();\n+        } else if (forClass == Instant.class) {\n+            return Instant.ofEpochSecond(5_000_000, 1000).toString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static final ClassLoader LOADER = SerializeAllValueClasses.class.getClassLoader();\n+\n+    private static Optional<Class<?>> findClass(String name) {\n+        try {\n+            Class<?> clazz = Class.forName(name, false, LOADER);\n+            return Optional.of(clazz);\n+        } catch (ClassNotFoundException | ExceptionInInitializerError |\n+                 NoClassDefFoundError | IllegalAccessError ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean isClass(Class<?> clazz) {\n+        return !(clazz.isEnum() || clazz.isInterface());\n+    }\n+\n+    private static boolean isNonAbstract(Class<?> clazz) {\n+        return (clazz.getModifiers() & Modifier.ABSTRACT) == 0;\n+    }\n+\n+    private static boolean isPublicOrProtected(Class<?> clazz) {\n+        return (clazz.getModifiers() & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0;\n+    }\n+\n+    @SuppressWarnings(\"preview\")\n+    private static boolean isValueClass(Class<?> clazz) {\n+        if (PreviewFeatures.isEnabled())\n+            return clazz.isValue();\n+        var a = clazz.getAnnotation(jdk.internal.ValueBased.class);\n+        return a != null;\n+    }\n+\n+    \/**\n+     * Scans classes in the JDK and returns matching classes.\n+     *\n+     * @return list of matching class\n+     * @throws IOException if an unexpected exception occurs\n+     * @throws URISyntaxException if an unexpected exception occurs\n+     *\/\n+    public static List<Class<?>> findAll() throws IOException, URISyntaxException {\n+        FileSystem fs = FileSystems.getFileSystem(new URI(\"jrt:\/\"));\n+        Path dir = fs.getPath(\"\/modules\");\n+        try (final Stream<Path> paths = Files.walk(dir)) {\n+            \/\/ each path is in the form: \/modules\/<modname>\/<pkg>\/<pkg>\/...\/name.class\n+            return paths.filter((path) -> path.getNameCount() > 2)\n+                    .map((path) -> path.subpath(2, path.getNameCount()))\n+                    .map(Path::toString)\n+                    .filter((name) -> name.endsWith(\".class\"))\n+                    .map((name) -> name.replaceFirst(\"\\\\.class$\", \"\"))\n+                    .filter((name) -> !name.equals(\"module-info\"))\n+                    .map((name) -> name.replaceAll(\"\/\", \".\"))\n+                    .flatMap((java.lang.String name) -> findClass(name).stream())\n+                    .filter(Serializable.class::isAssignableFrom)\n+                    .filter(SerializeAllValueClasses::isClass)\n+                    .filter(SerializeAllValueClasses::isNonAbstract)\n+                    .filter((klass) -> !klass.isSealed())\n+                    .filter(SerializeAllValueClasses::isValueClass)\n+                    .filter(SerializeAllValueClasses::isPublicOrProtected)\n+                    .collect(Collectors.toList());\n+        }\n+    }\n+\n+    private void serializeDeserialize(Object expected) {\n+        try {\n+            Object actual = deserialize(serialize(expected));\n+            assertEquals(expected, actual, \"round trip compare fail\");\n+        } catch (IOException  | ClassNotFoundException e) {\n+            fail(\"serialize\/Deserialize\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Serialize an object into byte array.\n+     *\/\n+    private static byte[] serialize(Object obj) throws IOException {\n+        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n+        try (ObjectOutputStream out = new ObjectOutputStream(bs)) {\n+            out.writeObject(obj);\n+        }\n+        return bs.toByteArray();\n+    }\n+\n+    \/**\n+     * Deserialize an object from byte array using the requested classloader.\n+     *\/\n+    private static Object deserialize(byte[] ba) throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(ba))) {\n+            return in.readObject();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/valueObjects\/SerializeAllValueClasses.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,1373 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InvalidClassException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.OptionalDataException;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.tools.Diagnostic;\n+import javax.tools.JavaFileObject;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.ObjectStreamPrinter;\n+\n+\/*\n+ * @test\n+ * @summary Deserialization Combo tests\n+ * @library \/test\/langtools\/tools\/javac\/lib \/test\/lib .\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build combo.ComboTestHelper SerializedObjectCombo\n+ * @run main\/othervm --enable-preview  SerializedObjectCombo --everything --no-pre-filter\n+ *\/\n+\n+\n+public final class SerializedObjectCombo extends ComboInstance<SerializedObjectCombo> {\n+    private static final Map<Path, URLClassLoader> LOADER_FOR_PATH = new ConcurrentHashMap<>();\n+    private static final ParamSet KIND_SET = new ParamSet(\"KIND\",\n+            SerializationKind.values());\n+    private static final ParamSet FIELD_SET = new ParamSet(\"FIELD\",\n+            2, ArgumentValue.BASIC_VALUES);\n+    private static final ParamSet CLASSACCESS_SET = new ParamSet(\"CLASSACCESS\",\n+            new ClassAccessKind[]{ClassAccessKind.PUBLIC});\n+    private static final ParamSet SPECIAL_WRITE_METHODS_SET = new ParamSet(\"SPECIAL_WRITE_METHODS\",\n+            WriteObjectFragments.values());\n+    private static final ParamSet SPECIAL_READ_METHODS_SET = new ParamSet(\"SPECIAL_READ_METHODS\",\n+            ReadObjectFragments.values());\n+    private static final ParamSet EXTERNALIZABLE_METHODS_SET = new ParamSet(\"EXTERNALIZABLE_METHODS\",\n+            ExternalizableMethodFragments.values());\n+    private static final ParamSet OBJECT_CONSTRUCTOR_SET = new ParamSet(\"OBJECT_CONSTRUCTOR\",\n+            ObjectConstructorFragment.ANNOTATED_OBJECT_CONSTRUCTOR_FRAGMENT, ObjectConstructorFragment.NONE);\n+    private static final ParamSet VALUE_SET = new ParamSet(\"VALUE\",\n+            ValueKind.values());\n+    private static final ParamSet TESTNAME_EXTENDS_SET = new ParamSet(\"TESTNAME_EXTENDS\",\n+                    TestNameExtendsFragments.NONE, TestNameExtendsFragments.TESTNAME_EXTENDS_FRAGMENT);\n+    private static final ParamSet TOP_ABSTRACT_SET = new ParamSet(\"TOP_FRAGMENTS\",\n+            TopFragments.values());\n+    \/**\n+     * The base template to generate all test classes.\n+     * Each substitutable fragment is defined by an Enum of the alternatives.\n+     * Giving each a name and an array of ComboParameters with the expansion value.\n+     *\/\n+    private static final String TEST_SOURCE_TEMPLATE = \"\"\"\n+            import java.io.*;\n+            import java.util.*;\n+            import jdk.internal.value.DeserializeConstructor;\n+            import jdk.internal.MigratedValueClass;\n+\n+            #{TOP_FRAGMENTS}\n+\n+            @MigratedValueClass\n+            #{CLASSACCESS} #{VALUE} class #{TESTNAME} #{TESTNAME_EXTENDS} #{KIND.IMPLEMENTS} {\n+                #{FIELD[0]} f1;\n+                #{FIELD[1]} f2;\n+                #{FIELD_ADDITIONS}\n+                #{CLASSACCESS} #{TESTNAME}() {\n+                    f1 = #{FIELD[0].RANDOM};\n+                    f2 = #{FIELD[1].RANDOM};\n+                    #{FIELD_CONSTRUCTOR_ADDITIONS}\n+                }\n+            #{OBJECT_CONSTRUCTOR}\n+                @Override public boolean equals(Object obj) {\n+                    if (obj instanceof #{TESTNAME} other) {\n+                        if (#{FIELD[0]}.class.isPrimitive()) {\n+                            if (f1 != other.f1) return false;\n+                        } else {\n+                            if (!Objects.equals(f1, other.f1)) return false;\n+                        }\n+                        if (#{FIELD[1]}.class.isPrimitive()) {\n+                            if (f2 != other.f2) return false;\n+                        } else {\n+                            if (!Objects.equals(f2, other.f2)) return false;\n+                        }\n+                        return true;\n+                    }\n+                    return false;\n+                }\n+                @Override public String toString() {\n+                    return \"f1: \" + String.valueOf(f1) +\n+                            \", f2: \" + String.valueOf(f2)\n+                            #{FIELD_TOSTRING_ADDITIONS};\n+                }\n+            #{KIND.SPECIAL_METHODS}\n+                private static final long serialVersionUID = 1L;\n+            }\n+            \"\"\";\n+\n+    \/\/ The unique number to qualify interface names, unique across multiple runs\n+    private static int uniqueId = 0;\n+    \/\/ Compilation errors prevent execution; set\/cleared by checkCompile\n+    private ComboTask.Result<?> compilationResult = null;\n+    \/\/ The current set of parameters for the file being compiled and tested\n+    private final Set<ComboParameter> currParams = new HashSet<>();\n+\n+    private static List<String> focusKeys = null;\n+\n+    private enum CommandOption {\n+        SHOW_SOURCE(\"--show-source\", \"show source files\"),\n+        VERBOSE(\"--verbose\", \"show extra information\"),\n+        SHOW_SERIAL_STREAM(\"--show-serial\", \"show and format the serialized stream\"),\n+        EVERYTHING(\"--everything\", \"run all tests\"),\n+        TRACE(\"--trace\", \"set TRACE system property of ObjectInputStream (temp)\"),\n+        MAX_COMBOS(\"--max-combo\", \"maximum number of values for each parameter\", CommandOption::parseInt),\n+        NO_PRE_FILTER(\"--no-pre-filter\", \"disable pre-filter checks\"),\n+        SELFTEST(\"--self-test\", \"run some self tests and exit\"),\n+        ;\n+        private final String option;\n+        private final String usage;\n+        private final BiFunction<CommandOption, String, Boolean> parseArg;\n+        private Optional<Object> value;\n+        CommandOption(String option, String usage, BiFunction<CommandOption, String, Boolean> parseArg) {\n+            this.option = option;\n+            this.usage = usage;\n+            this.parseArg = parseArg;\n+            this.value = Optional.empty();\n+        }\n+        CommandOption(String option, String usage) {\n+            this(option, usage, null);\n+        }\n+\n+        \/**\n+         * Evaluate and parse an array of command line args\n+         * @param args array of strings\n+         * @return true if parsing succeeded\n+         *\/\n+        static boolean parseOptions(String[] args) {\n+            boolean unknownArg = false;\n+            for (int i = 0; i < args.length; i++) {\n+                String arg = args[i];\n+                Optional<CommandOption> knownOpt = Arrays.stream(CommandOption.values())\n+                        .filter(o -> o.option.equals(arg))\n+                        .findFirst();\n+                if (knownOpt.isEmpty()) { \/\/ Not a recognized option\n+                    if (arg.startsWith(\"-\")) {\n+                        System.err.println(\"Unrecognized option: \" + arg);\n+                        unknownArg = true;\n+                    } else {\n+                        \/\/ Take the remaining non-option args as selectors of keys to be run\n+                        String[] keys = Arrays.copyOfRange(args, i, args.length);\n+                        focusKeys = List.of(keys);\n+                    }\n+                } else {\n+                    CommandOption option = knownOpt.get();\n+                    if (option.parseArg == null) {\n+                        option.setValue(true);\n+                    } else {\n+                        i++;\n+                        if (i >= args.length || args[i].startsWith(\"--\")) {\n+                            System.err.println(\"Missing argument for \" + option.option);\n+                            continue;\n+                        }\n+                        option.parseArg.apply(option, args[i]);\n+                    }\n+                }\n+            }\n+            return !unknownArg;\n+        }\n+        static void showUsage() {\n+            System.out.println(\"\"\"\n+                Usage:\n+                \"\"\");\n+            Arrays.stream(CommandOption.values()).forEach(o -> System.out.printf(\"  %-15s: %s\\n\", o.option, o.usage));\n+        }\n+        boolean present() {\n+            return value != null && value.isPresent();\n+        }\n+        void setValue(Object o) {\n+            value = Optional.ofNullable(o);\n+        }\n+        private static boolean parseInt(CommandOption option, String arg) {\n+            try {\n+                int count = Integer.parseInt(arg);\n+                option.setValue(count);\n+            } catch (NumberFormatException nfe) {\n+                System.out.println(\"--max-combo argument not a number: \" + arg);\n+            }\n+            return true;\n+        }\n+        \/\/ Get the int value from the option, defaulting if not valid or present\n+        private int getInt(int otherMax) {\n+            Object obj = value == null ? otherMax : value.orElseGet(() -> otherMax);\n+            return (obj instanceof Integer i) ? i : otherMax;\n+        }\n+    }\n+\n+    private static URLClassLoader getLoaderFor(Path path) {\n+        return LOADER_FOR_PATH.computeIfAbsent(path,\n+                p -> {\n+                    try {\n+                        \/\/ new URLClassLoader for path\n+                        Files.createDirectories(p);\n+                        URL[] urls = {p.toUri().toURL()};\n+                        return new URLClassLoader(p.toString(), urls, null);\n+                    } catch (IOException ioe) {\n+                        throw new UncheckedIOException(ioe);\n+                    }\n+                });\n+    }\n+\n+    \/\/ Map an array of strings to an array of ComboParameter.Constants.\n+    @SuppressWarnings(\"unchecked\")\n+    private static ComboParameter.Constant<String>[] paramsForStrings(String... strings) {\n+        return Arrays.stream(strings)\n+                .map(ComboParameter.Constant::new).toArray(ComboParameter.Constant[]::new);\n+    }\n+\n+    \/**\n+     * Main to generate combinations and run the tests.\n+     *\n+     * @param args may contain \"--verbose\" to show source of every file\n+     * @throws Exception In case of failure\n+     *\/\n+    public static void main(String... args) throws Exception {\n+        if (!CommandOption.parseOptions(args)) {\n+            CommandOption.showUsage();\n+            System.exit(1);\n+        }\n+\n+        Arrays.stream(CommandOption.values())\n+                .filter(o -> o.present())\n+                .forEach( o1 -> System.out.printf(\"   %15s: %s\\n\", o1.option, o1.value\n+                ));\n+\n+        if (CommandOption.SELFTEST.present()) {\n+            selftest();\n+            return;\n+        }\n+\n+        \/\/ Sets of all possible ComboParameters (substitutions)\n+        Set<ParamSet> allParams = Set.of(\n+                VALUE_SET,\n+                KIND_SET,\n+                TOP_ABSTRACT_SET,\n+                OBJECT_CONSTRUCTOR_SET,\n+                TESTNAME_EXTENDS_SET,\n+                CLASSACCESS_SET,\n+                SPECIAL_READ_METHODS_SET,\n+                SPECIAL_WRITE_METHODS_SET,\n+                EXTERNALIZABLE_METHODS_SET,\n+                FIELD_SET\n+        );\n+\n+        \/\/ Test variations of all code shapes\n+        var helper = new ComboTestHelper<SerializedObjectCombo>();\n+        int maxCombos = CommandOption.MAX_COMBOS.getInt(2);\n+\n+        Set<ParamSet> subSet = CommandOption.EVERYTHING.present() ? allParams\n+                : computeSubset(allParams, focusKeys, maxCombos);\n+        withDimensions(helper, subSet);\n+        if (CommandOption.VERBOSE.present()) {\n+            System.out.println(\"Keys; maximum combinations: \" + maxCombos);\n+            subSet.stream()\n+                    .sorted((p, q) -> String.CASE_INSENSITIVE_ORDER.compare(p.key(), q.key()))\n+                    .forEach(p -> System.out.println(\"    \" + p.key + \": \" + Arrays.toString(p.params)));\n+        }\n+        helper.withFilter(SerializedObjectCombo::filter)\n+                .withFailMode(ComboTestHelper.FailMode.FAIL_FAST)\n+                .run(SerializedObjectCombo::new);\n+    }\n+\n+    private static void withDimensions(ComboTestHelper<SerializedObjectCombo> helper, Set<ParamSet> subSet) {\n+        subSet.forEach(p -> {\n+            if (p.count() == 1)\n+                helper.withDimension(p.key(), SerializedObjectCombo::saveParameter, p.params());\n+            else\n+                helper.withArrayDimension(p.key(), SerializedObjectCombo::saveParameter, p.count(), p.params());\n+        });\n+    }\n+\n+    \/\/ Return a subset of ParamSets with the non-focused ParamSet's truncated to a max number of values\n+    private static Set<ParamSet> computeSubset(Set<ParamSet> allParams, List<String> focusKeys, int maxKeys) {\n+        if (focusKeys == null || focusKeys.isEmpty())\n+            return allParams;\n+        Set<ParamSet> r = allParams.stream().map(p ->\n+                        (focusKeys.contains(p.key())) ? p\n+                                : new ParamSet(p.key, p.count(), Arrays.copyOfRange(p.params(), 0, Math.min(p.params().length, maxKeys))))\n+                .collect(Collectors.toUnmodifiableSet());\n+        return r;\n+    }\n+\n+    \/**\n+     * Print the source files to System out\n+     *\n+     * @param task the compilation task\n+     *\/\n+    static void showSources(ComboTask task) {\n+        task.getSources()\n+                .forEach(fo -> {\n+                    System.out.println(\"Source: \" + fo.getName());\n+                    System.out.println(getSource(fo));\n+                });\n+    }\n+\n+    \/**\n+     * Return the contents of the source file\n+     *\n+     * @param fo a file object\n+     * @return the contents of the source file\n+     *\/\n+    static String getSource(JavaFileObject fo) {\n+        try (Reader reader = fo.openReader(true)) {\n+            char[] buf = new char[100000];\n+            var len = reader.read(buf);\n+            return new String(buf, 0, len);\n+        } catch (IOException ioe) {\n+            return \"IOException: \" + fo.getName() + \", ex: \" + ioe.getMessage();\n+        }\n+    }\n+\n+    \/**\n+     * Dump the serial stream.\n+     *\n+     * @param bytes the bytes of the stream\n+     *\/\n+    private static void showSerialStream(byte[] bytes) {\n+        HexPrinter.simple().dest(System.out).formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+    }\n+\n+    \/**\n+     * Serialize an object into byte array.\n+     *\/\n+    private static byte[] serialize(Object obj) throws IOException {\n+        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n+        try (ObjectOutputStream out = new ObjectOutputStream(bs)) {\n+            out.writeObject(obj);\n+        }\n+        return bs.toByteArray();\n+    }\n+\n+    \/**\n+     * Deserialize an object from byte array using the requested classloader.\n+     *\/\n+    private static Object deserialize(byte[] ba, ClassLoader loader) throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream in = new LoaderObjectInputStream(new ByteArrayInputStream(ba), loader)) {\n+            return in.readObject();\n+        }\n+    }\n+\n+\n+    @Override\n+    public int id() {\n+        return ++uniqueId;\n+    }\n+\n+    private void fail(String msg, Throwable thrown) {\n+        super.fail(msg);\n+        thrown.printStackTrace(System.out);\n+    }\n+\n+    \/**\n+     * Save a parameter.\n+     *\n+     * @param param a ComboParameter\n+     *\/\n+    private void saveParameter(ComboParameter param) {\n+        saveParameter(param, 0);\n+    }\n+\n+    \/**\n+     * Save an indexed parameter.\n+     *\n+     * @param param a ComboParameter\n+     * @param index unused\n+     *\/\n+    private void saveParameter(ComboParameter param, int index) {\n+        currParams.add(param);\n+    }\n+\n+    \/**\n+     * Filter out needless tests (mostly with more variations of arguments than needed).\n+     * Usually, these are compile time failures, or code shapes that cannot succeed.\n+     *\n+     * @return true to run the test, false if not\n+     *\/\n+    boolean filter() {\n+        if (!CommandOption.NO_PRE_FILTER.present()) {\n+            for (CodeShape shape : CodeShape.values()) {\n+                if (shape.test(currParams)) {\n+                    if (CommandOption.VERBOSE.present()) {\n+                        System.out.println(\"IGNORING: \" + shape);\n+                    }\n+                    return false;\n+                }\n+            }\n+        }\n+        if (CommandOption.VERBOSE.present()) {\n+            System.out.println(\"TESTING: \");\n+            showParams();\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Generate the source files from the parameters and test a single combination.\n+     * Two versions are compiled into different directories and separate class loaders.\n+     * They differ only with the addition of a field to the generated class.\n+     * Then each class is serialized and deserialized by the other class,\n+     * testing simple evolution in the process.\n+     *\n+     * @throws IOException catch all IOException\n+     *\/\n+    @Override\n+    public void doWork() throws IOException {\n+        String cp = System.getProperty(\"test.classes\");\n+        String className = \"Class_\" + this.id();\n+\n+        \/\/ new URLClassLoader for path\n+        final Path firstPath = Path.of(cp, \"1st\");\n+        URLClassLoader firstLoader = getLoaderFor(firstPath);\n+        final Path secondPath = Path.of(cp, \"2nd\");\n+        URLClassLoader secondLoader = getLoaderFor(secondPath);\n+\n+        \/\/ Create a map of additional constants that are resolved without the combo overhead.\n+        final Map<String, ComboParameter.Constant<String>> params = new HashMap<>();\n+        params.put(\"TESTNAME\", new ComboParameter.Constant<>(className));\n+        params.put(\"SPECIAL_METHODS_SERIALIZABLE\", new ComboParameter.Constant<>(\"#{SPECIAL_READ_METHODS} #{SPECIAL_WRITE_METHODS}\"));\n+        params.put(\"SPECIAL_METHODS_EXTERNALIZABLE\", new ComboParameter.Constant<>(\"#{EXTERNALIZABLE_METHODS}\"));\n+        params.put(\"FIELD_ADDITIONS\", new ComboParameter.Constant<>(\"\"));\n+        params.put(\"FIELD_CONSTRUCTOR_ADDITIONS\", new ComboParameter.Constant<>(\"\"));\n+        params.put(\"FIELD_TOSTRING_ADDITIONS\", new ComboParameter.Constant<>(\"\"));\n+\n+        final ComboTask firstTask = generateAndCompile(firstPath, className, params);\n+\n+        if (firstTask == null) {\n+            return; \/\/ Skip execution, errors already reported\n+        }\n+\n+        if (CommandOption.EVERYTHING.present()) {\n+            params.put(\"FIELD_ADDITIONS\", new ComboParameter.Constant<>(\"int fExtra;\"));\n+            params.put(\"FIELD_CONSTRUCTOR_ADDITIONS\", new ComboParameter.Constant<>(\"this.fExtra = 99;\"));\n+            params.put(\"FIELD_TOSTRING_ADDITIONS\", new ComboParameter.Constant<>(\"+ \\\", fExtra: String.valueOf(fExtra)\\\"\"));\n+            final ComboTask secondTask = generateAndCompile(secondPath, className, params);\n+            if (secondTask == null) {\n+                return; \/\/ Skip execution, errors already reported\n+            }\n+\n+            doTestWork(className, firstTask, firstLoader, secondLoader);\n+            doTestWork(className, secondTask, secondLoader, firstLoader);\n+        } else {\n+            doTestWork(className, firstTask, firstLoader, firstLoader);\n+        }\n+    }\n+\n+    \/**\n+     * Test that two versions of the class can be serialized using one version and deserialized\n+     * by the other version.\n+     * The two classes have the same name and have been compiled into different classloaders.\n+     * The original and result objects are compared using .equals if there is only 1 classloader.\n+     * If the classloaders are different the `toString()` output for each object is compared loosely.\n+     * (One must be the prefix of the other)\n+     *\n+     * @param className    the class name\n+     * @param task         the task context (for source and parameters to report failures)\n+     * @param firstLoader  the first classloader\n+     * @param secondLoader the second classloader\n+     *\/\n+    private void doTestWork(String className, ComboTask task, ClassLoader firstLoader, ClassLoader secondLoader) {\n+        byte[] bytes = null;\n+        try {\n+            Class<?> tc = Class.forName(className, true, firstLoader);\n+            Object testObj = tc.getDeclaredConstructor().newInstance();\n+            bytes = serialize(testObj);\n+            if (CommandOption.VERBOSE.present()) {\n+                System.out.println(\"Testing: \" + task.getSources());\n+                if (CommandOption.SHOW_SOURCE.present()) {\n+                    showParams();\n+                    showSources(task);\n+                }\n+                if (CommandOption.SHOW_SERIAL_STREAM.present()) {\n+                    showSerialStream(bytes);\n+                }\n+            }\n+\n+            if (CodeShape.BAD_SO_CONSTRUCTOR.test(currParams)) {\n+                \/\/ should have thrown ICE due to mismatch between value class and missing constructor\n+                System.out.println(CodeShape.BAD_SO_CONSTRUCTOR.explain(currParams));\n+                fail(CodeShape.BAD_SO_CONSTRUCTOR.explain(currParams));\n+            }\n+\n+            Object actual = deserialize(bytes, secondLoader);\n+            if (testObj.getClass().getClassLoader().equals(actual.getClass().getClassLoader())) {\n+                assertEquals(testObj, actual, \"Round-trip comparison fail using .equals\");\n+            } else {\n+                \/\/ The instances are from different classloaders and can't be compared directly\n+                final String s1 = testObj.toString();\n+                final String s2 = actual.toString();\n+                assertTrue(s1.startsWith(s2) || s2.startsWith(s1),\n+                        \"Round-trip comparison fail using toString(): s1: \" + s1 + \", s2: \" + s2);\n+            }\n+        } catch (InvalidClassException ice) {\n+            for (CodeShape shape : CodeShape.values()){\n+                if (ice.equals(shape.exception)) {\n+                    if (shape.test(currParams)) {\n+                        if (CommandOption.VERBOSE.present()) {\n+                            System.out.println(\"OK: \" + shape.explain(currParams));\n+                        } else {\n+                            \/\/ unexpected ICE\n+                            ice.printStackTrace(System.out);\n+                            showParams();\n+                            showSources(task);\n+                            if (bytes != null)\n+                                showSerialStream(bytes);\n+                            fail(ice.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (EOFException | OptionalDataException eof) {\n+            \/\/ Ignore if conditions of the source invite EOF\n+            if (0 == CodeShape.shapesThrowing(EOFException.class).peek(s -> {\n+                \/\/ Ignore: Serialized Object to reads custom data but none written\n+                if (CommandOption.VERBOSE.present()) {\n+                    System.out.println(\"OK: \" + s.explain(currParams));\n+                }\n+            }).count()) {\n+                eof.printStackTrace(System.out);\n+                showParams();\n+                showSources(task);\n+                showSerialStream(bytes);\n+                fail(eof.getMessage(), eof);\n+            }\n+        } catch (ClassFormatError cfe) {\n+            System.out.println(cfe.toString());\n+        } catch (NotSerializableException nse) {\n+            if (CodeShape.BAD_EXT_VALUE.test(currParams)) {\n+                \/\/ Expected Value class that is Externalizable w\/o writeReplace\n+            } else {\n+                \/\/ unexpected NSE\n+                nse.printStackTrace(System.out);\n+                showParams();\n+                showSources(task);\n+                fail(nse.getMessage(), nse);\n+            }\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            showParams();\n+            showSources(task);\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    \/\/ Side effect of error is compilationResult.hasErrors() > 0\n+    private ComboTask generateAndCompile(Path path, String className, Map<String, ComboParameter.Constant<String>> params) {\n+        ComboTask task = newCompilationTask()\n+                .withSourceFromTemplate(className,\n+                        TEST_SOURCE_TEMPLATE,\n+                        r -> params.computeIfAbsent(r, s -> new ComboParameter.Constant<>(\"UNKNOWN_\" + s)))\n+                .withOption(\"-d\")\n+                .withOption(path.toString())\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"--add-modules\")\n+                .withOption(\"java.base\")\n+                .withOption(\"--add-exports\")\n+                .withOption(\"java.base\/jdk.internal=ALL-UNNAMED\")\n+                .withOption(\"--add-exports\")\n+                .withOption(\"java.base\/jdk.internal.value=ALL-UNNAMED\")\n+                .withOption(\"--source\")\n+                .withOption(Integer.toString(Runtime.version().feature()));\n+        ;\n+        task.generate(this::checkCompile);\n+        if (compilationResult.hasErrors()) {\n+            boolean match = false;\n+            for (CodeShape shape : CodeShape.values()){\n+                if (CompileException.class.equals(shape.exception)) {\n+                    if (shape.test(currParams)) {\n+                        \/\/ shape matches known error\n+                        if (!uniqueParams.contains(shape))  {\n+                            System.out.println(\"\/\/ Unique: \" + shape);\n+                            uniqueParams.add(shape);\n+                        }\n+                        match = true;\n+                    }\n+                }\n+            }\n+            if (match)\n+                return null;\n+            \/\/ Unexpected compilation error\n+            showDiags(compilationResult);\n+            showSources(task);\n+            showParams();\n+            fail(\"Compilation failure\");\n+        }\n+        return task;\n+    }\n+\n+    private static Set<CodeShape> uniqueParams = new HashSet<>();\n+\n+    private String paramToString(ComboParameter param) {\n+        String name = param.getClass().getName();\n+        return name.substring(name.indexOf('$') + 1) + \"::\" +\n+                param + \": \" + truncate(param.expand(null), 60);\n+    }\n+\n+    private void showParams() {\n+        currParams.stream()\n+                .sorted((p, q) -> String.CASE_INSENSITIVE_ORDER.compare(paramToString(p), paramToString(q)))\n+                .forEach(p -> System.out.println(\"    \" + paramToString(p)));\n+    }\n+\n+    private void showParams(ComboParameter... params) {\n+        for (ComboParameter param : params) {\n+            System.out.println(\">>> \" + paramToString(param) + \", present: \"\n+                    + currParams.contains(param));\n+        }\n+    }\n+\n+    private static String truncate(String s, int maxLen) {\n+        int nl = s.indexOf(\"\\n\");\n+        if (nl >= 0)\n+            maxLen = nl;\n+        if (maxLen < s.length()) {\n+            return s.substring(0, maxLen).concat(\"...\");\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    \/**\n+     * Report any compilation errors.\n+     *\n+     * @param res the result\n+     *\/\n+    void checkCompile(ComboTask.Result<?> res) {\n+        compilationResult = res;\n+    }\n+\n+    void showDiags(ComboTask.Result<?> res) {\n+        res.diagnosticsForKind(Diagnostic.Kind.ERROR).forEach(SerializedObjectCombo::showDiag);\n+        res.diagnosticsForKind(Diagnostic.Kind.WARNING).forEach(SerializedObjectCombo::showDiag);\n+    }\n+\n+    static void showDiag(Diagnostic<? extends JavaFileObject> diag) {\n+        System.out.println(diag.getKind() + \": \" + diag.getMessage(Locale.ROOT));\n+        System.out.println(\"File: \" + diag.getSource() +\n+                \" line: \" + diag.getLineNumber() + \", col: \" + diag.getColumnNumber());\n+    }\n+\n+    private static class CodeShapePredicateOp<T> implements Predicate<T> {\n+        private final Predicate<T> first;\n+        private final Predicate<T> other;\n+        private final String op;\n+\n+        CodeShapePredicateOp(Predicate<T> first, Predicate<T> other, String op) {\n+            if (\"OR\" != op && \"AND\" != op && \"NOT\" != op)\n+                throw new IllegalArgumentException(\"unknown op: \" + op);\n+            this.first = first;\n+            this.other = other;\n+            this.op = op;\n+        }\n+\n+        @Override\n+        public boolean test(T comboParameters) {\n+            return switch (op) {\n+                case \"NOT\" -> !first.test(comboParameters);\n+                case \"OR\" -> first.test(comboParameters) || other.test(comboParameters);\n+                case \"AND\" -> first.test(comboParameters) && other.test(comboParameters);\n+                default -> throw new IllegalArgumentException(\"unknown op: \" + op);\n+            };\n+        }\n+        @Override\n+        public Predicate<T> and(Predicate<? super T> other) {\n+            return new CodeShapePredicateOp(this, other,\"AND\");\n+        }\n+\n+\n+        @Override\n+        public Predicate<T>  negate() {\n+            return new CodeShapePredicateOp(this, null,\"NOT\");\n+        }\n+\n+        @Override\n+        public Predicate<T> or(Predicate<? super T> other) {\n+            return new CodeShapePredicateOp(this, other,\"OR\");\n+        }\n+        public String toString() {\n+            return switch (op) {\n+                case \"NOT\" -> op + \" \" + first;\n+                case \"OR\" -> \"(\" + first + \" \" + op + \" \" + other + \")\";\n+                case \"AND\" -> \"(\" + first + \" \" + op + \" \" + other + \")\";\n+                default -> throw new IllegalArgumentException(\"unknown op: \" + op);\n+            };\n+        }\n+    }\n+\n+    interface CodeShapePredicate extends Predicate<Set<ComboParameter>> {\n+        @Override\n+        default boolean test(Set<ComboParameter> comboParameters) {\n+            return comboParameters.contains(this);\n+        }\n+\n+        @Override\n+        default Predicate<Set<ComboParameter>> and(Predicate<? super Set<ComboParameter>> other) {\n+            return new CodeShapePredicateOp(this, other,\"AND\");\n+        }\n+\n+\n+        @Override\n+        default Predicate<Set<ComboParameter>>  negate() {\n+            return new CodeShapePredicateOp(this, null,\"NOT\");\n+        }\n+\n+        @Override\n+        default Predicate<Set<ComboParameter>> or(Predicate<? super Set<ComboParameter>> other) {\n+            return new CodeShapePredicateOp(this, other,\"OR\");\n+        }\n+    }\n+\n+    \/**\n+     * A set of code shapes that are interesting, usually indicating an error\n+     * compile time, or runtime based on the shape of the code and the dependencies between\n+     * the code fragments.\n+     * The descriptive text may be easier to understand than the boolean expression of the fragments.\n+     * They can also be to filter out test cases that would not succeed.\n+     * Or can be used after a successful deserialization to check\n+     * if an exception should have been thrown.\n+     *\/\n+    private enum CodeShape implements Predicate<Set<ComboParameter>> {\n+        BAD_SO_CONSTRUCTOR(\"Value class does not have a constructor annotated with DeserializeConstructor\",\n+                InvalidClassException.class,\n+                ValueKind.VALUE,\n+                ObjectConstructorFragment.ANNOTATED_OBJECT_CONSTRUCTOR_FRAGMENT.negate()\n+                ),\n+        BAD_EXT_VALUE(\"Externalizable can not be a value class\",\n+                CompileException.class,\n+                SerializationKind.EXTERNALIZABLE,\n+                ValueKind.VALUE),\n+        BAD_EXT_METHODS(\"Externalizable methods but not Externalizable\",\n+                CompileException.class,\n+                ExternalizableMethodFragments.EXTERNALIZABLE_METHODS,\n+                SerializationKind.EXTERNALIZABLE.negate()),\n+        BAD_EXT_NO_METHODS(\"Externalizable but no implementation of readExternal or writeExternal\",\n+                CompileException.class,\n+                SerializationKind.EXTERNALIZABLE,\n+                ExternalizableMethodFragments.EXTERNALIZABLE_METHODS.negate()),\n+        BAD_VALUE_NON_ABSTRACT_SUPER(\"Can't inherit from non-abstract super or abstract super with fields\",\n+                CompileException.class,\n+                ValueKind.VALUE,\n+                TestNameExtendsFragments.TESTNAME_EXTENDS_FRAGMENT,\n+                TopFragments.ABSTRACT_NO_FIELDS.negate()),\n+        BAD_MISSING_SUPER(\"Extends TOP_ without TOP_ superclass\",\n+                CompileException.class,\n+                TestNameExtendsFragments.TESTNAME_EXTENDS_FRAGMENT,\n+                TopFragments.NONE),\n+        BAD_READ_CUSTOM_METHODS(\"Custom read fragment but no custom write fragment\",\n+                EOFException.class,\n+                ReadObjectFragments.READ_OBJECT_FIELDS_CUSTOM_FRAGMENT\n+                        .or(ReadObjectFragments.READ_OBJECT_DEFAULT_CUSTOM_FRAGMENT),\n+                WriteObjectFragments.WRITE_OBJECT_FIELDS_CUSTOM_FRAGMENT\n+                        .or(WriteObjectFragments.WRITE_OBJECT_DEFAULT_CUSTOM_FRAGMENT).negate()\n+                ),\n+        BAD_RW_CUSTOM_METHODS(\"Custom write fragment but no custom read fragment\",\n+                null,\n+                WriteObjectFragments.WRITE_OBJECT_FIELDS_CUSTOM_FRAGMENT\n+                        .or(WriteObjectFragments.WRITE_OBJECT_DEFAULT_CUSTOM_FRAGMENT),\n+                ReadObjectFragments.READ_OBJECT_FIELDS_CUSTOM_FRAGMENT\n+                        .or(ReadObjectFragments.READ_OBJECT_DEFAULT_CUSTOM_FRAGMENT).negate()),\n+        BAD_VALUE_READOBJECT_METHODS(\"readObjectXXX(OIS) methods incompatible with Value class\",\n+                CompileException.class,\n+                ReadObjectFragments.READ_OBJECT_FIELDS_FRAGMENT\n+                        .or(ReadObjectFragments.READ_OBJECT_DEFAULT_FRAGMENT)\n+                        .or(ReadObjectFragments.READ_OBJECT_FIELDS_CUSTOM_FRAGMENT)\n+                        .or(ReadObjectFragments.READ_OBJECT_DEFAULT_CUSTOM_FRAGMENT),\n+                ValueKind.VALUE),\n+        ;\n+\n+        private final String description;\n+        private final Class<? extends Exception> exception;\n+        private final List<Predicate<Set<ComboParameter>>> predicates;\n+        CodeShape(String desc, Class<? extends Exception> exception, Predicate<Set<ComboParameter>>... predicates) {\n+            this.description = desc;\n+            this.exception = exception;\n+            this.predicates = List.of(predicates);\n+        }\n+\n+        \/\/ Return a stream of CodeShapes throwing the exception\n+        static Stream<CodeShape> shapesThrowing(Class<?> exception) {\n+            return Arrays.stream(values()).filter(s -> exception.equals(s.exception));\n+\n+        }\n+\n+        \/**\n+         * {@return true if all of the predicates are true in the set of ComboParameters}\n+         * @param comboParameters a set of ComboParameters\n+         *\/\n+        @Override\n+        public boolean test(Set<ComboParameter> comboParameters) {\n+            for (Predicate<Set<ComboParameter>> p : predicates) {\n+                if (!p.test(comboParameters))\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        \/**\n+         * {@return a string describing the predicate in relation to a set of parameters}\n+         * @param comboParameters a set of active ComboParameters.\n+         *\/\n+        public String explain(Set<ComboParameter> comboParameters) {\n+            StringBuffer sbTrue = new StringBuffer();\n+            StringBuffer sbFalse = new StringBuffer();\n+            for (Predicate<Set<ComboParameter>> p : predicates) {\n+                ((p.test(comboParameters)) ? sbTrue : sbFalse)\n+                        .append(p).append(\", \");\n+            }\n+            return description + \"\\n\" +\"Missing: \" + sbFalse + \"\\nTrue: \" + sbTrue;\n+        }\n+        public String toString() {\n+            return super.toString() + \"::\" + description + \", params: \" + predicates;\n+        }\n+    }\n+\n+    \/**\n+     * TopAbstract Fragments\n+     *\/\n+    enum TopFragments implements ComboParameter, CodeShapePredicate {\n+        NONE(\"\"),\n+        ABSTRACT_NO_FIELDS(\"\"\"\n+                @MigratedValueClass\n+                abstract #{VALUE} class TOP_#{TESTNAME} implements Serializable {\n+                    #{CLASSACCESS} TOP_#{TESTNAME}() {}\n+                }\n+                \"\"\"),\n+        ABSTRACT_ONE_FIELD(\"\"\"\n+                @MigratedValueClass\n+                abstract #{VALUE} class TOP_#{TESTNAME} implements Serializable {\n+                    private int t1;\n+                    #{CLASSACCESS} TOP_#{TESTNAME}() {\n+                        t1 = 1;\n+                    }\n+                }\n+                \"\"\"),\n+        NO_FIELDS(\"\"\"\n+                @MigratedValueClass\n+                #{VALUE} class TOP_#{TESTNAME} implements Serializable {\n+                    #{CLASSACCESS} TOP_#{TESTNAME}() {}\n+                }\n+                \"\"\"),\n+        ONE_FIELD(\"\"\"\n+                @MigratedValueClass\n+                #{VALUE} class TOP_#{TESTNAME} implements Serializable {\n+                    private int t1;\n+                    #{CLASSACCESS} TOP_#{TESTNAME}() {\n+                        t1 = 1;\n+                    }\n+                }\n+                \"\"\"),\n+        ;\n+\n+        private final String template;\n+\n+        TopFragments(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    \/**\n+     * TopAbstract Fragments\n+     *\/\n+    enum TestNameExtendsFragments implements ComboParameter, CodeShapePredicate {\n+        NONE(\"\"),\n+        TESTNAME_EXTENDS_FRAGMENT(\"extends TOP_#{TESTNAME}\"),\n+        ;\n+\n+        private final String template;\n+\n+        TestNameExtendsFragments(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    \/**\n+     * SerializedObjectCustom Fragments\n+     *\/\n+    enum SerializedObjectCustomFragments implements ComboParameter, CodeShapePredicate {\n+        NONE(\"\"),\n+        ;\n+\n+        private final String template;\n+\n+        SerializedObjectCustomFragments(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    \/**\n+     * ExternalizableMethod Fragments\n+     *\/\n+    enum ExternalizableMethodFragments implements ComboParameter, CodeShapePredicate {\n+        NONE(\"\"),\n+        EXTERNALIZABLE_METHODS(\"\"\"\n+                    public void writeExternal(ObjectOutput oos) throws IOException {\n+                        oos.write#{FIELD[0].READFIELD}(f1);\n+                        oos.write#{FIELD[1].READFIELD}(f2);\n+                    }\n+\n+                    public void readExternal(ObjectInput ois) throws IOException, ClassNotFoundException {\n+                        f1 = (#{FIELD[0]})ois.read#{FIELD[0].READFIELD}();\n+                        f2 = (#{FIELD[1]})ois.read#{FIELD[1].READFIELD}();\n+                    }\n+                \"\"\"),\n+        ;\n+\n+        private final String template;\n+\n+        ExternalizableMethodFragments(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    \/**\n+     * ObjectConstructorFragment Fragments\n+     *\/\n+    enum ObjectConstructorFragment implements ComboParameter, CodeShapePredicate {\n+        NONE(\"\"),\n+        ANNOTATED_OBJECT_CONSTRUCTOR_FRAGMENT(\"\"\"\n+                    @DeserializeConstructor\n+                    #{CLASSACCESS} #{TESTNAME}(#{FIELD[0]} f1, #{FIELD[1]} f2) {\n+                        this.f1 = f1;\n+                        this.f2 = f2;\n+                        #{FIELD_CONSTRUCTOR_ADDITIONS}\n+                    }\n+\n+                    @DeserializeConstructor\n+                    #{CLASSACCESS} #{TESTNAME}(#{FIELD[0]} f1, #{FIELD[1]} f2, int fExtra) {\n+                        this.f1 = f1;\n+                        this.f2 = f2;\n+                        #{FIELD_CONSTRUCTOR_ADDITIONS}\n+                    }\n+                \"\"\"),\n+\n+        ;\n+\n+        private final String template;\n+\n+        ObjectConstructorFragment(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    \/**\n+     * WriteObject templates\n+     *\/\n+    enum WriteObjectFragments implements ComboParameter, CodeShapePredicate {\n+        NONE(\"\"),\n+        WRITE_OBJECT_DEFAULT_FRAGMENT(\"\"\"\n+                    private void writeObject(ObjectOutputStream oos) throws IOException {\n+                        oos.defaultWriteObject();\n+                    }\n+                \"\"\"),\n+        WRITE_OBJECT_FIELDS_FRAGMENT(\"\"\"\n+                    private void writeObject(ObjectOutputStream oos) throws IOException {\n+                        ObjectOutputStream.PutField fields = oos.putFields();\n+                        fields.put(\"f1\", f1);\n+                        fields.put(\"f2\", f2);\n+                        oos.writeFields();\n+                    }\n+                \"\"\"),\n+        WRITE_OBJECT_DEFAULT_CUSTOM_FRAGMENT(\"\"\"\n+                    private void writeObject(ObjectOutputStream oos) throws IOException {\n+                        oos.defaultWriteObject();\n+                        \/\/ Write custom data\n+                        oos.write#{FIELD[0].READFIELD}(#{FIELD[0].DEFAULT});\n+                        oos.write#{FIELD[1].READFIELD}(#{FIELD[1].DEFAULT});\n+                    }\n+                \"\"\"),\n+        WRITE_OBJECT_FIELDS_CUSTOM_FRAGMENT(\"\"\"\n+                    private void writeObject(ObjectOutputStream oos) throws IOException {\n+                        ObjectOutputStream.PutField fields = oos.putFields();\n+                        fields.put(\"f1\", f1);\n+                        fields.put(\"f2\", f2);\n+                        oos.writeFields();\n+                        \/\/ Write custom data\n+                        oos.write#{FIELD[0].READFIELD}(#{FIELD[0].DEFAULT});\n+                        oos.write#{FIELD[1].READFIELD}(#{FIELD[1].DEFAULT});\n+                    }\n+                \"\"\"),\n+        ;\n+\n+        private final String template;\n+\n+        WriteObjectFragments(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    \/**\n+     * ReadObject templates\n+     *\/\n+    enum ReadObjectFragments implements ComboParameter, CodeShapePredicate {\n+        NONE(\"\"),\n+        READ_OBJECT_DEFAULT_FRAGMENT(\"\"\"\n+                    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+                        ois.defaultReadObject();\n+                    }\n+                \"\"\"),\n+        READ_OBJECT_FIELDS_FRAGMENT(\"\"\"\n+                    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+                        ObjectInputStream.GetField fields = ois.readFields();\n+                        this.f1 = (#{FIELD[0]})fields.get(\"f1\", #{FIELD[0].DEFAULT});\n+                        this.f2 = (#{FIELD[1]})fields.get(\"f2\", #{FIELD[1].DEFAULT});\n+                    }\n+                 \"\"\"),\n+        READ_OBJECT_DEFAULT_CUSTOM_FRAGMENT(\"\"\"\n+                    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+                        ois.defaultReadObject();\n+                        \/\/ Read custom data\n+                        #{FIELD[0]} d1 = (#{FIELD[0]})ois.read#{FIELD[0].READFIELD}();\n+                        #{FIELD[1]} d2 = (#{FIELD[1]})ois.read#{FIELD[1].READFIELD}();\n+                        assert Objects.equals(#{FIELD[0].DEFAULT}, d1) : \"reading custom data1, actual: \" + d1;\n+                        assert Objects.equals(#{FIELD[1].DEFAULT}, d2) : \"reading custom data2, actual: \" + d2;\n+                    }\n+                \"\"\"),\n+        READ_OBJECT_FIELDS_CUSTOM_FRAGMENT(\"\"\"\n+                    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+                        ObjectInputStream.GetField fields = ois.readFields();\n+                        this.f1 = (#{FIELD[0]})fields.get(\"f1\", #{FIELD[0].DEFAULT});\n+                        this.f2 = (#{FIELD[1]})fields.get(\"f2\", #{FIELD[1].DEFAULT});\n+                        \/\/ Read custom data\n+                        #{FIELD[0]} d1 = (#{FIELD[0]})ois.read#{FIELD[0].READFIELD}();\n+                        #{FIELD[1]} d2 = (#{FIELD[1]})ois.read#{FIELD[1].READFIELD}();\n+                        assert Objects.equals(#{FIELD[0].DEFAULT}, d1) : \"reading custom data1, actual: \" + d1;\n+                        assert Objects.equals(#{FIELD[1].DEFAULT}, d2) : \"reading custom data2, actual: \" + d2;\n+                    }\n+                 \"\"\"),\n+        ;\n+\n+        private final String template;\n+\n+        ReadObjectFragments(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    \/**\n+     * Value and Identity kinds.\n+     *\/\n+    enum ValueKind implements ComboParameter, CodeShapePredicate {\n+        VALUE(\"value\"),\n+        IDENTITY(\"\"),\n+        ;\n+\n+        private final String template;\n+\n+        ValueKind(String template) {\n+            this.template = template;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return template;\n+        }\n+    }\n+\n+    enum SerializationKind implements ComboParameter, CodeShapePredicate {\n+        SERIALIZABLE(\"SER\", \"implements Serializable\"),\n+        EXTERNALIZABLE(\"EXT\", \"implements Externalizable\"),\n+        ;\n+\n+        private final String key;\n+        private final String declaration;\n+\n+        SerializationKind(String key, String declaration) {\n+            this.key = key;\n+            this.declaration = declaration;\n+        }\n+\n+        public String expand(String optParameter) {\n+            return switch (optParameter) {\n+                case null -> key;\n+                case \"IMPLEMENTS\" -> declaration;\n+                default ->\n+                        \"#{\" + optParameter + \"_\" + this + \"}\";   \/\/ everything ELSE turn into requested key with suffix\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * Class Access kinds.\n+     *\/\n+    enum ClassAccessKind implements ComboParameter, CodeShapePredicate {\n+        PUBLIC(\"public\"),\n+        PACKAGE(\"\"),\n+        ;\n+\n+        private final String classAccessTemplate;\n+\n+        ClassAccessKind(String classAccessTemplate) {\n+            this.classAccessTemplate = classAccessTemplate;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return classAccessTemplate;\n+        }\n+    }\n+\n+    \/**\n+     * Type of arguments to insert in method signatures\n+     *\/\n+    enum ArgumentValue implements ComboParameter, CodeShapePredicate {\n+        BOOLEAN(\"boolean\", true),\n+        BYTE(\"byte\", (byte) 127),\n+        CHAR(\"char\", 'Z'),\n+        SHORT(\"short\", (short) 0x7fff),\n+        INT(\"int\", 0x7fffffff),\n+        LONG(\"long\", 0x7fffffffffffffffL),\n+        FLOAT(\"float\", 1.0F),\n+        DOUBLE(\"double\", 1.0d),\n+        STRING(\"String\", \"xyz\");\n+\n+        static final ArgumentValue[] BASIC_VALUES = {INT, STRING};\n+\n+        private final String argumentsValueTemplate;\n+        private final Object value;\n+\n+        ArgumentValue(String argumentsValueTemplate, Object value) {\n+            this.argumentsValueTemplate = argumentsValueTemplate;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return switch (optParameter) {\n+                case null -> argumentsValueTemplate;\n+                case \"TITLECASE\" -> Character.toTitleCase(argumentsValueTemplate.charAt(0)) +\n+                        argumentsValueTemplate.substring(1);\n+                case \"DEFAULT\" -> switch (this) {\n+                    case BOOLEAN -> \"false\";\n+                    case BYTE -> \"(byte)-1\";\n+                    case CHAR -> \"'\" + \"!\" + \"'\";\n+                    case SHORT -> \"(short)-1\";\n+                    case INT -> \"-1\";\n+                    case LONG -> \"-1L\";\n+                    case FLOAT -> \"-1.0f\";\n+                    case DOUBLE -> \"-1.0d\";\n+                    case STRING -> '\"' + \"n\/a\" + '\"';\n+                };\n+                case \"READFIELD\" -> switch (this) {\n+                    case BOOLEAN -> \"Boolean\";\n+                    case BYTE -> \"Byte\";\n+                    case CHAR -> \"Char\";\n+                    case SHORT -> \"Short\";\n+                    case INT -> \"Int\";\n+                    case LONG -> \"Long\";\n+                    case FLOAT -> \"Float\";\n+                    case DOUBLE -> \"Double\";\n+                    case STRING -> \"Object\";\n+                };\n+                case \"RANDOM\" -> switch (this) {  \/\/ or can be Random\n+                    case BOOLEAN -> Boolean.toString(!(boolean) value);\n+                    case BYTE -> \"(byte)\" + value + 1;\n+                    case CHAR -> \"'\" + value + \"'\";\n+                    case SHORT -> \"(short)\" + value + 1;\n+                    case INT -> \"-2\";\n+                    case LONG -> \"-2L\";\n+                    case FLOAT -> (1.0f + (float) value) + \"f\";\n+                    case DOUBLE -> (1.0d + (float) value) + \"d\";\n+                    case STRING -> \"\\\"\" + value + \"!\\\"\";\n+                };\n+                default -> switch (this) {\n+                    case BOOLEAN -> value.toString();\n+                    case BYTE -> \"(byte)\" + value;\n+                    case CHAR -> \"'\" + value + \"'\";\n+                    case SHORT -> \"(short)\" + value;\n+                    case INT -> \"-1\";\n+                    case LONG -> \"-1L\";\n+                    case FLOAT -> value + \"f\";\n+                    case DOUBLE -> value + \"d\";\n+                    case STRING -> '\"' + (String) value + '\"';\n+                };\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * Set of Parameters to fill in template.\n+     *\n+     * @param key    the key\n+     * @param params the ComboParameters (one or more)\n+     *\/\n+    record ParamSet(String key, int count, ComboParameter... params) {\n+        \/**\n+         * Set of parameter strings for fill in template.\n+         * The strings are mapped to CompboParameter.Constants.\n+         *\n+         * @param key     the key\n+         * @param strings varargs strings\n+         *\/\n+        ParamSet(String key, String... strings) {\n+            this(key, 1, paramsForStrings(strings));\n+        }\n+\n+        \/**\n+         * Set of parameter strings for fill in template.\n+         * The strings are mapped to CompboParameter.Constants.\n+         *\n+         * @param key     the key\n+         * @param strings varargs strings\n+         *\/\n+        ParamSet(String key, int count, String... strings) {\n+            this(key, count, paramsForStrings(strings));\n+        }\n+\n+        \/**\n+         * Set of parameters for fill in template.\n+         * The strings are mapped to CompboParameter.Constants.\n+         *\n+         * @param key    the key\n+         * @param params varargs strings\n+         *\/\n+        ParamSet(String key, ComboParameter... params) {\n+            this(key, 1, params);\n+        }\n+    }\n+\n+    \/**\n+     * Marks conditions that should match compile time errors\n+     *\/\n+    static class CompileException extends RuntimeException {\n+        CompileException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    \/**\n+     * Custom ObjectInputStream to be resolve classes from a specific class loader.\n+     *\/\n+    private static class LoaderObjectInputStream extends ObjectInputStream {\n+        private final ClassLoader loader;\n+\n+        public LoaderObjectInputStream(InputStream in, ClassLoader loader) throws IOException {\n+            super(in);\n+            this.loader = loader;\n+        }\n+\n+        \/**\n+         * Override resolveClass to be resolve classes from the specified loader.\n+         *\n+         * @param desc an instance of class {@code ObjectStreamClass}\n+         * @return the class\n+         * @throws ClassNotFoundException if the class is not found\n+         *\/\n+        @Override\n+        protected Class<?> resolveClass(ObjectStreamClass desc) throws ClassNotFoundException {\n+            String name = desc.getName();\n+            try {\n+                return Class.forName(name, false, loader);\n+            } catch (ClassNotFoundException ex) {\n+                Class<?> cl = Class.forPrimitiveName(name);\n+                if (cl != null) {\n+                    return cl;\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+    }\n+\n+    private abstract class MyCompilationTask extends ComboInstance {\n+\n+    }\n+    private static void selftest() {\n+        Set<ComboParameter> params = Set.of(ValueKind.VALUE, SerializationKind.EXTERNALIZABLE);\n+        assertTrue(ValueKind.VALUE.test(params), \"VALUE\");\n+        assertTrue(SerializationKind.EXTERNALIZABLE.test(params), \"SerializationKind.EXTERNALIZABLE\");\n+        assertFalse(CodeShape.BAD_EXT_VALUE.test(params));\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/valueObjects\/SerializedObjectCombo.java","additions":1373,"deletions":0,"binary":false,"changes":1373,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ * @modules java.base\/jdk.internal.value\n@@ -43,1 +44,0 @@\n-import java.io.NotSerializableException;\n@@ -51,0 +51,1 @@\n+import jdk.internal.value.DeserializeConstructor;\n@@ -63,1 +64,1 @@\n-    private static boolean DEBUG = false;\n+    private static boolean DEBUG = true;\n@@ -112,1 +113,1 @@\n-     * Test serializing a object graph, and deserialize with a modification of the serialized form.\n+     * Test serializing an object graph, and deserialize with a modification of the serialized form.\n@@ -132,1 +133,1 @@\n-        \/\/ to a different class. The replacement name must be the same length as thr original name.\n+        \/\/ to a different class. The replacement name must be the same length as the original name.\n@@ -148,2 +149,3 @@\n-            Assert.assertEquals(ex.getClass(), expectedObject.getClass(), \"exception type\");\n-            Assert.assertEquals(ex.getMessage(), ((Exception)expectedObject).getMessage(), \"exception message\");\n+            ex.printStackTrace();\n+            Assert.assertEquals(ex.getClass(), expectedObject.getClass(), ex.toString());\n+            Assert.assertEquals(ex.getMessage(), ((Exception)expectedObject).getMessage(), ex.toString());\n@@ -181,1 +183,1 @@\n-     * Replace every occurence of the string in the byte array with the replacement.\n+     * Replace every occurrence of the string in the byte array with the replacement.\n@@ -196,1 +198,1 @@\n-     * Replace every occurence of the original bytes in the byte array with the replacement bytes.\n+     * Replace every occurrence of the original bytes in the byte array with the replacement bytes.\n@@ -290,1 +292,0 @@\n-            \/\/ avoid ==, is substutible check causes stack overflow.\n@@ -312,1 +313,1 @@\n-    @jdk.internal.MigratedValueClass\n+    @MigratedValueClass\n@@ -319,0 +320,1 @@\n+        @DeserializeConstructor\n@@ -339,1 +341,1 @@\n-        \/\/ Compare references but don't use ==; isSubstutitable may recurse\n+        \/\/ Compare references but don't use ==; isSubstitutable may recurse\n@@ -363,2 +365,3 @@\n-        var ex = Assert.expectThrows(NotSerializableException.class, () -> serialize(obj));\n-        Assert.assertEquals(ex.getMessage(), ValueExt.class.getName());\n+        var ex = Assert.expectThrows(InvalidClassException.class, () -> serialize(obj));\n+        Assert.assertEquals(ex.getMessage(),\n+                \"SimpleValueGraphs$ValueExt; Externalizable not valid for value class\");\n@@ -389,0 +392,1 @@\n+    \/\/ Not Desrializable or Deserializable, no writeable fields\n","filename":"test\/jdk\/java\/io\/Serializable\/valueObjects\/SimpleValueGraphs.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,295 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary ValueSerialization support of value classes\n- * @enablePreview\n- * @modules java.base\/jdk.internal\n- * @compile ValueSerialization.java\n- * @run testng\/othervm ValueSerialization\n- *\/\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataOutputStream;\n-import java.io.Externalizable;\n-import java.io.IOException;\n-import java.io.InvalidClassException;\n-import java.io.InvalidObjectException;\n-import java.io.NotSerializableException;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutput;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamClass;\n-import java.io.ObjectStreamException;\n-import java.io.Serializable;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static java.io.ObjectStreamConstants.*;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertThrows;\n-import static org.testng.Assert.expectThrows;\n-\n-public class ValueSerialization {\n-\n-    static final Class<NotSerializableException> NSE = NotSerializableException.class;\n-\n-    @DataProvider(name = \"doesNotImplementSerializable\")\n-    public Object[][] doesNotImplementSerializable() {\n-        return new Object[][] {\n-            new Object[] { new NonSerializablePoint(10, 100) },\n-            \/\/ an array of Points\n-            new Object[] { new NonSerializablePoint[] {new NonSerializablePoint(1, 5)} },\n-            new Object[] { new Object[] {new NonSerializablePoint(3, 7)} },\n-            new Object[] { new ExternalizablePoint(12, 102) },\n-            new Object[] { new ExternalizablePoint[] {\n-                    new ExternalizablePoint(3, 7),\n-                    new ExternalizablePoint(2, 8) } },\n-            new Object[] { new Object[] {\n-                    new ExternalizablePoint(13, 17),\n-                    new ExternalizablePoint(14, 18) } },\n-        };\n-    }\n-\n-    \/\/ value class that DOES NOT implement Serializable should throw NSE\n-    @Test(dataProvider = \"doesNotImplementSerializable\")\n-    public void doesNotImplementSerializable(Object obj) {\n-        assertThrows(NSE, () -> serialize(obj));\n-    }\n-\n-    \/** Non-Serializable point. *\/\n-    public static value class NonSerializablePoint {\n-        public int x;\n-        public int y;\n-\n-        public NonSerializablePoint(int x, int y) {\n-            this.x = x;\n-            this.y = y;\n-        }\n-    }\n-\n-    \/** A Serializable value class Point *\/\n-    @jdk.internal.MigratedValueClass\n-    static value class SerializablePoint implements Serializable {\n-        public int x;\n-        public int y;\n-        SerializablePoint(int x, int y) { this.x = x; this.y = y; }\n-        @Override public String toString() {\n-            return \"[SerializablePoint x=\" + x + \" y=\" + y + \"]\"; }\n-    }\n-\n-    \/** A Serializable value class Point *\/\n-    @jdk.internal.MigratedValueClass\n-    static value class SerializablePrimitivePoint implements Serializable {\n-        public int x;\n-        public int y;\n-        SerializablePrimitivePoint(int x, int y) { this.x = x; this.y = y; }\n-        @Override public String toString() {\n-            return \"[SerializablePrimitivePoint x=\" + x + \" y=\" + y + \"]\"; }\n-    }\n-\n-    \/** An Externalizable Point is not Serializable, readExternal cannot modify fields *\/\n-    static value class ExternalizablePoint implements Externalizable {\n-        public int x;\n-        public int y;\n-        ExternalizablePoint(int x, int y) { this.x = x; this.y = y; }\n-        @Override public void readExternal(ObjectInput in) {  }\n-        @Override public void writeExternal(ObjectOutput out) {  }\n-        @Override public String toString() {\n-            return \"[ExternalizablePoint x=\" + x + \" y=\" + y + \"]\"; }\n-    }\n-\n-    @DataProvider(name = \"doesImplementSerializable\")\n-    public Object[][] doesImplementSerializable() {\n-        return new Object[][] {\n-            new Object[] { new SerializablePoint(11, 101) },\n-            new Object[] { new SerializablePoint[] {\n-                    new SerializablePoint(1, 5),\n-                    new SerializablePoint(2, 6) } },\n-            new Object[] { new Object[] {\n-                    new SerializablePoint(3, 7),\n-                    new SerializablePoint(4, 8) } },\n-            new Object[] { new SerializablePrimitivePoint(711, 7101) },\n-            new Object[] { new SerializablePrimitivePoint[] {\n-                    new SerializablePrimitivePoint(71, 75),\n-                    new SerializablePrimitivePoint(72, 76) } },\n-            new Object[] { new Object[] {\n-                    new SerializablePrimitivePoint(73, 77),\n-                    new SerializablePrimitivePoint(74, 78) } },\n-        };\n-    }\n-\n-    \/\/ value class that DOES implement Serializable all supported\n-    @Test(dataProvider = \"doesImplementSerializable\")\n-    public void doesImplementSerializable(Object obj) throws IOException {\n-        serialize(obj);\n-    }\n-\n-    \/** A Serializable Foo, with a serial proxy *\/\n-    static value class SerializableFoo implements Serializable {\n-        public int x;\n-        SerializableFoo(int x) { this.x = x; }\n-\n-        Object writeReplace() throws ObjectStreamException {\n-            return new SerialFooProxy(x);\n-        }\n-        private void readObject(ObjectInputStream s) throws InvalidObjectException {\n-            throw new InvalidObjectException(\"Proxy required\");\n-        }\n-        private static class SerialFooProxy implements Serializable {\n-            final int x;\n-            SerialFooProxy(int x) { this.x = x; }\n-            Object readResolve() throws ObjectStreamException {\n-                return new SerializableFoo(this.x);\n-            }\n-        }\n-    }\n-\n-    \/** An Externalizable Foo, with a serial proxy *\/\n-    static value class ExternalizableFoo implements Externalizable {\n-        public String s;\n-        ExternalizableFoo(String s) {  this.s = s; }\n-        Object writeReplace() throws ObjectStreamException {\n-            return new SerialFooProxy(s);\n-        }\n-        private void readObject(ObjectInputStream s) throws InvalidObjectException {\n-            throw new InvalidObjectException(\"Proxy required\");\n-        }\n-        private static class SerialFooProxy implements Serializable {\n-            final String s;\n-            SerialFooProxy(String s) { this.s = s; }\n-            Object readResolve() throws ObjectStreamException {\n-                return new ExternalizableFoo(this.s);\n-            }\n-        }\n-        @Override public void readExternal(ObjectInput in) {  }\n-        @Override public void writeExternal(ObjectOutput out) {  }\n-    }\n-\n-    \/\/ value classes that DO implement Serializable, but have a serial proxy\n-    @Test\n-    public void serializableFooWithProxy() throws Exception {\n-        SerializableFoo foo = new SerializableFoo(45);\n-        SerializableFoo foo1 = serializeDeserialize(foo);\n-        assertEquals(foo.x, foo1.x);\n-    }\n-    @Test\n-    public void serializableFooArrayWithProxy() throws Exception {\n-        SerializableFoo[] fooArray = new SerializableFoo[]{new SerializableFoo(46)};\n-        SerializableFoo[] fooArray1 = serializeDeserialize(fooArray);\n-        assertEquals(fooArray.length, fooArray1.length);\n-        assertEquals(fooArray[0].x, fooArray1[0].x);\n-    }\n-    @Test\n-    public void externalizableFooWithProxy() throws Exception {\n-        ExternalizableFoo foo = new ExternalizableFoo(\"hello\");\n-        ExternalizableFoo foo1 = serializeDeserialize(foo);\n-        assertEquals(foo.s, foo1.s);\n-    }\n-    @Test\n-    public void externalizableFooArrayWithProxy() throws Exception {\n-        ExternalizableFoo[] fooArray = new ExternalizableFoo[] { new ExternalizableFoo(\"there\") };\n-        ExternalizableFoo[] fooArray1 = serializeDeserialize(fooArray);\n-        assertEquals(fooArray.length, fooArray1.length);\n-        assertEquals(fooArray[0].s, fooArray1[0].s);\n-    }\n-\n-    private static byte[] byteStreamFor(String className, long uid, byte flags)\n-        throws Exception\n-    {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        DataOutputStream dos = new DataOutputStream(baos);\n-        dos.writeShort(STREAM_MAGIC);\n-        dos.writeShort(STREAM_VERSION);\n-        dos.writeByte(TC_OBJECT);\n-        dos.writeByte(TC_CLASSDESC);\n-        dos.writeUTF(className);\n-        dos.writeLong(uid);\n-        dos.writeByte(flags);\n-        dos.writeShort(0);             \/\/ number of fields\n-        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n-        dos.writeByte(TC_NULL);           \/\/ no superclasses\n-        dos.close();\n-        return baos.toByteArray();\n-    }\n-\n-    private static byte[] serializableByteStreamFor(String className, long uid)\n-        throws Exception\n-    {\n-        return byteStreamFor(className, uid, SC_SERIALIZABLE);\n-    }\n-\n-    private static byte[] externalizableByteStreamFor(String className, long uid)\n-         throws Exception\n-    {\n-        return byteStreamFor(className, uid, SC_EXTERNALIZABLE);\n-    }\n-\n-    @DataProvider(name = \"classes\")\n-    public Object[][] classes() {\n-        return new Object[][] {\n-            new Object[] { NonSerializablePoint.class },\n-            new Object[] { SerializablePoint.class },\n-            new Object[] { SerializablePrimitivePoint.class }\n-        };\n-    }\n-\n-    static final Class<InvalidClassException> ICE = InvalidClassException.class;\n-\n-    \/\/ value class read directly from a byte stream, both serializable and externalizable are supported\n-    @Test(dataProvider = \"classes\")\n-    public void deserialize(Class<?> cls) throws Exception {\n-        var clsDesc = ObjectStreamClass.lookup(cls);\n-        long uid = clsDesc == null ? 0L : clsDesc.getSerialVersionUID();\n-\n-        byte[] serialBytes = serializableByteStreamFor(cls.getName(), uid);\n-\n-        byte[] extBytes = externalizableByteStreamFor(cls.getName(), uid);\n-    }\n-\n-    static <T> byte[] serialize(T obj) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(baos);\n-        oos.writeObject(obj);\n-        oos.close();\n-        return baos.toByteArray();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static <T> T deserialize(byte[] streamBytes)\n-        throws IOException, ClassNotFoundException\n-    {\n-        ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);\n-        ObjectInputStream ois  = new ObjectInputStream(bais);\n-        return (T) ois.readObject();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static <T> T serializeDeserialize(T obj)\n-        throws IOException, ClassNotFoundException\n-    {\n-        return (T) deserialize(serialize(obj));\n-    }\n-}\n","filename":"test\/jdk\/java\/io\/Serializable\/valueObjects\/ValueSerialization.java","additions":0,"deletions":295,"binary":false,"changes":295,"status":"deleted"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test serialization of value classes\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal java.base\/jdk.internal.value\n+ * @compile ValueSerializationTest.java\n+ * @run testng\/othervm ValueSerializationTest\n+ *\/\n+\n+import static java.io.ObjectStreamConstants.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.InvalidClassException;\n+import java.io.InvalidObjectException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInput;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutput;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamException;\n+import java.io.Serial;\n+import java.io.Serializable;\n+\n+import jdk.internal.MigratedValueClass;\n+import jdk.internal.value.DeserializeConstructor;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+\n+public class ValueSerializationTest {\n+\n+    static final Class<NotSerializableException> NSE = NotSerializableException.class;\n+    private static final Class<InvalidClassException> ICE = InvalidClassException.class;\n+\n+    @DataProvider(name = \"doesNotImplementSerializable\")\n+    public Object[][] doesNotImplementSerializable() {\n+        return new Object[][] {\n+            new Object[] { new NonSerializablePoint(10, 100), NSE},\n+            new Object[] { new NonSerializablePointNoCons(10, 100), ICE},\n+            \/\/ an array of Points\n+            new Object[] { new NonSerializablePoint[] {new NonSerializablePoint(1, 5)}, NSE},\n+            new Object[] { new Object[] {new NonSerializablePoint(3, 7)}, NSE},\n+            new Object[] { new ExternalizablePoint(12, 102), ICE},\n+            new Object[] { new ExternalizablePoint[] {\n+                    new ExternalizablePoint(3, 7),\n+                    new ExternalizablePoint(2, 8) }, ICE},\n+            new Object[] { new Object[] {\n+                    new ExternalizablePoint(13, 17),\n+                    new ExternalizablePoint(14, 18) }, ICE},\n+        };\n+    }\n+\n+    \/\/ value class that DOES NOT implement Serializable should throw ICE\n+    @Test(dataProvider = \"doesNotImplementSerializable\")\n+    public void doesNotImplementSerializable(Object obj, Class expectedException) {\n+        assertThrows(expectedException, () -> serialize(obj));\n+    }\n+\n+    \/* Non-Serializable point. *\/\n+    public static value class NonSerializablePoint {\n+        public int x;\n+        public int y;\n+\n+        public NonSerializablePoint(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+        @Override public String toString() {\n+            return \"[NonSerializablePoint x=\" + x + \" y=\" + y + \"]\";\n+        }\n+    }\n+\n+    \/* Non-Serializable point, because it does not have an @DeserializeConstructor constructor. *\/\n+    public static value class NonSerializablePointNoCons implements Serializable {\n+        public int x;\n+        public int y;\n+\n+        \/\/ Note: Must NOT have @DeserializeConstructor annotation\n+        public NonSerializablePointNoCons(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+        @Override public String toString() {\n+            return \"[NonSerializablePointNoCons x=\" + x + \" y=\" + y + \"]\";\n+        }\n+    }\n+\n+    \/* An Externalizable Point is not Serializable, readExternal cannot modify fields *\/\n+    static value class ExternalizablePoint implements Externalizable {\n+        public int x;\n+        public int y;\n+        public ExternalizablePoint() {this.x = 0; this.y = 0;}\n+        ExternalizablePoint(int x, int y) { this.x = x; this.y = y; }\n+        @Override public void readExternal(ObjectInput in) {  }\n+        @Override public void writeExternal(ObjectOutput out) {  }\n+        @Override public String toString() {\n+            return \"[ExternalizablePoint x=\" + x + \" y=\" + y + \"]\"; }\n+    }\n+\n+    @DataProvider(name = \"ImplementSerializable\")\n+    public Object[][] implementSerializable() {\n+        return new Object[][]{\n+                new Object[]{new SerializablePoint(11, 101)},\n+                new Object[]{new SerializablePoint[]{\n+                        new SerializablePoint(1, 5),\n+                        new SerializablePoint(2, 6)}},\n+                new Object[]{new Object[]{\n+                        new SerializablePoint(3, 7),\n+                        new SerializablePoint(4, 8)}},\n+                new Object[]{new SerializableFoo(45)},\n+                new Object[]{new SerializableFoo[]{new SerializableFoo(46)}},\n+                new Object[]{new ExternalizableFoo(\"hello\")},\n+                new Object[]{new ExternalizableFoo[]{new ExternalizableFoo(\"there\")}},\n+        };\n+    }\n+\n+    \/\/ value class that DOES implement Serializable is supported\n+    @Test(dataProvider = \"ImplementSerializable\")\n+    public void implementSerializable(Object obj) throws IOException, ClassNotFoundException {\n+        byte[] bytes = serialize(obj);\n+        Object actual = deserialize(bytes);\n+        if (obj.getClass().isArray())\n+            assertEquals((Object[])obj, (Object[])actual);\n+        else\n+            assertEquals(obj, actual);\n+    }\n+\n+    \/* A Serializable value class Point *\/\n+    @MigratedValueClass\n+    static value class SerializablePoint implements Serializable {\n+        public int x;\n+        public int y;\n+        @DeserializeConstructor\n+        private SerializablePoint(int x, int y) { this.x = x; this.y = y; }\n+\n+        @Override public String toString() {\n+            return \"[SerializablePoint x=\" + x + \" y=\" + y + \"]\";\n+        }\n+    }\n+\n+    \/* A Serializable Foo, with a serial proxy *\/\n+    static value class SerializableFoo implements Serializable {\n+        public int x;\n+        @DeserializeConstructor\n+        SerializableFoo(int x) { this.x = x; }\n+\n+        @Serial Object writeReplace() throws ObjectStreamException {\n+            return new SerialFooProxy(x);\n+        }\n+        @Serial private void readObject(ObjectInputStream s) throws InvalidObjectException {\n+            throw new InvalidObjectException(\"Proxy required\");\n+        }\n+        private record SerialFooProxy(int x) implements Serializable {\n+            @Serial Object readResolve() throws ObjectStreamException {\n+                return new SerializableFoo(x);\n+            }\n+        }\n+    }\n+\n+    \/* An Externalizable Foo, with a serial proxy *\/\n+    static value class ExternalizableFoo implements Externalizable {\n+        public String s;\n+        ExternalizableFoo(String s) {  this.s = s; }\n+        public boolean equals(Object other) {\n+            if (other instanceof ExternalizableFoo foo) {\n+                return s.equals(foo.s);\n+            } else {\n+                return false;\n+            }\n+        }\n+        @Serial  Object writeReplace() throws ObjectStreamException {\n+            return new SerialFooProxy(s);\n+        }\n+        private record SerialFooProxy(String s) implements Serializable {\n+            @Serial Object readResolve() throws ObjectStreamException {\n+                return new ExternalizableFoo(s);\n+            }\n+        }\n+        @Override public void readExternal(ObjectInput in) {  }\n+        @Override public void writeExternal(ObjectOutput out) {  }\n+    }\n+\n+    \/\/ Generate a byte stream containing a reference to the named class with the SVID and flags.\n+    private static byte[] byteStreamFor(String className, long uid, byte flags)\n+        throws Exception\n+    {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream dos = new DataOutputStream(baos);\n+        dos.writeShort(STREAM_MAGIC);\n+        dos.writeShort(STREAM_VERSION);\n+        dos.writeByte(TC_OBJECT);\n+        dos.writeByte(TC_CLASSDESC);\n+        dos.writeUTF(className);\n+        dos.writeLong(uid);\n+        dos.writeByte(flags);\n+        dos.writeShort(0);             \/\/ number of fields\n+        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n+        dos.writeByte(TC_NULL);           \/\/ no superclasses\n+        dos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    @DataProvider(name = \"classes\")\n+    public Object[][] classes() {\n+        return new Object[][] {\n+            new Object[] { ExternalizableFoo.class, SC_EXTERNALIZABLE, ICE },\n+            new Object[] { ExternalizableFoo.class, SC_SERIALIZABLE, ICE },\n+            new Object[] { SerializablePoint.class, SC_EXTERNALIZABLE, ICE },\n+            new Object[] { SerializablePoint.class, SC_SERIALIZABLE, null },\n+        };\n+    }\n+\n+    \/\/ value class read directly from a byte stream\n+    \/\/ a byte stream is generated containing a reference to the class with the flags  and SVID.\n+    \/\/ Reading the class from the stream verifies the exceptions thrown if there is a mismatch\n+    \/\/ between the stream and the local class.\n+    @Test(dataProvider = \"classes\")\n+    public void deserialize(Class<?> cls, byte flags, Class<?> expected) throws Exception {\n+        var clsDesc = ObjectStreamClass.lookup(cls);\n+        long uid = clsDesc == null ? 0L : clsDesc.getSerialVersionUID();\n+        byte[] serialBytes = byteStreamFor(cls.getName(), uid, flags);\n+        try {\n+            deserialize(serialBytes);\n+            Assert.assertNull(expected, \"Expected exception\");\n+        } catch (IOException ioe) {\n+            Assert.assertEquals(ioe.getClass(), expected);\n+        }\n+    }\n+\n+    static <T> byte[] serialize(T obj) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(obj);\n+        oos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T deserialize(byte[] streamBytes)\n+        throws IOException, ClassNotFoundException\n+    {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);\n+        ObjectInputStream ois  = new ObjectInputStream(bais);\n+        return (T) ois.readObject();\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/valueObjects\/ValueSerializationTest.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"}]}