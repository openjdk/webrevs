{"files":[{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test for AccessWatchpoint\/ModificationWatchpoint and InstanceFilter with value objects\n+ *\n+ * @library ..\n+ * @enablePreview\n+ * @run main\/othervm FieldWatchpointsTest\n+ *                   -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlineLayout -XX:+PrintFlatArrayLayout\n+ *\/\n+import com.sun.jdi.Field;\n+import com.sun.jdi.ClassType;\n+import com.sun.jdi.Method;\n+import com.sun.jdi.ObjectReference;\n+import com.sun.jdi.ThreadReference;\n+import com.sun.jdi.Value;\n+import com.sun.jdi.event.AccessWatchpointEvent;\n+import com.sun.jdi.event.BreakpointEvent;\n+import com.sun.jdi.event.ModificationWatchpointEvent;\n+import com.sun.jdi.event.WatchpointEvent;\n+import com.sun.jdi.request.WatchpointRequest;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class FieldWatchpointsTarg {\n+    static value class Value {\n+        int v;\n+        Value() {\n+            this(0);\n+        }\n+        Value(int v) {\n+            this.v = v;\n+        }\n+        public int getValue() {\n+            return v;\n+        }\n+    }\n+\n+    static Value staticField = new Value(1);\n+\n+    public static void main(String[] args) {\n+        System.out.println(\">>Targ.main\");\n+        Value obj = new Value(2); \/\/ modify\n+        System.out.println(\"obj value = \" + obj.v); \/\/ access\n+        System.out.println(\"staticField value = \" + staticField.v); \/\/ access\n+        System.out.println(\"<<Targ.main\");\n+    }\n+}\n+\n+public class FieldWatchpointsTest extends TestScaffold {\n+\n+    FieldWatchpointsTest (String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new FieldWatchpointsTest(args).startTests();\n+    }\n+\n+    boolean equals(ObjectReference obj1, ObjectReference obj2) throws Exception {\n+        return obj1.equals(obj2);\n+    }\n+\n+    void assertEqual(ObjectReference obj1, ObjectReference obj2) throws Exception {\n+        if (!equals(obj1, obj2)) {\n+            throw new RuntimeException(\"Values are not equal: \" + obj1 + \" and \" + obj2);\n+        }\n+    }\n+\n+    void assertNotEqual(ObjectReference obj1, ObjectReference obj2) throws Exception {\n+        if (equals(obj1, obj2)) {\n+            throw new RuntimeException(\"Values are equal: \" + obj1 + \" and \" + obj2);\n+        }\n+    }\n+\n+    public void fieldAccessed(AccessWatchpointEvent event) {\n+        TestCase.watchpoint(event);\n+    }\n+\n+    public void fieldModified(ModificationWatchpointEvent event) {\n+        TestCase.watchpoint(event);\n+    }\n+\n+    protected void runTests() throws Exception {\n+        List<TestCase> testCases = new ArrayList<>();\n+        try {\n+            BreakpointEvent bpe = startToMain(\"FieldWatchpointsTarg\");\n+            ThreadReference mainThread = bpe.thread();\n+            ClassType testClass = (ClassType)bpe.location().declaringType();\n+            Field staticValueField = testClass.fieldByName(\"staticField\");\n+            ClassType valueClass = (ClassType)staticValueField.type();\n+            ObjectReference staticFieldValue = (ObjectReference)testClass.getValue(staticValueField);\n+\n+            Field watchField = valueClass.fieldByName(\"v\");\n+\n+            WatchpointRequest request = eventRequestManager().createModificationWatchpointRequest(watchField);\n+            testCases.add(new TestCase(\"modify\", 1, request)); \/\/ obj ctor\n+\n+            request = eventRequestManager().createAccessWatchpointRequest(watchField);\n+            testCases.add(new TestCase(\"access\", 2, request)); \/\/ staticField, obj\n+\n+            request = eventRequestManager().createAccessWatchpointRequest(watchField);\n+            request.addInstanceFilter(staticFieldValue);\n+            testCases.add(new TestCase(\"access+instanceFilter\", 1, request)); \/\/ only staticField\n+        } finally {\n+            listenUntilVMDisconnect();\n+        }\n+\n+        for (TestCase test: testCases) {\n+            String msg = \"Testcase: \" + test.name\n+                        + \", count = \" + test.count\n+                        + \", expectedCount = \" + test.expectedCount;\n+            System.out.println(msg);\n+            if (test.count != test.expectedCount) {\n+                throw new RuntimeException(\"FAILED \" + msg);\n+            }\n+        }\n+    }\n+\n+    class TestCase {\n+        String name;\n+        int count;\n+        int expectedCount;\n+        TestCase(String name, int expectedCount, WatchpointRequest request) {\n+            this.name = name;\n+            this.expectedCount = expectedCount;\n+            request.putProperty(\"testcase\", this);\n+            request.enable();\n+        }\n+\n+        static void watchpoint(WatchpointEvent event) {\n+            TestCase test = (TestCase)event.request().getProperty(\"testcase\");\n+            test.count++;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/FieldWatchpointsTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test for ArrayReference (getValue\/setValue) with flat arrays\n+ *\n+ * @modules java.base\/jdk.internal.value\n+ * @library ..\n+ * @enablePreview\n+ * @run main\/othervm ValueArrayReferenceTest\n+ *                   --add-modules java.base --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlineLayout -XX:+PrintFlatArrayLayout\n+ *\/\n+import com.sun.jdi.ArrayReference;\n+import com.sun.jdi.Field;\n+import com.sun.jdi.ReferenceType;\n+import com.sun.jdi.Value;\n+import com.sun.jdi.event.BreakpointEvent;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import jdk.internal.value.ValueClass;\n+\n+class ValueArrayReferenceTarg {\n+    static value class Value {\n+        int v;\n+        Value() {\n+            this(0);\n+        }\n+        Value(int v) {\n+            this.v = v;\n+        }\n+        public int getValue() {\n+            return v;\n+        }\n+    }\n+\n+    static int ARRAY_SIZE = 5;\n+    static void initArray(Value[] arr) {\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Value(i);\n+        }\n+    }\n+\n+    static Value[] testRegularArray;\n+    static Value[] testNullableAtomicArray;\n+    static Value[] testNonNullNonAtomicArray;\n+    static Value[] testNonNullAtomicArray;\n+\n+    static Value otherValue = new Value(25);\n+\n+    static {\n+        try {\n+            testRegularArray = new Value[ARRAY_SIZE];\n+            initArray(testRegularArray);\n+\n+            testNullableAtomicArray = (Value[])ValueClass.newNullableAtomicArray(Value.class, ARRAY_SIZE);\n+            initArray(testNullableAtomicArray);\n+\n+            testNonNullNonAtomicArray = (Value[])ValueClass.newNullRestrictedNonAtomicArray(Value.class, ARRAY_SIZE, Value.class.newInstance());\n+            initArray(testNonNullNonAtomicArray);\n+\n+            testNonNullAtomicArray = (Value[])ValueClass.newNullRestrictedAtomicArray(Value.class, ARRAY_SIZE, Value.class.newInstance());\n+            initArray(testNonNullAtomicArray);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Hello and goodbye from main\");\n+    }\n+}\n+\n+public class ValueArrayReferenceTest extends TestScaffold {\n+\n+    ValueArrayReferenceTest (String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new ValueArrayReferenceTest(args).startTests();\n+    }\n+\n+    String arrayToString(ArrayReference array) {\n+        List<Value> values = array.getValues();\n+        \/\/ Mirror.toString reports object type and reference id,\n+        \/\/ it should be enough to see if objects are different.\n+        return values.stream()\n+                .map(String::valueOf)\n+                .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+    }\n+\n+    Value getFieldValue(ReferenceType cls, String fieldName) {\n+        System.out.println(\"Getting value from \" + fieldName);\n+        Value value = cls.getValue(cls.fieldByName(fieldName));\n+        System.out.println(\" - \" + value);\n+        return value;\n+    }\n+\n+    ArrayReference getArrayFromField(ReferenceType cls, Field field) throws Exception {\n+        System.out.println(\"Getting array from \" + field.name());\n+        ArrayReference array = (ArrayReference)cls.getValue(field);\n+        System.out.println(\" - \" + array);\n+        System.out.println(\"   \" + arrayToString(array));\n+        return array;\n+    }\n+\n+    boolean arraysEquals(ArrayReference arr1, ArrayReference arr2) throws Exception {\n+        \/\/ Compare string representation of the array (contains object type and id for each element).\n+        String s1 = arrayToString(arr1);\n+        String s2 = arrayToString(arr2);\n+        return s1.equals(s2);\n+    }\n+\n+    void fillArrayWithOtherValue(ArrayReference arr, Value value) throws Exception {\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.setValue(i, value);\n+        }\n+    }\n+\n+    void verifyArraysEqual(List<ArrayReference> arrays) throws Exception {\n+        for (ArrayReference arr1: arrays) {\n+            for (ArrayReference arr2: arrays) {\n+                if (!arraysEquals(arr1, arr2)) {\n+                    System.out.println(\"Arrays are different (1):\"\n+                                     + \"\\n    - \" + arrayToString(arr1)\n+                                     + \"\\n    - \" + arrayToString(arr2));\n+                    throw new RuntimeException(\"Arrays are different\");\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void runTests() throws Exception {\n+        try {\n+            BreakpointEvent bpe = startToMain(\"ValueArrayReferenceTarg\");\n+            ReferenceType cls = bpe.location().declaringType();\n+\n+            \/\/ Get all arrays.\n+            List<ArrayReference> arrays = new ArrayList<>();\n+            List<Field> fields = cls.allFields();\n+            for (Field field: fields) {\n+                if (field.name().startsWith(\"test\")) {\n+                    arrays.add(getArrayFromField(cls, field));\n+                }\n+            }\n+\n+            \/\/ Ensure elements in all arrays are equal.\n+            verifyArraysEqual(arrays);\n+\n+            \/\/ Update arrays.\n+            Value otherValue = getFieldValue(cls, \"otherValue\");\n+            for (ArrayReference arr: arrays) {\n+                fillArrayWithOtherValue(arr, otherValue);\n+                System.out.println(\"Array after update:\");\n+                System.out.println(\"   \" + arrayToString(arr));\n+            }\n+\n+            \/\/ Ensure elements in all arrays are equal.\n+            verifyArraysEqual(arrays);\n+        } finally {\n+            \/\/ Resume the target until end.\n+            listenUntilVMDisconnect();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/ValueArrayReferenceTest.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test for ClassType (getValue, setValue, newInstance) with value objects\n+ *\n+ * @library ..\n+ * @enablePreview\n+ * @run main\/othervm ValueClassTypeTest\n+ *                   -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlineLayout -XX:+PrintFlatArrayLayout\n+ *\/\n+import com.sun.jdi.Field;\n+import com.sun.jdi.ClassType;\n+import com.sun.jdi.Method;\n+import com.sun.jdi.ObjectReference;\n+import com.sun.jdi.ThreadReference;\n+import com.sun.jdi.Value;\n+import com.sun.jdi.event.BreakpointEvent;\n+import java.util.List;\n+\n+class ValueClassTypeTarg {\n+    static value class Value {\n+        static Value staticField = new Value(1);\n+\n+        int v;\n+        Value() {\n+            this(0);\n+        }\n+        Value(int v) {\n+            this.v = v;\n+        }\n+        public int getValue() {\n+            return v;\n+        }\n+    }\n+\n+    static Value staticField = new Value(2);\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Hello and goodbye from main\");\n+    }\n+}\n+\n+public class ValueClassTypeTest extends TestScaffold {\n+\n+    ValueClassTypeTest (String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new ValueClassTypeTest(args).startTests();\n+    }\n+\n+    boolean equals(ObjectReference obj1, ObjectReference obj2) throws Exception {\n+        return obj1.equals(obj2);\n+    }\n+\n+    void assertEqual(ObjectReference obj1, ObjectReference obj2) throws Exception {\n+        if (!equals(obj1, obj2)) {\n+            throw new RuntimeException(\"Values are not equal: \" + obj1 + \" and \" + obj2);\n+        }\n+    }\n+\n+    void assertNotEqual(ObjectReference obj1, ObjectReference obj2) throws Exception {\n+        if (equals(obj1, obj2)) {\n+            throw new RuntimeException(\"Values are equal: \" + obj1 + \" and \" + obj2);\n+        }\n+    }\n+\n+    protected void runTests() throws Exception {\n+        try {\n+            BreakpointEvent bpe = startToMain(\"ValueClassTypeTarg\");\n+            ThreadReference mainThread = bpe.thread();\n+            ClassType testClass = (ClassType)bpe.location().declaringType();\n+            Field testField = testClass.fieldByName(\"staticField\");\n+            ObjectReference value1 = (ObjectReference)testClass.getValue(testField);\n+\n+            ClassType valueClass = (ClassType)value1.type();\n+            Field valueField = valueClass.fieldByName(\"staticField\");\n+            ObjectReference value2 = (ObjectReference)valueClass.getValue(valueField);\n+\n+            Method valueCtor = valueClass.concreteMethodByName(\"<init>\", \"(I)V\");\n+\n+            ObjectReference newValue1 = valueClass.newInstance(mainThread, valueCtor, List.of(vm().mirrorOf(10)), 0);\n+            ObjectReference newValue2 = valueClass.newInstance(mainThread, valueCtor, List.of(vm().mirrorOf(11)), 0);\n+            \/\/ sanity check for enableCollection\/disableCollection\n+            newValue1.disableCollection();\n+            newValue2.disableCollection();\n+\n+            testClass.setValue(testField, newValue1);\n+            valueClass.setValue(valueField, newValue2);\n+\n+            ObjectReference updatedValue1 = (ObjectReference)testClass.getValue(testField);\n+            ObjectReference updatedValue2 = (ObjectReference)valueClass.getValue(valueField);\n+\n+            assertEqual(updatedValue1, newValue1);\n+            assertNotEqual(value1, newValue1);\n+            assertEqual(updatedValue2, newValue2);\n+            assertNotEqual(value2, newValue2);\n+\n+            \/\/ sanity check for enableCollection\/disableCollection\n+            newValue1.enableCollection();\n+            newValue2.enableCollection();\n+        } finally {\n+            \/\/ Resume the target until end\n+            listenUntilVMDisconnect();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/ValueClassTypeTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}