{"files":[{"patch":"@@ -28,0 +28,6 @@\n+import java.lang.annotation.Annotation;\n+import java.net.URL;\n+import java.security.CodeSource;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Objects;\n@@ -29,0 +35,5 @@\n+import jdk.internal.event.FinalFieldMutationEvent;\n+import jdk.internal.loader.ClassLoaders;\n+import jdk.internal.misc.VM;\n+import jdk.internal.module.ModuleBootstrap;\n+import jdk.internal.module.Modules;\n@@ -38,4 +49,0 @@\n-import java.lang.annotation.Annotation;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.Objects;\n@@ -168,0 +175,21 @@\n+     * {@inheritDoc}\n+     *\n+     * <p>If this reflected object represents a non-final field, and this method is\n+     * used to enable access, then both <em>{@linkplain #get(Object) read}<\/em>\n+     * and <em>{@linkplain #set(Object, Object) write}<\/em> access to the field\n+     * are enabled.\n+     *\n+     * <p>If this reflected object represents a <em>non-modifiable<\/em> final field\n+     * then enabling access only enables read access. Any attempt to {@linkplain\n+     * #set(Object, Object) set} the field value throws an {@code\n+     * IllegalAccessException}. The following fields are non-modifiable:\n+     * <ul>\n+     * <li>static final fields declared in any class or interface<\/li>\n+     * <li>final fields declared in a {@linkplain Class#isRecord() record}<\/li>\n+     * <li>final fields declared in a {@linkplain Class#isHidden() hidden class}<\/li>\n+     * <\/ul>\n+     * <p>If this reflected object represents a non-static final field in a class that\n+     * is not a record class or hidden class, then enabling access will enable read\n+     * access. Whether write access is allowed or not is checked when attempting to\n+     * {@linkplain #set(Object, Object) set} the field value.\n+     *\n@@ -782,2 +810,4 @@\n-     * <p>If the underlying field is final, this {@code Field} object has\n-     * <em>write<\/em> access if and only if the following conditions are met:\n+     * <p>If the underlying field is final, this {@code Field} object has <em>write<\/em>\n+     * access if and only if all of the following conditions are true, where {@code D} is\n+     * the field's {@linkplain #getDeclaringClass() declaring class}:\n+     *\n@@ -785,9 +815,17 @@\n-     * <li>{@link #setAccessible(boolean) setAccessible(true)} has succeeded for\n-     *     this {@code Field} object;<\/li>\n-     * <li>the field is non-static; and<\/li>\n-     * <li>the field's declaring class is not a {@linkplain Class#isHidden()\n-     *     hidden class};<\/li>\n-     * <li>the field's declaring class is not a {@linkplain Class#isValue()\n-     *     value class}; and<\/li>\n-     * <li>the field's declaring class is not a {@linkplain Class#isRecord()\n-     *     record class}.<\/li>\n+     * <li>{@link #setAccessible(boolean) setAccessible(true)} has succeeded for this\n+     *     {@code Field} object.<\/li>\n+     * <li><a href=\"doc-files\/MutationMethods.html\">final field mutation is enabled<\/a>\n+     *     for the caller's module.<\/li>\n+     * <li> At least one of the following conditions holds:\n+     *     <ol type=\"a\">\n+     *     <li> {@code D} and the caller class are in the same module.<\/li>\n+     *     <li> The field is {@code public} and {@code D} is {@code public} in a package\n+     *     that the module containing {@code D} exports to at least the caller's module.<\/li>\n+     *     <li> {@code D} is in a package that is {@linkplain Module#isOpen(String, Module)\n+     *     open} to the caller's module.<\/li>\n+     *     <\/ol>\n+     * <\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isRecord() record class}.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isHidden() hidden class}.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isValue() value class}.<\/li>\n+     * <li>The field is non-static.<\/li>\n@@ -795,1 +833,31 @@\n-     * If any of the above checks is not met, this method throws an\n+     *\n+     * <p>If any of the above conditions is not met, this method throws an\n+     * {@code IllegalAccessException}.\n+     *\n+     * <p>These conditions are more restrictive than the conditions specified by {@link\n+     * #setAccessible(boolean)} to suppress access checks. In particular, updating a\n+     * module to export or open a package cannot be used to allow <em>write<\/em> access\n+     * to final fields with the {@code set} methods defined by {@code Field}.\n+     * Condition (b) is not met if the module containing {@code D} has been updated with\n+     * {@linkplain Module#addExports(String, Module) addExports} to export the package to\n+     * the caller's module. Condition (c) is not met if the module containing {@code D}\n+     * has been updated with {@linkplain Module#addOpens(String, Module) addOpens} to open\n+     * the package to the caller's module.\n+     *\n+     * <p>This method may be called by <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">\n+     * JNI code<\/a> with no caller class on the stack. In that case, and when the\n+     * underlying field is final, this {@code Field} object has <em>write<\/em> access\n+     * if and only if all of the following conditions are true, where {@code D} is the\n+     * field's {@linkplain #getDeclaringClass() declaring class}:\n+     *\n+     * <ul>\n+     * <li>{@code setAccessible(true)} has succeeded for this {@code Field} object.<\/li>\n+     * <li>final field mutation is enabled for the unnamed module.<\/li>\n+     * <li>The field is {@code public} and {@code D} is {@code public} in a package that\n+     *     is {@linkplain Module#isExported(String) exported} to all modules.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isRecord() record class}.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isHidden() hidden class}.<\/li>\n+     * <li>The field is non-static.<\/li>\n+     * <\/ul>\n+     *\n+     * <p>If any of the above conditions is not met, this method throws an\n@@ -840,0 +908,2 @@\n+     *\n+     * @see <a href=\"doc-files\/MutationMethods.html\">Mutation methods<\/a>\n@@ -850,0 +920,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.set(obj, value);\n@@ -851,1 +927,1 @@\n-            getOverrideFieldAccessor().set(obj, value);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.set(obj, value));\n@@ -889,0 +965,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setBoolean(obj, z);\n@@ -890,1 +972,1 @@\n-            getOverrideFieldAccessor().setBoolean(obj, z);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setBoolean(obj, z));\n@@ -928,0 +1010,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setByte(obj, b);\n@@ -929,1 +1017,1 @@\n-            getOverrideFieldAccessor().setByte(obj, b);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setByte(obj, b));\n@@ -967,0 +1055,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setChar(obj, c);\n@@ -968,1 +1062,1 @@\n-            getOverrideFieldAccessor().setChar(obj, c);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setChar(obj, c));\n@@ -1006,0 +1100,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setShort(obj, s);\n@@ -1007,1 +1107,1 @@\n-            getOverrideFieldAccessor().setShort(obj, s);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setShort(obj, s));\n@@ -1045,0 +1145,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setInt(obj, i);\n@@ -1046,1 +1152,1 @@\n-            getOverrideFieldAccessor().setInt(obj, i);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setInt(obj, i));\n@@ -1084,0 +1190,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setLong(obj, l);\n@@ -1085,1 +1197,1 @@\n-            getOverrideFieldAccessor().setLong(obj, l);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setLong(obj, l));\n@@ -1123,0 +1235,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setFloat(obj, f);\n@@ -1124,1 +1242,1 @@\n-            getOverrideFieldAccessor().setFloat(obj, f);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setFloat(obj, f));\n@@ -1162,0 +1280,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setDouble(obj, d);\n@@ -1163,1 +1287,1 @@\n-            getOverrideFieldAccessor().setDouble(obj, d);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setDouble(obj, d));\n@@ -1333,1 +1457,240 @@\n-}\n+    }\n+\n+    \/**\n+     * A function that sets a field to a value.\n+     *\/\n+    @FunctionalInterface\n+    private interface FieldSetter {\n+        void setFieldValue() throws IllegalAccessException;\n+    }\n+\n+    \/**\n+     * Attempts to set a final field.\n+     *\/\n+    private void setFinal(Class<?> caller, Object obj, FieldSetter setter) throws IllegalAccessException {\n+        if (obj != null && isFinalInstanceInNormalClass()) {\n+            preSetFinal(caller, false);\n+            setter.setFieldValue();\n+            postSetFinal(caller, false);\n+        } else {\n+            \/\/ throws IllegalAccessException if static, or field in record or hidden class\n+            setter.setFieldValue();\n+        }\n+    }\n+\n+    \/**\n+     * Return true if this field is a final instance field in a normal class (not a\n+     * record class or hidden class),\n+     *\/\n+    private boolean isFinalInstanceInNormalClass() {\n+        return Modifier.isFinal(modifiers)\n+                && !Modifier.isStatic(modifiers)\n+                && !clazz.isRecord()\n+                && !clazz.isHidden();\n+    }\n+\n+    \/**\n+     * Check that the caller is allowed to unreflect for mutation a final instance field\n+     * in a normal class.\n+     * @throws IllegalAccessException if not allowed\n+     *\/\n+    void checkAllowedToUnreflectFinalSetter(Class<?> caller) throws IllegalAccessException {\n+        Objects.requireNonNull(caller);\n+        preSetFinal(caller, true);\n+        postSetFinal(caller, true);\n+    }\n+\n+    \/**\n+     * Invoke before attempting to mutate, or unreflect for mutation, a final instance\n+     * field in a normal class.\n+     * @throws IllegalAccessException if not allowed\n+     *\/\n+    private void preSetFinal(Class<?> caller, boolean unreflect) throws IllegalAccessException {\n+        assert isFinalInstanceInNormalClass();\n+\n+        if (caller != null) {\n+            \/\/ check if declaring class in package that is open to caller, or public field\n+            \/\/ and declaring class is public in package exported to caller\n+            if (!isFinalDeeplyAccessible(caller)) {\n+                throw new IllegalAccessException(notAccessibleToCallerMessage(caller, unreflect));\n+            }\n+        } else {\n+            \/\/ no java caller, only allowed if field is public in exported package\n+            if (!Reflection.verifyPublicMemberAccess(clazz, modifiers)) {\n+                throw new IllegalAccessException(notAccessibleToNoCallerMessage(unreflect));\n+            }\n+        }\n+\n+        \/\/ check if field mutation is enabled for caller module or illegal final field\n+        \/\/ mutation is allowed\n+        var mode = ModuleBootstrap.illegalFinalFieldMutation();\n+        if (mode == ModuleBootstrap.IllegalFinalFieldMutation.DENY\n+                && !Modules.isFinalMutationEnabled(moduleToCheck(caller))) {\n+            throw new IllegalAccessException(callerNotAllowedToMutateMessage(caller, unreflect));\n+        }\n+    }\n+\n+    \/**\n+     * Invoke after mutating a final instance field, or when unreflecting a final instance\n+     * field for mutation, to print a warning and record a JFR event.\n+     *\/\n+    private void postSetFinal(Class<?> caller, boolean unreflect) {\n+        assert isFinalInstanceInNormalClass();\n+\n+        var mode = ModuleBootstrap.illegalFinalFieldMutation();\n+        if (mode == ModuleBootstrap.IllegalFinalFieldMutation.WARN) {\n+            \/\/ first mutation prints warning\n+            Module moduleToCheck = moduleToCheck(caller);\n+            if (Modules.tryEnableFinalMutation(moduleToCheck)) {\n+                String warningMsg = finalFieldMutationWarning(caller, unreflect);\n+                String targetModule = (caller != null && moduleToCheck.isNamed())\n+                        ? moduleToCheck.getName()\n+                        : \"ALL-UNNAMED\";\n+                VM.initialErr().printf(\"\"\"\n+                        WARNING: %s\n+                        WARNING: Use --enable-final-field-mutation=%s to avoid a warning\n+                        WARNING: Mutating final fields will be blocked in a future release unless final field mutation is enabled\n+                        \"\"\", warningMsg, targetModule);\n+            }\n+        } else if (mode == ModuleBootstrap.IllegalFinalFieldMutation.DEBUG) {\n+            \/\/ print warning and stack trace\n+            var sb = new StringBuilder(finalFieldMutationWarning(caller, unreflect));\n+            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n+                    .forEach(sf -> {\n+                        sb.append(System.lineSeparator()).append(\"\\tat \" + sf);\n+                    });\n+            VM.initialErr().println(sb);\n+        }\n+\n+        \/\/ record JFR event\n+        FinalFieldMutationEvent.offer(getDeclaringClass(), getName());\n+    }\n+\n+    \/**\n+     * Returns true if this final field is \"deeply accessible\" to the caller.\n+     * The field is deeply accessible if declaring class is in a package that is open\n+     * to the caller's module, or the field is public in a public class that is exported\n+     * to the caller's module.\n+     *\n+     * Updates to the module of the declaring class at runtime with {@code Module.addExports}\n+     * or {@code Module.addOpens} have no impact on the result of this method.\n+     *\/\n+    private boolean isFinalDeeplyAccessible(Class<?> caller) {\n+        assert isFinalInstanceInNormalClass();\n+\n+        \/\/ all fields in unnamed modules are deeply accessible\n+        Module declaringModule = clazz.getModule();\n+        if (!declaringModule.isNamed()) return true;\n+\n+        \/\/ all fields in the caller's module are deeply accessible\n+        Module callerModule = caller.getModule();\n+        if (callerModule == declaringModule) return true;\n+\n+        \/\/ public field, public class, package exported to caller's module\n+        String pn = clazz.getPackageName();\n+        if (Modifier.isPublic(modifiers)\n+                && Modifier.isPublic(clazz.getModifiers())\n+                && Modules.isStaticallyExported(declaringModule, pn, callerModule)) {\n+            return true;\n+        }\n+\n+        \/\/ package open to caller's module\n+        return Modules.isStaticallyOpened(declaringModule, pn, callerModule);\n+    }\n+\n+    \/**\n+     * Returns the Module to use for access checks with the given caller.\n+     *\/\n+    private Module moduleToCheck(Class<?> caller) {\n+        if (caller != null) {\n+            return caller.getModule();\n+        } else {\n+            \/\/ no java caller, only allowed if field is public in exported package\n+            return ClassLoaders.appClassLoader().getUnnamedModule();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the warning message to print when this final field is mutated by\n+     * the given possibly-null caller.\n+     *\/\n+    private String finalFieldMutationWarning(Class<?> caller, boolean unreflect) {\n+        assert Modifier.isFinal(modifiers);\n+        String source;\n+        if (caller != null) {\n+            source = caller + \" in \" + caller.getModule();\n+            CodeSource cs = caller.getProtectionDomain().getCodeSource();\n+            if (cs != null) {\n+                URL url = cs.getLocation();\n+                if (url != null) {\n+                    source += \" (\" + url + \")\";\n+                }\n+            }\n+        } else {\n+            source = \"JNI attached thread with no caller frame\";\n+        }\n+        return String.format(\"Final field %s in %s has been %s by %s\",\n+                name,\n+                clazz,\n+                (unreflect) ? \"unreflected for mutation\" : \"mutated reflectively\",\n+                source);\n+    }\n+\n+    \/**\n+     * Returns the message for an IllegalAccessException when a final field cannot be\n+     * mutated because the declaring class is in a package that is not \"deeply accessible\"\n+     * to the caller.\n+     *\/\n+    private String notAccessibleToCallerMessage(Class<?> caller, boolean unreflect) {\n+        String exportsOrOpens = Modifier.isPublic(modifiers)\n+                && Modifier.isPublic(clazz.getModifiers()) ? \"exports\" : \"opens\";\n+        return String.format(\"%s, %s does not explicitly \\\"%s\\\" package %s to %s\",\n+                cannotSetFieldMessage(caller, unreflect),\n+                clazz.getModule(),\n+                exportsOrOpens,\n+                clazz.getPackageName(),\n+                caller.getModule());\n+    }\n+\n+    \/**\n+     * Returns the exception message for the IllegalAccessException when this\n+     * final field cannot be mutated because the caller module is not allowed\n+     * to mutate final fields.\n+     *\/\n+    private String callerNotAllowedToMutateMessage(Class<?> caller, boolean unreflect) {\n+        if (caller != null) {\n+            return String.format(\"%s, %s is not allowed to mutate final fields\",\n+                    cannotSetFieldMessage(caller, unreflect),\n+                    caller.getModule());\n+        } else {\n+            return notAccessibleToNoCallerMessage(unreflect);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the message for an IllegalAccessException when a field is not\n+     * accessible to a JNI attached thread.\n+     *\/\n+    private String notAccessibleToNoCallerMessage(boolean unreflect) {\n+        return cannotSetFieldMessage(\"JNI attached thread with no caller frame cannot\", unreflect);\n+    }\n+\n+    \/**\n+     * Returns a message to indicate that the caller cannot set\/unreflect this final field.\n+     *\/\n+    private String cannotSetFieldMessage(Class<?> caller, boolean unreflect) {\n+        return cannotSetFieldMessage(caller + \" (in \" + caller.getModule() + \") cannot\", unreflect);\n+    }\n+\n+    \/**\n+     * Returns a message to indicate that a field cannot be set\/unreflected.\n+     *\/\n+    private String cannotSetFieldMessage(String prefix, boolean unreflect) {\n+        if (unreflect) {\n+            return prefix + \" unreflect final field \" + clazz.getName() + \".\" + name\n+                    + \" (in \" + clazz.getModule() + \") for mutation\";\n+        } else {\n+            return prefix + \" set final field \" + clazz.getName() + \".\" + name\n+                    + \" (in \" + clazz.getModule() + \")\";\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":389,"deletions":26,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -4078,1 +4079,1 @@\n-    private List<Type> closureMin(List<Type> cl) {\n+    public List<Type> closureMin(List<Type> cl) {\n@@ -5212,2 +5213,3 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n-    \/** Check unconditionality between any combination of reference or primitive types.\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditional Exactness\">\n+    \/** Check type-based unconditional exactness between any combination of\n+     *  reference or primitive types according to JLS 5.7.2.\n@@ -5215,6 +5217,8 @@\n-     *  Rules:\n-     *    an identity conversion\n-     *    a widening reference conversion\n-     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n-     *    a boxing conversion\n-     *    a boxing conversion followed by a widening reference conversion\n+     *  The following are unconditionally exact regardless of the input\n+     *  expression:\n+     *\n+     *    - an identity conversion\n+     *    - a widening reference conversion\n+     *    - an exact widening primitive conversion\n+     *    - a boxing conversion\n+     *    - a boxing conversion followed by a widening reference conversion\n@@ -5225,1 +5229,1 @@\n-    public boolean isUnconditionallyExact(Type source, Type target) {\n+    public boolean isUnconditionallyExactTypeBased(Type source, Type target) {\n@@ -5230,3 +5234,12 @@\n-        return target.isPrimitive()\n-                ? isUnconditionallyExactPrimitives(source, target)\n-                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+        if (target.isPrimitive()) {\n+            if (source.isPrimitive() &&\n+                ((source.getTag().isStrictSubRangeOf(target.getTag())) &&\n+                        !((source.hasTag(BYTE) && target.hasTag(CHAR)) ||\n+                          (source.hasTag(INT) && target.hasTag(FLOAT)) ||\n+                          (source.hasTag(LONG) && (target.hasTag(DOUBLE) || target.hasTag(FLOAT)))))) return true;\n+            else {\n+                return false;\n+            }\n+        } else {\n+            return isSubtype(boxedTypeOrType(erasure(source)), target);\n+        }\n@@ -5235,1 +5248,7 @@\n-    \/** Check unconditionality between primitive types.\n+    \/** Check value-based unconditional exactness between any combination of\n+     *  reference or primitive types for the value of a constant expression\n+     *   according to JLS 5.7.2.\n+     *\n+     *  The following can be unconditionally exact if the source primitive is a\n+     *  constant expression and the conversions is exact for that constant\n+     *  expression:\n@@ -5237,4 +5256,72 @@\n-     *  - widening from one integral type to another,\n-     *  - widening from one floating point type to another,\n-     *  - widening from byte, short, or char to a floating point type,\n-     *  - widening from int to double.\n+     *    - a narrowing primitive conversion\n+     *    - a widening and narrowing primitive conversion\n+     *    - a widening primitive conversion that is not exact\n+     *\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExactValueBased(Type source, Type target) {\n+        if (!(source.constValue() instanceof Number value) || !target.getTag().isNumeric()) return false;\n+\n+        switch (source.getTag()) {\n+            case BYTE:\n+                switch (target.getTag()) {\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case CHAR:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                }\n+                break;\n+            case SHORT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case INT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                    case FLOAT:     return ExactConversionsSupport.isIntToFloatExact(value.intValue());\n+                }\n+                break;\n+            case FLOAT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isFloatToByteExact(value.floatValue());\n+                    case CHAR:      return ExactConversionsSupport.isFloatToCharExact(value.floatValue());\n+                    case SHORT:     return ExactConversionsSupport.isFloatToShortExact(value.floatValue());\n+                    case INT:       return ExactConversionsSupport.isFloatToIntExact(value.floatValue());\n+                    case LONG:      return ExactConversionsSupport.isFloatToLongExact(value.floatValue());\n+                }\n+                break;\n+            case LONG:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isLongToByteExact(value.longValue());\n+                    case CHAR:      return ExactConversionsSupport.isLongToCharExact(value.longValue());\n+                    case SHORT:     return ExactConversionsSupport.isLongToShortExact(value.longValue());\n+                    case INT:       return ExactConversionsSupport.isLongToIntExact(value.longValue());\n+                    case FLOAT:     return ExactConversionsSupport.isLongToFloatExact(value.longValue());\n+                    case DOUBLE:    return ExactConversionsSupport.isLongToDoubleExact(value.longValue());\n+                }\n+                break;\n+            case DOUBLE:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isDoubleToByteExact(value.doubleValue());\n+                    case CHAR:      return ExactConversionsSupport.isDoubleToCharExact(value.doubleValue());\n+                    case SHORT:     return ExactConversionsSupport.isDoubleToShortExact(value.doubleValue());\n+                    case INT:       return ExactConversionsSupport.isDoubleToIntExact(value.doubleValue());\n+                    case FLOAT:     return ExactConversionsSupport.isDoubleToFloatExact(value.doubleValue());\n+                    case LONG:      return ExactConversionsSupport.isDoubleToLongExact(value.doubleValue());\n+                }\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    \/** Check both type or value-based unconditional exactness between any\n+     *  combination of reference or primitive types for the value of a constant\n+     *  expression according to JLS 5.7.2.\n@@ -5242,2 +5329,2 @@\n-     *  @param selectorType     Type of selector\n-     *  @param targetType       Target type\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n@@ -5245,7 +5332,3 @@\n-    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n-        return isSameType(selectorType, targetType) ||\n-                (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n-                ((selectorType.getTag().isStrictSubRangeOf(targetType.getTag())) &&\n-                        !((selectorType.hasTag(BYTE) && targetType.hasTag(CHAR)) ||\n-                          (selectorType.hasTag(INT)  && targetType.hasTag(FLOAT)) ||\n-                          (selectorType.hasTag(LONG) && (targetType.hasTag(DOUBLE) || targetType.hasTag(FLOAT)))));\n+    public boolean isUnconditionallyExactCombined(Type currentType, Type testType) {\n+        return isUnconditionallyExactTypeBased(currentType, testType) ||\n+                (currentType.constValue() instanceof Number && isUnconditionallyExactValueBased(currentType, testType));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":110,"deletions":27,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2288,1 +2288,1 @@\n-                                types.isUnconditionallyExact(seltype, patternType);\n+                                types.isUnconditionallyExactTypeBased(seltype, patternType);\n@@ -4435,0 +4435,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, operand);\n@@ -4525,0 +4526,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, right);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Function;\n@@ -171,0 +170,1 @@\n+        allowPrimitivePatterns = preview.isEnabled() && Feature.PRIMITIVE_PATTERNS.allowedInSource(source);\n@@ -198,0 +198,4 @@\n+    \/** Are primitive patterns allowed\n+     *\/\n+    private final boolean allowPrimitivePatterns;\n+\n@@ -4293,0 +4297,31 @@\n+    \/**\n+     *  Check for bit shifts using an out-of-range bit count.\n+     *  @param pos           Position for error reporting.\n+     *  @param operator      The operator for the expression\n+     *  @param operand       The right hand operand for the expression\n+     *\/\n+    void checkOutOfRangeShift(final DiagnosticPosition pos, Symbol operator, Type operand) {\n+        if (operand.constValue() instanceof Number shiftAmount) {\n+            Type targetType;\n+            int maximumShift;\n+            switch (((OperatorSymbol)operator).opcode) {\n+            case ByteCodes.ishl, ByteCodes.ishr, ByteCodes.iushr, ByteCodes.ishll, ByteCodes.ishrl, ByteCodes.iushrl -> {\n+                targetType = syms.intType;\n+                maximumShift = 0x1f;\n+            }\n+            case ByteCodes.lshl, ByteCodes.lshr, ByteCodes.lushr, ByteCodes.lshll, ByteCodes.lshrl, ByteCodes.lushrl -> {\n+                targetType = syms.longType;\n+                maximumShift = 0x3f;\n+            }\n+            default -> {\n+                return;\n+            }\n+            }\n+            long specifiedShift = shiftAmount.longValue();\n+            if (specifiedShift > maximumShift || specifiedShift < -maximumShift) {\n+                int actualShift = (int)specifiedShift & (maximumShift - 1);\n+                log.warning(pos, LintWarnings.BitShiftOutOfRange(targetType, specifiedShift, actualShift));\n+            }\n+        }\n+    }\n+\n@@ -5031,0 +5066,7 @@\n+\n+                    \/\/ an unconditional pattern cannot be followed by any other label\n+                    if (allowPrimitivePatterns && unconditionalCaseLabel == testCaseLabel && unconditionalCaseLabel != label) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                        continue;\n+                    }\n+\n@@ -5032,5 +5074,5 @@\n-                    if (types.isUnconditionallyExact(currentType, testType) &&\n-                        !currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n-                        \/\/the current label is potentially dominated by the existing (test) label, check:\n-                        if (label instanceof JCConstantCaseLabel) {\n-                            dominated |= !(testCaseLabel instanceof JCConstantCaseLabel) &&\n+                    if (!currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+                        \/\/ the current label is potentially dominated by the existing (test) label, check:\n+                        if (types.isUnconditionallyExactCombined(currentType, testType) &&\n+                                label instanceof JCConstantCaseLabel) {\n+                            dominated = !(testCaseLabel instanceof JCConstantCaseLabel) &&\n@@ -5041,2 +5083,1 @@\n-                            dominated = patternDominated(testPatternCaseLabel.pat,\n-                                                         patternCL.pat);\n+                            dominated = patternDominated(testPatternCaseLabel.pat, patternCL.pat);\n@@ -5045,1 +5086,0 @@\n-\n@@ -5065,1 +5105,1 @@\n-            if (!types.isUnconditionallyExact(currentPatternType, existingPatternType)) {\n+            if (!types.isUnconditionallyExactTypeBased(currentPatternType, existingPatternType)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -2859,1 +2858,1 @@\n-            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+            if (types.isUnconditionallyExactTypeBased(tree.expr.type, tree.pattern.type)) {\n@@ -2868,1 +2867,1 @@\n-                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                if (types.isUnconditionallyExactTypeBased(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2475,0 +2475,5 @@\n+# 0: type, 1: long, 2: number\n+# lint: lossy-conversions\n+compiler.warn.bit.shift.out.of.range=\\\n+    shifting {0} by {1} bits is equivalent to shifting by {2} bit(s)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-    Warn about possible lossy conversions in compound assignment.\n+    Warn about possible lossy conversions in compound assignment and bit shift operations.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}