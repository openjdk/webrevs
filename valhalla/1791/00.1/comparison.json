{"files":[{"patch":"@@ -294,0 +294,15 @@\n+    \/**\n+     * Get a {@code RuntimeType} representing the type that is\n+     * dynamically enforced by this field. If the field does\n+     * not perform dynamic checks, this is the type that is\n+     * enforced by bytecode verification (the same as\n+     * {@link #getType} in most cases, but {@code Object} in\n+     * the case of an interface type).\n+     *\n+     * @return a {@code RuntimeType} representing the type that\n+     *         is dynamically enforced by this field\n+     *\/\n+    public RuntimeType<?> getRuntimeType() {\n+        return !type.isInterface() ? type : Object.class;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -54,0 +55,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -106,0 +108,4 @@\n+    \/* are nullable and null-restricted types allowed? *\/\n+    private boolean allowNullRestrictedTypes;\n+    private boolean tvarUnspecifiedNullity;\n+\n@@ -131,0 +137,3 @@\n+        Preview preview = Preview.instance(context);\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -133,0 +142,1 @@\n+        tvarUnspecifiedNullity = options.isSet(\"tvarUnspecifiedNullity\");\n@@ -1029,0 +1039,1 @@\n+                boolean result;\n@@ -1030,1 +1041,1 @@\n-                    return isSameType(elemtype(t), elemtype(s));\n+                    result = isSameType(elemtype(t), elemtype(s));\n@@ -1032,1 +1043,4 @@\n-                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                    result = isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                }\n+                if (result && allowNullRestrictedTypes && hasNarrowerNullability(s, t)) {\n+                    warn.warn(LintCategory.NULL);\n@@ -1034,1 +1048,2 @@\n-            } else if (isSubtype(t, s, capture)) {\n+                return result;\n+            } else if (isSubtype(t, s, capture, warn)) {\n@@ -1084,0 +1099,8 @@\n+    public boolean isSubtype(Type t, Type s, boolean capture, Warner warner) {\n+        try {\n+            pushWarner(warner);\n+            return isSubtype(t, s, capture);\n+        } finally {\n+            popWarner();\n+        }\n+    }\n@@ -1085,1 +1108,4 @@\n-        if (t.equalsIgnoreMetadata(s))\n+        if (t.equalsIgnoreMetadata(s)) {\n+            if (allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                warnStack.head.warn(LintCategory.NULL);\n+            }\n@@ -1087,0 +1113,1 @@\n+        }\n@@ -1127,1 +1154,4 @@\n-                 case BOT:\n+                 case BOT: {\n+                     if (isNonNullable(s)) {\n+                         return false;\n+                     }\n@@ -1129,2 +1159,3 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1195,1 +1226,1 @@\n-                return sup.tsym == s.tsym\n+                boolean result = sup.tsym == s.tsym\n@@ -1200,0 +1231,4 @@\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return result;\n@@ -1204,0 +1239,1 @@\n+                boolean result = false;\n@@ -1206,1 +1242,1 @@\n-                        return isSameType(t.elemtype, elemtype(s));\n+                        result = isSameType(t.elemtype, elemtype(s));\n@@ -1208,1 +1244,1 @@\n-                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n+                        result = isSubtypeNoCapture(t.elemtype, elemtype(s));\n@@ -1211,1 +1247,1 @@\n-                if (s.hasTag(CLASS)) {\n+                if (!result && s.hasTag(CLASS)) {\n@@ -1213,1 +1249,1 @@\n-                    return sname == names.java_lang_Object\n+                    result = sname == names.java_lang_Object\n@@ -1218,1 +1254,5 @@\n-                return false;\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+\n+                return result;\n@@ -1359,1 +1399,4 @@\n-                if (t.equalsIgnoreMetadata(s))\n+                if (t.equalsIgnoreMetadata(s)) {\n+                    if (allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                        warnStack.head.warn(LintCategory.NULL);\n+                    }\n@@ -1361,0 +1404,1 @@\n+                }\n@@ -1429,1 +1473,1 @@\n-                return t.tsym == s.tsym\n+                boolean equal = t.tsym == s.tsym\n@@ -1432,0 +1476,4 @@\n+                if (equal && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return equal;\n@@ -1438,8 +1486,13 @@\n-                if (t == s)\n-                    return true;\n-\n-                if (s.isPartial())\n-                    return visit(s, t);\n-\n-                return s.hasTag(ARRAY)\n-                    && containsTypeEquivalent(t.elemtype, elemtype(s));\n+                boolean result;\n+                if (t == s) {\n+                    result = true;\n+                } else if (s.isPartial()) {\n+                    result = visit(s, t);\n+                } else {\n+                    result = s.hasTag(ARRAY) &&\n+                            containsTypeEquivalent(t.elemtype, elemtype(s));\n+                }\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return result;\n@@ -1769,1 +1822,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT) && (!t.hasImplicitConstructor() || !isNonNullable(t)))\n@@ -2179,0 +2232,10 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n+    }\n+    \/\/ <\/editor-fold>\n+\n@@ -2368,0 +2431,4 @@\n+                            } else if (baseParams.length() != ownerParams.length()) {\n+                                \/\/ rare type, recovery\n+                                return subst(sym.type, ownerParams,\n+                                        baseParams.map(ta -> ta.asNullMarked(NullMarker.UNSPECIFIED)));\n@@ -2369,1 +2436,9 @@\n-                                return subst(sym.type, ownerParams, baseParams);\n+                                ListBuffer<Type> newBaseParams = new ListBuffer<>();\n+                                for (Type tvar : ownerParams) {\n+                                    Type baseParam = isParametric(tvar) ?\n+                                            baseParams.head :\n+                                            baseParams.head.asNullMarked(NullMarker.UNSPECIFIED);\n+                                    newBaseParams.add(baseParam);\n+                                    baseParams = baseParams.tail;\n+                                }\n+                                return subst(sym.type, ownerParams, newBaseParams.toList());\n@@ -2466,1 +2541,1 @@\n-                            return s.dropMetadata(Annotations.class);\n+                            return s.dropMetadata(Annotations.class).dropMetadata(TypeMetadata.NullMarker.class);\n@@ -2511,1 +2586,7 @@\n-        };\n+\n+        @Override\n+        public Type visitArrayType(ArrayType t, Boolean aBoolean) {\n+            Type erased = super.visitArrayType(t, aBoolean);\n+            return combineMetadata(erased, t);\n+        }\n+    };\n@@ -2854,1 +2935,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -4039,0 +4129,1 @@\n+        NullMarker nullMarker = NullMarker.NOT_NULL;\n@@ -4043,0 +4134,3 @@\n+            if (t.getNullMarker().ordinal() > nullMarker.ordinal()) {\n+                nullMarker = t.getNullMarker();\n+            }\n@@ -4092,1 +4186,2 @@\n-            return new ArrayType(lub(elements), syms.arrayClass);\n+            return new ArrayType(lub(elements), syms.arrayClass)\n+                    .asNullMarked(nullMarker);\n@@ -4127,1 +4222,2 @@\n-            return compoundMin(candidates);\n+            return compoundMin(candidates)\n+                    .asNullMarked(nullMarker);\n@@ -4180,1 +4276,4 @@\n-        else if (t.isPrimitive() || s.isPrimitive())\n+\n+        final NullMarker nullMarker = t.getNullMarker().ordinal() < s.getNullMarker().ordinal() ?\n+                    t.getNullMarker() : s.getNullMarker();\n+        if (t.isPrimitive() || s.isPrimitive())\n@@ -4183,1 +4282,1 @@\n-            return t;\n+            return t.asNullMarked(nullMarker);\n@@ -4185,1 +4284,1 @@\n-            return s;\n+            return s.asNullMarked(nullMarker);\n@@ -4188,1 +4287,1 @@\n-        return glbFlattened(closure, t);\n+        return glbFlattened(closure, t).asNullMarked(nullMarker);\n@@ -5294,0 +5393,4 @@\n+            assembleSig(type, false);\n+        }\n+\n+        public void assembleSig(Type type, boolean includeNullMarkers) {\n@@ -5327,1 +5430,7 @@\n-                    assembleClassSig(type);\n+                    assembleClassSig(type, includeNullMarkers);\n+                    if (includeNullMarkers) {\n+                        NullMarker nullMarker = type.getNullMarker();\n+                        if (nullMarker != NullMarker.UNSPECIFIED) {\n+                            append(nullMarker.typeSuffix().charAt(0));\n+                        }\n+                    }\n@@ -5333,1 +5442,7 @@\n-                    assembleSig(at.elemtype);\n+                    assembleSig(at.elemtype, includeNullMarkers);\n+                    \/*if (includeNullMarkers) {   \/\/ there is no type in the VM for null-restricted arrays, for now\n+                        NullMarker nmArray = at.getNullMarker();\n+                        if (nmArray != NullMarker.UNSPECIFIED) {\n+                            append(nmArray.typeSuffix().charAt(0));\n+                        }\n+                    }*\/\n@@ -5353,1 +5468,1 @@\n-                            assembleSig(ta.type);\n+                            assembleSig(ta.type, includeNullMarkers);\n@@ -5357,1 +5472,1 @@\n-                            assembleSig(ta.type);\n+                            assembleSig(ta.type, includeNullMarkers);\n@@ -5373,0 +5488,10 @@\n+                    if (includeNullMarkers) {\n+                        if (Types.this.isDeclaredParametric(type)) {\n+                            append('=');\/\/ '*' is already used for wildcards\n+                        } else {\n+                            NullMarker nmTV = type.getNullMarker();\n+                            if (nmTV != NullMarker.UNSPECIFIED) {\n+                                append(nmTV.typeSuffix().charAt(0));\n+                            }\n+                        }\n+                    }\n@@ -5396,0 +5521,4 @@\n+            assembleClassSig(type, false);\n+        }\n+\n+        public void assembleClassSig(Type type, boolean includeNullMarkers) {\n@@ -5406,1 +5535,1 @@\n-                        : outer);\n+                        : outer, includeNullMarkers);\n@@ -5417,1 +5546,1 @@\n-                assembleSig(ct.getTypeArguments());\n+                assembleSig(ct.getTypeArguments(), includeNullMarkers);\n@@ -5423,0 +5552,4 @@\n+            assembleParamsSig(typarams, false);\n+        }\n+\n+        public void assembleParamsSig(List<Type> typarams, boolean includeNullMarkers) {\n@@ -5433,1 +5566,1 @@\n-                    assembleSig(l.head);\n+                    assembleSig(l.head, includeNullMarkers);\n@@ -5440,0 +5573,4 @@\n+            assembleSig(types, false);\n+        }\n+\n+        public void assembleSig(List<Type> types, boolean includeNullMarkers) {\n@@ -5441,1 +5578,1 @@\n-                assembleSig(ts.head);\n+                assembleSig(ts.head, includeNullMarkers);\n@@ -5472,0 +5609,45 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+\n+    public boolean isNullable(Type type) {\n+        return type.getNullMarker() == NullMarker.NULLABLE;\n+    }\n+\n+    public boolean isNonNullable(Type type) {\n+        return type.getNullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isParametric(Type type) {\n+        return type.getNullMarker() == NullMarker.PARAMETRIC ||\n+                (type.hasTag(TYPEVAR) && type.getNullMarker() == NullMarker.UNSPECIFIED && !tvarUnspecifiedNullity);\n+    }\n+\n+    public boolean isDeclaredParametric(Type type) {\n+        return type.getNullMarker() == NullMarker.PARAMETRIC;\n+    }\n+\n+    public boolean isNullUnspecified(Type type) {\n+        return type.getNullMarker() == NullMarker.UNSPECIFIED &&\n+                (!type.hasTag(TYPEVAR) || tvarUnspecifiedNullity);\n+    }\n+\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return true;\n+        }\n+        return t.getNullMarker() == s.getNullMarker();\n+    }\n+\n+    \/**\n+     * Does t have narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return false;\n+        }\n+        return t.getNullMarker().ordinal() < s.getNullMarker().ordinal();\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":224,"deletions":42,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -193,0 +194,3 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n+        allowNullRestrictedTypesForValueClassesOnly = options.isSet(\"allowNullRestrictedTypesForValueClassesOnly\");\n@@ -226,0 +230,8 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n+    \/** Are null-restricted types allowed for value classes only\n+     *\/\n+    private final boolean allowNullRestrictedTypesForValueClassesOnly;\n+\n@@ -735,0 +747,4 @@\n+        if (allowNullRestrictedTypes && tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -1168,0 +1184,8 @@\n+            if (allowNullRestrictedTypes && tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1711,0 +1735,14 @@\n+            if (allowNullRestrictedTypes) {\n+                Type elemOrType = result;\n+                while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                    elemOrType = types.elemtype(elemOrType);\n+                }\n+                if (allowNullRestrictedTypesForValueClassesOnly &&\n+                        ((types.isNonNullable(result) || types.isNonNullable(elemOrType)) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor()))) {\n+                    log.error(tree.pos(),\n+                            types.elemtype(result) == null?\n+                                    Errors.TypeCantBeNullRestricted(result) :\n+                                    Errors.TypeCantBeNullRestricted2(result)\n+                    );\n+                }\n+            }\n@@ -1821,0 +1859,3 @@\n+                if (tree.stats.size() > 0) {\n+                    env.info.scope.owner.flags_field |= HASINITBLOCK;\n+                }\n@@ -3305,1 +3346,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -3307,0 +3348,4 @@\n+                if (allowNullRestrictedTypes && owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -3507,0 +3552,1 @@\n+            List<NullMarker> nullMarkers = tree.nullMarkers.reverse();\n@@ -3509,1 +3555,3 @@\n-                owntype = new ArrayType(owntype, syms.arrayClass);\n+                owntype = new ArrayType(owntype, syms.arrayClass)\n+                        .asNullMarked(nullMarkers.head);\n+                nullMarkers = nullMarkers.tail;\n@@ -4796,0 +4844,10 @@\n+        \/\/ check nullness of site\n+        if (types.isNullable(site)) {\n+            chk.warnNullableTypes(tree.selected, LintWarnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (types.isParametric(site)) {\n+            \/\/ see JDK-8339087\n+            \/\/chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -5111,0 +5169,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5758,0 +5821,5 @@\n+            if (c.type.isValueClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (allowNullRestrictedTypes && env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n@@ -5947,0 +6015,1 @@\n+                chk.checkConstraintsOfValueClassesWithImplicitConst((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -172,0 +173,2 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -209,0 +212,4 @@\n+    \/** Are null restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n@@ -264,0 +271,10 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnNullableTypes(DiagnosticPosition pos, LintWarning warnKey) {\n+        if (allowNullRestrictedTypes) {\n+            log.warning(pos, warnKey);\n+        }\n+    }\n+\n@@ -597,1 +614,3 @@\n-            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n+            if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n+                log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n+            }\n@@ -623,1 +642,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -628,1 +647,11 @@\n-             return types.isSubtype(a, bound);\n+             try {\n+                 if (pos != null) {\n+                     types.pushWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.popWarner();\n+                 }\n+             }\n+\n@@ -705,0 +734,24 @@\n+    void checkConstraintsOfValueClassesWithImplicitConst(JCClassDecl classDecl, ClassSymbol c) {\n+        if (allowNullRestrictedTypes) {\n+            JCMethodDecl implicitConstructor = TreeInfo.getImplicitConstructor(classDecl.defs);\n+            if (implicitConstructor != null) {\n+                Type encl = c.type.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitCannotBeInner(c));\n+                }\n+                if ((c.flags() & HASINITBLOCK) != 0) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitDeclaresInitBlock(c));\n+                }\n+                for (Symbol s : c.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0 & (s.flags() & HASINIT) != 0) {\n+                                log.error(classDecl.pos(), Errors.ValueClassWithImplicitInstanceFieldInitializer(c));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1070,1 +1123,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1073,1 +1130,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1110,1 +1167,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1183,0 +1240,1 @@\n+                boolean isNonNullableFieldOfNonValueClass = !sym.owner.type.isValueClass() && types.isNonNullable(sym.type);\n@@ -1186,0 +1244,3 @@\n+                } else if (isNonNullableFieldOfNonValueClass) {\n+                    implicit |= STRICT;\n+                    mask = ValueFieldFlags;\n@@ -1199,1 +1260,9 @@\n-                } else\n+                } else if ((flags & IMPLICIT) != 0) {\n+                    if ((flags & PUBLIC) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBePublic);\n+                    }\n+                    if ((sym.owner.flags_field & VALUE_CLASS) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBeDeclaredInValueClass);\n+                    }\n+                    mask = ImplicitConstructorFlags;\n+                } else {\n@@ -1201,0 +1270,1 @@\n+                }\n@@ -1313,0 +1383,4 @@\n+                 checkDisjoint(pos, flags,\n+                        INTERFACE,\n+                        VALUE_CLASS)\n+                 &&\n@@ -1444,1 +1518,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1848,2 +1922,16 @@\n-        boolean resultTypesOK =\n-            types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);\n+        boolean resultTypesOK = false;\n+        try {\n+            types.pushWarner(overrideWarner);\n+            resultTypesOK = types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);\n+            if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+                warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), LintWarnings.OverridesWithDifferentNullness1);\n+            }\n+            overrideWarner.remove(LintCategory.NULL);\n+            \/\/ at this point we know this will be true but to gather the warnings\n+            types.isSubSignature(mt, ot, overrideWarner);\n+            if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+                warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), LintWarnings.OverridesWithDifferentNullness2);\n+            }\n+        } finally {\n+            types.popWarner();\n+        }\n@@ -2326,0 +2414,43 @@\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n+    \/\/ TODO, update this method once we have null restricted types\n+    void checkNonCyclicMembership(JCClassDecl tree) {\n+        if (!tree.sym.type.hasImplicitConstructor()) {\n+            return;\n+        }\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                    }\n+                }\n+            }\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n+        \/*\n+        if ((c.flags_field & LOCKED) != 0) {\n+            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n+            return;\n+        }\n+        try {\n+            c.flags_field |= LOCKED;\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+        *\/\n+    }\n+        \/\/ where\n+        private boolean cyclePossible(VarSymbol symbol) {\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && types.isNonNullable(symbol.type);\n+        }\n+\n@@ -2582,0 +2713,13 @@\n+        boolean implementsLooselyConsistentValue = false;\n+        try {\n+            implementsLooselyConsistentValue = allowValueClasses && allowNullRestrictedTypes ? types.asSuper(c, syms.looselyConsistentValueType.tsym) != null : false;\n+        } catch (CompletionFailure cf) {\n+            \/\/ ignore\n+        }\n+        boolean cIsValue = (c.tsym.flags() & VALUE_CLASS) != 0;\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        if (c.getKind() == TypeKind.DECLARED && implementsLooselyConsistentValue && !c.tsym.isAbstract()) {\n+            if (!cIsValue || !((ClassSymbol)c.tsym).hasImplicitConstructor()) {\n+                log.error(pos, Errors.CantImplementInterface(c.tsym));\n+            }\n+        }\n@@ -4401,0 +4545,22 @@\n+    private class NullnessWarner extends Warner {\n+        public NullnessWarner(DiagnosticPosition pos) {\n+            super(pos);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (allowNullRestrictedTypes) {\n+                boolean warned = this.warned;\n+                super.warn(lint);\n+                if (warned) return; \/\/ suppress redundant diagnostics\n+                switch (lint) {\n+                    case NULL:\n+                        Check.this.warnNullableTypes(pos(), LintWarnings.UncheckedNullnessConversion);\n+                        break;\n+                    default:\n+                        throw new AssertionError(\"Unexpected lint: \" + lint);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -4429,0 +4595,3 @@\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), LintWarnings.UncheckedNullnessConversion);\n+                    break;\n@@ -4432,0 +4601,21 @@\n+            this.warned = true;\n+        }\n+    }\n+\n+    private class CastWarner extends ConversionWarner {\n+        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n+            super(pos, key, found, expected);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (lint != LintCategory.NULL) {\n+                super.warn(lint);\n+            } else {\n+                boolean warned = this.warned;\n+                if (warned) return;\n+                if (types.isParametric(expected)) {\n+                    \/\/ not sure this is the right warning\n+                    Check.this.warnNullableTypes(pos(), LintWarnings.NarrowingNullnessConversion);\n+                }\n+            }\n@@ -4436,1 +4626,1 @@\n-        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":201,"deletions":11,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+    private final boolean allowNullRestrictedTypes;\n@@ -148,0 +149,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -4294,0 +4297,2 @@\n+        \/\/ nullness info could be lost in the translation process, let's keep the original element type\n+        JCExpression originalElemType = tree.elemtype;\n@@ -4295,1 +4300,2 @@\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n+        int noOfDims = 0;\n+        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail) {\n@@ -4297,0 +4303,2 @@\n+            noOfDims++;\n+        }\n@@ -4298,1 +4306,26 @@\n-        result = tree;\n+        if (!allowNullRestrictedTypes || tree.elemtype == null || !types.isNonNullable(originalElemType.type)) {\n+            result = tree;\n+        } else {\n+            Symbol elemClass = syms.getClassField(tree.elemtype.type, types);\n+            JCFieldAccess elemClassExpr = make.Select(make.Ident(tree.elemtype.type.tsym).setType(tree.elemtype.type), elemClass);\n+            MethodSymbol asNullRestrictedTypeMeth = lookupMethod(tree.pos(), names.asNullRestrictedType, syms.classType, List.nil());\n+            JCExpression asNullRestrictedTypeCall = make.Apply(\n+                        null,\n+                        make.Select(elemClassExpr, asNullRestrictedTypeMeth).setType(syms.classType), List.nil()).setType(syms.classType);\n+            List<JCExpression> dimsExp = tree.dims;\n+            if (noOfDims > 1) {\n+                JCNewArray dimsArr = make.NewArray(make.Type(syms.intType), List.nil(), tree.dims);\n+                dimsArr.type = types.makeArrayType(syms.intType);\n+                dimsExp = List.of(dimsArr);\n+            }\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.newInstance,\n+                syms.reflectArrayType, List.of(syms.classType, noOfDims == 1 ? syms.intType : types.makeArrayType(syms.intType)));\n+            JCExpression call =\n+                    make.Apply(\n+                            null,\n+                            make.Select(make.Ident(syms.reflectArrayType.tsym).setType(syms.reflectArrayType), appyMeth).setType(syms.objectType),\n+                            dimsExp.prepend(asNullRestrictedTypeCall))\n+                            .setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(types.makeArrayType(tree.elemtype.type, noOfDims), call);\n+            result = cast;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3427,0 +3427,3 @@\n+compiler.misc.feature.null.restricted.types=\\\n+    nullable and null restricted types\n+\n@@ -4319,0 +4322,29 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n+compiler.err.implicit.const.must.be.public=\\\n+    implicit constructors must be public\n+\n+compiler.err.implicit.const.must.be.declared.in.value.class=\\\n+    only value classes can declare implicit constructors\n+\n+# 0: symbol\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n+     be value classes and declare an implicit constructor.\n+\n+\n@@ -4362,0 +4394,55 @@\n+\n+### null-restricted types\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    it must be a value class with an implicit constructor\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted.2=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    its element type must be a value class with an implicit constructor\n+\n+compiler.err.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+# 0: name\n+compiler.misc.attribute.must.be.unique=\\\n+    attribute {0} must be unique\n+\n+# 0: name\n+compiler.misc.attribute.only.applicable.to.fields=\\\n+    attribute {0} is only applicable to fields\n+\n+# 0: name, 1: type\n+compiler.misc.attribute.not.applicable.to.field.type=\\\n+    attribute {0} is not applicable to {1}\n+\n+# lint: null\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+# lint: null\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+# lint: null\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+# lint: null\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+# lint: null\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+# lint: null\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+# lint: null\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -243,0 +243,3 @@\n+javac.opt.Xlint.desc.null=\\\n+    Warn about operations on null-restricted and nullable types.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}