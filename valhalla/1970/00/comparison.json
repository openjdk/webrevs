{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -471,5 +471,2 @@\n-  \/\/ Currently, Canonicalizer is only used by GraphBuilder,\n-  \/\/ and IfOp is not created by GraphBuilder but only later\n-  \/\/ when eliminating conditional expressions with CE_Eliminator,\n-  \/\/ so this method will not be called.\n-  ShouldNotReachHere();\n+  \/\/ Currently, Canonicalizer is only used by GraphBuilder, and IfOp is only created by\n+  \/\/ GraphBuilder when loading\/storing flat fields, do nothing for now.\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"c1\/c1_Instruction.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"c1\/c1_ValueType.hpp\"\n@@ -1986,3 +1988,1 @@\n-          bool is_naturally_atomic = inline_klass->nof_declared_nonstatic_fields() <= 1;\n-          bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-          if (needs_atomic_access) {\n+          if (field->is_atomic()) {\n@@ -1993,1 +1993,0 @@\n-            assert(field->is_null_free(), \"must be null-free\");\n@@ -1996,11 +1995,13 @@\n-            ciBytecodeStream s(method());\n-            s.force_bci(bci());\n-            s.next();\n-            if (s.cur_bc() == Bytecodes::_getfield && !needs_patching) {\n-              ciField* next_field = s.get_field(will_link);\n-              bool next_needs_patching = !next_field->holder()->is_loaded() ||\n-                                         !next_field->will_link(method(), Bytecodes::_getfield) ||\n-                                         PatchALot;\n-              \/\/ We can't update the offset for atomic accesses\n-              bool next_needs_atomic_access = !next_field->is_null_free() || next_field->is_volatile();\n-              can_delay_access = C1UseDelayedFlattenedFieldReads && !next_needs_patching && !next_needs_atomic_access;\n+            if (field->is_null_free()) {\n+              ciBytecodeStream s(method());\n+              s.force_bci(bci());\n+              s.next();\n+              if (s.cur_bc() == Bytecodes::_getfield && !needs_patching) {\n+                ciField* next_field = s.get_field(will_link);\n+                bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+                                          !next_field->will_link(method(), Bytecodes::_getfield) ||\n+                                          PatchALot;\n+                \/\/ We can't update the offset for atomic accesses\n+                bool next_needs_atomic_access = next_field->is_flat() && next_field->is_atomic();\n+                can_delay_access = C1UseDelayedFlattenedFieldReads && !next_needs_patching && !next_needs_atomic_access && next_field->is_null_free();\n+              }\n@@ -2008,0 +2009,1 @@\n+\n@@ -2021,1 +2023,0 @@\n-              bool need_membar = false;\n@@ -2023,0 +2024,1 @@\n+                assert(field->is_null_free(), \"nullable fields do not support delayed accesses yet\");\n@@ -2031,1 +2033,10 @@\n-                need_membar = true;\n+              } else if (has_pending_field_access()) {\n+                assert(field->is_null_free(), \"nullable fields do not support delayed accesses yet\");\n+                state_before = pending_field_access()->state_before();\n+                NewInstance* new_instance = new NewInstance(inline_klass, state_before, false, true);\n+                _memory->new_instance(new_instance);\n+                apush(append_split(new_instance));\n+                copy_inline_content(inline_klass, pending_field_access()->obj(),\n+                                    pending_field_access()->offset() + field->offset_in_bytes() - field->holder()->as_inline_klass()->payload_offset(),\n+                                    new_instance, inline_klass->payload_offset(), state_before);\n+                set_pending_field_access(nullptr);\n@@ -2033,2 +2044,5 @@\n-                if (has_pending_field_access()) {\n-                  state_before = pending_field_access()->state_before();\n+                if (!field->is_null_free() && !inline_klass->is_initialized()) {\n+                  \/\/ Cannot allocate an instance of inline_klass because it may have not been\n+                  \/\/ initialized, bailout for now\n+                  bailout(\"load from an uninitialized nullable non-atomic flat field\");\n+                  return;\n@@ -2036,0 +2050,1 @@\n+\n@@ -2038,12 +2053,5 @@\n-                apush(append_split(new_instance));\n-                if (has_pending_field_access()) {\n-                  copy_inline_content(inline_klass, pending_field_access()->obj(),\n-                                      pending_field_access()->offset() + field->offset_in_bytes() - field->holder()->as_inline_klass()->payload_offset(),\n-                                      new_instance, inline_klass->payload_offset(), state_before);\n-                  set_pending_field_access(nullptr);\n-                } else {\n-                  if (field->type()->as_instance_klass()->is_initialized() && field->type()->as_inline_klass()->is_empty()) {\n-                    \/\/ Needs an explicit null check because below code does not perform any actual load if there are no fields\n-                    null_check(obj);\n-                  }\n-                  copy_inline_content(inline_klass, obj, field->offset_in_bytes(), new_instance, inline_klass->payload_offset(), state_before);\n+                append_split(new_instance);\n+\n+                if (inline_klass->is_initialized() && inline_klass->is_empty()) {\n+                  \/\/ Needs an explicit null check because below code does not perform any actual load if there are no fields\n+                  null_check(obj);\n@@ -2051,7 +2059,11 @@\n-                need_membar = true;\n-              }\n-              if (need_membar) {\n-                \/\/ If we allocated a new instance ensure the stores to copy the\n-                \/\/ field contents are visible before any subsequent store that\n-                \/\/ publishes this reference.\n-                append(new MemBar(lir_membar_storestore));\n+                copy_inline_content(inline_klass, obj, field->offset_in_bytes(), new_instance, inline_klass->payload_offset(), state_before);\n+\n+                Instruction* result = new_instance;\n+                if (!field->is_null_free()) {\n+                  Value int_zero = append(new Constant(intZero));\n+                  Value object_null = append(new Constant(objectNull));\n+                  Value nm_offset = append(new Constant(new LongConstant(offset + inline_klass->null_marker_offset_in_payload())));\n+                  Value nm = append(new UnsafeGet(T_BOOLEAN, obj, nm_offset, false));\n+                  result = append(new IfOp(nm, Instruction::neq, int_zero, new_instance, object_null, state_before, false));\n+                }\n+                apush(result);\n@@ -2059,0 +2071,5 @@\n+\n+              \/\/ If we allocated a new instance ensure the stores to copy the\n+              \/\/ field contents are visible before any subsequent store that\n+              \/\/ publishes this reference.\n+              append(new MemBar(lir_membar_storestore));\n@@ -2093,3 +2110,1 @@\n-        bool is_naturally_atomic = inline_klass->nof_declared_nonstatic_fields() <= 1;\n-        bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-        if (needs_atomic_access) {\n+        if (field->is_atomic()) {\n@@ -2100,2 +2115,2 @@\n-        } else {\n-          assert(field->is_null_free(), \"must be null-free\");\n+        } else if (field->is_null_free()) {\n+          assert(!inline_klass->is_empty(), \"should have been handled\");\n@@ -2103,0 +2118,19 @@\n+        } else {\n+          if (!inline_klass->is_initialized()) {\n+            \/\/ null_reset_value is not available, bailout for now\n+            bailout(\"store to an uninitialized nullable non-atomic flat field\");\n+            return;\n+          }\n+\n+          \/\/ Store the subfields when field is a nullable non-atomic field\n+          Value object_null = append(new Constant(objectNull));\n+          Value null_reset_value = append(new Constant(new ObjectConstant(inline_klass->get_null_reset_value().as_object())));\n+          Value src = append(new IfOp(val, Instruction::neq, object_null, val, null_reset_value, state_before, false));\n+          copy_inline_content(inline_klass, src, inline_klass->payload_offset(), obj, offset, state_before);\n+\n+          \/\/ Store the null marker\n+          Value int_one = append(new Constant(new IntConstant(1)));\n+          Value int_zero = append(new Constant(intZero));\n+          Value nm = append(new IfOp(val, Instruction::neq, object_null, int_one, int_zero, state_before, false));\n+          Value nm_offset = append(new Constant(new LongConstant(offset + inline_klass->null_marker_offset_in_payload())));\n+          append(new UnsafePut(T_BOOLEAN, obj, nm_offset, nm, false));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":78,"deletions":44,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1653,3 +1653,1 @@\n-    bool is_naturally_atomic = vk->nof_declared_nonstatic_fields() <= 1;\n-    bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-    assert(needs_atomic_access, \"No atomic access required\");\n+    assert(field->is_atomic(), \"No atomic access required %s.%s\", field->holder()->name()->as_utf8(), field->name()->as_utf8());\n@@ -2101,3 +2099,1 @@\n-    bool is_naturally_atomic = vk->nof_declared_nonstatic_fields() <= 1;\n-    bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-    assert(needs_atomic_access, \"No atomic access required\");\n+    assert(field->is_atomic(), \"No atomic access required\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -250,0 +251,1 @@\n+  _layout_kind = LayoutKind::UNKNOWN;\n@@ -277,0 +279,1 @@\n+  _layout_kind = LayoutKind::UNKNOWN;\n@@ -326,0 +329,1 @@\n+  _layout_kind = fd->is_flat() ? fd->layout_kind() : LayoutKind::UNKNOWN;\n@@ -419,0 +423,4 @@\n+bool ciField::is_atomic() {\n+  assert(is_flat(), \"should not ask this property for non-flat field %s.%s\", holder()->name()->as_utf8(), name()->as_utf8());\n+  return LayoutKindHelper::is_atomic_flat(_layout_kind) && !type()->as_inline_klass()->is_naturally_atomic(is_null_free());\n+}\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -52,0 +53,1 @@\n+  LayoutKind       _layout_kind;\n@@ -183,0 +185,7 @@\n+  \/\/ Whether this field needs to act atomically. Note that it does not actually need accessing\n+  \/\/ atomically. For example, if there cannot be racy accesses to this field, then it can be\n+  \/\/ accessed in a non-atomic manner. This method must not depend on the fact that the field cannot\n+  \/\/ be accessed racily (e.g. it is a strict final field), as if the holder object is flattened\n+  \/\/ as a field that is not strict final, this property is lost.\n+  bool is_atomic();\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"ci\/ciConstant.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"ci\/ciUtilities.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -29,0 +32,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -154,0 +158,10 @@\n+\n+\/\/ All fields of this object is zero even if they can be null-free. As a result, this object should\n+\/\/ only be used to reset the payload of fields or array elements and should not be leaked\n+\/\/ elsewhere.\n+ciConstant ciInlineKlass::get_null_reset_value() const {\n+  VM_ENTRY_MARK\n+  InlineKlass* vk = get_InlineKlass();\n+  oop null_reset_value = vk->null_reset_value();\n+  return ciConstant(T_OBJECT, CURRENT_ENV->get_object(null_reset_value));\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,1 @@\n+  ciConstant get_null_reset_value() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -447,2 +447,1 @@\n-      \/\/ Atomic if nullable or not LooselyConsistentValue\n-      bool atomic = !field_null_free || fvk->must_be_atomic();\n+      bool atomic = field->is_atomic();\n@@ -600,2 +599,1 @@\n-      \/\/ Atomic if nullable or not LooselyConsistentValue\n-      bool atomic = !field_null_free || fvk->must_be_atomic();\n+      bool atomic = field->is_atomic();\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-    bool atomic = vk->must_be_atomic() || !field->is_null_free();\n+    bool atomic = field->is_atomic();\n@@ -285,1 +285,1 @@\n-    bool atomic = vk->must_be_atomic() || !field->is_null_free();\n+    bool atomic = field->is_atomic();\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -841,1 +841,1 @@\n-  product(bool, UseNullableNonAtomicValueFlattening, false,                 \\\n+  product(bool, UseNullableNonAtomicValueFlattening, true,                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,0 +263,4 @@\n+    \/\/ TODO 8376254: C1 bailouts if the type of the nullable flat field is uninitialized\n+    static final EmptyType2 LOAD_EMPTY_TYPE_2 = new EmptyType2();\n+    static final EmptyContainer2 LOAD_EMPTY_CONTAINER_2 = new EmptyContainer2();\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}