{"files":[{"patch":"@@ -7264,1 +7264,2 @@\n-      \/\/ Also set all oop fields to zero to make the GC happy.\n+      \/\/ Also set all fields to zero since the runtime requires a canonical\n+      \/\/ representation of a flat null.\n@@ -7267,8 +7268,7 @@\n-        if (sig->at(stream.sig_index())._offset == -1 ||\n-            bt == T_OBJECT || bt == T_ARRAY) {\n-          if (toReg->is_stack()) {\n-            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n-            str(zr, Address(sp, st_off));\n-          } else {\n-            mov(toReg->as_Register(), zr);\n-          }\n+        if (toReg->is_stack()) {\n+          int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+          str(zr, Address(sp, st_off));\n+        } else if (toReg->is_FloatRegister()) {\n+          mov(toReg->as_FloatRegister(), T2S, 0);\n+        } else {\n+          mov(toReg->as_Register(), zr);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3058,1 +3058,1 @@\n-  if (vk->has_nullable_atomic_layout()) {\n+  if (vk->supports_nullable_layouts()) {\n@@ -3070,1 +3070,2 @@\n-  \/\/ Return value is null. Zero oop registers to make the GC happy.\n+  \/\/ Return value is null. Zero all registers because the runtime requires a canonical\n+  \/\/ representation of a flat null.\n@@ -3084,3 +3085,6 @@\n-    if (bt == T_OBJECT || bt == T_ARRAY) {\n-      VMRegPair pair = regs->at(j);\n-      VMReg r_1 = pair.first();\n+\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    if (r_1->is_FloatRegister()) {\n+      __ mov(r_1->as_FloatRegister(), Assembler::T2S, 0);\n+    } else {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -6383,1 +6383,2 @@\n-      \/\/ Also set all oop fields to zero to make the GC happy.\n+      \/\/ Also set all fields to zero since the runtime requires a canonical\n+      \/\/ representation of a flat null.\n@@ -6386,8 +6387,7 @@\n-        if (sig->at(stream.sig_index())._offset == -1 ||\n-            bt == T_OBJECT || bt == T_ARRAY) {\n-          if (toReg->is_stack()) {\n-            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n-            movq(Address(rsp, st_off), 0);\n-          } else {\n-            xorq(toReg->as_Register(), toReg->as_Register());\n-          }\n+        if (toReg->is_stack()) {\n+          int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+          movq(Address(rsp, st_off), 0);\n+        } else if (toReg->is_XMMRegister()) {\n+          xorps(toReg->as_XMMRegister(), toReg->as_XMMRegister());\n+        } else {\n+          xorl(toReg->as_Register(), toReg->as_Register());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3851,1 +3851,1 @@\n-  if (vk->has_nullable_atomic_layout()) {\n+  if (vk->supports_nullable_layouts()) {\n@@ -3864,1 +3864,2 @@\n-  \/\/ Return value is null. Zero oop registers to make the GC happy.\n+  \/\/ Return value is null. Zero all registers because the runtime requires a canonical\n+  \/\/ representation of a flat null.\n@@ -3878,4 +3879,7 @@\n-    if (bt == T_OBJECT || bt == T_ARRAY) {\n-      VMRegPair pair = regs->at(j);\n-      VMReg r_1 = pair.first();\n-      __ xorq(r_1->as_Register(), r_1->as_Register());\n+\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    if (r_1->is_XMMRegister()) {\n+      __ xorps(r_1->as_XMMRegister(), r_1->as_XMMRegister());\n+    } else {\n+      __ xorl(r_1->as_Register(), r_1->as_Register());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -471,5 +471,2 @@\n-  \/\/ Currently, Canonicalizer is only used by GraphBuilder,\n-  \/\/ and IfOp is not created by GraphBuilder but only later\n-  \/\/ when eliminating conditional expressions with CE_Eliminator,\n-  \/\/ so this method will not be called.\n-  ShouldNotReachHere();\n+  \/\/ Currently, Canonicalizer is only used by GraphBuilder, and IfOp is only created by\n+  \/\/ GraphBuilder when loading\/storing flat fields, do nothing for now.\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"c1\/c1_Instruction.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"c1\/c1_ValueType.hpp\"\n@@ -1986,3 +1988,1 @@\n-          bool is_naturally_atomic = inline_klass->nof_declared_nonstatic_fields() <= 1;\n-          bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-          if (needs_atomic_access) {\n+          if (field->is_atomic()) {\n@@ -1993,1 +1993,0 @@\n-            assert(field->is_null_free(), \"must be null-free\");\n@@ -1996,11 +1995,13 @@\n-            ciBytecodeStream s(method());\n-            s.force_bci(bci());\n-            s.next();\n-            if (s.cur_bc() == Bytecodes::_getfield && !needs_patching) {\n-              ciField* next_field = s.get_field(will_link);\n-              bool next_needs_patching = !next_field->holder()->is_loaded() ||\n-                                         !next_field->will_link(method(), Bytecodes::_getfield) ||\n-                                         PatchALot;\n-              \/\/ We can't update the offset for atomic accesses\n-              bool next_needs_atomic_access = !next_field->is_null_free() || next_field->is_volatile();\n-              can_delay_access = C1UseDelayedFlattenedFieldReads && !next_needs_patching && !next_needs_atomic_access;\n+            if (field->is_null_free()) {\n+              ciBytecodeStream s(method());\n+              s.force_bci(bci());\n+              s.next();\n+              if (s.cur_bc() == Bytecodes::_getfield && !needs_patching) {\n+                ciField* next_field = s.get_field(will_link);\n+                bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+                                          !next_field->will_link(method(), Bytecodes::_getfield) ||\n+                                          PatchALot;\n+                \/\/ We can't update the offset for atomic accesses\n+                bool next_needs_atomic_access = next_field->is_flat() && next_field->is_atomic();\n+                can_delay_access = C1UseDelayedFlattenedFieldReads && !next_needs_patching && !next_needs_atomic_access && next_field->is_null_free();\n+              }\n@@ -2008,0 +2009,1 @@\n+\n@@ -2021,1 +2023,0 @@\n-              bool need_membar = false;\n@@ -2023,0 +2024,1 @@\n+                assert(field->is_null_free(), \"nullable fields do not support delayed accesses yet\");\n@@ -2031,1 +2033,10 @@\n-                need_membar = true;\n+              } else if (has_pending_field_access()) {\n+                assert(field->is_null_free(), \"nullable fields do not support delayed accesses yet\");\n+                state_before = pending_field_access()->state_before();\n+                NewInstance* new_instance = new NewInstance(inline_klass, state_before, false, true);\n+                _memory->new_instance(new_instance);\n+                apush(append_split(new_instance));\n+                copy_inline_content(inline_klass, pending_field_access()->obj(),\n+                                    pending_field_access()->offset() + field->offset_in_bytes() - field->holder()->as_inline_klass()->payload_offset(),\n+                                    new_instance, inline_klass->payload_offset(), state_before);\n+                set_pending_field_access(nullptr);\n@@ -2033,2 +2044,5 @@\n-                if (has_pending_field_access()) {\n-                  state_before = pending_field_access()->state_before();\n+                if (!field->is_null_free() && !inline_klass->is_initialized()) {\n+                  \/\/ Cannot allocate an instance of inline_klass because it may have not been\n+                  \/\/ initialized, bailout for now\n+                  bailout(\"load from an uninitialized nullable non-atomic flat field\");\n+                  return;\n@@ -2036,0 +2050,1 @@\n+\n@@ -2038,12 +2053,5 @@\n-                apush(append_split(new_instance));\n-                if (has_pending_field_access()) {\n-                  copy_inline_content(inline_klass, pending_field_access()->obj(),\n-                                      pending_field_access()->offset() + field->offset_in_bytes() - field->holder()->as_inline_klass()->payload_offset(),\n-                                      new_instance, inline_klass->payload_offset(), state_before);\n-                  set_pending_field_access(nullptr);\n-                } else {\n-                  if (field->type()->as_instance_klass()->is_initialized() && field->type()->as_inline_klass()->is_empty()) {\n-                    \/\/ Needs an explicit null check because below code does not perform any actual load if there are no fields\n-                    null_check(obj);\n-                  }\n-                  copy_inline_content(inline_klass, obj, field->offset_in_bytes(), new_instance, inline_klass->payload_offset(), state_before);\n+                append_split(new_instance);\n+\n+                if (inline_klass->is_initialized() && inline_klass->is_empty()) {\n+                  \/\/ Needs an explicit null check because below code does not perform any actual load if there are no fields\n+                  null_check(obj);\n@@ -2051,7 +2059,11 @@\n-                need_membar = true;\n-              }\n-              if (need_membar) {\n-                \/\/ If we allocated a new instance ensure the stores to copy the\n-                \/\/ field contents are visible before any subsequent store that\n-                \/\/ publishes this reference.\n-                append(new MemBar(lir_membar_storestore));\n+                copy_inline_content(inline_klass, obj, field->offset_in_bytes(), new_instance, inline_klass->payload_offset(), state_before);\n+\n+                Instruction* result = new_instance;\n+                if (!field->is_null_free()) {\n+                  Value int_zero = append(new Constant(intZero));\n+                  Value object_null = append(new Constant(objectNull));\n+                  Value nm_offset = append(new Constant(new LongConstant(offset + inline_klass->null_marker_offset_in_payload())));\n+                  Value nm = append(new UnsafeGet(T_BOOLEAN, obj, nm_offset, false));\n+                  result = append(new IfOp(nm, Instruction::neq, int_zero, new_instance, object_null, state_before, false));\n+                }\n+                apush(result);\n@@ -2059,0 +2071,5 @@\n+\n+              \/\/ If we allocated a new instance ensure the stores to copy the\n+              \/\/ field contents are visible before any subsequent store that\n+              \/\/ publishes this reference.\n+              append(new MemBar(lir_membar_storestore));\n@@ -2093,3 +2110,1 @@\n-        bool is_naturally_atomic = inline_klass->nof_declared_nonstatic_fields() <= 1;\n-        bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-        if (needs_atomic_access) {\n+        if (field->is_atomic()) {\n@@ -2100,2 +2115,2 @@\n-        } else {\n-          assert(field->is_null_free(), \"must be null-free\");\n+        } else if (field->is_null_free()) {\n+          assert(!inline_klass->is_empty(), \"should have been handled\");\n@@ -2103,0 +2118,19 @@\n+        } else {\n+          if (!inline_klass->is_initialized()) {\n+            \/\/ null_reset_value is not available, bailout for now\n+            bailout(\"store to an uninitialized nullable non-atomic flat field\");\n+            return;\n+          }\n+\n+          \/\/ Store the subfields when field is a nullable non-atomic field\n+          Value object_null = append(new Constant(objectNull));\n+          Value null_reset_value = append(new Constant(new ObjectConstant(inline_klass->get_null_reset_value().as_object())));\n+          Value src = append(new IfOp(val, Instruction::neq, object_null, val, null_reset_value, state_before, false));\n+          copy_inline_content(inline_klass, src, inline_klass->payload_offset(), obj, offset, state_before);\n+\n+          \/\/ Store the null marker\n+          Value int_one = append(new Constant(new IntConstant(1)));\n+          Value int_zero = append(new Constant(intZero));\n+          Value nm = append(new IfOp(val, Instruction::neq, object_null, int_one, int_zero, state_before, false));\n+          Value nm_offset = append(new Constant(new LongConstant(offset + inline_klass->null_marker_offset_in_payload())));\n+          append(new UnsafePut(T_BOOLEAN, obj, nm_offset, nm, false));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":78,"deletions":44,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1653,3 +1653,1 @@\n-    bool is_naturally_atomic = vk->nof_declared_nonstatic_fields() <= 1;\n-    bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-    assert(needs_atomic_access, \"No atomic access required\");\n+    assert(field->is_atomic(), \"No atomic access required %s.%s\", field->holder()->name()->as_utf8(), field->name()->as_utf8());\n@@ -2101,3 +2099,1 @@\n-    bool is_naturally_atomic = vk->nof_declared_nonstatic_fields() <= 1;\n-    bool needs_atomic_access = !field->is_null_free() || (field->is_volatile() && !is_naturally_atomic);\n-    assert(needs_atomic_access, \"No atomic access required\");\n+    assert(field->is_atomic(), \"No atomic access required\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -250,0 +251,1 @@\n+  _layout_kind = LayoutKind::UNKNOWN;\n@@ -277,0 +279,1 @@\n+  _layout_kind = LayoutKind::UNKNOWN;\n@@ -326,0 +329,1 @@\n+  _layout_kind = fd->is_flat() ? fd->layout_kind() : LayoutKind::UNKNOWN;\n@@ -419,0 +423,4 @@\n+bool ciField::is_atomic() {\n+  assert(is_flat(), \"should not ask this property for non-flat field %s.%s\", holder()->name()->as_utf8(), name()->as_utf8());\n+  return LayoutKindHelper::is_atomic_flat(_layout_kind) && !type()->as_inline_klass()->is_naturally_atomic(is_null_free());\n+}\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -52,0 +53,1 @@\n+  LayoutKind       _layout_kind;\n@@ -183,0 +185,7 @@\n+  \/\/ Whether this field needs to act atomically. Note that it does not actually need accessing\n+  \/\/ atomically. For example, if there cannot be racy accesses to this field, then it can be\n+  \/\/ accessed in a non-atomic manner. This method must not depend on the fact that the field cannot\n+  \/\/ be accessed racily (e.g. it is a strict final field), as if the holder object is flattened\n+  \/\/ as a field that is not strict final, this property is lost.\n+  bool is_atomic();\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"ci\/ciConstant.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"ci\/ciUtilities.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -29,0 +32,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -136,4 +140,0 @@\n-bool ciInlineKlass::must_be_atomic() const {\n-  GUARDED_VM_ENTRY(return get_InlineKlass()->must_be_atomic();)\n-}\n-\n@@ -154,0 +154,10 @@\n+\n+\/\/ All fields of this object are zero even if they are null-free. As a result, this object should\n+\/\/ only be used to reset the payload of fields or array elements and should not be leaked\n+\/\/ elsewhere.\n+ciConstant ciInlineKlass::get_null_reset_value() const {\n+  VM_ENTRY_MARK\n+  InlineKlass* vk = get_InlineKlass();\n+  oop null_reset_value = vk->null_reset_value();\n+  return ciConstant(T_OBJECT, CURRENT_ENV->get_object(null_reset_value));\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,0 @@\n-  bool must_be_atomic() const;\n@@ -85,0 +84,1 @@\n+  ciConstant get_null_reset_value() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -447,2 +447,1 @@\n-      \/\/ Atomic if nullable or not LooselyConsistentValue\n-      bool atomic = !field_null_free || fvk->must_be_atomic();\n+      bool atomic = field->is_atomic();\n@@ -600,2 +599,1 @@\n-      \/\/ Atomic if nullable or not LooselyConsistentValue\n-      bool atomic = !field_null_free || fvk->must_be_atomic();\n+      bool atomic = field->is_atomic();\n@@ -1417,1 +1415,1 @@\n-void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free, Node* null_check_region, GrowableArray<ciType*>& visited) {\n+void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool no_null_marker, Node* null_check_region, GrowableArray<ciType*>& visited) {\n@@ -1420,1 +1418,1 @@\n-  if (!null_free) {\n+  if (!no_null_marker) {\n@@ -1503,3 +1501,0 @@\n-          if (null_free) {\n-            parm = kit->cast_not_null(parm);\n-          }\n@@ -1518,1 +1513,1 @@\n-  if (!null_free && !in) {\n+  if (!no_null_marker && !in) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free, Node* null_check_region, GrowableArray<ciType*>& visited);\n+  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool no_null_marker, Node* null_check_region, GrowableArray<ciType*>& visited);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-    bool atomic = vk->must_be_atomic() || !field->is_null_free();\n+    bool atomic = field->is_atomic();\n@@ -285,1 +285,1 @@\n-    bool atomic = vk->must_be_atomic() || !field->is_null_free();\n+    bool atomic = field->is_atomic();\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -427,1 +427,1 @@\n-  if (lk <= LayoutKind::REFERENCE || lk >= LayoutKind::UNKNOWN) {\n+  if (lk <= LayoutKind::REFERENCE || lk == LayoutKind::NULLABLE_NON_ATOMIC_FLAT || lk >= LayoutKind::UNKNOWN) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -841,2 +841,2 @@\n-  product(bool, UseNullableNonAtomicValueFlattening, false,                 \\\n-           \"Allow the JVM to flatten some strict final non-static fields\")  \\\n+  product(bool, UseNullableNonAtomicValueFlattening, true,                  \\\n+          \"Allow the JVM to flatten some strict final non-static fields\")   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java 8376461 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,0 +176,3 @@\n+\n+    \/\/ TODO 8376254: C1 bailouts if the type of the nullable flat field is uninitialized\n+    static final V2 LOAD_V2 = new V2();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,0 +263,4 @@\n+    \/\/ TODO 8376254: C1 bailouts if the type of the nullable flat field is uninitialized\n+    static final EmptyType2 LOAD_EMPTY_TYPE_2 = new EmptyType2();\n+    static final EmptyContainer2 LOAD_EMPTY_CONTAINER_2 = new EmptyContainer2();\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,3 @@\n+\n+    \/\/ TODO 8376254: C1 bailouts if the type of the nullable flat field is uninitialized\n+    static final V0 LOAD_V0 = new V0(0, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestScalarReplaceFlatFields.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -474,1 +474,2 @@\n-  static value class FieldsHolder {\n+  static class FieldsHolder {\n+    @Strict\n@@ -478,0 +479,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-    FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n@@ -143,1 +143,1 @@\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULL_FREE_ATOMIC_FLAT, f.layoutKind());\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULL_FREE_ATOMIC_FLAT, f0.layoutKind());\n@@ -145,1 +145,1 @@\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f0.layoutKind());\n@@ -148,5 +148,1 @@\n-    if (useNullableAtomicFlat) {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_ATOMIC_FLAT, f1.layoutKind());\n-    } else {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n-    }\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f1.layoutKind());\n@@ -170,2 +166,2 @@\n-    FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n-    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f0.layoutKind());\n@@ -221,5 +217,1 @@\n-    if (useNullableAtomicFlat) {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_ATOMIC_FLAT, f1.layoutKind());\n-    } else {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n-    }\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f1.layoutKind());\n@@ -291,5 +283,1 @@\n-    if (useNullableAtomicFlat) {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_ATOMIC_FLAT, f1.layoutKind());\n-    } else {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n-    }\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f1.layoutKind());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueCompositionTest.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"}]}