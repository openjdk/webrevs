{"files":[{"patch":"@@ -7264,1 +7264,2 @@\n-      \/\/ Also set all oop fields to zero to make the GC happy.\n+      \/\/ Also set all fields to zero since the runtime requires a canonical\n+      \/\/ representation of a flat null.\n@@ -7267,8 +7268,7 @@\n-        if (sig->at(stream.sig_index())._offset == -1 ||\n-            bt == T_OBJECT || bt == T_ARRAY) {\n-          if (toReg->is_stack()) {\n-            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n-            str(zr, Address(sp, st_off));\n-          } else {\n-            mov(toReg->as_Register(), zr);\n-          }\n+        if (toReg->is_stack()) {\n+          int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+          str(zr, Address(sp, st_off));\n+        } else if (toReg->is_FloatRegister()) {\n+          mov(toReg->as_FloatRegister(), T2S, 0);\n+        } else {\n+          mov(toReg->as_Register(), zr);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3058,1 +3058,1 @@\n-  if (vk->has_nullable_atomic_layout()) {\n+  if (vk->supports_nullable_layouts()) {\n@@ -3070,1 +3070,2 @@\n-  \/\/ Return value is null. Zero oop registers to make the GC happy.\n+  \/\/ Return value is null. Zero all registers because the runtime requires a canonical\n+  \/\/ representation of a flat null.\n@@ -3084,3 +3085,6 @@\n-    if (bt == T_OBJECT || bt == T_ARRAY) {\n-      VMRegPair pair = regs->at(j);\n-      VMReg r_1 = pair.first();\n+\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    if (r_1->is_FloatRegister()) {\n+      __ mov(r_1->as_FloatRegister(), Assembler::T2S, 0);\n+    } else {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -6383,1 +6383,2 @@\n-      \/\/ Also set all oop fields to zero to make the GC happy.\n+      \/\/ Also set all fields to zero since the runtime requires a canonical\n+      \/\/ representation of a flat null.\n@@ -6386,8 +6387,7 @@\n-        if (sig->at(stream.sig_index())._offset == -1 ||\n-            bt == T_OBJECT || bt == T_ARRAY) {\n-          if (toReg->is_stack()) {\n-            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n-            movq(Address(rsp, st_off), 0);\n-          } else {\n-            xorq(toReg->as_Register(), toReg->as_Register());\n-          }\n+        if (toReg->is_stack()) {\n+          int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+          movq(Address(rsp, st_off), 0);\n+        } else if (toReg->is_XMMRegister()) {\n+          xorps(toReg->as_XMMRegister(), toReg->as_XMMRegister());\n+        } else {\n+          xorl(toReg->as_Register(), toReg->as_Register());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3851,1 +3851,1 @@\n-  if (vk->has_nullable_atomic_layout()) {\n+  if (vk->supports_nullable_layouts()) {\n@@ -3864,1 +3864,2 @@\n-  \/\/ Return value is null. Zero oop registers to make the GC happy.\n+  \/\/ Return value is null. Zero all registers because the runtime requires a canonical\n+  \/\/ representation of a flat null.\n@@ -3878,4 +3879,7 @@\n-    if (bt == T_OBJECT || bt == T_ARRAY) {\n-      VMRegPair pair = regs->at(j);\n-      VMReg r_1 = pair.first();\n-      __ xorq(r_1->as_Register(), r_1->as_Register());\n+\n+    VMRegPair pair = regs->at(j);\n+    VMReg r_1 = pair.first();\n+    if (r_1->is_XMMRegister()) {\n+      __ xorps(r_1->as_XMMRegister(), r_1->as_XMMRegister());\n+    } else {\n+      __ xorl(r_1->as_Register(), r_1->as_Register());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -140,4 +140,0 @@\n-bool ciInlineKlass::must_be_atomic() const {\n-  GUARDED_VM_ENTRY(return get_InlineKlass()->must_be_atomic();)\n-}\n-\n@@ -159,1 +155,1 @@\n-\/\/ All fields of this object is zero even if they can be null-free. As a result, this object should\n+\/\/ All fields of this object are zero even if they are null-free. As a result, this object should\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-  bool must_be_atomic() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1501,3 +1501,0 @@\n-          if (null_free) {\n-            parm = kit->cast_not_null(parm);\n-          }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -427,1 +427,1 @@\n-  if (lk <= LayoutKind::REFERENCE || lk >= LayoutKind::UNKNOWN) {\n+  if (lk <= LayoutKind::REFERENCE || lk == LayoutKind::NULLABLE_NON_ATOMIC_FLAT || lk >= LayoutKind::UNKNOWN) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -842,1 +842,1 @@\n-           \"Allow the JVM to flatten some strict final non-static fields\")  \\\n+          \"Allow the JVM to flatten some strict final non-static fields\")   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java 8376461 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,0 +176,3 @@\n+\n+    \/\/ TODO 8376254: C1 bailouts if the type of the nullable flat field is uninitialized\n+    static final V2 LOAD_V2 = new V2();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,3 @@\n+\n+    \/\/ TODO 8376254: C1 bailouts if the type of the nullable flat field is uninitialized\n+    static final V0 LOAD_V0 = new V0(0, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestScalarReplaceFlatFields.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -474,1 +474,2 @@\n-  static value class FieldsHolder {\n+  static class FieldsHolder {\n+    @Strict\n@@ -478,0 +479,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-    FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n@@ -143,1 +143,1 @@\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULL_FREE_ATOMIC_FLAT, f.layoutKind());\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULL_FREE_ATOMIC_FLAT, f0.layoutKind());\n@@ -145,1 +145,1 @@\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f0.layoutKind());\n@@ -148,5 +148,1 @@\n-    if (useNullableAtomicFlat) {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_ATOMIC_FLAT, f1.layoutKind());\n-    } else {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n-    }\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f1.layoutKind());\n@@ -170,2 +166,2 @@\n-    FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n-    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f0.layoutKind());\n@@ -221,5 +217,1 @@\n-    if (useNullableAtomicFlat) {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_ATOMIC_FLAT, f1.layoutKind());\n-    } else {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n-    }\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f1.layoutKind());\n@@ -291,5 +283,1 @@\n-    if (useNullableAtomicFlat) {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_ATOMIC_FLAT, f1.layoutKind());\n-    } else {\n-      Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f1.layoutKind());\n-    }\n+    Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f1.layoutKind());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueCompositionTest.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"}]}