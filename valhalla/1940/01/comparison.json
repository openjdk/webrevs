{"files":[{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8351362\n+ * @summary Unit Test for StrictProcessor super rewrite\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @compile StrictProcessorSuperTest.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor --deferSuperCall\n+ *             StrictProcessorSuperTest$Rec StrictProcessorSuperTest$Exp\n+ *             StrictProcessorSuperTest$Inner\n+ * @run junit StrictProcessorSuperTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CompoundElement;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Opcode;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.helpers.StrictInit;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StrictProcessorSuperTest {\n+    static Stream<Class<?>> testClasses() {\n+        return Stream.of(Rec.class, Exp.class, Inner.class);\n+    }\n+\n+    static Stream<ClassModel> testClassModels() {\n+        return testClasses().map(cls -> {\n+            try (var in = StrictProcessorSuperTest.class.getResourceAsStream(\"\/\" + cls.getName() + \".class\")) {\n+                return ClassFile.of().parse(in.readAllBytes());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n+    }\n+\n+    @MethodSource(\"testClasses\")\n+    @ParameterizedTest\n+    void testReflectRewrittenRecord(Class<?> cls) throws Throwable {\n+        for (var field : cls.getDeclaredFields()) {\n+            if (Modifier.isStatic(field.getModifiers()) || field.isSynthetic())\n+                continue;\n+            assertEquals(ACC_PRIVATE | ACC_STRICT_INIT | ACC_FINAL, field.getModifiers(), () -> \"For field: \" + field.getName());\n+        }\n+    }\n+\n+    @MethodSource(\"testClassModels\")\n+    @ParameterizedTest\n+    void testRewrittenStrictAccessInClassFile(ClassModel cm) throws Throwable {\n+        for (var f : cm.fields()) {\n+            if (f.flags().has(AccessFlag.STATIC) || f.flags().has(AccessFlag.SYNTHETIC))\n+                continue;\n+            assertEquals(ACC_PRIVATE | ACC_STRICT_INIT | ACC_FINAL, f.flags().flagsMask(), () -> \"Field \" + f);\n+        }\n+    }\n+\n+    @MethodSource(\"testClassModels\")\n+    @ParameterizedTest\n+    void testRewrittenCtorBytecode(ClassModel cm) throws Throwable {\n+        var ctor = cm.methods().stream().filter(m -> m.methodName().equalsString(INIT_NAME)).findFirst().orElseThrow();\n+        var insts = new ArrayList<Instruction>();\n+        ctor.findAttribute(Attributes.code()).orElseThrow().forEach(ce -> {\n+            if (ce instanceof Instruction inst) {\n+                insts.add(inst);\n+            }\n+        });\n+        assertSame(Opcode.RETURN, insts.getLast().opcode());\n+        assertSame(Opcode.INVOKESPECIAL, insts.get(insts.size() - 2).opcode());\n+    }\n+\n+    record Rec(@StrictInit int a, @StrictInit long b) {\n+        static final String NOISE = \"noise\";\n+    }\n+\n+    static class Exp {\n+        private @StrictInit final int a;\n+        private @StrictInit final long b;\n+\n+        Exp(int a, long b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    class Inner {\n+        private @StrictInit final int a;\n+        private @StrictInit final long b;\n+\n+        Inner(int a, long b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return a + \" \" + StrictProcessorSuperTest.this + \" \" + b;\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictProcessorSuperTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8351362\n+ * @summary Unit Test for StrictProcessor\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @build StrictProcessorTest\n+ * @run driver jdk.test.lib.helpers.StrictProcessor StrictProcessorTest$StrictTarget\n+ * @run junit StrictProcessorTest\n+ *\/\n+\n+import jdk.test.lib.helpers.StrictInit;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class StrictProcessorTest {\n+    @Test\n+    void testReflectMyself() throws Throwable {\n+        for (var field : StrictTarget.class.getDeclaredFields()) {\n+            assertEquals(ACC_STRICT_INIT | ACC_FINAL, field.getModifiers(), () -> field.getName());\n+        }\n+    }\n+\n+    static final class StrictTarget {\n+        @StrictInit\n+        final int a;\n+        @StrictInit\n+        final Object b;\n+\n+        StrictTarget() {\n+            this.a = 1;\n+            this.b = 2392352234L;\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictProcessorTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.helpers;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Annotated field should be marked ACC_STRICT_INIT.\n+ *\/\n+@Target(ElementType.FIELD)\n+@Retention(RetentionPolicy.CLASS)\n+public @interface StrictInit {\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/helpers\/StrictInit.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.helpers;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+\n+\/**\n+ * Modify a class file to include strict init field access flag.\n+ *\/\n+public final class StrictProcessor {\n+    public static final String TEST_CLASSES = System.getProperty(\"test.classes\", \"\").trim();\n+    private static final ClassDesc CD_StrictInit = ClassDesc.of(\"jdk.test.lib.helpers.StrictInit\");\n+    \/\/ NR will stay in jdk.internal for now until we expose as a more formal feature\n+    private static final ClassDesc CD_NullRestricted = ClassDesc.of(\"jdk.internal.vm.annotation.NullRestricted\");\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean deferSuperCall = false;\n+        int i;\n+        for (i = 0; i < args.length; i++) {\n+            String opt = args[i];\n+            if (!opt.startsWith(\"--\")) {\n+                break;\n+            }\n+            switch (opt) {\n+                case \"--deferSuperCall\" -> deferSuperCall = true;\n+                default -> throw new IllegalArgumentException(\"Unknown option %s\".formatted(opt));\n+            }\n+        }\n+\n+        for (; i < args.length; i++) {\n+            String name = args[i];\n+            byte[] bytes = findClassBytes(name);\n+            bytes = deferSuperCall ? fixSuperAndPatchStrictInit(bytes) : patchStrictInit(bytes);\n+            ClassFileInstaller.writeClassToDisk(name, bytes, TEST_CLASSES);\n+        }\n+    }\n+\n+    static byte[] findClassBytes(String className) {\n+        ClassLoader cl = StrictProcessor.class.getClassLoader();\n+\n+        String pathName = className.replace('.', '\/').concat(\".class\");\n+\n+        try (InputStream is = cl.getResourceAsStream(pathName)) {\n+            if (is == null) {\n+                throw new RuntimeException(\"Failed to find \" + pathName);\n+            }\n+            return is.readAllBytes();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    public static byte[] fixSuperAndPatchStrictInit(byte[] rawBytes) {\n+        var cm = ClassFile.of().parse(rawBytes);\n+        record FieldKey(Utf8Entry name, Utf8Entry type) {}\n+        Set<FieldKey> strictInstances = new HashSet<>();\n+        for (var f : cm.fields()) {\n+            if (f.flags().has(AccessFlag.STATIC))\n+                continue;\n+            var riaa = f.findAttribute(Attributes.runtimeInvisibleAnnotations());\n+            if (riaa.isPresent()) {\n+                for (var anno : riaa.get().annotations()) {\n+                    var descString = anno.className();\n+                    if (descString.equalsString(CD_StrictInit.descriptorString())) {\n+                        strictInstances.add(new FieldKey(f.fieldName(), f.fieldType()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        var thisClass = cm.thisClass();\n+        var superName = cm.superclass().orElseThrow().name();\n+\n+        var rewritten = ClassFile.of().transformClass(cm, (clb, cle) -> {\n+            cond:\n+            if (cle instanceof MethodModel mm\n+                    && mm.methodName().equalsString(INIT_NAME)) {\n+                var code = mm.findAttribute(Attributes.code()).orElseThrow();\n+                var elements = code.elementList();\n+                int len = elements.size();\n+                int superCallPos = -1;\n+                int returnPos = -1;\n+                boolean deferSuperCall = false;\n+                for (int i = 0; i < len; i++) {\n+                    var e = elements.get(i);\n+                    if (superCallPos == -1) {\n+                        if (e instanceof InvokeInstruction inv &&\n+                                inv.opcode() == Opcode.INVOKESPECIAL &&\n+                                inv.method().name().equalsString(INIT_NAME) &&\n+                                inv.method().type().equalsString(\"()V\") &&\n+                                inv.owner().name().equals(superName)) {\n+                            \/\/ Assume we are calling on uninitializedThis...\n+                            superCallPos = i;\n+                        }\n+                    } else if (!deferSuperCall) {\n+                        if (e instanceof FieldInstruction ins &&\n+                                ins.opcode() == Opcode.PUTFIELD &&\n+                                ins.owner().equals(thisClass) &&\n+                                strictInstances.contains(new FieldKey(ins.name(), ins.type()))) {\n+                            deferSuperCall = true;\n+                        }\n+                    }\n+                    if (e instanceof ReturnInstruction inst && inst.opcode() == Opcode.RETURN) {\n+                        if (returnPos != -1) {\n+                            throw new IllegalArgumentException(\"Control flow too complex\");\n+                        } else {\n+                            returnPos = i;\n+                        }\n+                    }\n+                }\n+                if (elements.reversed().stream()\n+                        .<Instruction>mapMulti((e, sink) -> {\n+                            if (e instanceof Instruction i) {\n+                                sink.accept(i);\n+                            }\n+                        })\n+                        .findFirst()\n+                        .orElseThrow()\n+                        .opcode() != Opcode.RETURN) {\n+                    throw new IllegalArgumentException(\"Control flow too complex\");\n+                }\n+                if (!deferSuperCall) {\n+                    break cond;\n+                }\n+                var suppliedElements = new ArrayList<>(elements);\n+                var foundLoad = suppliedElements.remove(superCallPos - 1);\n+                var foundSuperCall = suppliedElements.remove(superCallPos - 1);\n+                var foundReturnInst = suppliedElements.remove(returnPos - 2);\n+                suppliedElements.add(foundLoad);\n+                suppliedElements.add(foundSuperCall);\n+                suppliedElements.add(foundReturnInst);\n+                clb.withMethod(INIT_NAME, mm.methodTypeSymbol(), mm.flags().flagsMask(), mb -> mb\n+                        .transform(mm, MethodTransform.dropping(ce -> ce instanceof CodeModel))\n+                        .withCode(suppliedElements::forEach));\n+                return;\n+            }\n+            clb.with(cle);\n+        });\n+\n+        return patchStrictInit(rewritten);\n+    }\n+\n+    public static byte[] patchStrictInit(byte[] rawBytes) {\n+        var cm = ClassFile.of().parse(rawBytes);\n+\n+        var classTransform = ClassTransform.transformingFields(FieldTransform.ofStateful(() -> new FieldTransform() {\n+            int oldAccessFlags;\n+            boolean nullRestricted;\n+            boolean strictInit;\n+\n+            @Override\n+            public void accept(FieldBuilder builder, FieldElement element) {\n+                if (element instanceof AccessFlags af) {\n+                    oldAccessFlags = af.flagsMask();\n+                    return;\n+                }\n+                builder.with(element);\n+                switch (element) {\n+                    case RuntimeInvisibleAnnotationsAttribute riaa -> {\n+                        for (var anno : riaa.annotations()) {\n+                            var descString = anno.className();\n+                            if (descString.equalsString(CD_StrictInit.descriptorString())) {\n+                                strictInit = true;\n+                            }\n+                        }\n+                    }\n+                    case RuntimeVisibleAnnotationsAttribute rvaa -> {\n+                        for (var anno : rvaa.annotations()) {\n+                            var descString = anno.className();\n+                            if (descString.equalsString(CD_NullRestricted.descriptorString())) {\n+                                nullRestricted = true;\n+                            }\n+                        }\n+                    }\n+                    default -> {}\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(FieldBuilder builder) {\n+                if (strictInit) {\n+                    oldAccessFlags |= ACC_STRICT_INIT;\n+                }\n+                builder.withFlags(oldAccessFlags);\n+                assert !nullRestricted || strictInit : cm.thisClass().asInternalName();\n+            }\n+        }));\n+\n+        if (cm.minorVersion() != PREVIEW_MINOR_VERSION) {\n+            \/\/ We need to patch minor version and InnerClasses\n+            classTransform = classTransform.andThen((clb, cle) -> {\n+                if (cle instanceof InnerClassesAttribute ica) {\n+                    \/\/ VM needs identity bit fixed\n+                    var fixedInfos = ica.classes().stream().map(info -> InnerClassInfo.of(info.innerClass(), info.outerClass(), info.innerName(), info.flagsMask() | ACC_IDENTITY)).toList();\n+                    clb.with(InnerClassesAttribute.of(fixedInfos));\n+                } else if (cle instanceof ClassFileVersion cfv) {\n+                    clb.withVersion(cfv.majorVersion(), PREVIEW_MINOR_VERSION);\n+                } else {\n+                    clb.with(cle);\n+                }\n+            });\n+        }\n+\n+        return ClassFile.of().transformClass(cm, classTransform);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/helpers\/StrictProcessor.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"}]}