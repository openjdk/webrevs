{"files":[{"patch":"@@ -2174,6 +2174,1 @@\n-    Label skip;\n-    __ cmp_klass(j_rarg0, rscratch2, rscratch1);\n-    __ br(Assembler::EQ, skip);\n-      __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n-    __ bind(skip);\n-\n+    __ ic_check(1);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1455,7 +1455,1 @@\n-    if (UseCompressedClassPointers) {\n-      __ load_klass(rscratch1, j_rarg0, rscratch2);\n-      __ cmpptr(rax, rscratch1);\n-    } else {\n-      __ cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));\n-    }\n-    __ jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));\n+    __ ic_check(1);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3517,7 +3517,0 @@\n-      if (!target->is_static()) {\n-        \/\/ The UEP of an nmethod ensures that the VEP is padded. However, the padding of the UEP is placed\n-        \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n-        \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately.\n-        \/\/ TODO 8325106 Check this\n-        \/\/ _code_offsets.set_value(CodeOffsets::Entry, _first_block_size - MacroAssembler::ic_check_size());\n-      }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}