{"files":[{"patch":"@@ -804,0 +804,45 @@\n+\/\/ See comment in MacroAssembler::remove_frame\n+frame::CompiledFramePointers frame::compiled_frame_details() const {\n+  \/\/ we cannot rely upon the last fp having been saved to the thread\n+  \/\/ in C2 code but it will have been pushed onto the stack. so we\n+  \/\/ have to find it relative to the unextended sp\n+\n+  assert(_cb->frame_size() > 0, \"must have non-zero frame size\");\n+\n+  \/\/ if need stack repair: the bottom of the fake frame, under LR #2\n+  \/\/ else the bottom of the frame\n+  intptr_t* l_sender_sp = (!PreserveFramePointer || _sp_is_trusted)\n+      ? unextended_sp() + _cb->frame_size()\n+      : sender_sp();\n+\n+#ifdef ASSERT\n+  \/\/ LR #2\n+  address sender_pc_copy = pauth_strip_verifiable((address) *(l_sender_sp - frame::return_addr_offset));\n+#endif\n+\n+  assert(!_sp_is_trusted || l_sender_sp == real_fp(), \"\");\n+\n+  \/\/ the actual bottom of the frame. This actually changes something if the frame needs stack repair\n+  l_sender_sp = repair_sender_sp(l_sender_sp, (intptr_t**)(l_sender_sp - frame::sender_sp_offset));\n+\n+  \/\/ From the sender's sp, we can locate the real saved lr (x30) and rfp (x29): they are\n+  \/\/ immediately above, no matter if the stack was extended or not\n+  CompiledFramePointers cfp;\n+  cfp.sender_sp = l_sender_sp;\n+  cfp.saved_fp_addr = (intptr_t**)(l_sender_sp - frame::sender_sp_offset);\n+  cfp.sender_pc_addr = (address*)(l_sender_sp - frame::return_addr_offset);\n+\n+#ifdef ASSERT\n+  \/\/ when the stack was extended (so LR #1 and LR #2 are distinct) and LR #1 was patched\n+  if (*cfp.sender_pc_addr != sender_pc_copy) {\n+    \/\/ When extending the stack in the callee method entry to make room for unpacking of value\n+    \/\/ type args, we keep a copy of the sender pc at the expected location in the callee frame.\n+    \/\/ If the sender pc is patched due to deoptimization, the copy is not consistent anymore.\n+    nmethod* nm = CodeCache::find_blob(*cfp.sender_pc_addr)->as_nmethod();\n+    assert(*cfp.sender_pc_addr == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+  }\n+#endif\n+\n+  return cfp;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -156,0 +156,6 @@\n+  struct CompiledFramePointers {\n+    intptr_t* sender_sp;       \/\/ The top of the stack of the sender\n+    intptr_t** saved_fp_addr;  \/\/ Where rfp (x29) is saved on the stack (FP #1 in remove_frame's comment)\n+    address* sender_pc_addr;   \/\/ Where lr (x30) is saved on the stack (LR #1)\n+  };\n+  CompiledFramePointers compiled_frame_details() const;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -447,17 +447,1 @@\n-  \/\/ we cannot rely upon the last fp having been saved to the thread\n-  \/\/ in C2 code but it will have been pushed onto the stack. so we\n-  \/\/ have to find it relative to the unextended sp\n-\n-  assert(_cb->frame_size() > 0, \"must have non-zero frame size\");\n-  intptr_t* l_sender_sp = (!PreserveFramePointer || _sp_is_trusted) ? unextended_sp() + _cb->frame_size()\n-                                                                    : sender_sp();\n-#ifdef ASSERT\n-   address sender_pc_copy = pauth_strip_verifiable((address) *(l_sender_sp-1));\n-#endif\n-\n-  assert(!_sp_is_trusted || l_sender_sp == real_fp(), \"\");\n-\n-  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp - frame::sender_sp_offset);\n-\n-  \/\/ Repair the sender sp if the frame has been extended\n-  l_sender_sp = repair_sender_sp(l_sender_sp, saved_fp_addr);\n+  CompiledFramePointers cfp = compiled_frame_details();\n@@ -468,11 +452,1 @@\n-  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp - 1));\n-\n-#ifdef ASSERT\n-  if (sender_pc != sender_pc_copy) {\n-    \/\/ When extending the stack in the callee method entry to make room for unpacking of value\n-    \/\/ type args, we keep a copy of the sender pc at the expected location in the callee frame.\n-    \/\/ If the sender pc is patched due to deoptimization, the copy is not consistent anymore.\n-    nmethod* nm = CodeCache::find_blob(sender_pc)->as_nmethod();\n-    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n-  }\n-#endif\n+  address sender_pc = pauth_strip_verifiable(*cfp.sender_pc_addr);\n@@ -511,1 +485,1 @@\n-    update_map_with_saved_link(map, saved_fp_addr);\n+    update_map_with_saved_link(map, cfp.saved_fp_addr);\n@@ -518,1 +492,1 @@\n-      return Continuation::continuation_bottom_sender(map->thread(), *this, l_sender_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, cfp.sender_sp);\n@@ -522,2 +496,2 @@\n-  intptr_t* unextended_sp = l_sender_sp;\n-  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  intptr_t* unextended_sp = cfp.sender_sp;\n+  return frame(cfp.sender_sp, unextended_sp, *cfp.saved_fp_addr, sender_pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -6064,2 +6064,5 @@\n-    \/\/ oop, the GC will be aware only of FP #2 as the spilled location of x29 and\n-    \/\/ will fix only this one.\n+    \/\/ oop, the GC will be aware only of FP #1 as the spilled location of x29 and\n+    \/\/ will fix only this one. Overall, FP\/LR #2 are not reliable and are simply\n+    \/\/ needed to add space between the extension space and the locals, as there\n+    \/\/ would be between the real arguments and the locals if we don't need to\n+    \/\/ do unpacking.\n@@ -6067,1 +6070,1 @@\n-    \/\/ When restoring, one must then load FP #2 into x29, and LR #1 into x30,\n+    \/\/ When restoring, one must then load FP #1 into x29, and LR #1 into x30,\n@@ -6073,1 +6076,4 @@\n-    \/\/ find LR #1. FP #2 is always located just after sp_inc.\n+    \/\/ find FP\/LR #1. This size is expressed in bytes. Be careful when using it\n+    \/\/ from C++ in pointer arithmetic; you might need to divide it by wordSize.\n+    \/\/\n+    \/\/ TODO 8371993 store fake values instead of LR\/FP#2\n@@ -6078,1 +6084,0 @@\n-    ldr(rfp, Address(sp, sp_inc_offset + wordSize));\n@@ -6080,2 +6085,1 @@\n-    ldr(lr, Address(sp, wordSize));\n-    add(sp, sp, 2 * wordSize);\n+    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -844,0 +844,3 @@\n+jdk\/internal\/vm\/Continuation\/Fuzz.java#default 8370177 generic-aarch64\n+jdk\/internal\/vm\/Continuation\/Fuzz.java#preserve-fp 8370177 generic-aarch64\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}