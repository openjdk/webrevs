{"files":[{"patch":"@@ -3507,2 +3507,10 @@\n-        \/\/ optimization: new Outer() can never be null; skip null check\n-        if (arg.getTag() == NEWCLASS)\n+        \/* optimization:\n+         * - non null literals can't be null\n+         * - new Class() can never be null; skip null check\n+         * - if we already applied a null check operator skip too\n+         * - if arg happens to be a strict type cast skip it too\n+         *\/\n+        if (arg.hasTag(LITERAL) && !arg.type.hasTag(TypeTag.BOT) ||\n+                arg.getTag() == NEWCLASS ||\n+                arg.hasTag(NULLRESTRICTEDCHK) || arg.hasTag(NULLCHK) ||\n+                arg instanceof JCTypeCast typeCast && typeCast.strict)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+        boolean generateNullCheck = tree.strict;\n@@ -219,1 +220,1 @@\n-            tree.strict = false;\n+            generateNullCheck = false;\n@@ -222,1 +223,1 @@\n-        if (tree.strict) {\n+        if (generateNullCheck) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -912,2 +912,2 @@\n-    public void testMultipleCasts(Path base) throws Exception {\n-        Path out = testHelper(base,\n+    public void testTypeCasts(Path base) throws Exception {\n+        String[] testCases = new String[] {\n@@ -922,6 +922,34 @@\n-                true, NullPointerException.class, PREVIEW);\n-        List<CodeElement> instructions = readInstructions(out.resolve(\"Test.class\"), \"main\");\n-        int numberOfNullChecks = 0;\n-        for (CodeElement ce : instructions) {\n-            if (ce.toString().equals(nullCheckInvocation)) {\n-                numberOfNullChecks++;\n+                \"\"\"\n+                import java.io.*;\n+                class Test {\n+                    public static void main(String... args) {\n+                        Object s = null;\n+                        Object o = (String!)(CharSequence!)(Serializable!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class OtherClass {\n+                        Object! m() {\n+                            return \"\";\n+                        }\n+                    }\n+                    public static void main(String... args) {\n+                        OtherClass oc = new Test().new OtherClass();\n+                        String! s = (String!)oc.m();\n+                    }\n+                }\n+                \"\"\"\n+        };\n+        for (String testCase : testCases) {\n+            Path out = compile(base, testCase, \"Test\", null, PREVIEW);\n+            List<CodeElement> instructions = readInstructions(out.resolve(\"Test.class\"), \"main\");\n+            int numberOfNullChecks = 0;\n+            for (CodeElement ce : instructions) {\n+                if (ce.toString().equals(nullCheckInvocation)) {\n+                    numberOfNullChecks++;\n+                }\n+            }\n+            if (numberOfNullChecks != 1) {\n+                throw new AssertionError(\"was expecting only one invocation to Checks::nullCheck\");\n@@ -929,3 +957,0 @@\n-        }\n-        if (numberOfNullChecks != 1) {\n-            throw new AssertionError(\"was expecting only one invocation to Checks::nullCheck\");\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"}]}