{"files":[{"patch":"@@ -3507,2 +3507,10 @@\n-        \/\/ optimization: new Outer() can never be null; skip null check\n-        if (arg.getTag() == NEWCLASS)\n+        \/* optimization:\n+         * - non null literals can't be null\n+         * - new Class() can never be null; skip null check\n+         * - if we already applied a null check operator skip too\n+         * - if arg happens to be a strict type cast skip it too\n+         *\/\n+        if (arg.hasTag(LITERAL) && !arg.type.hasTag(TypeTag.BOT) ||\n+                arg.getTag() == NEWCLASS ||\n+                arg.hasTag(NULLRESTRICTEDCHK) || arg.hasTag(NULLCHK) ||\n+                arg instanceof JCTypeCast typeCast && typeCast.strict)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n@@ -131,1 +132,0 @@\n-    ClassSymbol currentClass;\n@@ -138,1 +138,0 @@\n-                this.currentClass = (ClassSymbol) TreeInfo.symbolFor(cdef);\n@@ -144,1 +143,0 @@\n-                this.currentClass = null;\n@@ -206,1 +204,1 @@\n-                    sym.owner != currentClass) {\n+                    !isInThisSameCompUnit(sym)) {\n@@ -208,1 +206,1 @@\n-                 * class\n+                 * compilation unit\n@@ -214,0 +212,5 @@\n+        private boolean isInThisSameCompUnit(Symbol sym) {\n+            return env.toplevel.getTypeDecls().stream()\n+                    .anyMatch(tree -> TreeInfo.symbolFor(tree) == sym.outermostClass());\n+        }\n+\n@@ -215,0 +218,4 @@\n+        boolean generateNullCheck = tree.strict;\n+        if (tree.expr instanceof JCTypeCast otherTypeCast && tree.strict && otherTypeCast.strict) {\n+            generateNullCheck = false;\n+        }\n@@ -216,1 +223,1 @@\n-        if (tree.strict) {\n+        if (generateNullCheck) {\n@@ -259,2 +266,6 @@\n-        Symbol.MethodSymbol msym = (Symbol.MethodSymbol) TreeInfo.symbolFor(tree.meth);\n-        if (useSiteNullChecks.generateChecksForMethods) {\n+        MethodSymbol msym = (MethodSymbol) TreeInfo.symbolFor(tree.meth);\n+        boolean canBeOverriden = (msym.flags_field & (Flags.PRIVATE | Flags.STATIC | Flags.FINAL)) == 0 &&\n+                !msym.owner.isFinal();\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                hasNonNullArgs(msym) &&\n+                canBeOverriden) {\n@@ -265,4 +276,4 @@\n-        if (useSiteNullChecks.generateChecksForMethods) {\n-            if (types.isNonNullable(msym.type.asMethodType().restype)) {\n-                result = attr.makeNullCheck(tree, true);\n-            }\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                types.isNonNullable(msym.type.asMethodType().restype) &&\n+                canBeOverriden) {\n+            result = attr.makeNullCheck(tree, true);\n@@ -274,2 +285,4 @@\n-        if (useSiteNullChecks.generateChecksForMethods) {\n-            tree.args = newArgs((Symbol.MethodSymbol) tree.constructor, tree.args);\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                hasNonNullArgs((MethodSymbol) tree.constructor) &&\n+                !isInThisSameCompUnit(tree.constructor)) {\n+            tree.args = newArgs((MethodSymbol) tree.constructor, tree.args);\n@@ -281,1 +294,5 @@\n-    private List<JCExpression> newArgs(Symbol.MethodSymbol msym, List<JCExpression> actualArgs) {\n+    private boolean hasNonNullArgs(MethodSymbol msym) {\n+        return msym.type.asMethodType().argtypes.stream().anyMatch(argType -> types.isNonNullable(argType));\n+    }\n+\n+    private List<JCExpression> newArgs(MethodSymbol msym, List<JCExpression> actualArgs) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":32,"deletions":15,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n@@ -44,0 +46,2 @@\n+import com.sun.tools.javac.util.Assert;\n+\n@@ -343,1 +347,3 @@\n-    private void testHelper(Path base,\n+    \/* returns the path to the output folder in case the caller wants to analyze the produced class files\n+     *\/\n+    private Path testHelper(Path base,\n@@ -347,1 +353,1 @@\n-        testHelper(base, testCode, shouldFail, expectedError, PREVIEW);\n+        return testHelper(base, testCode, shouldFail, expectedError, PREVIEW);\n@@ -350,1 +356,3 @@\n-    private void testHelper(Path base,\n+    \/* returns the path to the output folder in case the caller wants to analyze the produced class files\n+     *\/\n+    private Path testHelper(Path base,\n@@ -392,0 +400,1 @@\n+        return out;\n@@ -455,0 +464,3 @@\n+    static final String nullCheckInvocation =\n+            \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\";\n+\n@@ -457,1 +469,1 @@\n-        String[] testCases = new String[] {\n+        String src =\n@@ -472,1 +484,18 @@\n-                \"\"\",\n+                \"\"\";\n+        String expectedInstSequence =\n+                \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\" +\n+                        \"Invoke[OP=INVOKEVIRTUAL, m=Test$Inner.m(Ljava\/lang\/Object;)Ljava\/lang\/Object;]\";\n+        Path out;\n+        for (String[] options : new String[][] {PREVIEW, USE_SITE_CHECKS_FOR_METHODS_ONLY, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS}) {\n+            out = testHelper(base, src, true, NullPointerException.class, options);\n+            if (!checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+                throw new AssertionError(\"was expecting a null check before Inner::m invocation\");\n+            }\n+        }\n+        out = testHelper(base, src, false, null, NO_USE_SITE_CHECKS);\n+        if (checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+            throw new AssertionError(\"was not expecting a null check before Inner::m invocation\");\n+        }\n+\n+        \/\/ null checks in user site for returns\n+        src =\n@@ -487,1 +516,22 @@\n-                \"\"\",\n+                \"\"\";\n+        expectedInstSequence =\n+                \"Invoke[OP=INVOKEVIRTUAL, m=Test$Inner.m(Ljava\/lang\/Object;)Ljava\/lang\/Object;]\" +\n+                        \"UnboundStackInstruction[op=DUP]\" +\n+                        \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\";\n+        for (String[] options : new String[][] {PREVIEW, USE_SITE_CHECKS_FOR_METHODS_ONLY, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS}) {\n+            out = testHelper(base, src, true, NullPointerException.class, options);\n+            if (!checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+                List<CodeElement> foundSequence = readInstructions(out.resolve(\"Test.class\"), \"main\");\n+                String found = \"\";\n+                for (CodeElement ce : foundSequence) {\n+                    found += ce.toString() + \"\\n\";\n+                }\n+                throw new AssertionError(\"was expecting a null check after Inner::m invocation, found: \\n\" + found);\n+            }\n+        }\n+        out = testHelper(base, src, false, null, NO_USE_SITE_CHECKS);\n+        if (checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+            throw new AssertionError(\"was not expecting a null check after Inner::m invocation\");\n+        }\n+\n+        String[] testCases2 = new String[] {\n@@ -491,5 +541,1 @@\n-                        Object m(Object! arg, Object... args) { return null; }\n-                    }\n-                    class Inner2 extends Inner {\n-                        @Override\n-                        String m(Object arg, Object... args) { return null; }\n+                        private Object m(Object! arg) { return null; }\n@@ -498,2 +544,2 @@\n-                        Inner inner = new Test().new Inner2();\n-                        inner.m(null, null);\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n@@ -506,1 +552,1 @@\n-                        Object! m(Object arg, Object... args) { return \"\"; }\n+                        final Object m(Object! arg) { return null; }\n@@ -508,3 +554,10 @@\n-                    class Inner2 extends Inner {\n-                        @Override\n-                        String m(Object arg, Object... args) { return null; }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static class Inner {\n+                        static Object m(Object! arg) { return null; }\n@@ -513,2 +566,12 @@\n-                        Inner inner = new Test().new Inner2();\n-                        inner.m(null, null);\n+                        Inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    final class Inner {\n+                        Object m(Object! arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n@@ -519,5 +582,5 @@\n-        for (String code : testCases) {\n-            testHelper(base, code, true, NullPointerException.class);\n-            testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_ONLY);\n-            testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS);\n-            testHelper(base, code, false, null, NO_USE_SITE_CHECKS);\n+        for (String code : testCases2) {\n+            out = testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS);\n+            if (checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", nullCheckInvocation)) {\n+                throw new AssertionError(\"an invocation to Checks::nullCheck was not expected\");\n+            }\n@@ -527,0 +590,23 @@\n+    private boolean checkInstructionsSequence(Path path, String methodName, String sequence) throws Exception {\n+        List<CodeElement> instructions = readInstructions(path, methodName);\n+        String foundSequence = \"\";\n+        for (CodeElement ce : instructions) {\n+            foundSequence += ce;\n+        }\n+        return foundSequence.contains(sequence);\n+    }\n+\n+    private List<CodeElement> readInstructions(Path path, String methodName) throws Exception {\n+        ClassModel classFile = ClassFile.of().parse(path);\n+        List<CodeElement> result = new ArrayList<>();\n+        for (MethodModel method: classFile.methods()) {\n+            if (method.methodName().stringValue().equals(methodName)) {\n+                CodeAttribute codeAttr = method.findAttribute(Attributes.code()).orElse(null);\n+                for (CodeElement ce : codeAttr.elementList()) {\n+                    result.add(ce);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -676,2 +762,3 @@\n-    public void testUseSideChecksForFieldsSepCompilation(Path base) throws Exception {\n-        testUseSiteForFieldsSeparateCompilationHelper(base,\n+    public void testUseSideChecksForFields(Path base) throws Exception {\n+        \/\/ separate compilation\n+        String ASrc1 =\n@@ -687,1 +774,2 @@\n-                \"\"\",\n+                \"\"\";\n+        String ASrc2 =\n@@ -697,1 +785,2 @@\n-                \"\"\",\n+                \"\"\";\n+        String testSrc =\n@@ -706,1 +795,23 @@\n-                \"\"\");\n+                \"\"\";\n+        Path out;\n+        String sequenceWithNullCheck =\n+                \"Field[OP=GETFIELD, field=pkg\/A.a:Ljava\/lang\/String;]\" +\n+                \"UnboundStackInstruction[op=DUP]\" +\n+                \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\" +\n+                        \"Invoke[OP=INVOKEVIRTUAL, m=java\/lang\/String.toString()Ljava\/lang\/String;]\";\n+        for (String[] options : new String[][] {USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS, PREVIEW}) {\n+            out = testUseSiteForFieldsSeparateCompilationHelper(base, ASrc1, ASrc2, testSrc, true, options);\n+            if (!checkInstructionsSequence(out.resolve(\"pkg\").resolve(\"Test.class\"), \"main\", sequenceWithNullCheck)) {\n+                throw new AssertionError(\"was expecting a null check before String::toString invocation\");\n+            }\n+        }\n+\n+        String sequenceWithoutNullCheck =\n+                \"Field[OP=GETFIELD, field=pkg\/A.a:Ljava\/lang\/String;]\" +\n+                        \"Invoke[OP=INVOKEVIRTUAL, m=java\/lang\/String.toString()Ljava\/lang\/String;]\";\n+        for (String[] options : new String[][] {USE_SITE_CHECKS_FOR_METHODS_ONLY, NO_USE_SITE_CHECKS}) {\n+            out = testUseSiteForFieldsSeparateCompilationHelper(base, ASrc1, ASrc2, testSrc, false, options);\n+            if (!checkInstructionsSequence(out.resolve(\"pkg\").resolve(\"Test.class\"), \"main\", sequenceWithoutNullCheck)) {\n+                throw new AssertionError(\"was expecting a null check before String::toString invocation\");\n+            }\n+        }\n@@ -709,1 +820,1 @@\n-    private void testUseSiteForFieldsSeparateCompilationHelper(\n+    private Path testUseSiteForFieldsSeparateCompilationHelper(\n@@ -713,1 +824,3 @@\n-            String testCode) throws Exception {\n+            String testCode,\n+            boolean shouldFailDueToNullCheck,\n+            String[] options) throws Exception {\n@@ -728,1 +841,1 @@\n-                .options(USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS) \/\/ equivalent to just using PREVIEW options\n+                .options(options)\n@@ -732,1 +845,0 @@\n-        \/\/ let's execute to check that it's producing the NPE\n@@ -750,1 +862,1 @@\n-                .options(USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS) \/\/ equivalent to just using PREVIEW options\n+                .options(options)\n@@ -764,3 +876,81 @@\n-        if (!output.contains(\"java.lang.NullPointerException\") &&\n-                !output.contains(\"java.base\/java.lang.runtime.Checks.nullCheck\")) {\n-            throw new AssertionError(\"unexpected output: \" + output);\n+        if (shouldFailDueToNullCheck) {\n+            if (!output.contains(\"java.lang.NullPointerException\") &&\n+                    !output.contains(\"java.base\/java.lang.runtime.Checks.nullCheck\")) {\n+                throw new AssertionError(\"unexpected output: \" + output);\n+            }\n+        } else {\n+            if (!output.startsWith(\"Exception in thread \\\"main\\\" java.lang.NullPointerException: Cannot invoke \\\"String.toString()\\\" because \\\"<local1>.a\\\" is null\")) {\n+                throw new AssertionError(\"unexpected output: \" + output);\n+            }\n+        }\n+        return out;\n+    }\n+\n+    private Path compile(Path base,\n+                         String code,\n+                         String className,\n+                         String pakageName,\n+                         String[] options) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = pakageName != null ? src.resolve(\"pakageName\") : src;\n+        Path ASrc = pkg.resolve(className);\n+\n+        tb.writeJavaFiles(ASrc, code);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(options) \/\/ equivalent to just using PREVIEW options\n+                .files(findJavaFiles(pkg))\n+                .run();\n+        return out;\n+    }\n+\n+    @Test\n+    public void testTypeCasts(Path base) throws Exception {\n+        String[] testCases = new String[] {\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        Object s = null;\n+                        Object o = (String!)(Object!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                import java.io.*;\n+                class Test {\n+                    public static void main(String... args) {\n+                        Object s = null;\n+                        Object o = (String!)(CharSequence!)(Serializable!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class OtherClass {\n+                        Object! m() {\n+                            return \"\";\n+                        }\n+                    }\n+                    public static void main(String... args) {\n+                        OtherClass oc = new Test().new OtherClass();\n+                        String! s = (String!)oc.m();\n+                    }\n+                }\n+                \"\"\"\n+        };\n+        for (String testCase : testCases) {\n+            Path out = compile(base, testCase, \"Test\", null, PREVIEW);\n+            List<CodeElement> instructions = readInstructions(out.resolve(\"Test.class\"), \"main\");\n+            int numberOfNullChecks = 0;\n+            for (CodeElement ce : instructions) {\n+                if (ce.toString().equals(nullCheckInvocation)) {\n+                    numberOfNullChecks++;\n+                }\n+            }\n+            if (numberOfNullChecks != 1) {\n+                throw new AssertionError(\"was expecting only one invocation to Checks::nullCheck\");\n+            }\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":227,"deletions":37,"binary":false,"changes":264,"status":"modified"}]}