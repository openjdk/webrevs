{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n@@ -131,1 +132,0 @@\n-    ClassSymbol currentClass;\n@@ -138,1 +138,0 @@\n-                this.currentClass = (ClassSymbol) TreeInfo.symbolFor(cdef);\n@@ -144,1 +143,0 @@\n-                this.currentClass = null;\n@@ -206,1 +204,1 @@\n-                    sym.owner != currentClass) {\n+                    !isInThisSameCompUnit(sym)) {\n@@ -208,1 +206,1 @@\n-                 * class\n+                 * compilation unit\n@@ -214,0 +212,5 @@\n+        private boolean isInThisSameCompUnit(Symbol sym) {\n+            return env.toplevel.getTypeDecls().stream()\n+                    .anyMatch(tree -> TreeInfo.symbolFor(tree) == sym.outermostClass());\n+        }\n+\n@@ -215,0 +218,3 @@\n+        if (tree.expr instanceof JCTypeCast otherTypeCast && tree.strict && otherTypeCast.strict) {\n+            tree.strict = false;\n+        }\n@@ -259,2 +265,6 @@\n-        Symbol.MethodSymbol msym = (Symbol.MethodSymbol) TreeInfo.symbolFor(tree.meth);\n-        if (useSiteNullChecks.generateChecksForMethods) {\n+        MethodSymbol msym = (MethodSymbol) TreeInfo.symbolFor(tree.meth);\n+        boolean canBeOverriden = (msym.flags_field & (Flags.PRIVATE | Flags.STATIC | Flags.FINAL)) == 0 &&\n+                !msym.owner.isFinal();\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                hasNonNullArgs(msym) &&\n+                canBeOverriden) {\n@@ -265,4 +275,4 @@\n-        if (useSiteNullChecks.generateChecksForMethods) {\n-            if (types.isNonNullable(msym.type.asMethodType().restype)) {\n-                result = attr.makeNullCheck(tree, true);\n-            }\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                types.isNonNullable(msym.type.asMethodType().restype) &&\n+                canBeOverriden) {\n+            result = attr.makeNullCheck(tree, true);\n@@ -274,2 +284,4 @@\n-        if (useSiteNullChecks.generateChecksForMethods) {\n-            tree.args = newArgs((Symbol.MethodSymbol) tree.constructor, tree.args);\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                hasNonNullArgs((MethodSymbol) tree.constructor) &&\n+                !isInThisSameCompUnit(tree.constructor)) {\n+            tree.args = newArgs((MethodSymbol) tree.constructor, tree.args);\n@@ -281,1 +293,5 @@\n-    private List<JCExpression> newArgs(Symbol.MethodSymbol msym, List<JCExpression> actualArgs) {\n+    private boolean hasNonNullArgs(MethodSymbol msym) {\n+        return msym.type.asMethodType().argtypes.stream().anyMatch(argType -> types.isNonNullable(argType));\n+    }\n+\n+    private List<JCExpression> newArgs(MethodSymbol msym, List<JCExpression> actualArgs) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n@@ -44,0 +46,2 @@\n+import com.sun.tools.javac.util.Assert;\n+\n@@ -343,1 +347,3 @@\n-    private void testHelper(Path base,\n+    \/* returns the path to the output folder in case the caller wants to analyze the produced class files\n+     *\/\n+    private Path testHelper(Path base,\n@@ -347,1 +353,1 @@\n-        testHelper(base, testCode, shouldFail, expectedError, PREVIEW);\n+        return testHelper(base, testCode, shouldFail, expectedError, PREVIEW);\n@@ -350,1 +356,3 @@\n-    private void testHelper(Path base,\n+    \/* returns the path to the output folder in case the caller wants to analyze the produced class files\n+     *\/\n+    private Path testHelper(Path base,\n@@ -392,0 +400,1 @@\n+        return out;\n@@ -455,0 +464,3 @@\n+    static final String nullCheckInvocation =\n+            \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\";\n+\n@@ -457,1 +469,1 @@\n-        String[] testCases = new String[] {\n+        String src =\n@@ -472,1 +484,18 @@\n-                \"\"\",\n+                \"\"\";\n+        String expectedInstSequence =\n+                \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\" +\n+                        \"Invoke[OP=INVOKEVIRTUAL, m=Test$Inner.m(Ljava\/lang\/Object;)Ljava\/lang\/Object;]\";\n+        Path out;\n+        for (String[] options : new String[][] {PREVIEW, USE_SITE_CHECKS_FOR_METHODS_ONLY, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS}) {\n+            out = testHelper(base, src, true, NullPointerException.class, options);\n+            if (!checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+                throw new AssertionError(\"was expecting a null check before Inner::m invocation\");\n+            }\n+        }\n+        out = testHelper(base, src, false, null, NO_USE_SITE_CHECKS);\n+        if (checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+            throw new AssertionError(\"was not expecting a null check before Inner::m invocation\");\n+        }\n+\n+        \/\/ null checks in user site for returns\n+        src =\n@@ -487,1 +516,22 @@\n-                \"\"\",\n+                \"\"\";\n+        expectedInstSequence =\n+                \"Invoke[OP=INVOKEVIRTUAL, m=Test$Inner.m(Ljava\/lang\/Object;)Ljava\/lang\/Object;]\" +\n+                        \"UnboundStackInstruction[op=DUP]\" +\n+                        \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\";\n+        for (String[] options : new String[][] {PREVIEW, USE_SITE_CHECKS_FOR_METHODS_ONLY, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS}) {\n+            out = testHelper(base, src, true, NullPointerException.class, options);\n+            if (!checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+                List<CodeElement> foundSequence = readInstructions(out.resolve(\"Test.class\"), \"main\");\n+                String found = \"\";\n+                for (CodeElement ce : foundSequence) {\n+                    found += ce.toString() + \"\\n\";\n+                }\n+                throw new AssertionError(\"was expecting a null check after Inner::m invocation, found: \\n\" + found);\n+            }\n+        }\n+        out = testHelper(base, src, false, null, NO_USE_SITE_CHECKS);\n+        if (checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", expectedInstSequence)) {\n+            throw new AssertionError(\"was not expecting a null check after Inner::m invocation\");\n+        }\n+\n+        String[] testCases2 = new String[] {\n@@ -491,5 +541,1 @@\n-                        Object m(Object! arg, Object... args) { return null; }\n-                    }\n-                    class Inner2 extends Inner {\n-                        @Override\n-                        String m(Object arg, Object... args) { return null; }\n+                        private Object m(Object! arg) { return null; }\n@@ -498,2 +544,2 @@\n-                        Inner inner = new Test().new Inner2();\n-                        inner.m(null, null);\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n@@ -506,1 +552,1 @@\n-                        Object! m(Object arg, Object... args) { return \"\"; }\n+                        final Object m(Object! arg) { return null; }\n@@ -508,3 +554,10 @@\n-                    class Inner2 extends Inner {\n-                        @Override\n-                        String m(Object arg, Object... args) { return null; }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static class Inner {\n+                        static Object m(Object! arg) { return null; }\n@@ -513,2 +566,12 @@\n-                        Inner inner = new Test().new Inner2();\n-                        inner.m(null, null);\n+                        Inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    final class Inner {\n+                        Object m(Object! arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n@@ -519,5 +582,5 @@\n-        for (String code : testCases) {\n-            testHelper(base, code, true, NullPointerException.class);\n-            testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_ONLY);\n-            testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS);\n-            testHelper(base, code, false, null, NO_USE_SITE_CHECKS);\n+        for (String code : testCases2) {\n+            out = testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS);\n+            if (checkInstructionsSequence(out.resolve(\"Test.class\"), \"main\", nullCheckInvocation)) {\n+                throw new AssertionError(\"an invocation to Checks::nullCheck was not expected\");\n+            }\n@@ -527,0 +590,23 @@\n+    private boolean checkInstructionsSequence(Path path, String methodName, String sequence) throws Exception {\n+        List<CodeElement> instructions = readInstructions(path, methodName);\n+        String foundSequence = \"\";\n+        for (CodeElement ce : instructions) {\n+            foundSequence += ce;\n+        }\n+        return foundSequence.contains(sequence);\n+    }\n+\n+    private List<CodeElement> readInstructions(Path path, String methodName) throws Exception {\n+        ClassModel classFile = ClassFile.of().parse(path);\n+        List<CodeElement> result = new ArrayList<>();\n+        for (MethodModel method: classFile.methods()) {\n+            if (method.methodName().stringValue().equals(methodName)) {\n+                CodeAttribute codeAttr = method.findAttribute(Attributes.code()).orElse(null);\n+                for (CodeElement ce : codeAttr.elementList()) {\n+                    result.add(ce);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -769,0 +855,24 @@\n+\n+    @Test\n+    public void testMultipleCasts(Path base) throws Exception {\n+        Path out = testHelper(base,\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        Object s = null;\n+                        Object o = (String!)(Object!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                true, NullPointerException.class, PREVIEW);\n+        List<CodeElement> instructions = readInstructions(out.resolve(\"Test.class\"), \"main\");\n+        int numberOfNullChecks = 0;\n+        for (CodeElement ce : instructions) {\n+            if (ce.toString().equals(nullCheckInvocation)) {\n+                numberOfNullChecks++;\n+            }\n+        }\n+        if (numberOfNullChecks != 1) {\n+            throw new AssertionError(\"was expecting only one invocation to Checks::nullCheck\");\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":134,"deletions":24,"binary":false,"changes":158,"status":"modified"}]}