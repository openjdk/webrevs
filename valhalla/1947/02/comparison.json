{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n@@ -131,1 +132,0 @@\n-    ClassSymbol currentClass;\n@@ -138,1 +138,0 @@\n-                this.currentClass = (ClassSymbol) TreeInfo.symbolFor(cdef);\n@@ -144,1 +143,0 @@\n-                this.currentClass = null;\n@@ -206,1 +204,1 @@\n-                    sym.owner != currentClass) {\n+                    !isInThisSameCompUnit(sym)) {\n@@ -208,1 +206,1 @@\n-                 * class\n+                 * compilation unit\n@@ -214,0 +212,5 @@\n+        private boolean isInThisSameCompUnit(Symbol sym) {\n+            return env.toplevel.getTypeDecls().stream()\n+                    .anyMatch(tree -> TreeInfo.symbolFor(tree) == sym.outermostClass());\n+        }\n+\n@@ -215,0 +218,3 @@\n+        if (tree.expr instanceof JCTypeCast otherTypeCast && tree.strict && otherTypeCast.strict) {\n+            tree.strict = false;\n+        }\n@@ -259,2 +265,6 @@\n-        Symbol.MethodSymbol msym = (Symbol.MethodSymbol) TreeInfo.symbolFor(tree.meth);\n-        if (useSiteNullChecks.generateChecksForMethods) {\n+        MethodSymbol msym = (MethodSymbol) TreeInfo.symbolFor(tree.meth);\n+        boolean canBeOverriden = (msym.flags_field & (Flags.PRIVATE | Flags.STATIC | Flags.FINAL)) == 0 &&\n+                !msym.owner.isFinal();\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                hasNonNullArgs(msym) &&\n+                canBeOverriden) {\n@@ -265,4 +275,4 @@\n-        if (useSiteNullChecks.generateChecksForMethods) {\n-            if (types.isNonNullable(msym.type.asMethodType().restype)) {\n-                result = attr.makeNullCheck(tree, true);\n-            }\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                types.isNonNullable(msym.type.asMethodType().restype) &&\n+                canBeOverriden) {\n+            result = attr.makeNullCheck(tree, true);\n@@ -274,2 +284,4 @@\n-        if (useSiteNullChecks.generateChecksForMethods) {\n-            tree.args = newArgs((Symbol.MethodSymbol) tree.constructor, tree.args);\n+        if (useSiteNullChecks.generateChecksForMethods &&\n+                hasNonNullArgs((MethodSymbol) tree.constructor) &&\n+                !isInThisSameCompUnit(tree.constructor)) {\n+            tree.args = newArgs((MethodSymbol) tree.constructor, tree.args);\n@@ -281,1 +293,5 @@\n-    private List<JCExpression> newArgs(Symbol.MethodSymbol msym, List<JCExpression> actualArgs) {\n+    private boolean hasNonNullArgs(MethodSymbol msym) {\n+        return msym.type.asMethodType().argtypes.stream().anyMatch(argType -> types.isNonNullable(argType));\n+    }\n+\n+    private List<JCExpression> newArgs(MethodSymbol msym, List<JCExpression> actualArgs) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n@@ -44,0 +46,2 @@\n+import com.sun.tools.javac.util.Assert;\n+\n@@ -343,1 +347,3 @@\n-    private void testHelper(Path base,\n+    \/* returns the path to the output folder in case the caller wants to analyze the produced class files\n+     *\/\n+    private Path testHelper(Path base,\n@@ -347,1 +353,1 @@\n-        testHelper(base, testCode, shouldFail, expectedError, PREVIEW);\n+        return testHelper(base, testCode, shouldFail, expectedError, PREVIEW);\n@@ -350,1 +356,3 @@\n-    private void testHelper(Path base,\n+    \/* returns the path to the output folder in case the caller wants to analyze the produced class files\n+     *\/\n+    private Path testHelper(Path base,\n@@ -392,0 +400,1 @@\n+        return out;\n@@ -455,0 +464,3 @@\n+    static final String nullCheckInvocation =\n+            \"Invoke[OP=INVOKESTATIC, m=java\/lang\/runtime\/Checks.nullCheck(Ljava\/lang\/Object;)V]\";\n+\n@@ -457,1 +469,1 @@\n-        String[] testCases = new String[] {\n+        String[] testCases1 = new String[] {\n@@ -519,1 +531,1 @@\n-        for (String code : testCases) {\n+        for (String code : testCases1) {\n@@ -525,0 +537,68 @@\n+\n+        String[] testCases2 = new String[] {\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        private Object m(Object! arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        final Object m(Object! arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static class Inner {\n+                        static Object m(Object! arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    final class Inner {\n+                        Object m(Object! arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\"\n+        };\n+        for (String code : testCases2) {\n+            Path out = testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS);\n+            List<CodeElement> instructions = readInstructions(out.resolve(\"Test.class\"), \"main\");\n+            if (instructions.stream()\n+                    .anyMatch(instruction -> instruction.toString().equals(nullCheckInvocation))) {\n+                throw new AssertionError(\"an invocation to Checks::nullCheck was not expected\");\n+            }\n+        }\n+    }\n+\n+    private List<CodeElement> readInstructions(Path path, String methodName) throws Exception {\n+        ClassModel classFile = ClassFile.of().parse(path);\n+        List<CodeElement> result = new ArrayList<>();\n+        for (MethodModel method: classFile.methods()) {\n+            if (method.methodName().stringValue().equals(methodName)) {\n+                CodeAttribute codeAttr = method.findAttribute(Attributes.code()).orElse(null);\n+                for (CodeElement ce : codeAttr.elementList()) {\n+                    result.add(ce);\n+                }\n+            }\n+        }\n+        return result;\n@@ -769,0 +849,24 @@\n+\n+    @Test\n+    public void testMultipleCasts(Path base) throws Exception {\n+        Path out = testHelper(base,\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        Object s = null;\n+                        Object o = (String!)(Object!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                true, NullPointerException.class, PREVIEW);\n+        List<CodeElement> instructions = readInstructions(out.resolve(\"Test.class\"), \"main\");\n+        int numberOfNullChecks = 0;\n+        for (CodeElement ce : instructions) {\n+            if (ce.toString().equals(nullCheckInvocation)) {\n+                numberOfNullChecks++;\n+            }\n+        }\n+        if (numberOfNullChecks != 1) {\n+            throw new AssertionError(\"was expecting only one invocation to Checks::nullCheck\");\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":109,"deletions":5,"binary":false,"changes":114,"status":"modified"}]}