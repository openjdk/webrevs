{"files":[{"patch":"@@ -279,1 +279,1 @@\n-  $1_FLAGS += $$($1_JAVAC_FLAGS)\n+  $1_FLAGS += $$($1_JAVAC_FLAGS) -XDenablePrimitiveClasses\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2292,1 +2292,18 @@\n-      break;\n+    break;\n+    case Op_AddHF:\n+    case Op_SubHF:\n+    case Op_MulHF:\n+    case Op_DivHF:\n+    case Op_MinHF:\n+    case Op_MaxHF:\n+    case Op_AbsHF:\n+    case Op_NegHF:\n+    case Op_SqrtHF:\n+    case Op_FmaHF:\n+      \/\/ Half-precision floating point scalar operations require FEAT_FP16\n+      \/\/ to be available. FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\"\n+      \/\/ features are supported.\n+      if (!VM_Version::supports_fphp() || !VM_Version::supports_asimdhp()) {\n+        return false;\n+    }\n+    break;\n@@ -13574,0 +13591,15 @@\n+\/\/ Half-precision floating point add operation\n+instruct addHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (AddHF src1 src2));\n+\n+  format %{ \"faddh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ faddh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13604,0 +13636,15 @@\n+instruct subHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (SubHF src1 src2));\n+\n+  ins_cost(INSN_COST * 5);\n+  format %{ \"fsubh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fsubh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13634,0 +13681,15 @@\n+instruct mulHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MulHF src1 src2));\n+\n+  ins_cost(INSN_COST * 6);\n+  format %{ \"fmulh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fmulh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13673,3 +13735,3 @@\n-             as_FloatRegister($src1$$reg),\n-             as_FloatRegister($src2$$reg),\n-             as_FloatRegister($src3$$reg));\n+              as_FloatRegister($src1$$reg),\n+              as_FloatRegister($src2$$reg),\n+              as_FloatRegister($src3$$reg));\n@@ -13690,3 +13752,20 @@\n-             as_FloatRegister($src1$$reg),\n-             as_FloatRegister($src2$$reg),\n-             as_FloatRegister($src3$$reg));\n+              as_FloatRegister($src1$$reg),\n+              as_FloatRegister($src2$$reg),\n+              as_FloatRegister($src3$$reg));\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ src1 * src2 + src3 (half-precision float)\n+instruct maddHF_reg_reg(vRegF dst, vRegF src1, vRegF src2, vRegF src3) %{\n+  match(Set dst (FmaHF src3 (Binary src1 src2)));\n+\n+  format %{ \"fmaddh   $dst, $src1, $src2, $src3\" %}\n+\n+  ins_encode %{\n+    assert(UseFMA, \"Needs FMA instructions support.\");\n+    __ fmaddh(as_FloatRegister($dst$$reg),\n+              as_FloatRegister($src1$$reg),\n+              as_FloatRegister($src2$$reg),\n+              as_FloatRegister($src3$$reg));\n@@ -13805,0 +13884,23 @@\n+\/\/ Math.max(HF)\n+instruct maxHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MaxHF src1 src2));\n+  format %{ \"fmaxh   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fmaxh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+\/\/ Math.min(HF)\n+instruct minHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MinHF src1 src2));\n+  format %{ \"fminh   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fminh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n@@ -13862,0 +13964,14 @@\n+instruct divHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (DivHF src1  src2));\n+\n+  ins_cost(INSN_COST * 18);\n+  format %{ \"fdivh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fdivh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_div_s);\n+%}\n@@ -13893,0 +14009,14 @@\n+instruct negHF_reg_reg(vRegF dst, vRegF src) %{\n+  match(Set dst (NegHF src));\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{ \"fneg   $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ fnegh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg));\n+  %}\n+\n+  ins_pipe(fp_uop_s);\n+%}\n+\n@@ -13955,0 +14085,13 @@\n+instruct absHF_reg(vRegF dst, vRegF src) %{\n+  match(Set dst (AbsHF src));\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{ \"fabsh   $dst, $src\" %}\n+  ins_encode %{\n+    __ fabsh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg));\n+  %}\n+\n+  ins_pipe(fp_uop_s);\n+%}\n+\n@@ -14016,1 +14159,1 @@\n-             as_FloatRegister($src$$reg));\n+              as_FloatRegister($src$$reg));\n@@ -14019,1 +14162,1 @@\n-  ins_pipe(fp_div_s);\n+  ins_pipe(fp_div_d);\n@@ -14029,1 +14172,1 @@\n-             as_FloatRegister($src$$reg));\n+              as_FloatRegister($src$$reg));\n@@ -14032,1 +14175,14 @@\n-  ins_pipe(fp_div_d);\n+  ins_pipe(fp_div_s);\n+%}\n+\n+instruct sqrtHF_reg(vRegF dst, vRegF src) %{\n+  match(Set dst (SqrtHF src));\n+\n+  ins_cost(INSN_COST * 50);\n+  format %{ \"fsqrth  $dst, $src\" %}\n+  ins_encode %{\n+    __ fsqrth(as_FloatRegister($dst$$reg),\n+              as_FloatRegister($src$$reg));\n+  %}\n+\n+  ins_pipe(fp_div_s);\n@@ -17046,0 +17202,39 @@\n+\/\/----------------------------- Reinterpret ----------------------------------\n+\n+instruct reinterpretHF2S(iRegINoSp dst, vRegF src) %{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"reinterpretHF2S $dst, $src\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ H, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretS2HF(vRegF dst, iRegINoSp src) %{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"reinterpretS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ H, 0, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2HFAndS2HF(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvtsh($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretHF2SAndHF2F(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"reinterpretHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvths($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":206,"deletions":11,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -234,0 +234,17 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n+      case Op_AbsVHF:\n+      case Op_NegVHF:\n+      case Op_SqrtVHF:\n+      case Op_FmaVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports half-precision floats\n+        \/\/ by default.\n+        if (UseSVE > 0 || (VM_Version::supports_fphp() && VM_Version::supports_asimdhp())) {\n+          break;\n+        }\n+        return false;\n@@ -581,0 +598,16 @@\n+instruct vaddHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"vaddHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fadd($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fadd($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -655,0 +688,10 @@\n+instruct vaddHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vaddHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadd($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -805,0 +848,16 @@\n+instruct vsubHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"vsubHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -879,0 +938,10 @@\n+instruct vsubHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vsubHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1002,0 +1071,16 @@\n+instruct vmulHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVHF src1 src2));\n+  format %{ \"vmulHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1076,0 +1161,10 @@\n+instruct vmulHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vmulHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1100,0 +1195,22 @@\n+instruct vdivHF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVHF src1 src2));\n+  format %{ \"vdivHF_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivHF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVHF dst_src1 src2));\n+  format %{ \"vdivHF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1146,0 +1263,10 @@\n+instruct vdivHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vdivHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1632,0 +1759,15 @@\n+instruct vabsHF(vReg dst, vReg src) %{\n+  match(Set dst (AbsVHF src));\n+  format %{ \"vabsHF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fabs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fabs($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1694,0 +1836,10 @@\n+instruct vabsHF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVHF dst_src pg));\n+  format %{ \"vabsHF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fabs($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1805,0 +1957,15 @@\n+instruct vnegVF(vReg dst, vReg src) %{\n+  match(Set dst (NegVHF src));\n+  format %{ \"vnegVF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fneg($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fneg($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1849,0 +2016,10 @@\n+instruct vnegHF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVHF dst_src pg));\n+  format %{ \"vnegHF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fneg($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1883,0 +2060,15 @@\n+instruct vsqrtHF(vReg dst, vReg src) %{\n+  match(Set dst (SqrtVHF src));\n+  format %{ \"vsqrtHF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsqrt($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsqrt($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1905,0 +2097,9 @@\n+instruct vsqrtHF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (SqrtVHF dst_src pg));\n+  format %{ \"vsqrtHF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fsqrt($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -1972,0 +2173,25 @@\n+instruct vhfmin_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MinVHF src1 src2));\n+  format %{ \"vhfmin_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ fmin($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vhfmin_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MinVHF dst_src1 src2));\n+  format %{ \"vhfmin_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1992,0 +2218,12 @@\n+instruct vhfmin_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MinVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vhfmin_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2059,0 +2297,25 @@\n+instruct vhfmax_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MaxVHF src1 src2));\n+  format %{ \"vhfmax_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ fmax($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vhfmax_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MaxVHF dst_src1 src2));\n+  format %{ \"vhfmax_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2079,0 +2342,12 @@\n+instruct vhfmax_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MaxVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vhfmax_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2135,0 +2410,1 @@\n+  match(Set dst_src1 (FmaVHF dst_src1 (Binary src2 src3)));\n@@ -2159,0 +2435,1 @@\n+  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":277,"deletions":0,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -224,0 +224,17 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n+      case Op_AbsVHF:\n+      case Op_NegVHF:\n+      case Op_SqrtVHF:\n+      case Op_FmaVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports half-precision floats\n+        \/\/ by default.\n+        if (UseSVE > 0 || (VM_Version::supports_fphp() && VM_Version::supports_asimdhp())) {\n+          break;\n+        }\n+        return false;\n@@ -506,6 +523,7 @@\n-BINARY_OP(vaddB, AddVB, addv, sve_add,  B)\n-BINARY_OP(vaddS, AddVS, addv, sve_add,  H)\n-BINARY_OP(vaddI, AddVI, addv, sve_add,  S)\n-BINARY_OP(vaddL, AddVL, addv, sve_add,  D)\n-BINARY_OP(vaddF, AddVF, fadd, sve_fadd, S)\n-BINARY_OP(vaddD, AddVD, fadd, sve_fadd, D)\n+BINARY_OP(vaddB,  AddVB,  addv, sve_add,  B)\n+BINARY_OP(vaddS,  AddVS,  addv, sve_add,  H)\n+BINARY_OP(vaddI,  AddVI,  addv, sve_add,  S)\n+BINARY_OP(vaddL,  AddVL,  addv, sve_add,  D)\n+BINARY_OP(vaddHF, AddVHF, fadd, sve_fadd, H)\n+BINARY_OP(vaddF,  AddVF,  fadd, sve_fadd, S)\n+BINARY_OP(vaddD,  AddVD,  fadd, sve_fadd, D)\n@@ -514,6 +532,7 @@\n-BINARY_OP_PREDICATE(vaddB, AddVB, sve_add,  B)\n-BINARY_OP_PREDICATE(vaddS, AddVS, sve_add,  H)\n-BINARY_OP_PREDICATE(vaddI, AddVI, sve_add,  S)\n-BINARY_OP_PREDICATE(vaddL, AddVL, sve_add,  D)\n-BINARY_OP_PREDICATE(vaddF, AddVF, sve_fadd, S)\n-BINARY_OP_PREDICATE(vaddD, AddVD, sve_fadd, D)\n+BINARY_OP_PREDICATE(vaddB,  AddVB,  sve_add,  B)\n+BINARY_OP_PREDICATE(vaddS,  AddVS,  sve_add,  H)\n+BINARY_OP_PREDICATE(vaddI,  AddVI,  sve_add,  S)\n+BINARY_OP_PREDICATE(vaddL,  AddVL,  sve_add,  D)\n+BINARY_OP_PREDICATE(vaddHF, AddVHF, sve_fadd, H)\n+BINARY_OP_PREDICATE(vaddF,  AddVF,  sve_fadd, S)\n+BINARY_OP_PREDICATE(vaddD,  AddVD,  sve_fadd, D)\n@@ -530,6 +549,7 @@\n-BINARY_OP(vsubB, SubVB, subv, sve_sub,  B)\n-BINARY_OP(vsubS, SubVS, subv, sve_sub,  H)\n-BINARY_OP(vsubI, SubVI, subv, sve_sub,  S)\n-BINARY_OP(vsubL, SubVL, subv, sve_sub,  D)\n-BINARY_OP(vsubF, SubVF, fsub, sve_fsub, S)\n-BINARY_OP(vsubD, SubVD, fsub, sve_fsub, D)\n+BINARY_OP(vsubB,  SubVB,  subv, sve_sub,  B)\n+BINARY_OP(vsubS,  SubVS,  subv, sve_sub,  H)\n+BINARY_OP(vsubI,  SubVI,  subv, sve_sub,  S)\n+BINARY_OP(vsubL,  SubVL,  subv, sve_sub,  D)\n+BINARY_OP(vsubHF, SubVHF, fsub, sve_fsub, H)\n+BINARY_OP(vsubF,  SubVF,  fsub, sve_fsub, S)\n+BINARY_OP(vsubD,  SubVD,  fsub, sve_fsub, D)\n@@ -538,6 +558,7 @@\n-BINARY_OP_PREDICATE(vsubB, SubVB, sve_sub,  B)\n-BINARY_OP_PREDICATE(vsubS, SubVS, sve_sub,  H)\n-BINARY_OP_PREDICATE(vsubI, SubVI, sve_sub,  S)\n-BINARY_OP_PREDICATE(vsubL, SubVL, sve_sub,  D)\n-BINARY_OP_PREDICATE(vsubF, SubVF, sve_fsub, S)\n-BINARY_OP_PREDICATE(vsubD, SubVD, sve_fsub, D)\n+BINARY_OP_PREDICATE(vsubB,  SubVB,  sve_sub,  B)\n+BINARY_OP_PREDICATE(vsubS,  SubVS,  sve_sub,  H)\n+BINARY_OP_PREDICATE(vsubI,  SubVI,  sve_sub,  S)\n+BINARY_OP_PREDICATE(vsubL,  SubVL,  sve_sub,  D)\n+BINARY_OP_PREDICATE(vsubHF, SubVHF, sve_fsub, H)\n+BINARY_OP_PREDICATE(vsubF,  SubVF,  sve_fsub, S)\n+BINARY_OP_PREDICATE(vsubD,  SubVD,  sve_fsub, D)\n@@ -610,2 +631,3 @@\n-BINARY_OP(vmulF, MulVF, fmul, sve_fmul, S)\n-BINARY_OP(vmulD, MulVD, fmul, sve_fmul, D)\n+BINARY_OP(vmulHF, MulVHF, fmul, sve_fmul, H)\n+BINARY_OP(vmulF,  MulVF,  fmul, sve_fmul, S)\n+BINARY_OP(vmulD,  MulVD,  fmul, sve_fmul, D)\n@@ -614,6 +636,7 @@\n-BINARY_OP_PREDICATE(vmulB, MulVB, sve_mul,  B)\n-BINARY_OP_PREDICATE(vmulS, MulVS, sve_mul,  H)\n-BINARY_OP_PREDICATE(vmulI, MulVI, sve_mul,  S)\n-BINARY_OP_PREDICATE(vmulL, MulVL, sve_mul,  D)\n-BINARY_OP_PREDICATE(vmulF, MulVF, sve_fmul, S)\n-BINARY_OP_PREDICATE(vmulD, MulVD, sve_fmul, D)\n+BINARY_OP_PREDICATE(vmulB,  MulVB,  sve_mul,  B)\n+BINARY_OP_PREDICATE(vmulS,  MulVS,  sve_mul,  H)\n+BINARY_OP_PREDICATE(vmulI,  MulVI,  sve_mul,  S)\n+BINARY_OP_PREDICATE(vmulL,  MulVL,  sve_mul,  D)\n+BINARY_OP_PREDICATE(vmulHF, MulVHF, sve_fmul, H)\n+BINARY_OP_PREDICATE(vmulF,  MulVF,  sve_fmul, S)\n+BINARY_OP_PREDICATE(vmulD,  MulVD,  sve_fmul, D)\n@@ -624,2 +647,3 @@\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivF, DivVF, fdiv, sve_fdiv, S)\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivD, DivVD, fdiv, sve_fdiv, D)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivHF, DivVHF, fdiv, sve_fdiv, H)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivF,  DivVF,  fdiv, sve_fdiv, S)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivD,  DivVD,  fdiv, sve_fdiv, D)\n@@ -628,2 +652,3 @@\n-BINARY_OP_PREDICATE(vdivF, DivVF, sve_fdiv, S)\n-BINARY_OP_PREDICATE(vdivD, DivVD, sve_fdiv, D)\n+BINARY_OP_PREDICATE(vdivHF, DivVHF, sve_fdiv, H)\n+BINARY_OP_PREDICATE(vdivF,  DivVF,  sve_fdiv, S)\n+BINARY_OP_PREDICATE(vdivD,  DivVD,  sve_fdiv, D)\n@@ -862,6 +887,7 @@\n-UNARY_OP(vabsB, AbsVB, absr, sve_abs,  B)\n-UNARY_OP(vabsS, AbsVS, absr, sve_abs,  H)\n-UNARY_OP(vabsI, AbsVI, absr, sve_abs,  S)\n-UNARY_OP(vabsL, AbsVL, absr, sve_abs,  D)\n-UNARY_OP(vabsF, AbsVF, fabs, sve_fabs, S)\n-UNARY_OP(vabsD, AbsVD, fabs, sve_fabs, D)\n+UNARY_OP(vabsB,  AbsVB,  absr, sve_abs,  B)\n+UNARY_OP(vabsS,  AbsVS,  absr, sve_abs,  H)\n+UNARY_OP(vabsI,  AbsVI,  absr, sve_abs,  S)\n+UNARY_OP(vabsL,  AbsVL,  absr, sve_abs,  D)\n+UNARY_OP(vabsF,  AbsVF,  fabs, sve_fabs, S)\n+UNARY_OP(vabsD,  AbsVD,  fabs, sve_fabs, D)\n+UNARY_OP(vabsHF, AbsVHF, fabs, sve_fabs, H)\n@@ -870,6 +896,7 @@\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsB, AbsVB, sve_abs,  B)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsS, AbsVS, sve_abs,  H)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsI, AbsVI, sve_abs,  S)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsL, AbsVL, sve_abs,  D)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsF, AbsVF, sve_fabs, S)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsD, AbsVD, sve_fabs, D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsB,  AbsVB,  sve_abs,  B)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsS,  AbsVS,  sve_abs,  H)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsI,  AbsVI,  sve_abs,  S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsL,  AbsVL,  sve_abs,  D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsF,  AbsVF,  sve_fabs, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsD,  AbsVD,  sve_fabs, D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsHF, AbsVHF, sve_fabs, H)\n@@ -945,0 +972,1 @@\n+UNARY_OP(vnegVF, NegVHF, fneg, sve_fneg, H)\n@@ -951,0 +979,1 @@\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegHF, NegVHF, sve_fneg, H)\n@@ -955,2 +984,3 @@\n-UNARY_OP(vsqrtF, SqrtVF, fsqrt, sve_fsqrt, S)\n-UNARY_OP(vsqrtD, SqrtVD, fsqrt, sve_fsqrt, D)\n+UNARY_OP(vsqrtF,  SqrtVF,  fsqrt, sve_fsqrt, S)\n+UNARY_OP(vsqrtD,  SqrtVD,  fsqrt, sve_fsqrt, D)\n+UNARY_OP(vsqrtHF, SqrtVHF, fsqrt, sve_fsqrt, H)\n@@ -959,3 +989,3 @@\n-UNARY_OP_PREDICATE_WITH_SIZE(vsqrtF, SqrtVF, sve_fsqrt, S)\n-UNARY_OP_PREDICATE_WITH_SIZE(vsqrtD, SqrtVD, sve_fsqrt, D)\n-\n+UNARY_OP_PREDICATE_WITH_SIZE(vsqrtF,  SqrtVF,  sve_fsqrt, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vsqrtD,  SqrtVD,  sve_fsqrt, D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vsqrtHF, SqrtVHF, sve_fsqrt, H)\n@@ -1013,0 +1043,15 @@\n+dnl VHFMINMAX_NEON($1,   $2,      $3     )\n+dnl VHFMINMAX_NEON(type, op_name, insn_fp)\n+define(`VHFMINMAX_NEON', `\n+instruct vhf$1_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"vhf$1_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1036,0 +1081,16 @@\n+dnl VHFMINMAX_SVE($1,   $2,      $3     )\n+dnl VHFMINMAX_SVE(type, op_name, insn_fp)\n+define(`VHFMINMAX_SVE', `\n+instruct vhf$1_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"vhf$1_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1057,0 +1118,15 @@\n+dnl VHFMINMAX_PREDICATE($1,   $2,      $3     )\n+dnl VHFMINMAX_PREDICATE(type, op_name, insn_fp)\n+define(`VHFMINMAX_PREDICATE', `\n+instruct vhf$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"vhf$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1066,0 +1142,2 @@\n+VHFMINMAX_NEON(min, MinVHF, fmin)\n+VHFMINMAX_SVE(min, MinVHF, sve_fmin)\n@@ -1069,0 +1147,1 @@\n+VHFMINMAX_PREDICATE(min, MinVHF, sve_fmin)\n@@ -1079,0 +1158,2 @@\n+VHFMINMAX_NEON(max, MaxVHF, fmax)\n+VHFMINMAX_SVE(max, MaxVHF, sve_fmax)\n@@ -1082,0 +1163,1 @@\n+VHFMINMAX_PREDICATE(max, MaxVHF, sve_fmax)\n@@ -1139,0 +1221,1 @@\n+  match(Set dst_src1 (FmaVHF dst_src1 (Binary src2 src3)));\n@@ -1163,0 +1246,1 @@\n+  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":137,"deletions":53,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -2010,1 +2010,0 @@\n-  INSN(fcvths, 0b11, 0b000100);   \/\/ Half-precision to single-precision\n@@ -2019,0 +2018,5 @@\n+  INSN(fabsh,  0b11, 0b000001);\n+  INSN(fnegh,  0b11, 0b000010);\n+  INSN(fsqrth, 0b11, 0b000011);\n+  INSN(fcvths, 0b11, 0b000100);   \/\/ Half-precision to single-precision\n+\n@@ -2046,1 +2050,1 @@\n-  void data_processing(unsigned op31, unsigned type, unsigned opcode,\n+  void data_processing(unsigned op31, unsigned type, unsigned opcode, unsigned op21,\n@@ -2051,1 +2055,1 @@\n-    f(type, 23, 22), f(1, 21), f(opcode, 15, 10);\n+    f(type, 23, 22), f(op21, 21), f(opcode, 15, 10);\n@@ -2055,1 +2059,1 @@\n-#define INSN(NAME, op31, type, opcode)                  \\\n+#define INSN(NAME, op31, type, opcode, op21)                            \\\n@@ -2057,21 +2061,29 @@\n-    data_processing(op31, type, opcode, Vd, Vn, Vm);    \\\n-  }\n-\n-  INSN(fabds,  0b011, 0b10, 0b110101);\n-  INSN(fmuls,  0b000, 0b00, 0b000010);\n-  INSN(fdivs,  0b000, 0b00, 0b000110);\n-  INSN(fadds,  0b000, 0b00, 0b001010);\n-  INSN(fsubs,  0b000, 0b00, 0b001110);\n-  INSN(fmaxs,  0b000, 0b00, 0b010010);\n-  INSN(fmins,  0b000, 0b00, 0b010110);\n-  INSN(fnmuls, 0b000, 0b00, 0b100010);\n-\n-  INSN(fabdd,  0b011, 0b11, 0b110101);\n-  INSN(fmuld,  0b000, 0b01, 0b000010);\n-  INSN(fdivd,  0b000, 0b01, 0b000110);\n-  INSN(faddd,  0b000, 0b01, 0b001010);\n-  INSN(fsubd,  0b000, 0b01, 0b001110);\n-  INSN(fmaxd,  0b000, 0b01, 0b010010);\n-  INSN(fmind,  0b000, 0b01, 0b010110);\n-  INSN(fnmuld, 0b000, 0b01, 0b100010);\n-\n+    data_processing(op31, type, opcode, op21, Vd, Vn, Vm);              \\\n+  }\n+\n+  INSN(fabds,  0b011, 0b10, 0b110101, 0b1);\n+  INSN(fmuls,  0b000, 0b00, 0b000010, 0b1);\n+  INSN(fdivs,  0b000, 0b00, 0b000110, 0b1);\n+  INSN(fadds,  0b000, 0b00, 0b001010, 0b1);\n+  INSN(fsubs,  0b000, 0b00, 0b001110, 0b1);\n+  INSN(fmaxs,  0b000, 0b00, 0b010010, 0b1);\n+  INSN(fmins,  0b000, 0b00, 0b010110, 0b1);\n+  INSN(fnmuls, 0b000, 0b00, 0b100010, 0b1);\n+\n+  INSN(fabdd,  0b011, 0b11, 0b110101, 0b1);\n+  INSN(fmuld,  0b000, 0b01, 0b000010, 0b1);\n+  INSN(fdivd,  0b000, 0b01, 0b000110, 0b1);\n+  INSN(faddd,  0b000, 0b01, 0b001010, 0b1);\n+  INSN(fsubd,  0b000, 0b01, 0b001110, 0b1);\n+  INSN(fmaxd,  0b000, 0b01, 0b010010, 0b1);\n+  INSN(fmind,  0b000, 0b01, 0b010110, 0b1);\n+  INSN(fnmuld, 0b000, 0b01, 0b100010, 0b1);\n+\n+  INSN(fabdh,  0b011, 0b11, 0b000101, 0b0);\n+  INSN(fmulh,  0b000, 0b11, 0b000010, 0b1);\n+  INSN(fdivh,  0b000, 0b11, 0b000110, 0b1);\n+  INSN(faddh,  0b000, 0b11, 0b001010, 0b1);\n+  INSN(fsubh,  0b000, 0b11, 0b001110, 0b1);\n+  INSN(fmaxh,  0b000, 0b11, 0b010010, 0b1);\n+  INSN(fminh,  0b000, 0b11, 0b010110, 0b1);\n+  INSN(fnmulh, 0b000, 0b11, 0b100010, 0b1);\n@@ -2107,0 +2119,6 @@\n+  \/\/ Half-precision instructions\n+  INSN(fmaddh,  0b000, 0b11, 0, 0);\n+  INSN(fmsubh,  0b000, 0b11, 0, 1);\n+  INSN(fnmaddh, 0b000, 0b11, 1, 0);\n+  INSN(fnmsubh, 0b000, 0b11, 1, 1);\n+\n@@ -2683,6 +2701,9 @@\n-#define INSN(NAME, op1, op2, op3)                                                       \\\n-  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \\\n-    starti;                                                                             \\\n-    assert(T == T2S || T == T4S || T == T2D, \"invalid arrangement\");                    \\\n-    f(0, 31), f((int)T & 1, 30), f(op1, 29), f(0b01110, 28, 24), f(op2, 23);            \\\n-    f(T==T2D ? 1:0, 22); f(1, 21), rf(Vm, 16), f(op3, 15, 10), rf(Vn, 5), rf(Vd, 0);    \\\n+\n+void adv_simd_three_same(Instruction_aarch64 &current_insn, FloatRegister Vd,\n+                         SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm,\n+                         int op1, int op2, int op3);\n+\n+#define INSN(NAME, op1, op2, op3)                                                             \\\n+  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) {       \\\n+    starti;                                                                                   \\\n+    adv_simd_three_same(current_insn, Vd, T, Vn, Vm, op1, op2, op3);                          \\\n@@ -2691,11 +2712,11 @@\n-  INSN(fabd, 1, 1, 0b110101);\n-  INSN(fadd, 0, 0, 0b110101);\n-  INSN(fdiv, 1, 0, 0b111111);\n-  INSN(faddp, 1, 0, 0b110101);\n-  INSN(fmul, 1, 0, 0b110111);\n-  INSN(fsub, 0, 1, 0b110101);\n-  INSN(fmla, 0, 0, 0b110011);\n-  INSN(fmls, 0, 1, 0b110011);\n-  INSN(fmax, 0, 0, 0b111101);\n-  INSN(fmin, 0, 1, 0b111101);\n-  INSN(facgt, 1, 1, 0b111011);\n+  INSN(fabd,  1, 1, 0b0101);\n+  INSN(fadd,  0, 0, 0b0101);\n+  INSN(fdiv,  1, 0, 0b1111);\n+  INSN(faddp, 1, 0, 0b0101);\n+  INSN(fmul,  1, 0, 0b0111);\n+  INSN(fsub,  0, 1, 0b0101);\n+  INSN(fmla,  0, 0, 0b0011);\n+  INSN(fmls,  0, 1, 0b0011);\n+  INSN(fmax,  0, 0, 0b1101);\n+  INSN(fmin,  0, 1, 0b1101);\n+  INSN(facgt, 1, 1, 0b1011);\n@@ -3152,7 +3173,9 @@\n-#define INSN(NAME, U, size, tmask, opcode)                                          \\\n-  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \\\n-       starti;                                                                      \\\n-       assert((ASSERTION), MSG);                                                    \\\n-       f(0, 31), f((int)T & 1, 30), f(U, 29), f(0b01110, 28, 24);                   \\\n-       f(size | ((int)(T >> 1) & tmask), 23, 22), f(0b10000, 21, 17);               \\\n-       f(opcode, 16, 12), f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                    \\\n+#define INSN(NAME, U, size, tmask, opcode)                                         \\\n+  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {              \\\n+       starti;                                                                     \\\n+       assert((ASSERTION), MSG);                                                   \\\n+       int op23 = (T == T4H || T == T8H) ? 0b11 : ((int)(T >> 1) & tmask);         \\\n+       int op20 = (T == T4H || T == T8H) ? 0b11 : 0b00;                            \\\n+       f(0, 31), f((int)T & 1, 30), f(U, 29), f(0b01110, 28, 24);                  \\\n+       f(size | op23, 23, 22), f(1, 21), f(op20, 20, 19), f(0b00, 18, 17);         \\\n+       f(opcode, 16, 12), f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                   \\\n@@ -3163,1 +3186,1 @@\n-#define ASSERTION (T == T2S || T == T4S || T == T2D)\n+#define ASSERTION (T == T4H || T == T8H || T == T2S || T == T4S || T == T2D)\n@@ -3286,1 +3309,1 @@\n-    assert(T == S || T == D, \"invalid register variant\");                              \\\n+    assert(T == H || T == S || T == D, \"invalid register variant\");                    \\\n@@ -3369,1 +3392,1 @@\n-    assert(T == S || T == D, \"invalid register variant\");                                             \\\n+    assert(T == H || T == S || T == D, \"invalid register variant\");                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":77,"deletions":54,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1209,1 +1209,2 @@\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n+  bool is_null_free = x->is_null_free() ||  x->klass()->has_flat_layout();\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, is_null_free);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -127,0 +127,2 @@\n+    decl(FPHP,          fphp,          9)     \\\n+    decl(ASIMDHP,       asimdhp,       10)    \\\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3275,0 +3275,16 @@\n+void Assembler::vmovw(XMMRegister dst, Register src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6E, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovw(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x7E, (0xC0 | encode));\n+}\n+\n@@ -7591,0 +7607,216 @@\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x58);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5C);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x59);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x5E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evsqrtph(XMMRegister dst, XMMRegister src1, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x51, (0xC0 | encode));\n+}\n+\n+void Assembler::evsqrtph(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x51);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16(0x98, (0xC0 | encode));\n+}\n+\n+void Assembler::evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int8(0x98);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::eaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::esubsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::edivsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::emulsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::emaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::eminsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n+void Assembler::esqrtsh(XMMRegister dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x51, (0xC0 | encode));\n+}\n+\n+void Assembler::efmadd132sh(XMMRegister dst, XMMRegister src1, XMMRegister src2) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16((unsigned char)0x99, (0xC0 | encode));\n+}\n+\n@@ -11784,1 +12016,1 @@\n-  \/\/ of form {0F, 0F_38, 0F_3A, 0F_3C}\n+  \/\/ of form {0F, 0F_38, 0F_3A, 0F_3C, MAP5, MAP6}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":233,"deletions":1,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -586,0 +586,2 @@\n+    VEX_OPCODE_MAP5  = 0x5,\n+    VEX_OPCODE_MAP6  = 0x6,\n@@ -1733,0 +1735,3 @@\n+  void vmovw(XMMRegister dst, Register src);\n+  void vmovw(Register dst, XMMRegister src);\n+\n@@ -2494,0 +2499,27 @@\n+  \/\/ FP16 instructions\n+  void eaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void esubsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void emulsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void edivsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void emaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void eminsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void esqrtsh(XMMRegister dst, XMMRegister src);\n+  void efmadd132sh(XMMRegister dst, XMMRegister src1, XMMRegister src2);\n+\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evaddph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evsubph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evfmadd132ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd132ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evsqrtph(XMMRegister dst, XMMRegister src1, int vector_len);\n+  void evsqrtph(XMMRegister dst, Address src1, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1404,1 +1404,2 @@\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n+  bool is_null_free = x->is_null_free() || x->klass()->has_flat_layout();\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, is_null_free);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6651,0 +6651,36 @@\n+\n+void C2_MacroAssembler::efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2) {\n+  switch(opcode) {\n+    case Op_AddHF: eaddsh(dst, src1, src2); break;\n+    case Op_SubHF: esubsh(dst, src1, src2); break;\n+    case Op_MulHF: emulsh(dst, src1, src2); break;\n+    case Op_DivHF: edivsh(dst, src1, src2); break;\n+    case Op_MaxHF: emaxsh(dst, src1, src2); break;\n+    case Op_MinHF: eminsh(dst, src1, src2); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    case Op_MaxVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n+    case Op_MinVHF: evminph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    case Op_MaxVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n+    case Op_MinVHF: evminph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -504,0 +504,5 @@\n+  void efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2);\n+\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -966,0 +966,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n@@ -1002,0 +1003,1 @@\n+      _features &= ~CPU_AVX512_FP16;\n@@ -3068,0 +3070,3 @@\n+\n+    if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+      result |= CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,1 +278,3 @@\n-                           : 11;\n+                           : 2,\n+              avx512_fp16  : 1,\n+                           : 8;\n@@ -403,1 +405,2 @@\n-    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/\n+    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n+    decl(AVX512_FP16,       \"avx512_fp16\",       60) \/* AVX512 FP16 ISA support*\/\n@@ -720,0 +723,1 @@\n+  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1464,0 +1464,14 @@\n+    case Op_AddHF:\n+    case Op_DivHF:\n+    case Op_FmaHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MulHF:\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n+    case Op_SubHF:\n+    case Op_SqrtHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -1729,0 +1743,12 @@\n+    case Op_AddVHF:\n+    case Op_DivVHF:\n+    case Op_FmaVHF:\n+    case Op_MaxVHF:\n+    case Op_MinVHF:\n+    case Op_MulVHF:\n+    case Op_SubVHF:\n+    case Op_SqrtVHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -10383,0 +10409,188 @@\n+\n+instruct reinterpretS2H(regF dst, rRegI src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2HFAndS2HF(regF dst, regF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretH2S(rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_sqrt_fp16(regF dst, regF src)\n+%{\n+  match(Set dst (SqrtHF src));\n+  format %{ \"esqrtsh $dst, $src\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ esqrtsh($dst$$XMMRegister, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_binOps_fp16(regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (SubHF src1 src2));\n+  format %{ \"efp16sh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ efp16sh(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_fma_fp16(regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (FmaHF  src2 (Binary dst src1)));\n+  effect(DEF dst);\n+  format %{ \"evfmash $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    __ efmadd132sh($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_abs_fp16_reg(vec dst, vec src, rRegI rtmp, vec xtmp)\n+%{\n+  match(Set dst (AbsVHF src));\n+  format %{ \"evabsph_reg $dst, $src !\\t using $rtmp and $xtmp as TEMP\" %}\n+  effect(TEMP rtmp, TEMP xtmp);\n+  ins_cost(150);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ movl($rtmp$$Register, 0x7FFF7FFF);\n+    __ vpbroadcast(T_FLOAT, $xtmp$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    __ vpand($dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_abs_fp16_mem(vec dst, memory src, rRegI rtmp, vec xtmp)\n+%{\n+  match(Set dst (AbsVHF src));\n+  effect(TEMP rtmp, TEMP xtmp);\n+  format %{ \"evabsph_reg $dst, $src !\\t using $rtmp and $xtmp as TEMP\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ movl($rtmp$$Register, 0x7FFF7FFF);\n+    __ vpbroadcast(T_FLOAT, $xtmp$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    __ vpand($dst$$XMMRegister, $xtmp$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sqrt_fp16_reg(vec dst, vec src)\n+%{\n+  match(Set dst (SqrtVHF src));\n+  format %{ \"evsqrtph_reg $dst, $src\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evsqrtph($dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sqrt_fp16_mem(vec dst, memory src)\n+%{\n+  match(Set dst (SqrtVHF (VectorReinterpret (LoadVector src))));\n+  format %{ \"evsqrtph_mem $dst, $src\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evsqrtph($dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_binOps_fp16_reg(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (AddVHF src1 src2));\n+  match(Set dst (DivVHF src1 src2));\n+  match(Set dst (MaxVHF src1 src2));\n+  match(Set dst (MinVHF src1 src2));\n+  match(Set dst (MulVHF src1 src2));\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"evbinopfp16_reg $dst, $src1, $src2\" %}\n+  ins_cost(450);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_binOps_fp16_mem(vec dst, vec src1, memory src2)\n+%{\n+  match(Set dst (AddVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (DivVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MaxVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MinVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MulVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (SubVHF src1 (VectorReinterpret (LoadVector src2))));\n+  format %{ \"evbinopfp16_mem $dst, $src1, $src2\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$Address, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct vector_fma_fp16_reg(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (FmaVHF src2 (Binary dst src1)));\n+  effect(DEF dst);\n+  format %{ \"evfmaph_reg $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_cost(450);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmadd132ph($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_fmah_fp16_mem(vec dst, memory src1, vec src2)\n+%{\n+  match(Set dst (FmaVHF src2 (Binary dst (VectorReinterpret (LoadVector src1)))));\n+  effect(DEF dst);\n+  format %{ \"evfmaph_mem $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmadd132ph($dst$$XMMRegister, $src2$$XMMRegister, $src1$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":214,"deletions":0,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -419,0 +419,1 @@\n+  static void restore_loader_data() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -959,0 +959,1 @@\n+    _jdk_internal_NullRestrictedArray,\n@@ -2076,0 +2077,4 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NullRestrictedArray_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_NullRestrictedArray;\n+    }\n@@ -4652,0 +4657,7 @@\n+bool ClassFileParser::is_jdk_internal_class_sig(const char* sig) const {\n+  if (strstr(sig, vmSymbols::java_lang_Float16_signature()->as_C_string())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -5597,0 +5609,3 @@\n+  if (_has_null_restricted_array) {\n+    ik->set_has_null_restricted_array();\n+  }\n@@ -5873,0 +5888,1 @@\n+  _has_null_restricted_array(false),\n@@ -6360,0 +6376,8 @@\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_NullRestrictedArray)) {\n+      _has_null_restricted_array = true;\n+      _is_implicitly_constructible = _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible);\n+    }\n+    \/\/ Implicit constructibility and null restriction are sufficient to guarantee atomic updates to value based boxed primitives.\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ValueBased) && _has_null_restricted_array && _is_implicitly_constructible) {\n+      _must_be_atomic = false;\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  bool _has_null_restricted_array;\n@@ -224,0 +225,2 @@\n+  bool is_jdk_internal_class_sig(const char* sig) const;\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -198,0 +198,25 @@\n+                                                                                                                        \\\n+  \/* Float16 intrinsics, similar to what we have in Math. *\/                                                            \\\n+  \/* All names for Float16 binary operations *\/                                                                         \\\n+  do_name(add_name, \"add\")                                                                                              \\\n+  do_name(subtract_name, \"subtract\")                                                                                    \\\n+  do_name(multiply_name, \"multiply\")                                                                                    \\\n+  do_name(divide_name, \"divide\")                                                                                        \\\n+  do_name(neg_name, \"negate\")                                                                                           \\\n+  \/* Float16 signatures *\/                                                                                              \\\n+  do_signature(float16_float16_signature, \"(Ljava\/lang\/Float16;)Ljava\/lang\/Float16;\")                                   \\\n+  do_signature(float16_2_float16_signature, \"(Ljava\/lang\/Float16;Ljava\/lang\/Float16;)Ljava\/lang\/Float16;\")              \\\n+  do_signature(float16_3_float16_signature, \"(Ljava\/lang\/Float16;Ljava\/lang\/Float16;Ljava\/lang\/Float16;)Ljava\/lang\/Float16;\") \\\n+  \/* Float16 intrinsics for binary operations *\/                                                                        \\\n+  do_intrinsic(_add_float16,              java_lang_Float16,      add_name,         float16_2_float16_signature,  F_S)  \\\n+  do_intrinsic(_subtract_float16,         java_lang_Float16,      subtract_name,    float16_2_float16_signature,  F_S)  \\\n+  do_intrinsic(_multiply_float16,         java_lang_Float16,      multiply_name,    float16_2_float16_signature,  F_S)  \\\n+  do_intrinsic(_divide_float16,           java_lang_Float16,      divide_name,      float16_2_float16_signature,  F_S)  \\\n+  do_intrinsic(_max_float16,              java_lang_Float16,      max_name,         float16_2_float16_signature,  F_S)  \\\n+  do_intrinsic(_min_float16,              java_lang_Float16,      min_name,         float16_2_float16_signature,  F_S)  \\\n+  \/* Float16 intrinsics for unary operations *\/                                                                         \\\n+  do_intrinsic(_abs_float16,              java_lang_Float16,      abs_name,   float16_float16_signature,         F_S)   \\\n+  do_intrinsic(_neg_float16,              java_lang_Float16,      neg_name,   float16_float16_signature,         F_S)   \\\n+  do_intrinsic(_sqrt_float16,             java_lang_Float16,      sqrt_name,  float16_float16_signature,         F_S)   \\\n+  \/* Float16 intrinsics for ternary operations *\/                                                                       \\\n+  do_intrinsic(_fma_float16,              java_lang_Float16,      fma_name,   float16_3_float16_signature,       F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  template(java_lang_Float16,                         \"java\/lang\/Float16\")                        \\\n+  template(java_lang_Float16_signature,               \"Ljava\/lang\/Float16;\")                      \\\n@@ -260,0 +262,1 @@\n+  template(jdk_internal_vm_annotation_NullRestrictedArray_signature,         \"Ljdk\/internal\/vm\/annotation\/NullRestrictedArray;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,2 +91,3 @@\n-    \/\/ has been aborted for any reason.\n-    bool yield_if_necessary() {\n+    \/\/ has been aborted for any reason. Yielded is set if there has been an actual\n+    \/\/ yield for a pause.\n+    bool yield_if_necessary(bool& yielded) {\n@@ -95,1 +96,1 @@\n-        _cm->do_yield_check();\n+        yielded = _cm->do_yield_check();\n@@ -125,1 +126,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -193,1 +195,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -213,1 +216,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded = true;\n+        bool mark_aborted = yield_if_necessary(yielded);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -367,0 +367,1 @@\n+  arrayOop obj = nullptr;\n@@ -368,1 +369,8 @@\n-  arrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n+  bool has_flat_layout = klass->is_inline_klass() &&\n+    InstanceKlass::cast(klass)->is_implicitly_constructible() &&\n+    InstanceKlass::cast(klass)->has_null_restricted_array();\n+  if (has_flat_layout) {\n+    obj = oopFactory::new_valueArray(klass, size, CHECK);\n+  } else {\n+    obj = oopFactory::new_objArray(klass, size, CHECK);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -555,0 +555,3 @@\n+  if (vmSymbols::java_lang_Float16() == name()) {\n+    Arguments::set_enable_preview();\n+  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -383,0 +383,3 @@\n+  bool has_null_restricted_array() const   { return _misc_flags.has_null_restricted_array(); }\n+  void set_has_null_restricted_array()     { _misc_flags.set_has_null_restricted_array(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-    flag(is_implicitly_constructible        , 1 << 19) \/* the class has the ImplicitlyConstrutible annotation *\/\n+    flag(is_implicitly_constructible        , 1 << 19) \/* the class has the ImplicitlyConstrutible annotation *\/ \\\n+    flag(has_null_restricted_array          , 1 << 20) \/* the class has the NullRestrictedArray annotation *\/\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,0 +141,8 @@\n+\/\/------------------------------AddHFNode---------------------------------------\n+\/\/ Add 2 half-precision floats\n+class AddHFNode : public AddFNode {\n+public:\n+  AddHFNode( Node *in1, Node *in2 ) : AddFNode(in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -402,0 +410,20 @@\n+\/\/------------------------------MaxHFNode--------------------------------------\n+\/\/ Maximum of 2 half floats.\n+class MaxHFNode : public MaxFNode {\n+public:\n+  MaxHFNode(Node* in1, Node* in2) : MaxFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n+\/\/------------------------------MinHFNode---------------------------------------\n+\/\/ Minimum of 2 half floats.\n+class MinHFNode : public MinFNode {\n+public:\n+  MinHFNode(Node* in1, Node* in2) : MinFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -608,0 +608,30 @@\n+  case vmIntrinsics::_add_float16:\n+    if (!Matcher::match_rule_supported(Op_AddHF)) return false;\n+    break;\n+  case vmIntrinsics::_subtract_float16:\n+    if (!Matcher::match_rule_supported(Op_SubHF)) return false;\n+    break;\n+  case vmIntrinsics::_multiply_float16:\n+    if (!Matcher::match_rule_supported(Op_MulHF)) return false;\n+    break;\n+  case vmIntrinsics::_divide_float16:\n+    if (!Matcher::match_rule_supported(Op_DivHF)) return false;\n+    break;\n+    case vmIntrinsics::_max_float16:\n+    if (!Matcher::match_rule_supported(Op_MaxHF)) return false;\n+    break;\n+  case vmIntrinsics::_min_float16:\n+    if (!Matcher::match_rule_supported(Op_MinHF)) return false;\n+    break;\n+  case vmIntrinsics::_abs_float16:\n+    if (!Matcher::match_rule_supported(Op_AbsHF)) return false;\n+    break;\n+  case vmIntrinsics::_neg_float16:\n+    if (!Matcher::match_rule_supported(Op_NegHF)) return false;\n+    break;\n+  case vmIntrinsics::_sqrt_float16:\n+    if (!Matcher::match_rule_supported(Op_SqrtHF)) return false;\n+    break;\n+  case vmIntrinsics::_fma_float16:\n+    if (!Matcher::match_rule_supported(Op_FmaHF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+macro(AbsHF)\n@@ -39,0 +40,1 @@\n+macro(AddHF)\n@@ -169,0 +171,1 @@\n+macro(DivHF)\n@@ -188,0 +191,1 @@\n+macro(FmaHF)\n@@ -225,0 +229,1 @@\n+macro(MaxHF)\n@@ -240,0 +245,1 @@\n+macro(MinHF)\n@@ -256,0 +262,1 @@\n+macro(MulHF)\n@@ -267,0 +274,1 @@\n+macro(NegHF)\n@@ -340,0 +348,1 @@\n+macro(SqrtHF)\n@@ -360,0 +369,1 @@\n+macro(SubHF)\n@@ -383,0 +393,1 @@\n+macro(AddVHF)\n@@ -391,0 +402,1 @@\n+macro(SubVHF)\n@@ -399,0 +411,1 @@\n+macro(MulVHF)\n@@ -406,0 +419,2 @@\n+macro(FmaVHF)\n+macro(DivVHF)\n@@ -412,0 +427,1 @@\n+macro(AbsVHF)\n@@ -418,0 +434,1 @@\n+macro(NegVHF)\n@@ -420,0 +437,1 @@\n+macro(SqrtVHF)\n@@ -440,0 +458,2 @@\n+macro(MinVHF)\n+macro(MaxVHF)\n@@ -487,0 +507,2 @@\n+macro(ReinterpretS2HF)\n+macro(ReinterpretHF2S)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3680,0 +3680,11 @@\n+  \/\/ Count all half-precision float operations that may use the FPU\n+  case Op_AddHF:\n+  case Op_SubHF:\n+  case Op_MulHF:\n+  case Op_DivHF:\n+  case Op_MaxHF:\n+  case Op_MinHF:\n+  case Op_AbsHF:\n+  case Op_NegHF:\n+  case Op_SqrtHF:\n+  case Op_FmaHF:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,3 +62,0 @@\n-  \/\/ Get the klass defining the field layout of the inline type\n-  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n-\n@@ -89,0 +86,3 @@\n+  \/\/ Get the klass defining the field layout of the inline type\n+  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -549,1 +549,10 @@\n-\n+  case vmIntrinsics::_abs_float16:\n+  case vmIntrinsics::_neg_float16:\n+  case vmIntrinsics::_sqrt_float16:             return inline_fp16_operations(intrinsic_id(), 1);\n+  case vmIntrinsics::_add_float16:\n+  case vmIntrinsics::_subtract_float16:\n+  case vmIntrinsics::_multiply_float16:\n+  case vmIntrinsics::_divide_float16:\n+  case vmIntrinsics::_max_float16:\n+  case vmIntrinsics::_min_float16:              return inline_fp16_operations(intrinsic_id(), 2);\n+  case vmIntrinsics::_fma_float16:              return inline_fp16_operations(intrinsic_id(), 3);\n@@ -5065,0 +5074,67 @@\n+bool LibraryCallKit::inline_fp16_operations(vmIntrinsics::ID id, int num_args) {\n+  if (!Matcher::match_rule_supported(Op_ReinterpretS2HF) ||\n+      !Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+    return false;\n+  }\n+\n+  \/\/ Inputs\n+  Node* val1 = nullptr;\n+  Node* val2 = nullptr;\n+  Node* val3 = nullptr;\n+  \/\/ Transformed nodes\n+  Node* fld1 = nullptr;\n+  Node* fld2 = nullptr;\n+  Node* fld3 = nullptr;\n+  switch(num_args) {\n+    case 3:\n+      val3 = argument(2);\n+      if (!val3->is_InlineType()) {\n+        return false;\n+      }\n+      fld3 = _gvn.transform(new ReinterpretS2HFNode(val3->as_InlineType()->field_value(0)));\n+    \/\/ fall-through\n+    case 2:\n+      val2 = argument(1);\n+      if (!val2->is_InlineType()) {\n+        return false;\n+      }\n+      fld2 = _gvn.transform(new ReinterpretS2HFNode(val2->as_InlineType()->field_value(0)));\n+    \/\/ fall-through\n+    case 1:\n+      val1 = argument(0);\n+      if (!val1->is_InlineType()) {\n+        return false;\n+      }\n+      fld1 = _gvn.transform(new ReinterpretS2HFNode(val1->as_InlineType()->field_value(0)));\n+      break;\n+    default: fatal(\"Unsupported number of arguments %d\", num_args);\n+  }\n+\n+  Node* result = nullptr;\n+  switch (id) {\n+  \/\/ Unary operations\n+  case vmIntrinsics::_abs_float16:       result = _gvn.transform(new AbsHFNode(fld1)); break;\n+  case vmIntrinsics::_neg_float16:       result = _gvn.transform(new NegHFNode(fld1)); break;\n+  case vmIntrinsics::_sqrt_float16:      result = _gvn.transform(new SqrtHFNode(C, control(), fld1)); break;\n+\n+  \/\/ Binary operations\n+  case vmIntrinsics::_add_float16:       result = _gvn.transform(new AddHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_subtract_float16:  result = _gvn.transform(new SubHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_multiply_float16:  result = _gvn.transform(new MulHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_divide_float16:    result = _gvn.transform(new DivHFNode(0, fld1, fld2)); break;\n+  case vmIntrinsics::_max_float16:       result = _gvn.transform(new MaxHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_min_float16:       result = _gvn.transform(new MinHFNode(fld1, fld2));    break;\n+\n+  \/\/ Ternary operations\n+  case vmIntrinsics::_fma_float16:       result = _gvn.transform(new FmaHFNode(control(), fld1, fld2, fld3)); break;\n+  default:\n+    fatal_unexpected_iid(id);\n+    break;\n+  }\n+  InlineTypeNode* box = InlineTypeNode::make_uninitialized(_gvn, val1->as_InlineType()->inline_klass(), true);\n+  Node* short_result  = _gvn.transform(new ReinterpretHF2SNode(result));\n+  box->set_field_value(0, short_result);\n+  set_result(_gvn.transform(box));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+  bool inline_fp16_operations(vmIntrinsics::ID id, int num_args);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6294,0 +6294,1 @@\n+    case Op_DivHF:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2310,0 +2310,1 @@\n+    case Op_FmaHF:\n@@ -2312,0 +2313,1 @@\n+    case Op_FmaVHF:\n@@ -2481,0 +2483,1 @@\n+    case Op_FmaHF:\n@@ -2482,1 +2485,2 @@\n-    case Op_FmaVF: {\n+    case Op_FmaVF:\n+    case Op_FmaVHF: {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2600,2 +2600,2 @@\n-      } else if (opc == Op_SqrtF || opc == Op_SqrtD ||\n-                 opc == Op_AbsF || opc == Op_AbsD ||\n+      } else if (opc == Op_SqrtHF || opc == Op_SqrtF || opc == Op_SqrtD ||\n+                 opc == Op_AbsHF || opc == Op_AbsF || opc == Op_AbsD ||\n@@ -2603,1 +2603,1 @@\n-                 opc == Op_NegF || opc == Op_NegD ||\n+                 opc == Op_NegHF || opc == Op_NegF || opc == Op_NegD ||\n@@ -2633,1 +2633,8 @@\n-      } else if (opc == Op_FmaD || opc == Op_FmaF) {\n+      } else if (opc == Op_ReinterpretS2HF || opc == Op_ReinterpretHF2S) {\n+        assert(n->req() == 2, \"only one input expected\");\n+        BasicType bt = velt_basic_type(n);\n+        const TypeVect* vt = TypeVect::make(bt, vlen);\n+        Node* in = vector_opd(p, 1);\n+        vn = VectorReinterpretNode::make(in, vt, vt);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n+      } else if (opc == Op_FmaD || opc == Op_FmaF || opc == Op_FmaHF) {\n@@ -3343,0 +3350,1 @@\n+  int opc = n->Opcode();\n@@ -3350,1 +3358,1 @@\n-    if (n->Opcode() == Op_LoadUB) {\n+    if (opc == Op_LoadUB) {\n@@ -3360,0 +3368,9 @@\n+\n+  \/\/ First check if the node is a float16 node returning a \"Short\" type.\n+  \/\/ If it is, then it needs to be checked before the next condition.\n+  \/\/ Else it might return TypeInt::INT for float16 nodes instead of TypeInt::SHORT\n+  \/\/ which could cause assertion errors in VectorCastNode::opcode().\n+  if (opc == Op_ReinterpretHF2S || VectorNode::is_float16_node(opc)) {\n+    return TypeInt::SHORT;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  case Op_AddHF: return (bt == T_SHORT ? Op_AddVHF : 0);\n@@ -62,0 +63,1 @@\n+  case Op_SubHF: return (bt == T_SHORT ? Op_SubVHF : 0);\n@@ -76,0 +78,2 @@\n+  case Op_MulHF:\n+    return (bt == T_SHORT ? Op_MulVHF : 0);\n@@ -84,0 +88,2 @@\n+  case Op_FmaHF:\n+    return (bt == T_SHORT ? Op_FmaVHF : 0);\n@@ -90,0 +96,2 @@\n+  case Op_DivHF:\n+    return (bt == T_SHORT ? Op_DivVHF : 0);\n@@ -116,0 +124,2 @@\n+  case Op_MinHF:\n+    return (bt == T_SHORT ? Op_MinVHF : 0);\n@@ -131,0 +141,2 @@\n+  case Op_MaxHF:\n+    return (bt == T_SHORT ? Op_MaxVHF : 0);\n@@ -139,0 +151,2 @@\n+  case Op_AbsHF:\n+    return (bt == T_SHORT ? Op_AbsVHF : 0);\n@@ -152,0 +166,2 @@\n+  case Op_NegHF:\n+    return (bt == T_SHORT ? Op_NegVHF : 0);\n@@ -160,0 +176,2 @@\n+  case Op_SqrtHF:\n+    return (bt == T_SHORT ? Op_SqrtVHF : 0);\n@@ -270,0 +288,3 @@\n+  case Op_ReinterpretS2HF:\n+  case Op_ReinterpretHF2S:\n+    return Op_VectorReinterpret;\n@@ -382,0 +403,4 @@\n+    case Op_MinVHF:\n+      return Op_MinHF;\n+    case Op_MaxVHF:\n+      return Op_MaxHF;\n@@ -576,0 +601,20 @@\n+bool VectorNode::is_float16_node(int opc) {\n+  switch (opc) {\n+  case Op_AddHF:\n+  case Op_SubHF:\n+  case Op_MulHF:\n+  case Op_DivHF:\n+  case Op_MinHF:\n+  case Op_MaxHF:\n+  case Op_SqrtHF:\n+  case Op_AbsHF:\n+  case Op_NegHF:\n+  case Op_FmaHF:\n+  case Op_ConvF2HF:\n+  case Op_ReinterpretS2HF:\n+     return true;\n+  default:\n+     return false;\n+  }\n+}\n+\n@@ -626,4 +671,4 @@\n-  case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:\n-  case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:\n-  case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:\n-  case Op_DivF: case Op_DivD:\n+  case Op_AddI: case Op_AddHF: case Op_AddL: case Op_AddF: case Op_AddD:\n+  case Op_SubI: case Op_SubL: case Op_SubHF: case Op_SubF: case Op_SubD:\n+  case Op_MulI: case Op_MulL: case Op_MulHF: case Op_MulF: case Op_MulD:\n+  case Op_DivHF: case Op_DivF: case Op_DivD:\n@@ -683,23 +728,27 @@\n-  case Op_AddVB: return new AddVBNode(n1, n2, vt);\n-  case Op_AddVS: return new AddVSNode(n1, n2, vt);\n-  case Op_AddVI: return new AddVINode(n1, n2, vt);\n-  case Op_AddVL: return new AddVLNode(n1, n2, vt);\n-  case Op_AddVF: return new AddVFNode(n1, n2, vt);\n-  case Op_AddVD: return new AddVDNode(n1, n2, vt);\n-\n-  case Op_SubVB: return new SubVBNode(n1, n2, vt);\n-  case Op_SubVS: return new SubVSNode(n1, n2, vt);\n-  case Op_SubVI: return new SubVINode(n1, n2, vt);\n-  case Op_SubVL: return new SubVLNode(n1, n2, vt);\n-  case Op_SubVF: return new SubVFNode(n1, n2, vt);\n-  case Op_SubVD: return new SubVDNode(n1, n2, vt);\n-\n-  case Op_MulVB: return new MulVBNode(n1, n2, vt);\n-  case Op_MulVS: return new MulVSNode(n1, n2, vt);\n-  case Op_MulVI: return new MulVINode(n1, n2, vt);\n-  case Op_MulVL: return new MulVLNode(n1, n2, vt);\n-  case Op_MulVF: return new MulVFNode(n1, n2, vt);\n-  case Op_MulVD: return new MulVDNode(n1, n2, vt);\n-\n-  case Op_DivVF: return new DivVFNode(n1, n2, vt);\n-  case Op_DivVD: return new DivVDNode(n1, n2, vt);\n+  case Op_AddVB:  return new AddVBNode(n1, n2, vt);\n+  case Op_AddVHF: return new AddVHFNode(n1, n2, vt);\n+  case Op_AddVS:  return new AddVSNode(n1, n2, vt);\n+  case Op_AddVI:  return new AddVINode(n1, n2, vt);\n+  case Op_AddVL:  return new AddVLNode(n1, n2, vt);\n+  case Op_AddVF:  return new AddVFNode(n1, n2, vt);\n+  case Op_AddVD:  return new AddVDNode(n1, n2, vt);\n+\n+  case Op_SubVB:  return new SubVBNode(n1, n2, vt);\n+  case Op_SubVS:  return new SubVSNode(n1, n2, vt);\n+  case Op_SubVI:  return new SubVINode(n1, n2, vt);\n+  case Op_SubVL:  return new SubVLNode(n1, n2, vt);\n+  case Op_SubVHF: return new SubVHFNode(n1, n2, vt);\n+  case Op_SubVF:  return new SubVFNode(n1, n2, vt);\n+  case Op_SubVD:  return new SubVDNode(n1, n2, vt);\n+\n+  case Op_MulVB:  return new MulVBNode(n1, n2, vt);\n+  case Op_MulVS:  return new MulVSNode(n1, n2, vt);\n+  case Op_MulVI:  return new MulVINode(n1, n2, vt);\n+  case Op_MulVL:  return new MulVLNode(n1, n2, vt);\n+  case Op_MulVHF: return new MulVHFNode(n1, n2, vt);\n+  case Op_MulVF:  return new MulVFNode(n1, n2, vt);\n+  case Op_MulVD:  return new MulVDNode(n1, n2, vt);\n+\n+  case Op_DivVHF: return new DivVHFNode(n1, n2, vt);\n+  case Op_DivVF:  return new DivVFNode(n1, n2, vt);\n+  case Op_DivVD:  return new DivVDNode(n1, n2, vt);\n@@ -710,6 +759,10 @@\n-  case Op_AbsVF: return new AbsVFNode(n1, vt);\n-  case Op_AbsVD: return new AbsVDNode(n1, vt);\n-  case Op_AbsVB: return new AbsVBNode(n1, vt);\n-  case Op_AbsVS: return new AbsVSNode(n1, vt);\n-  case Op_AbsVI: return new AbsVINode(n1, vt);\n-  case Op_AbsVL: return new AbsVLNode(n1, vt);\n+  case Op_MinVHF: return new MinVHFNode(n1, n2, vt);\n+  case Op_MaxVHF: return new MaxVHFNode(n1, n2, vt);\n+\n+  case Op_AbsVF : return new AbsVFNode(n1, vt);\n+  case Op_AbsVD : return new AbsVDNode(n1, vt);\n+  case Op_AbsVHF: return new AbsVHFNode(n1, vt);\n+  case Op_AbsVB : return new AbsVBNode(n1, vt);\n+  case Op_AbsVS : return new AbsVSNode(n1, vt);\n+  case Op_AbsVI : return new AbsVINode(n1, vt);\n+  case Op_AbsVL : return new AbsVLNode(n1, vt);\n@@ -717,4 +770,5 @@\n-  case Op_NegVI: return new NegVINode(n1, vt);\n-  case Op_NegVL: return new NegVLNode(n1, vt);\n-  case Op_NegVF: return new NegVFNode(n1, vt);\n-  case Op_NegVD: return new NegVDNode(n1, vt);\n+  case Op_NegVI : return new NegVINode(n1, vt);\n+  case Op_NegVL : return new NegVLNode(n1, vt);\n+  case Op_NegVF : return new NegVFNode(n1, vt);\n+  case Op_NegVD : return new NegVDNode(n1, vt);\n+  case Op_NegVHF: return new NegVHFNode(n1, vt);\n@@ -725,2 +779,3 @@\n-  case Op_SqrtVF: return new SqrtVFNode(n1, vt);\n-  case Op_SqrtVD: return new SqrtVDNode(n1, vt);\n+  case Op_SqrtVHF : return new SqrtVHFNode(n1, vt);\n+  case Op_SqrtVF  : return new SqrtVFNode(n1, vt);\n+  case Op_SqrtVD  : return new SqrtVDNode(n1, vt);\n@@ -788,0 +843,1 @@\n+  case Op_FmaVHF: return new FmaVHFNode(n1, n2, n3, vt);\n@@ -1666,0 +1722,4 @@\n+VectorNode* VectorReinterpretNode::make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt) {\n+  return new VectorReinterpretNode(n, dst_vt, src_vt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":99,"deletions":39,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+  static bool is_float16_node(int opc);\n+\n@@ -187,0 +189,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add float\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -305,0 +315,8 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector subtract half float\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -308,1 +326,1 @@\n- public:\n+public:\n@@ -316,1 +334,1 @@\n- public:\n+public:\n@@ -353,0 +371,8 @@\n+\/\/------------------------------MulVFNode--------------------------------------\n+\/\/ Vector multiply half float\n+class MulVHFNode : public VectorNode {\n+public:\n+  MulVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -403,0 +429,8 @@\n+\/\/------------------------------FmaVHFNode-------------------------------------\n+\/\/ Vector fused-multiply-add half-precision float\n+class FmaVHFNode : public FmaVNode {\n+public:\n+  FmaVHFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : FmaVNode(in1, in2, in3, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -435,0 +469,8 @@\n+\/\/------------------------------DivVHFNode-------------------------------------\n+\/\/ Vector divide half float\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -438,1 +480,1 @@\n- public:\n+public:\n@@ -446,1 +488,1 @@\n- public:\n+public:\n@@ -478,1 +520,1 @@\n- public:\n+public:\n@@ -483,0 +525,16 @@\n+\/\/------------------------------MinVHFNode------------------------------------\n+\/\/ Vector Min for half floats\n+class MinVHFNode : public VectorNode {\n+public:\n+  MinVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------MaxVHFNode------------------------------------\n+\/\/ Vector Max for half floats\n+class MaxVHFNode : public VectorNode {\n+public:\n+  MaxVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -502,1 +560,1 @@\n- public:\n+public:\n@@ -510,2 +568,10 @@\n- public:\n-  AbsVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}\n+public:\n+  AbsVDNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------AbsVHFNode-------------------------------------\n+\/\/ Vector Abs half-precision float\n+class AbsVHFNode : public VectorNode {\n+public:\n+  AbsVHFNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n@@ -548,1 +614,1 @@\n- public:\n+public:\n@@ -556,1 +622,1 @@\n- public:\n+public:\n@@ -561,0 +627,8 @@\n+\/\/------------------------------NegVHFNode-------------------------------------\n+\/\/ Vector Neg half-precision float\n+class NegVHFNode : public NegVNode {\n+public:\n+  NegVHFNode(Node* in, const TypeVect* vt) : NegVNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -582,2 +656,2 @@\n- public:\n-  SqrtVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}\n+public:\n+  SqrtVFNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n@@ -586,0 +660,9 @@\n+\n+\/\/------------------------------SqrtVHFNode-------------------------------------\n+\/\/ Vector Sqrt half-precision float\n+class SqrtVHFNode : public VectorNode {\n+public:\n+  SqrtVHFNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -597,1 +680,1 @@\n- public:\n+public:\n@@ -1591,0 +1674,2 @@\n+\n+  static VectorNode* make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":98,"deletions":13,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1406,0 +1406,1 @@\n+  declare_c2_type(AddHFNode, AddNode)                                     \\\n@@ -1419,0 +1420,2 @@\n+  declare_c2_type(MaxHFNode, MaxFNode)                                    \\\n+  declare_c2_type(MinHFNode, MinFNode)                                    \\\n@@ -1424,0 +1427,2 @@\n+  declare_c2_type(ReinterpretS2HFNode, Node)                              \\\n+  declare_c2_type(ReinterpretHF2SNode, Node)                              \\\n@@ -1520,0 +1525,1 @@\n+  declare_c2_type(DivHFNode, DivFNode)                                    \\\n@@ -1616,0 +1622,1 @@\n+  declare_c2_type(MulHFNode, MulFNode)                                    \\\n@@ -1637,0 +1644,1 @@\n+  declare_c2_type(SubHFNode, SubFNode)                                    \\\n@@ -1654,0 +1662,1 @@\n+  declare_c2_type(AbsHFNode, AbsFNode)                                    \\\n@@ -1660,0 +1669,1 @@\n+  declare_c2_type(NegHFNode, NegFNode)                                    \\\n@@ -1665,0 +1675,1 @@\n+  declare_c2_type(SqrtHFNode, SqrtFNode)                                  \\\n@@ -1671,0 +1682,1 @@\n+  declare_c2_type(AbsVHFNode, VectorNode)                                 \\\n@@ -1682,0 +1694,1 @@\n+  declare_c2_type(AddVHFNode, VectorNode)                                 \\\n@@ -1689,0 +1702,1 @@\n+  declare_c2_type(SubVHFNode, VectorNode)                                 \\\n@@ -1691,0 +1705,3 @@\n+  declare_c2_type(SqrtVHFNode, VectorNode)                                \\\n+  declare_c2_type(SqrtVFNode, VectorNode)                                 \\\n+  declare_c2_type(SqrtVDNode, VectorNode)                                 \\\n@@ -1697,0 +1714,1 @@\n+  declare_c2_type(MulVHFNode, VectorNode)                                 \\\n@@ -1705,0 +1723,1 @@\n+  declare_c2_type(NegVHFNode, NegVNode)                                   \\\n@@ -1707,0 +1726,1 @@\n+  declare_c2_type(FmaVHFNode, VectorNode)                                 \\\n@@ -1713,0 +1733,1 @@\n+  declare_c2_type(DivVHFNode, VectorNode)                                 \\\n@@ -1739,0 +1760,2 @@\n+  declare_c2_type(MaxVHFNode, VectorNode)                                 \\\n+  declare_c2_type(MinVHFNode, VectorNode)                                 \\\n@@ -1772,0 +1795,1 @@\n+  declare_c2_type(FmaHFNode, FmaFNode)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -337,0 +337,4 @@\n+    private static final int P_F16 = Float16.PRECISION;  \/\/ 11\n+    private static final int Q_MIN_F16 = Float16.MIN_EXPONENT - (P_F16 - 1);  \/\/ -24\n+    private static final int Q_MAX_F16 = Float16.MAX_EXPONENT - (P_F16 - 1);  \/\/ 5\n+\n@@ -3779,0 +3783,94 @@\n+    \/**\n+     * Converts this {@code BigDecimal} to a {@code Float16}.\n+     * This conversion is similar to the\n+     * <i>narrowing primitive conversion<\/i> from {@code double} to\n+     * {@code float} as defined in\n+     * <cite>The Java Language Specification<\/cite>:\n+     * if this {@code BigDecimal} has too great a\n+     * magnitude to represent as a {@code Float16}, it will be\n+     * converted to {@link Float16#NEGATIVE_INFINITY} or {@link\n+     * Float16#POSITIVE_INFINITY} as appropriate.  Note that even when\n+     * the return value is finite, this conversion can lose\n+     * information about the precision of the {@code BigDecimal}\n+     * value.Float16\n+     *\n+     * @return this {@code BigDecimal} converted to a {@code Float16}.\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    public Float16 float16Value() {\n+        \/* For details, see the extensive comments in doubleValue(). *\/\n+        if (intCompact != INFLATED) {\n+            Float16 v = Float16.valueOf(intCompact);\n+            if (scale == 0) {\n+                return v;\n+            }\n+            \/*\n+             * The discussion for the double case also applies here. That is,\n+             * the following test is precise for all long values, but here\n+             * Long.MAX_VALUE is not an issue.\n+             *\/\n+            if (v.longValue() == intCompact) {\n+                if (0 < scale && scale < FLOAT16_10_POW.length) {\n+                    return Float16.divide(v, FLOAT16_10_POW[scale]);\n+                }\n+                if (0 > scale && scale > -FLOAT16_10_POW.length) {\n+                    return Float16.multiply(v, FLOAT16_10_POW[-scale]);\n+                }\n+            }\n+        }\n+        return fullFloat16Value();\n+    }\n+\n+    private Float16 fullFloat16Value() {\n+        if (intCompact == 0) {\n+            return Float16.valueOf(0);\n+        }\n+        BigInteger w = unscaledValue().abs();\n+        long qb = w.bitLength() - (long) Math.ceil(scale * L);\n+        Float16 signum = Float16.valueOf(signum());\n+        if (qb < Q_MIN_F16 - 2) {  \/\/ qb < -26\n+            return Float16.multiply(signum, Float16.valueOf(0));\n+        }\n+        if (qb > Q_MAX_F16 + P_F16 + 1) {  \/\/ qb > 17\n+            return Float16.multiply(signum, Float16.POSITIVE_INFINITY);\n+        }\n+        if (scale < 0) {\n+            return Float16.multiply(signum, w.multiply(bigTenToThe(-scale)).float16Value());\n+        }\n+        if (scale == 0) {\n+            return Float16.multiply(signum, w.float16Value());\n+        }\n+        int ql = (int) qb - (P_F16 + 3);\n+        BigInteger pow10 = bigTenToThe(scale);\n+        BigInteger m, n;\n+        if (ql <= 0) {\n+            m = w.shiftLeft(-ql);\n+            n = pow10;\n+        } else {\n+            m = w;\n+            n = pow10.shiftLeft(ql);\n+        }\n+        BigInteger[] qr = m.divideAndRemainder(n);\n+        \/*\n+         * We have\n+         *      2^12 = 2^{P+1} <= i < 2^{P+5} = 2^16\n+         * Contrary to the double and float cases, where we use long and int, resp.,\n+         * here we cannot simply declare i as short, because P + 5 < Short.SIZE\n+         * fails to hold.\n+         * Using int is safe, though.\n+         *\n+         * Further, as Math.scalb(Float16) does not exists, we fall back to\n+         * Math.scalb(double).\n+         *\/\n+        int i = qr[0].intValue();\n+        int sb = qr[1].signum();\n+        int dq = (Integer.SIZE - (P_F16 + 2)) - Integer.numberOfLeadingZeros(i);\n+        int eq = (Q_MIN_F16 - 2) - ql;\n+        if (dq >= eq) {\n+            return Float16.valueOf(signum() * Math.scalb((double) (i | sb), ql));\n+        }\n+        int mask = (1 << eq) - 1;\n+        int j = i >> eq | (Integer.signum(i & mask)) | sb;\n+        return Float16.valueOf(signum() * Math.scalb((double) j, Q_MIN_F16 - 2));\n+    }\n+\n@@ -4153,0 +4251,9 @@\n+    \/**\n+     * Powers of 10 which can be represented exactly in {@code\n+     * Float16}.\n+     *\/\n+    private static final Float16[] FLOAT16_10_POW = {\n+            Float16.valueOf(1), Float16.valueOf(10), Float16.valueOf(100),\n+            Float16.valueOf(1_000), Float16.valueOf(10_000)\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -4397,0 +4397,24 @@\n+    \/**\n+     * Converts this BigInteger to a {@code Float16}.  This\n+     * conversion is similar to the\n+     * <i>narrowing primitive conversion<\/i> from {@code double} to\n+     * {@code float} as defined in\n+     * <cite>The Java Language Specification<\/cite>:\n+     * if this BigInteger has too great a magnitude\n+     * to represent as a {@code Float16}, it will be converted to\n+     * {@link Float16#NEGATIVE_INFINITY} or {@link\n+     * Float16#POSITIVE_INFINITY} as appropriate.  Note that even when\n+     * the return value is finite, this conversion can lose\n+     * information about the precision of the BigInteger value.\n+     *\n+     * @return this BigInteger converted to a {@code Float16}.\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    public Float16 float16Value() {\n+        return signum == 0 || mag.length == 1\n+                ? Float16.valueOf(longValue())  \/\/ might return infinities\n+                : signum > 0\n+                ? Float16.POSITIVE_INFINITY\n+                : Float16.NEGATIVE_INFINITY;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,2 @@\n+        FPHP,\n+        ASIMDHP\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8308363 8336406\n+* @summary Validate compiler IR for FP16 scalar operations.\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver TestFP16ScalarOps\n+*\/\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static java.lang.Float16.*;\n+\n+public class TestFP16ScalarOps {\n+    private static final int count = 1024;\n+\n+    private short[] src;\n+    private short[] dst;\n+    private short res;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--enable-preview\");\n+    }\n+\n+    public TestFP16ScalarOps() {\n+        src = new short[count];\n+        dst = new short[count];\n+        for (int i = 0; i < count; i++) {\n+            src[i] = Float.floatToFloat16(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testAdd1() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.add(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testAdd2() {\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        res = float16ToRawShortBits(Float16.add(Float16.add(Float16.add(Float16.add(hf0, hf1), hf2), hf3), hf4));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.SUB_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testSub() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.subtract(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.MUL_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMul() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.multiply(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.DIV_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testDiv() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.divide(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.MAX_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMax() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.max(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.MIN_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMin() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.min(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ABS_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testAbs() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.abs(shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.NEG_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testNeg() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.negate(shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SQRT_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.SQRT_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testSqrt() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.sqrt(shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.FMA_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testFma() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            Float16 in = shortBitsToFloat16(src[i]);\n+            res = Float16.fma(in, in, in) ;\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFP16ScalarOps.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -165,0 +165,5 @@\n+    public static final String ABS_HF = PREFIX + \"ABS_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_HF, \"AbsHF\");\n+    }\n+\n@@ -207,0 +212,5 @@\n+    public static final String ABS_VHF = PREFIX + \"ABS_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_VHF, \"AbsVHF\");\n+    }\n+\n@@ -222,0 +232,5 @@\n+    public static final String ADD_HF = PREFIX + \"ADD_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_HF, \"AddHF\");\n+    }\n+\n@@ -237,0 +252,5 @@\n+    public static final String ADD_VHF = PREFIX + \"ADD_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VHF, \"AddVHF\");\n+    }\n+\n@@ -455,0 +475,5 @@\n+    public static final String CONV_F2HF = PREFIX + \"CONV_F2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2HF, \"ConvF2HF\");\n+    }\n+\n@@ -465,0 +490,5 @@\n+    public static final String CONV_HF2F = PREFIX + \"CONV_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_HF2F, \"ConvHF2F\");\n+    }\n+\n@@ -549,0 +579,10 @@\n+    public static final String FMA_VHF = PREFIX + \"FMA_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_VHF, \"FmaVHF\");\n+    }\n+\n+    public static final String FMA_HF = PREFIX + \"FMA_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_HF, \"FmaHF\");\n+    }\n+\n@@ -890,0 +930,5 @@\n+    public static final String MAX_VHF = PREFIX + \"MAX_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_VHF, \"MaxVHF\");\n+    }\n+\n@@ -965,0 +1010,10 @@\n+    public static final String MIN_HF = PREFIX + \"MIN_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_HF, \"MinHF\");\n+    }\n+\n+    public static final String MAX_HF = PREFIX + \"MAX_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_HF, \"MaxHF\");\n+    }\n+\n@@ -980,0 +1035,5 @@\n+    public static final String MIN_VHF = PREFIX + \"MIN_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_VHF, \"MinVHF\");\n+    }\n+\n@@ -1016,0 +1076,5 @@\n+    public static final String MUL_HF = PREFIX + \"MUL_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HF, \"MulHF\");\n+    }\n+\n@@ -1041,0 +1106,5 @@\n+    public static final String MUL_VHF = PREFIX + \"MUL_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VHF, \"MulVHF\");\n+    }\n+\n@@ -1086,0 +1156,5 @@\n+    public static final String NEG_HF = PREFIX + \"NEG_HF\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(NEG_HF, \"NegHF\");\n+    }\n+\n@@ -1096,0 +1171,5 @@\n+    public static final String NEG_VHF = PREFIX + \"NEG_VHF\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(NEG_VHF, \"NegVHF\");\n+    }\n+\n@@ -1210,0 +1290,10 @@\n+    public static final String REINTERPRET_S2HF = PREFIX + \"REINTERPRET_S2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_S2HF, \"ReinterpretS2HF\");\n+    }\n+\n+    public static final String REINTERPRET_HF2S = PREFIX + \"REINTERPRET_HF2S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_HF2S, \"ReinterpretHF2S\");\n+    }\n+\n@@ -1376,0 +1466,10 @@\n+    public static final String SQRT_HF = PREFIX + \"SQRT_HF\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(SQRT_HF, \"SqrtHF\");\n+    }\n+\n+    public static final String SQRT_F = PREFIX + \"SQRT_F\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(SQRT_F, \"SqrtF\");\n+    }\n+\n@@ -1386,0 +1486,5 @@\n+    public static final String SQRT_VHF = PREFIX + \"SQRT_VHF\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(SQRT_VHF, \"SqrtVHF\");\n+    }\n+\n@@ -1517,0 +1622,5 @@\n+    public static final String SUB_HF = PREFIX + \"SUB_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_HF, \"SubHF\");\n+    }\n+\n@@ -1552,0 +1662,5 @@\n+    public static final String SUB_VHF = PREFIX + \"SUB_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_VHF, \"SubVHF\");\n+    }\n+\n@@ -1567,0 +1682,10 @@\n+    public static final String DIV_HF = PREFIX + \"DIV_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_HF, \"DivHF\");\n+    }\n+\n+    public static final String DIV_VHF = PREFIX + \"DIV_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_VHF, \"DivVHF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+        \"avx512_fp16\",\n@@ -106,0 +107,2 @@\n+        \"fphp\",\n+        \"asimdhp\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8308363 8336406\n+* @summary Test vectorization of Float16 binary operations\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @compile TestFloat16VectorOps.java\n+* @run driver compiler.vectorization.TestFloat16VectorOps\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static java.lang.Float16.*;\n+\n+public class TestFloat16VectorOps {\n+    private Float16[] input1;\n+    private Float16[] input2;\n+    private Float16[] input3;\n+    private Float16[] output;\n+    private static final int LEN = 2048;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--enable-preview\", \"-XX:-TieredCompilation\", \"-Xbatch\");\n+    }\n+\n+    public TestFloat16VectorOps() {\n+        input1 = new Float16[LEN];\n+        input2 = new Float16[LEN];\n+        input3 = new Float16[LEN];\n+        output = new Float16[LEN];\n+        rng = new Random(42);\n+        for (int i = 0; i < LEN; ++i) {\n+            input1[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n+            input2[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n+            input3[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorAddFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.add(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorAddFloat16\")\n+    public void checkResultAdd() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.add(input1[i], input2[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorSubFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.subtract(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubFloat16\")\n+    public void checkResultSub() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.subtract(input1[i], input2[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMulFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.multiply(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulFloat16\")\n+    public void checkResultMul() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.multiply(input1[i], input2[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorDivFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.divide(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivFloat16\")\n+    public void checkResultDiv() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.divide(input1[i], input2[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMinFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.min(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinFloat16\")\n+    public void checkResultMin() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.min(input1[i], input2[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMaxFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.max(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxFloat16\")\n+    public void checkResultMax() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.max(input1[i], input2[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.ABS_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"sve\", \"true\"})\n+    @IR(counts = {IRNode.ABS_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorAbsFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.abs(input1[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorAbsFloat16\")\n+    public void checkResultAbs() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.abs(input1[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.NEG_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"sve\", \"true\"})\n+    @IR(counts = {IRNode.NEG_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorNegFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.negate(input1[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorNegFloat16\")\n+    public void checkResultNeg() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.negate(input1[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorSqrtFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.sqrt(input1[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorSqrtFloat16\")\n+    public void checkResultSqrt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.sqrt(input1[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorFmaFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.fma(input1[i], input2[i], input3[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorFmaFloat16\")\n+    public void checkResultFma() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.fma(input1[i], input2[i], input3[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOps.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"}]}