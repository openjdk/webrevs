{"files":[{"patch":"@@ -356,1 +356,0 @@\n-  case vmIntrinsics::_getValue:\n@@ -367,1 +366,0 @@\n-  case vmIntrinsics::_putValue:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -752,2 +752,0 @@\n-  do_signature(getValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;)Ljava\/lang\/Object;\")                   \\\n-  do_signature(putValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;Ljava\/lang\/Object;)V\")                  \\\n@@ -780,1 +778,0 @@\n-  do_intrinsic(_getValue,           jdk_internal_misc_Unsafe,     getValue_name, getValue_signature,             F_RN)  \\\n@@ -791,1 +788,0 @@\n-  do_intrinsic(_putValue,           jdk_internal_misc_Unsafe,     putValue_name, putValue_signature,             F_RN)  \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -674,1 +674,0 @@\n-  case vmIntrinsics::_getValue:\n@@ -685,1 +684,0 @@\n-  case vmIntrinsics::_putValue:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-    case vmIntrinsicID::_putValue:\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -343,1 +343,0 @@\n-  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false, true);\n@@ -354,1 +353,0 @@\n-  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false, true);\n@@ -2465,1 +2463,1 @@\n-bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned, const bool is_flat) {\n+bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {\n@@ -2490,1 +2488,1 @@\n-      assert(sig->count() == 2 || (is_flat && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n+      assert(sig->count() == 2, \"oop getter has 2 arguments\");\n@@ -2496,1 +2494,1 @@\n-      assert(sig->count() == 3 || (is_flat && sig->count() == 4), \"oop putter has 3 arguments\");\n+      assert(sig->count() == 3, \"oop putter has 3 arguments\");\n@@ -2523,13 +2521,0 @@\n-  ciInlineKlass* inline_klass = nullptr;\n-  if (is_flat) {\n-    const TypeInstPtr* cls = _gvn.type(argument(4))->isa_instptr();\n-    if (cls == nullptr || cls->const_oop() == nullptr) {\n-      return false;\n-    }\n-    ciType* mirror_type = cls->const_oop()->as_instance()->java_mirror_type();\n-    if (!mirror_type->is_inlinetype()) {\n-      return false;\n-    }\n-    inline_klass = mirror_type->as_inline_klass();\n-  }\n-\n@@ -2552,1 +2537,1 @@\n-        if (bt == type && (!field->is_flat() || field->type() == inline_klass)) {\n+        if (bt == type && !field->is_flat()) {\n@@ -2581,1 +2566,1 @@\n-    if (type != T_OBJECT && (inline_klass == nullptr || !inline_klass->has_object_fields())) {\n+    if (type != T_OBJECT) {\n@@ -2597,1 +2582,1 @@\n-  Node* val = is_store ? argument(4 + (is_flat ? 1 : 0)) : nullptr;\n+  Node* val = is_store ? argument(4) : nullptr;\n@@ -2638,1 +2623,1 @@\n-    assert(bt == alias_type->basic_type() || is_flat, \"should match\");\n+    assert(bt == alias_type->basic_type(), \"should match\");\n@@ -2663,21 +2648,0 @@\n-  if (is_flat) {\n-    if (adr_type->isa_instptr()) {\n-      if (field == nullptr || field->type() != inline_klass) {\n-        mismatched = true;\n-      }\n-    } else if (adr_type->isa_aryptr()) {\n-      const Type* elem = adr_type->is_aryptr()->elem();\n-      if (!adr_type->is_flat() || elem->inline_klass() != inline_klass) {\n-        mismatched = true;\n-      }\n-    } else {\n-      mismatched = true;\n-    }\n-    if (is_store) {\n-      const Type* val_t = _gvn.type(val);\n-      if (!val_t->is_inlinetypeptr() || val_t->inline_klass() != inline_klass) {\n-        return false;\n-      }\n-    }\n-  }\n-\n@@ -2698,1 +2662,1 @@\n-    if (type == T_OBJECT && !is_flat) {\n+    if (type == T_OBJECT) {\n@@ -2725,9 +2689,5 @@\n-      if (is_flat) {\n-        p = InlineTypeNode::make_from_flat(this, inline_klass, base, adr, adr_type, false, false, true);\n-      } else {\n-        p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n-        const TypeOopPtr* ptr = value_type->make_oopptr();\n-        if (ptr != nullptr && ptr->is_inlinetypeptr()) {\n-          \/\/ Load a non-flattened inline type from memory\n-          p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass());\n-        }\n+      p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n+      const TypeOopPtr* ptr = value_type->make_oopptr();\n+      if (ptr != nullptr && ptr->is_inlinetypeptr()) {\n+        \/\/ Load a non-flattened inline type from memory\n+        p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass());\n@@ -2772,5 +2732,1 @@\n-    if (is_flat) {\n-      val->as_InlineType()->store_flat(this, base, adr, false, false, true, decorators);\n-    } else {\n-      access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n-    }\n+    access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":58,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned, bool is_flat = false);\n+  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -441,22 +441,0 @@\n-UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {\n-  oop base = JNIHandles::resolve(obj);\n-  if (base == nullptr) {\n-    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n-  }\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n-  InlineKlass* vk = InlineKlass::cast(k);\n-  assert_and_log_unsafe_value_access(base, offset, vk);\n-  LayoutKind lk = LayoutKind::UNKNOWN;\n-  if (base->is_array()) {\n-    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n-    lk = fak->layout_kind();\n-  } else {\n-    fieldDescriptor fd;\n-    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n-    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n-  }\n-  Handle base_h(THREAD, base);\n-  oop v = vk->read_payload_from_addr(base_h(), offset, lk, CHECK_NULL);\n-  return JNIHandles::make_local(THREAD, v);\n-} UNSAFE_END\n-\n@@ -478,22 +456,0 @@\n-UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {\n-  oop base = JNIHandles::resolve(obj);\n-  if (base == nullptr) {\n-    THROW(vmSymbols::java_lang_NullPointerException());\n-  }\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n-  InlineKlass* vk = InlineKlass::cast(k);\n-  assert(!base->is_inline_type() || base->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n-  assert_and_log_unsafe_value_access(base, offset, vk);\n-  LayoutKind lk = LayoutKind::UNKNOWN;\n-  if (base->is_array()) {\n-    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n-    lk = fak->layout_kind();\n-  } else {\n-    fieldDescriptor fd;\n-    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n-    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n-  }\n-  oop v = JNIHandles::resolve(value);\n-  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, lk, true, CHECK);\n-} UNSAFE_END\n-\n@@ -1210,1 +1166,0 @@\n-    {CC \"getValue\",             CC \"(\" OBJ \"J\" CLS \")\" OBJ, FN_PTR(Unsafe_GetValue)},\n@@ -1212,1 +1167,0 @@\n-    {CC \"putValue\",             CC \"(\" OBJ \"J\" CLS OBJ \")V\", FN_PTR(Unsafe_PutValue)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -302,19 +302,3 @@\n-     * @param o Java heap object in which the variable resides, if any, else\n-     *        null\n-     * @param offset indication of where the variable resides in a Java heap\n-     *        object, if any, else a memory address locating the variable\n-     *        statically\n-     * @param valueType value type\n-     * @param <V> the type of a value\n-     * @return the value fetched from the indicated Java variable\n-     * @throws RuntimeException No defined exceptions are thrown, not even\n-     *         {@link NullPointerException}\n-     *\/\n-    @IntrinsicCandidate\n-    public native <V> V getValue(Object o, long offset, Class<?> valueType);\n-\n-    \/**\n-     * Fetches a value of type {@code <V>} from a given Java variable.\n-     * More specifically, fetches a field or array element within the given\n-     * {@code o} object at the given offset, or (if {@code o} is null)\n-     * from the memory address whose numerical value is the given offset.\n+     * @apiNote\n+     * The returned object is newly allocated into the heap, because flat\n+     * values lack object headers and thus can't be used as objects directly.\n@@ -339,21 +323,0 @@\n-\n-    \/**\n-     * Stores the given value into a given Java variable.\n-     *\n-     * Unless the reference {@code o} being stored is either null\n-     * or matches the field type, the results are undefined.\n-     *\n-     * @param o Java heap object in which the variable resides, if any, else\n-     *        null\n-     * @param offset indication of where the variable resides in a Java heap\n-     *        object, if any, else a memory address locating the variable\n-     *        statically\n-     * @param valueType value type\n-     * @param v the value to store into the indicated Java variable\n-     * @param <V> the type of a value\n-     * @throws RuntimeException No defined exceptions are thrown, not even\n-     *         {@link NullPointerException}\n-     *\/\n-    @IntrinsicCandidate\n-    public native <V> void putValue(Object o, long offset, Class<?> valueType, V v);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import jdk.internal.misc.VM;\n@@ -104,0 +103,1 @@\n+        int layout_v2 = U.fieldLayout(Value2.class.getDeclaredField(\"v\"));\n@@ -106,0 +106,1 @@\n+        int layout_point = U.fieldLayout(Value1.class.getDeclaredField(\"point\"));\n@@ -116,2 +117,2 @@\n-            U.putValue(v, off_v + off_v2 - U.valueHeaderSize(Value2.class) + off_point - U.valueHeaderSize(Value1.class),\n-                       Point.class, new Point(100, 100));\n+            U.putFlatValue(v, off_v + off_v2 - U.valueHeaderSize(Value2.class) + off_point - U.valueHeaderSize(Value1.class),\n+                           layout_point, Point.class, new Point(100, 100));\n@@ -134,1 +135,1 @@\n-            U.putValue(v, off_v2, Value2.class, nv2);\n+            U.putFlatValue(v, off_v2, layout_v2, Value2.class, nv2);\n@@ -209,1 +210,1 @@\n-    \/\/ Testing of nullable flat field supports in Unsafe.getFlatValue()\/Unsafe.putValue()\n+    \/\/ Testing of nullable flat field supports in Unsafe.getFlatValue()\/Unsafe.putFlatValue()\n@@ -211,44 +212,0 @@\n-        Container1 c = new Container1();\n-        Class<?> cc = Container1.class;\n-        Field field = cc.getDeclaredField(\"value\");\n-        Class<?> fc = TestValue1.class;\n-        long offset = U.objectFieldOffset(field);\n-        if (!U.isFlatField(field)) return; \/\/ Field not flattened (due to VM flags?), test doesn't apply\n-        \/\/ Initial value of the field must be null\n-        Asserts.assertNull(U.getValue(c, offset, fc));\n-        \/\/ Writing all zero value to the field, field must become non-null\n-        TestValue1 val0 = new TestValue1((short)0, (short)0);\n-        U.putValue(c, offset, fc, val0);\n-        TestValue1 rval = U.getValue(c, offset, fc);\n-        Asserts.assertNotNull(rval);\n-        Asserts.assertEQ((short)0, rval.s0);\n-        Asserts.assertEQ((short)0, rval.s1);\n-        Asserts.assertEQ((short)0, c.value.s0);\n-        Asserts.assertEQ((short)0, c.value.s1);\n-        \/\/ Writing null to the field, field must become null again\n-        U.putValue(c, offset, fc, null);\n-        Asserts.assertNull(U.getValue(c, offset, fc));\n-        Asserts.assertNull(c.value);\n-        \/\/ Writing non zero value to the field\n-        TestValue1 val1 = new TestValue1((short)-1, (short)-2);\n-        U.putValue(c, offset, fc, val1);\n-        rval = U.getValue(c, offset, fc);\n-        Asserts.assertNotNull(rval);\n-        Asserts.assertNotNull(c.value);\n-        Asserts.assertEQ((short)-1, rval.s0);\n-        Asserts.assertEQ((short)-2, rval.s1);\n-        Asserts.assertEQ((short)-1, c.value.s0);\n-        Asserts.assertEQ((short)-2, c.value.s1);\n-        \/\/ Writing a different non zero value\n-        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)3);\n-        U.putValue(c, offset, fc, val2);\n-        rval = U.getValue(c, offset, fc);\n-        Asserts.assertNotNull(rval);\n-        Asserts.assertNotNull(c.value);\n-        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n-        Asserts.assertEQ((short)3, rval.s1);\n-        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n-        Asserts.assertEQ((short)3, rval.s1);\n-    }\n-\n-    public static void testNullableFlatFields2() throws Throwable {\n@@ -299,56 +256,0 @@\n-    \/\/ Testing of nullable flat arrays supports in Unsafe.getValue()\/Unsafe.putValue()\n-    public static void testNullableFlatArrays() throws Throwable {\n-        final int ARRAY_LENGTH = 10;\n-        TestValue1[] array = (TestValue1[])ValueClass.newNullableAtomicArray(TestValue1.class, ARRAY_LENGTH);\n-        Asserts.assertTrue(ValueClass.isFlatArray(array));\n-        long baseOffset = U.arrayInstanceBaseOffset(array);\n-        int scaleIndex = U.arrayInstanceIndexScale(array);\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-        }\n-        TestValue1 val = new TestValue1((short)0, (short)0);\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 == 0) {\n-                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, val );\n-            }\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 == 0) {\n-                Asserts.assertNotNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-                Asserts.assertNotNull(array[i]);\n-            } else {\n-                Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-                Asserts.assertNull(array[i]);\n-            }\n-        }\n-        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)Short.MIN_VALUE);\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 != 0) {\n-                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, val2 );\n-            } else {\n-                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, null );\n-            }\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 != 0) {\n-                TestValue1 rval = U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class);\n-                Asserts.assertNotNull(rval);\n-                Asserts.assertEQ(val2.s0, rval.s0);\n-                Asserts.assertEQ(val2.s1, rval.s1);\n-                Asserts.assertNotNull(array[i]);\n-                Asserts.assertEQ(val2.s0, array[i].s0);\n-                Asserts.assertEQ(val2.s1, array[i].s1);\n-            } else {\n-                Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-                Asserts.assertNull(array[i]);\n-            }\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, null );\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-            Asserts.assertNull(array[i]);\n-        }\n-    }\n-\n@@ -356,1 +257,1 @@\n-    public static void testNullableFlatArrays2() throws Throwable {\n+    public static void testNullableFlatArrays() throws Throwable {\n@@ -415,1 +316,0 @@\n-        testNullableFlatFields2();\n@@ -417,1 +317,0 @@\n-        testNullableFlatArrays2();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":8,"deletions":109,"binary":false,"changes":117,"status":"modified"}]}