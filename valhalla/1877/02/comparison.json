{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.javac.PreviewFeature.Feature;\n@@ -30,0 +32,2 @@\n+import java.util.Objects;\n+\n@@ -115,0 +119,37 @@\n+    \/**\n+     * Creates a new array with the specified component type, modifiers and\n+     * length, whose elements are copied from the provided source array.\n+     *\n+     * @param  componentType the {@code Class} object representing the\n+     *         component type of the new array\n+     * @param  modifiers the modifiers of the new array\n+     * @param  length the length of the new array\n+     * @param  sourceArray the source array from which the elements are copied\n+     * @param  sourceOffset the offset from which elements in the source array are copied\n+     * @return the new array\n+     * @throws NullPointerException if the specified\n+     *         {@code componentType} parameter is null\n+     * @throws IllegalArgumentException if {@code componentType} is {@link Void#TYPE}\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset} is not a valid index in {@code sourceArray}\n+     * @throws NegativeArraySizeException if {@code length < 0}\n+     *\/\n+    @PreviewFeature(feature = Feature.VALUE_OBJECTS)\n+    public static Object newInstance(Class<?> componentType, int modifiers, int length,\n+                              Object sourceArray, int sourceOffset) {\n+        \/\/ modifiers are ignored for now\n+        if (length < 0) {\n+            throw new NegativeArraySizeException(\"length must be >= 0\");\n+        }\n+        Objects.requireNonNull(componentType);\n+        Objects.requireNonNull(sourceArray);\n+        int sourceLength = getLength(sourceArray);\n+        if (sourceLength > 0) {\n+            Objects.checkIndex(sourceOffset, sourceLength);\n+        } else if (sourceOffset != 0) {\n+            throw new IndexOutOfBoundsException(\"sourceOffset=\" + sourceOffset);\n+        }\n+        Object newArray = newInstance(componentType, length);\n+        System.arraycopy(sourceArray, sourceOffset, newArray, 0, length);\n+        return newArray;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,2 @@\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.RuntimeType;\n-import java.util.Arrays;\n-import java.util.function.IntFunction;\n-import java.util.stream.IntStream;\n-import java.lang.invoke.*;\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.javac.PreviewFeature.Feature;\n@@ -37,1 +31,1 @@\n-import static java.lang.invoke.MethodHandles.*;\n+import java.lang.reflect.Array;\n@@ -42,0 +36,1 @@\n+@PreviewFeature(reflective = true, feature = Feature.VALUE_OBJECTS)\n@@ -46,184 +41,0 @@\n-    private static final Lookup LOOKUP = lookup();\n-    private static final MethodType MAKE_LARVAL_TYPE =\n-            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class);\n-    private static final MethodType MAKE_DEFAULT_TYPE =\n-            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class);\n-    private static final MethodType MAKE_FILLED_TYPE =\n-            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, Object.class);\n-    private static final MethodType MAKE_COMPUTED_TYPE =\n-            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, IntFunction.class);\n-    private static final MethodType MAKE_COPY_TYPE =\n-            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, Object.class, int.class);\n-\n-    private static boolean isDefault(RuntimeType<?> componentType, Object value) {\n-        Class<?> c = componentType.baseClass();\n-        if (c.isPrimitive()) {\n-            return Wrapper.forPrimitiveType(c).zero().equals(value);\n-        } else {\n-            return value == null && componentType.canCast(null);\n-        }\n-    }\n-\n-    \/\/ makeLarval\n-\n-    private static Object makeLarval(RuntimeType<?> componentType, int flags, int length) {\n-        return Array.newInstance(componentType.baseClass(), length);\n-    }\n-\n-    \/\/ makeDefault\n-\n-    private static Object makeDefault(RuntimeType<?> componentType, int flags, int length) {\n-        if (!componentType.baseClass().isPrimitive() && !componentType.canCast(null)) {\n-            throw new AssertionError(\"unsupported component type: \" + componentType);\n-        }\n-        return Array.newInstance(componentType.baseClass(), length);\n-    }\n-\n-    \/\/ makeFilled\n-\n-    private static Object makeFilled(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        Object[] result = (Object[]) Array.newInstance(componentType.baseClass(), length);\n-        Arrays.fill(result, init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_byte(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        byte[] result = new byte[length];\n-        Arrays.fill(result, (byte) init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_short(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        short[] result = new short[length];\n-        Arrays.fill(result, (short) init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_int(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        int[] result = new int[length];\n-        Arrays.fill(result, (int) init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_long(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        long[] result = new long[length];\n-        Arrays.fill(result, (long) init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_float(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        float[] result = new float[length];\n-        Arrays.fill(result, (float) init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_double(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        double[] result = new double[length];\n-        Arrays.fill(result, (double) init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_boolean(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        boolean[] result = new boolean[length];\n-        Arrays.fill(result, (boolean) init);\n-        return result;\n-    }\n-\n-    private static Object makeFilled_char(RuntimeType<?> componentType, int flags, int length, Object init) {\n-        char[] result = new char[length];\n-        Arrays.fill(result, (char) init);\n-        return result;\n-    }\n-\n-    \/\/ makeComputed\n-\n-    private static Object makeComputed(RuntimeType<?> componentType, int flags,\n-                                         int length, IntFunction<?> func) {\n-        Object[] result = (Object[]) Array.newInstance(componentType.baseClass(), length);\n-        Arrays.setAll(result, func);\n-        return result;\n-    }\n-\n-    private static Object makeComputed_byte(RuntimeType<?> componentType, int flags,\n-                                            int length, IntFunction<?> func) {\n-        byte[] result = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (byte) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    private static Object makeComputed_short(RuntimeType<?> componentType, int flags,\n-                                              int length, IntFunction<?> func) {\n-        short[] result = new short[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (short) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    private static Object makeComputed_int(RuntimeType<?> componentType, int flags,\n-                                          int length, IntFunction<?> func) {\n-        int[] result = new int[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (int) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    private static Object makeComputed_long(RuntimeType<?> componentType, int flags,\n-                                            int length, IntFunction<?> func) {\n-        long[] result = new long[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (long) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    private static Object makeComputed_float(RuntimeType<?> componentType, int flags,\n-                                              int length, IntFunction<?> func) {\n-        float[] result = new float[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (float) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    private static Object makeComputed_double(RuntimeType<?> componentType, int flags,\n-                                                int length, IntFunction<?> func) {\n-        double[] result = new double[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (double) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    private static Object makeComputed_boolean(RuntimeType<?> componentType, int flags,\n-                                                  int length, IntFunction<?> func) {\n-        boolean[] result = new boolean[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (boolean) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    private static Object makeComputed_char(RuntimeType<?> componentType, int flags,\n-                                            int length, IntFunction<?> func) {\n-        char[] result = new char[length];\n-        for (int i = 0; i < length; i++) {\n-            result[i] = (char) func.apply(i);\n-        }\n-        return result;\n-    }\n-\n-    \/\/ makeCopy\n-\n-    private static Object makeCopy(RuntimeType<?> componentType, int flags,\n-                                   int length, Object source, int start) {\n-        Object result = Array.newInstance(componentType.baseClass(), length);\n-        System.arraycopy(source, start, result, 0, length);\n-        return result;\n-    }\n-\n-    \/\/ bootstraps\n-\n@@ -231,2 +42,1 @@\n-     * Bootstrap method to create an array filled with a given constant initial value.\n-     * Intended for use with {@code invokedynamic} call sites.\n+     * {@return an empty array with provided type and flags}\n@@ -234,5 +44,1 @@\n-     * @param lookup        Ignored\n-     * @param methodName    Ignored\n-     * @param type          MethodType for the MethodHandle: an {@code int} length,\n-     *                      if necessary, with an array return type\n-     * @param componentType RuntimeType representing the array component type\n+     * @param componentType The array component type\n@@ -240,8 +46,1 @@\n-     * @param length        Length of the array, or -1 for dynamic\n-     * @param init          Initial value\n-     * @return              a call site wrapping the array creation MethodHandle\n-     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n-     *                                  or inconsistent\n-     * @throws NullPointerException if any argument is {@code null} or if any element\n-     *                              in the {@code getters} array is {@code null}\n-     * @throws Throwable if any exception is thrown during call site construction\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n@@ -249,26 +48,2 @@\n-    public static CallSite constantFilled(Lookup lookup, String methodName,\n-                                          MethodType type, RuntimeType<?> componentType,\n-                                          int flags, int length, Object init) throws Throwable {\n-        flags = flags | Modifier.STRICT;\n-        MethodHandle factory;\n-        if (isDefault(componentType, init)) {\n-            factory = LOOKUP.findStatic(ArrayCreation.class, \"makeDefault\", MAKE_DEFAULT_TYPE);\n-            if (length < 0) {\n-                factory = insertArguments(factory, 0, componentType, flags);\n-            } else {\n-                factory = insertArguments(factory, 0, componentType, flags, length);\n-            }\n-        } else {\n-            String mname = \"makeFilled\";\n-            if (componentType.baseClass().isPrimitive()) {\n-                mname += \"_\" + componentType;\n-            }\n-            factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_FILLED_TYPE);\n-            if (length < 0) {\n-                factory = insertArguments(factory, 0, componentType, flags);\n-                factory = insertArguments(factory, 1, init);\n-            } else {\n-                factory = insertArguments(factory, 0, componentType, flags, length, init);\n-            }\n-        }\n-        return new ConstantCallSite(factory.asType(type));\n+    public static Object empty(Class<?> componentType, int flags) {\n+        return copied(componentType, flags, 0, new Object[0]);\n@@ -278,2 +53,1 @@\n-     * Bootstrap method to create an array filled with a dynamically-evaluated\n-     * initial value. Intended for use with {@code invokedynamic} call sites.\n+     * {@return an array filled with the provided values}\n@@ -281,6 +55,1 @@\n-     * @param lookup        Ignored\n-     * @param methodName    Ignored\n-     * @param type          MethodType for the MethodHandle: an {@code int} length,\n-     *                      if necessary, and an appropriately-typed initial value,\n-     *                      with an array return type\n-     * @param componentType RuntimeType representing the array component type\n+     * @param componentType The array component type\n@@ -288,7 +57,2 @@\n-     * @param length        Length of the array, or -1 for dynamic\n-     * @return              a call site wrapping the array creation MethodHandle\n-     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n-     *                                  or inconsistent\n-     * @throws NullPointerException if any argument is {@code null} or if any element\n-     *                              in the {@code getters} array is {@code null}\n-     * @throws Throwable if any exception is thrown during call site construction\n+     * @param v1            First value\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n@@ -296,15 +60,2 @@\n-    public static CallSite dynamicFilled(Lookup lookup, String methodName,\n-                                         MethodType type, RuntimeType<?> componentType,\n-                                         int flags, int length) throws Throwable {\n-        flags = flags | Modifier.STRICT;\n-        String mname = \"makeFilled\";\n-        if (componentType.baseClass().isPrimitive()) {\n-            mname += \"_\" + componentType;\n-        }\n-        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_FILLED_TYPE);\n-        if (length  < 0) {\n-            factory = insertArguments(factory, 0, componentType, flags);\n-        } else {\n-            factory = insertArguments(factory, 0, componentType, flags, length);\n-        }\n-        return new ConstantCallSite(factory.asType(type));\n+    public static Object enumerated(Class<?> componentType, int flags, Object v1) {\n+        return copied(componentType, flags, 1, new Object[] { v1 });\n@@ -314,2 +65,1 @@\n-     * Bootstrap method to create an array filled with lazily-computed initial\n-     * values. Intended for use with {@code invokedynamic} call sites.\n+     * {@return an array filled with the provided values}\n@@ -317,6 +67,1 @@\n-     * @param lookup        Ignored\n-     * @param methodName    Ignored\n-     * @param type          MethodType for the MethodHandle: an {@code int} length,\n-     *                      if necessary, and an IntFunction producing initial values,\n-     *                      with an array return type\n-     * @param componentType RuntimeType representing the array component type\n+     * @param componentType The array component type\n@@ -324,7 +69,3 @@\n-     * @param length        Length of the array, or -1 for dynamic\n-     * @return              a call site wrapping the array creation MethodHandle\n-     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n-     *                                  or inconsistent\n-     * @throws NullPointerException if any argument is {@code null} or if any element\n-     *                              in the {@code getters} array is {@code null}\n-     * @throws Throwable if any exception is thrown during call site construction\n+     * @param v1            First value\n+     * @param v2            Second value\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n@@ -332,15 +73,2 @@\n-    public static CallSite computed(Lookup lookup, String methodName,\n-                                    MethodType type, RuntimeType<?> componentType,\n-                                    int flags, int length) throws Throwable {\n-        flags = flags | Modifier.STRICT;\n-        String mname = \"makeComputed\";\n-        if (componentType.baseClass().isPrimitive()) {\n-            mname += \"_\" + componentType;\n-        }\n-        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_COMPUTED_TYPE);\n-        if (length < 0) {\n-            factory = insertArguments(factory, 0, componentType, flags);\n-        } else {\n-            factory = insertArguments(factory, 0, componentType, flags, length);\n-        }\n-        return new ConstantCallSite(factory.asType(type));\n+    public static Object enumerated(Class<?> componentType, int flags, Object v1, Object v2) {\n+        return copied(componentType, flags, 2, new Object[] { v1, v2 });\n@@ -350,2 +78,1 @@\n-     * Bootstrap method to create an array filled with values copied from another\n-     * array. Intended for use with {@code invokedynamic} call sites.\n+     * {@return an array filled with the provided values}\n@@ -353,6 +80,1 @@\n-     * @param lookup        Ignored\n-     * @param methodName    Ignored\n-     * @param type          MethodType for the MethodHandle: an {@code int} length,\n-     *                      if necessary, and a source array of initial values,\n-     *                      with an array return type\n-     * @param componentType RuntimeType representing the array component type\n+     * @param componentType The array component type\n@@ -360,7 +82,4 @@\n-     * @param length        Length of the array, or -1 for dynamic\n-     * @return              a call site wrapping the array creation MethodHandle\n-     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n-     *                                  or inconsistent\n-     * @throws NullPointerException if any argument is {@code null} or if any element\n-     *                              in the {@code getters} array is {@code null}\n-     * @throws Throwable if any exception is thrown during call site construction\n+     * @param v1            First value\n+     * @param v2            Second value\n+     * @param v3            Third value\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n@@ -368,13 +87,2 @@\n-    public static CallSite copied(Lookup lookup, String methodName,\n-                                  MethodType type, RuntimeType<?> componentType,\n-                                  int flags, int length) throws Throwable {\n-        flags = flags | Modifier.STRICT;\n-        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n-        if (length < 0) {\n-            factory = insertArguments(factory, 0, componentType, flags);\n-            factory = insertArguments(factory, 2, 0);\n-        } else {\n-            factory = insertArguments(factory, 0, componentType, flags, length);\n-            factory = insertArguments(factory, 1, 0);\n-        }\n-        return new ConstantCallSite(factory.asType(type));\n+    public static Object enumerated(Class<?> componentType, int flags, Object v1, Object v2, Object v3) {\n+        return copied(componentType, flags, 3, new Object[] { v1, v2, v3 });\n@@ -384,3 +92,1 @@\n-     * Bootstrap method to create an array filled with values copied from another\n-     * array, starting at an offset. Intended for use with {@code invokedynamic}\n-     * call sites.\n+     * {@return an array filled with the provided values}\n@@ -388,6 +94,1 @@\n-     * @param lookup        Ignored\n-     * @param methodName    Ignored\n-     * @param type          MethodType for the MethodHandle: an {@code int} length,\n-     *                      if necessary, a source array of initial values, and\n-     *                      a start offset into the array, with an array return type\n-     * @param componentType RuntimeType representing the array component type\n+     * @param componentType The array component type\n@@ -395,7 +96,5 @@\n-     * @param length        Length of the array, or -1 for dynamic\n-     * @return              a call site wrapping the array creation MethodHandle\n-     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n-     *                                  or inconsistent\n-     * @throws NullPointerException if any argument is {@code null} or if any element\n-     *                              in the {@code getters} array is {@code null}\n-     * @throws Throwable if any exception is thrown during call site construction\n+     * @param v1            First value\n+     * @param v2            Second value\n+     * @param v3            Third value\n+     * @param v4            Fourth value\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n@@ -403,11 +102,2 @@\n-    public static CallSite offsetCopied(Lookup lookup, String methodName,\n-                                        MethodType type, RuntimeType<?> componentType,\n-                                        int flags, int length) throws Throwable {\n-        flags = flags | Modifier.STRICT;\n-        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n-        if (length < 0) {\n-            factory = insertArguments(factory, 0, componentType, flags);\n-        } else {\n-            factory = insertArguments(factory, 0, componentType, flags, length);\n-        }\n-        return new ConstantCallSite(factory.asType(type));\n+    public static Object enumerated(Class<?> componentType, int flags, Object v1, Object v2, Object v3, Object v4) {\n+        return copied(componentType, flags, 4, new Object[] { v1, v2, v3, v4 });\n@@ -417,2 +107,1 @@\n-     * Bootstrap method to create an array initialized to an enumerated list of\n-     * constant values. Intended for use with {@code invokedynamic} call sites.\n+     * {@return an array filled with the provided values}\n@@ -420,5 +109,1 @@\n-     * @param lookup        Ignored\n-     * @param methodName    Ignored\n-     * @param type          MethodType for the MethodHandle: no parameters, with\n-     *                      an array return type\n-     * @param componentType RuntimeType representing the array component type\n+     * @param componentType The array component type\n@@ -426,7 +111,6 @@\n-     * @param values        Initial values\n-     * @return              a call site wrapping the array creation MethodHandle\n-     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n-     *                                  or inconsistent\n-     * @throws NullPointerException if any argument is {@code null} or if any element\n-     *                              in the {@code getters} array is {@code null}\n-     * @throws Throwable if any exception is thrown during call site construction\n+     * @param v1            First value\n+     * @param v2            Second value\n+     * @param v3            Third value\n+     * @param v4            Fourth value\n+     * @param v5            Fifth value\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n@@ -434,15 +118,2 @@\n-    public static CallSite constantEnumerated(Lookup lookup, String methodName,\n-                                              MethodType type, RuntimeType<?> componentType,\n-                                              int flags, Object... values) throws Throwable {\n-        flags = flags | Modifier.STRICT;\n-        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n-        Object src = values;\n-        if (componentType.baseClass().isPrimitive()) {\n-            \/\/ unbox values\n-            src = Array.newInstance(componentType.baseClass(), values.length);\n-            for (int i = 0; i < values.length; i++) {\n-                Array.set(src, i, values[i]);\n-            }\n-        }\n-        factory = insertArguments(factory, 0, componentType, flags, values.length, src, 0);\n-        return new ConstantCallSite(factory.asType(type));\n+    public static Object enumerated(Class<?> componentType, int flags, Object v1, Object v2, Object v3, Object v4, Object v5) {\n+        return copied(componentType, flags, 5, new Object[] { v1, v2, v3, v4, v5 });\n@@ -452,3 +123,2 @@\n-     * Bootstrap method to create an array initialized to an enumerated list of\n-     * dynamically-evaluated values. Intended for use with {@code invokedynamic}\n-     * call sites.\n+     * {@return an array filled with values copied from another\n+     * array}\n@@ -456,5 +126,1 @@\n-     * @param lookup        Ignored\n-     * @param methodName    Ignored\n-     * @param type          MethodType for the MethodHandle: a parameter for each\n-     *                      array component, with an array return type\n-     * @param componentType RuntimeType representing the array component type\n+     * @param componentType The array component type\n@@ -462,6 +128,4 @@\n-     * @return              a call site wrapping the array creation MethodHandle\n-     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n-     *                                  or inconsistent\n-     * @throws NullPointerException if any argument is {@code null} or if any element\n-     *                              in the {@code getters} array is {@code null}\n-     * @throws Throwable if any exception is thrown during call site construction\n+     * @param len           Length of the array\n+     * @param arr           The array from which values are copied\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     * @throws NegativeArraySizeException if {@code length < 0}\n@@ -469,22 +133,2 @@\n-    public static CallSite dynamicEnumerated(Lookup lookup, String methodName,\n-                                             MethodType type, RuntimeType<?> componentType,\n-                                             int flags) throws Throwable {\n-        flags = flags | Modifier.STRICT;\n-        Class<?> ccls = componentType.baseClass();\n-        Class<?> acls = ccls.arrayType();\n-        int arity = type.parameterCount();\n-        MethodHandle binaryId = dropArguments(identity(acls), 1, ccls);\n-        \/\/ binaryId type: (acls, ccls)->acls\n-        MethodHandle alloc = LOOKUP.findStatic(ArrayCreation.class, \"makeLarval\", MAKE_LARVAL_TYPE);\n-        alloc = insertArguments(alloc, 0, componentType, flags, arity);\n-        MethodHandle result = alloc.asType(MethodType.methodType(acls));\n-        \/\/ result type: ()->acls\n-        for (int i = 0; i < arity; i++) {\n-            MethodHandle setter = arrayElementSetter(acls);\n-            setter = insertArguments(setter, 1, i);\n-            setter = foldArguments(binaryId, setter);\n-            \/\/ setter type: (acls, ccls)->acls\n-            result = collectArguments(setter, 0, result);\n-            \/\/ result type: (..., ccls)->acls\n-        }\n-        return new ConstantCallSite(result.asType(type));\n+    public static Object copied(Class<?> componentType, int flags, int len, Object arr) {\n+        return Array.newInstance(componentType, flags, len, arr, 0);\n@@ -492,1 +136,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ArrayCreation.java","additions":59,"deletions":416,"binary":false,"changes":475,"status":"modified"},{"patch":"@@ -600,0 +600,1 @@\n+            case '!':\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/parser\/SignatureParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -254,1 +254,0 @@\n-    public final Type reflectArrayType;\n@@ -256,0 +255,2 @@\n+    public final Type arrayCreationType;\n+    public final MethodSymbol arrayCreationCopied;\n@@ -663,1 +664,0 @@\n-        reflectArrayType = enterClass(\"java.lang.reflect.Array\");\n@@ -666,0 +666,6 @@\n+        arrayCreationType = enterClass(\"java.lang.runtime.ArrayCreation\");\n+        arrayCreationCopied = new MethodSymbol(PUBLIC | STATIC,\n+                names.copied,\n+                new MethodType(List.of(classType, intType, intType, objectType), objectType,\n+                        List.nil(), methodClass),\n+                arrayCreationType.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3553,0 +3553,1 @@\n+            tree.strict = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4298,1 +4298,0 @@\n-        JCExpression originalElemType = tree.elemtype;\n@@ -4300,1 +4299,0 @@\n-        int noOfDims = 0;\n@@ -4303,1 +4301,0 @@\n-            noOfDims++;\n@@ -4306,2 +4303,18 @@\n-        if (!allowNullRestrictedTypes || tree.elemtype == null || !types.isNonNullable(originalElemType.type)) {\n-            result = tree;\n+        if (tree.strict) {\n+            Assert.check(types.dimensions(tree.type) == 1, \"Unexpected multi-dimensional null-restricted array\");\n+            \/\/ create a null restricted array, this will generate code as follows:\n+            \/\/ let $tmp = <old array creation> in ArrayCreation.copied(<array type>, 0, <array size>, $tmp);\n+            VarSymbol tmpArrayVar = new VarSymbol(0, names.fromString(\"$arr\"), syms.objectType, currentMethodSym);\n+            JCVariableDecl tmpArrayVarDecl = make.VarDef(tmpArrayVar, tree);\n+            JCIdent tmpArrayVarRef = make.Ident(tmpArrayVar);\n+            JCFieldAccess qualifier = make.Select(make.Type(syms.arrayCreationType), names.copied);\n+            qualifier.sym = syms.arrayCreationCopied;\n+            qualifier.type = syms.arrayCreationCopied.type;\n+            JCMethodInvocation copiedCall = make.Apply(List.nil(), qualifier,\n+                    List.of(\n+                            classOfType(types.elemtype(tree.type), tree),\n+                            makeLit(syms.intType, 0), \/\/ flag -- 0 for now\n+                            makeLit(syms.intType, tree.elems.length()),\n+                            tmpArrayVarRef)).setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(tree.type, copiedCall);\n+            result = make.LetExpr(tmpArrayVarDecl, cast).setType(cast.type);\n@@ -4309,22 +4322,1 @@\n-            Symbol elemClass = syms.getClassField(tree.elemtype.type, types);\n-            JCFieldAccess elemClassExpr = make.Select(make.Ident(tree.elemtype.type.tsym).setType(tree.elemtype.type), elemClass);\n-            MethodSymbol asNullRestrictedTypeMeth = lookupMethod(tree.pos(), names.asNullRestrictedType, syms.classType, List.nil());\n-            JCExpression asNullRestrictedTypeCall = make.Apply(\n-                        null,\n-                        make.Select(elemClassExpr, asNullRestrictedTypeMeth).setType(syms.classType), List.nil()).setType(syms.classType);\n-            List<JCExpression> dimsExp = tree.dims;\n-            if (noOfDims > 1) {\n-                JCNewArray dimsArr = make.NewArray(make.Type(syms.intType), List.nil(), tree.dims);\n-                dimsArr.type = types.makeArrayType(syms.intType);\n-                dimsExp = List.of(dimsArr);\n-            }\n-            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.newInstance,\n-                syms.reflectArrayType, List.of(syms.classType, noOfDims == 1 ? syms.intType : types.makeArrayType(syms.intType)));\n-            JCExpression call =\n-                    make.Apply(\n-                            null,\n-                            make.Select(make.Ident(syms.reflectArrayType.tsym).setType(syms.reflectArrayType), appyMeth).setType(syms.objectType),\n-                            dimsExp.prepend(asNullRestrictedTypeCall))\n-                            .setType(syms.objectType);\n-            JCExpression cast = make.TypeCast(types.makeArrayType(tree.elemtype.type, noOfDims), call);\n-            result = cast;\n+            result = tree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1981,0 +1981,1 @@\n+        public boolean strict = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,0 +245,1 @@\n+    public final Name copied;\n@@ -443,0 +444,1 @@\n+        copied = fromString(\"copied\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-                    return;\n+                    throw new IllegalStateException(\"Cannot compile: \" + generationResult.compilationInfo());\n@@ -264,1 +264,1 @@\n-        private Consumer<Throwable> handler;\n+        private Consumer<Throwable> handler = t -> { throw new AssertionError(t); };\n@@ -275,1 +275,1 @@\n-            load(className);\n+            this.c = load(className);\n","filename":"test\/langtools\/tools\/javac\/lib\/combo\/ComboTask.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for array creation API\n+ * @library \/tools\/javac\/lib\n+ * @enablePreview\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build combo.ComboTestHelper\n+ * @run main ArrayCreationRuntimeTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask.ExecutionTask;\n+import combo.ComboTestHelper;\n+\n+import javax.lang.model.SourceVersion;\n+import java.util.List;\n+\n+public class ArrayCreationRuntimeTest extends ComboInstance<ArrayCreationRuntimeTest> {\n+\n+    enum ArrayInitKind implements ComboParameter {\n+        INIT_1_0(\"[] { }\"),\n+        INIT_1_1(\"[] { \\\"a\\\" }\"),\n+        INIT_1_2(\"[] { \\\"a\\\", \\\"b\\\" }\"),\n+        INIT_2_0(\"[] { }\"),\n+        INIT_2_0_0(\"[][] { { }, { } }\"),\n+        INIT_2_0_1_0(\"[][] { { }, { \\\"a\\\" }, { } }\"),\n+        INIT_2_1_2(\"[][] { { \\\"a\\\" }, { \\\"b\\\", \\\"c\\\" } }\");\n+\n+        final String initString;\n+\n+        ArrayInitKind(String typeString) {\n+            this.initString = typeString;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return initString;\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<ArrayCreationRuntimeTest>()\n+                .withDimension(\"INIT\", (x, tk) -> x.aik = tk, ArrayInitKind.values())\n+                .run(ArrayCreationRuntimeTest::new);\n+    }\n+\n+    ArrayInitKind aik;\n+\n+    static final String TEMPLATE = \"\"\"\n+            import java.util.Arrays;\n+\n+            public class Test {\n+\n+                static {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                static void m() {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                void g() {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                static void test(Object[] found, Object[] expected) {\n+                System.out.println(found);\n+                    if (!Arrays.deepToString(found).equals(Arrays.deepToString(expected))) {\n+                        throw new AssertionError(\"bad array comparison \" +\n+                            \"found: \" + Arrays.deepToString(found) + \" - expected: \" + Arrays.deepToString(expected));\n+                    }\n+                }\n+\n+                public static void main(String[] args) {\n+                    Test.m();\n+                    new Test().g();\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    public void doWork() {\n+        String latestVersion = String.valueOf(SourceVersion.latestSupported().runtimeVersion().feature());\n+        newCompilationTask()\n+                .withOptions(List.of(\"--enable-preview\", \"--release\", latestVersion))\n+                .withSourceFromTemplate(TEMPLATE)\n+                .execute(this::check);\n+    }\n+\n+    void check(ExecutionTask executionTask) {\n+        executionTask.withClass(\"Test\").run();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/ArrayCreationRuntimeTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -43,1 +44,0 @@\n-import java.lang.Runtime.Version;\n@@ -58,1 +58,1 @@\n-        NN_TVAR_ARR_ARR(\"T[][]!\"),\n+        NN_TVAR_ARR_ARR(\"X[][]!\"),\n@@ -86,1 +86,1 @@\n-                <Z> Z init() { return null; }\n+                static <Z> Z init() { return null; }\n@@ -114,1 +114,1 @@\n-            Method testMethod = testClass.getDeclaredMethod(\"meth\");\n+            Method testMethod = testClass.getDeclaredMethod(\"meth\", testField.getType());\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionReflectiveTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}