{"files":[{"patch":"@@ -363,1 +363,1 @@\n-    STRICT(Modifier.STRICT, true, Location.EMPTY_SET,\n+    STRICT(0x0000_0800, true, !ValhallaFeatures.isEnabled() ? Location.EMPTY_SET : Location.SET_FIELD,\n@@ -367,4 +367,9 @@\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n-                           cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n+                   if (ValhallaFeatures.isEnabled() && cffv.compareTo(ClassFileFormatVersion.RELEASE_22) >= 0) {\n+                       return Location.SET_FIELD;\n+                   } else if (cffv.compareTo(ClassFileFormatVersion.RELEASE_2) >= 0 &&\n+                              cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) {\n+                       return Location.SET_METHOD;\n+                   } else {\n+                       return Location.EMPTY_SET;\n+                   }\n+               }\n@@ -707,1 +712,1 @@\n-                                       TRANSIENT, SYNTHETIC, ENUM)),\n+                                       TRANSIENT, SYNTHETIC, ENUM, STRICT)),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+    public static final int ACC_STRICT   = 0x0800;\n@@ -412,0 +413,5 @@\n+    \/**\n+     * Flag to indicate that a field is strict\n+     *\/\n+    public static final long STRICT = 1L<<51; \/\/ VarSymbols\n+\n@@ -447,0 +453,1 @@\n+        ExtendedVarFlags                  = (long) VarFlags | STRICT,\n@@ -572,1 +579,2 @@\n-        };\n+        },\n+        STRICT(Flags.STRICT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1197,1 +1197,5 @@\n-                        tree.body.stats = tree.body.stats.prepend(supCall);\n+                        if (owner.isValueClass()) {\n+                            tree.body.stats = tree.body.stats.append(supCall);\n+                        } else {\n+                            tree.body.stats = tree.body.stats.prepend(supCall);\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1262,3 +1262,4 @@\n-                mask = VarFlags;\n-                if (sym.owner.type.isValueClass() && (flags & STATIC) == 0) {\n-                    implicit |= FINAL;\n+                boolean isInstanceFieldOfValueClass = sym.owner.type.isValueClass() && (flags & STATIC) == 0;\n+                mask = !isInstanceFieldOfValueClass ? VarFlags : ExtendedVarFlags;\n+                if (isInstanceFieldOfValueClass) {\n+                    implicit |= FINAL | STRICT;\n@@ -4167,0 +4168,2 @@\n+                \/\/ valhalla is using this feature so commenting this code for now so that the\n+                \/\/ build doesn't depend on preview code\n@@ -4168,1 +4171,1 @@\n-                if (!firstStatement)\n+                \/*if (!firstStatement) {\n@@ -4170,0 +4173,1 @@\n+                }*\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;\n-import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;\n@@ -2017,8 +2015,0 @@\n-    \/** Enum to model whether constructors allowed to \"leak\" this reference before\n-        all instance fields are DA.\n-     *\/\n-    enum ThisExposability {\n-        ALLOWED,     \/\/ identity Object classes - NOP\n-        BANNED,      \/\/ primitive\/value classes - Error\n-    }\n-\n@@ -2113,3 +2103,0 @@\n-        \/\/ Are constructors allowed to leak this reference ?\n-        ThisExposability thisExposability = ALLOWED;\n-\n@@ -2241,22 +2228,0 @@\n-        void checkEmbryonicThisExposure(JCTree node) {\n-            if (this.thisExposability == ALLOWED || classDef == null)\n-                return;\n-\n-            \/\/ Note: for non-initial constructors, firstadr is post all instance fields.\n-            for (int i = firstadr; i < nextadr; i++) {\n-                VarSymbol sym = vardecls[i].sym;\n-                if (sym.owner != classDef.sym)\n-                    continue;\n-                if ((sym.flags() & (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)\n-                    continue;\n-                if (sym.pos < startPos || sym.adr < firstadr)\n-                    continue;\n-                if (!inits.isMember(sym.adr)) {\n-                    if (this.thisExposability == BANNED) {\n-                        log.error(node, Errors.ThisExposedPrematurely);\n-                    }\n-                    return; \/\/ don't flog a dead horse.\n-                }\n-            }\n-        }\n-\n@@ -2456,1 +2421,0 @@\n-            ThisExposability priorThisExposability = this.thisExposability;\n@@ -2472,6 +2436,0 @@\n-                        this.thisExposability = ALLOWED;\n-                    } else {\n-                        if (tree.sym.owner.type.isValueClass())\n-                            this.thisExposability = BANNED;\n-                        else\n-                            this.thisExposability = ALLOWED;\n@@ -2542,1 +2500,0 @@\n-                this.thisExposability = priorThisExposability;\n@@ -3033,6 +2990,0 @@\n-\n-            if (tree.meth.hasTag(IDENT)) {\n-                JCIdent ident = (JCIdent) tree.meth;\n-                if (ident.name != names._super && !ident.sym.isStatic())\n-                    checkEmbryonicThisExposure(tree);\n-            }\n@@ -3045,6 +2996,0 @@\n-            if (classDef != null && tree.encl == null && tree.clazz.hasTag(IDENT)) {\n-                JCIdent clazz = (JCIdent) tree.clazz;\n-                if (!clazz.sym.isStatic() && clazz.type.getEnclosingType().tsym == classDef.sym) {\n-                    checkEmbryonicThisExposure(tree);\n-                }\n-            }\n@@ -3120,8 +3065,1 @@\n-            ThisExposability priorThisExposability = this.thisExposability;\n-            try {\n-                if (tree.name == names._this && classDef != null && tree.sym.owner == classDef.sym) {\n-                    checkEmbryonicThisExposure(tree);\n-                } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {\n-                    this.thisExposability = ALLOWED;\n-                }\n-                super.visitSelect(tree);\n+            super.visitSelect(tree);\n@@ -3130,4 +3068,1 @@\n-                    checkInit(tree.pos(), (VarSymbol)tree.sym);\n-                }\n-            } finally {\n-                 this.thisExposability = priorThisExposability;\n+                checkInit(tree.pos(), (VarSymbol)tree.sym);\n@@ -3197,3 +3132,0 @@\n-            if (tree.name == names._this) {\n-                checkEmbryonicThisExposure(tree);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":70,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1516,2 +1516,5 @@\n-                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0)\n-                        return new RefBeforeCtorCalledError(sym);\n+                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0) {\n+                        if (!env.tree.hasTag(ASSIGN) || !TreeInfo.isIdentOrThisDotIdent(((JCAssign)env.tree).lhs)) {\n+                            return new RefBeforeCtorCalledError(sym);\n+                        }\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3139,0 +3139,4 @@\n+        if ((flags & ACC_STRICT) != 0) {\n+            flags &= ~ACC_STRICT;\n+            flags |= STRICT;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1783,0 +1783,3 @@\n+        if ((flags & STRICT) != 0) {\n+            result |= ACC_STRICT;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -427,0 +427,2 @@\n+        \/\/ only used for value classes\n+        ListBuffer<JCStatement> initBlocks = new ListBuffer<>();\n@@ -442,2 +444,7 @@\n-                else if ((block.flags & SYNTHETIC) == 0)\n-                    initCode.append(block);\n+                else if ((block.flags & SYNTHETIC) == 0) {\n+                    if (c.isValueClass()) {\n+                        initBlocks.append(block);\n+                    } else {\n+                        initCode.append(block);\n+                    }\n+                }\n@@ -482,2 +489,1 @@\n-        if (initCode.length() != 0) {\n-            List<JCStatement> inits = initCode.toList();\n+        if (initCode.length() != 0 || initBlocks.length() != 0) {\n@@ -487,1 +493,1 @@\n-                normalizeMethod((JCMethodDecl)t, inits, initTAlist);\n+                normalizeMethod((JCMethodDecl)t, initCode.toList(), initBlocks.toList(), initTAlist);\n@@ -550,1 +556,1 @@\n-    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<TypeCompound> initTAs) {\n+    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initBlocks,  List<TypeCompound> initTAs) {\n@@ -554,1 +560,5 @@\n-            TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+            if (md.sym.owner.isValueClass()) {\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.append(supercall).appendList(initBlocks)));\n+            } else {\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4060,3 +4060,0 @@\n-compiler.err.this.exposed.prematurely=\\\n-    value class instance should not be passed around before being fully initialized\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    public static final int ACC_STRICT        = 0x0800; \/\/                      method\n+    public static final int ACC_STRICT        = 0x0800; \/\/                      method, field\n@@ -130,1 +130,1 @@\n-        ACC_VOLATILE, ACC_TRANSIENT, ACC_SYNTHETIC, ACC_ENUM\n+        ACC_VOLATILE, ACC_TRANSIENT, ACC_SYNTHETIC, ACC_ENUM, ACC_STRICT\n@@ -206,2 +206,2 @@\n-            case 0x40:\n-                return (t == Kind.Class || t == Kind.InnerClass) ? \"value\" : \"volatile\";\n+            case ACC_VOLATILE:\n+                return \"volatile\";\n@@ -213,1 +213,1 @@\n-                return (t == Kind.Class || t == Kind.InnerClass) ? \"primitive\" : \"strictfp\";\n+                return (t == Kind.Field) ? \"strict\" : \"strictfp\";\n@@ -245,2 +245,2 @@\n-        case 0x800:\n-            return (t == Kind.Class || t == Kind.InnerClass) ? \"ACC_PRIMITIVE\" : \"ACC_STRICT\";\n+        case ACC_STRICT:\n+            return \"ACC_STRICT\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -160,1 +160,0 @@\n-                case 'Q':\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Descriptor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,4 +245,0 @@\n-\n-    ACONST_INIT(203, CPREF_W),\n-    WITHFIELD(204, CPREF_W),\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Opcode.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-            case 'Q':\n@@ -195,1 +194,1 @@\n-        assert sig.charAt(sigp) == 'L' || sig.charAt(sigp) == 'Q';\n+        assert sig.charAt(sigp) == 'L';\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Signature.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -492,6 +492,0 @@\n-                case \"<vnew>\":\n-                    String returnType = getJavaName(sigPrinter.print(d.result()));\n-                    if (!returnType.equals(\"void\")) { \/\/ static factories for primitive classes\n-                        print(returnType);\n-                        print(\" \");\n-                    }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-            case 'Q':\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/Pretty.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-                case 'Q':\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/MethodSig.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8324873\n+ * @summary [lworld] implementation of value classes construction\n+ * @compile\/fail\/ref=DA_DUConstructors.out -XDrawDiagnostics DA_DUConstructors.java\n+ *\/\n+\n+public class DA_DUConstructors {\n+    \/\/ identity\n+    class C1 {\n+        final int x;\n+        final int y = x + 1;\n+        C1() {\n+            x = 12;\n+            super();\n+        }\n+    }\n+\n+    class C2 {\n+        final int x;\n+        C2() {\n+            this(x = 3); \/\/ error\n+        }\n+        C2(int i) {\n+            x = 4;\n+        }\n+    }\n+\n+    class C3 {\n+        C3(int i) {}\n+    }\n+    class C4 extends C3 {\n+        final int x;\n+        C4() {\n+            super(x = 3); \/\/ ok\n+        }\n+    }\n+\n+    class C5 {\n+        final int x;\n+        final int y = x + 1; \/\/ x is not DA\n+        C5() {\n+            x = 12; super();\n+        }\n+        C5(int i) {\n+            \/* no prologue *\/\n+            x = i;\n+        }\n+    }\n+\n+    \/\/ value classes\n+    value class V1 {\n+        int x;\n+        int y = x + 1; \/\/ allowed\n+        V1() {\n+            x = 12;\n+            \/\/ super();\n+        }\n+    }\n+\n+    value class V2 {\n+        int x;\n+        V2() { this(x = 3); } \/\/ error\n+        V2(int i) { x = 4; }\n+    }\n+\n+    abstract value class AV1 {\n+        AV1(int i) {}\n+    }\n+\n+    value class V3 extends AV1 {\n+        int x;\n+        V3() {\n+            super(x = 3); \/\/ ok\n+        }\n+    }\n+\n+    value class V4 { \/\/ OK\n+        int x;\n+        int y = x + 1;\n+\n+        V4() {\n+            x = 12;\n+        }\n+\n+        V4(int i) {\n+            x = i;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+DA_DUConstructors.java:22:17: compiler.err.var.might.already.be.assigned: x\n+DA_DUConstructors.java:41:23: compiler.err.var.might.not.have.been.initialized: x\n+DA_DUConstructors.java:63:20: compiler.err.var.might.already.be.assigned: x\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -94,1 +94,1 @@\n-        this.x = x.length;              \/\/ this should FAIL\n+        this.x = x.length;              \/\/ this should work\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,0 @@\n-SuperInitFails.java:94:9: compiler.err.cant.ref.before.ctor.called: this\n@@ -27,3 +26,1 @@\n-- compiler.note.preview.filename: SuperInitFails.java, DEFAULT\n-- compiler.note.preview.recompile\n-26 errors\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8324873\n+ * @summary Permit additional statements before this\/super in constructors\n+ * @compile\/fail\/ref=ValueClassSuperInitFails.out -XDrawDiagnostics ValueClassSuperInitFails.java\n+ * @enablePreview\n+ *\/\n+\n+abstract value class AR<V> implements java.io.Serializable {\n+    public AR(V initialValue) {\n+    }\n+\n+    public AR() {\n+    }\n+}\n+\n+value class ValueClassSuperInitFails extends AR <Object> implements Iterable<Object> {\n+\n+    private int x;\n+\n+\/\/\/ GOOD EXAMPLES\n+\n+    public ValueClassSuperInitFails() {           \/\/ this should be OK\n+        \/\/ super()\n+    }\n+\n+    public ValueClassSuperInitFails(Object x) {\n+        this.x = x.hashCode();          \/\/ this should be OK\n+        \/\/ super();  the compiler will introduce the super call at this location\n+    }\n+\n+    public ValueClassSuperInitFails(byte x) {\n+        super();                        \/\/ this should be OK\n+    }\n+\n+    public ValueClassSuperInitFails(char x) {\n+        this((int)x);                   \/\/ this should be OK\n+    }\n+\n+\/\/\/ FAIL EXAMPLES\n+\n+    {\n+        this(1);                        \/\/ this should FAIL\n+    }\n+\n+    {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod1() {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod2() {\n+        this();                         \/\/ this should FAIL\n+    }\n+\n+    void normalMethod3() {\n+        Runnable r = () -> super();     \/\/ this should FAIL\n+    }\n+\n+    void normalMethod4() {\n+        Runnable r = () -> this();      \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(short x) {\n+        hashCode();                     \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(float x) {\n+        this.hashCode();                \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(int x) {\n+        super.hashCode();               \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(long x) {\n+        ValueClassSuperInitFails.this.hashCode();      \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(double x) {\n+        ValueClassSuperInitFails.super.hashCode();     \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(byte[] x) {\n+        {\n+            super();                    \/\/ this should FAIL\n+        }\n+    }\n+\n+    public ValueClassSuperInitFails(char[] x) {\n+        if (x.length == 0)\n+            return;                     \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(short[] x) {\n+        this.x = x.length;              \/\/ this should be OK\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(float[] x) {\n+        System.identityHashCode(this);  \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(int[] x) {\n+        this(this);                     \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(long[] x) {\n+        this(Object.this);              \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(double[] x) {\n+        Iterable.super.spliterator();   \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(byte[][] x) {\n+        super(new Object() {\n+            {\n+                super();                \/\/ this should FAIL\n+            }\n+        });\n+    }\n+\n+    public ValueClassSuperInitFails(char[][] x) {\n+        new Inner1();                   \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    class Inner1 {\n+    }\n+\n+    record Record1(int value) {\n+        Record1(float x) {              \/\/ this should FAIL\n+        }\n+    }\n+\n+    record Record2(int value) {\n+        Record2(float x) {              \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    @Override\n+    public java.util.Iterator<Object> iterator() {\n+        return null;\n+    }\n+\n+    public ValueClassSuperInitFails(short[][] x) {\n+        class Foo {\n+            Foo() {\n+                ValueClassSuperInitFails.this.hashCode();\n+            }\n+        };\n+        new Foo();                      \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(float[][] x) {\n+        Runnable r = () -> {\n+            super();                    \/\/ this should FAIL\n+        };\n+    }\n+\n+    public ValueClassSuperInitFails(int[][] z) {\n+        super((Runnable)() -> x);       \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(long[][] z) {\n+        super(new Inner1());            \/\/ this should FAIL\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+ValueClassSuperInitFails.java:67:9: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:72:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:77:9: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:82:33: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:87:33: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:109:33: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:114:14: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:118:20: compiler.err.not.encl.class: java.lang.Object\n+ValueClassSuperInitFails.java:122:17: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:129:22: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:143:9: compiler.err.non.canonical.constructor.invoke.another.constructor: ValueClassSuperInitFails.Record1\n+ValueClassSuperInitFails.java:148:9: compiler.err.non.canonical.constructor.invoke.another.constructor: ValueClassSuperInitFails.Record2\n+ValueClassSuperInitFails.java:164:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:175:31: compiler.err.cant.ref.before.ctor.called: x\n+ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:43:13: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:47:14: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:51:14: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:55:13: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:59:33: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:63:32: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:93:18: compiler.err.ctor.calls.not.allowed.here\n+ValueClassSuperInitFails.java:99:13: compiler.err.return.before.superclass.initialized\n+ValueClassSuperInitFails.java:170:18: compiler.err.ctor.calls.not.allowed.here\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,497 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324873\n+ * @summary Test valid placements of super()\/this() in constructors\n+ * @enablePreview\n+ * @ignore fails at execution time because of Optional\n+ *\/\n+\n+public value class ValueClassSuperInitGood {\n+\n+    ValueClassSuperInitGood(Object obj) {\n+    }\n+\n+    ValueClassSuperInitGood(int x) {\n+    }\n+\n+    \/\/ Default constructor provided by compiler\n+    static value class Test0 {\n+    }\n+\n+    \/\/ No explicit calls to this()\/super()\n+    static abstract value class Test1 {\n+        Test1() {\n+        }\n+        Test1(int a) {\n+            super();\n+            this.hashCode();\n+        }\n+    }\n+\n+    \/\/ Explicit calls to this()\/super()\n+    static abstract value class Test2<T> {\n+        static int i;\n+        Test2() {\n+            this(0);\n+        }\n+        Test2(int i) {\n+            Test2.i = i;\n+            super();\n+        }\n+        Test2(T obj) {\n+            this(java.util.Objects.hashCode(obj));\n+        }\n+        public T get() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Explicit this()\/super() with stuff in front\n+    static value class Test3 {\n+        int x;\n+        final int y;\n+        final int z;\n+\n+        Test3() {\n+            new Object().hashCode();\n+            new Object().hashCode();\n+            super();\n+            this.x = new Object().hashCode();\n+            this.y = new Object().hashCode() % 17;\n+            this.z = this.x + this.y;\n+        }\n+    }\n+\n+    static abstract value class Test5Abstract {\n+        Test5Abstract(Object obj) {}\n+    }\n+\n+    \/\/ Reference within constructor to outer class that's also my superclass\n+    abstract value class Test5 extends Test5Abstract {\n+        Test5(Object obj) {\n+            if (obj == null)\n+                throw new IllegalArgumentException();\n+            super(ValueClassSuperInitGood.this);      \/\/ NOT a 'this' reference\n+        }\n+    }\n+\n+    \/\/ Initialization blocks\n+    value class Test6 {\n+        final long startTime;\n+        final int x;\n+        {\n+            this.x = 12;\n+        }\n+        Test6() {\n+            long now = System.nanoTime();\n+            long then = now + 1000000L;\n+            while (System.nanoTime() < then) {\n+                try {\n+                    Thread.sleep(1);\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    break;\n+                }\n+            }\n+            super();\n+            this.startTime = now;\n+        }\n+    }\n+\n+    \/\/ Mix up inner classes, proxies, and super() calls\n+    \/\/ Copied mostly from UnverifiableInitForNestedLocalClassTest.java\n+    public static void test7(final String arg) {\n+        final String inlined = \" inlined \";\n+        abstract value class LocalClass {\n+            String m() {\n+                return \"LocalClass \" + arg + inlined;\n+            }\n+\n+            abstract value class SubClass extends LocalClass {\n+                @Override\n+                String m() {\n+                    return \"SubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            value class SubSubClass extends SubClass {\n+                @Override\n+                String m() {\n+                    return \"SubSubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            value class AnotherLocal {\n+                value class AnotherSub extends LocalClass {\n+                    AnotherSub() {\n+                    }\n+                    AnotherSub(int x) {\n+                        this((char)x);\n+                    }\n+                    AnotherSub(char y) {\n+                        super();\n+                    }\n+                    @Override\n+                    String m() {\n+                        return \"AnotherSub \" + arg + inlined;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Anonymous inner class\n+    public static void test8() {\n+        new Test2<Byte>(null) {\n+            @Override\n+            public Byte get() {\n+                return (byte)-1;\n+            }\n+        };\n+    }\n+\n+    \/\/ Qualified super() invocation\n+    public static value class Test9 extends Test5 {\n+\n+        public Test9(ValueClassSuperInitGood implicit, Object obj) {\n+            obj.hashCode();\n+            implicit.super(obj);\n+        }\n+    }\n+\n+    \/\/ Copied from WhichImplicitThis6\n+    public static abstract value class Test10 {\n+        private int i;\n+        public Test10(int i) { this.i = i; }\n+        public value class Sub extends Test10 {\n+            public Sub() {\n+                super(i); \/\/ i is not inherited, so it is the enclosing i\n+            }\n+        }\n+    }\n+\n+    \/\/ Two constructors where only one invokes super()\n+    public static value class Test11 {\n+        public Test11() {\n+        }\n+        public Test11(int x) {\n+            super();\n+        }\n+    }\n+\n+    \/\/ Nested version of the previous test\n+    public static value class Test12 {\n+        Test12() {\n+            class Sub {\n+                public Sub() {\n+                }\n+                public Sub(int j) {\n+                    super();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested super()'s requiring initialization code appended\n+    public static value class Test13 extends Test5Abstract {\n+        final int x = new Object().hashCode();\n+        Test13() {\n+            super(new Object() {\n+                public void foo() {\n+                    class Bar {\n+                        final int y = new Object().hashCode();\n+                        Bar() {\n+                            super();\n+                        }\n+                        Bar(int ignored) {\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ Initializer in initializer block\n+    public static value class Test14 {\n+        final int x;                \/\/ initialized in constructor\n+        final int y;                \/\/ initialized in initialization block\n+        final int z = 13;           \/\/ initialized with intializer value\n+        public Test14() {\n+            this(0);\n+        }\n+        public Test14(boolean z) {\n+            this.x = z ? 1 : 0;\n+        }\n+        public Test14(int x) {\n+            super();\n+            this.x = x;\n+        }\n+        {\n+            this.y = -1;\n+        }\n+    }\n+\n+    \/\/ Qualified super() invocation with superclass instance\n+    public static abstract value class Test15 {\n+\n+        final String name;\n+\n+        public Test15(String name) {\n+            this.name = name;\n+        }\n+\n+        public abstract value class Test15b extends Test15 {\n+\n+            public Test15b(String name) {\n+                super(name);\n+            }\n+\n+            public String getName() {\n+                return Test15.this.name;\n+            }\n+        }\n+    }\n+\n+    public static value class Test15c extends Test15.Test15b {\n+        public Test15c(Test15 a, String name) {\n+            a.super(name);\n+        }\n+    }\n+\n+    \/\/ Mixing up outer instances, proxies, and initializers\n+    public static value class Test16 {\n+\n+        final String x = String.valueOf(new Object().hashCode());\n+\n+        public void run() {\n+\n+            final String y = String.valueOf(new Object().hashCode());\n+\n+            class Sub {\n+\n+                final String z;\n+\n+                Sub(String z, int ignored) {\n+                    this(z, (float)ignored);\n+                }\n+\n+                Sub(String z, float ignored) {\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, byte ignored) {\n+                    super();\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, char ignored) {\n+                    this(z, (int)ignored);\n+                }\n+\n+                String x() {\n+                    return x;\n+                }\n+\n+                String y() {\n+                    return y;\n+                }\n+\n+                String z() {\n+                    return z;\n+                }\n+            }\n+\n+            final String z = String.valueOf(new Object().hashCode());\n+\n+            final Sub[] subs = new Sub[] {\n+                new Sub(z, 1),\n+                new Sub(z, -1),\n+                new Sub(z, (float)0),\n+                new Sub(z, (byte)0),\n+                new Sub(z, (char)0)\n+            };\n+\n+            for (int i = 0; i < subs.length; i++) {\n+                \/\/System.err.println(\"i = \" + i);\n+                final Sub sub = subs[i];\n+                final String subx = sub.x();\n+                final String suby = sub.y();\n+                final String subz = sub.z();\n+                if (!x.equals(subx))\n+                    throw new RuntimeException(\"x=\" + x + \" but sub[\" + i + \"].x()=\" + subx);\n+                if (!y.equals(suby))\n+                    throw new RuntimeException(\"y=\" + y + \" but sub[\" + i + \"].y()=\" + suby);\n+                if (!z.equals(subz))\n+                    throw new RuntimeException(\"z=\" + z + \" but sub[\" + i + \"].z()=\" + subz);\n+            }\n+        }\n+    }\n+\n+    \/\/ Records\n+    public value class Test17 {\n+\n+        record Rectangle(float length, float width) { }\n+\n+        record StringHolder(String string) {\n+            StringHolder {\n+                java.util.Objects.requireNonNull(string);\n+            }\n+        }\n+\n+        record ValueHolder(int value) {\n+            ValueHolder(float x) {\n+                if (Float.isNaN(x))\n+                    throw new IllegalArgumentException();\n+                this((int)x);\n+            }\n+        }\n+    }\n+\n+    static abstract value class AR<V> implements java.io.Serializable {\n+        public AR(V initialValue) {\n+        }\n+\n+        public AR() {\n+        }\n+\n+        public final V get() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Exceptions thrown by initializer block\n+    public static value class Test18 extends AR<Object> {\n+\n+        {\n+            if ((this.get().hashCode() % 3) == 0)\n+                throw new MyException();\n+        }\n+\n+        public Test18(Object obj) throws MyException {\n+            super(obj);\n+        }\n+\n+        public Test18(boolean fail) throws MyException {\n+            Object obj;\n+            for (obj = new Object(); true; obj = new Object()) {\n+                if (((obj.hashCode() % 3) == 0) != fail)\n+                    continue;\n+                break;\n+            }\n+            this(obj);\n+        }\n+\n+        public static class MyException extends Exception {\n+        }\n+    }\n+\n+    \/\/ super()\/this() within outer try block but inside inner class\n+    public static value class Test19 {\n+        public Test19(int x) {\n+            try {\n+                new Test1(x) {\n+                    @Override\n+                    public int hashCode() {\n+                        return x ^ super.hashCode();\n+                    }\n+                };\n+            } catch (StackOverflowError e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/\/ local class declared before super(), but not used until after super()\n+    public static value class Test20 {\n+        public Test20() {\n+            class Foo {\n+                Foo() {\n+                    Test20.this.hashCode();\n+                }\n+            }\n+            super();\n+            new Foo();\n+        }\n+    }\n+\n+    \/\/ local class inside super() parameter list\n+    public static value class Test21 extends AR<Object> {\n+        private int x = 1;\n+        public Test21() {\n+            super(switch (\"foo\".hashCode()) {\n+                default -> {\n+                    class Nested {{ System.out.println(x); }}       \/\/ class is NOT instantiated - OK\n+                    yield \"bar\";\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Test0();\n+        new Test1() {};\n+        new Test1(7) {};\n+        new Test2<Byte>() {};\n+        new Test2<>(args) {};\n+        new Test3();\n+        new ValueClassSuperInitGood(3).new Test5(3) {};\n+        new ValueClassSuperInitGood(3).new Test6();\n+        ValueClassSuperInitGood.test7(\"foo\");\n+        ValueClassSuperInitGood.test8();\n+        new Test9(new ValueClassSuperInitGood(5), \"abc\");\n+        new Test10(7) {};\n+        new Test11(9);\n+        new Test12();\n+        new Test13();\n+        Test14 t14 = new Test14();\n+        assert t14.x == 0 && t14.y == -1 && t14.z == 13;\n+        t14 = new Test14(7);\n+        assert t14.x == 7 && t14.y == -1 && t14.z == 13;\n+        new Test15c(new Test15(\"foo\"){}, \"bar\");\n+        new Test16().run();\n+        new Test17.StringHolder(\"foo\");\n+        try {\n+            new Test17.StringHolder(null);\n+            throw new Error();\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(true);\n+            assert false : \"expected exception\";\n+        } catch (Test18.MyException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(false);\n+        } catch (Test18.MyException e) {\n+            assert false : \"unexpected exception: \" + e;\n+        }\n+        new Test19(123);\n+        new Test20();\n+        new Test21();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitGood.java","additions":497,"deletions":0,"binary":false,"changes":497,"status":"added"},{"patch":"@@ -229,0 +229,2 @@\n+compiler.misc.feature.super.init                            # temporary as we are using statements before super in value classes\n+compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n- \/\/ key: compiler.misc.feature.super.init\n- \/\/ key: compiler.warn.preview.feature.use\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureStatementsBeforeSuper.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.this.exposed.prematurely\n+\/\/ key: compiler.err.cant.ref.before.ctor.called\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ThisExposedPrematurely.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-                \"         7: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n-                \"        16: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"         3: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        12: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-                this.v2 = v;    \/\/ OK, null not constant propagated.\n+                this.v2 = null;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FlattenableTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.Set;\n@@ -246,1 +247,1 @@\n-        assertFail(\"compiler.err.this.exposed.prematurely\",\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -257,1 +258,1 @@\n-        assertOK(\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -263,1 +264,1 @@\n-                        foo(this); \/\/ Ok.\n+                        foo(this); \/\/ error\n@@ -437,1 +438,1 @@\n-                        Assert.check((classFile.access_flags.flags & (Flags.VALUE_CLASS | Flags.FINAL)) != 0);\n+                        Assert.check((classFile.access_flags.flags & (Flags.FINAL)) != 0);\n@@ -470,1 +471,55 @@\n-                        Assert.check(field.access_flags.is(Flags.FINAL));\n+                        Set<String> fieldFlags = field.access_flags.getFieldFlags();\n+                        Assert.check(fieldFlags.size() == 2 && fieldFlags.contains(\"ACC_FINAL\") && fieldFlags.contains(\"ACC_STRICT\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testConstruction() throws Exception {\n+        for (String source : List.of(\n+                \"\"\"\n+                value class Test {\n+                    int i = 100;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        i = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        i = 100;\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        this.i = 100;\n+                        super();\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,return,\";\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                for (Method method : classFile.methods) {\n+                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                        Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                        String foundCodeSequence = \"\";\n+                        for (Instruction inst: code.getInstructions()) {\n+                            foundCodeSequence += inst.getMnemonic() + \",\";\n+                        }\n+                        Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n@@ -475,0 +530,37 @@\n+\n+        String source =\n+                \"\"\"\n+                value class Test {\n+                    int i = 100;\n+                    int j;\n+                    {\n+                        j = 200;\n+                    }\n+                }\n+                \"\"\";\n+        String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,aload_0,sipush,putfield,return,\";\n+        File dir = assertOK(true, source);\n+        for (final File fileEntry : dir.listFiles()) {\n+            ClassFile classFile = ClassFile.read(fileEntry);\n+            for (Method method : classFile.methods) {\n+                if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                    String foundCodeSequence = \"\";\n+                    for (Instruction inst: code.getInstructions()) {\n+                        foundCodeSequence += inst.getMnemonic() + \",\";\n+                    }\n+                    Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                }\n+            }\n+        }\n+\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+                \"\"\"\n+                value class Test {\n+                    Test() {\n+                        m();\n+                    }\n+                    void m() {}\n+                }\n+                \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":97,"deletions":5,"binary":false,"changes":102,"status":"modified"}]}