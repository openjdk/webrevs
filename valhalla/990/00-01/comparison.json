{"files":[{"patch":"@@ -1516,2 +1516,9 @@\n-                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0 && !sym.owner.isValueClass())\n-                        return new RefBeforeCtorCalledError(sym);\n+                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0) {\n+                        if (sym.owner.isValueClass()) {\n+                            if (!env.tree.hasTag(ASSIGN) || !TreeInfo.isIdentOrThisDotIdent(((JCAssign)env.tree).lhs)) {\n+                                return new RefBeforeCtorCalledError(sym);\n+                            }\n+                        } else {\n+                            return new RefBeforeCtorCalledError(sym);\n+                        }\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    public static final int ACC_STRICT        = 0x0800; \/\/                      field\n+    public static final int ACC_STRICT        = 0x0800; \/\/                      method, field\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8324873\n+ * @summary Permit additional statements before this\/super in constructors\n+ * @compile\/fail\/ref=ValueClassSuperInitFails.out -XDrawDiagnostics ValueClassSuperInitFails.java\n+ * @enablePreview\n+ *\/\n+\n+abstract value class AR<V> implements java.io.Serializable {\n+    public AR(V initialValue) {\n+    }\n+\n+    public AR() {\n+    }\n+}\n+\n+value class ValueClassSuperInitFails extends AR <Object> implements Iterable<Object> {\n+\n+    private int x;\n+\n+\/\/\/ GOOD EXAMPLES\n+\n+    public ValueClassSuperInitFails() {           \/\/ this should be OK\n+        \/\/ super()\n+    }\n+\n+    public ValueClassSuperInitFails(Object x) {\n+        this.x = x.hashCode();          \/\/ this should be OK\n+        \/\/ super();  the compiler will introduce the super call at this location\n+    }\n+\n+    public ValueClassSuperInitFails(byte x) {\n+        super();                        \/\/ this should be OK\n+    }\n+\n+    public ValueClassSuperInitFails(char x) {\n+        this((int)x);                   \/\/ this should be OK\n+    }\n+\n+\/\/\/ FAIL EXAMPLES\n+\n+    {\n+        this(1);                        \/\/ this should FAIL\n+    }\n+\n+    {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod1() {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod2() {\n+        this();                         \/\/ this should FAIL\n+    }\n+\n+    void normalMethod3() {\n+        Runnable r = () -> super();     \/\/ this should FAIL\n+    }\n+\n+    void normalMethod4() {\n+        Runnable r = () -> this();      \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(short x) {\n+        hashCode();                     \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(float x) {\n+        this.hashCode();                \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(int x) {\n+        super.hashCode();               \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(long x) {\n+        ValueClassSuperInitFails.this.hashCode();      \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(double x) {\n+        ValueClassSuperInitFails.super.hashCode();     \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(byte[] x) {\n+        {\n+            super();                    \/\/ this should FAIL\n+        }\n+    }\n+\n+    public ValueClassSuperInitFails(char[] x) {\n+        if (x.length == 0)\n+            return;                     \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(short[] x) {\n+        this.x = x.length;              \/\/ this should be OK\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(float[] x) {\n+        System.identityHashCode(this);  \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(int[] x) {\n+        this(this);                     \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(long[] x) {\n+        this(Object.this);              \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(double[] x) {\n+        Iterable.super.spliterator();   \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(byte[][] x) {\n+        super(new Object() {\n+            {\n+                super();                \/\/ this should FAIL\n+            }\n+        });\n+    }\n+\n+    public ValueClassSuperInitFails(char[][] x) {\n+        new Inner1();                   \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    class Inner1 {\n+    }\n+\n+    record Record1(int value) {\n+        Record1(float x) {              \/\/ this should FAIL\n+        }\n+    }\n+\n+    record Record2(int value) {\n+        Record2(float x) {              \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    @Override\n+    public java.util.Iterator<Object> iterator() {\n+        return null;\n+    }\n+\n+    public ValueClassSuperInitFails(short[][] x) {\n+        class Foo {\n+            Foo() {\n+                ValueClassSuperInitFails.this.hashCode();\n+            }\n+        };\n+        new Foo();                      \/\/ this should FAIL\n+        \/\/super();\n+    }\n+\n+    public ValueClassSuperInitFails(float[][] x) {\n+        Runnable r = () -> {\n+            super();                    \/\/ this should FAIL\n+        };\n+    }\n+\n+    public ValueClassSuperInitFails(int[][] z) {\n+        super((Runnable)() -> x);       \/\/ this should FAIL\n+    }\n+\n+    public ValueClassSuperInitFails(long[][] z) {\n+        super(new Inner1());            \/\/ this should FAIL\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+ValueClassSuperInitFails.java:67:9: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:72:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:77:9: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:82:33: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:87:33: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:109:33: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:114:14: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:118:20: compiler.err.not.encl.class: java.lang.Object\n+ValueClassSuperInitFails.java:122:17: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:129:22: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:143:9: compiler.err.non.canonical.constructor.invoke.another.constructor: ValueClassSuperInitFails.Record1\n+ValueClassSuperInitFails.java:148:9: compiler.err.non.canonical.constructor.invoke.another.constructor: ValueClassSuperInitFails.Record2\n+ValueClassSuperInitFails.java:164:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:175:31: compiler.err.cant.ref.before.ctor.called: x\n+ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:43:13: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:47:14: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:51:14: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:55:13: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:59:33: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:63:32: compiler.err.call.must.only.appear.in.ctor\n+ValueClassSuperInitFails.java:93:18: compiler.err.ctor.calls.not.allowed.here\n+ValueClassSuperInitFails.java:99:13: compiler.err.return.before.superclass.initialized\n+ValueClassSuperInitFails.java:170:18: compiler.err.ctor.calls.not.allowed.here\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,496 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324873\n+ * @summary Test valid placements of super()\/this() in constructors\n+ * @enablePreview\n+ *\/\n+\n+public value class ValueClassSuperInitGood {\n+\n+    ValueClassSuperInitGood(Object obj) {\n+    }\n+\n+    ValueClassSuperInitGood(int x) {\n+    }\n+\n+    \/\/ Default constructor provided by compiler\n+    static value class Test0 {\n+    }\n+\n+    \/\/ No explicit calls to this()\/super()\n+    static abstract value class Test1 {\n+        Test1() {\n+        }\n+        Test1(int a) {\n+            super();\n+            this.hashCode();\n+        }\n+    }\n+\n+    \/\/ Explicit calls to this()\/super()\n+    static abstract value class Test2<T> {\n+        static int i;\n+        Test2() {\n+            this(0);\n+        }\n+        Test2(int i) {\n+            Test2.i = i;\n+            super();\n+        }\n+        Test2(T obj) {\n+            this(java.util.Objects.hashCode(obj));\n+        }\n+        public T get() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Explicit this()\/super() with stuff in front\n+    static value class Test3 {\n+        int x;\n+        final int y;\n+        final int z;\n+\n+        Test3() {\n+            new Object().hashCode();\n+            new Object().hashCode();\n+            super();\n+            this.x = new Object().hashCode();\n+            this.y = new Object().hashCode() % 17;\n+            this.z = this.x + this.y;\n+        }\n+    }\n+\n+    static abstract value class Test5Abstract {\n+        Test5Abstract(Object obj) {}\n+    }\n+\n+    \/\/ Reference within constructor to outer class that's also my superclass\n+    abstract value class Test5 extends Test5Abstract {\n+        Test5(Object obj) {\n+            if (obj == null)\n+                throw new IllegalArgumentException();\n+            super(ValueClassSuperInitGood.this);      \/\/ NOT a 'this' reference\n+        }\n+    }\n+\n+    \/\/ Initialization blocks\n+    value class Test6 {\n+        final long startTime;\n+        final int x;\n+        {\n+            this.x = 12;\n+        }\n+        Test6() {\n+            long now = System.nanoTime();\n+            long then = now + 1000000L;\n+            while (System.nanoTime() < then) {\n+                try {\n+                    Thread.sleep(1);\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    break;\n+                }\n+            }\n+            super();\n+            this.startTime = now;\n+        }\n+    }\n+\n+    \/\/ Mix up inner classes, proxies, and super() calls\n+    \/\/ Copied mostly from UnverifiableInitForNestedLocalClassTest.java\n+    public static void test7(final String arg) {\n+        final String inlined = \" inlined \";\n+        abstract value class LocalClass {\n+            String m() {\n+                return \"LocalClass \" + arg + inlined;\n+            }\n+\n+            abstract value class SubClass extends LocalClass {\n+                @Override\n+                String m() {\n+                    return \"SubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            value class SubSubClass extends SubClass {\n+                @Override\n+                String m() {\n+                    return \"SubSubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            value class AnotherLocal {\n+                value class AnotherSub extends LocalClass {\n+                    AnotherSub() {\n+                    }\n+                    AnotherSub(int x) {\n+                        this((char)x);\n+                    }\n+                    AnotherSub(char y) {\n+                        super();\n+                    }\n+                    @Override\n+                    String m() {\n+                        return \"AnotherSub \" + arg + inlined;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Anonymous inner class\n+    public static void test8() {\n+        new Test2<Byte>(null) {\n+            @Override\n+            public Byte get() {\n+                return (byte)-1;\n+            }\n+        };\n+    }\n+\n+    \/\/ Qualified super() invocation\n+    public static value class Test9 extends Test5 {\n+\n+        public Test9(ValueClassSuperInitGood implicit, Object obj) {\n+            obj.hashCode();\n+            implicit.super(obj);\n+        }\n+    }\n+\n+    \/\/ Copied from WhichImplicitThis6\n+    public static abstract value class Test10 {\n+        private int i;\n+        public Test10(int i) { this.i = i; }\n+        public value class Sub extends Test10 {\n+            public Sub() {\n+                super(i); \/\/ i is not inherited, so it is the enclosing i\n+            }\n+        }\n+    }\n+\n+    \/\/ Two constructors where only one invokes super()\n+    public static value class Test11 {\n+        public Test11() {\n+        }\n+        public Test11(int x) {\n+            super();\n+        }\n+    }\n+\n+    \/\/ Nested version of the previous test\n+    public static value class Test12 {\n+        Test12() {\n+            class Sub {\n+                public Sub() {\n+                }\n+                public Sub(int j) {\n+                    super();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested super()'s requiring initialization code appended\n+    public static value class Test13 extends Test5Abstract {\n+        final int x = new Object().hashCode();\n+        Test13() {\n+            super(new Object() {\n+                public void foo() {\n+                    class Bar {\n+                        final int y = new Object().hashCode();\n+                        Bar() {\n+                            super();\n+                        }\n+                        Bar(int ignored) {\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ Initializer in initializer block\n+    public static value class Test14 {\n+        final int x;                \/\/ initialized in constructor\n+        final int y;                \/\/ initialized in initialization block\n+        final int z = 13;           \/\/ initialized with intializer value\n+        public Test14() {\n+            this(0);\n+        }\n+        public Test14(boolean z) {\n+            this.x = z ? 1 : 0;\n+        }\n+        public Test14(int x) {\n+            super();\n+            this.x = x;\n+        }\n+        {\n+            this.y = -1;\n+        }\n+    }\n+\n+    \/\/ Qualified super() invocation with superclass instance\n+    public static abstract value class Test15 {\n+\n+        final String name;\n+\n+        public Test15(String name) {\n+            this.name = name;\n+        }\n+\n+        public abstract value class Test15b extends Test15 {\n+\n+            public Test15b(String name) {\n+                super(name);\n+            }\n+\n+            public String getName() {\n+                return Test15.this.name;\n+            }\n+        }\n+    }\n+\n+    public static value class Test15c extends Test15.Test15b {\n+        public Test15c(Test15 a, String name) {\n+            a.super(name);\n+        }\n+    }\n+\n+    \/\/ Mixing up outer instances, proxies, and initializers\n+    public static value class Test16 {\n+\n+        final String x = String.valueOf(new Object().hashCode());\n+\n+        public void run() {\n+\n+            final String y = String.valueOf(new Object().hashCode());\n+\n+            class Sub {\n+\n+                final String z;\n+\n+                Sub(String z, int ignored) {\n+                    this(z, (float)ignored);\n+                }\n+\n+                Sub(String z, float ignored) {\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, byte ignored) {\n+                    super();\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, char ignored) {\n+                    this(z, (int)ignored);\n+                }\n+\n+                String x() {\n+                    return x;\n+                }\n+\n+                String y() {\n+                    return y;\n+                }\n+\n+                String z() {\n+                    return z;\n+                }\n+            }\n+\n+            final String z = String.valueOf(new Object().hashCode());\n+\n+            final Sub[] subs = new Sub[] {\n+                new Sub(z, 1),\n+                new Sub(z, -1),\n+                new Sub(z, (float)0),\n+                new Sub(z, (byte)0),\n+                new Sub(z, (char)0)\n+            };\n+\n+            for (int i = 0; i < subs.length; i++) {\n+                \/\/System.err.println(\"i = \" + i);\n+                final Sub sub = subs[i];\n+                final String subx = sub.x();\n+                final String suby = sub.y();\n+                final String subz = sub.z();\n+                if (!x.equals(subx))\n+                    throw new RuntimeException(\"x=\" + x + \" but sub[\" + i + \"].x()=\" + subx);\n+                if (!y.equals(suby))\n+                    throw new RuntimeException(\"y=\" + y + \" but sub[\" + i + \"].y()=\" + suby);\n+                if (!z.equals(subz))\n+                    throw new RuntimeException(\"z=\" + z + \" but sub[\" + i + \"].z()=\" + subz);\n+            }\n+        }\n+    }\n+\n+    \/\/ Records\n+    public value class Test17 {\n+\n+        record Rectangle(float length, float width) { }\n+\n+        record StringHolder(String string) {\n+            StringHolder {\n+                java.util.Objects.requireNonNull(string);\n+            }\n+        }\n+\n+        record ValueHolder(int value) {\n+            ValueHolder(float x) {\n+                if (Float.isNaN(x))\n+                    throw new IllegalArgumentException();\n+                this((int)x);\n+            }\n+        }\n+    }\n+\n+    static abstract value class AR<V> implements java.io.Serializable {\n+        public AR(V initialValue) {\n+        }\n+\n+        public AR() {\n+        }\n+\n+        public final V get() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Exceptions thrown by initializer block\n+    public static value class Test18 extends AR<Object> {\n+\n+        {\n+            if ((this.get().hashCode() % 3) == 0)\n+                throw new MyException();\n+        }\n+\n+        public Test18(Object obj) throws MyException {\n+            super(obj);\n+        }\n+\n+        public Test18(boolean fail) throws MyException {\n+            Object obj;\n+            for (obj = new Object(); true; obj = new Object()) {\n+                if (((obj.hashCode() % 3) == 0) != fail)\n+                    continue;\n+                break;\n+            }\n+            this(obj);\n+        }\n+\n+        public static class MyException extends Exception {\n+        }\n+    }\n+\n+    \/\/ super()\/this() within outer try block but inside inner class\n+    public static value class Test19 {\n+        public Test19(int x) {\n+            try {\n+                new Test1(x) {\n+                    @Override\n+                    public int hashCode() {\n+                        return x ^ super.hashCode();\n+                    }\n+                };\n+            } catch (StackOverflowError e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/\/ local class declared before super(), but not used until after super()\n+    public static value class Test20 {\n+        public Test20() {\n+            class Foo {\n+                Foo() {\n+                    Test20.this.hashCode();\n+                }\n+            }\n+            super();\n+            new Foo();\n+        }\n+    }\n+\n+    \/\/ local class inside super() parameter list\n+    public static value class Test21 extends AR<Object> {\n+        private int x = 1;\n+        public Test21() {\n+            super(switch (\"foo\".hashCode()) {\n+                default -> {\n+                    class Nested {{ System.out.println(x); }}       \/\/ class is NOT instantiated - OK\n+                    yield \"bar\";\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Test0();\n+        new Test1() {};\n+        new Test1(7) {};\n+        new Test2<Byte>() {};\n+        new Test2<>(args) {};\n+        new Test3();\n+        new ValueClassSuperInitGood(3).new Test5(3) {};\n+        new ValueClassSuperInitGood(3).new Test6();\n+        ValueClassSuperInitGood.test7(\"foo\");\n+        ValueClassSuperInitGood.test8();\n+        new Test9(new ValueClassSuperInitGood(5), \"abc\");\n+        new Test10(7) {};\n+        new Test11(9);\n+        new Test12();\n+        new Test13();\n+        Test14 t14 = new Test14();\n+        assert t14.x == 0 && t14.y == -1 && t14.z == 13;\n+        t14 = new Test14(7);\n+        assert t14.x == 7 && t14.y == -1 && t14.z == 13;\n+        new Test15c(new Test15(\"foo\"){}, \"bar\");\n+        new Test16().run();\n+        new Test17.StringHolder(\"foo\");\n+        try {\n+            new Test17.StringHolder(null);\n+            throw new Error();\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(true);\n+            assert false : \"expected exception\";\n+        } catch (Test18.MyException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(false);\n+        } catch (Test18.MyException e) {\n+            assert false : \"unexpected exception: \" + e;\n+        }\n+        new Test19(123);\n+        new Test20();\n+        new Test21();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitGood.java","additions":496,"deletions":0,"binary":false,"changes":496,"status":"added"},{"patch":"@@ -18,1 +18,1 @@\n-                this.v2 = v;    \/\/ OK, null not constant propagated.\n+                this.v2 = null;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FlattenableTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.Set;\n@@ -437,1 +438,1 @@\n-                        Assert.check((classFile.access_flags.flags & (Flags.VALUE_CLASS | Flags.FINAL)) != 0);\n+                        Assert.check((classFile.access_flags.flags & (Flags.FINAL)) != 0);\n@@ -470,1 +471,2 @@\n-                        Assert.check(field.access_flags.is(Flags.FINAL));\n+                        Set<String> fieldFlags = field.access_flags.getFieldFlags();\n+                        Assert.check(fieldFlags.size() == 2 && fieldFlags.contains(\"ACC_FINAL\") && fieldFlags.contains(\"ACC_STRICT\"));\n@@ -477,0 +479,90 @@\n+    @Test\n+    void testConstruction() throws Exception {\n+        for (String source : List.of(\n+                \"\"\"\n+                value class Test {\n+                    int i = 100;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        i = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        i = 100;\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        this.i = 100;\n+                        super();\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,return,\";\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                for (Method method : classFile.methods) {\n+                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                        Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                        String foundCodeSequence = \"\";\n+                        for (Instruction inst: code.getInstructions()) {\n+                            foundCodeSequence += inst.getMnemonic() + \",\";\n+                        }\n+                        Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                    }\n+                }\n+            }\n+        }\n+\n+        String source =\n+                \"\"\"\n+                value class Test {\n+                    int i = 100;\n+                    int j;\n+                    {\n+                        j = 200;\n+                    }\n+                }\n+                \"\"\";\n+        String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,aload_0,sipush,putfield,return,\";\n+        File dir = assertOK(true, source);\n+        for (final File fileEntry : dir.listFiles()) {\n+            ClassFile classFile = ClassFile.read(fileEntry);\n+            for (Method method : classFile.methods) {\n+                if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                    String foundCodeSequence = \"\";\n+                    for (Instruction inst: code.getInstructions()) {\n+                        foundCodeSequence += inst.getMnemonic() + \",\";\n+                    }\n+                    Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                }\n+            }\n+        }\n+\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+                \"\"\"\n+                value class Test {\n+                    Test() {\n+                        m();\n+                    }\n+                    void m() {}\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":94,"deletions":2,"binary":false,"changes":96,"status":"modified"}]}