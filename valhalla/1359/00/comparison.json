{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- *          java.base\/jdk.internal.org.objectweb.asm\n@@ -36,0 +35,7 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -40,1 +46,1 @@\n-import java.lang.invoke.TypeDescriptor;\n+import java.lang.runtime.ObjectMethods;\n@@ -44,1 +50,1 @@\n-import java.util.Arrays;\n+import java.util.List;\n@@ -47,5 +53,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ConstantDynamic;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -53,0 +54,3 @@\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -54,11 +58,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_IDENTITY;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.H_GETFIELD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.V19;\n@@ -73,1 +66,0 @@\n-        static final Handle[] ACCESSORS = accessors();\n@@ -75,1 +67,7 @@\n-        private static Handle[] accessors() {\n+        private static final ClassDesc CD_ValueRecord = ValueRecord.class.describeConstable().orElseThrow();\n+        private static final ClassDesc CD_ObjectMethods = ObjectMethods.class.describeConstable().orElseThrow();\n+        private static final MethodTypeDesc MTD_ObjectMethods_bootstrap = MethodTypeDesc.of(CD_Object, CD_MethodHandles_Lookup, CD_String,\n+                ClassDesc.ofInternalName(\"java\/lang\/invoke\/TypeDescriptor\"), CD_Class, CD_String, CD_MethodHandle.arrayType());\n+        static final List<DirectMethodHandleDesc> ACCESSORS = accessors();\n+\n+        private static List<DirectMethodHandleDesc> accessors() {\n@@ -77,4 +75,4 @@\n-                return  new Handle[]{\n-                        new Handle(H_GETFIELD, Type.getInternalName(ValueRecord.class), \"i\", \"I\", false),\n-                        new Handle(H_GETFIELD, Type.getInternalName(ValueRecord.class), \"name\", String.class.descriptorString(), false)\n-                };\n+                return List.of(\n+                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.GETTER, CD_ValueRecord, \"i\", CD_int),\n+                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.GETTER, CD_ValueRecord, \"name\", CD_String)\n+                );\n@@ -95,3 +93,26 @@\n-            ClassFileBuilder builder = new ClassFileBuilder(\"Test-\" + methodName);\n-            builder.bootstrapMethod(methodName, TO_STRING_DESC, ValueRecord.class, NAME_LIST, ACCESSORS);\n-            byte[] bytes = builder.build();\n+            String className = \"Test-\" + methodName;\n+            ClassDesc testClass = ClassDesc.of(className);\n+            byte[] bytes = ClassFile.of().build(testClass, clb -> clb\n+                    .withVersion(JAVA_19_VERSION, 0)\n+                    .withFlags(ACC_FINAL | ACC_SUPER)\n+                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> cob\n+                            .aload(0)\n+                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                            .return_())\n+                    .withMethodBody(\"bootstrap\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC | ACC_STATIC, cob -> cob\n+                            .loadConstant(DynamicConstantDesc.ofNamed(\n+                                    MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, CD_ObjectMethods,\n+                                            \"bootstrap\", MTD_ObjectMethods_bootstrap),\n+                                    methodName,\n+                                    CD_MethodHandle,\n+                                    Stream.concat(Stream.of(CD_ValueRecord, NAME_LIST), ACCESSORS.stream()).toArray(ConstantDesc[]::new)))\n+                            .areturn())\n+            );\n+\n+            Path p = Paths.get(className + \".class\");\n+            try (OutputStream os = Files.newOutputStream(p)) {\n+                os.write(bytes);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+\n@@ -118,59 +139,0 @@\n-\n-    static class ClassFileBuilder {\n-        private static final String OBJECT_CLS = \"java\/lang\/Object\";\n-        private static final String OBJ_METHODS_CLS = \"java\/lang\/runtime\/ObjectMethods\";\n-        private static final String BSM_DESCR =\n-                MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class,\n-                                      TypeDescriptor.class, Class.class, String.class, MethodHandle[].class)\n-                          .descriptorString();\n-        private final ClassWriter cw;\n-        private final String classname;\n-\n-        \/**\n-         * A builder to generate a class file to access class data\n-         *\n-         * @param classname\n-         *\/\n-        ClassFileBuilder(String classname) {\n-            this.classname = classname;\n-            this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-            cw.visit(V19, ACC_FINAL | ACC_IDENTITY, classname, null, OBJECT_CLS, null);\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLS, \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-        }\n-\n-        byte[] build() {\n-            cw.visitEnd();\n-            byte[] bytes = cw.toByteArray();\n-            Path p = Paths.get(classname + \".class\");\n-            try (OutputStream os = Files.newOutputStream(p)) {\n-                os.write(bytes);\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-            return bytes;\n-        }\n-\n-        \/*\n-         * Generate the bootstrap method that invokes ObjectMethods::bootstrap via condy\n-         *\/\n-        void bootstrapMethod(String name, TypeDescriptor descriptor, Class<?> recordClass, String names, Handle[] getters) {\n-            MethodType mtype = MethodType.methodType(Object.class);\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC|ACC_STATIC,\n-                    \"bootstrap\", mtype.descriptorString(), null, null);\n-            mv.visitCode();\n-            Handle bsm = new Handle(H_INVOKESTATIC, OBJ_METHODS_CLS, \"bootstrap\",\n-                                    BSM_DESCR, false);\n-            Object[] args = Stream.concat(Stream.of(Type.getType(recordClass), names), Arrays.stream(getters)).toArray();\n-            ConstantDynamic dynamic = new ConstantDynamic(name, MethodHandle.class.descriptorString(), bsm, args);\n-            mv.visitLdcInsn(dynamic);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-        }\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethodsViaCondy.java","additions":50,"deletions":88,"binary":false,"changes":138,"status":"modified"}]}