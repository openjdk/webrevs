{"files":[{"patch":"@@ -0,0 +1,1078 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340339\n+ * @modules jdk.incubator.vector\n+ * @build Bfloat16\n+ * @run main BasicBfloat16ArithTests\n+ * @summary Basic tests of Bfloat16 arithmetic and similar operations\n+ *\/\n+\n+import jdk.incubator.vector.Float16;\n+\/\/ import static Bfloat16.*; Cannot do static import from an unnamed package\n+import java.math.BigDecimal;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+public class BasicBfloat16ArithTests {\n+    private static float InfinityF = Float.POSITIVE_INFINITY;\n+    private static float NaNf = Float.NaN;\n+\n+    private static final float MAX_VAL_FP16 = 0x1.fep127f;\n+    private static final float MIN_VAL_FP16 = 0x1.0p-133f;\n+\n+    public static void main(String... args) {\n+        checkBitWise();\n+        checkHash();\n+        checkConstants();\n+        checkNegate();\n+        checkAbs();\n+        checkIsNaN();\n+        checkFiniteness();\n+        checkMinMax();\n+        checkArith();\n+        checkSqrt();\n+        checkGetExponent();\n+        checkUlp();\n+        checkValueOfFloat16();\n+        checkValueOfDoubleSimple();\n+        checkValueOfDouble();\n+        checkValueOfLong();\n+        checkValueOfBigDecimal();\n+        checkValueOfString();\n+        \/\/ checkBaseConversionRoundTrip();\n+        FusedMultiplyAddTests.main();\n+    }\n+\n+    \/*\n+     * The software implementation of Bfloat16 delegates to float or\n+     * double operations for most of the actual computation. This\n+     * regression test takes that into account as it generally only\n+     * has limited testing to probe whether or not the proper\n+     * functionality is being delegated to.\n+     *\n+     * To make the test easier to read, float literals that are exact\n+     * upon conversion to Bfloat16 are used for the test data.\n+     *\n+     * The float <-> Bfloat16 conversions are well-tested from prior\n+     * work and are assumed to be correct by this regression test.\n+     *\/\n+\n+    \/**\n+     * Verify handling of NaN representations\n+     *\/\n+    private static void checkBitWise() {\n+        \/\/ TOOD: port\n+        short nanImage = Bfloat16.bfloat16ToRawShortBits(Bfloat16.NaN);\n+\n+        int exponent = 0x7F80;\n+        int sign =     0x8000;\n+\n+        \/\/ All-zeros significand with a max exponent are infinite\n+        \/\/ values, not NaN values.\n+        for(int i = 0x1; i <= 0x007f; i++) {\n+            short  posNaNasShort = (short)(       exponent | i);\n+            short  negNaNasShort = (short)(sign | exponent | i);\n+\n+            Bfloat16 posf16 = Bfloat16.shortBitsToBfloat16(posNaNasShort);\n+            Bfloat16 negf16 = Bfloat16.shortBitsToBfloat16(negNaNasShort);\n+\n+            \/\/ Mask-off high-order 16 bits to avoid sign extension woes\n+            checkInt(nanImage & 0xffff, Bfloat16.bfloat16ToShortBits(posf16) & 0xffff, \"positive NaN\");\n+            checkInt(nanImage & 0xffff, Bfloat16.bfloat16ToShortBits(negf16) & 0xffff, \"negative NaN\");\n+\n+            checkInt(posNaNasShort & 0xffff, Bfloat16.bfloat16ToRawShortBits(posf16) & 0xffff , \"positive NaN\");\n+            checkInt(negNaNasShort & 0xffff, Bfloat16.bfloat16ToRawShortBits(negf16) & 0xffff, \"negative NaN\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify correct number of hashValue's from Bfloat16's.\n+     *\/\n+    private static void checkHash() {\n+        \/\/ Slightly over-allocate the HashSet.\n+        HashSet<Integer> set = HashSet.newHashSet(Short.MAX_VALUE - Short.MIN_VALUE + 1);\n+\n+        \/\/ Each non-NaN value should have a distinct hashCode. All NaN\n+        \/\/ values should share a single hashCode. Check the latter\n+        \/\/ property by verifying the overall count of entries in the\n+        \/\/ set.\n+        for(int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; i++) {\n+            Bfloat16 f16 = Bfloat16.shortBitsToBfloat16((short)i);\n+            boolean addedToSet = set.add(f16.hashCode());\n+\n+            if (!Bfloat16.isNaN(f16)) {\n+                if (!addedToSet) {\n+                    throwRE(\"Existing hash value for \" + f16);\n+                }\n+            }\n+        }\n+\n+        \/\/ There are 2^16 = 65,536 total short values. Each of these\n+        \/\/ bit patterns is a valid representation of a Bfloat16\n+        \/\/ value. However, NaNs have multiple possible encodings.\n+        \/\/ With an exponent = 0x7f80, each nonzero significand 0x1 to\n+        \/\/ 0x007f is a NaN, for both positive and negative sign bits.\n+        \/\/\n+        \/\/ Therefore, the total number of distinct hash codes for\n+        \/\/ Bfloat16 values should be:\n+        \/\/ 65_536 - 2*(127) + 1 = 65_283\n+\n+        int NaNcount = 2*((1 << (Bfloat16.PRECISION - 1)) - 1);\n+\n+        int setSize = set.size();\n+        if (setSize != (65_536 - NaNcount + 1)) {\n+            throwRE(\"Unexpected number of distinct hash values \" + setSize);\n+        }\n+    }\n+\n+    private static void checkConstants() {\n+        checkInt(Bfloat16.BYTES,           2, \"Bfloat16.BYTES\");\n+        checkInt(Bfloat16.MAX_EXPONENT,  127, \"Bfloat16.MAX_EXPONENT\");\n+        checkInt(Bfloat16.MIN_EXPONENT, -126, \"Bfloat16.MIN_EXPONENT\");\n+        checkInt(Bfloat16.PRECISION,      8, \"Bfloat16.PRECISION\");\n+        checkInt(Bfloat16.SIZE,          16, \"Bfloat16.SIZE\");\n+\n+        checkBfloat16(Bfloat16.MIN_VALUE,  0x1.0p-133f, \"Bfloat16.MIN_VALUE\");\n+        checkBfloat16(Bfloat16.MIN_NORMAL, 0x1.0p-126f, \"Bfloat16.MIN_NORMAL\");\n+        checkBfloat16(Bfloat16.MAX_VALUE,  0x1.fep127f,  \"Bfloat16.MAX_VALUE\");\n+\n+        checkBfloat16(Bfloat16.POSITIVE_INFINITY,   InfinityF,  \"+infinity\");\n+        checkBfloat16(Bfloat16.NEGATIVE_INFINITY,  -InfinityF,  \"-infinity\");\n+        checkBfloat16(Bfloat16.NaN,                 NaNf,            \"NaN\");\n+    }\n+\n+    private static void checkInt(int value, int expected, String message) {\n+        if (value != expected) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %d, got %d\",\n+                                  message, expected, value));\n+        }\n+    }\n+\n+    private static void checkBfloat16(Bfloat16 value16, float expected, String message) {\n+        float value = value16.floatValue();\n+        if (Float.compare(value, expected) != 0) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %g (%a), got %g (%a)\",\n+                                  message, expected, expected, value, value));\n+        }\n+    }\n+\n+    private static void checkNegate() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,  -0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,  -1.0f},\n+\n+            { InfinityF, -InfinityF},\n+            {-InfinityF,  InfinityF},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Bfloat16 result =  Bfloat16.negate(valueOfExact(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkBfloat16(result, expected, \"negate(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkAbs() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,   0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,   1.0f},\n+\n+            { InfinityF, InfinityF},\n+            {-InfinityF, InfinityF},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Bfloat16 result =  Bfloat16.abs(valueOfExact(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkBfloat16(result, expected, \"abs(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkIsNaN() {\n+        if (!Bfloat16.isNaN(Bfloat16.NaN)) {\n+            throwRE(\"Bfloat16.isNaN() returns false for a NaN\");\n+        }\n+\n+        float[] testCases = {\n+            -InfinityF,\n+             InfinityF,\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var testCase : testCases) {\n+            boolean result = Bfloat16.isNaN(valueOfExact(testCase));\n+            if (result) {\n+                throwRE(\"isNaN returned true for \" + testCase);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkFiniteness() {\n+        float[] infinities = {\n+            -InfinityF,\n+             InfinityF,\n+        };\n+\n+        for(var infinity : infinities) {\n+            boolean result1 = Bfloat16.isFinite(valueOfExact(infinity));\n+            boolean result2 = Bfloat16.isInfinite(valueOfExact(infinity));\n+\n+            if (result1) {\n+                throwRE(\"Bfloat16.isFinite returned true for \" + infinity);\n+            }\n+\n+            if (!result2) {\n+                throwRE(\"Bfloat16.isInfinite returned false for \" + infinity);\n+            }\n+        }\n+\n+        if (Bfloat16.isFinite(Bfloat16.NaN)) {\n+            throwRE(\"Bfloat16.isFinite() returns true for a NaN\");\n+        }\n+\n+        if (Bfloat16.isInfinite(Bfloat16.NaN)) {\n+            throwRE(\"Bfloat16.isInfinite() returns true for a NaN\");\n+        }\n+\n+        float[] finities = {\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var finity : finities) {\n+            boolean result1 = Bfloat16.isFinite(valueOfExact(finity));\n+            boolean result2 = Bfloat16.isInfinite(valueOfExact(finity));\n+\n+            if (!result1) {\n+                throwRE(\"Bfloat16.isFinite returned true for \" + finity);\n+            }\n+\n+            if (result2) {\n+                throwRE(\"Bfloat16.isInfinite returned true for \" + finity);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkMinMax() {\n+        float small = 1.0f;\n+        float large = 2.0f;\n+\n+        if (Bfloat16.min(valueOfExact(small), valueOfExact(large)).floatValue() != small) {\n+            throwRE(String.format(\"min(%g, %g) not equal to %g)\",\n+                                  small, large, small));\n+        }\n+\n+        if (Bfloat16.max(valueOfExact(small), valueOfExact(large)).floatValue() != large) {\n+            throwRE(String.format(\"max(%g, %g) not equal to %g)\",\n+                                  small, large, large));\n+        }\n+    }\n+\n+    \/*\n+     * Cursory checks to make sure correct operation is being called\n+     * with arguments in proper order.\n+     *\/\n+    private static void checkArith() {\n+        float   a   = 1.0f;\n+        Bfloat16 a16 = valueOfExact(a);\n+\n+        float   b   = 2.0f;\n+        Bfloat16 b16 = valueOfExact(b);\n+\n+        if (Bfloat16.add(a16, b16).floatValue() != (a + b)) {\n+            throwRE(\"failure with \" + a16 + \" + \" + b16);\n+        }\n+        if (Bfloat16.add(b16, a16).floatValue() != (b + a)) {\n+            throwRE(\"failure with \" + b16 + \" + \" + a16);\n+        }\n+\n+        if (Bfloat16.subtract(a16, b16).floatValue() != (a - b)) {\n+            throwRE(\"failure with \" + a16 + \" - \" + b16);\n+        }\n+        if (Bfloat16.subtract(b16, a16).floatValue() != (b - a)) {\n+            throwRE(\"failure with \" + b16 + \" - \" + a16);\n+        }\n+\n+        if (Bfloat16.multiply(a16, b16).floatValue() != (a * b)) {\n+            throwRE(\"failure with \" + a16 + \" * \" + b16);\n+        }\n+        if (Bfloat16.multiply(b16, a16).floatValue() != (b * a)) {\n+            throwRE(\"failure with \" + b16 + \" * \" + a16);\n+        }\n+\n+        if (Bfloat16.divide(a16, b16).floatValue() != (a \/ b)) {\n+            throwRE(\"failure with \" + a16 + \" \/ \" + b16);\n+        }\n+        if (Bfloat16.divide(b16, a16).floatValue() != (b \/ a)) {\n+            throwRE(\"failure with \" + b16 + \" \/ \" + a16);\n+        }\n+        return;\n+    }\n+\n+    private static void checkSqrt() {\n+        float[][] testCases = {\n+            {-0.0f,   -0.0f},\n+            { 0.0f,    0.0f},\n+\n+            {1.0f,   1.0f},\n+            {4.0f,   2.0f},\n+            {9.0f,   3.0f},\n+\n+            { InfinityF, InfinityF},\n+            {-InfinityF, NaNf},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg       = testCase[0];\n+            float expected  = testCase[1];\n+            Bfloat16 result = Bfloat16.sqrt(valueOfExact(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkBfloat16(result, expected, \"sqrt(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkGetExponent() {\n+        float[][] testCases = {\n+            \/\/ Non-finite values\n+            { InfinityF,    Bfloat16.MAX_EXPONENT + 1},\n+            {-InfinityF,    Bfloat16.MAX_EXPONENT + 1},\n+            { NaNf,         Bfloat16.MAX_EXPONENT + 1},\n+\n+            \/\/ Subnormal and almost subnormal values\n+            {-0.0f,         Bfloat16.MIN_EXPONENT - 1},\n+            {+0.0f,         Bfloat16.MIN_EXPONENT - 1},\n+\n+            \/\/ Bfloat16 cardinal values\n+            { 0x1.0p-133f,  Bfloat16.MIN_EXPONENT - 1}, \/\/ Bfloat16.MIN_VALUE\n+            {-0x1.0p-133f,  Bfloat16.MIN_EXPONENT - 1}, \/\/ Bfloat16.MIN_VALUE\n+            { 0x1.0p-126f,  Bfloat16.MIN_EXPONENT},     \/\/ Bfloat16.MIN_NORMAL\n+            {-0x1.0p-126f,  Bfloat16.MIN_EXPONENT},     \/\/ Bfloat16.MIN_NORMAL\n+            { 0x1.fep127f,  Bfloat16.MAX_EXPONENT},     \/\/ Bfloat16.MAX_NORMAL\n+            {-0x1.fep127f,  Bfloat16.MAX_EXPONENT},     \/\/ Bfloat16.MAX_NORMAL\n+\n+            \/\/ Float16 cardinal values\n+            { 0x1.0p-24f,   -24},                       \/\/ Float16.MIN_VALUE\n+            {-0x1.0p-24f,   -24},                       \/\/ Float16.MIN_VALUE\n+            { 0x1.0p-14f,   -14},                       \/\/ Float16.MIN_NORMAL\n+            {-0x1.0p-14f,   -14},                       \/\/ Float16.MIN_NORMAL\n+            { 0x1.ffcp15f,   16},                       \/\/ Float16.MAX_VALUE (rounds up)\n+            {-0x1.ffcp15f,   16},                       \/\/ Float16.MAX_VALUE (rounds up)\n+\n+            \/\/ Normal values\n+            { 1.0f,       0},\n+            { 2.0f,       1},\n+            { 4.0f,       2},\n+\n+            {MAX_VAL_FP16*0.5f, Bfloat16.MAX_EXPONENT - 1},\n+            {MAX_VAL_FP16,      Bfloat16.MAX_EXPONENT},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            float result =  Bfloat16.getExponent(Bfloat16.valueOf(arg));\n+\n+            if (Float.compare(expected, result) != 0) {\n+                checkBfloat16(Bfloat16.valueOf(result), expected, \"getExponent(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    private static void checkUlp() {\n+        float[][] testCases = {\n+            { InfinityF, InfinityF},\n+            {-InfinityF, InfinityF},\n+            { NaNf,      NaNf},\n+\n+            \/\/ Zeros, subnormals, and MIN_VALUE all have MIN_VALUE as an ulp.\n+            {-0.0f,        0x1.0p-133f},\n+            {+0.0f,        0x1.0p-133f},\n+            { 0x1.0p-133f, 0x1.0p-133f},\n+            {-0x1.0p-133f, 0x1.0p-133f},\n+            { 0x1.0p-132f, 0x1.0p-133f},\n+            {-0x1.0p-132f, 0x1.0p-133f},\n+            { 0x1.0p-127f, 0x1.0p-133f},\n+            {-0x1.0p-127f, 0x1.0p-133f},\n+\n+            \/\/ ulp is 7 bits away\n+            {0x1.0p0f,       0x1.0p-7f}, \/\/ 1.0f\n+            {0x1.0p1f,       0x1.0p-6f}, \/\/ 2.0f\n+            {0x1.0p2f,       0x1.0p-5f}, \/\/ 4.0f\n+\n+            { MAX_VAL_FP16,  0x1.0p120f}, \/\/  MAX_VALUE\n+            {-MAX_VAL_FP16,  0x1.0p120f}, \/\/ -MAX_VALUE\n+\n+\/\/             {MAX_VAL_FP16*0.5f, 0x0.004p14f},\n+\/\/             {MAX_VAL_FP16,      0x0.004p15f},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            \/\/ Exponents are in-range for Bfloat16\n+            Bfloat16 result =  Bfloat16.ulp(valueOfExact(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkBfloat16(result, expected, \"ulp(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    private static void throwRE(String message) {\n+        throw new RuntimeException(message);\n+    }\n+\n+    private static void checkValueOfFloat16() {\n+        \/\/ {Float16 value stored as float, Float16 value converted to Bfloat16 stored as float}\n+        float[][] testCases = {\n+            {InfinityF, InfinityF},\n+            {NaNf, NaNf},\n+\n+            {-0.0f, -0.0f},\n+            {+0.0f, +0.0f},\n+\n+            {1.0f,   1.0f},\n+            {-1.0f, -1.0f},\n+\n+            {65504.0f,   0x1.0p16f},  \/\/ Float16.MIN_VALUE rounds up in Bfloat16.\n+            {0x1.0p-14f, 0x1.0p-14f}, \/\/ Float16.MIN_NORMAL carries over to BFloat16\n+            {0x1.0p-24f, 0x1.0p-24f}, \/\/ Float16.MIN_VALUE carries over to BFloat16\n+        };\n+\n+        for(var testCase : testCases) {\n+            float input     = testCase[0];\n+            float expected  = testCase[1];\n+            Bfloat16 actual = Bfloat16.valueOf(Float16.valueOf(input));\n+\n+            checkBfloat16(actual, expected, \"Unexpected conversion of Float16 value\" + input);\n+        }\n+    }\n+\n+    private static void checkValueOfDoubleSimple() {\n+        \/\/ Check special cases first; double value to be converted to\n+        \/\/ BFloat16, then converted back\n+        double[][] testCases = {\n+            {InfinityF, InfinityF},\n+            {NaNf, NaNf},\n+\n+            {-0.0, -0.0},\n+            {+0.0, +0.0},\n+\n+            { Double.MIN_VALUE,  0.0},\n+            {-Double.MIN_VALUE, -0.0},\n+\n+            { 0x1.0p-133f * 0.5d,  0.0},\n+            {-0x1.0p-133f * 0.5d, -0.0},\n+\n+            { 0x1.0p-1024d,  0.0},\n+            {-0x1.0p-1024d, -0.0},\n+\n+            {1.0, 1.0},\n+            {2.0, 2.0},\n+\n+            {0x1.fep127f + 0x0.00fp127f, (Bfloat16.MAX_VALUE).doubleValue()},\n+            {0x1.fep127f + 0x0.01p127f,  InfinityF},\n+            {0x1.fep127f + 0x0.02p127f,  InfinityF},\n+\n+            {0x1.0p-126f, 0x1.0p-126}, \/\/ Bfloat16.MIN_NORMAL\n+            {0x1.fp-126f, 0x1.fp-126},\n+\n+            \/\/ Reorder after code fixed\n+             {Math.nextUp( 0x1.0p-133f * 0.5d),  0x1.0p-133}, \/\/ Bfloat16.MIN_VALUE\n+        };\n+\n+        System.out.println(Bfloat16.toHexString(Bfloat16.MIN_VALUE));\n+        System.out.println(Double.toHexString(Bfloat16.MIN_VALUE.doubleValue()));\n+\n+        for(var testCase : testCases) {\n+            double input   = testCase[0];\n+            double expected = testCase[1];\n+            double actual = Bfloat16.valueOf(input).doubleValue();\n+\n+            if (Double.compare(expected, actual) != 0) {\n+                System.err.println(\"Unexpected result handling \" + input + \" (\" + Double.toHexString(input) + \")\");\n+                System.err.println(\"Expected  \" + expected + \" (\" + Double.toHexString(expected) + \")\" + \" got \" + actual + \" (\" +  Double.toHexString(actual) + \")\");\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    private static void checkValueOfDouble() {\n+        \/*\n+         * Check that double -> Bfloat16 conversion rounds properly\n+         * around the midway point for each finite Bfloat16 value by\n+         * looping over the positive values and checking the negations\n+         * along the way.\n+         *\/\n+\n+        String roundUpMsg   = \"Didn't get half-way case rounding down\";\n+        String roundDownMsg = \"Didn't get half-way case rounding up\";\n+\n+        for(int i = 0; i <= Short.MAX_VALUE; i++ ) {\n+            boolean isEven = ((i & 0x1) == 0);\n+            Bfloat16 f16 = Bfloat16.shortBitsToBfloat16((short)i);\n+            Bfloat16 f16Neg = Bfloat16.negate(f16);\n+\n+            if (!Bfloat16.isFinite(f16))\n+                continue;\n+\n+            Bfloat16 ulp = Bfloat16.ulp(f16);\n+            double halfWay = f16.doubleValue() + ulp.doubleValue() * 0.5;\n+\n+            \/\/ Under the round to nearest even rounding policy, the\n+            \/\/ half-way case should round down to the starting value\n+            \/\/ if the starting value is even; otherwise, it should round up.\n+            float roundedBack = Bfloat16.valueOf(halfWay).floatValue();\n+            float roundedBackNeg = Bfloat16.valueOf(-halfWay).floatValue();\n+\n+            if (isEven) {\n+                checkBfloat16(f16,    roundedBack,    roundDownMsg);\n+                checkBfloat16(f16Neg, roundedBackNeg, roundDownMsg);\n+            } else {\n+                checkBfloat16(Bfloat16.add(f16,         ulp), roundedBack,    roundUpMsg);\n+                checkBfloat16(Bfloat16.subtract(f16Neg, ulp), roundedBackNeg, roundUpMsg);\n+            }\n+\n+            \/\/ Should always round down\n+            double halfWayNextDown = Math.nextDown(halfWay);\n+            checkBfloat16(f16,    Bfloat16.valueOf(halfWayNextDown).floatValue(),  roundDownMsg);\n+            checkBfloat16(f16Neg, Bfloat16.valueOf(-halfWayNextDown).floatValue(), roundDownMsg);\n+\n+            \/\/ Should always round up\n+            double halfWayNextUp =   Math.nextUp(halfWay);\n+            checkBfloat16(Bfloat16.add(f16, ulp),         Bfloat16.valueOf( halfWayNextUp).floatValue(), roundUpMsg);\n+            checkBfloat16(Bfloat16.subtract(f16Neg, ulp), Bfloat16.valueOf(-halfWayNextUp).floatValue(), roundUpMsg);\n+        }\n+    }\n+\n+    private static void checkValueOfLong() {\n+        checkBfloat16(Bfloat16.valueOf(0L),  0.0f, \"zero\");\n+        checkBfloat16(Bfloat16.valueOf(1L),  1.0f, \"one\");\n+        checkBfloat16(Bfloat16.valueOf(2L),  2.0f, \"two\");\n+        checkBfloat16(Bfloat16.valueOf(Long.MIN_VALUE),  -0x1.0p63f, \"MIN_VALUE\");\n+        checkBfloat16(Bfloat16.valueOf(Long.MAX_VALUE),   0x1.0p63f, \"MAX_VALUE\");\n+\n+        \/\/ Values near +\/- 2^54, limit where double can hold all contiguous integers\n+        checkBfloat16(Bfloat16.valueOf( 0x40_0000_0000_0000L),   0x1.0p54f, \"transition\");\n+        checkBfloat16(Bfloat16.valueOf(-0x40_0000_0000_0000L),  -0x1.0p54f, \"transition\");\n+        checkBfloat16(Bfloat16.valueOf( 0x3f_ffff_ffff_ffffL),   0x1.0p54f, \"transition\");\n+        checkBfloat16(Bfloat16.valueOf(-0x3f_ffff_ffff_ffffL),  -0x1.0p54f, \"transition\");\n+\n+        \/\/ Probe around rounding transition\n+        checkBfloat16(Bfloat16.valueOf(0x7F80_0000_0000_0001L),  0x1.fep62f, \"transition\");\n+        checkBfloat16(Bfloat16.valueOf(0x7FB0_0000_0000_0001L),  0x1.fep62f, \"transition\");\n+        checkBfloat16(Bfloat16.valueOf(0x7FBF_0000_0000_0001L),  0x1.fep62f, \"transition\");\n+        checkBfloat16(Bfloat16.valueOf(0x7F80_0000_0000_0000L),  0x1.fep62f, \"transition\");\n+\n+        checkBfloat16(Bfloat16.valueOf(0x7FC0_0000_0000_0000L),  0x1.00p63f, \"transition\");\n+\n+        checkBfloat16(Bfloat16.valueOf(0x7_fbff_ffff_ffff_dffL), 0x1.fe0p62f, \"rounding\");\n+\n+        \/\/ Double-rounding hazard if full argument is converted to\n+        \/\/ double first before a second conversion to Bfloat16.\n+        checkBfloat16(Bfloat16.valueOf( 0x7_fbff_ffff_ffff_fffL),  0x1.fe0p62f, \"rounding\");\n+        checkBfloat16(Bfloat16.valueOf(-0x7_fbff_ffff_ffff_fffL), -0x1.fe0p62f, \"rounding\");\n+\n+        checkBfloat16(Bfloat16.valueOf(0x7_ffff_ffff_ffff_fffL), 0x1.00p63f, \"rounding\");\n+    }\n+\n+    private static void checkValueOfBigDecimal() {\n+        Bd2Bfloat16Case[] testCases = {\n+            new Bd2Bfloat16Case(BigDecimal.ZERO,          0.0f),\n+\n+            new Bd2Bfloat16Case(BigDecimal.ONE,           1.0f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"1.0\"),    1.0f),\n+            new Bd2Bfloat16Case(BigDecimal.TEN,           10.0f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"10.0\"),   10.0f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"100\"),    100.0f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"100.0\"),  100.0f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"1000\"),   1000.0f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"1000.0\"), 1000.0f),\n+\n+            new Bd2Bfloat16Case(new BigDecimal(\"9984\"), 9984.0f), \/\/ exact value\n+            new Bd2Bfloat16Case(new BigDecimal(\"9984.0\"), 9984.0f),\n+\n+            new Bd2Bfloat16Case(new BigDecimal(\"10000\"), 9984.0f), \/\/ rounding\n+\n+            new Bd2Bfloat16Case(new BigDecimal(\"0.25\"),  0.25f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"0.125\"), 0.125f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"0.0625\"), 0.0625f),\n+\n+            new Bd2Bfloat16Case(new BigDecimal(\"0.6875\"), 0.6875f), \/\/ \"0x1.6p-1\"\n+\n+            \/\/ Convert +\/-0x7_fbff_ffff_ffff_fffL; would experience\n+            \/\/ double-rounding if a direct conversion to double was\n+            \/\/ done before converting to Bfloat16.\n+            new Bd2Bfloat16Case(new BigDecimal( \"9205357638345293823\"),  0x1.fe0p62f),\n+            new Bd2Bfloat16Case(new BigDecimal(\"-9205357638345293823\"), -0x1.fe0p62f),\n+\n+\n+        };\n+\n+        for(Bd2Bfloat16Case testCase : testCases) {\n+            BigDecimal input = testCase.input();\n+            float expected = testCase.expected();\n+            Bfloat16 result = Bfloat16.valueOf(input);\n+            checkBfloat16(result, expected, \"Bfloat16.valueOf(BigDecimal) \" + input);\n+        }\n+\n+        return;\n+    }\n+\n+    private static record Bd2Bfloat16Case(BigDecimal input, float expected) {\n+    }\n+\n+    private static void checkValueOfString() {\n+        String2Bfloat16Case[] testCases = {\n+            new String2Bfloat16Case( \"NaN\", NaNf),\n+            new String2Bfloat16Case(\"+NaN\", NaNf),\n+            new String2Bfloat16Case(\"-NaN\", NaNf),\n+\n+            new String2Bfloat16Case(\"+Infinity\", +InfinityF),\n+            new String2Bfloat16Case(\"-Infinity\", -InfinityF),\n+\n+            new String2Bfloat16Case( \"0.0\",  0.0f),\n+            new String2Bfloat16Case(\"+0.0\",  0.0f),\n+            new String2Bfloat16Case(\"-0.0\", -0.0f),\n+\n+            \/\/ Decimal signed integers are accepted as input; hex\n+            \/\/ signed integers are not, see negative test cases below.\n+            new String2Bfloat16Case( \"1\",  1.0f),\n+            new String2Bfloat16Case(\"-1\", -1.0f),\n+\n+            new String2Bfloat16Case( \"12\",  12.0f),\n+            new String2Bfloat16Case(\"-12\", -12.0f),\n+\n+            new String2Bfloat16Case( \"123\",  123.0f),\n+            new String2Bfloat16Case(\"-123\", -123.0f),\n+\n+            new String2Bfloat16Case( \"1.0\",  1.0f),\n+            new String2Bfloat16Case(\"-1.0\", -1.0f),\n+\n+            \/\/ Check for FloatTypeSuffix handling\n+            new String2Bfloat16Case( \"1.5f\", 1.5f),\n+            new String2Bfloat16Case( \"1.5F\", 1.5f),\n+            new String2Bfloat16Case( \"1.5D\", 1.5f),\n+            new String2Bfloat16Case( \"1.5d\", 1.5f),\n+\n+            new String2Bfloat16Case(\"65504.0\", 0x1.0p16f),  \/\/ Float16.MAX_VALUE, rounds up in Bfloat16\n+\n+            \/\/ Bfloat16.MAX_VALUE in hex and decimal\n+            new String2Bfloat16Case(\"0x1.fep127\", 0x1.fep127f),\n+            new String2Bfloat16Case(\"338953138925153547590470800371487866880.0\", 0x1.fep127f),\n+\n+            \/\/ Bfloat16.MAX_VALUE + 0.5*ulp in hex and decimal\n+            new String2Bfloat16Case(\"0x1.ffp127\", InfinityF),\n+            new String2Bfloat16Case(\"339617752923046005526922703901628039168.0\", InfinityF),\n+\n+\n+\/\/             new String2Bfloat16Case(\"65520.01\", InfinityF), \/\/ Bfloat16.MAX_VALUE + > 0.5*ulp\n+\/\/             new String2Bfloat16Case(\"65520.001\", InfinityF), \/\/ Bfloat16.MAX_VALUE + > 0.5*ulp\n+\/\/             new String2Bfloat16Case(\"65520.0001\", InfinityF), \/\/ Bfloat16.MAX_VALUE + > 0.5*ulp\n+\/\/             new String2Bfloat16Case(\"65520.00000000001\", InfinityF), \/\/ Bfloat16.MAX_VALUE + > 0.5*ulp\n+\n+\/\/             new String2Bfloat16Case(\"65519.99999999999\", 65504.0f), \/\/ Bfloat16.MAX_VALUE +  < 0.5*ulp\n+\/\/             new String2Bfloat16Case(\"0x1.ffdffffffffffp15\", 65504.0f),\n+\/\/             new String2Bfloat16Case(\"0x1.ffdfffffffffp15\", 65504.0f), \/\/ -- FIXME\n+\n+\n+\/\/             new String2Bfloat16Case(\"65519.999999999999\", 65504.0f),\n+\/\/             new String2Bfloat16Case(\"65519.9999999999999\", 65504.0f),\n+\/\/             new String2Bfloat16Case(\"65519.99999999999999\", 65504.0f),\n+\/\/             new String2Bfloat16Case(\"65519.999999999999999\", 65504.0f),\n+\n+\/\/             \/\/ Bfloat16.MAX_VALUE +  < 0.5*ulp\n+\/\/             new String2Bfloat16Case(\"65519.9999999999999999999999999999999999999\", 65504.0f),\n+\n+\/\/             \/\/ Near MAX_VALUE - 0.5 ulp\n+\/\/             new String2Bfloat16Case(\"65488.0\", 65472.0f),\n+\/\/             new String2Bfloat16Case(\"65487.9999\", 65472.0f),\n+\/\/             new String2Bfloat16Case(\"65487.99999999\", 65472.0f),\n+\/\/             new String2Bfloat16Case(\"65487.9999999999999999\", 65472.0f),\n+\n+\/\/             new String2Bfloat16Case(\"65488.000001\", MAX_VAL_FP16),\n+\n+\/\/             new String2Bfloat16Case(\"65536.0\", InfinityF), \/\/ Bfloat16.MAX_VALUE + ulp\n+\n+            \/\/ Double-rounding hazard\n+            new String2Bfloat16Case(\"0x7fbffffffffffdffp0\",   0x1.fe0p62f),\n+            new String2Bfloat16Case(\"0x7fbffffffffffdffp-1\",  0x1.fe0p61f),\n+            new String2Bfloat16Case(\"0x7fbffffffffffdffp-64\", 0x1.fe0p-02f),\n+\n+            new String2Bfloat16Case(\"0x7fffffffffffffffp0\",   0x1.00p63f),\n+\n+            \/\/ Hex values\n+            new String2Bfloat16Case(\"0x1p2\",   0x1.0p2f),\n+            new String2Bfloat16Case(\"0x1p2f\",  0x1.0p2f),\n+            new String2Bfloat16Case(\"0x1p2d\",  0x1.0p2f),\n+            new String2Bfloat16Case(\"0x1.0p1\", 0x1.0p1f),\n+\n+            new String2Bfloat16Case(\"-0x1p2\",  -0x1.0p2f),\n+            new String2Bfloat16Case(\"0x3.48p12\", 0x3.48p12f),\n+\n+            new String2Bfloat16Case(\"0x3.4800000001p12\", 0x3.48p12f),\n+\n+            \/\/ Near half-way double + float cases in hex\n+            \/\/            new String2Bfloat16Case(\"0x1.ffdfffffffffffffffffffffffffffffffffffp15\", 65504.0f),\n+\n+        };\n+\n+        for(String2Bfloat16Case testCase : testCases) {\n+            String input = testCase.input();\n+            float expected = testCase.expected();\n+            Bfloat16 result = Bfloat16.valueOf(input);\n+            checkBfloat16(result, expected, \"Bfloat16.valueOf(String) \" + input);\n+        }\n+\n+        List<String> negativeCases = List.of(\"0x1\",\n+                                       \"-0x1\",\n+                                        \"0x12\",\n+                                       \"-0x12\");\n+\n+        for(String negativeCase : negativeCases) {\n+            try {\n+                Bfloat16 f16 = Bfloat16.valueOf(negativeCase);\n+                throwRE(\"Did not get expected exception for input \" + negativeCase);\n+            } catch (NumberFormatException nfe) {\n+                ; \/\/ Expected\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static record String2Bfloat16Case(String input, float expected) {\n+    }\n+\n+    private static void checkBaseConversionRoundTrip() {\n+        checkBfloat16(Bfloat16.NaN,\n+                     Bfloat16.valueOf(\"NaN\").floatValue(),\n+                     \"base conversion of NaN\");\n+\n+        \/\/ For each non-NaN value, make sure\n+        \/\/ value -> string -> value\n+        \/\/ sequence of conversions gives the expected result.\n+\n+        for(int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; i++) {\n+            Bfloat16 f16 = Bfloat16.shortBitsToBfloat16((short)i);\n+            if (Bfloat16.isNaN(f16))\n+                continue;\n+\n+            checkBfloat16(f16,\n+                         Bfloat16.valueOf(Bfloat16.toString(f16)).floatValue(),\n+                         \"base conversion\");\n+        }\n+        return;\n+    }\n+\n+    private static class FusedMultiplyAddTests {\n+        public static void main(String... args) {\n+            testZeroNanInfCombos();\n+            testNonFinite();\n+            testZeroes();\n+            testSimple();\n+            testRounding();\n+        }\n+\n+        private static void testZeroNanInfCombos() {\n+            float [] testInputs = {\n+                Float.NaN,\n+                -InfinityF,\n+                +InfinityF,\n+                -0.0f,\n+                +0.0f,\n+            };\n+\n+            for (float i : testInputs) {\n+                for (float j : testInputs) {\n+                    for (float k : testInputs) {\n+                        testFusedMacCase(i, j, k, Math.fma(i, j, k));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static void testNonFinite() {\n+            float [][] testCases = {\n+                {1.0f,       InfinityF,  2.0f,\n+                 InfinityF},\n+\n+                {1.0f,       2.0f,       InfinityF,\n+                 InfinityF},\n+\n+                {InfinityF,  1.0f,       InfinityF,\n+                 InfinityF},\n+\n+\/\/                 {0x1.ffcp14f, 2.0f,     -InfinityF, \/\/ TOOD\n+\/\/                  -InfinityF},\n+\n+                {InfinityF,  1.0f,      -InfinityF,\n+                 NaNf},\n+\n+                {-InfinityF, 1.0f,       InfinityF,\n+                 NaNf},\n+\n+                {1.0f,       NaNf,       2.0f,\n+                 NaNf},\n+\n+                {1.0f,       2.0f,       NaNf,\n+                 NaNf},\n+\n+                {InfinityF,  2.0f,       NaNf,\n+                 NaNf},\n+\n+                {NaNf,       2.0f,       InfinityF,\n+                 NaNf},\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testZeroes() {\n+            float [][] testCases = {\n+                {+0.0f, +0.0f, +0.0f,\n+                 +0.0f},\n+\n+                {-0.0f, +0.0f, +0.0f,\n+                 +0.0f},\n+\n+                {+0.0f, +0.0f, -0.0f,\n+                 +0.0f},\n+\n+                {+0.0f, +0.0f, -0.0f,\n+                 +0.0f},\n+\n+                {-0.0f, +0.0f, -0.0f,\n+                 -0.0f},\n+\n+                {-0.0f, -0.0f, -0.0f,\n+                 +0.0f},\n+\n+                {-1.0f, +0.0f, -0.0f,\n+                 -0.0f},\n+\n+                {-1.0f, +0.0f, +0.0f,\n+                 +0.0f},\n+\n+                {-2.0f, +0.0f, -0.0f,\n+                 -0.0f},\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testSimple() {\n+            final float ulpOneFp16 = Bfloat16.ulp(valueOfExact(1.0f)).floatValue();\n+\n+            float [][] testCases = {\n+                {1.0f, 2.0f, 3.0f,\n+                 5.0f},\n+\n+                {1.0f, 2.0f, -2.0f,\n+                 0.0f},\n+\n+                {5.0f, 5.0f, -25.0f,\n+                 0.0f},\n+\n+                {0.5f*MAX_VAL_FP16, 2.0f, -0.5f*MAX_VAL_FP16,\n+                 0.5f*MAX_VAL_FP16},\n+\n+                {MAX_VAL_FP16, 2.0f, -MAX_VAL_FP16,\n+                 MAX_VAL_FP16},\n+\n+                {MAX_VAL_FP16, 2.0f, 1.0f,\n+                 InfinityF},\n+\n+                {(1.0f + ulpOneFp16),\n+                 (1.0f + ulpOneFp16),\n+                 -1.0f - 2.0f*ulpOneFp16,\n+                 ulpOneFp16 * ulpOneFp16},\n+\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testRounding() { \/\/ TOOD -- update test cases\n+            final float ulpOneFp16 = Bfloat16.ulp(valueOfExact(1.0f)).floatValue();\n+\n+            float [][] testCases = {\n+\/\/                 \/\/ The product is equal to\n+\/\/                 \/\/ (MAX_VALUE + 1\/2 * ulp(MAX_VALUE) + MAX_VALUE = (0x1.ffcp15 + 0x0.002p15)+ 0x1.ffcp15\n+\/\/                 \/\/ so overflows.\n+\/\/                 {0x1.3p1f, 0x1.afp15f, -MAX_VAL_FP16,\n+\/\/                  InfinityF},\n+\n+\/\/                 \/\/ The product is equal to\n+\/\/                 \/\/ (MAX_VALUE + 1\/2 * ulp(MAX_VALUE) + MAX_VALUE = (0x1.ffcp15 + 0x0.002p15)+ 0x1.ffcp15\n+\/\/                 \/\/ so overflows.\n+\/\/                 {0x1.cp127, 0x1.24p0, -MAX_VAL_FP16,\n+\/\/                  InfinityF}\n+\n+\n+                \/\/ Product exactly equals 0x1.ffp127, the overflow\n+                \/\/ threshold; subtracting a non-zero finite value will\n+                \/\/ result in MAX_VALUE, adding zero or a positive\n+                \/\/ value will overflow.\n+                {0x1.cp127f, 0x1.24p0f, -MIN_VAL_FP16,\n+                 MAX_VAL_FP16},\n+\n+                {0x1.cp127f, 0x1.24p0f, -0.0f,\n+                 InfinityF},\n+\n+                {0x1.cp127f, 0x1.24p0f, +0.0f,\n+                 InfinityF},\n+\n+                {0x1.cp127f, 0x1.24p0f, +0x1.0p-14f,\n+                 InfinityF},\n+\n+                {0x1.cp127f, 0x1.24p0f, InfinityF,\n+                 InfinityF},\n+\n+\/\/                 \/\/ PRECISION bits in the subnormal intermediate product\n+\/\/                 {0x1.ffcp-14f, 0x1.0p-24f, 0x1.0p13f, \/\/ Can be held exactly\n+\/\/                  0x1.0p13f},\n+\n+\/\/                 {0x1.ffcp-14f, 0x1.0p-24f, 0x1.0p14f, \/\/ *Cannot* be held exactly\n+\/\/                  0x1.0p14f},\n+\n+                \/\/ Check values where the exact result cannot be\n+                \/\/ exactly stored in a double.\n+\n+                \/\/ Use Float16 MIN_VALUE\n+                {0x1.0p-24f, 0x1.0p-24f, 0x1.0p10f,\n+                 0x1.0p10f},\n+\n+                \/\/ Use Bfloat16 MIN_VALUE\n+                {MIN_VAL_FP16, MIN_VAL_FP16, 0x1.0p10f,\n+                 0x1.0p10f},\n+\n+                \/\/ Combine the min values\n+                {MIN_VAL_FP16, 0x1.0p-24f, 0x1.0p14f,\n+                 0x1.0p14f},\n+\n+                 \/\/ Check subnormal results, underflow to zero\n+                 {MIN_VAL_FP16, -0.5f, MIN_VAL_FP16,\n+                  0.0f},\n+\n+                 \/\/ Check subnormal results, underflow to zero\n+                 {MIN_VAL_FP16, -0.5f, 0.0f,\n+                  -0.0f},\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testFusedMacCase(float input1, float input2, float input3, float expected) {\n+            Bfloat16 a = valueOfExact(input1);\n+            Bfloat16 b = valueOfExact(input2);\n+            Bfloat16 c = valueOfExact(input3);\n+            Bfloat16 d = valueOfExact(expected);\n+\n+            test(\"Bfloat16.fma(float)\", a, b, c, Bfloat16.fma(a, b, c), d);\n+\n+            \/\/ Permute first two inputs\n+            test(\"Bfloat16.fma(float)\", b, a, c, Bfloat16.fma(b, a, c), d);\n+            return;\n+        }\n+    }\n+\n+    private static void test(String testName,\n+                             Bfloat16 input1, Bfloat16 input2, Bfloat16 input3,\n+                             Bfloat16 result, Bfloat16 expected) {\n+        if (Bfloat16.compare(expected, result ) != 0) {\n+            System.err.println(\"Failure for \"  + testName + \":\\n\" +\n+                               \"\\tFor inputs \" + input1   + \"\\t(\" + Bfloat16.toHexString(input1) + \") and \"\n+                                               + input2   + \"\\t(\" + Bfloat16.toHexString(input2) + \") and\"\n+                                               + input3   + \"\\t(\" + Bfloat16.toHexString(input3) + \")\\n\"  +\n+                               \"\\texpected  \"  + expected + \"\\t(\" + Bfloat16.toHexString(expected) + \")\\n\" +\n+                               \"\\tgot       \"  + result   + \"\\t(\" + Bfloat16.toHexString(result) + \").\");\n+            throw new RuntimeException();\n+        }\n+    }\n+    \/**\n+     * {@return a Float16 value converted from the {@code float}\n+     * argument throwing an {@code ArithmeticException} if the\n+     * conversion is inexact}.\n+     *\n+     * @param f the {@code float} value to convert exactly\n+     * @throws ArithmeticException\n+     *\/\n+    private static Bfloat16 valueOfExact(float f) {\n+        Bfloat16 f16 = Bfloat16.valueOf(f);\n+        if (Float.compare(f16.floatValue(), f) != 0) {\n+            throw new ArithmeticException(\"Inexact conversion to Bfloat16 of float value \" + f);\n+        }\n+        return f16;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/BasicBfloat16ArithTests.java","additions":1078,"deletions":0,"binary":false,"changes":1078,"status":"added"},{"patch":"@@ -0,0 +1,2509 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ package jdk.incubator.vector;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+\/\/ import jdk.internal.math.*;\n+\n+import static java.lang.Integer.numberOfLeadingZeros;\n+import static java.lang.Math.multiplyHigh;\n+\/\/ import jdk.internal.vm.vector.Float16Math;\n+\n+\/**\n+ * The {@code Bfloat16} is a class holding 16-bit data\n+ * in the bfloat16 format.\n+ *\n+ * TOOD: revise\/correct\n+ * <p>Binary16 Format:<br>\n+ *   S EEEEEEEE  MMMMMMM<br>\n+ *   Sign        - 1 bit<br>\n+ *   Exponent    - 8 bits<br>\n+ *   Significand - 7 bits (does not include the <i>implicit bit<\/i>\n+ *                    inferred from the exponent, see {@link #PRECISION})<br>\n+ *\n+ * <p>Unless otherwise specified, the methods in this class use a\n+ * <em>rounding policy<\/em> (JLS {@jls 15.4}) of {@linkplain\n+ * java.math.RoundingMode#HALF_EVEN round to nearest}.\n+ *\n+ * <p>This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n+ * class; programmers should treat instances that are\n+ * {@linkplain #equals(Object) equal} as interchangeable and should not\n+ * use instances for synchronization, or unpredictable behavior may\n+ * occur. For example, in a future release, synchronization may fail.\n+ *\n+ * <h2><a id=equivalenceRelation>Floating-point Equality, Equivalence,\n+ * and Comparison<\/a><\/h2>\n+ *\n+ * The class {@code java.lang.Double} has a {@linkplain\n+ * Double##equivalenceRelation discussion of equality,\n+ * equivalence, and comparison of floating-point values} that is\n+ * equally applicable to {@code Bfloat16} values.\n+ *\n+ * <h2><a id=decimalToBinaryConversion>Decimal &harr; Binary Conversion Issues<\/a><\/h2>\n+ *\n+ * The {@linkplain Double##decimalToBinaryConversion discussion of binary to\n+ * decimal conversion issues} in {@code java.lang.Double} is also\n+ * applicable to {@code Bfloat16} values.\n+ *\n+ *\n+ * @apiNote\n+ * The methods in this class generally have analogous methods in\n+ * either {@link Float}\/{@link Double} or {@link Math}\/{@link\n+ * StrictMath}. Unless otherwise specified, the handling of special\n+ * floating-point values such as {@linkplain #isNaN(Bfloat16) NaN}\n+ * values, {@linkplain #isInfinite(Bfloat16) infinities}, and signed\n+ * zeros of methods in this class is wholly analogous to the handling\n+ * of equivalent cases by methods in {@code Float}, {@code Double},\n+ * {@code Math}, etc.\n+ *\n+ * @see <a href=\"https:\/\/standards.ieee.org\/ieee\/754\/6210\/\">\n+ *      <cite>IEEE Standard for Floating-Point Arithmetic<\/cite><\/a>\n+ *\/\n+\n+\/\/ Currently Bfloat16 is a value-based class and in future it is\n+\/\/ expected to be aligned with Value Classes and Object as described in\n+\/\/ JEP-401 (https:\/\/openjdk.org\/jeps\/401).\n+\/\/ @jdk.internal.ValueBased\n+public final class Bfloat16\n+    extends Number\n+    implements Comparable<Bfloat16> {\n+\n+    \/**\n+     * {@return the {@code float} value closest to the numerical value\n+     * of the argument, a floating-point bfloat16 value encoded in a\n+     * {@code short}} The conversion is exact; all bfloat16 values can\n+     * be exactly represented in {@code float}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * TODO: update discussion; bfloat16 is not an IEEE_defined format.\n+     *\n+     * <h4><a id=binary16Format>IEEE 754 binary16 format<\/a><\/h4>\n+     * The IEEE 754 standard defines binary16 as a 16-bit format, along\n+     * with the 32-bit binary32 format (corresponding to the {@code\n+     * float} type) and the 64-bit binary64 format (corresponding to\n+     * the {@code double} type). The binary16 format is similar to the\n+     * other IEEE 754 formats, except smaller, having all the usual\n+     * IEEE 754 values such as NaN, signed infinities, signed zeros,\n+     * and subnormals. The parameters (JLS {@jls 4.2.3}) for the\n+     * binary16 format are N = 11 precision bits, K = 5 exponent bits,\n+     * <i>E<\/i><sub><i>max<\/i><\/sub> = 15, and\n+     * <i>E<\/i><sub><i>min<\/i><\/sub> = -14.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary16 format to the binary32 format.\n+     * The operation of this method is analogous to a primitive\n+     * widening conversion (JLS {@jls 5.1.2}).\n+     *\n+     * @param floatBinary16 the binary16 value to convert to {@code float}\n+     *\/\n+    public static float bfloat16ToFloat(short floatBinary16) {\n+        \/\/ Just pad with trailing zeros\n+        return Float.intBitsToFloat( ((int) floatBinary16) << 16);\n+    }\n+\n+    \/**\n+     * {@return the floating-point bfloat16 value, encoded in a {@code\n+     * short}, closest in value to the argument}\n+     * The conversion is computed under the {@linkplain\n+     * java.math.RoundingMode#HALF_EVEN round to nearest even rounding\n+     * mode}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * The {@linkplain ##binary16Format binary16 format} is discussed in\n+     * more detail in the {@link #float16ToFloat} method.\n+     *\n+     * TOOD: update\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary32 format to the binary16 format.\n+     * The operation of this method is analogous to a primitive\n+     * narrowing conversion (JLS {@jls 5.1.3}).\n+     *\n+     * @param f the {@code float} value to convert to binary16\n+     *\/\n+    public static short floatToBfloat16(float f) {\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel & 0x8000_0000) >> 16);\n+\n+        if (Float.isNaN(f)) {\n+            \/\/ Preserve sign and attempt to preserve significand bits\n+            return (short)( sign_bit | (doppel >> 16) |\n+                            \/\/ If any of the lower 16 bits of a float\n+                            \/\/ NaN are set, OR into LSB of bfloat16\n+                            \/\/ NaN.\n+                            ((doppel & 0xff) == 0 ? 0 : 1  ));\n+        }\n+\n+        float abs_f = Math.abs(f);\n+\n+        \/\/ The overflow threshold is bfloat16 MAX_VALUE + 1\/2 ulp\n+        if (abs_f >= OVERFLOW_THRESH) {\n+            return (short)(sign_bit | 0x7f80); \/\/ Positive or negative infinity\n+        }\n+\n+        if (abs_f <= UNDERFLOW_THRESH) { \/\/ Covers float zeros and small subnormals\n+            \/\/ positive or negative zero\n+            return sign_bit;\n+        }\n+\n+         int f_signif_bits = Float.floatToRawIntBits(abs_f);\n+\n+         \/\/ For round to nearest even, determining whether or not to\n+         \/\/ round up (in magnitude) is a function of the least\n+         \/\/ significant bit (LSB), the next bit position (the round\n+         \/\/ position), and the sticky bit (whether there are any\n+         \/\/ nonzero bits in the exact result to the right of the round\n+         \/\/ digit). An increment occurs in three cases:\n+         \/\/\n+         \/\/ LSB  Round Sticky\n+         \/\/ 0    1     1\n+         \/\/ 1    1     0\n+         \/\/ 1    1     1\n+         \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+         int lsb    = f_signif_bits & 0x1_0000;\n+         int round  = f_signif_bits & 0x0_8000;\n+         int sticky = f_signif_bits & 0x0_7FFF;\n+\n+         if (round != 0 && ((lsb | sticky) != 0 )) {\n+             f_signif_bits += 0x1_0000 ;\n+         }\n+\n+         return (short) (((f_signif_bits >> 16 ) | sign_bit) & 0xffff);\n+    }\n+\n+    \/** @serial *\/\n+    private final short value;\n+    private static final long serialVersionUID = 16; \/\/ May not be needed when a value class?\n+\n+    \/\/ Functionality for future consideration:\n+    \/\/ IEEEremainder and separate % operator remainder (which are\n+    \/\/ defined to use different rounding modes, see JLS sections 15.4\n+    \/\/ and 15.17.3).\n+\n+    \/\/ Do *not* define any public constructors\n+   \/**\n+    * Returns a {@code Bfloat16} instance wrapping bfloat16\n+    * encoded {@code short} value.\n+    *\n+    * @param  bits a short value.\n+    *\/\n+    private Bfloat16(short bits) {\n+        this.value = bits;\n+    }\n+\n+    \/**\n+     * The number of bits used to represent a {@code Bfloat16} value,\n+     * {@value}.\n+     *\n+     * @see Float#SIZE\n+     * @see Double#SIZE\n+     *\/\n+    public static final int SIZE = 16;\n+\n+    \/**\n+     * The number of bits in the significand of a {@code Bfloat16}\n+     * value, {@value}.  This corresponds to parameter N in section\n+     * {@jls 4.2.3} of <cite>The Java Language Specification<\/cite>.\n+     *\n+     * @see Float#PRECISION\n+     * @see Double#PRECISION\n+     *\/\n+    public static final int PRECISION = 8;\n+\n+    \/\/ For other floating-point types, analogs of the following\n+    \/\/ private constants are hosted as public constants in a companion\n+    \/\/ package access {$Type}Consts class. This allows access to\n+    \/\/ low-level constants to other classes in the package while\n+    \/\/ avoiding adding the constants appearing in the full the public\n+    \/\/ API. As this numeric type is being implemented in a single\n+    \/\/ file, adding the constants in a private static nested class is\n+    \/\/ less helpful since the constants would not be accessible from\n+    \/\/ another type and each constant would need to be accessed via\n+    \/\/ its qualified name.\n+    \/\/\n+    \/\/ To avoid class initialization issues,the constants are being\n+    \/\/ defined and initialized toward the start of the file so the\n+    \/\/ constants can be used by other constants and methods.\n+\n+    \/**\n+     * The number of logical bits in the significand of a\n+     * {@code Bfloat16} number, including the implicit bit.\n+     *\/\n+    private static final int SIGNIFICAND_WIDTH = PRECISION;\n+\n+\/\/     \/**\n+\/\/      * The exponent the smallest positive {@code Bfloat16}\n+\/\/      * subnormal value would have if it could be normalized.\n+\/\/      *\/\n+\/\/     private static final int MIN_SUB_EXPONENT =\n+\/\/         MIN_EXPONENT - (SIGNIFICAND_WIDTH - 1); \/\/ -133\n+\n+    \/**\n+     * Bias used in representing a {@code Bfloat16} exponent.\n+     *\/\n+    private static final int EXP_BIAS =\n+        (1 << (SIZE - SIGNIFICAND_WIDTH - 1)) - 1; \/\/ 127\n+\n+    \/**\n+     * Bit mask to isolate the sign bit of a {@code Bfloat16}.\n+     *\/\n+    private static final int SIGN_BIT_MASK = 1 << (SIZE - 1);\n+\n+    \/**\n+     * Bit mask to isolate the exponent field of a {@code Bfloat16}.\n+     *\/\n+    private static final int EXP_BIT_MASK =\n+        ((1 << (SIZE - SIGNIFICAND_WIDTH)) - 1) << (SIGNIFICAND_WIDTH - 1);\n+\n+    \/**\n+     * Bit mask to isolate the significand field of a {@code Bfloat16}.\n+     *\/\n+    private static final int SIGNIF_BIT_MASK = (1 << (SIGNIFICAND_WIDTH - 1)) - 1;\n+\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code Bfloat16}.\n+     *\/\n+    private static final int MAG_BIT_MASK = EXP_BIT_MASK | SIGNIF_BIT_MASK;\n+\n+    static {\n+        \/\/ verify bit masks cover all bit positions and that the bit\n+        \/\/ masks are non-overlapping\n+        assert(((SIGN_BIT_MASK | EXP_BIT_MASK | SIGNIF_BIT_MASK) == 0xFFFF) &&\n+               (((SIGN_BIT_MASK & EXP_BIT_MASK) == 0) &&\n+                ((SIGN_BIT_MASK & SIGNIF_BIT_MASK) == 0) &&\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)) &&\n+               ((SIGN_BIT_MASK | MAG_BIT_MASK) == 0xFFFF));\n+    }\n+\n+    \/**\n+     * A constant holding the positive infinity of type {@code\n+     * Bfloat16}.\n+     *\n+     * @see Float#POSITIVE_INFINITY\n+     * @see Double#POSITIVE_INFINITY\n+     *\/\n+    public static final Bfloat16 POSITIVE_INFINITY = valueOf(Float.POSITIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding the negative infinity of type {@code\n+     * Bfloat16}.\n+     *\n+     * @see Float#NEGATIVE_INFINITY\n+     * @see Double#NEGATIVE_INFINITY\n+     *\/\n+    public static final Bfloat16 NEGATIVE_INFINITY = valueOf(Float.NEGATIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding a Not-a-Number (NaN) value of type {@code\n+     * Bfloat16}.\n+     *\n+     * @see Float#NaN\n+     * @see Double#NaN\n+     *\/\n+    public static final Bfloat16 NaN = valueOf(Float.NaN);\n+\n+     \/**\n+      * A constant holding a zero (0.0) of type {@code Bfloat16}.\n+      *\/\n+    private static final Bfloat16 ZERO = valueOf(0);\n+\n+     \/**\n+      * A constant holding a one (1.0) of type {@code Bfloat16}.\n+      *\/\n+    private static final Bfloat16 ONE  = valueOf(1);\n+\n+\n+    \/**\n+     * A constant holding the largest positive finite value of type\n+     * {@code Bfloat16},\n+     * (2-2<sup>-7<\/sup>)&middot;2<sup>127<\/sup>.\n+     *\n+     * @see Float#MAX_VALUE\n+     * @see Double#MAX_VALUE\n+     *\/\n+    public static final Bfloat16 MAX_VALUE = valueOf(0x1.fep127f);\n+\n+    \/**\n+     * A constant holding the smallest positive normal value of type\n+     * {@code Bfloat16}, 2<sup>-126<\/sup>.\n+     *\n+     * @see Float#MIN_NORMAL\n+     * @see Double#MIN_NORMAL\n+     *\/\n+    public static final Bfloat16 MIN_NORMAL = valueOf(0x1.0p-126f);\n+\n+    \/**\n+     * A constant holding the smallest positive nonzero value of type\n+     * {@code Bfloat16}, 2<sup>-133<\/sup>.\n+     *\n+     * @see Float#MIN_VALUE\n+     * @see Double#MIN_VALUE\n+     *\/\n+    public static final Bfloat16 MIN_VALUE = valueOf(0x1.0p-133f);\n+\n+    \/**\n+     * Maximum exponent a finite {@code Bfloat16} variable may have,\n+     * {@value}. It is equal to the value returned by {@code\n+     * Bfloat16.getExponent(Bfloat16.MAX_VALUE)}.\n+     *\n+     * @see Float#MAX_EXPONENT\n+     * @see Double#MAX_EXPONENT\n+     *\/\n+    public static final int MAX_EXPONENT = (1 << (SIZE - PRECISION - 1)) - 1; \/\/ 127\n+\n+    \/**\n+     * Minimum exponent a normalized {@code Bfloat16} variable may\n+     * have, {@value}.  It is equal to the value returned by {@code\n+     * Bfloat16.getExponent(Bfloat16.MIN_NORMAL)}.\n+     *\n+     * @see Float#MIN_EXPONENT\n+     * @see Double#MIN_EXPONENT\n+     *\/\n+    public static final int MIN_EXPONENT = 1 - MAX_EXPONENT; \/\/ -126\n+\n+    static { \/\/ Same number of exponent bits in float and Bfloat16\n+        assert\n+            MAX_EXPONENT == Float.MAX_EXPONENT &\n+            MIN_EXPONENT == Float.MIN_EXPONENT;\n+    }\n+    \/**\n+     * The number of bytes used to represent a {@code Bfloat16} value,\n+     * {@value}.\n+     *\n+     * @see Float#BYTES\n+     * @see Double#BYTES\n+     *\/\n+    public static final int BYTES = SIZE \/ Byte.SIZE;\n+\n+    \/**\n+     * The overflow threshold (for round to nearest) is MAX_VALUE + 1\/2 ulp.\n+     *\/\n+    private static final double OVERFLOW_THRESH = 0x1.fep127 + 0x0.01p127;\n+\n+    \/**\n+     * The underflow threshold (for round to nearest) is MIN_VALUE * 0.5.\n+     *\/\n+    private static final double UNDERFLOW_THRESH = 0x1.0p-133f * 0.5d;\n+\n+    \/**\n+     * Returns a string representation of the {@code Bfloat16}\n+     * argument.\n+     *\n+     * The behavior of this method is analogous to {@link\n+     * Float#toString(float)} in the handling of special values\n+     * (signed zeros, infinities, and NaN) and the generation of a\n+     * decimal string that will convert back to the argument value.\n+     *\n+     * @param   bf16   the {@code Bfloat16} to be converted.\n+     * @return a string representation of the argument.\n+     * @see java.lang.Float#toString(float)\n+     *\/\n+    public static String toString(Bfloat16 bf16) {\n+         return Bfloat16ToDecimal.toString(bf16);\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string representation of the {@code\n+     * Bfloat16} argument.\n+     *\n+     * The behavior of this class is analogous to {@link\n+     * Float#toHexString(float)}.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertToHexCharacter operation\n+     * defined in IEEE 754.\n+     *\n+     * @param   bf16   the {@code Bfloat16} to be converted.\n+     * @return a hex string representation of the argument.\n+     *\n+     * @see Float#toHexString(float)\n+     * @see Double#toHexString(double)\n+     *\/\n+    public static String toHexString(Bfloat16 bf16) {\n+        \/\/ Subnormal Bfloat16 values are subnormal float values\n+        return Float.toHexString(bf16.floatValue());\n+    }\n+\n+    \/\/ -----------------------\n+\n+   \/**\n+    * {@return the value of an {@code int} converted to {@code\n+    * Bfloat16}}\n+    *\n+    * @param  value an {@code int} value.\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n+    *\/\n+    public static Bfloat16 valueOf(int value) {\n+        \/\/ int -> double conversion is exact\n+        return valueOf((double)value);\n+    }\n+\n+   \/**\n+    * {@return the value of a {@code long} converted to {@code Bfloat16}}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  value a {@code long} value.\n+    *\/\n+    public static Bfloat16 valueOf(long value) {\n+        if (value == Long.MIN_VALUE || \/\/ Power of two exactly representable in double\n+            Math.abs(value) <= 0x40_0000_0000_0000L) { \/\/ 0x1L << 54 {\n+            \/\/ All contiguous integers in the range [-2^54, 2^54] can\n+            \/\/ be exactly held in a double.\n+            return valueOf((double)value);\n+        } else {\n+            \/\/  assert 2^54 < abs(value) <= 2^63 - 1\n+\n+            \/\/ For the float16 format, the overall range of finite\n+            \/\/ value representable in the format is smaller than the\n+            \/\/ range of long values that can be exactly converted to a\n+            \/\/ double. Therefore, the long -> float16 conversion logic\n+            \/\/ for that other format is simple.\n+\n+            \/\/ For Bfloat16, there is the possibility of\n+            \/\/ double-rounding from the sequence of conversions:\n+            \/\/\n+            \/\/   long -> double -> Bfloat16\n+            \/\/\n+            \/\/ In this condition, since the integral argument to be\n+            \/\/ processed is greater in magnitude than 2^54 and\n+            \/\/ Bfloat16 has a precision of 8 bits, the high-order bits\n+            \/\/ that will appear in a Bfloat16 and within +\/- 7 bits of\n+            \/\/ 2^54. Which implies all the possible high-order bit\n+            \/\/ positions will be in the top 32-bits of the long\n+            \/\/ argument. With a synthesized sticky bits in the outside\n+            \/\/ of the +\/- 7 bit range but within the 54-bit precision\n+            \/\/ range of double, the conversion sequence:\n+            \/\/\n+            \/\/   condensed long -> double -> Bfloat16\n+            \/\/\n+            \/\/ will round the same as a correct rounding of a\n+            \/\/\n+            \/\/   original long -> Bfloat16\n+            \/\/\n+            \/\/ conversion. If the argument is negative, the\n+            \/\/ bit-handling is done on a negated value and the\n+            \/\/ intermediate double negated again to a negative value\n+            \/\/ after the initial condensed long -> double mapping.\n+\n+            boolean isNegative = value < 0;\n+\n+            if (isNegative) {\n+                \/\/ Long.MAX_VALUE screened out already so don't have\n+                \/\/ to worry about that edge case.\n+                value = -value;\n+            }\n+\n+            \/\/ If there are any nonzero bits in the lower 32 bits of\n+            \/\/ the long, create a nonzero sticky bit as the least\n+            \/\/ significant bit in the upper 32 bits.\n+            long sticky = ((value & 0x0000_0000_FFFF_FFFFL) == 0) ?\n+                0L : 0x000_0001_0000_0000L;\n+\n+            double roundedValue = (double)((value & 0xFFFF_FFFF_0000_0000L) | sticky);\n+            if (isNegative) {\n+                roundedValue = -roundedValue;\n+            }\n+\n+            return valueOf(roundedValue);\n+        }\n+    }\n+\n+   \/**\n+    * {@return a {@code Bfloat16} value rounded from the {@code Float16}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * Note this conversion is neither a widening nor a narrowing conversion.\n+    *\n+    * @param  f a {@code float}\n+    *\/\n+    public static Bfloat16 valueOf(jdk.incubator.vector.Float16 f16) {\n+        return valueOf(f16.floatValue());\n+    }\n+\n+   \/**\n+    * {@return a {@code Bfloat16} value rounded from the {@code float}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  f a {@code float}\n+    *\/\n+    public static Bfloat16 valueOf(float f) {\n+        return new Bfloat16(floatToBfloat16(f));\n+    }\n+\n+   \/**\n+    * {@return a {@code Bfloat16} value rounded from the {@code double}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  d a {@code double}\n+    *\/\n+    public static Bfloat16 valueOf(double d) {\n+        if (Double.isNaN(d)) {\n+            \/\/ Have existing float code handle any attempts to\n+            \/\/ preserve NaN bits.\n+            return valueOf((float)d);\n+        }\n+\n+        long doppel = Double.doubleToRawLongBits(d);\n+        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> (64 - 16));\n+        double abs_d = Math.abs(d);\n+\n+        if (abs_d >= OVERFLOW_THRESH) {\n+             \/\/ correctly signed infinity\n+            return new Bfloat16((short)(sign_bit | 0x7f80));\n+        }\n+\n+        if (abs_d <= UNDERFLOW_THRESH) { \/\/ Covers double zeros and subnormals.\n+            \/\/ Positive or negative zero\n+            return new Bfloat16(sign_bit);\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of bfloat16\n+        \/\/ (when rounding is done, could still round up)\n+        int exp = Math.getExponent(d);\n+        assert\n+            (MIN_EXPONENT - PRECISION) <= exp &&\n+            exp <= MAX_EXPONENT;\n+\n+        \/\/ For target format subnormals, beside forcing exp to\n+        \/\/ MIN_EXPONENT-1, retain the difference expdelta = E_min -\n+        \/\/ exp.  This is the excess shift value, in addition to the\n+        \/\/ difference in precision bits, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in d must be involved as well.\n+        int expdelta = 0;\n+        long msb = 0x0000_0000_0000_0000L;\n+        if (exp < MIN_EXPONENT) {\n+            expdelta = MIN_EXPONENT - exp;\n+            exp = MIN_EXPONENT - 1;\n+            msb = 0x0010_0000_0000_0000L;\n+        }\n+        long f_signif_bits = doppel & 0x000f_ffff_ffff_ffffL | msb;\n+\n+        final int PRECISION_DIFF = Double.PRECISION - PRECISION; \/\/ 45\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (PRECISION_DIFF + expdelta));\n+\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+        long lsb    = f_signif_bits &  (1L << (PRECISION_DIFF      + expdelta));\n+        long round  = f_signif_bits &  (1L << (PRECISION_DIFF - 1) + expdelta);\n+        long sticky = f_signif_bits & ((1L << (PRECISION_DIFF - 1) + expdelta) - 1);\n+\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the significand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xff00 & signif_bits) == 0x0;\n+\n+        return new Bfloat16((short)(sign_bit |\n+                                    ( ((exp + EXP_BIAS) << (PRECISION - 1)) + signif_bits ) ));\n+    }\n+\n+    \/**\n+     * Returns a {@code Bfloat16} holding the floating-point value\n+     * represented by the argument string.\n+     *\n+     * The grammar of strings accepted by this method is the same as\n+     * that accepted by {@link Double#valueOf(String)}. The rounding\n+     * policy is also analogous to the one used by that method, a\n+     * valid input is regarded as an exact numerical value that is\n+     * rounded once to the nearest representable {@code Bfloat16} value.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFromDecimalCharacter and\n+     * convertFromHexCharacter operations defined in IEEE 754.\n+     *\n+     * @param  s the string to be parsed.\n+     * @return the {@code Bfloat16} value represented by the string\n+     *         argument.\n+     * @throws NullPointerException  if the string is null\n+     * @throws NumberFormatException if the string does not contain a\n+     *               parsable {@code Bfloat16}.\n+     * @see    java.lang.Float#valueOf(String)\n+     *\/\n+    public static Bfloat16 valueOf(String s) throws NumberFormatException {\n+        s = s.trim(); \/\/ Legacy behavior from analogous methods on\n+                      \/\/ Float and Double.\n+\n+        \/\/ Trial conversion from String -> double. Do quick range\n+        \/\/ check for a pass-through, then check for possibility of\n+        \/\/ double-rounding and another conversion using\n+        \/\/ BigInteger\/BigDecimal, if needed.\n+        double trialResult = Double.parseDouble(s);\n+        \/\/ After this point, the trimmed string is known to be\n+        \/\/ syntactically well-formed; should be able to operate on\n+        \/\/ characters rather than codepoints.\n+\n+        if (trialResult == 0.0 \/\/ handles signed zeros\n+            || Math.abs(trialResult) > (0x1.0p128) || \/\/ MAX_VALUE + ulp(MAX_VALUE)\n+                                                      \/\/ handles infinities too\n+            Double.isNaN(trialResult) ||\n+            noDoubleRoundingToBfloat16(trialResult)) {\n+            return valueOf(trialResult);\n+        } else {\n+            \/\/ If double rounding is not ruled out, re-parse, create a\n+            \/\/ BigDecimal to hold the exact numerical value, round and\n+            \/\/ return.\n+\n+            \/\/ Remove any trailing FloatTypeSuffix (f|F|d|D), not\n+            \/\/ recognized by BigDecimal (or BigInteger)\n+            int sLength = s.length();\n+            if (Character.isAlphabetic(s.charAt(sLength-1))) {\n+                s = s.substring(0, sLength - 1);\n+            }\n+\n+            char startingChar = s.charAt(0);\n+            boolean isSigned = (startingChar == '-') || (startingChar == '+');\n+            \/\/ Hex literal will start \"-0x...\" or \"+0x...\" or \"0x...\"\"\n+            \/\/ A valid hex literal must be at least three characters\n+            \/\/ long \"0xH\" where H is a hex digit.\n+            boolean hexInput = (s.length() >= 3 ) && isX(s.charAt(isSigned ? 2 : 1));\n+\n+            if (!hexInput) { \/\/ Decimal input\n+                \/\/ Grammar of BigDecimal string input is compatible\n+                \/\/ with the decimal grammar for this method after\n+                \/\/ trimming and removal of any FloatTypeSuffix.\n+                return valueOf(new BigDecimal(s));\n+            } else {\n+                \/\/ For hex inputs, convert the significand and\n+                \/\/ exponent portions separately.\n+                \/\/\n+                \/\/ Rough form of the hex input:\n+                \/\/ Sign_opt 0x IntHexDigits_opt . FracHexDigits_opt [p|P] SignedInteger\n+                \/\/\n+                \/\/ Partition input into between \"0x\" and \"p\" and from\n+                \/\/ \"p\" to end of string.\n+                \/\/\n+                \/\/ For the region between x and p, see if there is a\n+                \/\/ period present. If so, the net exponent will need\n+                \/\/ to be adjusted by the number of digits to the right\n+                \/\/ of the (hexa)decimal point.\n+                \/\/\n+                \/\/ Use BigInteger(String, 16) to construct the\n+                \/\/ significand -- accepts leading sign.\n+                StringBuilder hexSignificand = new StringBuilder();\n+                if (isSigned) {\n+                    hexSignificand.append(startingChar);\n+                }\n+\n+                int fractionDigits = 0;\n+                int digitStart = isSigned ? 3 : 2 ;\n+\n+                int periodIndex = s.indexOf((int)'.');\n+\n+                int pIndex = findPIndex(s);\n+\n+                \/\/ Gather the significand digits\n+                if (periodIndex != -1) {\n+                    \/\/ Reconstruct integer and fraction digit sequence\n+                    \/\/ without the period.\n+                    hexSignificand.append(s, digitStart,      periodIndex);\n+                    hexSignificand.append(s, periodIndex + 1, pIndex);\n+                    fractionDigits = pIndex - periodIndex - 1;\n+                } else {\n+                    \/\/ All integer digits, no fraction digits\n+                    hexSignificand.append(s, digitStart, pIndex);\n+                }\n+\n+                \/\/ The exponent of a hexadecimal floating-point\n+                \/\/ literal is written in _decimal_.\n+                int rawExponent = Integer.parseInt(s.substring(pIndex+1));\n+\n+                \/\/ The exact numerical value of the string is:\n+                \/\/\n+                \/\/ normalizedSignificand * 2^(adjustedExponent)\n+                \/\/\n+                \/\/ Given the set of methods on BigDecimal, in\n+                \/\/ particular pow being limited to non-negative\n+                \/\/ exponents, this is computed either by multiplying\n+                \/\/ by BigDecimal.TWO raised to the adjustedExponent or\n+                \/\/ dividing by BigDecimal.TWO raised to the negated\n+                \/\/ adjustedExponent.\n+\n+                BigDecimal normalizedSignficand =\n+                    new BigDecimal(new BigInteger(hexSignificand.toString(), 16));\n+\n+                \/\/ Each hex fraction digit is four bits\n+                int adjustedExponent = rawExponent - 4*fractionDigits;\n+\n+                BigDecimal convertedStringValue = (adjustedExponent >= 0) ?\n+                    normalizedSignficand.multiply(BigDecimal.TWO.pow( adjustedExponent)) :\n+                    normalizedSignficand.divide(  BigDecimal.TWO.pow(-adjustedExponent));\n+                return valueOf(convertedStringValue);\n+            }\n+        }\n+    }\n+\n+    private static boolean noDoubleRoundingToBfloat16(double d) {\n+        \/\/ Note that if the String -> double conversion returned\n+        \/\/ whether or not the conversion was exact, many cases could\n+        \/\/ be skipped since the double-rounding would be known not to\n+        \/\/ have occurred.\n+        long dAsLong = Double.doubleToRawLongBits(d);\n+        long mask = 0x1FFF_FFFF_FFFFL; \/\/ 45 low-order bits\n+        long maskedValue = dAsLong & mask;\n+        \/\/ not half-way between two adjacent Bfloat16 values\n+        return maskedValue != 0x0200_0000_0000L;\n+    }\n+\n+    private static boolean isX(int character) {\n+        return character == (int)'x' || character == (int)'X';\n+    }\n+\n+    private static int findPIndex(String s) {\n+        int pIndex = s.indexOf((int)'p');\n+        return (pIndex != -1) ?  pIndex : s.indexOf((int)'P');\n+    }\n+\n+    \/**\n+     * {@return a {@link Bfloat16} value rounded from the {@link BigDecimal}\n+     * argument using the round to nearest rounding policy}\n+     *\n+     * @param  v a {@link BigDecimal}\n+     *\/\n+    public static Bfloat16 valueOf(BigDecimal v) {\n+        return BigDecimalConversion.float16Value(v);\n+    }\n+\n+    \/\/ TODO: Host this functionality in this class for now until\n+    \/\/ java.base has Bfloat16 support and this logic can be moved to\n+    \/\/ BigDecimal.\n+    private class BigDecimalConversion {\n+        \/*\n+         * Let l = log_2(10).\n+         * Then, L < l < L + ulp(L) \/ 2, that is, L = roundTiesToEven(l).\n+         *\/\n+        private static final double L = 3.321928094887362;\n+\n+        private static final int P_BF16 = PRECISION;  \/\/ 8\n+        private static final int Q_MIN_BF16 = MIN_EXPONENT - (P_BF16 - 1);  \/\/ -133\n+        private static final int Q_MAX_BF16 = MAX_EXPONENT - (P_BF16 - 1);  \/\/  120\n+\n+        \/**\n+         * Powers of 10 which can be represented exactly in {@code\n+         * Bfloat16}.\n+         *\/\n+        private static final Bfloat16[] FLOAT16_10_POW = {\n+            Bfloat16.ONE,\n+            Bfloat16.valueOf(10),\n+            Bfloat16.valueOf(100),\n+            Bfloat16.valueOf(1_000),\n+        };\n+\n+        public static Bfloat16 float16Value(BigDecimal bd) {\n+            int scale = bd.scale();\n+            BigInteger unscaledValue = bd.unscaledValue();\n+\n+            if (unscaledValue.abs().compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\n+                long intCompact = unscaledValue.longValue();\n+                Bfloat16 v = Bfloat16.valueOf(intCompact);\n+                if (scale == 0) {\n+                    return v;\n+                }\n+                \/*\n+                 * The discussion for the double case also applies here. That is,\n+                 * the following test is precise for all long values, but here\n+                 * Long.MAX_VALUE is not an issue.\n+                 *\/\n+                if (v.longValue() == intCompact) {\n+                    if (0 < scale && scale < FLOAT16_10_POW.length) {\n+                        return Bfloat16.divide(v, FLOAT16_10_POW[scale]);\n+                    }\n+                    if (0 > scale && scale > -FLOAT16_10_POW.length) {\n+                        return Bfloat16.multiply(v, FLOAT16_10_POW[-scale]);\n+                    }\n+                }\n+            }\n+            return fullBfloat16Value(bd);\n+        }\n+\n+        private static BigInteger bigTenToThe(int scale) {\n+            return BigInteger.TEN.pow(scale);\n+        }\n+\n+        private static Bfloat16 fullBfloat16Value(BigDecimal bd) {\n+            if (BigDecimal.ZERO.compareTo(bd) == 0) {\n+                return ZERO;\n+            }\n+            BigInteger w = bd.unscaledValue().abs();\n+            int scale = bd.scale();\n+            long qb = w.bitLength() - (long) Math.ceil(scale * L);\n+            Bfloat16 signum = Bfloat16.valueOf(bd.signum());\n+            if (qb < Q_MIN_BF16 - 2) {  \/\/ qb < -135\n+                return Bfloat16.multiply(signum, Bfloat16.ZERO);\n+            }\n+            if (qb > Q_MAX_BF16 + P_BF16 + 1) {  \/\/ qb > 129\n+                return Bfloat16.multiply(signum, Bfloat16.POSITIVE_INFINITY);\n+            }\n+            if (scale < 0) {\n+                return Bfloat16.multiply(signum, valueOf(w.multiply(bigTenToThe(-scale))));\n+            }\n+            if (scale == 0) {\n+                return Bfloat16.multiply(signum, valueOf(w));\n+            }\n+            int ql = (int) qb - (P_BF16 + 3);\n+            BigInteger pow10 =  bigTenToThe(scale);\n+            BigInteger m, n;\n+            if (ql <= 0) {\n+                m = w.shiftLeft(-ql);\n+                n = pow10;\n+            } else {\n+                m = w;\n+                n = pow10.shiftLeft(ql);\n+            }\n+            BigInteger[] qr = m.divideAndRemainder(n);\n+            \/*\n+             * We have\n+             *      2^12 = 2^{P+1} <= i < 2^{P+5} = 2^16\n+             * Contrary to the double and float cases, where we use long and int, resp.,\n+             * here we cannot simply declare i as short, because P + 5 < Short.SIZE\n+             * fails to hold.\n+             * Using int is safe, though.\n+             *\n+             * Further, as Math.scalb(Bfloat16) does not exists, we fall back to\n+             * Math.scalb(double).\n+             *\/\n+            int i = qr[0].intValue();\n+            int sb = qr[1].signum();\n+            int dq = (Integer.SIZE - (P_BF16 + 2)) - Integer.numberOfLeadingZeros(i);\n+            int eq = (Q_MIN_BF16 - 2) - ql;\n+            if (dq >= eq) {\n+                return Bfloat16.valueOf(bd.signum() * Math.scalb((double) (i | sb), ql));\n+            }\n+            int mask = (1 << eq) - 1;\n+            int j = i >> eq | (Integer.signum(i & mask)) | sb;\n+            return Bfloat16.valueOf(bd.signum() * Math.scalb((double) j, Q_MIN_BF16 - 2));\n+        }\n+\n+        \/*\n+         * Favor a straightforward implementation of this method for\n+         * now, aim to reuse detailed rounding logic from other\n+         * methods that have already been tested, etc.\n+         *\/\n+        public static Bfloat16 valueOf(BigInteger bi) {\n+            \/\/ Also see BigInteger.floatValue() for reference\n+            int signum = bi.signum();\n+\n+            if (signum == 0 || bi.bitLength() <= 63) {\n+                \/\/ handle long values\n+                return Bfloat16.valueOf(bi.longValue());\n+            }\n+\n+            if (signum == -1) {\n+                bi = bi.negate();\n+            }\n+            \/\/ For ease of coding, just deal with positive representation\n+            int exponent = bi.bitLength() - 1;\n+            if (exponent > MAX_EXPONENT) {\n+                return (signum == -1) ? NEGATIVE_INFINITY: POSITIVE_INFINITY;\n+            }\n+            assert exponent >= 64 && exponent <= MAX_EXPONENT : \"exponent = \" + exponent;\n+\n+            int bitLength = exponent + 1;\n+            if (bitLength <= Double.PRECISION) {\n+                return Bfloat16.valueOf(signum * bi.doubleValue());\n+            } else {\n+                \/\/ bitLength > Double.PRECISION && bitLength-1 < MAX_EXPONENT\n+\n+                int shiftDistance = bitLength - (Double.PRECISION - 3);\n+                BigInteger biShifted = bi.shiftRight(shiftDistance).shiftLeft(shiftDistance);\n+                double biShiftedAsDouble = biShifted.doubleValue();\n+                if (!bi.equals(biShifted)) {\n+                    \/\/ set low-order sticky bit\n+                    biShiftedAsDouble =\n+                        Double.longBitsToDouble(Double.doubleToLongBits(biShiftedAsDouble) | 0x1L);\n+                }\n+                return Bfloat16.valueOf(signum * biShiftedAsDouble);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is a\n+     * Not-a-Number (NaN) value, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isNaN operation defined in IEEE\n+     * 754.\n+     *\n+     * @param   bf16   the value to be tested.\n+     * @return  {@code true} if the argument is NaN;\n+     *          {@code false} otherwise.\n+     *\n+     * @see Float#isNaN(float)\n+     * @see Double#isNaN(double)\n+     *\/\n+    public static boolean isNaN(Bfloat16 bf16) {\n+        final short bits = bfloat16ToRawShortBits(bf16);\n+        \/\/ A NaN value has all ones in its exponent and a non-zero significand\n+        return ((bits & EXP_BIT_MASK) == EXP_BIT_MASK && (bits & SIGNIF_BIT_MASK) != 0);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is infinitely\n+     * large in magnitude, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isInfinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param   bf16   the value to be tested.\n+     * @return  {@code true} if the argument is positive infinity or\n+     *          negative infinity; {@code false} otherwise.\n+     *\n+     * @see Float#isInfinite(float)\n+     * @see Double#isInfinite(double)\n+     *\/\n+    public static boolean isInfinite(Bfloat16 bf16) {\n+        final short bits = bfloat16ToRawShortBits(bf16);\n+        \/\/ An infinite value has all ones in its exponent and a zero significand\n+        return ((bits & EXP_BIT_MASK) == EXP_BIT_MASK && (bits & SIGNIF_BIT_MASK) == 0);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the argument is a finite floating-point\n+     * value; returns {@code false} otherwise (for NaN and infinity\n+     * arguments).\n+     *\n+     * @apiNote\n+     * This method corresponds to the isFinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param bf16 the {@code Bfloat16} value to be tested\n+     * @return {@code true} if the argument is a finite\n+     * floating-point value, {@code false} otherwise.\n+     *\n+     * @see Float#isFinite(float)\n+     * @see Double#isFinite(double)\n+     *\/\n+    public static boolean isFinite(Bfloat16 bf16) {\n+        return (bfloat16ToRawShortBits(bf16) & MAG_BIT_MASK) <=\n+            bfloat16ToRawShortBits(MAX_VALUE);\n+     }\n+\n+    \/**\n+     * {@return the value of this {@code Bfloat16} as a {@code byte} after\n+     * a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public byte byteValue() {\n+        return (byte)floatValue();\n+    }\n+\n+    \/**\n+     * {@return a string representation of this {@code Bfloat16}}\n+     *\n+     * @implSpec\n+     * This method returns the result of {@code Bfloat16.toString(this)}.\n+     *\/\n+    public String toString() {\n+        return toString(this);\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Bfloat16} as a {@code short}\n+     * after a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public short shortValue() {\n+        return (short)floatValue();\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Bfloat16} as an {@code int} after\n+     * a narrowing primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public int intValue() {\n+        return (int)floatValue();\n+    }\n+\n+    \/**\n+     * {@return value of this {@code Bfloat16} as a {@code long} after a\n+     * narrowing primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public long longValue() {\n+        return (long)floatValue();\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Bfloat16} as a {@code float}\n+     * after a widening primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @jls 5.1.2 Widening Primitive Conversion\n+     *\/\n+    @Override\n+    public float floatValue() {\n+        return bfloat16ToFloat(value);\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Bfloat16} as a {@code double}\n+     * after a widening primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @jls 5.1.2 Widening Primitive Conversion\n+     *\/\n+    @Override\n+    public double doubleValue() {\n+        return (double)floatValue();\n+    }\n+\n+    \/**\n+     * {@return a hash code for this {@code Bfloat16} object}\n+     *\n+     * The general contract of {@code Object#hashCode()} is satisfied.\n+     * All NaN values have the same hash code. Additionally, all\n+     * distinct numerical values have unique hash codes; in\n+     * particular, negative zero and positive zero have different hash\n+     * codes from each other.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return hashCode(this);\n+    }\n+\n+    \/**\n+     * Returns a hash code for a {@code Bfloat16} value; compatible with\n+     * {@code Bfloat16.hashCode()}.\n+     *\n+     * @param value the value to hash\n+     * @return a hash code value for a {@code Bfloat16} value.\n+     *\/\n+    public static int hashCode(Bfloat16 value) {\n+        \/\/ Use bit-pattern of canonical NaN for hashing.\n+        Bfloat16 bf16 = isNaN(value) ? NaN : value;\n+        return (int)bfloat16ToRawShortBits(bf16);\n+    }\n+\n+    \/**\n+     * Compares this object against the specified object.  The result\n+     * is {@code true} if and only if the argument is not\n+     * {@code null} and is a {@code Bfloat16} object that\n+     * represents a {@code Bfloat16} that has the same value as the\n+     * {@code double} represented by this object.\n+     *\n+     * @jls 15.21.1 Numerical Equality Operators == and !=\n+     *\/\n+    public boolean equals(Object obj) {\n+        return (obj instanceof Bfloat16 bf16) &&\n+            (bfloat16ToShortBits(bf16) == bfloat16ToShortBits(this));\n+    }\n+\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     *\n+     * @param   bf16   a {@code Bfloat16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n+     *\/\n+    public static short bfloat16ToRawShortBits(Bfloat16 bf16) {\n+        return bf16.value;\n+    }\n+\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     * All NaN values return the same bit pattern as {@link Bfloat16#NaN}.\n+     *\n+     * @param   bf16   a {@code Bfloat16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n+     *\/\n+    public static short bfloat16ToShortBits(Bfloat16 bf16) {\n+        if (isNaN(bf16)) {\n+            return NaN.value;\n+        }\n+        return bf16.value;\n+    }\n+\n+    \/**\n+     * Returns the {@code Bfloat16} value corresponding to a given bit\n+     * representation.\n+     *\n+     * @param   bits   any {@code short} integer.\n+     * @return  the {@code Bfloat16} floating-point value with the same\n+     *          bit pattern.\n+     *\n+     * @see Float#intBitsToFloat(int)\n+     * @see Double#longBitsToDouble(long)\n+     *\/\n+    public static Bfloat16 shortBitsToBfloat16(short bits) {\n+        return new Bfloat16(bits);\n+    }\n+\n+    \/**\n+     * Compares two {@code Bfloat16} objects numerically.\n+     *\n+     * This method imposes a total order on {@code Bfloat16} objects\n+     * with two differences compared to the incomplete order defined by\n+     * the Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code float} and {@code double} values.\n+     *\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Bfloat16.NaN} to be equal to itself and greater than all\n+     *          other {@code Bfloat16} values (including {@code\n+     *          Bfloat16.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero\n+     *      to be greater than negative zero.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * For a discussion of differences between the total order of this\n+     * method compared to the total order defined by the IEEE 754\n+     * standard, see the note in {@link Double#compareTo(Double)}.\n+     *\n+     * @param   anotherBfloat16   the {@code Bfloat16} to be compared.\n+     * @return  the value {@code 0} if {@code anotherBfloat16} is\n+     *          numerically equal to this {@code Bfloat16}; a value\n+     *          less than {@code 0} if this {@code Bfloat16}\n+     *          is numerically less than {@code anotherBfloat16};\n+     *          and a value greater than {@code 0} if this\n+     *          {@code Bfloat16} is numerically greater than\n+     *          {@code anotherBfloat16}.\n+     *\n+     * @see Float#compareTo(Float)\n+     * @see Double#compareTo(Double)\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+     *\/\n+    @Override\n+    public int compareTo(Bfloat16 anotherBfloat16) {\n+        return compare(this, anotherBfloat16);\n+    }\n+\n+    \/**\n+     * Compares the two specified {@code Bfloat16} values.\n+     *\n+     * @apiNote\n+     * One idiom to implement {@linkplain Double##repEquivalence\n+     * representation equivalence} on {@code Bfloat16} values is\n+     * {@snippet lang=\"java\" :\n+     * Bfloat16.compare(a, b) == 0\n+     * }\n+     * @param   f1        the first {@code Bfloat16} to compare\n+     * @param   f2        the second {@code Bfloat16} to compare\n+     * @return  the value {@code 0} if {@code f1} is\n+     *          numerically equal to {@code f2}; a value less than\n+     *          {@code 0} if {@code f1} is numerically less than\n+     *          {@code f2}; and a value greater than {@code 0}\n+     *          if {@code f1} is numerically greater than\n+     *          {@code f2}.\n+     *\n+     * @see Float#compare(float, float)\n+     * @see Double#compare(double, double)\n+     *\/\n+    public static int compare(Bfloat16 f1, Bfloat16 f2) {\n+        return Float.compare(f1.floatValue(), f2.floatValue());\n+    }\n+\n+    \/**\n+     * Returns the larger of two {@code Bfloat16} values.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is analogous to the handling of\n+     * those cases by the Math#max(double, double) method.\n+     *\n+     * @apiNote\n+     * This method corresponds to the maximum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#max(float, float)\n+     *\/\n+    public static Bfloat16 max(Bfloat16 a, Bfloat16 b) {\n+        return valueOf(Math.max(a.floatValue(), b.floatValue()));\n+    }\n+\n+    \/**\n+     * Returns the smaller of two {@code Bfloat16} values.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is analogous to the handling of\n+     * those cases by the Math#min(double, double) method.\n+     *\n+     * @apiNote\n+     * This method corresponds to the minimum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#min(float, float)\n+     *\/\n+    public static Bfloat16 min(Bfloat16 a, Bfloat16 b) {\n+        return valueOf(Math.min(a.floatValue(), b.floatValue()));\n+    }\n+\n+    \/\/ Skipping for now\n+    \/\/ public Optional<Bfloat16> describeConstable()\n+    \/\/ public Bfloat16 resolveConstantDesc(MethodHandles.Lookup lookup)\n+\n+    \/\/ TODO: Verify 2p+2 holds when there is the same number of\n+    \/\/ exponent bits?\n+\n+    \/*\n+     * Note: for the basic arithmetic operations {+, -, *, \/} and\n+     * square root, among binary interchange formats (binary16,\n+     * binary32 a.k.a. float, binary64 a.k.a double, etc.) the \"2p + 2\"\n+     * property holds. That is, if one format has p bits of precision,\n+     * if the next larger format has at least 2p + 2 bits of\n+     * precision, arithmetic on the smaller format can be implemented by:\n+     *\n+     * 1) converting each argument to the wider format\n+     * 2) performing the operation in the wider format\n+     * 3) converting the result from 2) to the narrower format\n+     *\n+     * For example, this property holds between the formats used for the\n+     * float and double types. Therefore, the following is a valid\n+     * implementation of a float addition:\n+     *\n+     * float add(float addend, float augend) {\n+     *     return (float)((double)addend + (double)augend);\n+     * }\n+     *\n+     * The same property holds between the Bfloat16 format and\n+     * float. Therefore, the software implementations of Bfloat16 {+,\n+     * -, *, \/} and square root below use the technique of widening\n+     * the Bfloat16 arguments to float, performing the operation in\n+     * float arithmetic, and then rounding the float result to\n+     * Bfloat16.\n+     * (TODO: more than sufficient precision, but think through to make sure\n+     * no extra exponent range is needed...)\n+     *\n+     * For discussion and derivation of this property see:\n+     *\n+     * \"When Is Double Rounding Innocuous?\" by Samuel Figueroa\n+     * ACM SIGNUM Newsletter, Volume 30 Issue 3, pp 21-26\n+     * https:\/\/dl.acm.org\/doi\/pdf\/10.1145\/221332.221334\n+     *\n+     * Figueroa's write-up refers to lecture notes by W. Kahan. Those\n+     * lectures notes are assumed to be these ones by Kahan and\n+     * others:\n+     *\n+     * https:\/\/www.arithmazium.org\/classroom\/lib\/Lecture_08_notes_slides.pdf\n+     * https:\/\/www.arithmazium.org\/classroom\/lib\/Lecture_09_notes_slides.pdf\n+     *\/\n+\n+    \/**\n+     * Adds two {@code Bfloat16} values together as per the {@code +}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code +} operator for\n+     * floating-point addition (JLS {@jls 15.18.2}).\n+     *\n+     * @apiNote This method corresponds to the addition operation\n+     * defined in IEEE 754.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.18.2 Additive Operators (+ and -) for Numeric Types\n+     *\/\n+    public static Bfloat16 add(Bfloat16 addend, Bfloat16 augend) {\n+        return valueOf(addend.floatValue() + augend.floatValue());\n+    }\n+\n+    \/**\n+     * Subtracts two {@code Bfloat16} values as per the {@code -}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code -} operator for\n+     * floating-point subtraction (JLS {@jls 15.18.2}).\n+     *\n+     * @apiNote This method corresponds to the subtraction operation\n+     * defined in IEEE 754.\n+     *\n+     * @param minuend the first operand\n+     * @param  subtrahend the second operand\n+     * @return the difference of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.18.2 Additive Operators (+ and -) for Numeric Types\n+     *\/\n+    public static Bfloat16 subtract(Bfloat16 minuend, Bfloat16 subtrahend) {\n+        return valueOf(minuend.floatValue() - subtrahend.floatValue());\n+    }\n+\n+    \/**\n+     * Multiplies two {@code Bfloat16} values as per the {@code *}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code *} operator for\n+     * floating-point multiplication (JLS {@jls 15.17.1}).\n+     *\n+     * @apiNote This method corresponds to the multiplication\n+     * operation defined in IEEE 754.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.17.1 Multiplication Operator *\n+     *\/\n+    public static Bfloat16 multiply(Bfloat16 multiplier, Bfloat16 multiplicand) {\n+        return valueOf(multiplier.floatValue() * multiplicand.floatValue());\n+    }\n+\n+    \/**\n+     * Divides two {@code Bfloat16} values as per the {@code \/}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code \/} operator for\n+     * floating-point division (JLS {@jls 15.17.2}).\n+     *\n+     * @apiNote This method corresponds to the division\n+     * operation defined in IEEE 754.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.17.2 Division Operator \/\n+     *\/\n+    public static Bfloat16 divide(Bfloat16 dividend, Bfloat16 divisor) {\n+        return valueOf(dividend.floatValue() \/ divisor.floatValue());\n+    }\n+\n+    \/**\n+     * {@return the square root of the operand} The square root is\n+     * computed using the round to nearest rounding policy.\n+     *\n+     * The handling of zeros, NaN, infinities, and negative arguments\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#sqrt(double)}.\n+     *\n+     * @apiNote\n+     * This method corresponds to the squareRoot operation defined in\n+     * IEEE 754.\n+     *\n+     * @param radicand the argument to have its square root taken\n+     *\n+     * @see Math#sqrt(double)\n+     *\/\n+    public static Bfloat16 sqrt(Bfloat16 radicand) {\n+        \/\/ Rounding path of sqrt(Bfloat16 -> double) -> Bfloat16 is fine\n+        \/\/ for preserving the correct final value. The conversion\n+        \/\/ Bfloat16 -> double preserves the exact numerical value. The\n+        \/\/ conversion of double -> Bfloat16 also benefits from the\n+        \/\/ 2p+2 property of IEEE 754 arithmetic.\n+        return valueOf(Math.sqrt(radicand.doubleValue()));\n+    }\n+\n+    \/**\n+     * Returns the fused multiply add of the three arguments; that is,\n+     * returns the exact product of the first two arguments summed\n+     * with the third argument and then rounded once to the nearest\n+     * {@code Bfloat16}.\n+     *\n+     * The handling of zeros, NaN, infinities, and other special cases\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#fma(float, float, float)}.\n+     *\n+     * @apiNote This method corresponds to the fusedMultiplyAdd\n+     * operation defined in IEEE 754.\n+     *\n+     * @param a a value\n+     * @param b a value\n+     * @param c a value\n+     *\n+     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n+     * computed, as if with unlimited range and precision, and rounded\n+     * once to the nearest {@code Bfloat16} value\n+     *\n+     * @see Math#fma(float, float, float)\n+     * @see Math#fma(double, double, double)\n+     *\/\n+    public static Bfloat16 fma(Bfloat16 a, Bfloat16 b, Bfloat16 c) {\n+        \/\/ Initially use a simple implementation that relies primarily\n+        \/\/ on BigDecimal. Many inputs could be handled correctly using\n+        \/\/ double arithmetic; logic can look for potential\n+        \/\/ double-rounding situations to fail-over to BigDecimal when\n+        \/\/ needed.\n+\n+        float  aFlt = a.floatValue();\n+        float  bFlt = b.floatValue();\n+        float  cFlt = c.floatValue();\n+\n+        \/\/ BigDecimal doesn't have signed zeros or non-finite\n+        \/\/ values. Handling those cases using float arithmetic.  If\n+        \/\/ any arguments are any of zero, NaN, or infinity, do the\n+        \/\/ arithmetic in float and return the converted result.\n+        if (aFlt == 0.0f || bFlt == 0.0f || cFlt == 0.0 ||\n+            !Float.isFinite(aFlt) || !Float.isFinite(bFlt) || !Float.isFinite(cFlt)) {\n+            return valueOf((aFlt * bFlt) + cFlt);\n+        } else { \/\/ Otherwise, calculate the exact numerical value and round once\n+            \/\/ Note: cannot use float for the product here due to the\n+            \/\/ possibility of an intermediate overflow that would be\n+            \/\/ in normal range once the third value was added in.\n+            double product = (double)aFlt * (double)bFlt;\n+            return valueOf((new BigDecimal(product)).add(new BigDecimal(cFlt)));\n+        }\n+    }\n+\n+    \/**\n+     * {@return the negation of the argument}\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * opposite sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the opposite sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method corresponds to the negate operation defined in IEEE\n+     * 754.\n+     *\n+     * @param bf16 the value to be negated\n+     * @jls 15.15.4 Unary Minus Operator {@code -}\n+     *\/\n+    public static Bfloat16 negate(Bfloat16 bf16) {\n+        \/\/ Negate sign bit only. Per IEEE 754-2019 section 5.5.1,\n+        \/\/ negate is a bit-level operation and not a logical\n+        \/\/ operation. Therefore, in this case do _not_ use the float\n+        \/\/ unary minus as an implementation as that is not guaranteed\n+        \/\/ to flip the sign bit of a NaN.\n+        return shortBitsToBfloat16((short)(bf16.value ^ SIGN_BIT_MASK));\n+    }\n+\n+    \/**\n+     * {@return the absolute value of the argument}\n+     *\n+     * The handling of zeros, NaN, and infinities by this method is\n+     * analogous to the handling of those cases by {@link\n+     * Math#abs(float)}.\n+     *\n+     * @param bf16 the argument whose absolute value is to be determined\n+     *\n+     * @see Math#abs(float)\n+     * @see Math#abs(double)\n+     *\/\n+    public static Bfloat16 abs(Bfloat16 bf16) {\n+        \/\/ Zero out sign bit. Per IEE 754-2019 section 5.5.1, abs is a\n+        \/\/ bit-level operation and not a logical operation.\n+        return shortBitsToBfloat16((short)(bf16.value & MAG_BIT_MASK));\n+    }\n+\n+    \/**\n+     * Returns the unbiased exponent used in the representation of a\n+     * {@code Bfloat16}.\n+     *\n+     * <ul>\n+     * <li>If the argument is NaN or infinite, then the result is\n+     * {@link Bfloat16#MAX_EXPONENT} + 1.\n+     * <li>If the argument is zero or subnormal, then the result is\n+     * {@link Bfloat16#MIN_EXPONENT} - 1.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method is analogous to the logB operation defined in IEEE\n+     * 754, but returns a different value on subnormal arguments.\n+     *\n+     * @param bf16 a {@code Bfloat16} value\n+     * @return the unbiased exponent of the argument\n+     *\n+     * @see Math#getExponent(float)\n+     * @see Math#getExponent(double)\n+     *\/\n+    public static int getExponent(Bfloat16 bf16) {\n+        return getExponent0(bf16.value);\n+    }\n+\n+    \/**\n+     * From the bitwise representation of a Bfloat16, mask out exponent\n+     * bits, shift to the right and then subtract out bfloat16's bias\n+     * adjust, 127, to get true exponent value.\n+     *\/\n+    \/*package*\/ static int getExponent0(short bits) {\n+        \/\/ package private to be usable in java.lang.Float.\n+        int bin16ExpBits = EXP_BIT_MASK & bits; \/\/ Eight exponent bits.\n+        return (bin16ExpBits >> (PRECISION - 1)) - EXP_BIAS;\n+    }\n+\n+    \/**\n+     * Returns the size of an ulp of the argument.  An ulp, unit in\n+     * the last place, of a {@code Bfloat16} value is the positive\n+     * distance between this floating-point value and the {@code\n+     * Bfloat16} value next larger in magnitude.  Note that for non-NaN\n+     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive or negative infinity, then the\n+     * result is positive infinity.\n+     * <li> If the argument is positive or negative zero, then the result is\n+     * {@code Bfloat16.MIN_VALUE}.\n+     * <li> If the argument is &plusmn;{@code Bfloat16.MAX_VALUE}, then\n+     * the result is equal to 2<sup>5<\/sup>, 32.0.\n+     * <\/ul>\n+     *\n+     * @param bf16 the floating-point value whose ulp is to be returned\n+     * @return the size of an ulp of the argument\n+     *\n+     * @see Math#ulp(float)\n+     * @see Math#ulp(double)\n+     *\/\n+    public static Bfloat16 ulp(Bfloat16 bf16) {\n+        int exp = getExponent(bf16);\n+\n+        return switch(exp) {\n+        case MAX_EXPONENT + 1 -> abs(bf16);  \/\/ NaN or infinity\n+        case MIN_EXPONENT - 1 -> MIN_VALUE; \/\/ zero or subnormal\n+        default -> {\n+            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT : \"Out of range exponent\";\n+            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+            \/\/ Let float -> Bfloat16 conversion handle encoding issues.\n+            yield scalb(ONE, exp - (PRECISION - 1));\n+        }\n+        };\n+    }\n+\n+    \/**\n+     * Returns the floating-point value adjacent to {@code v} in\n+     * the direction of positive infinity.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, the result is NaN.\n+     *\n+     * <li> If the argument is positive infinity, the result is\n+     * positive infinity.\n+     *\n+     * <li> If the argument is zero, the result is\n+     * {@link #MIN_VALUE}\n+     *\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the nextUp\n+     * operation defined in IEEE 754.\n+     *\n+     * @param v starting floating-point value\n+     * @return The adjacent floating-point value closer to positive\n+     * infinity.\n+     *\n+     * @see Math#nextUp(float)\n+     * @see Math#nextUp(double)\n+     *\/\n+    public static Bfloat16 nextUp(Bfloat16 v) {\n+        float f = v.floatValue();\n+        if (f < Float.POSITIVE_INFINITY) {\n+            if (f != 0) {\n+                int bits = bfloat16ToRawShortBits(v);\n+                return shortBitsToBfloat16((short) (bits + ((bits >= 0) ? 1 : -1)));\n+            }\n+            return MIN_VALUE;\n+        }\n+        return v; \/\/ v is NaN or +Infinity\n+    }\n+\n+    \/**\n+     * Returns the floating-point value adjacent to {@code v} in\n+     * the direction of negative infinity.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, the result is NaN.\n+     *\n+     * <li> If the argument is negative infinity, the result is\n+     * negative infinity.\n+     *\n+     * <li> If the argument is zero, the result is\n+     * -{@link #MIN_VALUE}\n+     *\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the nextDown\n+     * operation defined in IEEE 754.\n+     *\n+     * @param v  starting floating-point value\n+     * @return The adjacent floating-point value closer to negative\n+     * infinity.\n+     *\n+     * @see Math#nextDown(float)\n+     * @see Math#nextDown(double)\n+     *\/\n+    public static Bfloat16 nextDown(Bfloat16 v) {\n+        float f = v.floatValue();\n+        if (f > Float.NEGATIVE_INFINITY) {\n+            if (f != 0) {\n+                int bits = bfloat16ToRawShortBits(v);\n+                return shortBitsToBfloat16((short) (bits - ((bits >= 0) ? 1 : -1)));\n+            }\n+            return negate(MIN_VALUE);\n+        }\n+        return v; \/\/ v is NaN or -Infinity\n+    }\n+\n+    \/**\n+     * Returns {@code v} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     * rounded as if performed by a single correctly rounded\n+     * floating-point multiply.  If the exponent of the result is\n+     * between {@link Bfloat16#MIN_EXPONENT} and {@link\n+     * Bfloat16#MAX_EXPONENT}, the answer is calculated exactly.  If the\n+     * exponent of the result would be larger than {@code\n+     * Bfloat16.MAX_EXPONENT}, an infinity is returned.  Note that if the\n+     * result is subnormal, precision may be lost; that is, when\n+     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n+     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n+     * result has the same sign as {@code v}.\n+     *\n+     * <p>Special cases:\n+     * <ul>\n+     * <li> If the first argument is NaN, NaN is returned.\n+     * <li> If the first argument is infinite, then an infinity of the\n+     * same sign is returned.\n+     * <li> If the first argument is zero, then a zero of the same\n+     * sign is returned.\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the scaleB operation\n+     * defined in IEEE 754.\n+     *\n+     * @param v number to be scaled by a power of two.\n+     * @param scaleFactor power of 2 used to scale {@code v}\n+     * @return {@code v} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     *\n+     * @see Math#scalb(float, int)\n+     * @see Math#scalb(double, int)\n+     *\/\n+    public static Bfloat16 scalb(Bfloat16 v, int scaleFactor) {\n+        \/\/ magnitude of a power of two so large that scaling a finite\n+        \/\/ nonzero value by it would be guaranteed to over or\n+        \/\/ underflow; due to rounding, scaling down takes an\n+        \/\/ additional power of two which is reflected here\n+        final int MAX_SCALE = MAX_EXPONENT + -MIN_EXPONENT + SIGNIFICAND_WIDTH + 1;\n+\n+        \/\/ Make sure scaling factor is in a reasonable range\n+        scaleFactor = Math.clamp(scaleFactor, -MAX_SCALE, MAX_SCALE);\n+\n+        int DoubleConsts_EXP_BIAS = 1023;\n+        \/*\n+         * Since + MAX_SCALE for Bfloat16 fits well within the double\n+         * exponent range and + Bfloat16 -> double conversion is exact\n+         * the multiplication below will be exact. Therefore, the\n+         * rounding that occurs when the double product is cast to\n+         * Bfloat16 will be the correctly rounded Bfloat16 result.\n+         *\/\n+        return valueOf(v.doubleValue()\n+                * Double.longBitsToDouble((long) (scaleFactor + DoubleConsts_EXP_BIAS) << Double.PRECISION - 1));\n+    }\n+    \/**\n+     * Returns the first floating-point argument with the sign of the\n+     * second floating-point argument.\n+     * This method does not require NaN {@code sign}\n+     * arguments to be treated as positive values; implementations are\n+     * permitted to treat some NaN arguments as positive and other NaN\n+     * arguments as negative to allow greater performance.\n+     *\n+     * @apiNote\n+     * This method corresponds to the copySign operation defined in\n+     * IEEE 754.\n+     *\n+     * @param magnitude  the parameter providing the magnitude of the result\n+     * @param sign   the parameter providing the sign of the result\n+     * @return a value with the magnitude of {@code magnitude}\n+     * and the sign of {@code sign}.\n+     *\n+     * @see Math#copySign(float, float)\n+     * @see Math#copySign(double, double)\n+     *\/\n+    public static Bfloat16 copySign(Bfloat16 magnitude, Bfloat16 sign) {\n+        return shortBitsToBfloat16((short)((bfloat16ToRawShortBits(sign)      & SIGN_BIT_MASK) |\n+                                           (bfloat16ToRawShortBits(magnitude) & MAG_BIT_MASK )));\n+    }\n+\n+    \/**\n+     * Returns the signum function of the argument; zero if the argument\n+     * is zero, 1.0 if the argument is greater than zero, -1.0 if the\n+     * argument is less than zero.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive zero or negative zero, then the\n+     *      result is the same as the argument.\n+     * <\/ul>\n+     *\n+     * @param f the floating-point value whose signum is to be returned\n+     * @return the signum function of the argument\n+     *\n+     * @see Math#signum(float)\n+     * @see Math#signum(double)\n+     *\/\n+    public static Bfloat16 signum(Bfloat16 f) {\n+        return (f.floatValue() == 0.0f || isNaN(f)) ? f : copySign(ONE, f);\n+    }\n+\n+    \/\/ TODO: Temporary location for this functionality while Bfloat16\n+    \/\/ resides in incubator.\n+    private static final class Bfloat16ToDecimal {\n+        \/*\n+         * For full details about this code see the following references:\n+         *\n+         * [1] Giulietti, \"The Schubfach way to render doubles\",\n+         *     https:\/\/drive.google.com\/file\/d\/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb\n+         *\n+         * [2] IEEE Computer Society, \"IEEE Standard for Floating-Point Arithmetic\"\n+         *\n+         * [3] Bouvier & Zimmermann, \"Division-Free Binary-to-Decimal Conversion\"\n+         *\n+         * Divisions are avoided altogether for the benefit of those architectures\n+         * that do not provide specific machine instructions or where they are slow.\n+         * This is discussed in section 10 of [1].\n+         *\/\n+\n+        \/* The precision in bits *\/\n+        static final int P = PRECISION;\n+\n+        \/* Exponent width in bits *\/\n+        private static final int W = (Bfloat16.SIZE - 1) - (P - 1);\n+\n+        \/* Minimum value of the exponent: -(2^(W-1)) - P + 3 *\/\n+        static final int Q_MIN = (-1 << (W - 1)) - P + 3;\n+\n+        \/* Maximum value of the exponent: 2^(W-1) - P *\/\n+        static final int Q_MAX = (1 << (W - 1)) - P;\n+\n+        \/* 10^(E_MIN - 1) <= MIN_VALUE < 10^E_MIN *\/\n+        static final int E_MIN = -7;\n+\n+        \/* 10^(E_MAX - 1) <= MAX_VALUE < 10^E_MAX *\/\n+        static final int E_MAX = 5;\n+\n+        \/* Threshold to detect tiny values, as in section 8.2.1 of [1] *\/\n+        static final int C_TINY = 2;\n+\n+        \/* The minimum and maximum k, as in section 8 of [1] *\/\n+        static final int K_MIN = -8;\n+        static final int K_MAX = 1;\n+\n+        \/* H is as in section 8.1 of [1] *\/\n+        static final int H = 5;\n+\n+        \/* Minimum value of the significand of a normal value: 2^(P-1) *\/\n+        private static final int C_MIN = 1 << (P - 1);\n+\n+        \/* Mask to extract the biased exponent *\/\n+        private static final int BQ_MASK = (1 << W) - 1;\n+\n+        \/* Mask to extract the fraction bits *\/\n+        private static final int T_MASK = (1 << (P - 1)) - 1;\n+\n+        \/* Used in rop() *\/\n+        private static final long MASK_32 = (1L << 32) - 1;\n+\n+        \/* Used for left-to-tight digit extraction *\/\n+        private static final int MASK_15 = (1 << 15) - 1;\n+\n+        private static final int NON_SPECIAL    = 0;\n+        private static final int PLUS_ZERO      = 1;\n+        private static final int MINUS_ZERO     = 2;\n+        private static final int PLUS_INF       = 3;\n+        private static final int MINUS_INF      = 4;\n+        private static final int NAN            = 5;\n+\n+        \/*\n+         * Room for the longer of the forms\n+         *     -ddd.dd      H + 2 characters\n+         *     -ddddd.0     H + 3 characters\n+         *     -0.00ddddd   H + 5 characters\n+         *     -d.ddddE-e   H + 5 characters\n+         * where there are H digits d\n+         *\/\n+        public static final int MAX_CHARS = H + 5;\n+\n+        private final byte[] bytes = new byte[MAX_CHARS];\n+\n+        \/* Index into bytes of rightmost valid character *\/\n+        private int index;\n+\n+        private Bfloat16ToDecimal() {\n+        }\n+\n+        \/**\n+         * Returns a string representation of the {@code Bfloat16}\n+         * argument. All characters mentioned below are ASCII characters.\n+         *\n+         * @param   v   the {@code Bfloat16} to be converted.\n+         * @return a string representation of the argument.\n+         * @see Bfloat16#toString(Bfloat16)\n+         *\/\n+        public static String toString(Bfloat16 v) {\n+            return new Bfloat16ToDecimal().toDecimalString(v);\n+        }\n+\n+        \/**\n+         * Appends the rendering of the {@code v} to {@code app}.\n+         *\n+         * <p>The outcome is the same as if {@code v} were first\n+         * {@link #toString(Bfloat16) rendered} and the resulting string were then\n+         * {@link Appendable#append(CharSequence) appended} to {@code app}.\n+         *\n+         * @param v the {@code Bfloat16} whose rendering is appended.\n+         * @param app the {@link Appendable} to append to.\n+         * @throws IOException If an I\/O error occurs\n+         *\/\n+        public static Appendable appendTo(Bfloat16 v, Appendable app)\n+                throws IOException {\n+            return new Bfloat16ToDecimal().appendDecimalTo(v, app);\n+        }\n+\n+        private String toDecimalString(Bfloat16 v) {\n+            return switch (toDecimal(v)) {\n+                case NON_SPECIAL -> charsToString();\n+                case PLUS_ZERO -> \"0.0\";\n+                case MINUS_ZERO -> \"-0.0\";\n+                case PLUS_INF -> \"Infinity\";\n+                case MINUS_INF -> \"-Infinity\";\n+                default -> \"NaN\";\n+            };\n+        }\n+\n+        private Appendable appendDecimalTo(Bfloat16 v, Appendable app)\n+                throws IOException {\n+            switch (toDecimal(v)) {\n+                case NON_SPECIAL:\n+                    char[] chars = new char[index + 1];\n+                    for (int i = 0; i < chars.length; ++i) {\n+                        chars[i] = (char) bytes[i];\n+                    }\n+                    if (app instanceof StringBuilder builder) {\n+                        return builder.append(chars);\n+                    }\n+                    if (app instanceof StringBuffer buffer) {\n+                        return buffer.append(chars);\n+                    }\n+                    for (char c : chars) {\n+                        app.append(c);\n+                    }\n+                    return app;\n+                case PLUS_ZERO: return app.append(\"0.0\");\n+                case MINUS_ZERO: return app.append(\"-0.0\");\n+                case PLUS_INF: return app.append(\"Infinity\");\n+                case MINUS_INF: return app.append(\"-Infinity\");\n+                default: return app.append(\"NaN\");\n+            }\n+        }\n+\n+        \/*\n+         * Returns\n+         *     PLUS_ZERO       iff v is 0.0\n+         *     MINUS_ZERO      iff v is -0.0\n+         *     PLUS_INF        iff v is POSITIVE_INFINITY\n+         *     MINUS_INF       iff v is NEGATIVE_INFINITY\n+         *     NAN             iff v is NaN\n+         *\/\n+        private int toDecimal(Bfloat16 v) {\n+            \/*\n+             * For full details see references [2] and [1].\n+             *\n+             * For finite v != 0, determine integers c and q such that\n+             *     |v| = c 2^q    and\n+             *     Q_MIN <= q <= Q_MAX    and\n+             *         either    2^(P-1) <= c < 2^P                 (normal)\n+             *         or        0 < c < 2^(P-1)  and  q = Q_MIN    (subnormal)\n+             *\/\n+            int bits = bfloat16ToRawShortBits(v);\n+            int t = bits & T_MASK;\n+            int bq = (bits >>> P - 1) & BQ_MASK;\n+            if (bq < BQ_MASK) {\n+                index = -1;\n+                if (bits < 0) {\n+                    append('-');\n+                }\n+                if (bq != 0) {\n+                    \/* normal value. Here mq = -q *\/\n+                    int mq = -Q_MIN + 1 - bq;\n+                    int c = C_MIN | t;\n+                    \/* The fast path discussed in section 8.3 of [1] *\/\n+                    if (0 < mq & mq < P) {\n+                        int f = c >> mq;\n+                        if (f << mq == c) {\n+                            return toChars(f, 0);\n+                        }\n+                    }\n+                    return toDecimal(-mq, c, 0);\n+                }\n+                if (t != 0) {\n+                    \/* subnormal value *\/\n+                    return t < C_TINY\n+                            ? toDecimal(Q_MIN, 10 * t, -1)\n+                            : toDecimal(Q_MIN, t, 0);\n+                }\n+                return bits == 0 ? PLUS_ZERO : MINUS_ZERO;\n+            }\n+            if (t != 0) {\n+                return NAN;\n+            }\n+            return bits > 0 ? PLUS_INF : MINUS_INF;\n+        }\n+\n+        private int toDecimal(int q, int c, int dk) {\n+            \/*\n+             * The skeleton corresponds to figure 7 of [1].\n+             * The efficient computations are those summarized in figure 9.\n+             * Also check the appendix.\n+             *\n+             * Here's a correspondence between Java names and names in [1],\n+             * expressed as approximate LaTeX source code and informally.\n+             * Other names are identical.\n+             * cb:     \\bar{c}     \"c-bar\"\n+             * cbr:    \\bar{c}_r   \"c-bar-r\"\n+             * cbl:    \\bar{c}_l   \"c-bar-l\"\n+             *\n+             * vb:     \\bar{v}     \"v-bar\"\n+             * vbr:    \\bar{v}_r   \"v-bar-r\"\n+             * vbl:    \\bar{v}_l   \"v-bar-l\"\n+             *\n+             * rop:    r_o'        \"r-o-prime\"\n+             *\/\n+            int out = c & 0x1;\n+            long cb = c << 2;\n+            long cbr = cb + 2;\n+            long cbl;\n+            int k;\n+            \/*\n+             * flog10pow2(e) = floor(log_10(2^e))\n+             * flog10threeQuartersPow2(e) = floor(log_10(3\/4 2^e))\n+             * flog2pow10(e) = floor(log_2(10^e))\n+             *\/\n+            if (c != C_MIN | q == Q_MIN) {\n+                \/* regular spacing *\/\n+                cbl = cb - 2;\n+                k = MathUtils.flog10pow2(q);\n+            } else {\n+                \/* irregular spacing *\/\n+                cbl = cb - 1;\n+                k = MathUtils.flog10threeQuartersPow2(q);\n+            }\n+            int h = q + MathUtils.flog2pow10(-k) + 33;\n+\n+            \/* g is as in the appendix *\/\n+            long g = MathUtils.g1(k) + 1;\n+\n+            int vb = rop(g, cb << h);\n+            int vbl = rop(g, cbl << h);\n+            int vbr = rop(g, cbr << h);\n+\n+            int s = vb >> 2;\n+            if (s >= 100) {\n+                \/*\n+                 * For n = 5, m = 1 the discussion in section 10 of [1] shows\n+                 *     s' = floor(s \/ 10) = floor(s 52_429 \/ 2^19)\n+                 *\n+                 * sp10 = 10 s'\n+                 * tp10 = 10 t'\n+                 * upin    iff    u' = sp10 10^k in Rv\n+                 * wpin    iff    w' = tp10 10^k in Rv\n+                 * See section 9.3 of [1].\n+                 *\/\n+                int sp10 = 10 * (int) (s * 52_429L >>> 19);\n+                int tp10 = sp10 + 10;\n+                boolean upin = vbl + out <= sp10 << 2;\n+                boolean wpin = (tp10 << 2) + out <= vbr;\n+                if (upin != wpin) {\n+                    return toChars(upin ? sp10 : tp10, k);\n+                }\n+            }\n+\n+            \/*\n+             * 10 <= s < 100    or    s >= 100  and  u', w' not in Rv\n+             * uin    iff    u = s 10^k in Rv\n+             * win    iff    w = t 10^k in Rv\n+             * See section 9.3 of [1].\n+             *\/\n+            int t = s + 1;\n+            boolean uin = vbl + out <= s << 2;\n+            boolean win = (t << 2) + out <= vbr;\n+            if (uin != win) {\n+                \/* Exactly one of u or w lies in Rv *\/\n+                return toChars(uin ? s : t, k + dk);\n+            }\n+            \/*\n+             * Both u and w lie in Rv: determine the one closest to v.\n+             * See section 9.3 of [1].\n+             *\/\n+            int cmp = vb - (s + t << 1);\n+            return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        }\n+\n+        \/*\n+         * Computes rop(cp g 2^(-95))\n+         * See appendix and figure 11 of [1].\n+         *\/\n+        private static int rop(long g, long cp) {\n+            long x1 = multiplyHigh(g, cp);\n+            long vbp = x1 >>> 31;\n+            return (int) (vbp | (x1 & MASK_32) + MASK_32 >>> 32);\n+        }\n+\n+        \/*\n+         * Formats the decimal f 10^e.\n+         *\/\n+        private int toChars(int f, int e) {\n+            \/*\n+             * For details not discussed here see section 10 of [1].\n+             *\n+             * Determine len such that\n+             *     10^(len-1) <= f < 10^len\n+             *\/\n+            int len = MathUtils.flog10pow2(Integer.SIZE - numberOfLeadingZeros(f));\n+            if (f >= MathUtils.pow10(len)) {\n+                len += 1;\n+            }\n+\n+            \/*\n+             * Let fp and ep be the original f and e, respectively.\n+             * Transform f and e to ensure\n+             *     10^(H-1) <= f < 10^H\n+             *     fp 10^ep = f 10^(e-H) = 0.f 10^e\n+             *\/\n+            f *= (int)MathUtils.pow10(H - len);\n+            e += len;\n+\n+            \/*\n+             * The toChars?() methods perform left-to-right digits extraction\n+             * using ints, provided that the arguments are limited to 8 digits.\n+             * Therefore, split the H = 9 digits of f into:\n+             *     h = the most significant digit of f\n+             *     l = the last 4, least significant digits of f\n+             *\n+             * For n = 5, m = 4 the discussion in section 10 of [1] shows\n+             *     floor(f \/ 10^4) = floor(107_375L f \/ 2^30)\n+             *\/\n+            int h = (int) (f * 107_375L >>> 30);\n+            int l = f - 10_000 * h;\n+\n+            if (0 < e && e <= 7) {\n+                return toChars1(h, l, e);\n+            }\n+            if (-3 < e && e <= 0) {\n+                return toChars2(h, l, e);\n+            }\n+            return toChars3(h, l, e);\n+        }\n+\n+        private int toChars1(int h, int l, int e) {\n+            \/*\n+             * 0 < e <= 7: plain format without leading zeroes.\n+             * Left-to-right digits extraction:\n+             * algorithm 1 in [3], with b = 10, k = 4, n = 15.\n+             *\/\n+            appendDigit(h);\n+            int y = y(l);\n+            int t;\n+            int i = 1;\n+            for (; i < e; ++i) {\n+                t = 10 * y;\n+                appendDigit(t >>> 15);\n+                y = t & MASK_15;\n+            }\n+            append('.');\n+            for (; i <= 4; ++i) {\n+                t = 10 * y;\n+                appendDigit(t >>> 15);\n+                y = t & MASK_15;\n+            }\n+            \/*\n+             * As H = 5 < 7, where 7 is the threshold for plain format without\n+             * leading zeros, it can happen that the 2nd loop above is not executed.\n+             * The following line ensures the presence of a digit to the right\n+             * of the decimal point.\n+             *\/\n+            appendDigit(0);\n+            removeTrailingZeroes();\n+            return NON_SPECIAL;\n+        }\n+\n+        private int toChars2(int h, int l, int e) {\n+            \/* -3 < e <= 0: plain format with leading zeroes *\/\n+            appendDigit(0);\n+            append('.');\n+            for (; e < 0; ++e) {\n+                appendDigit(0);\n+            }\n+            appendDigit(h);\n+            append4Digits(l);\n+            removeTrailingZeroes();\n+            return NON_SPECIAL;\n+        }\n+\n+        private int toChars3(int h, int l, int e) {\n+            \/* -3 >= e | e > 7: computerized scientific notation *\/\n+            appendDigit(h);\n+            append('.');\n+            append4Digits(l);\n+            removeTrailingZeroes();\n+            exponent(e - 1);\n+            return NON_SPECIAL;\n+        }\n+\n+        private void append4Digits(int m) {\n+            \/*\n+             * Left-to-right digits extraction:\n+             * algorithm 1 in [3], with b = 10, k = 4, n = 15.\n+             *\/\n+            int y = y(m);\n+            for (int i = 0; i < 4; ++i) {\n+                int t = 10 * y;\n+                appendDigit(t >>> 15);\n+                y = t & MASK_15;\n+            }\n+        }\n+\n+        private void removeTrailingZeroes() {\n+            while (bytes[index] == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (bytes[index] == '.') {\n+                ++index;\n+            }\n+        }\n+\n+        private int y(int a) {\n+            \/*\n+             * Algorithm 1 in [3] needs computation of\n+             *     floor((a + 1) 2^n \/ b^k) - 1\n+             * with a < 10^4, b = 10, k = 4, n = 15.\n+             * Noting that\n+             *     (a + 1) 2^n <= 10^4 2^15 < 10^9\n+             * For n = 9, m = 4 the discussion in section 10 of [1] leads to:\n+             *\/\n+            return (int) (((a + 1) << 15) * 1_759_218_605L >>> 44) - 1;\n+        }\n+\n+        private void exponent(int e) {\n+            append('E');\n+            if (e < 0) {\n+                append('-');\n+                e = -e;\n+            }\n+            appendDigit(e);\n+        }\n+\n+        private void append(int c) {\n+            bytes[++index] = (byte) c;\n+        }\n+\n+        private void appendDigit(int d) {\n+            bytes[++index] = (byte) ('0' + d);\n+        }\n+\n+        \/* Using the deprecated constructor enhances performance *\/\n+        @SuppressWarnings(\"deprecation\")\n+        private String charsToString() {\n+            return new String(bytes, 0, 0, index + 1);\n+        }\n+\n+    }\n+\n+    \/* TODO Temporary hack while Bfloat16 resides in incubator *\/\n+\n+    \/**\n+     * This class exposes package private utilities for other classes.\n+     * Thus, all methods are assumed to be invoked with correct arguments,\n+     * so these are not checked at all.\n+     *\/\n+    private static final class MathUtils {\n+        \/*\n+         * For full details about this code see the following reference:\n+         *\n+         *     Giulietti, \"The Schubfach way to render doubles\",\n+         *     https:\/\/drive.google.com\/file\/d\/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb\n+         *\/\n+\n+        \/*\n+         * The boundaries for k in g0(int) and g1(int).\n+         * K_MIN must be DoubleToDecimal.K_MIN or less.\n+         * K_MAX must be DoubleToDecimal.K_MAX or more.\n+         *\/\n+        static final int K_MIN = -8;\n+        static final int K_MAX = 1;\n+\n+        \/* Must be DoubleToDecimal.H or more *\/\n+        static final int H = 17;\n+\n+        \/* C_10 = floor(log10(2) * 2^Q_10), A_10 = floor(log10(3\/4) * 2^Q_10) *\/\n+        private static final int Q_10 = 41;\n+        private static final long C_10 = 661_971_961_083L;\n+        private static final long A_10 = -274_743_187_321L;\n+\n+        \/* C_2 = floor(log2(10) * 2^Q_2) *\/\n+        private static final int Q_2 = 38;\n+        private static final long C_2 = 913_124_641_741L;\n+\n+        private MathUtils() {\n+            throw new RuntimeException(\"not supposed to be instantiated.\");\n+        }\n+\n+        \/* The first powers of 10. The last entry must be 10^(DoubleToDecimal.H) *\/\n+        private static final long[] pow10 = {\n+                1L,\n+                10L,\n+                100L,\n+                1_000L,\n+                10_000L,\n+                100_000L,\n+                1_000_000L,\n+                10_000_000L,\n+                100_000_000L,\n+                1_000_000_000L,\n+                10_000_000_000L,\n+                100_000_000_000L,\n+                1_000_000_000_000L,\n+                10_000_000_000_000L,\n+                100_000_000_000_000L,\n+                1_000_000_000_000_000L,\n+                10_000_000_000_000_000L,\n+                100_000_000_000_000_000L,\n+        };\n+\n+        \/**\n+         * Returns 10<sup>{@code e}<\/sup>.\n+         *\n+         * @param e The exponent which must meet\n+         *          0 &le; {@code e} &le; {@link #H}.\n+         * @return 10<sup>{@code e}<\/sup>.\n+         *\/\n+        static long pow10(int e) {\n+            return pow10[e];\n+        }\n+\n+        \/**\n+         * Returns the unique integer <i>k<\/i> such that\n+         * 10<sup><i>k<\/i><\/sup> &le; 2<sup>{@code e}<\/sup>\n+         * &lt; 10<sup><i>k<\/i>+1<\/sup>.\n+         * <p>\n+         * The result is correct when |{@code e}| &le; 6_432_162.\n+         * Otherwise, the result is undefined.\n+         *\n+         * @param e The exponent of 2, which should meet\n+         *          |{@code e}| &le; 6_432_162 for safe results.\n+         * @return &lfloor;log<sub>10<\/sub>2<sup>{@code e}<\/sup>&rfloor;.\n+         *\/\n+        static int flog10pow2(int e) {\n+            return (int) (e * C_10 >> Q_10);\n+        }\n+\n+        \/**\n+         * Returns the unique integer <i>k<\/i> such that\n+         * 10<sup><i>k<\/i><\/sup> &le; 3\/4 &middot; 2<sup>{@code e}<\/sup>\n+         * &lt; 10<sup><i>k<\/i>+1<\/sup>.\n+         * <p>\n+         * The result is correct when\n+         * -3_606_689 &le; {@code e} &le; 3_150_619.\n+         * Otherwise, the result is undefined.\n+         *\n+         * @param e The exponent of 2, which should meet\n+         *          -3_606_689 &le; {@code e} &le; 3_150_619 for safe results.\n+         * @return &lfloor;log<sub>10<\/sub>(3\/4 &middot;\n+         * 2<sup>{@code e}<\/sup>)&rfloor;.\n+         *\/\n+        static int flog10threeQuartersPow2(int e) {\n+            return (int) (e * C_10 + A_10 >> Q_10);\n+        }\n+\n+        \/**\n+         * Returns the unique integer <i>k<\/i> such that\n+         * 2<sup><i>k<\/i><\/sup> &le; 10<sup>{@code e}<\/sup>\n+         * &lt; 2<sup><i>k<\/i>+1<\/sup>.\n+         * <p>\n+         * The result is correct when |{@code e}| &le; 1_838_394.\n+         * Otherwise, the result is undefined.\n+         *\n+         * @param e The exponent of 10, which should meet\n+         *          |{@code e}| &le; 1_838_394 for safe results.\n+         * @return &lfloor;log<sub>2<\/sub>10<sup>{@code e}<\/sup>&rfloor;.\n+         *\/\n+        static int flog2pow10(int e) {\n+            return (int) (e * C_2 >> Q_2);\n+        }\n+\n+        \/**\n+         * Let 10<sup>-{@code k}<\/sup> = <i>&beta;<\/i> 2<sup><i>r<\/i><\/sup>,\n+         * for the unique pair of integer <i>r<\/i> and real <i>&beta;<\/i> meeting\n+         * 2<sup>125<\/sup> &le; <i>&beta;<\/i> &lt; 2<sup>126<\/sup>.\n+         * Further, let <i>g<\/i> = &lfloor;<i>&beta;<\/i>&rfloor; + 1.\n+         * Split <i>g<\/i> into the higher 63 bits <i>g<\/i><sub>1<\/sub> and\n+         * the lower 63 bits <i>g<\/i><sub>0<\/sub>. Thus,\n+         * <i>g<\/i><sub>1<\/sub> =\n+         * &lfloor;<i>g<\/i> 2<sup>-63<\/sup>&rfloor;\n+         * and\n+         * <i>g<\/i><sub>0<\/sub> =\n+         * <i>g<\/i> - <i>g<\/i><sub>1<\/sub> 2<sup>63<\/sup>.\n+         * <p>\n+         * This method returns <i>g<\/i><sub>1<\/sub> while\n+         * {@link #g0(int)} returns <i>g<\/i><sub>0<\/sub>.\n+         * <p>\n+         * If needed, the exponent <i>r<\/i> can be computed as\n+         * <i>r<\/i> = {@code flog2pow10(-k)} - 125 (see {@link #flog2pow10(int)}).\n+         *\n+         * @param k The exponent of 10, which must meet\n+         *          {@link #K_MIN} &le; {@code e} &le; {@link #K_MAX}.\n+         * @return <i>g<\/i><sub>1<\/sub> as described above.\n+         *\/\n+        static long g1(int k) {\n+            return g[k - K_MIN << 1];\n+        }\n+\n+        \/**\n+         * Returns <i>g<\/i><sub>0<\/sub> as described in\n+         * {@link #g1(int)}.\n+         *\n+         * @param k The exponent of 10, which must meet\n+         *          {@link #K_MIN} &le; {@code e} &le; {@link #K_MAX}.\n+         * @return <i>g<\/i><sub>0<\/sub> as described in\n+         * {@link #g1(int)}.\n+         *\/\n+        static long g0(int k) {\n+            return g[k - K_MIN << 1 | 1];\n+        }\n+\n+        \/*\n+         * The precomputed values for g1(int) and g0(int).\n+         * The first entry must be for an exponent of K_MIN or less.\n+         * The last entry must be for an exponent of K_MAX or more.\n+         *\/\n+        private static final long[] g = {\n+                0x5F5E_1000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -8\n+                0x4C4B_4000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -7\n+                0x7A12_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -6\n+                0x61A8_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -5\n+                0x4E20_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -4\n+                0x7D00_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -3\n+                0x6400_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -2\n+                0x5000_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -1\n+                0x4000_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/    0\n+                0x6666_6666_6666_6666L, 0x3333_3333_3333_3334L, \/\/    1\n+        };\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/Bfloat16.java","additions":2509,"deletions":0,"binary":false,"changes":2509,"status":"added"},{"patch":"@@ -0,0 +1,442 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340339\n+ * @summary Verify conversion between float and the bfloat16 format\n+ * @library ..\/..\/..\/..\/java\/lang\/Math\n+ * @modules jdk.incubator.vector\n+ * @build Bfloat16\n+ * @run main Binary16Conversion\n+ *\/\n+\n+public class Binary16Conversion {\n+    public static void main(String... argv) {\n+        int errors = 0;\n+        errors += binary16RoundTrip();\n+        \/\/ Note that helper methods do sign-symmetric testing\n+        errors += binary16CardinalValues();\n+        errors += roundFloatToBinary16();\n+        errors += roundFloatToBinary16HalfWayCases();\n+        errors += roundFloatToBinary16FullBinade();\n+        \/\/         errors += alternativeImplementation();\n+\n+        if (errors > 0)\n+            throw new RuntimeException(errors + \" errors\");\n+    }\n+\n+    \/*\n+     * Put all 16-bit values through a conversion loop and make sure\n+     * the values are preserved (NaN bit patterns notwithstanding).\n+     *\/\n+    private static int binary16RoundTrip() {\n+        int errors = 0;\n+        for (int i = Short.MIN_VALUE; i < Short.MAX_VALUE; i++) {\n+            short s = (short)i;\n+            float f =  Bfloat16.bfloat16ToFloat(s);\n+            short s2 = Bfloat16.floatToBfloat16(f);\n+\n+            if (!Binary16.equivalent(s, s2)) {\n+                errors++;\n+                System.out.println(\"Roundtrip failure on 0x\" +\n+                                   Integer.toHexString(0xFFFF & (int)s) +\n+                                   \"\\t got back 0x\" + Integer.toHexString(0xFFFF & (int)s2));\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    private static int binary16CardinalValues() {\n+        int errors = 0;\n+        \/\/ Encode short value for different binary16 cardinal values as an\n+        \/\/ integer-valued float.\n+        float[][] testCases = {\n+            {Binary16.POSITIVE_ZERO,         +0.0f},\n+            {Binary16.MIN_VALUE,              0x1.0p-133f},\n+            {Binary16.MAX_SUBNORMAL,          0x0.fep-126f},\n+            {Binary16.MIN_NORMAL,             0x1.0p-126f},\n+            {Binary16.ONE,                    1.0f},\n+            {Binary16.MAX_VALUE,              0x1.fep127f},\n+            {Binary16.POSITIVE_INFINITY,      Float.POSITIVE_INFINITY},\n+\n+            \/\/ Cardinal values of the binary float16 format\n+            {floatToShortBitsAsFloat(0x1.0p-24f),   0x1.0p-24f}, \/\/ Float16.MIN_VALUE\n+            {floatToShortBitsAsFloat(0x1.ff8p-15f), 0x1.0p-14f}, \/\/ Float16 MAX_SUBNORMAL (rounded)\n+            {floatToShortBitsAsFloat(0x1.0p-14f),   0x1.0p-14f}, \/\/ Float16.MIN_NORMAL\n+            {floatToShortBitsAsFloat(0x1.ffcp15f),  0x1.00p16f}, \/\/ Float16.MAX_VALUE (rounded)\n+        };\n+\n+        \/\/ Check conversions in both directions\n+\n+        \/\/ short -> float\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError((short)testCase[0],\n+                                            testCase[1]);\n+        }\n+\n+        \/\/ float -> short\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[1],\n+                                            (short)testCase[0]);\n+        }\n+\n+        return errors;\n+    }\n+\n+    private static float floatToShortBitsAsFloat(float f) {\n+        return (float)Bfloat16.bfloat16ToRawShortBits(Bfloat16.valueOf(f));\n+    }\n+\n+    private static int roundFloatToBinary16() {\n+        int errors = 0;\n+\n+        float[][] testCases = {\n+            \/\/ Test all combinations of LSB, round, and sticky bit\n+\n+            \/\/ LSB = 0, test combination of round and sticky\n+            {0x1.fc0000p-1f,       (short)0x3f7e},             \/\/ round = 0, sticky = 0\n+            {0x1.fc0010p-1f,       (short)0x3f7e},             \/\/ round = 0, sticky = 1\n+            {0x1.fd0000p-1f,       (short)0x3f7e},             \/\/ round = 1, sticky = 0\n+            {0x1.fd0010p-1f,       (short)0x3f7f},             \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ LSB = 1, test combination of round and sticky\n+            {0x1.fe0000p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 0\n+            {0x1.fe0010p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 1\n+            {0x1.ff0000p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ff0010p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test subnormal rounding\n+            \/\/ Largest subnormal bfloat16 0x007f => 0x0.fep126f; LSB = 1\n+            {0x0.fe000p-126f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 0\n+            {0x0.fe001p-126f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 1\n+            {0x0.ff000p-126f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 0 => ++\n+            {0x0.ff001p-126f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test rounding near bfloat16 MIN_VALUE\n+            \/\/ Smallest in magnitude subnormal bfloat16 value 0x0001 => 0x1.0p-133f\n+            \/\/ Half-way case,0x1.0p-134f = 0x0.010000p-126f, and smaller should round down to zero\n+            {0x0.00fffep-126f,      Binary16.POSITIVE_ZERO},     \/\/ nextDown in float\n+            {0x0.010000p-126f,      Binary16.POSITIVE_ZERO},\n+            {0x0.010002p-126f,      Binary16.MIN_VALUE},         \/\/ nextUp in float\n+            {0x0.018000p-126f,      Binary16.MIN_VALUE},\n+\n+            \/\/ Test rounding near overflow threshold\n+            \/\/ Largest normal binary16 number 0x7f7f => 0x1.fep127f; LSB = 1\n+            {0x1.fe0000p127f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 0\n+            {0x1.fe0010p127f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 1\n+            {0x1.ff0000p127f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ff0010p127f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 1 => ++\n+        };\n+\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[0],\n+                                            (short)testCase[1]);\n+        }\n+        return errors;\n+    }\n+\n+    private static int roundFloatToBinary16HalfWayCases() {\n+        int errors = 0;\n+\n+        \/\/ Test rounding of exact half-way cases between each pair of\n+        \/\/ finite exactly-representable binary16 numbers. Also test\n+        \/\/ rounding of half-way +\/- ulp of the *float* value.\n+        \/\/ Additionally, test +\/- float ulp of the endpoints. (Other\n+        \/\/ tests in this file make sure all short values round-trip so\n+        \/\/ that doesn't need to be tested here.)\n+\n+         for (int i = Binary16.POSITIVE_ZERO; \/\/ 0x0000\n+              i    <= Binary16.MAX_VALUE;     \/\/ 0x7F7F\n+              i += 2) {     \/\/ Check every even\/odd pair once\n+\n+             short lower = (short) i;\n+             short upper = (short)(i+1);\n+\n+             float lowerFloat = Bfloat16.bfloat16ToFloat(lower);\n+             float upperFloat = Bfloat16.bfloat16ToFloat(upper);\n+             assert lowerFloat < upperFloat;\n+\n+             \/\/ Avoid intermediate overflow in computation\n+             float midway = (float)(0.5*((double)lowerFloat + (double)upperFloat)); \/\/ Exact midpoint\n+\n+             errors += compareAndReportError(Math.nextUp(lowerFloat),   lower);\n+             errors += compareAndReportError(Math.nextDown(midway),     lower);\n+\n+             \/\/ Under round to nearest even, the midway point will\n+             \/\/ round *down* to the (even) lower endpoint.\n+             errors += compareAndReportError(              midway,      lower);\n+\n+             errors += compareAndReportError(Math.nextUp(  midway),     upper);\n+             errors += compareAndReportError(Math.nextDown(upperFloat), upper);\n+         }\n+\n+        \/\/ More testing around the overflow threshold\n+        \/\/ Binary16.ulp(Binary16.MAX_VALUE) == 32.0f; test around Binary16.MAX_VALUE + 1\/2 ulp\n+        float binary16_MAX_VALUE = Bfloat16.bfloat16ToFloat(Binary16.MAX_VALUE);\n+        \/\/        float binary16_MAX_VALUE_halfUlp = binary16_MAX_VALUE +\n+        \/\/            (Bfloat16.ulp(Bfloat16.MAX_VALUE)).floatValue()*0.5f; \/\/ UPDATED\n+\n+        float binary16_MAX_VALUE_halfUlp =  0x1.ffp127f;\n+\n+        System.out.println(\"binary16_MAX_VALUE = \\t\" + Float.toHexString(binary16_MAX_VALUE) +\n+                           \"  binary16_MAX_VALUE_halfUlp = \\t\" + Float.toHexString(binary16_MAX_VALUE_halfUlp));\n+\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE,  Binary16.MAX_VALUE);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+\n+        \/\/ Binary16.MAX_VALUE is an \"odd\" value since its LSB = 1 so\n+        \/\/ the half-way value greater than Bfloat16.MAX_VALUE should\n+        \/\/ round up to the next even value, in this case Bfloat16.POSITIVE_INFINITY.\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE_halfUlp), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE_halfUlp,  Binary16.POSITIVE_INFINITY);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE_halfUlp), Binary16.POSITIVE_INFINITY);\n+\n+        return errors;\n+    }\n+\n+    private static int compareAndReportError(float input,\n+                                             short expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0( input,                 expected) +\n+               compareAndReportError0(-input, Binary16.negate(expected));\n+    }\n+\n+    private static int compareAndReportError0(float input,\n+                                              short expected) {\n+        short actual = Bfloat16.floatToBfloat16(input);\n+        if (!Binary16.equivalent(actual, expected)) {\n+            System.out.println(\"Unexpected result of converting \" +\n+                               Float.toHexString(input) +\n+                               \" to bits. Expected 0x\" + Integer.toHexString(0xFFFF & expected) +\n+                               \" got (0x\" + Integer.toHexString(0xFFFF & actual) + \" \" +\n+                               Float.toHexString(Bfloat16.bfloat16ToFloat(actual))+\")\" );\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError0(short input,\n+                                              float expected) {\n+        float actual = Bfloat16.bfloat16ToFloat(input);\n+        if (Float.compare(actual, expected) != 0) {\n+            System.out.println(\"Unexpected result of converting 0x\" +\n+                               Integer.toHexString(input & 0xFFFF) +\n+                               \" to float. Expected \" + Float.toHexString(expected) +\n+                               \" got \" + Float.toHexString(actual));\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError(short input,\n+                                             float expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0(                input,   expected) +\n+               compareAndReportError0(Binary16.negate(input), -expected);\n+    }\n+\n+    private static int roundFloatToBinary16FullBinade() {\n+        int errors = 0;\n+\n+        \/\/ For each float value between 1.0 and less than 2.0\n+        \/\/ (i.e. set of float values with an exponent of 0), convert\n+        \/\/ each value to bfloat16 and then convert that bfloat16 value\n+        \/\/ back to float.\n+        \/\/\n+        \/\/ Any exponent could be used; the maximum exponent for normal\n+        \/\/ values would not exercise the full set of code paths since\n+        \/\/ there is an up-front check on values that would overflow,\n+        \/\/ which correspond to a ripple-carry of the significand that\n+        \/\/ bumps the exponent.\n+        short previous = (short)0;\n+        for (int i = Float.floatToIntBits(1.0f);\n+             i <= Float.floatToIntBits(Math.nextDown(2.0f));\n+             i++) {\n+            \/\/ (Could also express the loop control directly in terms\n+            \/\/ of floating-point operations, incrementing by ulp(1.0),\n+            \/\/ etc.)\n+\n+            float f = Float.intBitsToFloat(i);\n+            short f_as_bin16 = Bfloat16.floatToBfloat16(f);\n+            short f_as_bin16_down = (short)(f_as_bin16 - 1);\n+            short f_as_bin16_up   = (short)(f_as_bin16 + 1);\n+\n+            \/\/ Across successive float values to convert to bfloat16,\n+            \/\/ the bfloat16 results should be semi-monotonic,\n+            \/\/ non-decreasing in this case.\n+\n+            \/\/ Only positive bfloat16 values so can compare using integer operations\n+            if (f_as_bin16 < previous) {\n+                errors++;\n+                System.out.println(\"Semi-monotonicity violation observed on \" +\n+                                   Integer.toHexString(0xfff & f_as_bin16));\n+            }\n+            previous = f_as_bin16;\n+\n+            \/\/ If round-to-nearest was correctly done, when exactly\n+            \/\/ mapped back to float, f_as_bin16 should be at least as\n+            \/\/ close as either of its neighbors to the original value\n+            \/\/ of f.\n+\n+            float f_prime_down = Bfloat16.bfloat16ToFloat(f_as_bin16_down);\n+            float f_prime      = Bfloat16.bfloat16ToFloat(f_as_bin16);\n+            float f_prime_up   = Bfloat16.bfloat16ToFloat(f_as_bin16_up);\n+\n+            float f_prime_diff = Math.abs(f - f_prime);\n+            if (f_prime_diff == 0.0) {\n+                continue;\n+            }\n+            float f_prime_down_diff = Math.abs(f - f_prime_down);\n+            float f_prime_up_diff   = Math.abs(f - f_prime_up);\n+\n+            if (f_prime_diff > f_prime_down_diff ||\n+                f_prime_diff > f_prime_up_diff) {\n+                errors++;\n+                System.out.println(\"Round-to-nearest violation on converting \" +\n+                                   Float.toHexString(f) + \" to binary16 and back.\");\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    private static int alternativeImplementation() {\n+        int errors = 0;\n+\n+        \/\/ For exhaustive test of all float values use\n+        \/\/ for (long ell = Integer.MIN_VALUE; ell <= Integer.MAX_VALUE; ell++) {\n+\n+        for (long ell   = Float.floatToIntBits(2.0f);\n+             ell       <= Float.floatToIntBits(4.0f);\n+             ell++) {\n+            float f = Float.intBitsToFloat((int)ell);\n+            short s1 = Float.floatToFloat16(f);\n+            short s2 =    altFloatToFloat16(f);\n+\n+            if (s1 != s2) {\n+                errors++;\n+                System.out.println(\"Different conversion of float value \" + Float.toHexString(f));\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    \/*\n+     * Rely on float operations to do rounding in both normal and\n+     * subnormal binary16 cases.\n+     *\/\n+    public static short altFloatToFloat16(float f) {\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel & 0x8000_0000) >> 16);\n+\n+        if (Float.isNaN(f)) {\n+            \/\/ Preserve sign and attempt to preserve significand bits\n+            return (short)(sign_bit\n+                    | 0x7c00 \/\/ max exponent + 1\n+                    \/\/ Preserve high order bit of float NaN in the\n+                    \/\/ binary16 result NaN (tenth bit); OR in remaining\n+                    \/\/ bits into lower 9 bits of binary 16 significand.\n+                    | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+                    | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+                    | (doppel & 0x0000_000f));     \/\/  4 bits\n+        }\n+\n+        float abs_f = Math.abs(f);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_f >= (65504.0f + 16.0f) ) {\n+            return (short)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+        } else {\n+            \/\/ Smallest magnitude nonzero representable binary16 value\n+            \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+            if (abs_f <= 0x1.0p-25f) { \/\/ Covers float zeros and subnormals.\n+                return sign_bit; \/\/ Positive or negative zero\n+            }\n+\n+            \/\/ Dealing with finite values in exponent range of\n+            \/\/ binary16 (when rounding is done, could still round up)\n+            int exp = Math.getExponent(f);\n+            assert -25 <= exp && exp <= 15;\n+            short signif_bits;\n+\n+            if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n+                \/\/ Use a float multiply to compute the correct\n+                \/\/ trailing significand bits for a binary16 subnormal.\n+                \/\/\n+                \/\/ The exponent range of normalized binary16 subnormal\n+                \/\/ values is [-24, -15]. The exponent range of float\n+                \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n+                \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that\n+                \/\/ the trailing bits of a subnormal float represent\n+                \/\/ the correct trailing bits of a binary16 subnormal.\n+                exp = -15; \/\/ Subnormal encoding using -E_max.\n+                float f_adjust = abs_f * 0x1.0p-125f;\n+\n+                \/\/ In case the significand rounds up and has a carry\n+                \/\/ propagate all the way up, take the bottom 11 bits\n+                \/\/ rather than bottom 10 bits. Adding this value,\n+                \/\/ rather than OR'ing htis value, will cause the right\n+                \/\/ exponent adjustment.\n+                signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n+                return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+            } else {\n+                \/\/ Scale down to subnormal range to round off excess bits\n+                int scalingExp = -139 - exp;\n+                float scaled = Math.scalb(Math.scalb(f, scalingExp),\n+                                                       -scalingExp);\n+                exp = Math.getExponent(scaled);\n+                doppel = Float.floatToRawIntBits(scaled);\n+\n+                signif_bits = (short)((doppel & 0x007f_e000) >>\n+                                      (FloatConsts.SIGNIFICAND_WIDTH - 11));\n+                return (short)(sign_bit | ( ((exp + 15) << 10) | signif_bits ) );\n+            }\n+        }\n+    }\n+\n+    public static class Binary16 {\n+        public static final short POSITIVE_INFINITY = (short)0x7F80;\n+        public static final short MAX_VALUE         = 0x7F7F;\n+        public static final short ONE               = 0x3f80;\n+        public static final short MIN_NORMAL        = 0x0080;\n+        public static final short MAX_SUBNORMAL     = 0x007F;\n+        public static final short MIN_VALUE         = 0x0001;\n+        public static final short POSITIVE_ZERO     = 0x0000;\n+\n+        public static boolean isNaN(short binary16) {\n+            return ((binary16 & 0x7F80) == 0x7F80) \/\/ Max exponent and...\n+                && ((binary16 & 0x007F) != 0 );    \/\/ significand nonzero.\n+        }\n+\n+        public static short negate(short binary16) {\n+            return (short)(binary16 ^ 0x8000 ); \/\/ Flip only sign bit.\n+        }\n+\n+        public static boolean equivalent(short bin16_1, short bin16_2) {\n+            return (bin16_1 == bin16_2) ||\n+                (isNaN(bin16_1) && isNaN(bin16_2));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/Binary16Conversion.java","additions":442,"deletions":0,"binary":false,"changes":442,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/Binary16ConversionNaN.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","status":"copied"}]}