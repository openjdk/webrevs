{"files":[{"patch":"@@ -825,1 +825,1 @@\n-    \/\/ TODO 8227588: shouldn't this have the same IR matching rules as test6?\n+    \/\/ TODO 8350865: Support flat arrays in System.arraycopy\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -382,1 +383,2 @@\n-        counts = {SCOPE_OBJECT, \">= 1\"}) \/\/ LOAD_OF_ANY_KLASS, \"<= 12\"}) \/\/ TODO 8372332, 8227588 (loads should be removed)\n+        failOn = LOAD_OF_ANY_KLASS,\n+        counts = {SCOPE_OBJECT, \">= 1\"})\n@@ -407,0 +409,4 @@\n+        \/\/ Disable OSR compilation prevents the method from getting recompiled because the IR rules\n+        \/\/ expect all loads moved into the uncommon trap, which is not the case when the method get\n+        \/\/ recompiled and the path that was unreached before is now compiled\n+        WhiteBox.getWhiteBox().makeMethodNotCompilable(info.getTest(), CompLevel.C2.getValue(), true);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -982,1 +982,0 @@\n-    \/\/ TODO 8227588: shouldn't this have the same IR matching rules as test6?\n@@ -984,0 +983,1 @@\n+    \/\/ TODO 8372332: Add LOAD_OF_ANY_KLASS when return values are not scalarized\n@@ -1036,2 +1036,1 @@\n-    \/\/ TODO 8227588\n-    \/\/ @Test(failOn = ALLOC_OF_MYVALUE_KLASS + ALLOC_ARRAY_OF_MYVALUE_KLASS + LOOP + LOAD_OF_ANY_KLASS + STORE_OF_ANY_KLASS + UNSTABLE_IF_TRAP, PREDICATE_TRAP)\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}