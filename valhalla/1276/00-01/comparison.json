{"files":[{"patch":"@@ -66,5 +66,6 @@\n-currently possible to generate configuration for two such indexers, <a\n-href=\"https:\/\/clang.llvm.org\/extra\/clangd\/\">clangd<\/a> and <a\n-href=\"https:\/\/github.com\/Andersbakken\/rtags\">rtags<\/a>. These can be\n-configured by appending the name of the indexer to the make target, such\n-as:<\/p>\n+currently possible to generate configuration for three such indexers, <a\n+href=\"https:\/\/clang.llvm.org\/extra\/clangd\/\">clangd<\/a>, <a\n+href=\"https:\/\/github.com\/MaskRay\/ccls\/wiki\/Visual-Studio-Code\">ccls<\/a>\n+and <a href=\"https:\/\/github.com\/Andersbakken\/rtags\">rtags<\/a>. These can\n+be configured by appending the name of the indexer to the make target,\n+such as:<\/p>\n","filename":"doc\/ide.html","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-configuration for two such indexers, [clangd](https:\/\/clang.llvm.org\/extra\/clangd\/)\n+configuration for three such indexers, [clangd](https:\/\/clang.llvm.org\/extra\/clangd\/),\n+[ccls](https:\/\/github.com\/MaskRay\/ccls\/wiki\/Visual-Studio-Code)\n","filename":"doc\/ide.md","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=true\n+    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=auto\n@@ -202,1 +202,0 @@\n-  AC_SUBST(COMPATIBLE_CDS_ALIGNMENT_DEFAULT)\n@@ -441,0 +440,9 @@\n+          # detect_stack_use_after_return causes ASAN to offload stack-local\n+          # variables to c-heap and therefore breaks assumptions in hotspot\n+          # that rely on data (e.g. Marks) living in thread stacks.\n+          if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+            ASAN_CFLAGS=\"$ASAN_CFLAGS --param asan-use-after-return=0\"\n+          fi\n+          if test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+            ASAN_CFLAGS=\"$ASAN_CFLAGS -fsanitize-address-use-after-return=never\"\n+          fi\n@@ -447,0 +455,2 @@\n+          # -fsanitize-address-use-after-return is off by default in MS Visual Studio 22 (19.37.32824).\n+          # cl : Command line warning D9002 : ignoring unknown option '-fno-sanitize-address-use-after-return'\n@@ -675,1 +685,1 @@\n-      DEFAULT_DESC: [disabled],\n+      DEFAULT_DESC: [disabled except on linux-aarch64],\n","filename":"make\/autoconf\/jdk-options.m4","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,0 +54,9 @@\n+\n+################################################################################\n+## Build jnativescan\n+################################################################################\n+\n+$(eval $(call SetupBuildLauncher, jnativescan, \\\n+    MAIN_CLASS := com.sun.tools.jnativescan.Main, \\\n+    CFLAGS := -DEXPAND_CLASSPATH_WILDCARDS, \\\n+))\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-            for (TypeElement t : metadata.getEventsAndStructs()) {\n+            for (TypeElement t : metadata.getEvents()) {\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1185,1 +1185,1 @@\n-  \/\/ Bizzarely, the counts are passed in bytes, regardless of whether they\n+  \/\/ Bizarrely, the counts are passed in bytes, regardless of whether they\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1639,2 +1639,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n@@ -1679,2 +1678,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2032,5 +2032,2 @@\n-  {\n-    uint64_t offset;\n-    __ adrp(rscratch1, ExternalAddress((address)&DTraceMethodProbes), offset);\n-    __ ldrb(rscratch1, Address(rscratch1, offset));\n-    __ cbnzw(rscratch1, dtrace_method_entry);\n+  if (DTraceMethodProbes) {\n+    __ b(dtrace_method_entry);\n@@ -2272,5 +2269,2 @@\n-  {\n-    uint64_t offset;\n-    __ adrp(rscratch1, ExternalAddress((address)&DTraceMethodProbes), offset);\n-    __ ldrb(rscratch1, Address(rscratch1, offset));\n-    __ cbnzw(rscratch1, dtrace_method_exit);\n+  if (DTraceMethodProbes) {\n+    __ b(dtrace_method_exit);\n@@ -2420,16 +2414,17 @@\n-  {\n-    __ block_comment(\"dtrace entry {\");\n-    __ bind(dtrace_method_entry);\n-\n-    \/\/ We have all of the arguments setup at this point. We must not touch any register\n-    \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n-\n-    save_args(masm, total_c_args, c_arg, out_regs);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-      CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n-      rthread, c_rarg1);\n-    restore_args(masm, total_c_args, c_arg, out_regs);\n-    __ b(dtrace_method_entry_done);\n-    __ block_comment(\"} dtrace entry\");\n-  }\n+  if (DTraceMethodProbes) {\n+    {\n+      __ block_comment(\"dtrace entry {\");\n+      __ bind(dtrace_method_entry);\n+\n+      \/\/ We have all of the arguments setup at this point. We must not touch any register\n+      \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n+\n+      save_args(masm, total_c_args, c_arg, out_regs);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+        CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n+        rthread, c_rarg1);\n+      restore_args(masm, total_c_args, c_arg, out_regs);\n+      __ b(dtrace_method_entry_done);\n+      __ block_comment(\"} dtrace entry\");\n+    }\n@@ -2437,11 +2432,12 @@\n-  {\n-    __ block_comment(\"dtrace exit {\");\n-    __ bind(dtrace_method_exit);\n-    save_native_result(masm, ret_type, stack_slots);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-         CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n-         rthread, c_rarg1);\n-    restore_native_result(masm, ret_type, stack_slots);\n-    __ b(dtrace_method_exit_done);\n-    __ block_comment(\"} dtrace exit\");\n+    {\n+      __ block_comment(\"dtrace exit {\");\n+      __ bind(dtrace_method_exit);\n+      save_native_result(masm, ret_type, stack_slots);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+        CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n+        rthread, c_rarg1);\n+      restore_native_result(masm, ret_type, stack_slots);\n+      __ b(dtrace_method_exit_done);\n+      __ block_comment(\"} dtrace exit\");\n+    }\n@@ -2450,1 +2446,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":33,"deletions":38,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -3916,0 +3916,8 @@\n+    if (DTraceAllocProbes) {\n+      \/\/ Trigger dtrace event for fastpath\n+      __ push(atos); \/\/ save the return value\n+      __ call_VM_leaf(\n+           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), r0);\n+      __ pop(atos); \/\/ restore the return value\n+\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,2 +155,8 @@\n-    __ ldr(R1, Address(OSR_buf, slot_offset + 0*BytesPerWord));\n-    __ ldr(R2, Address(OSR_buf, slot_offset + 1*BytesPerWord));\n+    if (slot_offset >= 4096 - BytesPerWord) {\n+      __ add_slow(R2, OSR_buf, slot_offset);\n+      __ ldr(R1, Address(R2, 0*BytesPerWord));\n+      __ ldr(R2, Address(R2, 1*BytesPerWord));\n+    } else {\n+      __ ldr(R1, Address(OSR_buf, slot_offset + 0*BytesPerWord));\n+      __ ldr(R2, Address(OSR_buf, slot_offset + 1*BytesPerWord));\n+    }\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -353,0 +353,1 @@\n+    SETBCR_OPCODE = (31u << OPCODE_SHIFT | 416u << 1),\n@@ -1783,0 +1784,2 @@\n+  inline void setbcr(Register d, int biint);\n+  inline void setbcr(Register d, ConditionRegister cr, Condition cc);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -422,0 +422,5 @@\n+inline void Assembler::setbcr(Register d, int biint)\n+                                                  { emit_int32(SETBCR_OPCODE | rt(d) | bi(biint)); }\n+inline void Assembler::setbcr(Register d, ConditionRegister cr, Condition cc) {\n+  setbcr(d, bi0(cr, cc));\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2386,4 +2386,1 @@\n-  neg(R0, result);\n-  orr(result, result, R0);\n-  srdi(result, result, 63);\n-\n+  normalize_bool(result, R0, true);\n@@ -2398,3 +2395,1 @@\n-  neg(R0, linear_result);\n-  orr(linear_result, linear_result, R0);\n-  srdi(linear_result, linear_result, 63);\n+  normalize_bool(linear_result, R0, true);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -181,0 +181,2 @@\n+  \/\/ Branch-free implementation to convert !=0 to 1.\n+  void inline normalize_bool(Register dst, Register temp = R0, bool is_64bit = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -267,0 +267,23 @@\n+\/\/ Branch-free implementation to convert !=0 to 1\n+\/\/ Set register dst to 1 if dst is non-zero. Uses setbcr instruction on Power10.\n+inline void MacroAssembler::normalize_bool(Register dst, Register temp, bool is_64bit) {\n+\n+  if (VM_Version::has_brw()) {\n+    if (is_64bit) {\n+      cmpdi(CCR0, dst, 0);\n+    } else {\n+      cmpwi(CCR0, dst, 0);\n+    }\n+    setbcr(dst, CCR0, Assembler::equal);\n+  } else {\n+    assert_different_registers(temp, dst);\n+    neg(temp, dst);\n+    orr(temp, dst, temp);\n+    if (is_64bit) {\n+      srdi(dst, temp, 63);\n+    } else {\n+      srwi(dst, temp, 31);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2475,5 +2475,1 @@\n-      Label skip_modify;\n-      __ cmpwi(CCR0, R3_RET, 0);\n-      __ beq(CCR0, skip_modify);\n-      __ li(R3_RET, 1);\n-      __ bind(skip_modify);\n+      __ normalize_bool(R3_RET);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -375,3 +375,1 @@\n-    __ neg(R0, R3_RET);\n-    __ orr(R0, R3_RET, R0);\n-    __ srwi(R3_RET, R0, 31);\n+    __ normalize_bool(R3_RET);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3862,4 +3862,5 @@\n-    SkipIfEqualZero::skip_to_label_if_equal_zero(_masm, Rscratch, &DTraceAllocProbes, Ldone);\n-    __ push(atos);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)));\n-    __ pop(atos);\n+    if (DTraceAllocProbes) {\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)));\n+      __ pop(atos);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1610,1 +1610,16 @@\n-void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) { Unimplemented(); }\n+void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {\n+  assert(op->crc()->is_single_cpu(),  \"crc must be register\");\n+  assert(op->val()->is_single_cpu(),  \"byte value must be register\");\n+  assert(op->result_opr()->is_single_cpu(), \"result must be register\");\n+  Register crc = op->crc()->as_register();\n+  Register val = op->val()->as_register();\n+  Register res = op->result_opr()->as_register();\n+\n+  assert_different_registers(val, crc, res);\n+  __ la(res, ExternalAddress(StubRoutines::crc_table_addr()));\n+\n+  __ notr(crc, crc); \/\/ ~crc\n+  __ zero_extend(crc, crc, 32);\n+  __ update_byte_crc32(crc, val, res);\n+  __ notr(res, crc); \/\/ ~crc\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -784,1 +784,73 @@\n-  ShouldNotReachHere();\n+  assert(UseCRC32Intrinsics, \"why are we here?\");\n+  \/\/ Make all state_for calls early since they can emit code\n+  LIR_Opr result = rlock_result(x);\n+  switch (x->id()) {\n+    case vmIntrinsics::_updateCRC32: {\n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem val(x->argument_at(1), this);\n+      \/\/ val is destroyed by update_crc32\n+      val.set_destroys_register();\n+      crc.load_item();\n+      val.load_item();\n+      __ update_crc32(crc.result(), val.result(), result);\n+      break;\n+    }\n+    case vmIntrinsics::_updateBytesCRC32:\n+    case vmIntrinsics::_updateByteBufferCRC32: {\n+      bool is_updateBytes = (x->id() == vmIntrinsics::_updateBytesCRC32);\n+\n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem buf(x->argument_at(1), this);\n+      LIRItem off(x->argument_at(2), this);\n+      LIRItem len(x->argument_at(3), this);\n+      buf.load_item();\n+      off.load_nonconstant();\n+\n+      LIR_Opr index = off.result();\n+      int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;\n+      if (off.result()->is_constant()) {\n+        index = LIR_OprFact::illegalOpr;\n+        offset += off.result()->as_jint();\n+      }\n+      LIR_Opr base_op = buf.result();\n+\n+      if (index->is_valid()) {\n+        LIR_Opr tmp = new_register(T_LONG);\n+        __ convert(Bytecodes::_i2l, index, tmp);\n+        index = tmp;\n+      }\n+\n+      if (offset) {\n+        LIR_Opr tmp = new_pointer_register();\n+        __ add(base_op, LIR_OprFact::intConst(offset), tmp);\n+        base_op = tmp;\n+        offset = 0;\n+      }\n+\n+      LIR_Address* a = new LIR_Address(base_op,\n+                                       index,\n+                                       offset,\n+                                       T_BYTE);\n+      BasicTypeList signature(3);\n+      signature.append(T_INT);\n+      signature.append(T_ADDRESS);\n+      signature.append(T_INT);\n+      CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+      const LIR_Opr result_reg = result_register_for(x->type());\n+\n+      LIR_Opr addr = new_pointer_register();\n+      __ leal(LIR_OprFact::address(a), addr);\n+\n+      crc.load_item_force(cc->at(0));\n+      __ move(addr, cc->at(1));\n+      len.load_item_force(cc->at(2));\n+\n+      __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc->args());\n+      __ move(result_reg, result);\n+\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1325,1 +1325,1 @@\n-  \/\/ Bizzarely, the counts are passed in bytes, regardless of whether they\n+  \/\/ Bizarrely, the counts are passed in bytes, regardless of whether they\n@@ -2329,1 +2329,2 @@\n-                                        VectorRegister vr1, VectorRegister vr2, VectorRegister vrs, bool islatin, Label &DONE) {\n+                                        VectorRegister vr1, VectorRegister vr2, VectorRegister vrs, bool islatin, Label &DONE,\n+                                        Assembler::LMUL lmul) {\n@@ -2334,1 +2335,1 @@\n-  vsetvli(tmp1, cnt, sew, Assembler::m2);\n+  vsetvli(tmp1, cnt, sew, lmul);\n@@ -2360,1 +2361,1 @@\n-  element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, true, DONE);\n+  element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, true, DONE, Assembler::m2);\n@@ -2413,1 +2414,1 @@\n-  element_compare(a1, a2, result, cnt1, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE);\n+  element_compare(a1, a2, result, cnt1, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE, Assembler::m2);\n@@ -2448,0 +2449,3 @@\n+  \/\/ We focus on the optimization of small sized string.\n+  \/\/ Please check below document for string size distribution statistics.\n+  \/\/ https:\/\/cr.openjdk.org\/~shade\/density\/string-density-report.pdf\n@@ -2449,1 +2453,8 @@\n-    element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v2, v4, v2, encLL, DIFFERENCE);\n+    \/\/ Below construction of v regs and lmul is based on test on 2 different boards,\n+    \/\/ vlen == 128 and vlen == 256 respectively.\n+    if (!encLL && MaxVectorSize == 16) { \/\/ UU\n+      element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v4, v8, v4, encLL, DIFFERENCE, Assembler::m4);\n+    } else { \/\/ UU + MaxVectorSize or LL\n+      element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v2, v4, v2, encLL, DIFFERENCE, Assembler::m2);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-                       bool is_latin, Label& DONE);\n+                       bool is_latin, Label& DONE, Assembler::LMUL lmul);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1470,2 +1470,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n@@ -1509,2 +1508,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -1431,0 +1431,168 @@\n+static const int64_t right_32_bits = right_n_bits(32);\n+static const int64_t right_8_bits = right_n_bits(8);\n+\n+\/**\n+ * Emits code to update CRC-32 with a byte value according to constants in table\n+ *\n+ * @param [in,out]crc   Register containing the crc.\n+ * @param [in]val       Register containing the byte to fold into the CRC.\n+ * @param [in]table     Register containing the table of crc constants.\n+ *\n+ * uint32_t crc;\n+ * val = crc_table[(val ^ crc) & 0xFF];\n+ * crc = val ^ (crc >> 8);\n+ *\n+ *\/\n+void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {\n+  assert_different_registers(crc, val, table);\n+\n+  xorr(val, val, crc);\n+  andi(val, val, right_8_bits);\n+  shadd(val, val, table, val, 2);\n+  lwu(val, Address(val));\n+  srli(crc, crc, 8);\n+  xorr(crc, val, crc);\n+}\n+\n+\/**\n+ * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3\n+ *\n+ * @param [in,out]crc   Register containing the crc.\n+ * @param [in]v         Register containing the 32-bit to fold into the CRC.\n+ * @param [in]table0    Register containing table 0 of crc constants.\n+ * @param [in]table1    Register containing table 1 of crc constants.\n+ * @param [in]table2    Register containing table 2 of crc constants.\n+ * @param [in]table3    Register containing table 3 of crc constants.\n+ *\n+ * uint32_t crc;\n+ *   v = crc ^ v\n+ *   crc = table3[v&0xff]^table2[(v>>8)&0xff]^table1[(v>>16)&0xff]^table0[v>>24]\n+ *\n+ *\/\n+void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2, Register tmp3,\n+        Register table0, Register table1, Register table2, Register table3, bool upper) {\n+  assert_different_registers(crc, v, tmp1, tmp2, tmp3, table0, table1, table2, table3);\n+\n+  if (upper)\n+    srli(v, v, 32);\n+  xorr(v, v, crc);\n+\n+  andi(tmp1, v, right_8_bits);\n+  shadd(tmp1, tmp1, table3, tmp2, 2);\n+  lwu(crc, Address(tmp1));\n+\n+  slli(tmp1, v, 16);\n+  slli(tmp3, v, 8);\n+\n+  srliw(tmp1, tmp1, 24);\n+  srliw(tmp3, tmp3, 24);\n+\n+  shadd(tmp1, tmp1, table2, tmp1, 2);\n+  lwu(tmp2, Address(tmp1));\n+\n+  shadd(tmp3, tmp3, table1, tmp3, 2);\n+  xorr(crc, crc, tmp2);\n+\n+  lwu(tmp2, Address(tmp3));\n+  \/\/ It is more optimal to use 'srli' instead of 'srliw' for case when it is not necessary to clean upper bits\n+  if (upper)\n+    srli(tmp1, v, 24);\n+  else\n+    srliw(tmp1, v, 24);\n+\n+  \/\/ no need to clear bits other than lowest two\n+  shadd(tmp1, tmp1, table0, tmp1, 2);\n+  xorr(crc, crc, tmp2);\n+  lwu(tmp2, Address(tmp1));\n+  xorr(crc, crc, tmp2);\n+}\n+\n+\/**\n+ * @param crc   register containing existing CRC (32-bit)\n+ * @param buf   register pointing to input byte buffer (byte*)\n+ * @param len   register containing number of bytes\n+ * @param table register that will contain address of CRC table\n+ * @param tmp   scratch registers\n+ *\/\n+void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n+  assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+  Label L_by16_loop, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+\n+  const int64_t unroll = 16;\n+  const int64_t unroll_words = unroll*wordSize;\n+  mv(tmp5, right_32_bits);\n+  subw(len, len, unroll_words);\n+  andn(crc, tmp5, crc);\n+\n+  const ExternalAddress table_addr = StubRoutines::crc_table_addr();\n+  la(table0, table_addr);\n+  add(table1, table0, 1*256*sizeof(juint), tmp1);\n+  add(table2, table0, 2*256*sizeof(juint), tmp1);\n+  add(table3, table2, 1*256*sizeof(juint), tmp1);\n+\n+  bge(len, zr, L_unroll_loop_entry);\n+  addiw(len, len, unroll_words-4);\n+  bge(len, zr, L_by4_loop);\n+  addiw(len, len, 4);\n+  bgt(len, zr, L_by1_loop);\n+  j(L_exit);\n+\n+  align(CodeEntryAlignment);\n+  bind(L_unroll_loop_entry);\n+    const Register buf_end = tmp3;\n+    add(buf_end, buf, len); \/\/ buf_end will be used as endpoint for loop below\n+    andi(len, len, unroll_words-1); \/\/ len = (len % unroll_words)\n+    sub(len, len, unroll_words); \/\/ Length after all iterations\n+  bind(L_unroll_loop);\n+    for (int i = 0; i < unroll; i++) {\n+      ld(tmp1, Address(buf, i*wordSize));\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, false);\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, true);\n+    }\n+\n+    addi(buf, buf, unroll_words);\n+    ble(buf, buf_end, L_unroll_loop);\n+    addiw(len, len, unroll_words-4);\n+    bge(len, zr, L_by4_loop);\n+    addiw(len, len, 4);\n+    bgt(len, zr, L_by1_loop);\n+    j(L_exit);\n+\n+  bind(L_by4_loop);\n+    lwu(tmp1, Address(buf));\n+    update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, false);\n+    subw(len, len, 4);\n+    addi(buf, buf, 4);\n+    bge(len, zr, L_by4_loop);\n+    addiw(len, len, 4);\n+    ble(len, zr, L_exit);\n+\n+  bind(L_by1_loop);\n+    subw(len, len, 1);\n+    lwu(tmp1, Address(buf));\n+    andi(tmp2, tmp1, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    subw(len, len, 1);\n+    srli(tmp2, tmp1, 8);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    subw(len, len, 1);\n+    srli(tmp2, tmp1, 16);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    srli(tmp2, tmp1, 24);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+\n+  bind(L_exit);\n+    andn(crc, tmp5, crc);\n+}\n+\n@@ -2498,0 +2666,45 @@\n+void MacroAssembler::encode_heap_oop_not_null(Register r) {\n+#ifdef ASSERT\n+  if (CheckCompressedOops) {\n+    Label ok;\n+    bnez(r, ok);\n+    stop(\"null oop passed to encode_heap_oop_not_null\");\n+    bind(ok);\n+  }\n+#endif\n+  verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n+  if (CompressedOops::base() != nullptr) {\n+    sub(r, r, xheapbase);\n+  }\n+  if (CompressedOops::shift() != 0) {\n+    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n+    srli(r, r, LogMinObjAlignmentInBytes);\n+  }\n+}\n+\n+void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n+#ifdef ASSERT\n+  if (CheckCompressedOops) {\n+    Label ok;\n+    bnez(src, ok);\n+    stop(\"null oop passed to encode_heap_oop_not_null2\");\n+    bind(ok);\n+  }\n+#endif\n+  verify_oop_msg(src, \"broken oop in encode_heap_oop_not_null2\");\n+\n+  Register data = src;\n+  if (CompressedOops::base() != nullptr) {\n+    sub(dst, src, xheapbase);\n+    data = dst;\n+  }\n+  if (CompressedOops::shift() != 0) {\n+    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n+    srli(dst, data, LogMinObjAlignmentInBytes);\n+    data = dst;\n+  }\n+  if (data == src) {\n+    mv(dst, src);\n+  }\n+}\n+\n@@ -3802,1 +4015,1 @@\n-    bge(r_array_length, r_array_index, skip);\n+    blt(r_array_index, r_array_length, skip);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":215,"deletions":2,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -209,0 +209,2 @@\n+  void encode_heap_oop_not_null(Register r);\n+  void encode_heap_oop_not_null(Register dst, Register src);\n@@ -1291,0 +1293,9 @@\n+  \/\/ CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.\n+  void kernel_crc32(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6);\n+  void update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2, Register tmp3,\n+        Register table0, Register table1, Register table2, Register table3,\n+        bool upper);\n+  void update_byte_crc32(Register crc, Register val, Register table);\n+\n@@ -1320,0 +1331,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-\/\/ Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -8407,0 +8407,1 @@\n+  predicate(n->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);\n@@ -8418,0 +8419,11 @@\n+instruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) %{\n+  predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n+  match(Set dst (EncodeP src));\n+  ins_cost(ALU_COST);\n+  format %{ \"encode_heap_oop_not_null $dst, $src\\t#@encodeHeapOop_not_null\" %}\n+  ins_encode %{\n+    __ encode_heap_oop_not_null($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3608,0 +3608,22 @@\n+instruct vstring_compareU_128b(iRegP_R11 str1, iRegI_R12 cnt1, iRegP_R13 str2, iRegI_R14 cnt2,\n+                          iRegI_R10 result, vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7,\n+                          vReg_V8 v8, vReg_V9 v9, vReg_V10 v10, vReg_V11 v11,\n+                          iRegP_R28 tmp1, iRegL_R29 tmp2)\n+%{\n+  predicate(UseRVV && ((StrCompNode *)n)->encoding() == StrIntrinsicNode::UU &&\n+            MaxVectorSize == 16);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(KILL tmp1, KILL tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2,\n+        TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v8, TEMP v9, TEMP v10, TEMP v11);\n+\n+  format %{ \"String Compare $str1, $cnt1, $str2, $cnt2 -> $result\\t#@string_compareU\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare_v($str1$$Register, $str2$$Register,\n+                        $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                        $tmp1$$Register, $tmp2$$Register,\n+                        StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -3612,1 +3634,2 @@\n-  predicate(UseRVV && ((StrCompNode *)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(UseRVV && ((StrCompNode *)n)->encoding() == StrIntrinsicNode::UU &&\n+            MaxVectorSize > 16);\n@@ -3615,1 +3638,1 @@\n-         TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n+        TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n@@ -3627,0 +3650,1 @@\n+\n@@ -3634,1 +3658,1 @@\n-         TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n+        TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1641,8 +1641,2 @@\n-  {\n-    ExternalAddress target((address)&DTraceMethodProbes);\n-    __ relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      __ la(t0, target.target(), offset);\n-      __ lbu(t0, Address(t0, offset));\n-    });\n-    __ bnez(t0, dtrace_method_entry);\n+  if (DTraceMethodProbes) {\n+    __ j(dtrace_method_entry);\n@@ -1864,8 +1858,2 @@\n-  {\n-    ExternalAddress target((address)&DTraceMethodProbes);\n-    __ relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      __ la(t0, target.target(), offset);\n-      __ lbu(t0, Address(t0, offset));\n-    });\n-    __ bnez(t0, dtrace_method_exit);\n+  if (DTraceMethodProbes) {\n+    __ j(dtrace_method_exit);\n@@ -2012,16 +2000,17 @@\n-  {\n-    __ block_comment(\"dtrace entry {\");\n-    __ bind(dtrace_method_entry);\n-\n-    \/\/ We have all of the arguments setup at this point. We must not touch any register\n-    \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n-\n-    save_args(masm, total_c_args, c_arg, out_regs);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-      CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n-      xthread, c_rarg1);\n-    restore_args(masm, total_c_args, c_arg, out_regs);\n-    __ j(dtrace_method_entry_done);\n-    __ block_comment(\"} dtrace entry\");\n-  }\n+  if (DTraceMethodProbes) {\n+    {\n+      __ block_comment(\"dtrace entry {\");\n+      __ bind(dtrace_method_entry);\n+\n+      \/\/ We have all of the arguments setup at this point. We must not touch any register\n+      \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n+\n+      save_args(masm, total_c_args, c_arg, out_regs);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+        CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n+        xthread, c_rarg1);\n+      restore_args(masm, total_c_args, c_arg, out_regs);\n+      __ j(dtrace_method_entry_done);\n+      __ block_comment(\"} dtrace entry\");\n+    }\n@@ -2029,11 +2018,12 @@\n-  {\n-    __ block_comment(\"dtrace exit {\");\n-    __ bind(dtrace_method_exit);\n-    save_native_result(masm, ret_type, stack_slots);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-         CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n-         xthread, c_rarg1);\n-    restore_native_result(masm, ret_type, stack_slots);\n-    __ j(dtrace_method_exit_done);\n-    __ block_comment(\"} dtrace exit\");\n+    {\n+      __ block_comment(\"dtrace exit {\");\n+      __ bind(dtrace_method_exit);\n+      save_native_result(masm, ret_type, stack_slots);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n+           xthread, c_rarg1);\n+      restore_native_result(masm, ret_type, stack_slots);\n+      __ j(dtrace_method_exit_done);\n+      __ block_comment(\"} dtrace exit\");\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":33,"deletions":43,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -5316,0 +5316,46 @@\n+  \/**\n+   *  Arguments:\n+   *\n+   * Inputs:\n+   *   c_rarg0   - int crc\n+   *   c_rarg1   - byte* buf\n+   *   c_rarg2   - int length\n+   *\n+   * Output:\n+   *   c_rarg0   - int crc result\n+   *\/\n+  address generate_updateBytesCRC32() {\n+    assert(UseCRC32Intrinsics, \"what are we doing here?\");\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+\n+    address start = __ pc();\n+\n+    const Register crc    = c_rarg0;  \/\/ crc\n+    const Register buf    = c_rarg1;  \/\/ source java byte array address\n+    const Register len    = c_rarg2;  \/\/ length\n+    const Register table0 = c_rarg3;  \/\/ crc_table address\n+    const Register table1 = c_rarg4;\n+    const Register table2 = c_rarg5;\n+    const Register table3 = c_rarg6;\n+\n+    const Register tmp1 = c_rarg7;\n+    const Register tmp2 = t2;\n+    const Register tmp3 = x28; \/\/ t3\n+    const Register tmp4 = x29; \/\/ t4\n+    const Register tmp5 = x30; \/\/ t5\n+    const Register tmp6 = x31; \/\/ t6\n+\n+    BLOCK_COMMENT(\"Entry:\");\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    __ kernel_crc32(crc, buf, len, table0, table1, table2,\n+                    table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -5562,0 +5608,6 @@\n+\n+    if (UseCRC32Intrinsics) {\n+      \/\/ set table address before stub generation which use it\n+      StubRoutines::_crc_table_adr = (address)StubRoutines::riscv::_crc_table;\n+      StubRoutines::_updateBytesCRC32 = generate_updateBytesCRC32();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -58,0 +58,222 @@\n+\n+\/**\n+ *  crc_table[] from jdk\/src\/java.base\/share\/native\/libzip\/zlib\/crc32.h\n+ *\/\n+ATTRIBUTE_ALIGNED(4096) juint StubRoutines::riscv::_crc_table[] =\n+{\n+    \/\/ Table 0\n+    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,\n+    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,\n+    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,\n+    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,\n+    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,\n+    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,\n+    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,\n+    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,\n+    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,\n+    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,\n+    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,\n+    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,\n+    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,\n+    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,\n+    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,\n+    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,\n+    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,\n+    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,\n+    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,\n+    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,\n+    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,\n+    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,\n+    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,\n+    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,\n+    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,\n+    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,\n+    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,\n+    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,\n+    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,\n+    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,\n+    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,\n+    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,\n+    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,\n+    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,\n+    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,\n+    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,\n+    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,\n+    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,\n+    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,\n+    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,\n+    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,\n+    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,\n+    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,\n+    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,\n+    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,\n+    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,\n+    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,\n+    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,\n+    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,\n+    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,\n+    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,\n+    0x2d02ef8dUL,\n+\n+    \/\/ Table 1\n+    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,\n+    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,\n+    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,\n+    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,\n+    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,\n+    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,\n+    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,\n+    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,\n+    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,\n+    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,\n+    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,\n+    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,\n+    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,\n+    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,\n+    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,\n+    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,\n+    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,\n+    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,\n+    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,\n+    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,\n+    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,\n+    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,\n+    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,\n+    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,\n+    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,\n+    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,\n+    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,\n+    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,\n+    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,\n+    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,\n+    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,\n+    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,\n+    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,\n+    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,\n+    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,\n+    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,\n+    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,\n+    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,\n+    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,\n+    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,\n+    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,\n+    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,\n+    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,\n+    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,\n+    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,\n+    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,\n+    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,\n+    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,\n+    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,\n+    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,\n+    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,\n+    0x9324fd72UL,\n+\n+    \/\/ Table 2\n+    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,\n+    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,\n+    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,\n+    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,\n+    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,\n+    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,\n+    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,\n+    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,\n+    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,\n+    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,\n+    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,\n+    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,\n+    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,\n+    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,\n+    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,\n+    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,\n+    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,\n+    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,\n+    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,\n+    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,\n+    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,\n+    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,\n+    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,\n+    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,\n+    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,\n+    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,\n+    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,\n+    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,\n+    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,\n+    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,\n+    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,\n+    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,\n+    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,\n+    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,\n+    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,\n+    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,\n+    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,\n+    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,\n+    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,\n+    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,\n+    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,\n+    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,\n+    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,\n+    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,\n+    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,\n+    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,\n+    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,\n+    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,\n+    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,\n+    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,\n+    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,\n+    0xbe9834edUL,\n+\n+    \/\/ Table 3\n+    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,\n+    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,\n+    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,\n+    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,\n+    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,\n+    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,\n+    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,\n+    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,\n+    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,\n+    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,\n+    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,\n+    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,\n+    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,\n+    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,\n+    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,\n+    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,\n+    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,\n+    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,\n+    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,\n+    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,\n+    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,\n+    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,\n+    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,\n+    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,\n+    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,\n+    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,\n+    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,\n+    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,\n+    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,\n+    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,\n+    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,\n+    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,\n+    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,\n+    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,\n+    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,\n+    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,\n+    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,\n+    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,\n+    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,\n+    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,\n+    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,\n+    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,\n+    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,\n+    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,\n+    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,\n+    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,\n+    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,\n+    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,\n+    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,\n+    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,\n+    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,\n+    0xde0506f1UL,\n+};\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":222,"deletions":0,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+\n+private:\n+  static juint    _crc_table[];\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3595,2 +3595,1 @@\n-    {\n-      SkipIfEqual skip(_masm, &DTraceAllocProbes, false);\n+    if (DTraceAllocProbes) {\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,2 +134,8 @@\n-  if (UseCRC32Intrinsics) {\n-    warning(\"CRC32 intrinsics are not available on this CPU.\");\n+  if (UseZba) {\n+    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n+    }\n+  } else {\n+    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      warning(\"CRC32 intrinsic requires Zba instructions (not available on this CPU)\");\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  \/\/ Load object header.\n-  z_lg(Rmark, Address(Roop, hdr_offset));\n-\n@@ -88,0 +85,4 @@\n+\n+    \/\/ Load object header.\n+    z_lg(Rmark, Address(Roop, hdr_offset));\n+\n@@ -144,6 +145,1 @@\n-    const Register tmp = Z_R1_scratch;\n-    z_lg(Rmark, Address(Roop, hdr_offset));\n-    z_lgr(tmp, Rmark);\n-    z_nill(tmp, markWord::monitor_value);\n-    branch_optimized(Assembler::bcondNotZero, slow_case);\n-    lightweight_unlock(Roop, Rmark, tmp, slow_case);\n+    lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -36,0 +36,9 @@\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_lock_lightweight_object(obj, temp1, temp2);\n+}\n+\n+\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_unlock_lightweight_object(obj, temp1, temp2);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -32,0 +32,4 @@\n+  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in s390.ad file.\n+  void fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n+  void fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1008,3 +1008,0 @@\n-  \/\/ Load markWord from object into header.\n-  z_lg(header, hdr_offset, object);\n-\n@@ -1018,1 +1015,1 @@\n-    lightweight_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+    lightweight_lock(object, header, tmp, slow_case);\n@@ -1021,0 +1018,3 @@\n+    \/\/ Load markWord from object into header.\n+    z_lg(header, hdr_offset, object);\n+\n@@ -1156,18 +1156,0 @@\n-    \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-    \/\/ must handle it.\n-\n-    Register tmp = current_header;\n-\n-    \/\/ First check for lock-stack underflow.\n-    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondNotHigh, slow_case);\n-\n-    \/\/ Then check if the top of the lock-stack matches the unlocked object.\n-    z_aghi(tmp, -oopSize);\n-    z_lg(tmp, Address(Z_thread, tmp));\n-    compare64_and_branch(tmp, object, Assembler::bcondNotEqual, slow_case);\n-\n-    z_lg(header, Address(object, hdr_offset));\n-    z_lgr(tmp, header);\n-    z_nill(tmp, markWord::monitor_value);\n-    z_brne(slow_case);\n@@ -1175,1 +1157,1 @@\n-    lightweight_unlock(object, header, tmp, slow_case);\n+    lightweight_unlock(object, header, current_header, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3193,0 +3193,1 @@\n+\/\/ \"The box\" is the space on the stack where we copy the object mark.\n@@ -3194,0 +3195,4 @@\n+\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n+  assert_different_registers(oop, box, temp1, temp2);\n+\n@@ -3195,2 +3200,3 @@\n-  Register currentHeader = temp1;\n-  Register temp = temp2;\n+  Register currentHeader   = temp1;\n+  Register temp            = temp2;\n+\n@@ -3201,2 +3207,0 @@\n-  assert_different_registers(temp1, temp2, oop, box);\n-\n@@ -3210,2 +3214,4 @@\n-    testbit(Address(temp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n-    z_btrue(done);\n+    z_l(temp, Address(temp, Klass::access_flags_offset()));\n+    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n+    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_brne(done);\n@@ -3225,1 +3231,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -3254,4 +3261,0 @@\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-    lightweight_lock(oop, displacedHeader, temp, done);\n@@ -3273,4 +3276,3 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Store a non-null value into the box.\n-    z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  }\n+\n+  \/\/ Store a non-null value into the box.\n+  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n@@ -3298,0 +3300,4 @@\n+\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n+  assert_different_registers(oop, box, temp1, temp2);\n+\n@@ -3299,2 +3305,2 @@\n-  Register currentHeader = temp2;\n-  Register temp = temp1;\n+  Register currentHeader   = temp2;\n+  Register temp            = temp1;\n@@ -3304,2 +3310,0 @@\n-  assert_different_registers(temp1, temp2, oop, box);\n-\n@@ -3329,1 +3333,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -3336,5 +3341,0 @@\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n-    lightweight_unlock(oop, currentHeader, displacedHeader, done);\n-    z_bru(done);\n@@ -5708,3 +5708,0 @@\n-\/\/ Branches to slow upon failure to lock the object.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5712,1 +5709,1 @@\n-\/\/  - hdr: the header, already loaded from obj, contents destroyed.\n+\/\/  - temp1, temp2: temporary registers, contents destroyed.\n@@ -5714,1 +5711,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register temp, Label& slow_case) {\n+void MacroAssembler::lightweight_lock(Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -5717,1 +5714,12 @@\n-  assert_different_registers(obj, hdr, temp);\n+  assert_different_registers(obj, temp1, temp2);\n+\n+  Label push;\n+  const Register top           = temp1;\n+  const Register mark          = temp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  \/\/ Preload the markWord. It is important that this is the first\n+  \/\/ instruction emitted as it is part of C1's null check semantics.\n+  z_lg(mark, Address(obj, mark_offset));\n+\n@@ -5720,1 +5728,1 @@\n-  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n@@ -5722,1 +5730,1 @@\n-  compareU32_and_branch(temp, (unsigned)LockStack::end_offset()-1, bcondHigh, slow_case);\n+  compareU32_and_branch(top, (unsigned)LockStack::end_offset(), bcondNotLow, slow);\n@@ -5724,3 +5732,2 @@\n-  \/\/ attempting a lightweight_lock\n-  \/\/ Load (object->mark() | 1) into hdr\n-  z_oill(hdr, markWord::unlocked_value);\n+  \/\/ The underflow check is elided. The recursive check will always fail\n+  \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n@@ -5728,1 +5735,4 @@\n-  z_lgr(temp, hdr);\n+  \/\/ Check for recursion:\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  z_bre(push);\n@@ -5730,2 +5740,3 @@\n-  \/\/ Clear lock-bits from hdr (locked state)\n-  z_xilf(temp, markWord::unlocked_value);\n+  \/\/ Check header for monitor (0b10).\n+  z_tmll(mark, markWord::monitor_value);\n+  branch_optimized(bcondNotAllZero, slow);\n@@ -5733,2 +5744,9 @@\n-  z_csg(hdr, temp, oopDesc::mark_offset_in_bytes(), obj);\n-  branch_optimized(Assembler::bcondNotEqual, slow_case);\n+  { \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+    const Register locked_obj = top;\n+    z_oill(mark, markWord::unlocked_value);\n+    z_lgr(locked_obj, mark);\n+    \/\/ Clear lock-bits from locked_obj (locked state)\n+    z_xilf(locked_obj, markWord::unlocked_value);\n+    z_csg(mark, locked_obj, mark_offset, obj);\n+    branch_optimized(Assembler::bcondNotEqual, slow);\n+  }\n@@ -5736,5 +5754,1 @@\n-  \/\/ After successful lock, push object on lock-stack\n-  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-  z_stg(obj, Address(Z_thread, temp));\n-  z_ahi(temp, oopSize);\n-  z_st(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  bind(push);\n@@ -5742,2 +5756,4 @@\n-  \/\/ as locking was successful, set CC to EQ\n-  z_cr(temp, temp);\n+  \/\/ After successful lock, push object on lock-stack\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  z_stg(obj, Address(Z_thread, top));\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n@@ -5747,3 +5763,0 @@\n-\/\/ Branches to slow upon failure.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5751,1 +5764,1 @@\n-\/\/ - hdr: the (pre-loaded) header of the object, will be destroyed\n+\/\/ - temp1, temp2: temporary registers, will be destroyed\n@@ -5753,1 +5766,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -5756,1 +5769,7 @@\n-  assert_different_registers(obj, hdr, tmp);\n+  assert_different_registers(obj, temp1, temp2);\n+\n+  Label unlocked, push_and_slow;\n+  const Register mark          = temp1;\n+  const Register top           = temp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n@@ -5759,9 +5778,0 @@\n-  {\n-    \/\/ Check that hdr is lightweight-locked.\n-    Label hdr_ok;\n-    z_lgr(tmp, hdr);\n-    z_nill(tmp, markWord::lock_mask_in_place);\n-    z_bre(hdr_ok);\n-    stop(\"Header is not lightweight-locked\");\n-    bind(hdr_ok);\n-  }\n@@ -5774,3 +5784,3 @@\n-    Label stack_ok;\n-    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondHigh, stack_ok);\n+    NearLabel stack_ok;\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    compareU32_and_branch(top, (unsigned)LockStack::start_offset(), bcondNotLow, stack_ok);\n@@ -5780,8 +5790,155 @@\n-  {\n-    \/\/ Check if the top of the lock-stack matches the unlocked object.\n-    Label tos_ok;\n-    z_aghi(tmp, -oopSize);\n-    z_lg(tmp, Address(Z_thread, tmp));\n-    compare64_and_branch(tmp, obj, Assembler::bcondEqual, tos_ok);\n-    stop(\"Top of lock-stack does not match the unlocked object\");\n-    bind(tos_ok);\n+#endif \/\/ ASSERT\n+\n+  \/\/ Check if obj is top of lock-stack.\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  branch_optimized(bcondNotEqual, slow);\n+\n+  \/\/ pop object from lock-stack\n+#ifdef ASSERT\n+  const Register temp_top = temp1; \/\/ mark is not yet loaded, but be careful\n+  z_agrk(temp_top, top, Z_thread);\n+  z_xc(0, oopSize-1, temp_top, 0, temp_top);  \/\/ wipe out lock-stack entry\n+#endif \/\/ ASSERT\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, -oopSize);  \/\/ pop object\n+\n+  \/\/ The underflow check is elided. The recursive check will always fail\n+  \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+  \/\/ Check if recursive. (this is a check for the 2nd object on the stack)\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  branch_optimized(bcondEqual, unlocked);\n+\n+  \/\/ Not recursive. Check header for monitor (0b10).\n+  z_lg(mark, Address(obj, mark_offset));\n+  z_tmll(mark, markWord::monitor_value);\n+  z_brnaz(push_and_slow);\n+\n+#ifdef ASSERT\n+  \/\/ Check header not unlocked (0b01).\n+  NearLabel not_unlocked;\n+  z_tmll(mark, markWord::unlocked_value);\n+  z_braz(not_unlocked);\n+  stop(\"lightweight_unlock already unlocked\");\n+  bind(not_unlocked);\n+#endif \/\/ ASSERT\n+\n+  { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+    Register unlocked_obj = top;\n+    z_lgr(unlocked_obj, mark);\n+    z_oill(unlocked_obj, markWord::unlocked_value);\n+    z_csg(mark, unlocked_obj, mark_offset, obj);\n+    branch_optimized(Assembler::bcondEqual, unlocked);\n+  }\n+\n+  bind(push_and_slow);\n+\n+  \/\/ Restore lock-stack and handle the unlock in runtime.\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  DEBUG_ONLY(z_stg(obj, Address(Z_thread, top));)\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+  \/\/ set CC to NE\n+  z_ltgr(obj, obj); \/\/ object shouldn't be null at this point\n+  branch_optimized(bcondAlways, slow);\n+\n+  bind(unlocked);\n+}\n+\n+void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, tmp1, tmp2);\n+\n+  \/\/ Handle inflated monitor.\n+  NearLabel inflated;\n+  \/\/ Finish fast lock successfully. MUST reach to with flag == NE\n+  NearLabel locked;\n+  \/\/ Finish fast lock unsuccessfully. MUST branch to with flag == EQ\n+  NearLabel slow_path;\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp1, obj);\n+    z_l(tmp1, Address(tmp1, Klass::access_flags_offset()));\n+    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n+    z_nilh(tmp1, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_brne(slow_path);\n+  }\n+\n+  const Register mark          = tmp1;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  BLOCK_COMMENT(\"compiler_fast_lightweight_locking {\");\n+  { \/\/ lightweight locking\n+\n+    \/\/ Push lock to the lock stack and finish successfully. MUST reach to with flag == EQ\n+    NearLabel push;\n+\n+    const Register top = tmp2;\n+\n+    \/\/ Check if lock-stack is full.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    compareU32_and_branch(top, (unsigned) LockStack::end_offset() - 1, bcondHigh, slow_path);\n+\n+    \/\/ The underflow check is elided. The recursive check will always fail\n+    \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+    \/\/ Check if recursive.\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_bre(push);\n+\n+    \/\/ Check for monitor (0b10)\n+    z_lg(mark, Address(obj, mark_offset));\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+\n+    \/\/ not inflated\n+\n+    { \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+      assert(mark_offset == 0, \"required to avoid a lea\");\n+      const Register locked_obj = top;\n+      z_oill(mark, markWord::unlocked_value);\n+      z_lgr(locked_obj, mark);\n+      \/\/ Clear lock-bits from locked_obj (locked state)\n+      z_xilf(locked_obj, markWord::unlocked_value);\n+      z_csg(mark, locked_obj, mark_offset, obj);\n+      branch_optimized(Assembler::bcondNotEqual, slow_path);\n+    }\n+\n+    bind(push);\n+\n+    \/\/ After successful lock, push object on lock-stack.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    z_stg(obj, Address(Z_thread, top));\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+\n+    z_cgr(obj, obj); \/\/ set the CC to EQ, as it could be changed by alsi\n+    z_bru(locked);\n+  }\n+  BLOCK_COMMENT(\"} compiler_fast_lightweight_locking\");\n+\n+  BLOCK_COMMENT(\"handle_inflated_monitor_lightweight_locking {\");\n+  { \/\/ Handle inflated monitor.\n+    bind(inflated);\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register tagged_monitor = mark;\n+    const Register zero           = tmp2;\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n+    z_bre(locked);\n+\n+    \/\/ Check if recursive.\n+    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+    z_brne(slow_path);\n+\n+    \/\/ Recursive\n+    z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+    z_cgr(zero, zero);\n+    \/\/ z_bru(locked);\n+    \/\/ Uncomment above line in the future, for now jump address is right next to us.\n@@ -5789,0 +5946,18 @@\n+  BLOCK_COMMENT(\"} handle_inflated_monitor_lightweight_locking\");\n+\n+  bind(locked);\n+\n+#ifdef ASSERT\n+  \/\/ Check that locked label is reached with flag == EQ.\n+  NearLabel flag_correct;\n+  z_bre(flag_correct);\n+  stop(\"CC is not set to EQ, it should be - lock\");\n+#endif \/\/ ASSERT\n+\n+  bind(slow_path);\n+\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  z_brne(flag_correct);\n+  stop(\"CC is not set to NE, it should be - lock\");\n+  bind(flag_correct);\n@@ -5791,4 +5966,5 @@\n-  z_lgr(tmp, hdr);\n-  z_oill(tmp, markWord::unlocked_value);\n-  z_csg(hdr, tmp, oopDesc::mark_offset_in_bytes(), obj);\n-  branch_optimized(Assembler::bcondNotEqual, slow);\n+  \/\/ C2 uses the value of flag (NE vs EQ) to determine the continuation.\n+}\n+\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, tmp1, tmp2);\n@@ -5796,1 +5972,23 @@\n-  \/\/ After successful unlock, pop object from lock-stack\n+  \/\/ Handle inflated monitor.\n+  NearLabel inflated, inflated_load_monitor;\n+  \/\/ Finish fast unlock successfully. MUST reach to with flag == EQ.\n+  NearLabel unlocked;\n+  \/\/ Finish fast unlock unsuccessfully. MUST branch to with flag == NE.\n+  NearLabel slow_path;\n+\n+  const Register mark          = tmp1;\n+  const Register top           = tmp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  BLOCK_COMMENT(\"compiler_fast_lightweight_unlock {\");\n+  { \/\/ Lightweight Unlock\n+\n+    \/\/ Check if obj is top of lock-stack.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    branch_optimized(bcondNotEqual, inflated_load_monitor);\n+\n+    \/\/ Pop lock-stack.\n@@ -5798,4 +5996,3 @@\n-  z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-  z_aghi(tmp, -oopSize);\n-  z_agr(tmp, Z_thread);\n-  z_xc(0, oopSize-1, tmp, 0, tmp);  \/\/ wipe out lock-stack entry\n+    const Register temp_top = tmp1; \/\/ let's not kill top here, we can use for recursive check\n+    z_agrk(temp_top, top, Z_thread);\n+    z_xc(0, oopSize-1, temp_top, 0, temp_top);  \/\/ wipe out lock-stack entry\n@@ -5803,2 +6000,128 @@\n-  z_alsi(in_bytes(JavaThread::lock_stack_top_offset()), Z_thread, -oopSize);  \/\/ pop object\n-  z_cr(tmp, tmp); \/\/ set CC to EQ\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, -oopSize);  \/\/ pop object\n+\n+    \/\/ The underflow check is elided. The recursive check will always fail\n+    \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+    \/\/ Check if recursive.\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_bre(unlocked);\n+\n+    \/\/ Not recursive\n+\n+    \/\/ Check for monitor (0b10).\n+    z_lg(mark, Address(obj, mark_offset));\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+\n+#ifdef ASSERT\n+    \/\/ Check header not unlocked (0b01).\n+    NearLabel not_unlocked;\n+    z_tmll(mark, markWord::unlocked_value);\n+    z_braz(not_unlocked);\n+    stop(\"lightweight_unlock already unlocked\");\n+    bind(not_unlocked);\n+#endif \/\/ ASSERT\n+\n+    { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+      Register unlocked_obj = top;\n+      z_lgr(unlocked_obj, mark);\n+      z_oill(unlocked_obj, markWord::unlocked_value);\n+      z_csg(mark, unlocked_obj, mark_offset, obj);\n+      branch_optimized(Assembler::bcondEqual, unlocked);\n+    }\n+\n+    \/\/ Restore lock-stack and handle the unlock in runtime.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    DEBUG_ONLY(z_stg(obj, Address(Z_thread, top));)\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+    \/\/ set CC to NE\n+    z_ltgr(obj, obj); \/\/ object is not null here\n+    z_bru(slow_path);\n+  }\n+  BLOCK_COMMENT(\"} compiler_fast_lightweight_unlock\");\n+\n+  { \/\/ Handle inflated monitor.\n+\n+    bind(inflated_load_monitor);\n+\n+    z_lg(mark, Address(obj, mark_offset));\n+\n+#ifdef ASSERT\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+    stop(\"Fast Unlock not monitor\");\n+#endif \/\/ ASSERT\n+\n+    bind(inflated);\n+\n+#ifdef ASSERT\n+    NearLabel check_done, loop;\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    bind(loop);\n+    z_aghi(top, -oopSize);\n+    compareU32_and_branch(top, in_bytes(JavaThread::lock_stack_base_offset()),\n+                          bcondLow, check_done);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_brne(loop);\n+    stop(\"Fast Unlock lock on stack\");\n+    bind(check_done);\n+#endif \/\/ ASSERT\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n+\n+    NearLabel not_recursive;\n+    const Register recursions = tmp2;\n+\n+    \/\/ Check if recursive.\n+    load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+\n+    \/\/ Recursive unlock\n+    z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+    z_bru(unlocked);\n+\n+    bind(not_recursive);\n+\n+    NearLabel not_ok;\n+    \/\/ Check if the entry lists are empty.\n+    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    z_brne(not_ok);\n+    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+    z_brne(not_ok);\n+\n+    z_release();\n+    z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+\n+    z_bru(unlocked); \/\/ CC = EQ here\n+\n+    bind(not_ok);\n+\n+    \/\/ The owner may be anonymous, and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+    z_bru(slow_path); \/\/ CC = NE here\n+  }\n+\n+  bind(unlocked);\n+\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with flag == EQ.\n+  NearLabel flag_correct;\n+  z_bre(flag_correct);\n+  stop(\"CC is not set to EQ, it should be - unlock\");\n+#endif \/\/ ASSERT\n+\n+  bind(slow_path);\n+\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  z_brne(flag_correct);\n+  stop(\"CC is not set to NE, it should be - unlock\");\n+  bind(flag_correct);\n+#endif \/\/ ASSERT\n+\n+  \/\/ C2 uses the value of flag (NE vs EQ) to determine the continuation.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":408,"deletions":85,"binary":false,"changes":493,"status":"modified"},{"patch":"@@ -730,2 +730,4 @@\n-  void lightweight_lock(Register obj, Register hdr, Register tmp, Label& slow);\n-  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void lightweight_unlock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n+  void compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9582,0 +9582,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -9592,0 +9593,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -9601,0 +9603,32 @@\n+instruct cmpFastLockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set pcc (FastLock oop box));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_cost(100);\n+  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n+  format %{ \"FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n+  ins_encode %{\n+    __ fast_lock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    \/\/ If locking was successful, cc should indicate 'EQ'.\n+    \/\/ The compiler generates a branch to the runtime call to\n+    \/\/ _complete_monitor_locking_Java for the case where cc is 'NE'.\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct cmpFastUnlockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set pcc (FastUnlock oop box));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_cost(100);\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n+  format %{ \"FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n+  ins_encode %{\n+    __ fast_unlock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    \/\/ If unlocking was successful, cc should indicate 'EQ'.\n+    \/\/ The compiler generates a branch to the runtime call to\n+    \/\/ _complete_monitor_unlocking_Java for the case where cc is 'NE'.\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1714,2 +1714,7 @@\n-    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-    __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+      __ compiler_fast_lock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+    } else {\n+      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+      __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    }\n@@ -1913,2 +1918,7 @@\n-    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-    __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+      __ compiler_fast_unlock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+    } else {\n+      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+      __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3979,2 +3979,1 @@\n-    {\n-      SkipIfEqual skip(_masm, &DTraceAllocProbes, false, Z_ARG5 \/*scratch*\/);\n+    if (DTraceAllocProbes) {\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  constexpr static bool supports_recursive_lightweight_locking() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2222,2 +2222,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n@@ -2267,2 +2266,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1630,2 +1630,1 @@\n-  {\n-    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0, noreg);\n+  if (DTraceMethodProbes) {\n@@ -1875,2 +1874,1 @@\n-  {\n-    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0, noreg);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2473,2 +2473,1 @@\n-  {\n-    SkipIfEqual skip(masm, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n@@ -2716,2 +2715,1 @@\n-  {\n-    SkipIfEqual skip(masm, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4380,0 +4380,7 @@\n+    if (DTraceAllocProbes) {\n+      \/\/ Trigger dtrace event for fastpath\n+      __ push(atos);\n+      __ call_VM_leaf(\n+           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), rax);\n+      __ pop(atos);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,0 @@\n-#ifndef DONT_USE_REGISTER_DEFINES\n@@ -119,1 +118,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/zero\/register_zero.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -99,0 +100,6 @@\n+\/\/ sys\/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+#ifndef MAP_ANON_64K\n+  #define MAP_ANON_64K 0x400\n+#else\n+  STATIC_ASSERT(MAP_ANON_64K == 0x400);\n+#endif\n@@ -220,8 +227,9 @@\n-  size_t pagesize;            \/\/ sysconf _SC_PAGESIZE (4K)\n-  size_t datapsize;           \/\/ default data page size (LDR_CNTRL DATAPSIZE)\n-  size_t shmpsize;            \/\/ default shared memory page size (LDR_CNTRL SHMPSIZE)\n-  size_t pthr_stack_pagesize; \/\/ stack page size of pthread threads\n-  size_t textpsize;           \/\/ default text page size (LDR_CNTRL STACKPSIZE)\n-  bool can_use_64K_pages;     \/\/ True if we can alloc 64K pages dynamically with Sys V shm.\n-  bool can_use_16M_pages;     \/\/ True if we can alloc 16M pages dynamically with Sys V shm.\n-  int error;                  \/\/ Error describing if something went wrong at multipage init.\n+  size_t pagesize;             \/\/ sysconf _SC_PAGESIZE (4K)\n+  size_t datapsize;            \/\/ default data page size (LDR_CNTRL DATAPSIZE)\n+  size_t shmpsize;             \/\/ default shared memory page size (LDR_CNTRL SHMPSIZE)\n+  size_t pthr_stack_pagesize;  \/\/ stack page size of pthread threads\n+  size_t textpsize;            \/\/ default text page size (LDR_CNTRL STACKPSIZE)\n+  bool can_use_64K_pages;      \/\/ True if we can alloc 64K pages dynamically with Sys V shm.\n+  bool can_use_16M_pages;      \/\/ True if we can alloc 16M pages dynamically with Sys V shm.\n+  bool can_use_64K_mmap_pages; \/\/ True if we can alloc 64K pages dynamically with mmap.\n+  int error;                   \/\/ Error describing if something went wrong at multipage init.\n@@ -234,1 +242,1 @@\n-  false, false,\n+  false, false, false,\n@@ -369,6 +377,10 @@\n-    guarantee(shmid != -1, \"shmget failed\");\n-    void* p = ::shmat(shmid, nullptr, 0);\n-    ::shmctl(shmid, IPC_RMID, nullptr);\n-    guarantee(p != (void*) -1, \"shmat failed\");\n-    g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n-    ::shmdt(p);\n+    assert(shmid != -1, \"shmget failed\");\n+    if (shmid != -1) {\n+      void* p = ::shmat(shmid, nullptr, 0);\n+      ::shmctl(shmid, IPC_RMID, nullptr);\n+      assert(p != (void*) -1, \"shmat failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n+        ::shmdt(p);\n+      }\n+    }\n@@ -424,16 +436,9 @@\n-      guarantee0(shmid != -1); \/\/ Should always work.\n-      \/\/ Try to set pagesize.\n-      struct shmid_ds shm_buf = { };\n-      shm_buf.shm_pagesize = pagesize;\n-      if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n-        const int en = errno;\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n-      } else {\n-        \/\/ Attach and double check pageisze.\n-        void* p = ::shmat(shmid, nullptr, 0);\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        guarantee0(p != (void*) -1); \/\/ Should always work.\n-        const size_t real_pagesize = os::Aix::query_pagesize(p);\n-        if (real_pagesize != pagesize) {\n-          log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+      assert(shmid != -1, \"shmget failed\");\n+      if (shmid != -1) {\n+        \/\/ Try to set pagesize.\n+        struct shmid_ds shm_buf = { };\n+        shm_buf.shm_pagesize = pagesize;\n+        if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n+          const int en = errno;\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n@@ -441,1 +446,13 @@\n-          can_use = true;\n+          \/\/ Attach and double check pageisze.\n+          void* p = ::shmat(shmid, nullptr, 0);\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          assert(p != (void*) -1, \"shmat failed\");\n+          if (p != (void*) -1) {\n+            const size_t real_pagesize = os::Aix::query_pagesize(p);\n+            if (real_pagesize != pagesize) {\n+              log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+            } else {\n+              can_use = true;\n+            }\n+            ::shmdt(p);\n+          }\n@@ -443,1 +460,0 @@\n-        ::shmdt(p);\n@@ -453,0 +469,10 @@\n+    \/\/ Can we use mmap with 64K pages? (Should be available with AIX7.3 TL1)\n+    {\n+      void* p = mmap(NULL, 64*K, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n+      assert(p != (void*) -1, \"mmap failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n+        munmap(p, 64*K);\n+      }\n+    }\n+\n@@ -465,0 +491,2 @@\n+  trcVerbose(\"Can use 64K pages with mmap memory: %s\",\n+      (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1136,0 +1164,2 @@\n+  st->print_cr(\"  Can use 64K pages with mmap memory:     %s\",\n+    (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1615,0 +1645,4 @@\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    flags |= MAP_ANON_64K;\n+  }\n+\n@@ -1664,1 +1698,5 @@\n-  vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    vmembk_add(addr, size, 64*K, VMEM_MAPPED);\n+  } else {\n+    vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  }\n@@ -1857,2 +1895,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2045,2 +2083,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2186,3 +2224,3 @@\n-  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically       what we do                      remarks\n-  \/\/ 4K           no                                  4K                              old systems (aix 5.2) or new systems with AME activated\n-  \/\/ 4k           yes                                 64k (treat 4k stacks as 64k)    different loader than java and standard settings\n+  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically(mmap or shm)       what we do                      remarks\n+  \/\/ 4K           no                                               4K                              old systems (aix 5.2) or new systems with AME activated\n+  \/\/ 4k           yes                                              64k (treat 4k stacks as 64k)    different loader than java and standard settings\n@@ -2190,1 +2228,1 @@\n-  \/\/ 64k          yes                                 64k                             new systems and standard java loader (we set datapsize=64k when linking)\n+  \/\/ 64k          yes                                              64k                             new systems and standard java loader (we set datapsize=64k when linking)\n@@ -2197,1 +2235,1 @@\n-    if (g_multipage_support.can_use_64K_pages) {\n+    if (g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2227,1 +2265,1 @@\n-    assert0(g_multipage_support.can_use_64K_pages);\n+    assert0(g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages);\n@@ -2712,0 +2750,4 @@\n+bool os::Aix::supports_64K_mmap_pages() {\n+  return g_multipage_support.can_use_64K_mmap_pages;\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":86,"deletions":44,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  static bool supports_64K_mmap_pages();\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -64,3 +65,9 @@\n-    \/\/ Note: any index in cg_infos will do as the path is the same for\n-    \/\/       all controllers.\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    \/\/ Note: We use the memory for non-cpu non-memory controller look-ups.\n+    \/\/       Perhaps we ought to have separate controllers for all.\n+    CgroupV2Controller mem_other = CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n+                                                      cg_infos[MEMORY_IDX]._cgroup_path,\n+                                                      cg_infos[MEMORY_IDX]._read_only);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(mem_other);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_infos[CPU_IDX]._mount_path,\n+                                                                              cg_infos[CPU_IDX]._cgroup_path,\n+                                                                              cg_infos[CPU_IDX]._read_only));\n@@ -69,1 +76,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu, mem_other);\n@@ -103,1 +110,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory = new CgroupV1MemoryController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -106,1 +113,1 @@\n-        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -109,1 +116,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1CpuController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -112,1 +119,1 @@\n-        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -115,1 +122,1 @@\n-        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -130,1 +137,2 @@\n-                                                  char* root_path) {\n+                                                  char* root_path,\n+                                                  bool read_only) {\n@@ -142,0 +150,1 @@\n+      cg_infos[controller]._read_only = read_only;\n@@ -149,0 +158,1 @@\n+    cg_infos[controller]._read_only = read_only;\n@@ -152,0 +162,56 @@\n+\/*\n+ * Determine whether or not the mount options, which are comma separated,\n+ * contain the 'ro' string.\n+ *\/\n+static bool find_ro_opt(char* mount_opts) {\n+  char* token;\n+  char* mo_ptr = mount_opts;\n+  \/\/ mount options are comma-separated (man proc).\n+  while ((token = strsep(&mo_ptr, \",\")) != NULL) {\n+    if (strcmp(token, \"ro\") == 0) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/*\n+ * Read values of a \/proc\/self\/mountinfo line into variables. For cgroups v1\n+ * super options are needed. On cgroups v2 super options are not used.\n+ *\n+ * The scanning of a single mountinfo line entry is as follows:\n+ *\n+ * 36  35  98:0      \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+ * (1) (2) (3):(4)   (5)   (6)      (7)      (8)   (9) (10)   (11)         (12)\n+ *\n+ * The numbers in parentheses are labels for the descriptions below:\n+ *\n+ *  (1)   mount ID:        matched with '%*d' and discarded\n+ *  (2)   parent ID:       matched with '%*d' and discarded\n+ *  (3)   major:           ---,---> major, minor separated by ':'. matched with '%*d:%*d' and discarded\n+ *  (4)   minor:           ---'\n+ *  (5)   root:            matched with '%s' and captured in 'tmproot'. Must be non-empty.\n+ *  (6)   mount point:     matched with '%s' and captured in 'tmpmount'. Must be non-empty.\n+ *  (7)   mount options:   matched with '%s' and captured in 'mount_opts'. Must be non-empty.\n+ *  (8)   optional fields: ---,---> matched with '%*[^-]-'. Anything not a hyphen, followed by a hyphen\n+ *  (9)   separator:       ---'     and discarded. Note: The discarded match is space characters if there\n+ *                                  are no optionals. Otherwise it includes the optional fields as well.\n+ * (10)   filesystem type: matched with '%s' and captured in 'tmp_fs_type'\n+ * (11)   mount source:    matched with '%*s' and discarded\n+ * (12)   super options:   matched with '%s' and captured in 'tmpcgroups'\n+ *\/\n+static inline bool match_mount_info_line(char* line,\n+                                         char* tmproot,\n+                                         char* tmpmount,\n+                                         char* mount_opts,\n+                                         char* tmp_fs_type,\n+                                         char* tmpcgroups) {\n+ return sscanf(line,\n+               \"%*d %*d %*d:%*d %s %s %s%*[^-]- %s %*s %s\",\n+               tmproot,\n+               tmpmount,\n+               mount_opts,\n+               tmp_fs_type,\n+               tmpcgroups) == 5;\n+}\n+\n@@ -321,0 +387,1 @@\n+    char mount_opts[MAXPATHLEN+1];\n@@ -324,4 +391,13 @@\n-    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n-    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n-    \/\/ block in the hybrid case.\n-    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %*s\", tmproot, tmpmount, tmp_fs_type) == 3) {\n+    \/* Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+     * as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+     * block in the hybrid case.\n+     *\n+     * We collect the read only mount option in the cgroup infos so as to have that\n+     * info ready when determining is_containerized().\n+     *\/\n+    if (is_cgroupsV2 && match_mount_info_line(p,\n+                                              tmproot,\n+                                              tmpmount,\n+                                              mount_opts,\n+                                              tmp_fs_type,\n+                                              tmpcgroups \/* unused *\/)) {\n@@ -332,0 +408,3 @@\n+        \/\/ For unified we only have a single line with cgroup2 fs type.\n+        \/\/ Therefore use that option for all CG info structs.\n+        bool ro_option = find_ro_opt(mount_opts);\n@@ -333,1 +412,1 @@\n-          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot);\n+          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot, ro_option);\n@@ -340,1 +419,2 @@\n-     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids. For each controller\n+     * determine whether or not they show up as mounted read only or not.\n@@ -349,0 +429,1 @@\n+     *\n@@ -350,1 +431,1 @@\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+    if (match_mount_info_line(p, tmproot, tmpmount, mount_opts, tmp_fs_type, tmpcgroups)) {\n@@ -358,1 +439,2 @@\n-          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot, ro_option);\n@@ -362,1 +444,2 @@\n-          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot, ro_option);\n@@ -366,1 +449,2 @@\n-          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot, ro_option);\n@@ -370,1 +454,2 @@\n-          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot, ro_option);\n@@ -374,1 +459,2 @@\n-          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot, ro_option);\n@@ -478,1 +564,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -484,1 +570,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController>* contrl = cpu_controller();\n@@ -492,17 +578,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -525,1 +596,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController>* contrl = memory_controller();\n@@ -532,22 +603,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -718,0 +768,52 @@\n+\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n+}\n+\n+void CgroupSubsystem::print_version_specific_info(outputStream* st) {\n+  julong phys_mem = os::Linux::physical_memory();\n+  memory_controller()->controller()->print_version_specific_info(st, phys_mem);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":167,"deletions":65,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    virtual bool is_read_only() = 0;\n@@ -182,0 +183,1 @@\n+template <class T>\n@@ -184,1 +186,1 @@\n-    CgroupController* _controller;\n+    T* _controller;\n@@ -188,1 +190,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T* cont) {\n@@ -194,1 +196,1 @@\n-    CgroupController* controller() { return _controller; }\n+    T* controller() { return _controller; }\n@@ -197,1 +199,2 @@\n-class CgroupSubsystem: public CHeapObj<mtInternal> {\n+\/\/ Pure virtual class representing version agnostic CPU controllers\n+class CgroupCpuController: public CHeapObj<mtInternal> {\n@@ -199,3 +202,0 @@\n-    jlong memory_limit_in_bytes();\n-    int active_processor_count();\n-\n@@ -205,2 +205,7 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual bool is_read_only() = 0;\n+};\n+\n+\/\/ Pure virtual class representing version agnostic memory controllers\n+class CgroupMemoryController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n@@ -208,3 +213,3 @@\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n@@ -214,0 +219,12 @@\n+    virtual void print_version_specific_info(outputStream* st, julong host_mem) = 0;\n+    virtual bool is_read_only() = 0;\n+};\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual jlong pids_max() = 0;\n+    virtual jlong pids_current() = 0;\n+    virtual bool is_containerized() = 0;\n@@ -217,1 +234,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -219,4 +235,15 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n-\n-    virtual void print_version_specific_info(outputStream* st) = 0;\n+    virtual CachingCgroupController<CgroupMemoryController>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController>* cpu_controller() = 0;\n+\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_and_swap_usage_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st);\n@@ -236,0 +263,1 @@\n+    bool _read_only;            \/\/ whether or not the mount path is mounted read-only\n@@ -246,0 +274,1 @@\n+      _read_only = false;\n@@ -277,1 +306,2 @@\n-                                     char* root_path);\n+                                     char* root_path,\n+                                     bool read_only);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -79,1 +80,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n@@ -84,1 +85,1 @@\n-  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  reader()->set_subsystem_path(cgroup_path);\n@@ -91,1 +92,23 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+static inline\n+void verbose_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n+      } else {\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n+    }\n+  }\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n@@ -93,2 +116,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n-  if (memlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n+  if (memlimit >= phys_mem) {\n@@ -96,2 +119,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -99,3 +121,1 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   \"hierarchical_memory_limit\",\n-                                                                   &hier_memlimit);\n+      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n@@ -106,3 +126,2 @@\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n+      if (hier_memlimit < phys_mem) {\n+        verbose_log(hier_memlimit, phys_mem);\n@@ -111,0 +130,1 @@\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n@@ -112,0 +132,1 @@\n+    verbose_log(memlimit, phys_mem);\n@@ -113,2 +134,2 @@\n-  }\n-  else {\n+  } else {\n+    verbose_log(memlimit, phys_mem);\n@@ -131,2 +152,1 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n@@ -135,2 +155,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -139,2 +158,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -142,3 +160,3 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   matchline,\n-                                                                   &hier_memswlimit);\n+      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n+                                                           matchline,\n+                                                           &hier_memswlimit);\n@@ -161,2 +179,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -171,1 +189,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -189,3 +207,3 @@\n-jlong CgroupV1Subsystem::memory_and_swap_usage_in_bytes() {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes();\n-  jlong memory_limit = CgroupSubsystem::memory_limit_in_bytes();\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -195,1 +213,1 @@\n-      return memory_swap_usage_impl(_memory->controller());\n+      return memory_swap_usage_impl(reader());\n@@ -201,1 +219,1 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n@@ -203,1 +221,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n@@ -207,1 +225,1 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -209,2 +227,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n+  if (memsoftlimit >= phys_mem) {\n@@ -218,0 +236,11 @@\n+bool CgroupV1Subsystem::is_containerized() {\n+  \/\/ containerized iff all required controllers are mounted\n+  \/\/ read-only. See OSContainer::is_containerized() for\n+  \/\/ the full logic.\n+  \/\/\n+  return _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only() &&\n+         _cpuacct->is_read_only() &&\n+         _cpuset->is_read_only();\n+}\n+\n@@ -227,1 +256,1 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n@@ -229,1 +258,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n@@ -241,1 +270,1 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n@@ -243,1 +272,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n@@ -247,1 +276,1 @@\n-jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n@@ -249,3 +278,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                               \"rss\",\n-                                                               &rss);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n@@ -259,1 +286,1 @@\n-jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n@@ -261,3 +288,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                               \"cache\",\n-                                                               &cache);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n@@ -271,1 +296,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n@@ -273,1 +298,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n@@ -277,1 +302,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n@@ -279,2 +304,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+  if (kmem_limit >= phys_mem) {\n@@ -286,1 +311,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n@@ -288,1 +313,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n@@ -292,1 +317,1 @@\n-void CgroupV1Subsystem::print_version_specific_info(outputStream* st) {\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n@@ -294,1 +319,1 @@\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n+  jlong kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n@@ -324,1 +349,1 @@\n-int CgroupV1Subsystem::cpu_quota() {\n+int CgroupV1CpuController::cpu_quota() {\n@@ -326,2 +351,1 @@\n-  bool is_ok = _cpu->controller()->\n-                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", &quota);\n@@ -339,1 +363,1 @@\n-int CgroupV1Subsystem::cpu_period() {\n+int CgroupV1CpuController::cpu_period() {\n@@ -341,1 +365,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n@@ -355,1 +379,1 @@\n-int CgroupV1Subsystem::cpu_shares() {\n+int CgroupV1CpuController::cpu_shares() {\n@@ -357,1 +381,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", shares);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":88,"deletions":64,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -37,2 +37,3 @@\n-    char *_root;\n-    char *_mount_point;\n+    char* _root;\n+    char* _mount_point;\n+    bool _read_only;\n@@ -41,1 +42,1 @@\n-    char *_path;\n+    char* _path;\n@@ -44,4 +45,16 @@\n-    CgroupV1Controller(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = nullptr;\n+    CgroupV1Controller(char *root,\n+                       char *mountpoint,\n+                       bool ro) : _root(os::strdup(root)),\n+                                  _mount_point(os::strdup(mountpoint)),\n+                                  _read_only(ro),\n+                                  _path(nullptr) {\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV1Controller(const CgroupV1Controller& o) : _root(o._root),\n+                                                      _mount_point(o._mount_point),\n+                                                      _read_only(o._read_only),\n+                                                      _path(o._path) {\n+    }\n+    ~CgroupV1Controller() {\n+      \/\/ At least one subsystem controller exists with paths to malloc'd path\n+      \/\/ names\n@@ -50,2 +63,3 @@\n-    virtual void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() { return _path; }\n+    void set_subsystem_path(char *cgroup_path);\n+    char *subsystem_path() override { return _path; }\n+    bool is_read_only() { return _read_only; }\n@@ -54,1 +68,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController final : public CgroupMemoryController {\n@@ -56,0 +70,3 @@\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n@@ -59,0 +76,15 @@\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -66,0 +98,2 @@\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -68,2 +102,3 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n+    CgroupV1MemoryController(const CgroupV1Controller& reader)\n+      : _reader(reader),\n+        _uses_mem_hierarchy(false) {\n@@ -74,1 +109,15 @@\n-class CgroupV1Subsystem: public CgroupSubsystem {\n+class CgroupV1CpuController final : public CgroupCpuController {\n+\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n+  public:\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    void set_subsystem_path(char *cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -77,8 +126,5 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    CgroupV1CpuController(const CgroupV1Controller& reader) : _reader(reader) {\n+    }\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n@@ -86,0 +132,1 @@\n+  public:\n@@ -93,5 +140,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -100,2 +142,1 @@\n-\n-    void print_version_specific_info(outputStream* st);\n+    bool is_containerized();\n@@ -106,2 +147,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n@@ -111,1 +152,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n@@ -113,1 +154,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -117,3 +158,0 @@\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n@@ -122,1 +160,1 @@\n-                      CgroupV1Controller* cpu,\n+                      CgroupV1CpuController* cpu,\n@@ -125,6 +163,6 @@\n-                      CgroupV1MemoryController* memory) {\n-      _cpuset = cpuset;\n-      _cpu = new CachingCgroupController(cpu);\n-      _cpuacct = cpuacct;\n-      _pids = pids;\n-      _memory = new CachingCgroupController(memory);\n+                      CgroupV1MemoryController* memory) :\n+      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+      _cpuset(cpuset),\n+      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n+      _cpuacct(cpuacct),\n+      _pids(pids) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":80,"deletions":42,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,1 +38,1 @@\n-int CgroupV2Subsystem::cpu_shares() {\n+int CgroupV2CpuController::cpu_shares() {\n@@ -39,1 +40,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n@@ -86,1 +87,1 @@\n-int CgroupV2Subsystem::cpu_quota() {\n+int CgroupV2CpuController::cpu_quota() {\n@@ -88,1 +89,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n@@ -97,0 +98,6 @@\n+bool CgroupV2Subsystem::is_containerized() {\n+  return _unified.is_read_only() &&\n+         _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only();\n+}\n+\n@@ -99,1 +106,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -105,1 +112,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -109,1 +116,1 @@\n-int CgroupV2Subsystem::cpu_period() {\n+int CgroupV2CpuController::cpu_period() {\n@@ -111,1 +118,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n@@ -130,1 +137,1 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n@@ -132,1 +139,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", memusage);\n@@ -136,1 +143,1 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -138,1 +145,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n@@ -142,1 +149,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -148,1 +155,1 @@\n-jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n@@ -150,2 +157,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n@@ -159,1 +165,1 @@\n-jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n@@ -161,2 +167,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n@@ -175,1 +180,2 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem,\n+                                                               julong host_swap \/* unused in cg v2 *\/) {\n@@ -177,1 +183,1 @@\n-  bool is_ok = _memory->controller()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n@@ -182,1 +188,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -186,1 +192,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -194,7 +200,6 @@\n-jlong CgroupV2Subsystem::memory_and_swap_usage_in_bytes() {\n-    jlong memory_usage = memory_usage_in_bytes();\n-    if (memory_usage >= 0) {\n-        jlong swap_current = mem_swp_current_val();\n-        return memory_usage + (swap_current >= 0 ? swap_current : 0);\n-    }\n-    return memory_usage; \/\/ not supported or unlimited case\n+\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n+static\n+jlong memory_swap_current_value(CgroupV2Controller* ctrl) {\n+  julong swap_current;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  return (jlong)swap_current;\n@@ -203,4 +208,7 @@\n-jlong CgroupV2Subsystem::mem_swp_limit_val() {\n-  jlong swap_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n-  return swap_limit;\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_usage = memory_usage_in_bytes();\n+  if (memory_usage >= 0) {\n+      jlong swap_current = memory_swap_current_value(reader());\n+      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+  }\n+  return memory_usage; \/\/ not supported or unlimited case\n@@ -209,5 +217,5 @@\n-\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n-jlong CgroupV2Subsystem::mem_swp_current_val() {\n-  julong swap_current;\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n-  return (jlong)swap_current;\n+static\n+jlong memory_limit_value(CgroupV2Controller* ctrl) {\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n@@ -216,1 +224,1 @@\n-\/* memory_limit_in_bytes\n+\/* read_memory_limit_in_bytes\n@@ -224,4 +232,33 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  jlong memory_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.max\", \"Memory Limit\", memory_limit);\n-  return memory_limit;\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  jlong limit = memory_limit_value(reader());\n+  if (log_is_enabled(Trace, os, container)) {\n+    if (limit == -1) {\n+      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+    } else {\n+      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n+  return limit;\n+}\n+\n+static\n+jlong memory_swap_limit_value(CgroupV2Controller* ctrl) {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -230,3 +267,3 @@\n-void CgroupV2Subsystem::print_version_specific_info(outputStream* st) {\n-  jlong swap_current = mem_swp_current_val();\n-  jlong swap_limit = mem_swp_limit_val();\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n+  jlong swap_current = memory_swap_current_value(reader());\n+  jlong swap_limit = memory_swap_limit_value(reader());\n@@ -258,1 +295,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n@@ -272,1 +309,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":86,"deletions":49,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    bool _read_only;\n@@ -42,4 +43,16 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n-      _mount_path = mount_path;\n-      _cgroup_path = os::strdup(cgroup_path);\n-      _path = construct_path(mount_path, cgroup_path);\n+    CgroupV2Controller(char* mount_path,\n+                       char *cgroup_path,\n+                       bool ro) :  _mount_path(os::strdup(mount_path)),\n+                                   _cgroup_path(os::strdup(cgroup_path)),\n+                                   _read_only(ro),\n+                                   _path(construct_path(mount_path, cgroup_path)) {\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV2Controller(const CgroupV2Controller& o) :\n+                                            _mount_path(o._mount_path),\n+                                            _cgroup_path(o._cgroup_path),\n+                                            _read_only(o._read_only),\n+                                            _path(o._path) {\n+    }\n+    ~CgroupV2Controller() {\n+      \/\/ At least one controller exists with references to the paths\n@@ -48,1 +61,39 @@\n-    char *subsystem_path() { return _path; }\n+    char *subsystem_path() override { return _path; }\n+    bool is_read_only() override { return _read_only; }\n+};\n+\n+class CgroupV2CpuController: public CgroupCpuController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2CpuController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n+};\n+\n+class CgroupV2MemoryController final: public CgroupMemoryController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2MemoryController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -54,1 +105,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2Controller _unified;\n@@ -56,2 +107,2 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -59,2 +110,1 @@\n-    jlong mem_swp_limit_val();\n-    jlong mem_swp_current_val();\n+    CgroupV2Controller* unified() { return &_unified; }\n@@ -63,4 +113,6 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n+    CgroupV2Subsystem(CgroupV2MemoryController* memory,\n+                      CgroupV2CpuController* cpu,\n+                      CgroupV2Controller unified) :\n+        _unified(unified),\n+        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n@@ -69,20 +121,8 @@\n-    jlong read_memory_limit_in_bytes();\n-    int cpu_quota();\n-    int cpu_period();\n-    int cpu_shares();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n-\n-    char * cpu_cpuset_cpus();\n-    char * cpu_cpuset_memory_nodes();\n-    jlong pids_max();\n-    jlong pids_current();\n-\n-    void print_version_specific_info(outputStream* st);\n-\n-    const char * container_type() {\n+    char * cpu_cpuset_cpus() override;\n+    char * cpu_cpuset_memory_nodes() override;\n+    jlong pids_max() override;\n+    jlong pids_current() override;\n+\n+    bool is_containerized() override;\n+\n+    const char * container_type() override {\n@@ -91,2 +131,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":76,"deletions":36,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,1 +392,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n@@ -442,1 +442,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n","filename":"src\/hotspot\/os\/linux\/gc\/x\/xPhysicalMemoryBacking_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,1 +394,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n@@ -444,1 +444,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -28,1 +28,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -30,0 +29,3 @@\n+#include \"procMapsParser.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -31,0 +33,2 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n@@ -33,14 +37,33 @@\n-struct ProcMapsInfo {\n-  void* from = 0;\n-  void* to = 0;\n-  char prot[20 + 1];\n-  char offset[20 + 1];\n-  char dev[20 + 1];\n-  char inode[20 + 1];\n-  char filename[1024 + 1];\n-\n-  bool scan_proc_maps_line(const char* line) {\n-    prot[0] = offset[0] = dev[0] = inode[0] = filename[0] = '\\0';\n-    const int items_read = ::sscanf(line, \"%p-%p %20s %20s %20s %20s %1024s\",\n-        &from, &to, prot, offset, dev, inode, filename);\n-    return items_read >= 2; \/\/ need at least from and to\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _vsize;        \/\/ combined virtual size\n+  size_t _rss;          \/\/ combined resident set size\n+  size_t _committed;    \/\/ combined committed size\n+  size_t _shared;       \/\/ combined shared size\n+  size_t _swapped_out;  \/\/ combined amount of swapped-out memory\n+  size_t _hugetlb;      \/\/ combined amount of memory backed by explicit huge pages\n+  size_t _thp;          \/\/ combined amount of memory backed by THPs\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _vsize(0), _rss(0), _committed(0), _shared(0),\n+                     _swapped_out(0), _hugetlb(0), _thp(0) {}\n+  void add_mapping(const ProcSmapsInfo& info) {\n+    _num_mappings++;\n+    _vsize += info.vsize();\n+    _rss += info.rss;\n+    _committed += info.nr ? 0 : info.vsize();\n+    _shared += info.sh ? info.vsize() : 0;\n+    _swapped_out += info.swap;\n+    _hugetlb += info.private_hugetlb + info.shared_hugetlb;\n+    _thp += info.anonhugepages;\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+    st->print_cr(\"             vsize: %zu (\" PROPERFMT \")\", _vsize, PROPERFMTARGS(_vsize));\n+    st->print_cr(\"               rss: %zu (\" PROPERFMT \")\", _rss, PROPERFMTARGS(_rss));\n+    st->print_cr(\"         committed: %zu (\" PROPERFMT \")\", _committed, PROPERFMTARGS(_committed));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out, PROPERFMTARGS(_swapped_out));\n+    st->print_cr(\"         using thp: %zu (\" PROPERFMT \")\", _thp, PROPERFMTARGS(_thp));\n+    st->print_cr(\"           hugetlb: %zu (\" PROPERFMT \")\", _hugetlb, PROPERFMTARGS(_hugetlb));\n@@ -50,2 +73,2 @@\n-class LinuxMappingPrintInformation : public MappingPrintInformation {\n-  const ProcMapsInfo _info;\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n@@ -53,0 +76,3 @@\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n@@ -54,2 +80,46 @@\n-  LinuxMappingPrintInformation(const void* from, const void* to, const ProcMapsInfo* info) :\n-    MappingPrintInformation(from, to), _info(*info) {}\n+  void print_single_mapping(const ProcSmapsInfo& info) const {\n+    outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(PTR_FORMAT \"-\" PTR_FORMAT, p2i(info.from), p2i(info.to));\n+    INDENT_BY(38);\n+    st->print(\"%12zu\", info.vsize());\n+    INDENT_BY(51);\n+    st->print(\"%s\", info.prot);\n+    INDENT_BY(56);\n+    st->print(\"%12zu\", info.rss);\n+    INDENT_BY(69);\n+    st->print(\"%12zu\", info.private_hugetlb);\n+    INDENT_BY(82);\n+    st->print(EXACTFMT, EXACTFMTARGS(info.kernelpagesize));\n+    {\n+      INDENT_BY(87);\n+      int num_printed = 0;\n+#define PRINTIF(cond, s)                                    \\\n+      if (cond) {                                           \\\n+        st->print(\"%s%s\", (num_printed > 0 ? \",\" : \"\"), s); \\\n+        num_printed++;                                      \\\n+      }\n+      PRINTIF(info.sh, \"shrd\");\n+      PRINTIF(!info.nr, \"com\");\n+      PRINTIF(info.swap > 0, \"swap\");\n+      PRINTIF(info.ht, \"huge\");\n+      PRINTIF(info.anonhugepages > 0, \"thp\");\n+      PRINTIF(info.hg, \"thpad\");\n+      PRINTIF(info.nh, \"nothp\");\n+      if (num_printed == 0) {\n+        st->print(\"-\");\n+      }\n+#undef PRINTIF\n+    }\n+    INDENT_BY(104);\n+    if (!_session.print_nmt_info_for_region(info.from, info.to)) {\n+      st->print(\"-\");\n+    }\n+    INDENT_BY(142);\n+    st->print_raw(info.filename[0] == '\\0' ? \"-\" : info.filename);\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n@@ -57,2 +127,21 @@\n-  void print_OS_specific_details(outputStream* st) const override {\n-    st->print(\"%s %s \", _info.prot, _info.offset);\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:            protection\");\n+    st->print_cr(\"rss:             resident set size\");\n+    st->print_cr(\"hugetlb:         size of private hugetlb pages\");\n+    st->print_cr(\"pgsz:            page size\");\n+    st->print_cr(\"notes:           mapping information  (detail mode only)\");\n+    st->print_cr(\"                      shrd: mapping is shared\");\n+    st->print_cr(\"                       com: mapping committed (swap space reserved)\");\n+    st->print_cr(\"                      swap: mapping partly or completely swapped out\");\n+    st->print_cr(\"                       thp: mapping uses THP\");\n+    st->print_cr(\"                     thpad: mapping is THP-madvised\");\n+    st->print_cr(\"                     nothp: mapping is forbidden to use THP\");\n+    st->print_cr(\"                      huge: mapping uses hugetlb pages\");\n+    st->print_cr(\"vm info:         VM information (requires NMT)\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n@@ -61,1 +150,8 @@\n-  const char* filename() const override { return _info.filename; }\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x0000000414000000-0x0000000453000000 123456789012 rw-p 123456789012 123456789012 16g  thp,thpadv       STACK-340754-Monitor-Deflation-Thread \/shared\/tmp.txt\n+    st->print_cr(\"from               to                        vsize prot          rss      hugetlb pgsz notes            info                                  file\");\n+    st->print_cr(\"========================================================================================================================================================================\");\n+  }\n@@ -64,6 +160,3 @@\n-void MemMapPrinter::pd_print_header(outputStream* st) {\n-  st->print_cr(\"size          prot offset  What\");\n-}\n-\n-void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n-  FILE* f = os::fopen(\"\/proc\/self\/maps\", \"r\");\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+  constexpr char filename[] = \"\/proc\/self\/smaps\";\n+  FILE* f = os::fopen(filename, \"r\");\n@@ -71,0 +164,1 @@\n+    session.out()->print_cr(\"Cannot open %s\", filename);\n@@ -73,9 +167,15 @@\n-  constexpr size_t linesize = sizeof(ProcMapsInfo);\n-  char line[linesize];\n-  while (fgets(line, sizeof(line), f) == line) {\n-    line[sizeof(line) - 1] = '\\0';\n-    ProcMapsInfo info;\n-    if (info.scan_proc_maps_line(line)) {\n-      LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n-      closure.do_it(&mapinfo);\n-    }\n+\n+  ProcSmapsPrinter printer(session);\n+  ProcSmapsSummary summary;\n+\n+  outputStream* const st = session.out();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  ProcSmapsInfo info;\n+  ProcSmapsParser parser(f);\n+  while (parser.parse_next(info)) {\n+    printer.print_single_mapping(info);\n+    summary.add_mapping(info);\n@@ -83,0 +183,5 @@\n+  st->cr();\n+\n+  summary.print_on(session);\n+  st->cr();\n+\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":144,"deletions":39,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -61,2 +61,37 @@\n-\n-  _is_containerized = true;\n+  \/*\n+   * In order to avoid a false positive on is_containerized() on\n+   * Linux systems outside a container *and* to ensure compatibility\n+   * with in-container usage, we detemine is_containerized() by two\n+   * steps:\n+   * 1.) Determine if all the cgroup controllers are mounted read only.\n+   *     If yes, is_containerized() == true. Otherwise, do the fallback\n+   *     in 2.)\n+   * 2.) Query for memory and cpu limits. If any limit is set, we set\n+   *     is_containerized() == true.\n+   *\n+   * Step 1.) covers the basic in container use-cases. Step 2.) ensures\n+   * that limits enforced by other means (e.g. systemd slice) are properly\n+   * detected.\n+   *\/\n+  const char *reason;\n+  bool any_mem_cpu_limit_present = false;\n+  bool controllers_read_only = cgroup_subsystem->is_containerized();\n+  if (controllers_read_only) {\n+    \/\/ in-container case\n+    reason = \" because all controllers are mounted read-only (container case)\";\n+  } else {\n+    \/\/ We can be in one of two cases:\n+    \/\/  1.) On a physical Linux system without any limit\n+    \/\/  2.) On a physical Linux system with a limit enforced by other means (like systemd slice)\n+    any_mem_cpu_limit_present = cgroup_subsystem->memory_limit_in_bytes() > 0 ||\n+                                     os::Linux::active_processor_count() != cgroup_subsystem->active_processor_count();\n+    if (any_mem_cpu_limit_present) {\n+      reason = \" because either a cpu or a memory limit is present\";\n+    } else {\n+      reason = \" because no cpu or memory limit is present\";\n+    }\n+  }\n+  _is_containerized = controllers_read_only || any_mem_cpu_limit_present;\n+  log_debug(os, container)(\"OSContainer::init: is_containerized() = %s%s\",\n+                                                            _is_containerized ? \"true\" : \"false\",\n+                                                            reason);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"procMapsParser.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static bool is_lowercase_hex(char c) {\n+  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');\n+}\n+\n+static size_t max_mapping_line_len() {\n+  return 100 + \/\/ everything but the file name\n+         os::vm_page_size() \/\/ the file name (kernel limits \/proc\/pid\/cmdline to one page\n+         ;\n+}\n+\n+ProcSmapsParser::ProcSmapsParser(FILE* f) :\n+  _f(f), _linelen(max_mapping_line_len()), _line(nullptr) {\n+  assert(_f != nullptr, \"Invalid file handle given\");\n+  _line = NEW_C_HEAP_ARRAY(char, max_mapping_line_len(), mtInternal);\n+  _line[0] = '\\0';\n+}\n+\n+ProcSmapsParser::~ProcSmapsParser() {\n+  FREE_C_HEAP_ARRAY(char, _line);\n+}\n+\n+bool ProcSmapsParser::read_line() {\n+  _line[0] = '\\0';\n+  return ::fgets(_line, _linelen, _f) != nullptr;\n+}\n+\n+bool ProcSmapsParser::is_header_line() {\n+  \/\/ e.g. ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\n+  return is_lowercase_hex(_line[0]); \/\/ All non-header lines in \/proc\/pid\/smaps start with upper-case letters.\n+}\n+\n+void ProcSmapsParser::scan_header_line(ProcSmapsInfo& out) {\n+  const int items_read = ::sscanf(_line, \"%p-%p %20s %*s %*s %*s %1024s\",\n+                                  &out.from, &out.to, out.prot, out.filename);\n+  assert(items_read >= 2, \"Expected header_line\");\n+}\n+\n+void ProcSmapsParser::scan_additional_line(ProcSmapsInfo& out) {\n+#define SCAN(key, var) \\\n+ if (::sscanf(_line, key \": %zu kB\", &var) == 1) { \\\n+     var *= K; \\\n+     return; \\\n+ }\n+  SCAN(\"KernelPageSize\", out.kernelpagesize);\n+  SCAN(\"Rss\", out.rss);\n+  SCAN(\"AnonHugePages\", out.anonhugepages);\n+  SCAN(\"Private_Hugetlb\", out.private_hugetlb);\n+  SCAN(\"Shared_Hugetlb\", out.shared_hugetlb);\n+  SCAN(\"Swap\", out.swap);\n+  int i = 0;\n+#undef SCAN\n+  \/\/ scan some flags too\n+  if (strncmp(_line, \"VmFlags:\", 8) == 0) {\n+#define SCAN(flag) { out.flag = (::strstr(_line + 8, \" \" #flag) != nullptr); }\n+    SCAN(rd);\n+    SCAN(wr);\n+    SCAN(ex);\n+    SCAN(nr);\n+    SCAN(sh);\n+    SCAN(hg);\n+    SCAN(ht);\n+    SCAN(nh);\n+#undef SCAN\n+  }\n+}\n+\n+\/\/ Starts or continues parsing. Returns true on success,\n+\/\/ false on EOF or on error.\n+bool ProcSmapsParser::parse_next(ProcSmapsInfo& out) {\n+\n+  \/\/ Information about a single mapping reaches across several lines.\n+  out.reset();\n+\n+  \/\/ Read header line, unless we already read it\n+  if (_line[0] == '\\0') {\n+    if (!read_line()) {\n+      return false;\n+    }\n+  }\n+  assert(is_header_line(), \"Not a header line: \\\"%s\\\".\", _line);\n+  scan_header_line(out);\n+\n+  \/\/ Now read until we encounter the next header line or EOF or an error.\n+  bool ok = false, stop = false;\n+  do {\n+    ok = read_line();\n+    stop = !ok || is_header_line();\n+    if (!stop) {\n+      scan_additional_line(out);\n+    }\n+  } while (!stop);\n+\n+  return ok;\n+}\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.cpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_HPP\n+#define OS_LINUX_PROCMAPSPARSER_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ This header exposes two simple parsers for \/proc\/pid\/maps and\n+\/\/ \/proc\/pid\/smaps.\n+\/\/\n+\/\/ Usage:\n+\/\/\n+\/\/ FILE* f = fopen(...)\n+\/\/ ProcSMapsParser parser(f);\n+\/\/ ProcSMapsInfo info;\n+\/\/ while (parser.parse_next(info)) { ... }\n+\n+struct ProcSmapsInfo {\n+  void* from;\n+  void* to;\n+  char prot[20 + 1];\n+  char filename[1024 + 1];\n+  size_t kernelpagesize;\n+  size_t rss;\n+  size_t private_hugetlb;\n+  size_t shared_hugetlb;\n+  size_t anonhugepages;\n+  size_t swap;\n+  bool rd, wr, ex;\n+  bool sh; \/\/ shared\n+  bool nr; \/\/ no reserve\n+  bool hg; \/\/ thp-advised\n+  bool ht; \/\/ uses hugetlb pages\n+  bool nh; \/\/ thp forbidden\n+\n+  size_t vsize() const {\n+    return from < to ? pointer_delta(to, from, 1) : 0;\n+  }\n+\n+  void reset() {\n+    from = to = nullptr;\n+    prot[0] = filename[0] = '\\0';\n+    kernelpagesize = rss = private_hugetlb = shared_hugetlb = anonhugepages = swap = 0;\n+    rd = wr = ex = sh = nr = hg = ht = nh = false;\n+  }\n+};\n+\n+class ProcSmapsParser {\n+  FILE* _f;\n+  const size_t _linelen;\n+  char* _line;\n+\n+  bool read_line(); \/\/ sets had_error in case of error\n+  bool is_header_line();\n+  void scan_header_line(ProcSmapsInfo& out);\n+  void scan_additional_line(ProcSmapsInfo& out);\n+\n+public:\n+\n+  ProcSmapsParser(FILE* f);\n+  ~ProcSmapsParser();\n+\n+  \/\/ Starts or continues parsing. Returns true on success,\n+  \/\/ false on EOF or on error.\n+  bool parse_next(ProcSmapsInfo& out);\n+};\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n+  print_hex_dump(st, pc - 32, pc + 32, sizeof(char), \/* print_ascii=*\/false);\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1276,1 +1276,1 @@\n-      os::print_hex_dump(&lsh, base, top, unitsize, 32, requested_base);\n+      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/cdsEnumKlass.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+bool CDSEnumKlass::is_enum_obj(oop orig_obj) {\n+  Klass* k = orig_obj->klass();\n+  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n+  return k->is_instance_klass() &&\n+         InstanceKlass::cast(k)->java_super() == vmClasses::Enum_klass();\n+}\n+\n+\/\/ -- Handling of Enum objects\n+\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n+\/\/     enum MyEnum {FOO, BAR}\n+\/\/     MyEnum::<clinint> {\n+\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n+\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n+\/\/     }\n+\/\/\n+\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n+\/\/ ensure the archived value equals (in object address) to the runtime value of\n+\/\/ MyEnum::FOO.\n+\/\/\n+\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n+\/\/ no way of programmatically handling this inside the Java code (as you would handle\n+\/\/ ModuleLayer::EMPTY_LAYER, for example).\n+\/\/\n+\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n+\/\/ HeapShared::initialize_enum_klass() skips the <clinit> method and instead pulls\n+\/\/ the static fields out of the archived heap.\n+void CDSEnumKlass::handle_enum_obj(int level,\n+                                   KlassSubGraphInfo* subgraph_info,\n+                                   oop orig_obj) {\n+  assert(level > 1, \"must never be called at the first (outermost) level\");\n+  assert(is_enum_obj(orig_obj), \"must be\");\n+\n+  InstanceKlass* ik = InstanceKlass::cast(orig_obj->klass());\n+  if (ik->has_archived_enum_objs()) {\n+    return;\n+  }\n+\n+  ik->set_has_archived_enum_objs();\n+  ArchiveBuilder::get_buffered_klass(ik)->set_has_archived_enum_objs();\n+\n+  oop mirror = ik->java_mirror();\n+  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      archive_static_field(level, subgraph_info, ik, mirror, fs);\n+    }\n+  }\n+}\n+\n+void CDSEnumKlass::archive_static_field(int level, KlassSubGraphInfo* subgraph_info,\n+                                        InstanceKlass* ik, oop mirror, JavaFieldStream& fs) {\n+  ResourceMark rm;\n+  fieldDescriptor& fd = fs.field_descriptor();\n+  if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+    guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  }\n+  oop oop_field = mirror->obj_field(fd.offset());\n+  if (oop_field == nullptr) {\n+    guarantee(false, \"static field %s::%s must not be null\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+    guarantee(false, \"static field %s::%s is of the wrong type\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  }\n+  bool success = HeapShared::archive_reachable_objects_from(level, subgraph_info, oop_field);\n+  assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n+  int root_index = HeapShared::append_root(oop_field);\n+  log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \")\",\n+                      root_index, ik->external_name(), fd.name()->as_C_string(),\n+                      p2i((oopDesc*)oop_field));\n+  SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n+}\n+\n+bool CDSEnumKlass::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n+    return false;\n+  }\n+\n+  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n+  assert(info != nullptr, \"sanity\");\n+\n+  if (log_is_enabled(Info, cds, heap)) {\n+    ResourceMark rm;\n+    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n+  }\n+\n+  oop mirror = k->java_mirror();\n+  int i = 0;\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      int root_index = info->enum_klass_static_field_root_index_at(i++);\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n+      mirror->obj_field_put(fd.offset(), HeapShared::get_root(root_index, \/*clear=*\/true));\n+    }\n+  }\n+  return true;\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_CDSENUMKLASS_HPP\n+#define SHARE_CDS_CDSENUMKLASS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class InstanceKlass;\n+class JavaFieldStream;\n+class KlassSubGraphInfo;\n+\n+class CDSEnumKlass: AllStatic {\n+public:\n+  static bool is_enum_obj(oop orig_obj);\n+  static void handle_enum_obj(int level,\n+                              KlassSubGraphInfo* subgraph_info,\n+                              oop orig_obj);\n+  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+\n+private:\n+  static void archive_static_field(int level, KlassSubGraphInfo* subgraph_info,\n+                                   InstanceKlass* ik, oop mirror, JavaFieldStream& fs);\n+};\n+\n+#endif \/\/ SHARE_CDS_CDSENUMKLASS_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -837,0 +837,2 @@\n+    case JVM_CONSTANT_Methodref:\n+    case JVM_CONSTANT_InterfaceMethodref:\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,3 +261,1 @@\n-        if (rfe->is_resolved(Bytecodes::_getstatic) ||\n-            rfe->is_resolved(Bytecodes::_putstatic) ||\n-            rfe->is_resolved(Bytecodes::_getfield) ||\n+        if (rfe->is_resolved(Bytecodes::_getfield) ||\n@@ -270,0 +268,13 @@\n+\n+    Array<ResolvedMethodEntry>* method_entries = cp->cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokevirtual) ||\n+            rme->is_resolved(Bytecodes::_invokespecial) ||\n+            rme->is_resolved(Bytecodes::_invokeinterface)) {\n+          list.at_put(rme->constant_pool_index(), true);\n+          print = true;\n+        }\n+      }\n+    }\n@@ -279,1 +290,3 @@\n-               cp_tag.value() == JVM_CONSTANT_Fieldref, \"sanity\");\n+               cp_tag.value() == JVM_CONSTANT_Fieldref ||\n+               cp_tag.value() == JVM_CONSTANT_Methodref||\n+               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -92,1 +92,3 @@\n-  } else if (cp->tag_at(cp_index).is_field()) {\n+  } else if (cp->tag_at(cp_index).is_field() ||\n+             cp->tag_at(cp_index).is_method() ||\n+             cp->tag_at(cp_index).is_interface_method()) {\n@@ -266,0 +268,8 @@\n+      case Bytecodes::_invokespecial:\n+      case Bytecodes::_invokevirtual:\n+      case Bytecodes::_invokeinterface:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n@@ -304,0 +314,6 @@\n+  case Bytecodes::_invokevirtual:\n+  case Bytecodes::_invokespecial:\n+  case Bytecodes::_invokeinterface:\n+    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n+    break;\n+\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  msg.info(\"Method CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_method_cp_entries, _num_method_cp_entries_archived,\n+           percent_of(_num_method_cp_entries_archived, _num_method_cp_entries),\n+           _num_method_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+  int _num_method_cp_entries;\n+  int _num_method_cp_entries_archived;\n+  int _num_method_cp_entries_reverted;\n@@ -87,0 +90,3 @@\n+    _num_method_cp_entries          = 0;\n+    _num_method_cp_entries_archived = 0;\n+    _num_method_cp_entries_reverted = 0;\n@@ -125,0 +131,6 @@\n+  void record_method_cp_entry(bool archived, bool reverted) {\n+    _num_method_cp_entries ++;\n+    _num_method_cp_entries_archived += archived ? 1 : 0;\n+    _num_method_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/cdsEnumKlass.hpp\"\n@@ -454,89 +455,0 @@\n-\/\/ -- Handling of Enum objects\n-\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n-\/\/     enum MyEnum {FOO, BAR}\n-\/\/     MyEnum::<clinint> {\n-\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n-\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n-\/\/     }\n-\/\/\n-\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n-\/\/ ensure the archived value equals (in object address) to the runtime value of\n-\/\/ MyEnum::FOO.\n-\/\/\n-\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n-\/\/ no way of programmatically handling this inside the Java code (as you would handle\n-\/\/ ModuleLayer::EMPTY_LAYER, for example).\n-\/\/\n-\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n-\/\/ HeapShared::initialize_enum_klass() will skip the <clinit> method and pull\n-\/\/ the static fields out of the archived heap.\n-void HeapShared::check_enum_obj(int level,\n-                                KlassSubGraphInfo* subgraph_info,\n-                                oop orig_obj) {\n-  assert(level > 1, \"must never be called at the first (outermost) level\");\n-  Klass* k = orig_obj->klass();\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n-  if (!k->is_instance_klass()) {\n-    return;\n-  }\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->java_super() == vmClasses::Enum_klass() && !ik->has_archived_enum_objs()) {\n-    ResourceMark rm;\n-    ik->set_has_archived_enum_objs();\n-    buffered_k->set_has_archived_enum_objs();\n-    oop mirror = ik->java_mirror();\n-\n-    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n-      if (fs.access_flags().is_static()) {\n-        fieldDescriptor& fd = fs.field_descriptor();\n-        if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n-          guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        }\n-        oop oop_field = mirror->obj_field(fd.offset());\n-        if (oop_field == nullptr) {\n-          guarantee(false, \"static field %s::%s must not be null\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n-          guarantee(false, \"static field %s::%s is of the wrong type\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        }\n-        bool success = archive_reachable_objects_from(level, subgraph_info, oop_field);\n-        assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n-        int root_index = append_root(oop_field);\n-        log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \")\",\n-                            root_index, ik->external_name(), fd.name()->as_C_string(),\n-                            p2i((oopDesc*)oop_field));\n-        SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ See comments in HeapShared::check_enum_obj()\n-bool HeapShared::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n-  if (!ArchiveHeapLoader::is_in_use()) {\n-    return false;\n-  }\n-\n-  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n-  assert(info != nullptr, \"sanity\");\n-\n-  if (log_is_enabled(Info, cds, heap)) {\n-    ResourceMark rm;\n-    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n-  }\n-\n-  oop mirror = k->java_mirror();\n-  int i = 0;\n-  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static()) {\n-      int root_index = info->enum_klass_static_field_root_index_at(i++);\n-      fieldDescriptor& fd = fs.field_descriptor();\n-      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n-      mirror->obj_field_put(fd.offset(), get_root(root_index, \/*clear=*\/true));\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1244,1 +1156,3 @@\n-  check_enum_obj(level + 1, subgraph_info, orig_obj);\n+  if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n+    CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":90,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -215,3 +215,0 @@\n-  static void check_enum_obj(int level, KlassSubGraphInfo* subgraph_info,\n-                             oop orig_obj);\n-\n@@ -431,1 +428,0 @@\n-  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -515,0 +515,2 @@\n+  guarantee(!CDSConfig::is_using_archive(), \"We should not be using an archive when we dump\");\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -776,11 +776,4 @@\n-    if (UseVtableBasedCHA) {\n-      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n-                                                                              root_m->get_Method(),\n-                                                                              callee_holder->get_Klass(),\n-                                                                              this->get_Method()));\n-    } else {\n-      if (root_m->is_abstract()) {\n-        return nullptr; \/\/ not supported\n-      }\n-      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n-    }\n+    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n+                                                                            root_m->get_Method(),\n+                                                                            callee_holder->get_Klass(),\n+                                                                            this->get_Method()));\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-    _bc_start =_was_wide = 0;\n+    _bc_start = _was_wide = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  vm_exit_during_initialization(error, message);\n+  vm_exit_during_cds_dumping(error, message);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-  Chunk* chunk = _head;\n+  Chunk* chunk = Atomic::load_acquire(&_head);\n@@ -208,1 +208,1 @@\n-    count += chunk->_size;\n+    count += Atomic::load(&chunk->_size);\n@@ -262,1 +262,1 @@\n-  Chunk* chunk = _head;\n+  Chunk* chunk = Atomic::load_acquire(&_head);\n@@ -264,1 +264,1 @@\n-    if (&(chunk->_data[0]) <= oop_handle && oop_handle < &(chunk->_data[chunk->_size])) {\n+    if (&(chunk->_data[0]) <= oop_handle && oop_handle < &(chunk->_data[Atomic::load(&chunk->_size)])) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,3 +244,8 @@\n-\/\/ unloading can remove entries concurrently soon.\n-template <bool keep_alive = true>\n-class ClassLoaderDataGraphIteratorBase : public StackObj {\n+\/\/ unloading can remove entries concurrently.\n+\/\/ This iterator does not keep the CLD alive.\n+\/\/ Any CLD OopHandles (modules, mirrors, resolved refs)\n+\/\/ resolved must be treated as no keepalive. And requires\n+\/\/ that its CLD's holder is kept alive if they escape the\n+\/\/ caller's safepoint or ClassLoaderDataGraph_lock\n+\/\/ critical section.\n+class ClassLoaderDataGraph::ClassLoaderDataGraphIterator : public StackObj {\n@@ -254,6 +259,2 @@\n-  ClassLoaderDataGraphIteratorBase() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n-    if (keep_alive) {\n-      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-    } else {\n-      assert_at_safepoint();\n-    }\n+  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n+    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -269,4 +270,0 @@\n-      if (keep_alive) {\n-        \/\/ Keep cld that is being returned alive.\n-        Handle(_thread, cld->holder());\n-      }\n@@ -281,3 +278,0 @@\n-using ClassLoaderDataGraphIterator = ClassLoaderDataGraphIteratorBase<true \/* keep_alive *\/>;\n-using ClassLoaderDataGraphIteratorNoKeepAlive = ClassLoaderDataGraphIteratorBase<false \/* keep_alive *\/>;\n-\n@@ -291,7 +285,0 @@\n-void ClassLoaderDataGraph::loaded_cld_do_no_keepalive(CLDClosure* cl) {\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n-  while (ClassLoaderData* cld = iter.get_next()) {\n-    cl->do_cld(cld);\n-  }\n-}\n-\n@@ -321,0 +308,10 @@\n+void ClassLoaderDataGraph::modules_do_keepalive(void f(ModuleEntry*)) {\n+  assert_locked_or_safepoint(Module_lock);\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n+    cld->modules_do(f);\n+  }\n+}\n+\n@@ -337,1 +334,1 @@\n-void ClassLoaderDataGraph::loaded_classes_do(KlassClosure* klass_closure) {\n+void ClassLoaderDataGraph::loaded_classes_do_keepalive(KlassClosure* klass_closure) {\n@@ -340,0 +337,2 @@\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n@@ -349,1 +348,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n@@ -357,4 +356,0 @@\n-#define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \\\n-                                while (ClassLoaderData* X = iter.get_next()) \\\n-                                  if (X->dictionary() != nullptr)\n-\n@@ -362,6 +357,9 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    st->print(\"Dictionary for \");\n-    cld->print_value_on(st);\n-    st->cr();\n-    cld->dictionary()->print_on(st);\n-    st->cr();\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      st->print(\"Dictionary for \");\n+      cld->print_value_on(st);\n+      st->cr();\n+      cld->dictionary()->print_on(st);\n+      st->cr();\n+    }\n@@ -372,5 +370,8 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    ResourceMark rm; \/\/ loader_name_and_id\n-    stringStream tempst;\n-    tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n-    cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      ResourceMark rm; \/\/ loader_name_and_id\n+      stringStream tempst;\n+      tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n+      cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+    }\n@@ -553,1 +554,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-  template <bool keep_alive>\n-  friend class ClassLoaderDataGraphIteratorBase;\n@@ -44,0 +42,2 @@\n+  class ClassLoaderDataGraphIterator;\n+\n@@ -74,0 +74,5 @@\n+  \/\/ All the do suffixed functions do not keep the CLD alive. Any CLD OopHandles\n+  \/\/ (modules, mirrors, resolved refs) resolved must be treated as no keepalive.\n+  \/\/ And requires that its CLD's holder is kept alive if they escape the\n+  \/\/ caller's safepoint or ClassLoaderDataGraph_lock critical section.\n+  \/\/ The do_keepalive suffixed functions will keep all CLDs alive.\n@@ -75,1 +80,0 @@\n-  static void loaded_cld_do_no_keepalive(CLDClosure* cl);\n@@ -84,0 +88,1 @@\n+  static void modules_do_keepalive(void f(ModuleEntry*));\n@@ -86,1 +91,1 @@\n-  static void loaded_classes_do(KlassClosure* klass_closure);\n+  static void loaded_classes_do_keepalive(KlassClosure* klass_closure);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  _fold(\"fold\", \"Show loaders of the same name and class as one.\", \"BOOLEAN\", true, \"true\") {\n+  _fold(\"fold\", \"Show loaders of the same name and class as one.\", \"BOOLEAN\", false, \"true\") {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  ClassLoaderDataGraph::loaded_cld_do_no_keepalive(&clsc);\n+  ClassLoaderDataGraph::loaded_cld_do(&clsc);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-\n+  \/\/ Will not keep metadata alive. See ClassLoaderDataGraph::methods_do.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,5 +116,1 @@\n-  if (UseVtableBasedCHA) {\n-    assert_common_4(unique_concrete_method_4, ctxk, uniqm, resolved_klass, resolved_method);\n-  } else {\n-    assert_common_2(unique_concrete_method_2, ctxk, uniqm);\n-  }\n+  assert_common_4(unique_concrete_method_4, ctxk, uniqm, resolved_klass, resolved_method);\n@@ -1477,1 +1473,0 @@\n-    assert(UseVtableBasedCHA, \"required\");\n@@ -1952,1 +1947,0 @@\n-  assert(UseVtableBasedCHA, \"required\");\n@@ -2133,1 +2127,1 @@\n-    if (UseVtableBasedCHA && changes->is_klass_init_change()) {\n+    if (changes->is_klass_init_change()) {\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  ImplicitExceptionTable( ) :  _size(0), _len(0), _data(0) { }\n+  ImplicitExceptionTable( ) :  _size(0), _len(0), _data(nullptr) { }\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,0 +262,12 @@\n+inline uint VtableStubs::unsafe_hash(address entry_point, bool caller_is_c1) {\n+  \/\/ The entrypoint may or may not be a VtableStub. Generate a hash as if it was.\n+  address vtable_stub_addr = entry_point - VtableStub::entry_offset();\n+  assert(CodeCache::contains(vtable_stub_addr), \"assumed to always be the case\");\n+  address vtable_type_addr = vtable_stub_addr + offset_of(VtableStub, _type);\n+  address vtable_index_addr = vtable_stub_addr + offset_of(VtableStub, _index);\n+  bool is_vtable_stub = *vtable_type_addr == static_cast<uint8_t>(VtableStub::Type::vtable_stub);\n+  int vtable_index;\n+  memcpy(&vtable_index, vtable_index_addr, sizeof(vtable_index));\n+  return hash(is_vtable_stub, vtable_index, caller_is_c1);\n+}\n+\n@@ -282,0 +294,4 @@\n+  \/\/ The pc may or may not be the entry point for a VtableStub. Use unsafe_hash\n+  \/\/ to generate the hash that would have been used if it was. The lookup in the\n+  \/\/ _table will only succeed if there is a VtableStub with an entry point at\n+  \/\/ the pc.\n@@ -284,1 +300,1 @@\n-  uint hash = VtableStubs::hash(stub->is_vtable_stub(), stub->index(), stub->caller_is_c1());\n+  uint hash = VtableStubs::unsafe_hash(pc, stub->caller_is_c1());\n@@ -286,2 +302,2 @@\n-  for (s = Atomic::load(&_table[hash]); s != nullptr && s != stub; s = s->next()) {}\n-  return (s == stub) ? s : nullptr;\n+  for (s = Atomic::load(&_table[hash]); s != nullptr && s->entry_point() != pc; s = s->next()) {}\n+  return (s != nullptr && s->entry_point() == pc) ? s : nullptr;\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,1 @@\n+  static inline uint unsafe_hash       (address entry_point, bool caller_is_c1);\n@@ -121,0 +122,6 @@\n+  enum class Type : uint8_t {\n+    itable_stub,\n+    vtable_stub,\n+  };\n+\n+\n@@ -129,1 +136,1 @@\n-  bool           _is_vtable_stub;    \/\/ True if vtable stub, false, is itable stub\n+  Type           _type;              \/\/ Type, either vtable stub or itable stub\n@@ -138,1 +145,1 @@\n-          _is_vtable_stub(is_vtable_stub), _caller_is_c1(caller_is_c1) {}\n+          _type(is_vtable_stub ? Type::vtable_stub : Type::itable_stub), _caller_is_c1(caller_is_c1) {}\n@@ -146,1 +153,1 @@\n-  address code_end() const                       { return code_begin() + VtableStubs::code_size_limit(_is_vtable_stub); }\n+  address code_end() const                       { return code_begin() + VtableStubs::code_size_limit(is_vtable_stub()); }\n@@ -151,1 +158,1 @@\n-    return _index == index && _is_vtable_stub == is_vtable_stub && _caller_is_c1 == caller_is_c1;\n+    return _index == index && this->is_vtable_stub() == is_vtable_stub && _caller_is_c1 == caller_is_c1;\n@@ -177,2 +184,2 @@\n-  bool is_itable_stub()                          { return !_is_vtable_stub; }\n-  bool is_vtable_stub()                          { return  _is_vtable_stub; }\n+  bool is_itable_stub() const                    { return _type == Type::itable_stub; }\n+  bool is_vtable_stub() const                    { return _type == Type::vtable_stub; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -414,1 +414,1 @@\n-    void set(kind_t kind, int offset, int size, const OopMap* map = 0, const OopMap* other = 0) {\n+    void set(kind_t kind, int offset, int size, const OopMap* map, const OopMap* other = nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-      \"the alloc region should never be empty\");\n+                      \"the alloc region should never be empty\");\n@@ -109,4 +109,1 @@\n-  assert_alloc_region(alloc_region->used() >= _used_bytes_before, \"invariant\");\n-  size_t allocated_bytes = alloc_region->used() - _used_bytes_before;\n-  retire_region(alloc_region, allocated_bytes);\n-  _used_bytes_before = 0;\n+  retire_region(alloc_region);\n@@ -135,1 +132,0 @@\n-  assert_alloc_region(_used_bytes_before == 0, \"pre-condition\");\n@@ -141,3 +137,3 @@\n-    \/\/ Need to do this before the allocation\n-    _used_bytes_before = new_alloc_region->used();\n-    HeapWord* result = allocate(new_alloc_region, word_size);\n+\n+    assert(new_alloc_region->is_empty(), \"new regions should be empty\");\n+    HeapWord* result = new_alloc_region->allocate(word_size);\n@@ -162,1 +158,1 @@\n-  assert_alloc_region(_alloc_region == nullptr && _used_bytes_before == 0, \"pre-condition\");\n+  assert_alloc_region(_alloc_region == nullptr, \"pre-condition\");\n@@ -171,6 +167,1 @@\n-  \/\/ We explicitly check that the region is not empty to make sure we\n-  \/\/ maintain the \"the alloc region cannot be empty\" invariant.\n-  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"pre-condition\");\n-  assert_alloc_region(_alloc_region == _dummy_region &&\n-                         _used_bytes_before == 0 && _count == 0,\n-                         \"pre-condition\");\n+  assert_alloc_region(_alloc_region == _dummy_region && _count == 0, \"pre-condition\");\n@@ -178,3 +169,1 @@\n-  _used_bytes_before = alloc_region->used();\n-  _alloc_region = alloc_region;\n-  _count += 1;\n+  update_alloc_region(alloc_region);\n@@ -240,1 +229,1 @@\n-                     min_word_size, desired_word_size, actual_word_size, p2i(result));\n+                   min_word_size, desired_word_size, actual_word_size, p2i(result));\n@@ -250,3 +239,1 @@\n-G1AllocRegion::G1AllocRegion(const char* name,\n-                             bool bot_updates,\n-                             uint node_index)\n+G1AllocRegion::G1AllocRegion(const char* name, uint node_index)\n@@ -255,1 +242,0 @@\n-    _used_bytes_before(0),\n@@ -264,3 +250,2 @@\n-void MutatorAllocRegion::retire_region(G1HeapRegion* alloc_region,\n-                                       size_t allocated_bytes) {\n-  _g1h->retire_mutator_alloc_region(alloc_region, allocated_bytes);\n+void MutatorAllocRegion::retire_region(G1HeapRegion* alloc_region) {\n+  _g1h->retire_mutator_alloc_region(alloc_region, alloc_region->used());\n@@ -349,2 +334,3 @@\n-void G1GCAllocRegion::retire_region(G1HeapRegion* alloc_region,\n-                                    size_t allocated_bytes) {\n+void G1GCAllocRegion::retire_region(G1HeapRegion* alloc_region) {\n+  assert(alloc_region->used() >= _used_bytes_before, \"invariant\");\n+  size_t allocated_bytes = alloc_region->used() - _used_bytes_before;\n@@ -352,0 +338,1 @@\n+  _used_bytes_before = 0;\n@@ -363,0 +350,5 @@\n+\n+void G1GCAllocRegion::reuse(G1HeapRegion* alloc_region) {\n+  _used_bytes_before = alloc_region->used();\n+  set(alloc_region);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -66,5 +66,0 @@\n-  \/\/ When we set up a new active region we save its used bytes in this\n-  \/\/ field so that, when we retire it, we can calculate how much space\n-  \/\/ we allocated in it.\n-  size_t _used_bytes_before;\n-\n@@ -97,0 +92,2 @@\n+  void set(G1HeapRegion* alloc_region);\n+\n@@ -100,4 +97,0 @@\n-  \/\/ Perform a non-MT-safe allocation out of the given region.\n-  inline HeapWord* allocate(G1HeapRegion* alloc_region,\n-                            size_t word_size);\n-\n@@ -107,8 +100,0 @@\n-  \/\/ Perform a MT-safe allocation out of the given region, with the given\n-  \/\/ minimum and desired size. Returns the actual size allocated (between\n-  \/\/ minimum and desired size) in actual_word_size if the allocation has been\n-  \/\/ successful.\n-  inline HeapWord* par_allocate(G1HeapRegion* alloc_region,\n-                                size_t min_word_size,\n-                                size_t desired_word_size,\n-                                size_t* actual_word_size);\n@@ -134,2 +119,1 @@\n-  virtual void retire_region(G1HeapRegion* alloc_region,\n-                             size_t allocated_bytes) = 0;\n+  virtual void retire_region(G1HeapRegion* alloc_region) = 0;\n@@ -137,1 +121,1 @@\n-  G1AllocRegion(const char* name, bool bot_updates, uint node_index);\n+  G1AllocRegion(const char* name, uint node_index);\n@@ -176,6 +160,0 @@\n-  \/\/ This can be used to set the active region to a specific\n-  \/\/ region. (Use Example: we try to retain the last old GC alloc\n-  \/\/ region that we've used during a GC and we can use set() to\n-  \/\/ re-instate it at the beginning of the next GC.)\n-  void set(G1HeapRegion* alloc_region);\n-\n@@ -208,4 +186,3 @@\n-  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n-  virtual size_t retire(bool fill_up);\n-\n+  G1HeapRegion* allocate_new_region(size_t word_size) override;\n+  void retire_region(G1HeapRegion* alloc_region) override;\n+  size_t retire(bool fill_up) override;\n@@ -214,1 +191,1 @@\n-    : G1AllocRegion(\"Mutator Alloc Region\", false \/* bot_updates *\/, node_index),\n+    : G1AllocRegion(\"Mutator Alloc Region\", node_index),\n@@ -234,1 +211,1 @@\n-  virtual G1HeapRegion* release();\n+  G1HeapRegion* release() override;\n@@ -236,1 +213,1 @@\n-  virtual void init();\n+  void init() override;\n@@ -241,0 +218,4 @@\n+  \/\/ When we set up a new active region we save its used bytes in this\n+  \/\/ field so that, when we retire it, we can calculate how much space\n+  \/\/ we allocated in it.\n+  size_t _used_bytes_before;\n@@ -245,2 +226,2 @@\n-  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n+  G1HeapRegion* allocate_new_region(size_t word_size) override;\n+  void retire_region(G1HeapRegion* alloc_region) override;\n@@ -248,1 +229,1 @@\n-  virtual size_t retire(bool fill_up);\n+  size_t retire(bool fill_up) override;\n@@ -250,1 +231,1 @@\n-  G1GCAllocRegion(const char* name, bool bot_updates, G1EvacStats* stats,\n+  G1GCAllocRegion(const char* name, G1EvacStats* stats,\n@@ -252,1 +233,1 @@\n-  : G1AllocRegion(name, bot_updates, node_index), _stats(stats), _purpose(purpose) {\n+    : G1AllocRegion(name, node_index), _used_bytes_before(0), _stats(stats), _purpose(purpose) {\n@@ -255,0 +236,5 @@\n+public:\n+  \/\/ This can be used to reuse a specific region. (Use Example: we try to retain the\n+  \/\/ last old GC alloc region that we've used during a GC and we can use reuse() to\n+  \/\/ re-instate it at the beginning of the next GC.)\n+  void reuse(G1HeapRegion* alloc_region);\n@@ -260,1 +246,1 @@\n-  : G1GCAllocRegion(\"Survivor GC Alloc Region\", false \/* bot_updates *\/, stats, G1HeapRegionAttr::Young, node_index) { }\n+  : G1GCAllocRegion(\"Survivor GC Alloc Region\", stats, G1HeapRegionAttr::Young, node_index) { }\n@@ -266,1 +252,1 @@\n-  : G1GCAllocRegion(\"Old GC Alloc Region\", true \/* bot_updates *\/, stats, G1HeapRegionAttr::Old) { }\n+  : G1GCAllocRegion(\"Old GC Alloc Region\", stats, G1HeapRegionAttr::Old) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":26,"deletions":40,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-    assert((p), \"[%s] %s c: %u r: \" PTR_FORMAT \" u: \" SIZE_FORMAT,       \\\n-           _name, (message), _count, p2i(_alloc_region),                 \\\n-           _used_bytes_before);                                          \\\n+    assert((p), \"[%s] %s c: %u r: \" PTR_FORMAT,                          \\\n+           _name, (message), _count, p2i(_alloc_region)                  \\\n+          );                                                             \\\n@@ -44,7 +44,0 @@\n-inline HeapWord* G1AllocRegion::allocate(G1HeapRegion* alloc_region,\n-                                         size_t word_size) {\n-  assert(alloc_region != nullptr, \"pre-condition\");\n-\n-  return alloc_region->allocate(word_size);\n-}\n-\n@@ -52,8 +45,0 @@\n-  size_t temp;\n-  return par_allocate(alloc_region, word_size, word_size, &temp);\n-}\n-\n-inline HeapWord* G1AllocRegion::par_allocate(G1HeapRegion* alloc_region,\n-                                             size_t min_word_size,\n-                                             size_t desired_word_size,\n-                                             size_t* actual_word_size) {\n@@ -62,2 +47,2 @@\n-\n-  return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n+  size_t temp;\n+  return alloc_region->par_allocate(word_size, word_size, &temp);\n@@ -70,1 +55,3 @@\n-  assert_alloc_region(alloc_region != nullptr, \"not initialized properly\");\n+  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"not initialized properly\");\n+\n+  HeapWord* result = alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n@@ -72,1 +59,0 @@\n-  HeapWord* result = par_allocate(alloc_region, min_word_size, desired_word_size, actual_word_size);\n@@ -75,1 +61,2 @@\n-    return result;\n+  } else {\n+    trace(\"alloc failed\", min_word_size, desired_word_size);\n@@ -77,2 +64,1 @@\n-  trace(\"alloc failed\", min_word_size, desired_word_size);\n-  return nullptr;\n+  return result;\n@@ -115,1 +101,1 @@\n-    HeapWord* result = par_allocate(_retained_alloc_region, min_word_size, desired_word_size, actual_word_size);\n+    HeapWord* result = _retained_alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    old->set(retained_region);\n+    old->reuse(retained_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,0 @@\n-\n@@ -131,1 +130,0 @@\n-\n@@ -136,1 +134,1 @@\n-  assert(log2i_exact(HeapRegionBounds::min_size()) == LOG_M, \"inv\");\n+  assert(log2i_exact(G1HeapRegionBounds::min_size()) == LOG_M, \"inv\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,11 @@\n+  static ContainerPtr empty_card_set() {\n+    \/\/ Work around https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=114573\n+    \/\/ gcc issues -Wzero-as-null-pointer-constant here, even though\n+    \/\/ ContainerInlinePtr is a *non-literal* constant 0.  We cast a non-const\n+    \/\/ copy, and let the compiler's constant propagation optimize into\n+    \/\/ equivalent code.\n+    static_assert(G1CardSet::ContainerInlinePtr == 0, \"unnecessary warning dodge\");\n+    auto value = G1CardSet::ContainerInlinePtr;\n+    return reinterpret_cast<ContainerPtr>(value);\n+  }\n+\n@@ -90,1 +101,1 @@\n-  G1CardSetInlinePtr() : _value_addr(nullptr), _value((ContainerPtr)G1CardSet::ContainerInlinePtr) { }\n+  G1CardSetInlinePtr() : G1CardSetInlinePtr(empty_card_set()) {}\n@@ -92,3 +103,2 @@\n-  G1CardSetInlinePtr(ContainerPtr value) : _value_addr(nullptr), _value(value) {\n-    assert(G1CardSet::container_type(_value) == G1CardSet::ContainerInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInlinePtr.\", p2i(_value));\n-  }\n+  explicit G1CardSetInlinePtr(ContainerPtr value) :\n+    G1CardSetInlinePtr(nullptr, value) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  HeapRegionRemSet::invalidate_from_card_cache(start_idx, num_regions);\n+  G1HeapRegionRemSet::invalidate_from_card_cache(start_idx, num_regions);\n@@ -165,1 +165,1 @@\n-                                          HeapRegionType type,\n+                                          G1HeapRegionType type,\n@@ -713,1 +713,1 @@\n-class PostCompactionPrinterClosure: public HeapRegionClosure {\n+class PostCompactionPrinterClosure: public G1HeapRegionClosure {\n@@ -1073,1 +1073,1 @@\n-class OldRegionSetChecker : public HeapRegionSetChecker {\n+class OldRegionSetChecker : public G1HeapRegionSetChecker {\n@@ -1101,1 +1101,1 @@\n-class HumongousRegionSetChecker : public HeapRegionSetChecker {\n+class HumongousRegionSetChecker : public G1HeapRegionSetChecker {\n@@ -1355,1 +1355,1 @@\n-  HeapRegionRemSet::initialize(_reserved);\n+  G1HeapRegionRemSet::initialize(_reserved);\n@@ -1357,1 +1357,1 @@\n-  FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n+  G1FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n@@ -1539,1 +1539,1 @@\n-class SumUsedClosure: public HeapRegionClosure {\n+class SumUsedClosure: public G1HeapRegionClosure {\n@@ -1890,1 +1890,1 @@\n-class IterateObjectClosureRegionClosure: public HeapRegionClosure {\n+class IterateObjectClosureRegionClosure: public G1HeapRegionClosure {\n@@ -1910,1 +1910,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -1926,1 +1926,1 @@\n-void G1CollectedHeap::object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer) {\n+void G1CollectedHeap::object_iterate_parallel(ObjectClosure* cl, uint worker_id, G1HeapRegionClaimer* claimer) {\n@@ -1935,1 +1935,1 @@\n-void G1CollectedHeap::heap_region_iterate(HeapRegionClosure* cl) const {\n+void G1CollectedHeap::heap_region_iterate(G1HeapRegionClosure* cl) const {\n@@ -1939,1 +1939,1 @@\n-void G1CollectedHeap::heap_region_iterate(HeapRegionIndexClosure* cl) const {\n+void G1CollectedHeap::heap_region_iterate(G1HeapRegionIndexClosure* cl) const {\n@@ -1943,2 +1943,2 @@\n-void G1CollectedHeap::heap_region_par_iterate_from_worker_offset(HeapRegionClosure* cl,\n-                                                                 HeapRegionClaimer *hrclaimer,\n+void G1CollectedHeap::heap_region_par_iterate_from_worker_offset(G1HeapRegionClosure* cl,\n+                                                                 G1HeapRegionClaimer *hrclaimer,\n@@ -1949,2 +1949,2 @@\n-void G1CollectedHeap::heap_region_par_iterate_from_start(HeapRegionClosure* cl,\n-                                                         HeapRegionClaimer *hrclaimer) const {\n+void G1CollectedHeap::heap_region_par_iterate_from_start(G1HeapRegionClosure* cl,\n+                                                         G1HeapRegionClaimer *hrclaimer) const {\n@@ -1954,1 +1954,1 @@\n-void G1CollectedHeap::collection_set_iterate_all(HeapRegionClosure* cl) {\n+void G1CollectedHeap::collection_set_iterate_all(G1HeapRegionClosure* cl) {\n@@ -1958,2 +1958,2 @@\n-void G1CollectedHeap::collection_set_par_iterate_all(HeapRegionClosure* cl,\n-                                                     HeapRegionClaimer* hr_claimer,\n+void G1CollectedHeap::collection_set_par_iterate_all(G1HeapRegionClosure* cl,\n+                                                     G1HeapRegionClaimer* hr_claimer,\n@@ -1964,2 +1964,2 @@\n-void G1CollectedHeap::collection_set_iterate_increment_from(HeapRegionClosure *cl,\n-                                                            HeapRegionClaimer* hr_claimer,\n+void G1CollectedHeap::collection_set_iterate_increment_from(G1HeapRegionClosure *cl,\n+                                                            G1HeapRegionClaimer* hr_claimer,\n@@ -1970,2 +1970,2 @@\n-void G1CollectedHeap::par_iterate_regions_array(HeapRegionClosure* cl,\n-                                                HeapRegionClaimer* hr_claimer,\n+void G1CollectedHeap::par_iterate_regions_array(G1HeapRegionClosure* cl,\n+                                                G1HeapRegionClaimer* hr_claimer,\n@@ -2049,1 +2049,1 @@\n-class PrintRegionClosure: public HeapRegionClosure {\n+class G1PrintRegionClosure: public G1HeapRegionClosure {\n@@ -2052,1 +2052,1 @@\n-  PrintRegionClosure(outputStream* st) : _st(st) {}\n+  G1PrintRegionClosure(outputStream* st) : _st(st) {}\n@@ -2124,1 +2124,1 @@\n-  PrintRegionClosure blk(st);\n+  G1PrintRegionClosure blk(st);\n@@ -2284,1 +2284,1 @@\n-  HeapRegionRemSet* rem_set = r->rem_set();\n+  G1HeapRegionRemSet* rem_set = r->rem_set();\n@@ -2291,1 +2291,1 @@\n-  class VerifyRegionAttrRemSet : public HeapRegionClosure {\n+  class VerifyRegionAttrRemSet : public G1HeapRegionClosure {\n@@ -2541,1 +2541,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -2543,1 +2543,1 @@\n-  class UnregisterNMethodsHeapRegionClosure : public HeapRegionClosure {\n+  class UnregisterNMethodsHeapRegionClosure : public G1HeapRegionClosure {\n@@ -2617,1 +2617,1 @@\n-void G1CollectedHeap::free_region(G1HeapRegion* hr, FreeRegionList* free_list) {\n+void G1CollectedHeap::free_region(G1HeapRegion* hr, G1FreeRegionList* free_list) {\n@@ -2639,1 +2639,1 @@\n-                                            FreeRegionList* free_list) {\n+                                            G1FreeRegionList* free_list) {\n@@ -2655,1 +2655,1 @@\n-void G1CollectedHeap::prepend_to_freelist(FreeRegionList* list) {\n+void G1CollectedHeap::prepend_to_freelist(G1FreeRegionList* list) {\n@@ -2681,1 +2681,1 @@\n-class G1AbandonCollectionSetClosure : public HeapRegionClosure {\n+class G1AbandonCollectionSetClosure : public G1HeapRegionClosure {\n@@ -2710,1 +2710,1 @@\n-class NoYoungRegionsClosure: public HeapRegionClosure {\n+class NoYoungRegionsClosure: public G1HeapRegionClosure {\n@@ -2771,1 +2771,1 @@\n-class RebuildRegionSetsClosure : public HeapRegionClosure {\n+class RebuildRegionSetsClosure : public G1HeapRegionClosure {\n@@ -2775,2 +2775,2 @@\n-  HeapRegionSet* _old_set;\n-  HeapRegionSet* _humongous_set;\n+  G1HeapRegionSet* _old_set;\n+  G1HeapRegionSet* _humongous_set;\n@@ -2778,1 +2778,1 @@\n-  HeapRegionManager* _hrm;\n+  G1HeapRegionManager* _hrm;\n@@ -2784,3 +2784,3 @@\n-                           HeapRegionSet* old_set,\n-                           HeapRegionSet* humongous_set,\n-                           HeapRegionManager* hrm) :\n+                           G1HeapRegionSet* old_set,\n+                           G1HeapRegionSet* humongous_set,\n+                           G1HeapRegionManager* hrm) :\n@@ -2852,1 +2852,1 @@\n-                                                HeapRegionType::Eden,\n+                                                G1HeapRegionType::Eden,\n@@ -2898,1 +2898,1 @@\n-  HeapRegionType type;\n+  G1HeapRegionType type;\n@@ -2900,1 +2900,1 @@\n-    type = HeapRegionType::Survivor;\n+    type = G1HeapRegionType::Survivor;\n@@ -2902,1 +2902,1 @@\n-    type = HeapRegionType::Old;\n+    type = G1HeapRegionType::Old;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":47,"deletions":47,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  friend class HeapRegionClaimer;\n+  friend class G1HeapRegionClaimer;\n@@ -183,2 +183,2 @@\n-  HeapRegionSet _old_set;\n-  HeapRegionSet _humongous_set;\n+  G1HeapRegionSet _old_set;\n+  G1HeapRegionSet _humongous_set;\n@@ -215,1 +215,1 @@\n-  HeapRegionManager _hrm;\n+  G1HeapRegionManager _hrm;\n@@ -389,1 +389,1 @@\n-  \/\/ Old, Eden, Humongous, Survivor defined in HeapRegionType.)\n+  \/\/ Old, Eden, Humongous, Survivor defined in G1HeapRegionType.)\n@@ -391,1 +391,1 @@\n-                           HeapRegionType type,\n+                           G1HeapRegionType type,\n@@ -682,1 +682,1 @@\n-  void free_region(G1HeapRegion* hr, FreeRegionList* free_list);\n+  void free_region(G1HeapRegion* hr, G1FreeRegionList* free_list);\n@@ -700,1 +700,1 @@\n-                             FreeRegionList* free_list);\n+                             G1FreeRegionList* free_list);\n@@ -1025,1 +1025,1 @@\n-  void prepend_to_freelist(FreeRegionList* list);\n+  void prepend_to_freelist(G1FreeRegionList* list);\n@@ -1063,1 +1063,1 @@\n-  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer);\n+  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, G1HeapRegionClaimer* claimer);\n@@ -1075,2 +1075,2 @@\n-  void heap_region_iterate(HeapRegionClosure* blk) const;\n-  void heap_region_iterate(HeapRegionIndexClosure* blk) const;\n+  void heap_region_iterate(G1HeapRegionClosure* blk) const;\n+  void heap_region_iterate(G1HeapRegionIndexClosure* blk) const;\n@@ -1094,1 +1094,1 @@\n-  \/\/ compete using the HeapRegionClaimer to claim the regions before\n+  \/\/ compete using the G1HeapRegionClaimer to claim the regions before\n@@ -1096,1 +1096,1 @@\n-  \/\/ The _from_worker_offset version uses the HeapRegionClaimer and\n+  \/\/ The _from_worker_offset version uses the G1HeapRegionClaimer and\n@@ -1099,2 +1099,2 @@\n-  void heap_region_par_iterate_from_worker_offset(HeapRegionClosure* cl,\n-                                                  HeapRegionClaimer* hrclaimer,\n+  void heap_region_par_iterate_from_worker_offset(G1HeapRegionClosure* cl,\n+                                                  G1HeapRegionClaimer* hrclaimer,\n@@ -1103,2 +1103,2 @@\n-  void heap_region_par_iterate_from_start(HeapRegionClosure* cl,\n-                                          HeapRegionClaimer* hrclaimer) const;\n+  void heap_region_par_iterate_from_start(G1HeapRegionClosure* cl,\n+                                          G1HeapRegionClaimer* hrclaimer) const;\n@@ -1107,2 +1107,2 @@\n-  void collection_set_par_iterate_all(HeapRegionClosure* cl,\n-                                      HeapRegionClaimer* hr_claimer,\n+  void collection_set_par_iterate_all(G1HeapRegionClosure* cl,\n+                                      G1HeapRegionClaimer* hr_claimer,\n@@ -1112,1 +1112,1 @@\n-  void collection_set_iterate_all(HeapRegionClosure* blk);\n+  void collection_set_iterate_all(G1HeapRegionClosure* blk);\n@@ -1118,1 +1118,1 @@\n-  \/\/ The variant with the HeapRegionClaimer guarantees that the closure will be\n+  \/\/ The variant with the G1HeapRegionClaimer guarantees that the closure will be\n@@ -1120,1 +1120,1 @@\n-  void collection_set_iterate_increment_from(HeapRegionClosure *blk, uint worker_id) {\n+  void collection_set_iterate_increment_from(G1HeapRegionClosure *blk, uint worker_id) {\n@@ -1123,1 +1123,1 @@\n-  void collection_set_iterate_increment_from(HeapRegionClosure *blk, HeapRegionClaimer* hr_claimer, uint worker_id);\n+  void collection_set_iterate_increment_from(G1HeapRegionClosure *blk, G1HeapRegionClaimer* hr_claimer, uint worker_id);\n@@ -1125,1 +1125,1 @@\n-  \/\/ the given HeapRegionClosure on each region. The worker_id will determine where\n+  \/\/ the given G1HeapRegionClosure on each region. The worker_id will determine where\n@@ -1127,2 +1127,2 @@\n-  void par_iterate_regions_array(HeapRegionClosure* cl,\n-                                 HeapRegionClaimer* hr_claimer,\n+  void par_iterate_regions_array(G1HeapRegionClosure* cl,\n+                                 G1HeapRegionClaimer* hr_claimer,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+  assert(!hr->is_free(), \"looking up obj \" PTR_FORMAT \" in Free region %u\", p2i(obj), hr->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-void G1CollectionSet::iterate(HeapRegionClosure* cl) const {\n+void G1CollectionSet::iterate(G1HeapRegionClosure* cl) const {\n@@ -146,2 +146,2 @@\n-void G1CollectionSet::par_iterate(HeapRegionClosure* cl,\n-                                  HeapRegionClaimer* hr_claimer,\n+void G1CollectionSet::par_iterate(G1HeapRegionClosure* cl,\n+                                  G1HeapRegionClaimer* hr_claimer,\n@@ -152,1 +152,1 @@\n-void G1CollectionSet::iterate_optional(HeapRegionClosure* cl) const {\n+void G1CollectionSet::iterate_optional(G1HeapRegionClosure* cl) const {\n@@ -161,2 +161,2 @@\n-void G1CollectionSet::iterate_incremental_part_from(HeapRegionClosure* cl,\n-                                                    HeapRegionClaimer* hr_claimer,\n+void G1CollectionSet::iterate_incremental_part_from(G1HeapRegionClosure* cl,\n+                                                    G1HeapRegionClaimer* hr_claimer,\n@@ -167,2 +167,2 @@\n-void G1CollectionSet::iterate_part_from(HeapRegionClosure* cl,\n-                                        HeapRegionClaimer* hr_claimer,\n+void G1CollectionSet::iterate_part_from(G1HeapRegionClosure* cl,\n+                                        G1HeapRegionClaimer* hr_claimer,\n@@ -210,1 +210,1 @@\n-class G1VerifyYoungAgesClosure : public HeapRegionClosure {\n+class G1VerifyYoungAgesClosure : public G1HeapRegionClosure {\n@@ -214,1 +214,1 @@\n-  G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }\n+  G1VerifyYoungAgesClosure() : G1HeapRegionClosure(), _valid(true) { }\n@@ -249,1 +249,1 @@\n-class G1PrintCollectionSetDetailClosure : public HeapRegionClosure {\n+class G1PrintCollectionSetDetailClosure : public G1HeapRegionClosure {\n@@ -252,1 +252,1 @@\n-  G1PrintCollectionSetDetailClosure(outputStream* st) : HeapRegionClosure(), _st(st) { }\n+  G1PrintCollectionSetDetailClosure(outputStream* st) : G1HeapRegionClosure(), _st(st) { }\n@@ -474,1 +474,1 @@\n-class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {\n+class G1VerifyYoungCSetIndicesClosure : public G1HeapRegionClosure {\n@@ -479,1 +479,1 @@\n-  G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {\n+  G1VerifyYoungCSetIndicesClosure(size_t young_length) : G1HeapRegionClosure(), _young_length(young_length) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-class HeapRegionClaimer;\n-class HeapRegionClosure;\n+class G1HeapRegionClaimer;\n+class G1HeapRegionClosure;\n@@ -200,1 +200,1 @@\n-  \/\/ HeapRegionClosure. The worker_id will determine where in the part to start the iteration\n+  \/\/ G1HeapRegionClosure. The worker_id will determine where in the part to start the iteration\n@@ -202,2 +202,2 @@\n-  void iterate_part_from(HeapRegionClosure* cl,\n-                         HeapRegionClaimer* hr_claimer,\n+  void iterate_part_from(G1HeapRegionClosure* cl,\n+                         G1HeapRegionClaimer* hr_claimer,\n@@ -246,1 +246,1 @@\n-  \/\/ Iterate over the current collection set increment applying the given HeapRegionClosure\n+  \/\/ Iterate over the current collection set increment applying the given G1HeapRegionClosure\n@@ -248,1 +248,1 @@\n-  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id) const;\n+  void iterate_incremental_part_from(G1HeapRegionClosure* cl, G1HeapRegionClaimer* hr_claimer, uint worker_id) const;\n@@ -256,4 +256,4 @@\n-  \/\/ the given HeapRegionClosure on all of them.\n-  void iterate(HeapRegionClosure* cl) const;\n-  void par_iterate(HeapRegionClosure* cl,\n-                   HeapRegionClaimer* hr_claimer,\n+  \/\/ the given G1HeapRegionClosure on all of them.\n+  void iterate(G1HeapRegionClosure* cl) const;\n+  void par_iterate(G1HeapRegionClosure* cl,\n+                   G1HeapRegionClaimer* hr_claimer,\n@@ -262,1 +262,1 @@\n-  void iterate_optional(HeapRegionClosure* cl) const;\n+  void iterate_optional(G1HeapRegionClosure* cl) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-class HeapRegionClosure;\n+class G1HeapRegionClosure;\n@@ -113,1 +113,1 @@\n-  \/\/ Removes any HeapRegions stored in this list also in the other list. The other\n+  \/\/ Removes any heap regions stored in this list also in the other list. The other\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  class G1BuildCandidateRegionsClosure : public HeapRegionClosure {\n+  class G1BuildCandidateRegionsClosure : public G1HeapRegionClosure {\n@@ -180,1 +180,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-HeapRegionRange::HeapRegionRange(uint start, uint end) :\n+G1HeapRegionRange::G1HeapRegionRange(uint start, uint end) :\n@@ -100,1 +100,1 @@\n-HeapRegionRange G1CommittedRegionMap::next_active_range(uint offset) const {\n+G1HeapRegionRange G1CommittedRegionMap::next_active_range(uint offset) const {\n@@ -105,1 +105,1 @@\n-    return HeapRegionRange(max_length(), max_length());\n+    return G1HeapRegionRange(max_length(), max_length());\n@@ -111,1 +111,1 @@\n-  return HeapRegionRange(start, end);\n+  return G1HeapRegionRange(start, end);\n@@ -114,1 +114,1 @@\n-HeapRegionRange G1CommittedRegionMap::next_committable_range(uint offset) const {\n+G1HeapRegionRange G1CommittedRegionMap::next_committable_range(uint offset) const {\n@@ -122,1 +122,1 @@\n-    return HeapRegionRange(max_length(), max_length());\n+    return G1HeapRegionRange(max_length(), max_length());\n@@ -128,1 +128,1 @@\n-  return HeapRegionRange(start, end);\n+  return G1HeapRegionRange(start, end);\n@@ -131,1 +131,1 @@\n-HeapRegionRange G1CommittedRegionMap::next_inactive_range(uint offset) const {\n+G1HeapRegionRange G1CommittedRegionMap::next_inactive_range(uint offset) const {\n@@ -137,1 +137,1 @@\n-    return HeapRegionRange(max_length(), max_length());\n+    return G1HeapRegionRange(max_length(), max_length());\n@@ -143,1 +143,1 @@\n-  return HeapRegionRange(start, end);\n+  return G1HeapRegionRange(start, end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-class HeapRegionRange : public StackObj {\n+class G1HeapRegionRange : public StackObj {\n@@ -39,1 +39,1 @@\n-  HeapRegionRange(uint start, uint end);\n+  G1HeapRegionRange(uint start, uint end);\n@@ -104,1 +104,1 @@\n-  HeapRegionRange next_active_range(uint offset) const;\n+  G1HeapRegionRange next_active_range(uint offset) const;\n@@ -106,1 +106,1 @@\n-  HeapRegionRange next_inactive_range(uint offset) const;\n+  G1HeapRegionRange next_inactive_range(uint offset) const;\n@@ -110,1 +110,1 @@\n-  HeapRegionRange next_committable_range(uint offset) const;\n+  G1HeapRegionRange next_committable_range(uint offset) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-  class G1ClearBitmapHRClosure : public HeapRegionClosure {\n+  class G1ClearBitmapHRClosure : public G1HeapRegionClosure {\n@@ -718,1 +718,1 @@\n-      HeapRegionClosure(),\n+      G1HeapRegionClosure(),\n@@ -762,1 +762,1 @@\n-  HeapRegionClaimer _hr_claimer;\n+  G1HeapRegionClaimer _hr_claimer;\n@@ -846,1 +846,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -866,1 +866,1 @@\n-class NoteStartOfMarkHRClosure : public HeapRegionClosure {\n+class NoteStartOfMarkHRClosure : public G1HeapRegionClosure {\n@@ -870,1 +870,1 @@\n-  NoteStartOfMarkHRClosure() : HeapRegionClosure(), _cm(G1CollectedHeap::heap()->concurrent_mark()) { }\n+  NoteStartOfMarkHRClosure() : G1HeapRegionClosure(), _cm(G1CollectedHeap::heap()->concurrent_mark()) { }\n@@ -1207,1 +1207,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -1212,1 +1212,1 @@\n-  FreeRegionList _cleanup_list;\n+  G1FreeRegionList _cleanup_list;\n@@ -1214,1 +1214,1 @@\n-  struct G1OnRegionClosure : public HeapRegionClosure {\n+  struct G1OnRegionClosure : public G1HeapRegionClosure {\n@@ -1223,1 +1223,1 @@\n-    FreeRegionList* _local_cleanup_list;\n+    G1FreeRegionList* _local_cleanup_list;\n@@ -1227,1 +1227,1 @@\n-                      FreeRegionList* local_cleanup_list) :\n+                      G1FreeRegionList* local_cleanup_list) :\n@@ -1328,1 +1328,1 @@\n-    FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n+    G1FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n@@ -1355,1 +1355,1 @@\n-class G1UpdateRegionsAfterRebuild : public HeapRegionClosure {\n+class G1UpdateRegionsAfterRebuild : public G1HeapRegionClosure {\n@@ -3081,1 +3081,1 @@\n-  _total_remset_bytes += HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -952,1 +952,1 @@\n-class G1PrintRegionLivenessInfoClosure : public HeapRegionClosure {\n+class G1PrintRegionLivenessInfoClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  HeapRegionClaimer _hr_claimer;\n+  G1HeapRegionClaimer _hr_claimer;\n@@ -70,1 +70,1 @@\n-  class G1RebuildRSAndScrubRegionClosure : public HeapRegionClosure {\n+  class G1RebuildRSAndScrubRegionClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,2 +256,1 @@\n-class G1ConcurrentRefine::RemSetSamplingClosure : public HeapRegionClosure {\n-  G1CollectionSet* _cset;\n+class G1ConcurrentRefine::RemSetSamplingClosure : public G1HeapRegionClosure {\n@@ -262,2 +261,2 @@\n-  explicit RemSetSamplingClosure(G1CollectionSet* cset) :\n-    _cset(cset), _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n+  RemSetSamplingClosure() :\n+    _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n@@ -266,1 +265,1 @@\n-    HeapRegionRemSet* rem_set = r->rem_set();\n+    G1HeapRegionRemSet* rem_set = r->rem_set();\n@@ -290,0 +289,1 @@\n+    RemSetSamplingClosure cl;\n@@ -291,1 +291,0 @@\n-    RemSetSamplingClosure cl{cset};\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-void G1EvacFailureRegions::par_iterate(HeapRegionClosure* closure,\n-                                       HeapRegionClaimer* hrclaimer,\n+void G1EvacFailureRegions::par_iterate(G1HeapRegionClosure* closure,\n+                                       G1HeapRegionClaimer* hrclaimer,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-class HeapRegionClosure;\n-class HeapRegionClaimer;\n+class G1HeapRegionClaimer;\n+class G1HeapRegionClosure;\n@@ -73,2 +73,2 @@\n-  void par_iterate(HeapRegionClosure* closure,\n-                   HeapRegionClaimer* hrclaimer,\n+  void par_iterate(G1HeapRegionClosure* closure,\n+                   G1HeapRegionClaimer* hrclaimer,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-class PrepareRegionsClosure : public HeapRegionClosure {\n+class PrepareRegionsClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-class G1AdjustRegionClosure : public HeapRegionClosure {\n+class G1AdjustRegionClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  HeapRegionClaimer        _hrclaimer;\n+  G1HeapRegionClaimer      _hrclaimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-\/\/ This table is used to store attribute values of all HeapRegions that need\n+\/\/ This table is used to store attribute values of all heap regions that need\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-class G1DetermineCompactionQueueClosure : public HeapRegionClosure {\n+class G1DetermineCompactionQueueClosure : public G1HeapRegionClosure {\n@@ -65,1 +65,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -77,1 +77,1 @@\n-  class G1CalculatePointersClosure : public HeapRegionClosure {\n+  class G1CalculatePointersClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -34,1 +34,1 @@\n-  class G1ResetMetadataClosure : public HeapRegionClosure {\n+  class G1ResetMetadataClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  return HeapRegionBounds::max_size();\n+  return G1HeapRegionBounds::max_size();\n@@ -62,1 +62,1 @@\n-  return HeapRegionBounds::min_size() >> LogHeapWordSize;\n+  return G1HeapRegionBounds::min_size() >> LogHeapWordSize;\n@@ -69,3 +69,3 @@\n-    region_size = clamp(max_heap_size \/ HeapRegionBounds::target_number(),\n-                        HeapRegionBounds::min_size(),\n-                        HeapRegionBounds::max_ergonomics_size());\n+    region_size = clamp(max_heap_size \/ G1HeapRegionBounds::target_number(),\n+                        G1HeapRegionBounds::min_size(),\n+                        G1HeapRegionBounds::max_ergonomics_size());\n@@ -79,1 +79,1 @@\n-  region_size = clamp(region_size, HeapRegionBounds::min_size(), HeapRegionBounds::max_size());\n+  region_size = clamp(region_size, G1HeapRegionBounds::min_size(), G1HeapRegionBounds::max_size());\n@@ -250,1 +250,1 @@\n-  _rem_set = new HeapRegionRemSet(this, config);\n+  _rem_set = new G1HeapRegionRemSet(this, config);\n@@ -267,5 +267,5 @@\n-  HeapRegionTracer::send_region_type_change(_hrm_index,\n-                                            get_trace_type(),\n-                                            to,\n-                                            (uintptr_t)bottom(),\n-                                            used());\n+  G1HeapRegionTracer::send_region_type_change(_hrm_index,\n+                                              get_trace_type(),\n+                                              to,\n+                                              (uintptr_t)bottom(),\n+                                              used());\n@@ -380,1 +380,1 @@\n-  HeapRegionRemSet* hrrs = rem_set();\n+  G1HeapRegionRemSet* hrrs = rem_set();\n@@ -550,1 +550,4 @@\n-      return !_is_in_heap || this->_g1h->is_obj_dead_cond(this->_obj, _vo);\n+      return !_is_in_heap ||\n+             \/\/ is_obj_dead* assume that obj is not in a Free region.\n+             this->_g1h->heap_region_containing(this->_obj)->is_free() ||\n+             this->_g1h->is_obj_dead_cond(this->_obj, _vo);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-class HeapRegionRemSet;\n@@ -45,1 +44,2 @@\n-class HeapRegionSetBase;\n+class G1HeapRegionRemSet;\n+class G1HeapRegionSetBase;\n@@ -130,12 +130,0 @@\n-  \/\/ Try to allocate at least min_word_size and up to desired_size from this region.\n-  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n-  \/\/ space allocated.\n-  \/\/ This version assumes that all allocation requests to this G1HeapRegion are properly\n-  \/\/ synchronized.\n-  inline HeapWord* allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-  \/\/ Try to allocate at least min_word_size and up to desired_size from this G1HeapRegion.\n-  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n-  \/\/ space allocated.\n-  \/\/ This version synchronizes with other calls to par_allocate_impl().\n-  inline HeapWord* par_allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-\n@@ -166,0 +154,5 @@\n+\n+  \/\/ Try to allocate at least min_word_size and up to desired_size from this HeapRegion.\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ space allocated.\n+  \/\/ This version synchronizes with other calls to par_allocate().\n@@ -168,0 +161,5 @@\n+  \/\/ Try to allocate at least min_word_size and up to desired_size from this region.\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ space allocated.\n+  \/\/ This version assumes that all allocation requests to this HeapRegion are properly\n+  \/\/ synchronized.\n@@ -200,1 +198,1 @@\n-  HeapRegionRemSet* _rem_set;\n+  G1HeapRegionRemSet* _rem_set;\n@@ -205,1 +203,1 @@\n-  HeapRegionType _type;\n+  G1HeapRegionType _type;\n@@ -216,1 +214,1 @@\n-  \/\/ Fields used by the HeapRegionSetBase class and subclasses.\n+  \/\/ Fields used by the G1HeapRegionSetBase class and subclasses.\n@@ -220,1 +218,1 @@\n-  HeapRegionSetBase* _containing_set;\n+  G1HeapRegionSetBase* _containing_set;\n@@ -281,1 +279,1 @@\n-  \/\/ If this region is a member of a HeapRegionManager, the index in that\n+  \/\/ If this region is a member of a G1HeapRegionManager, the index in that\n@@ -423,1 +421,1 @@\n-  void set_rem_set(HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n+  void set_rem_set(G1HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n@@ -425,1 +423,1 @@\n-  HeapRegionRemSet* rem_set() const {\n+  G1HeapRegionRemSet* rem_set() const {\n@@ -433,1 +431,1 @@\n-  \/\/ Methods used by the HeapRegionSetBase class and subclasses.\n+  \/\/ Methods used by the G1HeapRegionSetBase class and subclasses.\n@@ -450,1 +448,1 @@\n-  void set_containing_set(HeapRegionSetBase* containing_set) {\n+  void set_containing_set(G1HeapRegionSetBase* containing_set) {\n@@ -460,1 +458,1 @@\n-  HeapRegionSetBase* containing_set() { return _containing_set; }\n+  G1HeapRegionSetBase* containing_set() { return _containing_set; }\n@@ -462,1 +460,1 @@\n-  void set_containing_set(HeapRegionSetBase* containing_set) { }\n+  void set_containing_set(G1HeapRegionSetBase* containing_set) { }\n@@ -557,1 +555,1 @@\n-\/\/ HeapRegionClosure is used for iterating over regions.\n+\/\/ G1HeapRegionClosure is used for iterating over regions.\n@@ -559,2 +557,2 @@\n-class HeapRegionClosure : public StackObj {\n-  friend class HeapRegionManager;\n+class G1HeapRegionClosure : public StackObj {\n+  friend class G1HeapRegionManager;\n@@ -568,1 +566,1 @@\n-  HeapRegionClosure(): _is_complete(true) {}\n+  G1HeapRegionClosure(): _is_complete(true) {}\n@@ -578,2 +576,2 @@\n-class HeapRegionIndexClosure : public StackObj {\n-  friend class HeapRegionManager;\n+class G1HeapRegionIndexClosure : public StackObj {\n+  friend class G1HeapRegionManager;\n@@ -587,1 +585,1 @@\n-  HeapRegionIndexClosure(): _is_complete(true) {}\n+  G1HeapRegionIndexClosure(): _is_complete(true) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":30,"deletions":32,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -45,41 +45,0 @@\n-inline HeapWord* G1HeapRegion::allocate_impl(size_t min_word_size,\n-                                           size_t desired_word_size,\n-                                           size_t* actual_size) {\n-  HeapWord* obj = top();\n-  size_t available = pointer_delta(end(), obj);\n-  size_t want_to_allocate = MIN2(available, desired_word_size);\n-  if (want_to_allocate >= min_word_size) {\n-    HeapWord* new_top = obj + want_to_allocate;\n-    set_top(new_top);\n-    assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n-    *actual_size = want_to_allocate;\n-    return obj;\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-inline HeapWord* G1HeapRegion::par_allocate_impl(size_t min_word_size,\n-                                               size_t desired_word_size,\n-                                               size_t* actual_size) {\n-  do {\n-    HeapWord* obj = top();\n-    size_t available = pointer_delta(end(), obj);\n-    size_t want_to_allocate = MIN2(available, desired_word_size);\n-    if (want_to_allocate >= min_word_size) {\n-      HeapWord* new_top = obj + want_to_allocate;\n-      HeapWord* result = Atomic::cmpxchg(&_top, obj, new_top);\n-      \/\/ result can be one of two:\n-      \/\/  the old top value: the exchange succeeded\n-      \/\/  otherwise: the new value of the top is returned.\n-      if (result == obj) {\n-        assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n-        *actual_size = want_to_allocate;\n-        return obj;\n-      }\n-    } else {\n-      return nullptr;\n-    }\n-  } while (true);\n-}\n-\n@@ -228,3 +187,21 @@\n-                                          size_t desired_word_size,\n-                                          size_t* actual_word_size) {\n-  return par_allocate_impl(min_word_size, desired_word_size, actual_word_size);\n+                                            size_t desired_word_size,\n+                                            size_t* actual_word_size) {\n+  do {\n+    HeapWord* obj = top();\n+    size_t available = pointer_delta(end(), obj);\n+    size_t want_to_allocate = MIN2(available, desired_word_size);\n+    if (want_to_allocate >= min_word_size) {\n+      HeapWord* new_top = obj + want_to_allocate;\n+      HeapWord* result = Atomic::cmpxchg(&_top, obj, new_top);\n+      \/\/ result can be one of two:\n+      \/\/ the old top value: the exchange succeeded\n+      \/\/ otherwise: the new value of the top is returned.\n+      if (result == obj) {\n+        assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n+        *actual_word_size = want_to_allocate;\n+        return obj;\n+      }\n+    } else {\n+      return nullptr;\n+    }\n+  } while (true);\n@@ -239,3 +216,14 @@\n-                                      size_t desired_word_size,\n-                                      size_t* actual_word_size) {\n-  return allocate_impl(min_word_size, desired_word_size, actual_word_size);\n+                                        size_t desired_word_size,\n+                                        size_t* actual_word_size) {\n+  HeapWord* obj = top();\n+  size_t available = pointer_delta(end(), obj);\n+  size_t want_to_allocate = MIN2(available, desired_word_size);\n+  if (want_to_allocate >= min_word_size) {\n+    HeapWord* new_top = obj + want_to_allocate;\n+    set_top(new_top);\n+    assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n+    *actual_word_size = want_to_allocate;\n+    return obj;\n+  } else {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":35,"deletions":47,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-class HeapRegionBounds : public AllStatic {\n+class G1HeapRegionBounds : public AllStatic {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionBounds.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-size_t HeapRegionBounds::min_size() {\n+size_t G1HeapRegionBounds::min_size() {\n@@ -34,1 +34,1 @@\n-size_t HeapRegionBounds::max_ergonomics_size() {\n+size_t G1HeapRegionBounds::max_ergonomics_size() {\n@@ -38,1 +38,1 @@\n-size_t HeapRegionBounds::max_size() {\n+size_t G1HeapRegionBounds::max_size() {\n@@ -42,1 +42,1 @@\n-size_t HeapRegionBounds::target_number() {\n+size_t G1HeapRegionBounds::target_number() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionBounds.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-class DumpEventInfoClosure : public HeapRegionClosure {\n+class DumpEventInfoClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionEventSender.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-class MasterFreeRegionListChecker : public HeapRegionSetChecker {\n+class G1MasterFreeRegionListChecker : public G1HeapRegionSetChecker {\n@@ -65,1 +65,1 @@\n-HeapRegionManager::HeapRegionManager() :\n+G1HeapRegionManager::G1HeapRegionManager() :\n@@ -72,1 +72,1 @@\n-  _free_list(\"Free list\", new MasterFreeRegionListChecker())\n+  _free_list(\"Free list\", new G1MasterFreeRegionListChecker())\n@@ -75,4 +75,4 @@\n-void HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,\n-                                   G1RegionToSpaceMapper* bitmap,\n-                                   G1RegionToSpaceMapper* bot,\n-                                   G1RegionToSpaceMapper* cardtable) {\n+void G1HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,\n+                                     G1RegionToSpaceMapper* bitmap,\n+                                     G1RegionToSpaceMapper* bot,\n+                                     G1RegionToSpaceMapper* cardtable) {\n@@ -93,1 +93,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_free_region(HeapRegionType type, uint requested_node_index) {\n+G1HeapRegion* G1HeapRegionManager::allocate_free_region(G1HeapRegionType type, uint requested_node_index) {\n@@ -121,1 +121,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_humongous_from_free_list(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::allocate_humongous_from_free_list(uint num_regions) {\n@@ -129,1 +129,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_humongous_allow_expand(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::allocate_humongous_allow_expand(uint num_regions) {\n@@ -138,1 +138,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_humongous(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::allocate_humongous(uint num_regions) {\n@@ -141,1 +141,1 @@\n-    return allocate_free_region(HeapRegionType::Humongous, G1NUMA::AnyNodeIndex);\n+    return allocate_free_region(G1HeapRegionType::Humongous, G1NUMA::AnyNodeIndex);\n@@ -146,1 +146,1 @@\n-G1HeapRegion* HeapRegionManager::expand_and_allocate_humongous(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::expand_and_allocate_humongous(uint num_regions) {\n@@ -151,1 +151,1 @@\n-bool HeapRegionManager::is_free(G1HeapRegion* hr) const {\n+bool G1HeapRegionManager::is_free(G1HeapRegion* hr) const {\n@@ -156,1 +156,1 @@\n-G1HeapRegion* HeapRegionManager::new_heap_region(uint hrm_index) {\n+G1HeapRegion* G1HeapRegionManager::new_heap_region(uint hrm_index) {\n@@ -164,1 +164,1 @@\n-void HeapRegionManager::expand(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+void G1HeapRegionManager::expand(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -179,1 +179,1 @@\n-void HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkerThreads* pretouch_workers) {\n+void G1HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkerThreads* pretouch_workers) {\n@@ -193,1 +193,1 @@\n-void HeapRegionManager::uncommit_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::uncommit_regions(uint start, uint num_regions) {\n@@ -218,1 +218,1 @@\n-void HeapRegionManager::initialize_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::initialize_regions(uint start, uint num_regions) {\n@@ -230,1 +230,1 @@\n-void HeapRegionManager::activate_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::activate_regions(uint start, uint num_regions) {\n@@ -235,1 +235,1 @@\n-void HeapRegionManager::reactivate_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::reactivate_regions(uint start, uint num_regions) {\n@@ -244,1 +244,1 @@\n-void HeapRegionManager::deactivate_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::deactivate_regions(uint start, uint num_regions) {\n@@ -259,1 +259,1 @@\n-void HeapRegionManager::clear_auxiliary_data_structures(uint start, uint num_regions) {\n+void G1HeapRegionManager::clear_auxiliary_data_structures(uint start, uint num_regions) {\n@@ -268,1 +268,1 @@\n-MemoryUsage HeapRegionManager::get_auxiliary_data_memory_usage() const {\n+MemoryUsage G1HeapRegionManager::get_auxiliary_data_memory_usage() const {\n@@ -282,1 +282,1 @@\n-bool HeapRegionManager::has_inactive_regions() const {\n+bool G1HeapRegionManager::has_inactive_regions() const {\n@@ -286,1 +286,1 @@\n-uint HeapRegionManager::uncommit_inactive_regions(uint limit) {\n+uint G1HeapRegionManager::uncommit_inactive_regions(uint limit) {\n@@ -293,1 +293,1 @@\n-    HeapRegionRange range = _committed_map.next_inactive_range(offset);\n+    G1HeapRegionRange range = _committed_map.next_inactive_range(offset);\n@@ -310,1 +310,1 @@\n-uint HeapRegionManager::expand_inactive(uint num_regions) {\n+uint G1HeapRegionManager::expand_inactive(uint num_regions) {\n@@ -315,1 +315,1 @@\n-    HeapRegionRange regions = _committed_map.next_inactive_range(offset);\n+    G1HeapRegionRange regions = _committed_map.next_inactive_range(offset);\n@@ -330,1 +330,1 @@\n-uint HeapRegionManager::expand_any(uint num_regions, WorkerThreads* pretouch_workers) {\n+uint G1HeapRegionManager::expand_any(uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -337,1 +337,1 @@\n-    HeapRegionRange regions = _committed_map.next_committable_range(offset);\n+    G1HeapRegionRange regions = _committed_map.next_committable_range(offset);\n@@ -352,1 +352,1 @@\n-uint HeapRegionManager::expand_by(uint num_regions, WorkerThreads* pretouch_workers) {\n+uint G1HeapRegionManager::expand_by(uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -368,1 +368,1 @@\n-void HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+void G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -396,1 +396,1 @@\n-uint HeapRegionManager::expand_on_preferred_node(uint preferred_index) {\n+uint G1HeapRegionManager::expand_on_preferred_node(uint preferred_index) {\n@@ -423,1 +423,1 @@\n-bool HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {\n+bool G1HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {\n@@ -429,1 +429,1 @@\n-void HeapRegionManager::assert_contiguous_range(uint start, uint num_regions) {\n+void G1HeapRegionManager::assert_contiguous_range(uint start, uint num_regions) {\n@@ -442,1 +442,1 @@\n-uint HeapRegionManager::find_contiguous_in_range(uint start, uint end, uint num_regions) {\n+uint G1HeapRegionManager::find_contiguous_in_range(uint start, uint end, uint num_regions) {\n@@ -468,1 +468,1 @@\n-uint HeapRegionManager::find_contiguous_in_free_list(uint num_regions) {\n+uint G1HeapRegionManager::find_contiguous_in_free_list(uint num_regions) {\n@@ -470,1 +470,1 @@\n-  HeapRegionRange range(0,0);\n+  G1HeapRegionRange range(0,0);\n@@ -480,1 +480,1 @@\n-uint HeapRegionManager::find_contiguous_allow_expand(uint num_regions) {\n+uint G1HeapRegionManager::find_contiguous_allow_expand(uint num_regions) {\n@@ -489,1 +489,1 @@\n-G1HeapRegion* HeapRegionManager::next_region_in_heap(const G1HeapRegion* r) const {\n+G1HeapRegion* G1HeapRegionManager::next_region_in_heap(const G1HeapRegion* r) const {\n@@ -501,1 +501,1 @@\n-void HeapRegionManager::iterate(HeapRegionClosure* blk) const {\n+void G1HeapRegionManager::iterate(G1HeapRegionClosure* blk) const {\n@@ -517,1 +517,1 @@\n-void HeapRegionManager::iterate(HeapRegionIndexClosure* blk) const {\n+void G1HeapRegionManager::iterate(G1HeapRegionIndexClosure* blk) const {\n@@ -532,1 +532,1 @@\n-uint HeapRegionManager::find_highest_free(bool* expanded) {\n+uint G1HeapRegionManager::find_highest_free(bool* expanded) {\n@@ -554,1 +554,1 @@\n-bool HeapRegionManager::allocate_containing_regions(MemRegion range, size_t* commit_count, WorkerThreads* pretouch_workers) {\n+bool G1HeapRegionManager::allocate_containing_regions(MemRegion range, size_t* commit_count, WorkerThreads* pretouch_workers) {\n@@ -577,1 +577,1 @@\n-void HeapRegionManager::par_iterate(HeapRegionClosure* blk, HeapRegionClaimer* hrclaimer, const uint start_index) const {\n+void G1HeapRegionManager::par_iterate(G1HeapRegionClosure* blk, G1HeapRegionClaimer* hrclaimer, const uint start_index) const {\n@@ -606,1 +606,1 @@\n-uint HeapRegionManager::shrink_by(uint num_regions_to_remove) {\n+uint G1HeapRegionManager::shrink_by(uint num_regions_to_remove) {\n@@ -636,1 +636,1 @@\n-void HeapRegionManager::shrink_at(uint index, size_t num_regions) {\n+void G1HeapRegionManager::shrink_at(uint index, size_t num_regions) {\n@@ -648,1 +648,1 @@\n-uint HeapRegionManager::find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const {\n+uint G1HeapRegionManager::find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const {\n@@ -682,1 +682,1 @@\n-void HeapRegionManager::verify() {\n+void G1HeapRegionManager::verify() {\n@@ -727,1 +727,1 @@\n-void HeapRegionManager::verify_optional() {\n+void G1HeapRegionManager::verify_optional() {\n@@ -732,1 +732,1 @@\n-HeapRegionClaimer::HeapRegionClaimer(uint n_workers) :\n+G1HeapRegionClaimer::G1HeapRegionClaimer(uint n_workers) :\n@@ -739,1 +739,1 @@\n-HeapRegionClaimer::~HeapRegionClaimer() {\n+G1HeapRegionClaimer::~G1HeapRegionClaimer() {\n@@ -743,1 +743,1 @@\n-uint HeapRegionClaimer::offset_for_worker(uint worker_id) const {\n+uint G1HeapRegionClaimer::offset_for_worker(uint worker_id) const {\n@@ -749,1 +749,1 @@\n-bool HeapRegionClaimer::is_region_claimed(uint region_index) const {\n+bool G1HeapRegionClaimer::is_region_claimed(uint region_index) const {\n@@ -754,1 +754,1 @@\n-bool HeapRegionClaimer::claim_region(uint region_index) {\n+bool G1HeapRegionClaimer::claim_region(uint region_index) {\n@@ -761,4 +761,4 @@\n-  HeapRegionManager* _hrm;\n-  FreeRegionList*    _worker_freelists;\n-  uint               _worker_chunk_size;\n-  uint               _num_workers;\n+  G1HeapRegionManager* _hrm;\n+  G1FreeRegionList*    _worker_freelists;\n+  uint                 _worker_chunk_size;\n+  uint                 _num_workers;\n@@ -767,1 +767,1 @@\n-  G1RebuildFreeListTask(HeapRegionManager* hrm, uint num_workers) :\n+  G1RebuildFreeListTask(G1HeapRegionManager* hrm, uint num_workers) :\n@@ -770,1 +770,1 @@\n-      _worker_freelists(NEW_C_HEAP_ARRAY(FreeRegionList, num_workers, mtGC)),\n+      _worker_freelists(NEW_C_HEAP_ARRAY(G1FreeRegionList, num_workers, mtGC)),\n@@ -774,1 +774,1 @@\n-      ::new (&_worker_freelists[worker]) FreeRegionList(\"Appendable Worker Free List\");\n+      ::new (&_worker_freelists[worker]) G1FreeRegionList(\"Appendable Worker Free List\");\n@@ -780,1 +780,1 @@\n-      _worker_freelists[worker].~FreeRegionList();\n+      _worker_freelists[worker].~G1FreeRegionList();\n@@ -782,1 +782,1 @@\n-    FREE_C_HEAP_ARRAY(FreeRegionList, _worker_freelists);\n+    FREE_C_HEAP_ARRAY(G1FreeRegionList, _worker_freelists);\n@@ -785,1 +785,1 @@\n-  FreeRegionList* worker_freelist(uint worker) {\n+  G1FreeRegionList* worker_freelist(uint worker) {\n@@ -803,1 +803,1 @@\n-    FreeRegionList* free_list = worker_freelist(worker_id);\n+    G1FreeRegionList* free_list = worker_freelist(worker_id);\n@@ -818,1 +818,1 @@\n-void HeapRegionManager::rebuild_free_list(WorkerThreads* workers) {\n+void G1HeapRegionManager::rebuild_free_list(WorkerThreads* workers) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,3 @@\n-class HeapRegionClosure;\n-class HeapRegionClaimer;\n-class FreeRegionList;\n+class G1HeapRegionClaimer;\n+class G1HeapRegionClosure;\n+class G1FreeRegionList;\n@@ -52,1 +52,1 @@\n-\/\/ HeapRegions are kept in the _regions array in address order. A region's\n+\/\/ G1HeapRegions are kept in the _regions array in address order. A region's\n@@ -68,1 +68,1 @@\n-\/\/   number of regions+1 for which we have HeapRegions.\n+\/\/   number of regions+1 for which we have G1HeapRegions.\n@@ -73,1 +73,1 @@\n-class HeapRegionManager: public CHeapObj<mtGC> {\n+class G1HeapRegionManager: public CHeapObj<mtGC> {\n@@ -75,1 +75,1 @@\n-  friend class HeapRegionClaimer;\n+  friend class G1HeapRegionClaimer;\n@@ -93,1 +93,1 @@\n-  \/\/ Initialize the HeapRegions in the range and put them on the free list.\n+  \/\/ Initialize the G1HeapRegions in the range and put them on the free list.\n@@ -126,1 +126,1 @@\n-  FreeRegionList _free_list;\n+  G1FreeRegionList _free_list;\n@@ -160,1 +160,1 @@\n-  HeapRegionManager();\n+  G1HeapRegionManager();\n@@ -199,1 +199,1 @@\n-  void insert_list_into_free_list(FreeRegionList* list) {\n+  void insert_list_into_free_list(G1FreeRegionList* list) {\n@@ -204,1 +204,1 @@\n-  G1HeapRegion* allocate_free_region(HeapRegionType type, uint requested_node_index);\n+  G1HeapRegion* allocate_free_region(G1HeapRegionType type, uint requested_node_index);\n@@ -249,1 +249,1 @@\n-  \/\/ HeapRegions, or re-use existing ones. Returns the number of regions the\n+  \/\/ G1HeapRegions, or re-use existing ones. Returns the number of regions the\n@@ -271,2 +271,2 @@\n-  void iterate(HeapRegionClosure* blk) const;\n-  void iterate(HeapRegionIndexClosure* blk) const;\n+  void iterate(G1HeapRegionClosure* blk) const;\n+  void iterate(G1HeapRegionIndexClosure* blk) const;\n@@ -274,1 +274,1 @@\n-  void par_iterate(HeapRegionClosure* blk, HeapRegionClaimer* hrclaimer, const uint start_index) const;\n+  void par_iterate(G1HeapRegionClosure* blk, G1HeapRegionClaimer* hrclaimer, const uint start_index) const;\n@@ -297,1 +297,1 @@\n-\/\/ The HeapRegionClaimer is used during parallel iteration over heap regions,\n+\/\/ The G1HeapRegionClaimer is used during parallel iteration over heap regions,\n@@ -299,1 +299,1 @@\n-class HeapRegionClaimer : public StackObj {\n+class G1HeapRegionClaimer : public StackObj {\n@@ -308,2 +308,2 @@\n-  HeapRegionClaimer(uint n_workers);\n-  ~HeapRegionClaimer();\n+  G1HeapRegionClaimer(uint n_workers);\n+  ~G1HeapRegionClaimer();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-inline bool HeapRegionManager::is_available(uint region) const {\n+inline bool G1HeapRegionManager::is_available(uint region) const {\n@@ -38,1 +38,1 @@\n-inline G1HeapRegion* HeapRegionManager::addr_to_region(HeapWord* addr) const {\n+inline G1HeapRegion* G1HeapRegionManager::addr_to_region(HeapWord* addr) const {\n@@ -46,1 +46,1 @@\n-inline G1HeapRegion* HeapRegionManager::at(uint index) const {\n+inline G1HeapRegion* G1HeapRegionManager::at(uint index) const {\n@@ -54,1 +54,1 @@\n-inline G1HeapRegion* HeapRegionManager::at_or_null(uint index) const {\n+inline G1HeapRegion* G1HeapRegionManager::at_or_null(uint index) const {\n@@ -64,1 +64,1 @@\n-inline G1HeapRegion* HeapRegionManager::next_region_in_humongous(G1HeapRegion* hr) const {\n+inline G1HeapRegion* G1HeapRegionManager::next_region_in_humongous(G1HeapRegion* hr) const {\n@@ -76,1 +76,1 @@\n-inline void HeapRegionManager::insert_into_free_list(G1HeapRegion* hr) {\n+inline void G1HeapRegionManager::insert_into_free_list(G1HeapRegion* hr) {\n@@ -80,1 +80,1 @@\n-inline G1HeapRegion* HeapRegionManager::allocate_free_regions_starting_at(uint first, uint num_regions) {\n+inline G1HeapRegion* G1HeapRegionManager::allocate_free_regions_starting_at(uint first, uint num_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class FreeRegionList;\n+class G1FreeRegionList;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-HeapWord* HeapRegionRemSet::_heap_base_address = nullptr;\n+HeapWord* G1HeapRegionRemSet::_heap_base_address = nullptr;\n@@ -50,2 +50,2 @@\n-const char* HeapRegionRemSet::_state_strings[] =  {\"Untracked\", \"Updating\", \"Complete\"};\n-const char* HeapRegionRemSet::_short_state_strings[] =  {\"UNTRA\", \"UPDAT\", \"CMPLT\"};\n+const char* G1HeapRegionRemSet::_state_strings[] =  {\"Untracked\", \"Updating\", \"Complete\"};\n+const char* G1HeapRegionRemSet::_short_state_strings[] =  {\"UNTRA\", \"UPDAT\", \"CMPLT\"};\n@@ -53,1 +53,1 @@\n-void HeapRegionRemSet::initialize(MemRegion reserved) {\n+void G1HeapRegionRemSet::initialize(MemRegion reserved) {\n@@ -58,1 +58,1 @@\n-HeapRegionRemSet::HeapRegionRemSet(G1HeapRegion* hr,\n+G1HeapRegionRemSet::G1HeapRegionRemSet(G1HeapRegion* hr,\n@@ -66,1 +66,1 @@\n-void HeapRegionRemSet::clear_fcc() {\n+void G1HeapRegionRemSet::clear_fcc() {\n@@ -70,1 +70,1 @@\n-void HeapRegionRemSet::clear(bool only_cardset, bool keep_tracked) {\n+void G1HeapRegionRemSet::clear(bool only_cardset, bool keep_tracked) {\n@@ -84,1 +84,1 @@\n-void HeapRegionRemSet::reset_table_scanner() {\n+void G1HeapRegionRemSet::reset_table_scanner() {\n@@ -89,1 +89,1 @@\n-G1MonotonicArenaMemoryStats HeapRegionRemSet::card_set_memory_stats() const {\n+G1MonotonicArenaMemoryStats G1HeapRegionRemSet::card_set_memory_stats() const {\n@@ -93,2 +93,2 @@\n-void HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n-  out->print_cr(\"  Static structures = \" SIZE_FORMAT, HeapRegionRemSet::static_mem_size());\n+void G1HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n+  out->print_cr(\"  Static structures = \" SIZE_FORMAT, G1HeapRegionRemSet::static_mem_size());\n@@ -104,1 +104,1 @@\n-void HeapRegionRemSet::add_code_root(nmethod* nm) {\n+void G1HeapRegionRemSet::add_code_root(nmethod* nm) {\n@@ -109,1 +109,1 @@\n-void HeapRegionRemSet::remove_code_root(nmethod* nm) {\n+void G1HeapRegionRemSet::remove_code_root(nmethod* nm) {\n@@ -118,1 +118,1 @@\n-void HeapRegionRemSet::bulk_remove_code_roots() {\n+void G1HeapRegionRemSet::bulk_remove_code_roots() {\n@@ -122,1 +122,1 @@\n-void HeapRegionRemSet::code_roots_do(NMethodClosure* blk) const {\n+void G1HeapRegionRemSet::code_roots_do(NMethodClosure* blk) const {\n@@ -126,1 +126,1 @@\n-void HeapRegionRemSet::clean_code_roots(G1HeapRegion* hr) {\n+void G1HeapRegionRemSet::clean_code_roots(G1HeapRegion* hr) {\n@@ -130,1 +130,1 @@\n-size_t HeapRegionRemSet::code_roots_mem_size() {\n+size_t G1HeapRegionRemSet::code_roots_mem_size() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-class HeapRegionRemSet : public CHeapObj<mtGC> {\n+class G1HeapRegionRemSet : public CHeapObj<mtGC> {\n@@ -60,1 +60,1 @@\n-  HeapRegionRemSet(G1HeapRegion* hr, G1CardSetConfiguration* config);\n+  G1HeapRegionRemSet(G1HeapRegion* hr, G1CardSetConfiguration* config);\n@@ -129,1 +129,1 @@\n-           + (sizeof(HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n+           + (sizeof(G1HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-void HeapRegionRemSet::set_state_untracked() {\n+void G1HeapRegionRemSet::set_state_untracked() {\n@@ -46,1 +46,1 @@\n-void HeapRegionRemSet::set_state_updating() {\n+void G1HeapRegionRemSet::set_state_updating() {\n@@ -53,1 +53,1 @@\n-void HeapRegionRemSet::set_state_complete() {\n+void G1HeapRegionRemSet::set_state_complete() {\n@@ -110,1 +110,1 @@\n-inline void HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+inline void G1HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n@@ -119,1 +119,1 @@\n-uintptr_t HeapRegionRemSet::to_card(OopOrNarrowOopStar from) const {\n+uintptr_t G1HeapRegionRemSet::to_card(OopOrNarrowOopStar from) const {\n@@ -123,1 +123,1 @@\n-void HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n+void G1HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n@@ -139,1 +139,1 @@\n-bool HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n+bool G1HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n@@ -143,1 +143,1 @@\n-void HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n+void G1HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-uint FreeRegionList::_unrealistically_long_length = 0;\n+uint G1FreeRegionList::_unrealistically_long_length = 0;\n@@ -34,1 +34,1 @@\n-void HeapRegionSetBase::verify_region(G1HeapRegion* hr) {\n+void G1HeapRegionSetBase::verify_region(G1HeapRegion* hr) {\n@@ -44,1 +44,1 @@\n-void HeapRegionSetBase::verify() {\n+void G1HeapRegionSetBase::verify() {\n@@ -56,1 +56,1 @@\n-void HeapRegionSetBase::verify_start() {\n+void G1HeapRegionSetBase::verify_start() {\n@@ -62,1 +62,1 @@\n-  HeapRegionSetBase::verify();\n+  G1HeapRegionSetBase::verify();\n@@ -67,1 +67,1 @@\n-void HeapRegionSetBase::verify_end() {\n+void G1HeapRegionSetBase::verify_end() {\n@@ -75,1 +75,1 @@\n-void HeapRegionSetBase::print_on(outputStream* out, bool print_contents) {\n+void G1HeapRegionSetBase::print_on(outputStream* out, bool print_contents) {\n@@ -82,1 +82,1 @@\n-HeapRegionSetBase::HeapRegionSetBase(const char* name, HeapRegionSetChecker* checker)\n+G1HeapRegionSetBase::G1HeapRegionSetBase(const char* name, G1HeapRegionSetChecker* checker)\n@@ -87,1 +87,1 @@\n-void FreeRegionList::set_unrealistically_long_length(uint len) {\n+void G1FreeRegionList::set_unrealistically_long_length(uint len) {\n@@ -92,1 +92,1 @@\n-void FreeRegionList::abandon() {\n+void G1FreeRegionList::abandon() {\n@@ -98,1 +98,1 @@\n-void FreeRegionList::remove_all() {\n+void G1FreeRegionList::remove_all() {\n@@ -120,1 +120,1 @@\n-void FreeRegionList::add_list_common_start(FreeRegionList* from_list) {\n+void G1FreeRegionList::add_list_common_start(G1FreeRegionList* from_list) {\n@@ -135,1 +135,1 @@\n-  FreeRegionListIterator iter(from_list);\n+  G1FreeRegionListIterator iter(from_list);\n@@ -147,1 +147,1 @@\n-void FreeRegionList::add_list_common_end(FreeRegionList* from_list) {\n+void G1FreeRegionList::add_list_common_end(G1FreeRegionList* from_list) {\n@@ -155,1 +155,1 @@\n-void FreeRegionList::append_ordered(FreeRegionList* from_list) {\n+void G1FreeRegionList::append_ordered(G1FreeRegionList* from_list) {\n@@ -180,1 +180,1 @@\n-void FreeRegionList::add_ordered(FreeRegionList* from_list) {\n+void G1FreeRegionList::add_ordered(G1FreeRegionList* from_list) {\n@@ -230,1 +230,1 @@\n-void FreeRegionList::verify_region_to_remove(G1HeapRegion* curr, G1HeapRegion* next) {\n+void G1FreeRegionList::verify_region_to_remove(G1HeapRegion* curr, G1HeapRegion* next) {\n@@ -247,1 +247,1 @@\n-void FreeRegionList::remove_starting_at(G1HeapRegion* first, uint num_regions) {\n+void G1FreeRegionList::remove_starting_at(G1HeapRegion* first, uint num_regions) {\n@@ -307,2 +307,2 @@\n-void FreeRegionList::verify() {\n-  \/\/ See comment in HeapRegionSetBase::verify() about MT safety and\n+void G1FreeRegionList::verify() {\n+  \/\/ See comment in G1HeapRegionSetBase::verify() about MT safety and\n@@ -320,1 +320,1 @@\n-void FreeRegionList::clear() {\n+void G1FreeRegionList::clear() {\n@@ -331,1 +331,1 @@\n-void FreeRegionList::verify_list() {\n+void G1FreeRegionList::verify_list() {\n@@ -367,2 +367,2 @@\n-FreeRegionList::FreeRegionList(const char* name, HeapRegionSetChecker* checker):\n-  HeapRegionSetBase(name, checker),\n+G1FreeRegionList::G1FreeRegionList(const char* name, G1HeapRegionSetChecker* checker):\n+  G1HeapRegionSetBase(name, checker),\n@@ -374,1 +374,1 @@\n-FreeRegionList::~FreeRegionList() {\n+G1FreeRegionList::~G1FreeRegionList() {\n@@ -380,2 +380,2 @@\n-FreeRegionList::NodeInfo::NodeInfo() : _numa(G1NUMA::numa()), _length_of_node(nullptr),\n-                                       _num_nodes(_numa->num_active_nodes()) {\n+G1FreeRegionList::NodeInfo::NodeInfo() : _numa(G1NUMA::numa()), _length_of_node(nullptr),\n+                                         _num_nodes(_numa->num_active_nodes()) {\n@@ -387,1 +387,1 @@\n-FreeRegionList::NodeInfo::~NodeInfo() {\n+G1FreeRegionList::NodeInfo::~NodeInfo() {\n@@ -391,1 +391,1 @@\n-void FreeRegionList::NodeInfo::clear() {\n+void G1FreeRegionList::NodeInfo::clear() {\n@@ -397,1 +397,1 @@\n-void FreeRegionList::NodeInfo::add(NodeInfo* info) {\n+void G1FreeRegionList::NodeInfo::add(NodeInfo* info) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-\/\/ HeapRegionSets.\n-class HeapRegionSetChecker : public CHeapObj<mtGC> {\n+\/\/ G1HeapRegionSets.\n+class G1HeapRegionSetChecker : public CHeapObj<mtGC> {\n@@ -54,1 +54,1 @@\n-  \/\/ Verify MT safety for this HeapRegionSet.\n+  \/\/ Verify MT safety for this G1HeapRegionSet.\n@@ -56,1 +56,1 @@\n-  \/\/ Returns true if the given G1HeapRegion is of the correct type for this HeapRegionSet.\n+  \/\/ Returns true if the given G1HeapRegion is of the correct type for this G1HeapRegionSet.\n@@ -58,1 +58,1 @@\n-  \/\/ Return a description of the type of regions this HeapRegionSet contains.\n+  \/\/ Return a description of the type of regions this G1HeapRegionSet contains.\n@@ -67,1 +67,1 @@\n-class HeapRegionSetBase {\n+class G1HeapRegionSetBase {\n@@ -70,1 +70,1 @@\n-  HeapRegionSetChecker* _checker;\n+  G1HeapRegionSetChecker* _checker;\n@@ -90,1 +90,1 @@\n-  HeapRegionSetBase(const char* name, HeapRegionSetChecker* verifier);\n+  G1HeapRegionSetBase(const char* name, G1HeapRegionSetChecker* verifier);\n@@ -120,1 +120,1 @@\n-\/\/ the same interface (namely, the HeapRegionSetBase API).\n+\/\/ the same interface (namely, the G1HeapRegionSetBase API).\n@@ -122,1 +122,1 @@\n-class HeapRegionSet : public HeapRegionSetBase {\n+class G1HeapRegionSet : public G1HeapRegionSetBase {\n@@ -124,2 +124,2 @@\n-  HeapRegionSet(const char* name, HeapRegionSetChecker* checker):\n-    HeapRegionSetBase(name, checker) {\n+  G1HeapRegionSet(const char* name, G1HeapRegionSetChecker* checker):\n+    G1HeapRegionSetBase(name, checker) {\n@@ -138,1 +138,1 @@\n-class FreeRegionListIterator;\n+class G1FreeRegionListIterator;\n@@ -141,2 +141,2 @@\n-class FreeRegionList : public HeapRegionSetBase {\n-  friend class FreeRegionListIterator;\n+class G1FreeRegionList : public G1HeapRegionSetBase {\n+  friend class G1FreeRegionListIterator;\n@@ -184,2 +184,2 @@\n-  void add_list_common_start(FreeRegionList* from_list);\n-  void add_list_common_end(FreeRegionList* from_list);\n+  void add_list_common_start(G1FreeRegionList* from_list);\n+  void add_list_common_end(G1FreeRegionList* from_list);\n@@ -189,1 +189,1 @@\n-  \/\/ See the comment for HeapRegionSetBase::clear()\n+  \/\/ See the comment for G1HeapRegionSetBase::clear()\n@@ -193,2 +193,2 @@\n-  FreeRegionList(const char* name, HeapRegionSetChecker* checker = nullptr);\n-  ~FreeRegionList();\n+  G1FreeRegionList(const char* name, G1HeapRegionSetChecker* checker = nullptr);\n+  ~G1FreeRegionList();\n@@ -221,2 +221,2 @@\n-  void add_ordered(FreeRegionList* from_list);\n-  void append_ordered(FreeRegionList* from_list);\n+  void add_ordered(G1FreeRegionList* from_list);\n+  void append_ordered(G1FreeRegionList* from_list);\n@@ -238,1 +238,1 @@\n-  using HeapRegionSetBase::length;\n+  using G1HeapRegionSetBase::length;\n@@ -245,1 +245,1 @@\n-class FreeRegionListIterator : public StackObj {\n+class G1FreeRegionListIterator : public StackObj {\n@@ -247,1 +247,1 @@\n-  FreeRegionList* _list;\n+  G1FreeRegionList* _list;\n@@ -268,1 +268,1 @@\n-  FreeRegionListIterator(FreeRegionList* list)\n+  G1FreeRegionListIterator(G1FreeRegionList* list)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-inline void HeapRegionSetBase::add(G1HeapRegion* hr) {\n+inline void G1HeapRegionSetBase::add(G1HeapRegion* hr) {\n@@ -43,1 +43,1 @@\n-inline void HeapRegionSetBase::remove(G1HeapRegion* hr) {\n+inline void G1HeapRegionSetBase::remove(G1HeapRegion* hr) {\n@@ -54,1 +54,1 @@\n-inline void FreeRegionList::add_to_tail(G1HeapRegion* region_to_add) {\n+inline void G1FreeRegionList::add_to_tail(G1HeapRegion* region_to_add) {\n@@ -74,1 +74,1 @@\n-inline void FreeRegionList::add_ordered(G1HeapRegion* hr) {\n+inline void G1FreeRegionList::add_ordered(G1HeapRegion* hr) {\n@@ -123,1 +123,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_from_head_impl() {\n+inline G1HeapRegion* G1FreeRegionList::remove_from_head_impl() {\n@@ -135,1 +135,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_from_tail_impl() {\n+inline G1HeapRegion* G1FreeRegionList::remove_from_tail_impl() {\n@@ -148,1 +148,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_region(bool from_head) {\n+inline G1HeapRegion* G1FreeRegionList::remove_region(bool from_head) {\n@@ -177,1 +177,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_region_with_node_index(bool from_head,\n+inline G1HeapRegion* G1FreeRegionList::remove_region_with_node_index(bool from_head,\n@@ -235,1 +235,1 @@\n-inline void FreeRegionList::NodeInfo::increase_length(uint node_index) {\n+inline void G1FreeRegionList::NodeInfo::increase_length(uint node_index) {\n@@ -241,1 +241,1 @@\n-inline void FreeRegionList::NodeInfo::decrease_length(uint node_index) {\n+inline void G1FreeRegionList::NodeInfo::decrease_length(uint node_index) {\n@@ -250,1 +250,1 @@\n-inline uint FreeRegionList::NodeInfo::length(uint node_index) const {\n+inline uint G1FreeRegionList::NodeInfo::length(uint node_index) const {\n@@ -254,1 +254,1 @@\n-inline void FreeRegionList::increase_length(uint node_index) {\n+inline void G1FreeRegionList::increase_length(uint node_index) {\n@@ -260,1 +260,1 @@\n-inline void FreeRegionList::decrease_length(uint node_index) {\n+inline void G1FreeRegionList::decrease_length(uint node_index) {\n@@ -266,1 +266,1 @@\n-inline uint FreeRegionList::length(uint node_index) const {\n+inline uint G1FreeRegionList::length(uint node_index) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-void HeapRegionTracer::send_region_type_change(uint index,\n+void G1HeapRegionTracer::send_region_type_change(uint index,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-class HeapRegionTracer : AllStatic {\n+class G1HeapRegionTracer : AllStatic {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionTracer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,4 @@\n-const HeapRegionType HeapRegionType::Eden      = HeapRegionType(EdenTag);\n-const HeapRegionType HeapRegionType::Survivor  = HeapRegionType(SurvTag);\n-const HeapRegionType HeapRegionType::Old       = HeapRegionType(OldTag);\n-const HeapRegionType HeapRegionType::Humongous = HeapRegionType(StartsHumongousTag);\n+const G1HeapRegionType G1HeapRegionType::Eden      = G1HeapRegionType(EdenTag);\n+const G1HeapRegionType G1HeapRegionType::Survivor  = G1HeapRegionType(SurvTag);\n+const G1HeapRegionType G1HeapRegionType::Old       = G1HeapRegionType(OldTag);\n+const G1HeapRegionType G1HeapRegionType::Humongous = G1HeapRegionType(StartsHumongousTag);\n@@ -34,1 +34,1 @@\n-bool HeapRegionType::is_valid(Tag tag) {\n+bool G1HeapRegionType::is_valid(Tag tag) {\n@@ -48,1 +48,1 @@\n-const char* HeapRegionType::get_str() const {\n+const char* G1HeapRegionType::get_str() const {\n@@ -63,1 +63,1 @@\n-const char* HeapRegionType::get_short_str() const {\n+const char* G1HeapRegionType::get_short_str() const {\n@@ -78,1 +78,1 @@\n-G1HeapRegionTraceType::Type HeapRegionType::get_trace_type() {\n+G1HeapRegionTraceType::Type G1HeapRegionType::get_trace_type() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionType.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-class HeapRegionType {\n+class G1HeapRegionType {\n@@ -104,1 +104,1 @@\n-  HeapRegionType(Tag t) : _tag(t) { hrt_assert_is_valid(_tag); }\n+  G1HeapRegionType(Tag t) : _tag(t) { hrt_assert_is_valid(_tag); }\n@@ -162,1 +162,1 @@\n-  HeapRegionType() : _tag(FreeTag) { hrt_assert_is_valid(_tag); }\n+  G1HeapRegionType() : _tag(FreeTag) { hrt_assert_is_valid(_tag); }\n@@ -164,4 +164,4 @@\n-  static const HeapRegionType Eden;\n-  static const HeapRegionType Survivor;\n-  static const HeapRegionType Old;\n-  static const HeapRegionType Humongous;\n+  static const G1HeapRegionType Eden;\n+  static const G1HeapRegionType Survivor;\n+  static const G1HeapRegionType Old;\n+  static const G1HeapRegionType Humongous;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionType.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-class G1HeapTransition::DetailedUsageClosure: public HeapRegionClosure {\n+class G1HeapTransition::DetailedUsageClosure: public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-      HeapRegionRemSet* hrrs = hr->rem_set();\n+      G1HeapRegionRemSet* hrrs = hr->rem_set();\n@@ -234,1 +234,1 @@\n-class VerifyRegionClosure: public HeapRegionClosure {\n+class VerifyRegionClosure: public G1HeapRegionClosure {\n@@ -290,4 +290,4 @@\n-  G1CollectedHeap*  _g1h;\n-  VerifyOption      _vo;\n-  bool              _failures;\n-  HeapRegionClaimer _hrclaimer;\n+  G1CollectedHeap*    _g1h;\n+  VerifyOption        _vo;\n+  bool                _failures;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -380,1 +380,1 @@\n-class VerifyRegionListsClosure : public HeapRegionClosure {\n+class VerifyRegionListsClosure : public G1HeapRegionClosure {\n@@ -382,3 +382,3 @@\n-  HeapRegionSet*   _old_set;\n-  HeapRegionSet*   _humongous_set;\n-  HeapRegionManager* _hrm;\n+  G1HeapRegionSet*     _old_set;\n+  G1HeapRegionSet*     _humongous_set;\n+  G1HeapRegionManager* _hrm;\n@@ -391,3 +391,3 @@\n-  VerifyRegionListsClosure(HeapRegionSet* old_set,\n-                           HeapRegionSet* humongous_set,\n-                           HeapRegionManager* hrm) :\n+  VerifyRegionListsClosure(G1HeapRegionSet* old_set,\n+                           G1HeapRegionSet* humongous_set,\n+                           G1HeapRegionManager* hrm) :\n@@ -415,1 +415,1 @@\n-  void verify_counts(HeapRegionSet* old_set, HeapRegionSet* humongous_set, HeapRegionManager* free_list) {\n+  void verify_counts(G1HeapRegionSet* old_set, G1HeapRegionSet* humongous_set, G1HeapRegionManager* free_list) {\n@@ -438,1 +438,1 @@\n-class G1VerifyRegionMarkingStateClosure : public HeapRegionClosure {\n+class G1VerifyRegionMarkingStateClosure : public G1HeapRegionClosure {\n@@ -538,1 +538,1 @@\n-  class G1VerifyBitmapClear : public HeapRegionClosure {\n+  class G1VerifyBitmapClear : public G1HeapRegionClosure {\n@@ -560,1 +560,1 @@\n-class G1VerifyCardTableCleanup: public HeapRegionClosure {\n+class G1VerifyCardTableCleanup: public G1HeapRegionClosure {\n@@ -606,1 +606,1 @@\n-class G1VerifyDirtyYoungListClosure : public HeapRegionClosure {\n+class G1VerifyDirtyYoungListClosure : public G1HeapRegionClosure {\n@@ -610,1 +610,1 @@\n-  G1VerifyDirtyYoungListClosure(G1HeapVerifier* verifier) : HeapRegionClosure(), _verifier(verifier) { }\n+  G1VerifyDirtyYoungListClosure(G1HeapVerifier* verifier) : G1HeapRegionClosure(), _verifier(verifier) { }\n@@ -622,1 +622,1 @@\n-class G1CheckRegionAttrTableClosure : public HeapRegionClosure {\n+class G1CheckRegionAttrTableClosure : public G1HeapRegionClosure {\n@@ -627,1 +627,1 @@\n-  G1CheckRegionAttrTableClosure() : HeapRegionClosure(), _failures(false) { }\n+  G1CheckRegionAttrTableClosure() : G1HeapRegionClosure(), _failures(false) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,1 @@\n-  \/\/ There would be some cases that 1 page may be consisted of multiple HeapRegions.\n+  \/\/ There would be some cases that 1 page may be consisted of multiple heap regions.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  \/\/ This assumes that HeapRegions are evenly spit, so we can decide preferred index\n+  \/\/ This assumes that heap regions are evenly spit, so we can decide preferred index\n@@ -130,1 +130,1 @@\n-class G1NodeIndexCheckClosure : public HeapRegionClosure {\n+class G1NodeIndexCheckClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-  HeapRegionRemSet* to_rem_set = _g1h->heap_region_containing(obj)->rem_set();\n+  G1HeapRegionRemSet* to_rem_set = _g1h->heap_region_containing(obj)->rem_set();\n@@ -269,1 +269,1 @@\n-  HeapRegionRemSet* rem_set = to->rem_set();\n+  G1HeapRegionRemSet* rem_set = to->rem_set();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-  void iterate_dirty_regions_from(HeapRegionClosure* cl, uint worker_id) {\n+  void iterate_dirty_regions_from(G1HeapRegionClosure* cl, uint worker_id) {\n@@ -484,1 +484,1 @@\n-class G1ScanHRForRegionClosure : public HeapRegionClosure {\n+class G1ScanHRForRegionClosure : public G1HeapRegionClosure {\n@@ -758,1 +758,1 @@\n-class G1ScanCollectionSetRegionClosure : public HeapRegionClosure {\n+class G1ScanCollectionSetRegionClosure : public G1HeapRegionClosure {\n@@ -975,1 +975,1 @@\n-  \/\/ table. This is in addition to being the HeapRegionClosure to iterate over\n+  \/\/ table. This is in addition to being the HG1eapRegionClosure to iterate over\n@@ -981,1 +981,1 @@\n-  class G1MergeCardSetClosure : public HeapRegionClosure {\n+  class G1MergeCardSetClosure : public G1HeapRegionClosure {\n@@ -1077,1 +1077,1 @@\n-      HeapRegionRemSet* rem_set = r->rem_set();\n+      G1HeapRegionRemSet* rem_set = r->rem_set();\n@@ -1101,1 +1101,1 @@\n-  class G1ClearBitmapClosure : public HeapRegionClosure {\n+  class G1ClearBitmapClosure : public G1HeapRegionClosure {\n@@ -1147,3 +1147,3 @@\n-  class G1CombinedClosure : public HeapRegionClosure {\n-    HeapRegionClosure* _closure1;\n-    HeapRegionClosure* _closure2;\n+  class G1CombinedClosure : public G1HeapRegionClosure {\n+    G1HeapRegionClosure* _closure1;\n+    G1HeapRegionClosure* _closure2;\n@@ -1151,1 +1151,1 @@\n-    G1CombinedClosure(HeapRegionClosure* cl1, HeapRegionClosure* cl2) :\n+    G1CombinedClosure(G1HeapRegionClosure* cl1, G1HeapRegionClosure* cl2) :\n@@ -1163,1 +1163,1 @@\n-  class G1FlushHumongousCandidateRemSets : public HeapRegionIndexClosure {\n+  class G1FlushHumongousCandidateRemSets : public G1HeapRegionIndexClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+class G1HeapRegionClaimer;\n@@ -52,1 +53,0 @@\n-class HeapRegionClaimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-class HRRSStatsIter: public HeapRegionClosure {\n+class HRRSStatsIter: public G1HeapRegionClosure {\n@@ -219,1 +219,1 @@\n-    HeapRegionRemSet* hrrs = r->rem_set();\n+    G1HeapRegionRemSet* hrrs = r->rem_set();\n@@ -221,1 +221,1 @@\n-    \/\/ HeapRegionRemSet::mem_size() includes the\n+    \/\/ G1HeapRegionRemSet::mem_size() includes the\n@@ -277,1 +277,1 @@\n-    HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n+    G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n@@ -284,1 +284,1 @@\n-    HeapRegionRemSet::print_static_mem_size(out);\n+    G1HeapRegionRemSet::print_static_mem_size(out);\n@@ -289,1 +289,1 @@\n-    HeapRegionRemSet* max_code_root_rem_set = max_code_root_mem_sz_region()->rem_set();\n+    G1HeapRegionRemSet* max_code_root_rem_set = max_code_root_mem_sz_region()->rem_set();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-class G1PrintCollectionSetClosure : public HeapRegionClosure {\n+class G1PrintCollectionSetClosure : public G1HeapRegionClosure {\n@@ -289,1 +289,1 @@\n-  class G1PrepareRegionsClosure : public HeapRegionClosure {\n+  class G1PrepareRegionsClosure : public G1HeapRegionClosure {\n@@ -421,1 +421,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class SelectAllocationFailureRegionClosure : public HeapRegionClosure {\n+class SelectAllocationFailureRegionClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -336,1 +336,1 @@\n-class G1FreeHumongousRegionClosure : public HeapRegionIndexClosure {\n+class G1FreeHumongousRegionClosure : public G1HeapRegionIndexClosure {\n@@ -540,1 +540,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -542,1 +542,1 @@\n-  class ProcessEvacuationFailedRegionsClosure : public HeapRegionClosure {\n+  class ProcessEvacuationFailedRegionsClosure : public G1HeapRegionClosure {\n@@ -709,1 +709,1 @@\n-class FreeCSetClosure : public HeapRegionClosure {\n+class FreeCSetClosure : public G1HeapRegionClosure {\n@@ -810,1 +810,1 @@\n-      HeapRegionClosure(),\n+      G1HeapRegionClosure(),\n@@ -856,6 +856,6 @@\n-  G1CollectedHeap*  _g1h;\n-  G1EvacInfo*       _evacuation_info;\n-  FreeCSetStats*    _worker_stats;\n-  HeapRegionClaimer _claimer;\n-  const size_t*     _surviving_young_words;\n-  uint              _active_workers;\n+  G1CollectedHeap*    _g1h;\n+  G1EvacInfo*         _evacuation_info;\n+  FreeCSetStats*      _worker_stats;\n+  G1HeapRegionClaimer _claimer;\n+  const size_t*       _surviving_young_words;\n+  uint                _active_workers;\n@@ -863,1 +863,1 @@\n-  volatile uint     _num_retained_regions;\n+  volatile uint       _num_retained_regions;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-  if (FLAG_IS_CMDLINE(G1HeapRegionSize) && (value < HeapRegionBounds::min_size())) {\n+  if (FLAG_IS_CMDLINE(G1HeapRegionSize) && (value < G1HeapRegionBounds::min_size())) {\n@@ -183,1 +183,1 @@\n-  return HeapRegionBounds::max_size();\n+  return G1HeapRegionBounds::max_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  nonstatic_field(G1HeapRegion, _type,           HeapRegionType)              \\\n+  nonstatic_field(G1HeapRegion, _type,           G1HeapRegionType)            \\\n@@ -46,1 +46,1 @@\n-  nonstatic_field(HeapRegionType, _tag,       HeapRegionType::Tag volatile)   \\\n+  nonstatic_field(G1HeapRegionType, _tag,   G1HeapRegionType::Tag volatile)   \\\n@@ -55,1 +55,1 @@\n-  nonstatic_field(HeapRegionManager, _regions,          G1HeapRegionTable)    \\\n+  nonstatic_field(G1HeapRegionManager, _regions,        G1HeapRegionTable)    \\\n@@ -58,1 +58,1 @@\n-  nonstatic_field(G1CollectedHeap, _hrm,                HeapRegionManager)    \\\n+  nonstatic_field(G1CollectedHeap, _hrm,                G1HeapRegionManager)  \\\n@@ -60,2 +60,2 @@\n-  nonstatic_field(G1CollectedHeap, _old_set,            HeapRegionSetBase)    \\\n-  nonstatic_field(G1CollectedHeap, _humongous_set,      HeapRegionSetBase)    \\\n+  nonstatic_field(G1CollectedHeap, _old_set,            G1HeapRegionSetBase)  \\\n+  nonstatic_field(G1CollectedHeap, _humongous_set,      G1HeapRegionSetBase)  \\\n@@ -70,1 +70,1 @@\n-  nonstatic_field(HeapRegionSetBase,   _length,         uint)                 \\\n+  nonstatic_field(G1HeapRegionSetBase,   _length,       uint)                 \\\n@@ -77,8 +77,8 @@\n-  declare_constant(HeapRegionType::FreeTag)                                   \\\n-  declare_constant(HeapRegionType::YoungMask)                                 \\\n-  declare_constant(HeapRegionType::EdenTag)                                   \\\n-  declare_constant(HeapRegionType::SurvTag)                                   \\\n-  declare_constant(HeapRegionType::HumongousMask)                             \\\n-  declare_constant(HeapRegionType::StartsHumongousTag)                        \\\n-  declare_constant(HeapRegionType::ContinuesHumongousTag)                     \\\n-  declare_constant(HeapRegionType::OldMask)                                   \\\n+  declare_constant(G1HeapRegionType::FreeTag)                                 \\\n+  declare_constant(G1HeapRegionType::YoungMask)                               \\\n+  declare_constant(G1HeapRegionType::EdenTag)                                 \\\n+  declare_constant(G1HeapRegionType::SurvTag)                                 \\\n+  declare_constant(G1HeapRegionType::HumongousMask)                           \\\n+  declare_constant(G1HeapRegionType::StartsHumongousTag)                      \\\n+  declare_constant(G1HeapRegionType::ContinuesHumongousTag)                   \\\n+  declare_constant(G1HeapRegionType::OldMask)                                 \\\n@@ -97,2 +97,2 @@\n-  declare_toplevel_type(HeapRegionManager)                                    \\\n-  declare_toplevel_type(HeapRegionSetBase)                                    \\\n+  declare_toplevel_type(G1HeapRegionManager)                                  \\\n+  declare_toplevel_type(G1HeapRegionSetBase)                                  \\\n@@ -101,1 +101,1 @@\n-  declare_toplevel_type(HeapRegionType)                                       \\\n+  declare_toplevel_type(G1HeapRegionType)                                     \\\n@@ -109,1 +109,1 @@\n-  declare_integer_type(HeapRegionType::Tag volatile)\n+  declare_integer_type(G1HeapRegionType::Tag volatile)\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  _heap_start = 0;\n+  _heap_start = nullptr;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -444,5 +444,1 @@\n-  \/\/ The do_full_collection() parameter clear_all_soft_refs\n-  \/\/ is interpreted here as maximum_compaction which will\n-  \/\/ cause SoftRefs to be cleared.\n-  bool maximum_compaction = clear_all_soft_refs;\n-  PSParallelCompact::invoke(maximum_compaction);\n+  PSParallelCompact::invoke(clear_all_soft_refs);\n@@ -664,1 +660,1 @@\n-  return 0;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  if (vspace != 0) {\n+  if (vspace != nullptr) {\n@@ -250,1 +250,1 @@\n-  return 0;\n+  return nullptr;\n@@ -259,1 +259,1 @@\n-  if (_region_vspace != 0) {\n+  if (_region_vspace != nullptr) {\n@@ -830,4 +830,10 @@\n-bool PSParallelCompact::reassess_maximum_compaction(bool maximum_compaction,\n-                                                    size_t total_live_words,\n-                                                    MutableSpace* const old_space,\n-                                                    HeapWord* full_region_prefix_end) {\n+bool PSParallelCompact::check_maximum_compaction(size_t total_live_words,\n+                                                 MutableSpace* const old_space,\n+                                                 HeapWord* full_region_prefix_end) {\n+\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+\n+  \/\/ Check System.GC\n+  bool is_max_on_system_gc = UseMaximumCompactionOnSystemGC\n+                          && GCCause::is_user_requested_gc(heap->gc_cause());\n+\n@@ -838,1 +844,1 @@\n-  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n+  const uint total_invocations = heap->total_full_collections();\n@@ -847,1 +853,1 @@\n-  if (maximum_compaction || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n+  if (is_max_on_system_gc || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n@@ -855,1 +861,1 @@\n-void PSParallelCompact::summary_phase(bool maximum_compaction)\n+void PSParallelCompact::summary_phase()\n@@ -878,4 +884,3 @@\n-    maximum_compaction = reassess_maximum_compaction(maximum_compaction,\n-                                                     total_live_words,\n-                                                     old_space,\n-                                                     full_region_prefix_end);\n+    bool maximum_compaction = check_maximum_compaction(total_live_words,\n+                                                       old_space,\n+                                                       full_region_prefix_end);\n@@ -962,1 +967,1 @@\n-bool PSParallelCompact::invoke(bool maximum_heap_compaction) {\n+bool PSParallelCompact::invoke(bool clear_all_soft_refs) {\n@@ -967,3 +972,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  assert(!heap->is_stw_gc_active(), \"not reentrant\");\n-\n@@ -972,2 +974,3 @@\n-  const bool clear_all_soft_refs =\n-    heap->soft_ref_policy()->should_clear_all_soft_refs();\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+  clear_all_soft_refs = clear_all_soft_refs\n+                     || heap->soft_ref_policy()->should_clear_all_soft_refs();\n@@ -975,2 +978,1 @@\n-  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||\n-                                             maximum_heap_compaction);\n+  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs);\n@@ -981,1 +983,1 @@\n-bool PSParallelCompact::invoke_no_policy(bool maximum_heap_compaction) {\n+bool PSParallelCompact::invoke_no_policy(bool clear_all_soft_refs) {\n@@ -1002,1 +1004,1 @@\n-  ClearedAllSoftRefs casr(maximum_heap_compaction,\n+  ClearedAllSoftRefs casr(clear_all_soft_refs,\n@@ -1037,1 +1039,1 @@\n-    ref_processor()->start_discovery(maximum_heap_compaction);\n+    ref_processor()->start_discovery(clear_all_soft_refs);\n@@ -1045,3 +1047,1 @@\n-    bool max_on_system_gc = UseMaximumCompactionOnSystemGC\n-      && GCCause::is_user_requested_gc(gc_cause);\n-    summary_phase(maximum_heap_compaction || max_on_system_gc);\n+    summary_phase();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -726,4 +726,3 @@\n-  static bool reassess_maximum_compaction(bool maximum_compaction,\n-                                          size_t total_live_words,\n-                                          MutableSpace* const old_space,\n-                                          HeapWord* full_region_prefix_end);\n+  static bool check_maximum_compaction(size_t total_live_words,\n+                                       MutableSpace* const old_space,\n+                                       HeapWord* full_region_prefix_end);\n@@ -742,1 +741,1 @@\n-  static void summary_phase(bool maximum_compaction);\n+  static void summary_phase();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -252,4 +252,0 @@\n-  \/\/ Parallel GC claims with a release - so other threads might access this object\n-  \/\/ after claiming and they should see the \"completed\" object.\n-  ContinuationGCSupport::transform_stack_chunk(new_obj);\n-\n@@ -274,0 +270,2 @@\n+    ContinuationGCSupport::transform_stack_chunk(new_obj);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -238,1 +238,0 @@\n-  PSAdaptiveSizePolicy* policy = heap->size_policy();\n@@ -253,2 +252,1 @@\n-    SoftRefPolicy* srp = heap->soft_ref_policy();\n-    const bool clear_all_softrefs = srp->should_clear_all_soft_refs();\n+    const bool clear_all_softrefs = heap->soft_ref_policy()->should_clear_all_soft_refs();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-    _should_allocate_from_space(false),\n@@ -537,5 +536,0 @@\n-size_t DefNewGeneration::contiguous_available() const {\n-  return eden()->free();\n-}\n-\n-\n@@ -581,27 +575,0 @@\n-\/\/ The last collection bailed out, we are running out of heap space,\n-\/\/ so we try to allocate the from-space, too.\n-HeapWord* DefNewGeneration::allocate_from_space(size_t size) {\n-  bool should_try_alloc = should_allocate_from_space() || GCLocker::is_active_and_needs_gc();\n-\n-  \/\/ If the Heap_lock is not locked by this thread, this will be called\n-  \/\/ again later with the Heap_lock held.\n-  bool do_alloc = should_try_alloc && (Heap_lock->owned_by_self() || (SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread()));\n-\n-  HeapWord* result = nullptr;\n-  if (do_alloc) {\n-    result = from()->allocate(size);\n-  }\n-\n-  log_trace(gc, alloc)(\"DefNewGeneration::allocate_from_space(\" SIZE_FORMAT \"):  will_fail: %s  heap_lock: %s  free: \" SIZE_FORMAT \"%s%s returns %s\",\n-                        size,\n-                        SerialHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n-                          \"true\" : \"false\",\n-                        Heap_lock->is_locked() ? \"locked\" : \"unlocked\",\n-                        from()->free(),\n-                        should_try_alloc ? \"\" : \"  should_allocate_from_space: NOT\",\n-                        do_alloc ? \"  Heap_lock is not owned by self\" : \"\",\n-                        result == nullptr ? \"null\" : \"object\");\n-\n-  return result;\n-}\n-\n@@ -710,2 +677,0 @@\n-\n-    assert(!heap->incremental_collection_failed(), \"Should be clear\");\n@@ -718,7 +683,0 @@\n-    \/\/ Add to-space to the list of space to compact\n-    \/\/ when a promotion failure has occurred.  In that\n-    \/\/ case there can be live objects in to-space\n-    \/\/ as a result of a partial evacuation of eden\n-    \/\/ and from-space.\n-    swap_spaces();   \/\/ For uniformity wrt ParNewGeneration.\n-    heap->set_incremental_collection_failed();\n@@ -807,1 +765,1 @@\n-    obj = _old_gen->promote(old, s);\n+    obj = _old_gen->allocate_for_promotion(old, s);\n@@ -813,2 +771,0 @@\n-    ContinuationGCSupport::transform_stack_chunk(obj);\n-\n@@ -816,4 +772,5 @@\n-  } else {\n-    \/\/ Prefetch beyond obj\n-    const intx interval = PrefetchCopyIntervalInBytes;\n-    Prefetch::write(obj, interval);\n+  }\n+\n+  \/\/ Prefetch beyond obj\n+  const intx interval = PrefetchCopyIntervalInBytes;\n+  Prefetch::write(obj, interval);\n@@ -821,2 +778,2 @@\n-    \/\/ Copy obj\n-    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), s);\n+  \/\/ Copy obj\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), s);\n@@ -824,1 +781,1 @@\n-    ContinuationGCSupport::transform_stack_chunk(obj);\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n@@ -826,0 +783,1 @@\n+  if (!new_obj_is_tenured) {\n@@ -874,11 +832,0 @@\n-bool DefNewGeneration::collection_attempt_is_safe() {\n-  if (!to()->is_empty()) {\n-    log_trace(gc)(\":: to is not empty ::\");\n-    return false;\n-  }\n-  if (_old_gen == nullptr) {\n-    _old_gen = SerialHeap::heap()->old_gen();\n-  }\n-  return _old_gen->promotion_attempt_is_safe(used());\n-}\n-\n@@ -886,2 +833,0 @@\n-  DEBUG_ONLY(static bool seen_incremental_collection_failed = false;)\n-\n@@ -889,39 +834,0 @@\n-  \/\/ Check if the heap is approaching full after a collection has\n-  \/\/ been done.  Generally the young generation is empty at\n-  \/\/ a minimum at the end of a collection.  If it is not, then\n-  \/\/ the heap is approaching full.\n-  SerialHeap* gch = SerialHeap::heap();\n-  if (full) {\n-    DEBUG_ONLY(seen_incremental_collection_failed = false;)\n-    if (!collection_attempt_is_safe() && !_eden_space->is_empty()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, not safe, set_failed, set_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->set_incremental_collection_failed(); \/\/ Slight lie: a full gc left us in that state\n-      set_should_allocate_from_space(); \/\/ we seem to be running out of space\n-    } else {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, safe, clear_failed, clear_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->clear_incremental_collection_failed(); \/\/ We just did a full collection\n-      clear_should_allocate_from_space(); \/\/ if set\n-    }\n-  } else {\n-#ifdef ASSERT\n-    \/\/ It is possible that incremental_collection_failed() == true\n-    \/\/ here, because an attempted scavenge did not succeed. The policy\n-    \/\/ is normally expected to cause a full collection which should\n-    \/\/ clear that condition, so we should not be here twice in a row\n-    \/\/ with incremental_collection_failed() == true without having done\n-    \/\/ a full collection in between.\n-    if (!seen_incremental_collection_failed &&\n-        gch->incremental_collection_failed()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, not_seen_failed, failed, set_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = true;\n-    } else if (seen_incremental_collection_failed) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, seen_failed, will_clear_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = false;\n-    }\n-#endif \/\/ ASSERT\n-  }\n-\n@@ -930,1 +836,1 @@\n-  gch->counters()->update_counters();\n+  SerialHeap::heap()->counters()->update_counters();\n@@ -970,7 +876,0 @@\n-  if (result == nullptr) {\n-    \/\/ If the eden is full and the last collection bailed out, we are running\n-    \/\/ out of heap space, and we try to allocate the from-space, too.\n-    \/\/ allocate_from_space can't be inlined because that would introduce a\n-    \/\/ circular dependency at compile time.\n-    result = allocate_from_space(word_size);\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":11,"deletions":112,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-class ScanWeakRefClosure;\n@@ -122,12 +121,0 @@\n-  \/\/ Allocation support\n-  bool _should_allocate_from_space;\n-  bool should_allocate_from_space() const {\n-    return _should_allocate_from_space;\n-  }\n-  void clear_should_allocate_from_space() {\n-    _should_allocate_from_space = false;\n-  }\n-  void set_should_allocate_from_space() {\n-    _should_allocate_from_space = true;\n-  }\n-\n@@ -188,2 +175,0 @@\n-  size_t contiguous_available() const;\n-\n@@ -228,1 +213,0 @@\n-  HeapWord* allocate_from_space(size_t word_size);\n@@ -244,7 +228,0 @@\n-  \/\/ Returns true if the collection is likely to be safely\n-  \/\/ completed. Even if this method returns true, a collection\n-  \/\/ may not be guaranteed to succeed, and the system should be\n-  \/\/ able to safely unwind and recover from that failure, albeit\n-  \/\/ at some additional cost.\n-  bool collection_attempt_is_safe();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -99,4 +99,0 @@\n-  \/\/ The largest number of contiguous free bytes in the generation,\n-  \/\/ including expansion  (Assumes called at a safepoint.)\n-  virtual size_t contiguous_available() const = 0;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-    _incremental_collection_failed(false),\n@@ -290,2 +289,1 @@\n-         || GCLocker::is_active_and_needs_gc()\n-         || incremental_collection_failed();\n+         || GCLocker::is_active_and_needs_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-public:\n@@ -78,5 +77,0 @@\n-  enum GenerationType {\n-    YoungGen,\n-    OldGen\n-  };\n-\n@@ -94,5 +88,0 @@\n-  \/\/ Indicates that the most recent previous incremental collection failed.\n-  \/\/ The flag is cleared when an action is taken that might clear the\n-  \/\/ condition that caused that incremental collection to fail.\n-  bool _incremental_collection_failed;\n-\n@@ -132,1 +121,0 @@\n-  bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }\n@@ -258,23 +246,0 @@\n-  \/\/ Returns true if an incremental collection is likely to fail.\n-  \/\/ We optionally consult the young gen, if asked to do so;\n-  \/\/ otherwise we base our answer on whether the previous incremental\n-  \/\/ collection attempt failed with no corrective action as of yet.\n-  bool incremental_collection_will_fail(bool consult_young) {\n-    \/\/ The first disjunct remembers if an incremental collection failed, even\n-    \/\/ when we thought (second disjunct) that it would not.\n-    return incremental_collection_failed() ||\n-           (consult_young && !_young_gen->collection_attempt_is_safe());\n-  }\n-\n-  \/\/ If a generation bails out of an incremental collection,\n-  \/\/ it sets this flag.\n-  bool incremental_collection_failed() const {\n-    return _incremental_collection_failed;\n-  }\n-  void set_incremental_collection_failed() {\n-    _incremental_collection_failed = true;\n-  }\n-  void clear_incremental_collection_failed() {\n-    _incremental_collection_failed = false;\n-  }\n-\n@@ -292,1 +257,0 @@\n-private:\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-  size_t available = contiguous_available();\n+  size_t available = _the_space->free() + _virtual_space.uncommitted_size();\n@@ -390,1 +390,1 @@\n-oop TenuredGeneration::promote(oop obj, size_t obj_size) {\n+oop TenuredGeneration::allocate_for_promotion(oop obj, size_t obj_size) {\n@@ -404,3 +404,0 @@\n-    if (result == nullptr) {\n-      return nullptr;\n-    }\n@@ -409,4 +406,1 @@\n-  \/\/ Copy to new location.\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), result, obj_size);\n-  oop new_obj = cast_to_oop<HeapWord*>(result);\n-  return new_obj;\n+  return cast_to_oop<HeapWord*>(result);\n@@ -422,4 +416,0 @@\n-size_t TenuredGeneration::contiguous_available() const {\n-  return _the_space->free() + _virtual_space.uncommitted_size();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -127,2 +127,0 @@\n-  size_t contiguous_available() const;\n-\n@@ -166,2 +164,1 @@\n-  \/\/ in the old-gen, and copy \"obj\" into the newly allocated space, if\n-  \/\/ possible, returning the result (or null if the allocation failed).\n+  \/\/ in the old-gen, returning the result (or null if the allocation failed).\n@@ -171,1 +168,1 @@\n-  oop promote(oop obj, size_t obj_size);\n+  oop allocate_for_promotion(oop obj, size_t obj_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -181,8 +181,0 @@\n-  \/\/ Check for disarmed method here to avoid going into DeoptimizeNMethodBarriersALot code\n-  \/\/ too often. nmethod_entry_barrier checks for disarmed status itself,\n-  \/\/ but we have no visibility into whether the barrier acted or not.\n-  if (!bs_nm->is_armed(nm)) {\n-    return 0;\n-  }\n-\n-  assert(!nm->is_osr_method(), \"Should not reach here\");\n@@ -191,0 +183,1 @@\n+  assert(!nm->is_osr_method() || may_enter, \"OSR nmethods should always be entrant after migration\");\n@@ -200,1 +193,1 @@\n-  \/\/ Diagnostic option to force deoptimization 1 in 3 times. It is otherwise\n+  \/\/ Diagnostic option to force deoptimization 1 in 10 times. It is otherwise\n@@ -202,1 +195,1 @@\n-  if (DeoptimizeNMethodBarriersALot) {\n+  if (DeoptimizeNMethodBarriersALot && !nm->is_osr_method()) {\n@@ -204,1 +197,1 @@\n-    if (Atomic::add(&counter, 1u) % 3 == 0) {\n+    if (Atomic::add(&counter, 1u) % 10 == 0) {\n@@ -217,9 +210,0 @@\n-  \/\/ This check depends on the invariant that all nmethods that are deoptimized \/ made not entrant\n-  \/\/ are NOT disarmed.\n-  \/\/ This invariant is important because a method can be deoptimized after the method have been\n-  \/\/ resolved \/ looked up by OSR by another thread. By not deoptimizing them we guarantee that\n-  \/\/ a deoptimized method will always hit the barrier and come to the same conclusion - deoptimize\n-  if (!is_armed(nm)) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -43,1 +43,5 @@\n-\n+  if (is_full_gc) {\n+    \/\/ Explicit Full GC would do the clearing of soft-refs as well\n+    \/\/ So reset in the beginning\n+    soft_ref_policy->set_should_clear_all_soft_refs(false);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcOverheadChecker.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -156,4 +156,1 @@\n-  {\n-    ShenandoahHeapLocker locker(heap->lock());\n-    heap->free_set()->log_status();\n-  }\n+  heap->free_set()->log_status_under_lock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -150,4 +150,1 @@\n-      {\n-        ShenandoahHeapLocker locker(heap->lock());\n-        heap->free_set()->log_status();\n-      }\n+      heap->free_set()->log_status_under_lock();\n@@ -181,3 +178,1 @@\n-      {\n-        ShenandoahHeapLocker locker(heap->lock());\n-        heap->free_set()->log_status();\n+      heap->free_set()->log_status_under_lock();\n@@ -185,4 +180,4 @@\n-        \/\/ Notify Universe about new heap usage. This has implications for\n-        \/\/ global soft refs policy, and we better report it every time heap\n-        \/\/ usage goes down.\n-        heap->update_capacity_and_used_at_gc();\n+      \/\/ Notify Universe about new heap usage. This has implications for\n+      \/\/ global soft refs policy, and we better report it every time heap\n+      \/\/ usage goes down.\n+      heap->update_capacity_and_used_at_gc();\n@@ -190,3 +185,2 @@\n-        \/\/ Signal that we have completed a visit to all live objects.\n-        heap->record_whole_heap_examined_timestamp();\n-      }\n+      \/\/ Signal that we have completed a visit to all live objects.\n+      heap->record_whole_heap_examined_timestamp();\n@@ -327,1 +321,2 @@\n-    \/\/ Cycle is complete\n+    \/\/ Cycle is complete.  There were no failed allocation requests and no degeneration, so count this as good progress.\n+    heap->notify_gc_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-    heap->notify_gc_no_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1133,0 +1133,10 @@\n+void ShenandoahFreeSet::log_status_under_lock() {\n+  \/\/ Must not be heap locked, it acquires heap lock only when log is enabled\n+  shenandoah_assert_not_heaplocked();\n+  if (LogTarget(Info, gc, free)::is_enabled()\n+      DEBUG_ONLY(|| LogTarget(Debug, gc, free)::is_enabled())) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    log_status();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -321,0 +321,3 @@\n+  \/\/ log status, assuming lock has already been acquired by the caller.\n+  void log_status();\n+\n@@ -343,1 +346,2 @@\n-  void log_status();\n+  \/\/ Acquire heap lock and log status, assuming heap lock is not acquired by the caller.\n+  void log_status_under_lock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -948,18 +948,30 @@\n-    \/\/ Block until control thread reacted, then retry allocation.\n-    \/\/\n-    \/\/ It might happen that one of the threads requesting allocation would unblock\n-    \/\/ way later after GC happened, only to fail the second allocation, because\n-    \/\/ other threads have already depleted the free storage. In this case, a better\n-    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n-    \/\/ one full GC has completed).\n-    size_t original_count = shenandoah_policy()->full_gc_count();\n-    while (result == nullptr\n-        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req, true);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n-\n-    if (log_is_enabled(Debug, gc, alloc)) {\n-      ResourceMark rm;\n-      log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n-                           Thread::current()->name(), p2i(result), req.type_string(), req.size(), original_count, get_gc_no_progress_count());\n+    if (result == nullptr) {\n+      \/\/ Block until control thread reacted, then retry allocation.\n+      \/\/\n+      \/\/ It might happen that one of the threads requesting allocation would unblock\n+      \/\/ way later after GC happened, only to fail the second allocation, because\n+      \/\/ other threads have already depleted the free storage. In this case, a better\n+      \/\/ strategy is to try again, until at least one full GC has completed.\n+      \/\/\n+      \/\/ Stop retrying and return nullptr to cause OOMError exception if our allocation failed even after:\n+      \/\/   a) We experienced a GC that had good progress, or\n+      \/\/   b) We experienced at least one Full GC (whether or not it had good progress)\n+      \/\/\n+      \/\/ TODO: Consider GLOBAL GC rather than Full GC to remediate OOM condition: https:\/\/bugs.openjdk.org\/browse\/JDK-8335910\n+\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req, true);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+      if (result != nullptr) {\n+        \/\/ If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        notify_gc_progress();\n+      }\n+      if (log_is_enabled(Debug, gc, alloc)) {\n+        ResourceMark rm;\n+        log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT\n+                             \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n+                             Thread::current()->name(), p2i(result), req.type_string(), req.size(),\n+                             original_count, get_gc_no_progress_count());\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":30,"deletions":18,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  \/\/ Spin this much on multi-processor, do not spin on multi-processor.\n+  \/\/ Spin this much, but only on multi-processor systems.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-    return 0;\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,0 +153,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsContainerized(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1022,1 +1022,0 @@\n-  ConstantPoolCache* cache = pool->cache();\n@@ -1047,0 +1046,7 @@\n+  update_invoke_cp_cache_entry(info, bytecode, resolved_method, pool, method_index);\n+}\n+\n+void InterpreterRuntime::update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                                      methodHandle& resolved_method,\n+                                                      constantPoolHandle& pool,\n+                                                      int method_index) {\n@@ -1051,0 +1057,1 @@\n+  ConstantPoolCache* cache = pool->cache();\n@@ -1102,0 +1109,27 @@\n+void InterpreterRuntime::cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                            constantPoolHandle& pool, TRAPS) {\n+  LinkInfo link_info(pool, method_index, bytecode, CHECK);\n+\n+  if (!link_info.resolved_klass()->is_instance_klass() || InstanceKlass::cast(link_info.resolved_klass())->is_linked()) {\n+    CallInfo call_info;\n+    switch (bytecode) {\n+      case Bytecodes::_invokevirtual:   LinkResolver::cds_resolve_virtual_call  (call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokeinterface: LinkResolver::cds_resolve_interface_call(call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokespecial:   LinkResolver::cds_resolve_special_call  (call_info, link_info, CHECK); break;\n+\n+      default: fatal(\"Unimplemented: %s\", Bytecodes::name(bytecode));\n+    }\n+    methodHandle resolved_method(THREAD, call_info.resolved_method());\n+    guarantee(resolved_method->method_holder()->is_linked(), \"\");\n+    update_invoke_cp_cache_entry(call_info, bytecode, resolved_method, pool, method_index);\n+  } else {\n+    \/\/ FIXME: why a shared class is not linked yet?\n+    \/\/ Can't link it here since there are no guarantees it'll be prelinked on the next run.\n+    ResourceMark rm;\n+    InstanceKlass* resolved_iklass = InstanceKlass::cast(link_info.resolved_klass());\n+    log_info(cds, resolve)(\"Not resolved: class not linked: %s %s %s\",\n+                           resolved_iklass->is_shared() ? \"is_shared\" : \"\",\n+                           resolved_iklass->init_state_name(),\n+                           resolved_iklass->external_name());\n+  }\n+}\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  \/\/ Used by ClassListParser.\n+  \/\/ Used by ClassPrelinker\n@@ -109,0 +109,2 @@\n+  static void cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                 constantPoolHandle& pool, TRAPS);\n@@ -119,0 +121,3 @@\n+  static void update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                           methodHandle& resolved_method,\n+                                           constantPoolHandle& pool, int method_index);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,1 +145,3 @@\n-  assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  if (selected_method.not_null()) {\n+    assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  }\n@@ -154,1 +156,3 @@\n-  CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  if (selected_method.not_null()) {\n+    CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  }\n@@ -1156,0 +1160,4 @@\n+void LinkResolver::cds_resolve_special_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  resolve_special_call(result, Handle(), link_info, CHECK);\n+}\n+\n@@ -1339,1 +1347,11 @@\n-                                 check_null_and_abstract, CHECK);\n+                                 check_null_and_abstract,\n+                                 \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_virtual_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);\n+  runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),\n+                                 link_info.resolved_klass(),\n+                                 Handle(), nullptr,\n+                                 \/*check_null_and_abstract*\/ false,\n+                                 \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1391,0 +1409,1 @@\n+                                                  bool is_abstract_interpretation,\n@@ -1392,0 +1411,3 @@\n+  \/\/ is_abstract_interpretation is true IFF CDS is resolving method references without\n+  \/\/ running any actual bytecode. Therefore, we don't have an actual recv\/recv_klass, so\n+  \/\/ we cannot check the actual selected_method (which is not needed by CDS anyway).\n@@ -1412,1 +1434,3 @@\n-    selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    if (!is_abstract_interpretation) {\n+      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    }\n@@ -1426,1 +1450,3 @@\n-      selected_method = resolved_method;\n+      if (!is_abstract_interpretation) {\n+        selected_method = resolved_method;\n+      }\n@@ -1428,1 +1454,3 @@\n-      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      if (!is_abstract_interpretation) {\n+        selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      }\n@@ -1432,4 +1460,5 @@\n-  \/\/ check if method exists\n-  if (selected_method.is_null()) {\n-    throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n-  }\n+  if (!is_abstract_interpretation) {\n+    \/\/ check if method exists\n+    if (selected_method.is_null()) {\n+      throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n+    }\n@@ -1437,5 +1466,5 @@\n-  \/\/ check if abstract\n-  if (check_null_and_abstract && selected_method->is_abstract()) {\n-    \/\/ Pass arguments for generating a verbose error message.\n-    throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n-  }\n+    \/\/ check if abstract\n+    if (check_null_and_abstract && selected_method->is_abstract()) {\n+      \/\/ Pass arguments for generating a verbose error message.\n+      throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n+    }\n@@ -1443,4 +1472,5 @@\n-  if (log_develop_is_enabled(Trace, vtables)) {\n-    trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n-                            recv_klass, resolved_klass, selected_method(),\n-                            false, vtable_index);\n+    if (log_develop_is_enabled(Trace, vtables)) {\n+      trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n+                              recv_klass, resolved_klass, selected_method(),\n+                              false, vtable_index);\n+    }\n@@ -1448,0 +1478,1 @@\n+\n@@ -1450,1 +1481,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (selected_method.not_null()) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n@@ -1460,1 +1493,10 @@\n-                                   recv, recv_klass, check_null_and_abstract, CHECK);\n+                                   recv, recv_klass, check_null_and_abstract,\n+                                   \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);\n+  runtime_resolve_interface_method(result, methodHandle(THREAD, resolved_method), link_info.resolved_klass(),\n+                                   Handle(), nullptr,\n+                                   \/*check_null_and_abstract*\/ false,\n+                                   \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1479,1 +1521,3 @@\n-                                                    bool check_null_and_abstract, TRAPS) {\n+                                                    bool check_null_and_abstract,\n+                                                    bool is_abstract_interpretation, TRAPS) {\n+  \/\/ is_abstract_interpretation -- see comments in runtime_resolve_virtual_method()\n@@ -1487,1 +1531,1 @@\n-  if (!recv_klass->is_subtype_of(resolved_klass)) {\n+  if (!is_abstract_interpretation && !recv_klass->is_subtype_of(resolved_klass)) {\n@@ -1496,1 +1540,5 @@\n-  methodHandle selected_method = resolved_method;\n+  methodHandle selected_method;\n+\n+  if (!is_abstract_interpretation) {\n+    selected_method = resolved_method;\n+  }\n@@ -1499,1 +1547,1 @@\n-  if (!resolved_method()->is_private()) {\n+  if (!is_abstract_interpretation && !resolved_method()->is_private()) {\n@@ -1545,1 +1593,1 @@\n-    assert(vtable_index == selected_method->vtable_index(), \"sanity check\");\n+    assert(is_abstract_interpretation || vtable_index == selected_method->vtable_index(), \"sanity check\");\n@@ -1562,1 +1610,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (!is_abstract_interpretation) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":77,"deletions":27,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -245,1 +245,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -251,1 +252,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -328,0 +330,4 @@\n+  static void cds_resolve_virtual_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_special_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,3 +69,0 @@\n-#ifdef ASSERT\n-    _resource_allocate_bit_mask = false;\n-#endif\n@@ -180,3 +177,7 @@\n-#ifdef ASSERT\n-  _resource_allocate_bit_mask = true;\n-#endif\n+}\n+\n+InterpreterOopMap::~InterpreterOopMap() {\n+  if (has_valid_mask() && mask_size() > small_mask_limit) {\n+    assert(_bit_mask[0] != 0, \"should have pointer to C heap\");\n+    FREE_C_HEAP_ARRAY(uintptr_t, _bit_mask[0]);\n+  }\n@@ -402,5 +403,5 @@\n-void InterpreterOopMap::resource_copy(OopMapCacheEntry* from) {\n-  assert(_resource_allocate_bit_mask,\n-    \"Should not resource allocate the _bit_mask\");\n-  assert(from->has_valid_mask(),\n-    \"Cannot copy entry with an invalid mask\");\n+void InterpreterOopMap::copy_from(const OopMapCacheEntry* src) {\n+  \/\/ The expectation is that this InterpreterOopMap is recently created\n+  \/\/ and empty. It is used to get a copy of a cached entry.\n+  assert(!has_valid_mask(), \"InterpreterOopMap object can only be filled once\");\n+  assert(src->has_valid_mask(), \"Cannot copy entry with an invalid mask\");\n@@ -408,5 +409,5 @@\n-  set_method(from->method());\n-  set_bci(from->bci());\n-  set_mask_size(from->mask_size());\n-  set_expression_stack_size(from->expression_stack_size());\n-  _num_oops = from->num_oops();\n+  set_method(src->method());\n+  set_bci(src->bci());\n+  set_mask_size(src->mask_size());\n+  set_expression_stack_size(src->expression_stack_size());\n+  _num_oops = src->num_oops();\n@@ -415,3 +416,2 @@\n-  if (from->mask_size() <= small_mask_limit) {\n-    memcpy((void *)_bit_mask, (void *)from->_bit_mask,\n-      mask_word_size() * BytesPerWord);\n+  if (src->mask_size() <= small_mask_limit) {\n+    memcpy(_bit_mask, src->_bit_mask, mask_word_size() * BytesPerWord);\n@@ -419,14 +419,2 @@\n-    \/\/ The expectation is that this InterpreterOopMap is a recently created\n-    \/\/ and empty. It is used to get a copy of a cached entry.\n-    \/\/ If the bit mask has a value, it should be in the\n-    \/\/ resource area.\n-    assert(_bit_mask[0] == 0 ||\n-      Thread::current()->resource_area()->contains((void*)_bit_mask[0]),\n-      \"The bit mask should have been allocated from a resource area\");\n-    \/\/ Allocate the bit_mask from a Resource area for performance.  Allocating\n-    \/\/ from the C heap as is done for OopMapCache has a significant\n-    \/\/ performance impact.\n-    _bit_mask[0] = (uintptr_t) NEW_RESOURCE_ARRAY(uintptr_t, mask_word_size());\n-    assert(_bit_mask[0] != 0, \"bit mask was not allocated\");\n-    memcpy((void*) _bit_mask[0], (void*) from->_bit_mask[0],\n-      mask_word_size() * BytesPerWord);\n+    _bit_mask[0] = (uintptr_t) NEW_C_HEAP_ARRAY(uintptr_t, mask_word_size(), mtClass);\n+    memcpy((void*) _bit_mask[0], (void*) src->_bit_mask[0], mask_word_size() * BytesPerWord);\n@@ -448,2 +436,1 @@\n-  _array  = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);\n-  for(int i = 0; i < _size; i++) _array[i] = nullptr;\n+  for(int i = 0; i < size; i++) _array[i] = nullptr;\n@@ -454,1 +441,0 @@\n-  assert(_array != nullptr, \"sanity check\");\n@@ -457,2 +443,0 @@\n-  \/\/ Deallocate array\n-  FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);\n@@ -462,1 +446,1 @@\n-  return Atomic::load_acquire(&(_array[i % _size]));\n+  return Atomic::load_acquire(&(_array[i % size]));\n@@ -466,1 +450,1 @@\n-  return Atomic::cmpxchg(&_array[i % _size], old, entry) == old;\n+  return Atomic::cmpxchg(&_array[i % size], old, entry) == old;\n@@ -470,1 +454,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -481,1 +465,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -516,1 +500,1 @@\n-    for (int i = 0; i < _probe_depth; i++) {\n+    for (int i = 0; i < probe_depth; i++) {\n@@ -519,1 +503,1 @@\n-        entry_for->resource_copy(entry);\n+        entry_for->copy_from(entry);\n@@ -533,1 +517,1 @@\n-  entry_for->resource_copy(tmp);\n+  entry_for->copy_from(tmp);\n@@ -545,1 +529,1 @@\n-  for (int i = 0; i < _probe_depth; i++) {\n+  for (int i = 0; i < probe_depth; i++) {\n@@ -634,1 +618,1 @@\n-    entry->resource_copy(tmp);\n+    entry->copy_from(tmp);\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":32,"deletions":48,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-\/\/ bit_mask can fit into two words it is stored in\n+\/\/ bit_mask can fit into four words it is stored in\n@@ -43,3 +43,4 @@\n-\/\/ For InterpreterOopMap the bit_mask is allocated in\n-\/\/ a resource area for better performance.  InterpreterOopMap\n-\/\/ should only be created and deleted during same garbage collection.\n+\/\/ For InterpreterOopMap the bit_mask is allocated in the C heap\n+\/\/ to avoid issues with allocations from the resource area that have\n+\/\/ to live accross the oop closure. InterpreterOopMap should only be\n+\/\/ created and deleted during the same garbage collection.\n@@ -86,1 +87,0 @@\n-  unsigned short _bci;            \/\/ the bci    for which the mask is valid\n@@ -89,0 +89,1 @@\n+  unsigned short _bci;            \/\/ the bci    for which the mask is valid\n@@ -91,0 +92,1 @@\n+  int            _num_oops;\n@@ -97,4 +99,0 @@\n-  int            _num_oops;\n-#ifdef ASSERT\n-  bool _resource_allocate_bit_mask;\n-#endif\n@@ -131,0 +129,1 @@\n+  ~InterpreterOopMap();\n@@ -132,5 +131,5 @@\n-  \/\/ Copy the OopMapCacheEntry in parameter \"from\" into this\n-  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"from\" points to\n-  \/\/ allocated space (i.e., the bit mask was to large to hold\n-  \/\/ in-line), allocate the space from a Resource area.\n-  void resource_copy(OopMapCacheEntry* from);\n+  \/\/ Copy the OopMapCacheEntry in parameter \"src\" into this\n+  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"src\" points to\n+  \/\/ allocated space (i.e., the bit mask was too large to hold\n+  \/\/ in-line), allocate the space from the C heap.\n+  void copy_from(const OopMapCacheEntry* src);\n@@ -155,3 +154,2 @@\n-  enum { _size        = 32,     \/\/ Use fixed size for now\n-         _probe_depth = 3       \/\/ probe depth in case of collisions\n-  };\n+  static constexpr int size = 32;        \/\/ Use fixed size for now\n+  static constexpr int probe_depth = 3;  \/\/ probe depth in case of collisions\n@@ -159,1 +157,1 @@\n-  OopMapCacheEntry* volatile * _array;\n+  OopMapCacheEntry* volatile _array[size];\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-  } else {\n-    ++last;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  template(jdk_jfr_internal_HiddenWait,                               \"jdk\/jfr\/internal\/HiddenWait\")                 \\\n+  template(jdk_jfr_internal_management_HiddenWait,                    \"jdk\/jfr\/internal\/management\/HiddenWait\")      \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -900,1 +900,3 @@\n-      assert(cp->tag_at(index).is_unresolved_klass(), \"wrong tag\");\n+      if (!tag.is_unresolved_klass()) {\n+        JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Expected %d at index %d, got %d\", JVM_CONSTANT_UnresolvedClassInError, index, tag.value()));\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,4 @@\n+#ifdef X86\n+    static int L1_line_size;\n+#endif\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,0 +117,4 @@\n+#ifdef X86\n+int CompilerToVM::Data::L1_line_size;\n+#endif\n+\n@@ -243,0 +247,4 @@\n+#ifdef X86\n+  L1_line_size = VM_Version::L1_line_size();\n+#endif\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -115,0 +115,2 @@\n+  X86_ONLY(static_field(CompilerToVM::Data,    L1_line_size,                           int))                                         \\\n+                                                                                                                                     \\\n@@ -782,0 +784,1 @@\n+  declare_constant(vmIntrinsics::_linkToNative)                           \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,3 +120,0 @@\n-#ifdef ASSERT\n-  , _first_fence(nullptr)\n-#endif\n@@ -131,6 +128,0 @@\n-#ifdef ASSERT\n-  SOMETIMES(verify();)\n-  if (Settings::use_allocation_guard()) {\n-    verify_allocation_guards();\n-  }\n-#endif\n@@ -138,1 +129,0 @@\n-\n@@ -242,17 +232,0 @@\n-#ifdef ASSERT\n-  \/\/ Fence allocation\n-  if (p != nullptr && Settings::use_allocation_guard()) {\n-    STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n-    MetaWord* guard = allocate_inner(sizeof(Fence) \/ BytesPerWord);\n-    if (guard != nullptr) {\n-      \/\/ Ignore allocation errors for the fence to keep coding simple. If this\n-      \/\/ happens (e.g. because right at this time we hit the Metaspace GC threshold)\n-      \/\/ we miss adding this one fence. Not a big deal. Note that his would\n-      \/\/ be pretty rare. Chances are much higher the primary allocation above\n-      \/\/ would have already failed).\n-      Fence* f = new(guard) Fence(_first_fence);\n-      _first_fence = f;\n-    }\n-  }\n-#endif \/\/ ASSERT\n-\n@@ -430,12 +403,0 @@\n-void MetaspaceArena::Fence::verify() const {\n-  assert(_eye1 == EyeCatcher && _eye2 == EyeCatcher,\n-         \"Metaspace corruption: fence block at \" PTR_FORMAT \" broken.\", p2i(this));\n-}\n-\n-void MetaspaceArena::verify_allocation_guards() const {\n-  assert(Settings::use_allocation_guard(), \"Don't call with guards disabled.\");\n-  for (const Fence* f = _first_fence; f != nullptr; f = f->next()) {\n-    f->verify();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,22 +103,0 @@\n-#ifdef ASSERT\n-  \/\/ Allocation guards: When active, arena allocations are interleaved with\n-  \/\/  fence allocations. An overwritten fence indicates a buffer overrun in either\n-  \/\/  the preceding or the following user block. All fences are linked together;\n-  \/\/  validating the fences just means walking that linked list.\n-  \/\/ Note that for the Arena, fence blocks are just another form of user blocks.\n-  class Fence {\n-    static const uintx EyeCatcher =\n-      NOT_LP64(0x77698465) LP64_ONLY(0x7769846577698465ULL); \/\/ \"META\" resp \"METAMETA\"\n-    \/\/ Two eyecatchers to easily spot a corrupted _next pointer\n-    const uintx _eye1;\n-    const Fence* const _next;\n-    NOT_LP64(uintx _dummy;)\n-    const uintx _eye2;\n-  public:\n-    Fence(const Fence* next) : _eye1(EyeCatcher), _next(next), _eye2(EyeCatcher) {}\n-    const Fence* next() const { return _next; }\n-    void verify() const;\n-  };\n-  const Fence* _first_fence;\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.hpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-DEBUG_ONLY(bool Settings::_use_allocation_guard = false;)\n-\n@@ -49,3 +47,0 @@\n-  \/\/ Off for release builds, off by default - but switchable - for debug builds.\n-  DEBUG_ONLY(_use_allocation_guard = MetaspaceGuardAllocations;)\n-\n@@ -61,1 +56,0 @@\n-  st->print_cr(\" - use_allocation_guard: %d.\", (int)use_allocation_guard());\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSettings.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,0 @@\n-  \/\/ If true, metablock allocations are guarded and periodically checked.\n-  DEBUG_ONLY(static bool _use_allocation_guard;)\n-\n@@ -69,1 +66,0 @@\n-  static bool use_allocation_guard()                          { return DEBUG_ONLY(_use_allocation_guard) NOT_DEBUG(false); }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSettings.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-        AIX_ONLY(&& os::vm_page_size() != 64*K)) {\n+        AIX_ONLY(&& (os::Aix::supports_64K_mmap_pages() || os::vm_page_size() == 4*K))) {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"logging\/logAsyncWriter.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -163,7 +163,0 @@\n-\n-  void print_on(outputStream* st) const {\n-    for (size_t i = 0; i < _count; i ++) {\n-      st->print_cr(PTR_FORMAT \"-\" PTR_FORMAT \" %s\", p2i(_ranges[i].from), p2i(_ranges[i].to),\n-          NMTUtil::flag_to_enum_name(_flags[i]));\n-    }\n-  }\n@@ -201,1 +194,10 @@\n-  st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", (uintx)thread_id, name);\n+  \/\/ avoid commas and spaces in output to ease post-processing via awk\n+  char tmp[64];\n+  stringStream ss(tmp, sizeof(tmp));\n+  ss.print(\":\" UINTX_FORMAT \"-%s\", (uintx)thread_id, name);\n+  for (int i = 0; tmp[i] != '\\0'; i++) {\n+    if (!isalnum(tmp[i])) {\n+      tmp[i] = '-';\n+    }\n+  }\n+  st->print_raw(tmp);\n@@ -233,2 +235,6 @@\n-static void print_legend(outputStream* st) {\n-#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+MappingPrintSession::MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info) :\n+    _out(st), _nmt_info(nmt_info)\n+{}\n+\n+void MappingPrintSession::print_nmt_flag_legend() const {\n+#define DO(flag, shortname, text) _out->indent(); _out->print_cr(\"%10s: %s\", shortname, text);\n@@ -239,29 +245,2 @@\n-MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info) :\n-    _out(st), _human_readable(human_readable),\n-    _total_count(0), _total_vsize(0), _nmt_info(nmt_info)\n-{}\n-\n-void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n-\n-  _total_count++;\n-\n-  const void* const vma_from = info->from();\n-  const void* const vma_to = info->to();\n-\n-  \/\/ print from, to\n-  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(vma_from), p2i(vma_to));\n-  const size_t size = pointer_delta(vma_to, vma_from, 1);\n-  _total_vsize += size;\n-\n-  \/\/ print mapping size\n-  if (_human_readable) {\n-    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n-  } else {\n-    _out->print(\"%11zu\", size);\n-  }\n-\n-  assert(info->from() <= info->to(), \"Invalid VMA\");\n-  _out->fill_to(53);\n-  info->print_OS_specific_details(_out);\n-  _out->fill_to(70);\n-\n+bool MappingPrintSession::print_nmt_info_for_region(const void* vma_from, const void* vma_to) const {\n+  int num_printed = 0;\n@@ -276,0 +255,3 @@\n+          if (num_printed > 0) {\n+            _out->put(',');\n+          }\n@@ -280,1 +262,1 @@\n-          _out->print(\" \");\n+          num_printed++;\n@@ -285,21 +267,1 @@\n-\n-  \/\/ print file name, if available\n-  const char* f = info->filename();\n-  if (f != nullptr) {\n-    _out->print_raw(f);\n-  }\n-  _out->cr();\n-}\n-\n-void MemMapPrinter::print_header(outputStream* st) {\n-  st->print(\n-#ifdef _LP64\n-  \/\/   0x0000000000000000 - 0x0000000000000000\n-      \"from                 to                 \"\n-#else\n-  \/\/   0x00000000 - 0x00000000\n-      \"from         to         \"\n-#endif\n-  );\n-  \/\/ Print platform-specific columns\n-  pd_print_header(st);\n+  return num_printed > 0;\n@@ -308,2 +270,1 @@\n-void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n-  \/\/ First collect all NMT information\n+void MemMapPrinter::print_all_mappings(outputStream* st) {\n@@ -311,2 +272,0 @@\n-  nmt_info.fill_from_nmt();\n-  DEBUG_ONLY(nmt_info.print_on(st);)\n@@ -314,3 +273,6 @@\n-  if (!MemTracker::enabled()) {\n-    st->cr();\n-    st->print_cr(\" (NMT is disabled, will not annotate mappings).\");\n+  \/\/ Prepare NMT info cache. But only do so if we print individual mappings,\n+  \/\/ otherwise, we won't need it and can save that work.\n+  if (MemTracker::enabled()) {\n+    nmt_info.fill_from_nmt();\n+  } else {\n+    st->print_cr(\"NMT is disabled. VM info not available.\");\n@@ -318,11 +280,2 @@\n-  st->cr();\n-\n-  print_legend(st);\n-  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n-  st->cr();\n-\n-  pd_print_header(st);\n-  MappingPrintClosure closure(st, human_readable, nmt_info);\n-  pd_iterate_all_mappings(closure);\n-  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n-               closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+  MappingPrintSession session(st, nmt_info);\n+  pd_print_all_mappings(session);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":34,"deletions":81,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -38,14 +38,1 @@\n-class MappingPrintInformation {\n-  const void* const _from;\n-  const void* const _to;\n-public:\n-  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n-  const void* from() const { return _from; }\n-  const void* to() const { return _to; }\n-  \/\/ Will be called for each mapping before VM annotations are printed.\n-  virtual void print_OS_specific_details(outputStream* st) const {}\n-  \/\/ If mapping is backed by a file, the name of that file\n-  virtual const char* filename() const { return nullptr; }\n-};\n-\n-class MappingPrintClosure {\n+class MappingPrintSession {\n@@ -53,3 +40,0 @@\n-  const bool _human_readable;\n-  uintx _total_count;\n-  size_t _total_vsize;\n@@ -58,4 +42,4 @@\n-  MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info);\n-  void do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n-  uintx total_count() const { return _total_count; }\n-  size_t total_vsize() const { return _total_vsize; }\n+  MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info);\n+  bool print_nmt_info_for_region(const void* from, const void* to) const;\n+  void print_nmt_flag_legend() const;\n+  outputStream* out() const { return _out; }\n@@ -65,3 +49,1 @@\n-  static void pd_print_header(outputStream* st);\n-  static void print_header(outputStream* st);\n-  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+  static void pd_print_all_mappings(const MappingPrintSession& session);\n@@ -69,2 +51,1 @@\n-  static void mark_page_malloced(const void* p, MEMFLAGS f);\n-  static void print_all_mappings(outputStream* st, bool human_readable);\n+  static void print_all_mappings(outputStream* st);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -412,3 +413,1 @@\n-    for (int i = 0; i < _resolved_method_entries->length(); i++) {\n-      resolved_method_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_method_entries_if_non_deterministic();\n@@ -452,0 +451,90 @@\n+\n+void ConstantPoolCache::remove_resolved_method_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_method_entries->length(); i++) {\n+    ResolvedMethodEntry* rme = _resolved_method_entries->adr_at(i);\n+    int cp_index = rme->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rme->is_resolved(Bytecodes::_invokevirtual)   ||\n+                    rme->is_resolved(Bytecodes::_invokespecial)   ||\n+                    rme->is_resolved(Bytecodes::_invokeinterface);\n+\n+    \/\/ Just for safety -- this should not happen, but do not archive if we ever see this.\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n+                  rme->is_resolved(Bytecodes::_invokestatic));\n+\n+    if (resolved && can_archive_resolved_method(rme)) {\n+      rme->mark_and_relocate(src_cp);\n+      archived = true;\n+    } else {\n+      rme->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+        if (archived) {\n+          Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n+          log.print(\" => %s%s\",\n+                    resolved_klass->name()->as_C_string(),\n+                    (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n+        }\n+      }\n+      ArchiveBuilder::alloc_stats()->record_method_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+  InstanceKlass* pool_holder = constant_pool()->pool_holder();\n+  if (!(pool_holder->is_shared_boot_class() || pool_holder->is_shared_platform_class() ||\n+        pool_holder->is_shared_app_class())) {\n+    \/\/ Archiving resolved cp entries for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return false;\n+  }\n+\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    \/\/ InstanceKlass::methods() has been resorted. We need to\n+    \/\/ update the vtable_index in method_entry (not implemented)\n+    return false;\n+  }\n+\n+  if (!method_entry->is_resolved(Bytecodes::_invokevirtual)) {\n+    if (method_entry->method() == nullptr) {\n+      return false;\n+    }\n+    if (method_entry->method()->is_continuation_native_intrinsic()) {\n+      return false; \/\/ FIXME: corresponding stub is generated on demand during method resolution (see LinkResolver::resolve_static_call).\n+    }\n+  }\n+\n+  int cp_index = method_entry->constant_pool_index();\n+  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n+  assert(src_cp->tag_at(cp_index).is_method() || src_cp->tag_at(cp_index).is_interface_method(), \"sanity\");\n+\n+  if (!ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+    return false;\n+  }\n+\n+  if (method_entry->is_resolved(Bytecodes::_invokeinterface) ||\n+      method_entry->is_resolved(Bytecodes::_invokevirtual) ||\n+      method_entry->is_resolved(Bytecodes::_invokespecial)) {\n+    return true;\n+  } else {\n+    \/\/ invokestatic and invokehandle are not supported yet.\n+    return false;\n+  }\n+\n+}\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,2 @@\n+  void remove_resolved_method_entries_if_non_deterministic();\n+  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsEnumKlass.hpp\"\n@@ -1105,1 +1106,1 @@\n-      if (UseVtableBasedCHA && Universe::is_fully_initialized()) {\n+      if (Universe::is_fully_initialized()) {\n@@ -1491,1 +1492,1 @@\n-void InstanceKlass::add_to_hierarchy_impl(JavaThread* current) {\n+void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n@@ -1517,17 +1518,0 @@\n-void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n-\n-  if (UseVtableBasedCHA || !Universe::is_fully_initialized()) {\n-    add_to_hierarchy_impl(current);\n-  } else {\n-    \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n-    \/\/ deopt is completed before anyone links this class.\n-    \/\/ Linking is done with init_lock held, by loading and deopting with it\n-    \/\/ held we make sure the deopt is completed before linking.\n-    Handle h_init_lock(current, init_lock());\n-    ObjectLocker ol(h_init_lock, current);\n-    add_to_hierarchy_impl(current);\n-\n-    \/\/ This doesn't need a notify because the wait is only on the class initialization path.\n-  }\n-}\n-\n@@ -1820,1 +1804,1 @@\n-    bool initialized = HeapShared::initialize_enum_klass(this, CHECK);\n+    bool initialized = CDSEnumKlass::initialize_enum_klass(this, CHECK);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -892,3 +892,0 @@\n- private:\n-  void add_to_hierarchy_impl(JavaThread* current);\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -164,5 +164,0 @@\n-  \/\/ Bitmap and hash code used by hashed secondary supers.\n-  uintx    _bitmap;\n-  uint8_t  _hash_slot;\n-\n-  static uint8_t compute_hash_slot(Symbol* s);\n@@ -179,0 +174,4 @@\n+  \/\/ Bitmap and hash code used by hashed secondary supers.\n+  uintx    _bitmap;\n+  uint8_t  _hash_slot;\n+\n@@ -398,0 +397,1 @@\n+  static uint8_t compute_hash_slot(Symbol* s);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2181,1 +2181,0 @@\n-private:\n@@ -2315,1 +2314,0 @@\n-  int                _jvmci_ir_size;\n@@ -2317,0 +2315,1 @@\n+  int                _jvmci_ir_size;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,15 @@\n+  void copy_from(const ResolvedMethodEntry& other) {\n+    _method = other._method;\n+    _entry_specific = other._entry_specific;\n+    _cpool_index = other._cpool_index;\n+    _number_of_parameters = other._number_of_parameters;\n+    _tos_state = other._tos_state;\n+    _flags = other._flags;\n+    _bytecode1 = other._bytecode1;\n+    _bytecode2 = other._bytecode2;\n+#ifdef ASSERT\n+    _has_interface_klass = other._has_interface_klass;\n+    _has_table_index = other._has_table_index;\n+#endif\n+  }\n+\n@@ -102,0 +117,10 @@\n+    ResolvedMethodEntry(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+    }\n+\n+    ResolvedMethodEntry& operator=(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+      return *this;\n+    }\n+\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  AddNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  AddNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -168,1 +168,1 @@\n-  AddPNode( Node *base, Node *ptr, Node *off ) : Node(0,base,ptr,off) {\n+  AddPNode( Node *base, Node *ptr, Node *off ) : Node(nullptr,base,ptr,off) {\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,1 @@\n-      _idom(0),\n+      _idom(nullptr),\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-  virtual bool pinned() const { return in(0) != 0; }\n+  virtual bool pinned() const { return in(0) != nullptr; }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    Constant() : _type(T_ILLEGAL), _is_array(false), _alignment(-1), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }\n+    Constant() : _type(T_ILLEGAL), _is_array(false), _alignment(-1), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = nullptr; }\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,1 +263,1 @@\n-  RoundDoubleModeNode(Node *in1, Node * rmode): Node(0, in1, rmode) {}\n+  RoundDoubleModeNode(Node *in1, Node * rmode): Node(nullptr, in1, rmode) {}\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  CountBitsNode(Node* in1) : Node(0, in1) {}\n+  CountBitsNode(Node* in1) : Node(nullptr, in1) {}\n","filename":"src\/hotspot\/share\/opto\/countbitsnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-  \/\/ (http:\/\/www.hackersdelight.org\/HDcode\/mulhs.c)\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -671,1 +671,6 @@\n-    Node* curr_cmp = curr_ctrl->in(0)->in(1)->in(1); \/\/ true\/false -> if -> bool -> cmp\n+    \/\/ can_reduce_check_users() verified graph: true\/false -> if -> bool -> cmp\n+    assert(curr_ctrl->in(0)->Opcode() == Op_If, \"unexpected node %s\", curr_ctrl->in(0)->Name());\n+    Node* bol = curr_ctrl->in(0)->in(1);\n+    assert(bol->is_Bool(), \"unexpected node %s\", bol->Name());\n+    Node* curr_cmp = bol->in(1);\n+    assert(curr_cmp->Opcode() == Op_CmpP || curr_cmp->Opcode() == Op_CmpN, \"unexpected node %s\", curr_cmp->Name());\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  _append = append;\n@@ -148,1 +149,1 @@\n-    init_file_stream(file_name, use_multiple_files, append);\n+    init_file_stream(file_name, use_multiple_files);\n@@ -153,1 +154,1 @@\n-  if (!append) {\n+  if (!_append) {\n@@ -160,1 +161,3 @@\n-  tail(TOP_ELEMENT);\n+  if (!_append) {\n+    tail(TOP_ELEMENT);\n+  }\n@@ -863,1 +866,1 @@\n-void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files, bool append) {\n+void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files) {\n@@ -866,1 +869,1 @@\n-    assert(!append, \"append should only be used for debugging with a single file\");\n+    assert(!_append, \"append should only be used for debugging with a single file\");\n@@ -878,1 +881,1 @@\n-    _output = new (mtCompiler) fileStream(file_name, append ? \"a\" : \"w\");\n+    _output = new (mtCompiler) fileStream(file_name, _append ? \"a\" : \"w\");\n@@ -881,1 +884,1 @@\n-    assert(!append, \"append should only be used for debugging with a single file\");\n+    assert(!_append, \"append should only be used for debugging with a single file\");\n@@ -912,3 +915,10 @@\n-    end_method();\n-    _current_method = nullptr;\n-    begin_method();\n+    if (_append) {\n+      \/\/ Do not call `end_method` if we are appending, just update `_current_method`,\n+      \/\/ because `begin_method` is not called in the constructor in append mode.\n+      _current_method = current_method;\n+    } else {\n+      \/\/ End the old method and begin a new one.\n+      \/\/ Don't worry about `_current_method`, `end_method` will clear it.\n+      end_method();\n+      begin_method();\n+    }\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+  bool _append;\n@@ -121,1 +122,1 @@\n-  void init_file_stream(const char* file_name, bool use_multiple_files, bool append);\n+  void init_file_stream(const char* file_name, bool use_multiple_files);\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,1 +242,1 @@\n-  CopySignDNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+  CopySignDNode(Node* in1, Node* in2, Node* in3) : Node(nullptr, in1, in2, in3) {}\n@@ -252,1 +252,1 @@\n-  CopySignFNode(Node* in1, Node* in2) : Node(0, in1, in2) {}\n+  CopySignFNode(Node* in1, Node* in2) : Node(nullptr, in1, in2) {}\n@@ -261,1 +261,1 @@\n-  SignumDNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+  SignumDNode(Node* in1, Node* in2, Node* in3) : Node(nullptr, in1, in2, in3) {}\n@@ -271,1 +271,1 @@\n-  SignumFNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+  SignumFNode(Node* in1, Node* in2, Node* in3) : Node(nullptr, in1, in2, in3) {}\n@@ -309,1 +309,1 @@\n-  IsInfiniteFNode(Node* in1) : Node(0, in1) {}\n+  IsInfiniteFNode(Node* in1) : Node(nullptr, in1) {}\n@@ -318,1 +318,1 @@\n-  IsInfiniteDNode(Node* in1) : Node(0, in1) {}\n+  IsInfiniteDNode(Node* in1) : Node(nullptr, in1) {}\n@@ -327,1 +327,1 @@\n-  IsFiniteFNode(Node* in1) : Node(0, in1) {}\n+  IsFiniteFNode(Node* in1) : Node(nullptr, in1) {}\n@@ -336,1 +336,1 @@\n-  IsFiniteDNode(Node* in1) : Node(0, in1) {}\n+  IsFiniteDNode(Node* in1) : Node(nullptr, in1) {}\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -5856,0 +5856,32 @@\n+\/\/ Common checks for array sorting intrinsics arguments.\n+\/\/ Returns `true` if checks passed.\n+bool LibraryCallKit::check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt) {\n+  \/\/ check address of the class\n+  if (elementType == nullptr || elementType->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  if (elem_klass == nullptr) {\n+    return false;  \/\/ dead path\n+  }\n+  \/\/ java_mirror_type() returns non-null for compile-time Class constants only\n+  ciType* elem_type = elem_klass->java_mirror_type();\n+  if (elem_type == nullptr) {\n+    return false;\n+  }\n+  bt = elem_type->basic_type();\n+  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n+  if (!Matcher::supports_simd_sort(bt)) {\n+    return false;\n+  }\n+  \/\/ check address of the array\n+  if (obj == nullptr || obj->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM) {\n+    return false; \/\/ failed input validation\n+  }\n+  return true;\n+}\n+\n@@ -5858,0 +5890,5 @@\n+  address stubAddr = StubRoutines::select_array_partition_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 9, \"arrayPartition has 8 parameters (one long)\");\n@@ -5859,1 +5896,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5861,1 +5899,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5866,0 +5904,1 @@\n+  \/\/ PartitionOperation:  argument(8) is ignored\n@@ -5868,0 +5907,1 @@\n+  BasicType bt = T_ILLEGAL;\n@@ -5869,0 +5909,8 @@\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n+    return false;\n+  }\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -5874,18 +5922,0 @@\n-    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-    BasicType bt = elem_type->basic_type();\n-    \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-    if (!Matcher::supports_simd_sort(bt)) {\n-      return false;\n-    }\n-    address stubAddr = nullptr;\n-    stubAddr = StubRoutines::select_array_partition_function();\n-    \/\/ stub not loaded\n-    if (stubAddr == nullptr) {\n-      return false;\n-    }\n-    \/\/ get the address of the array\n-    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-      return false; \/\/ failed input validation\n-    }\n@@ -5924,0 +5954,5 @@\n+  address stubAddr = StubRoutines::select_arraysort_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 7, \"arraySort has 6 parameters (one long)\");\n@@ -5925,1 +5960,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5927,1 +5963,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5930,0 +5966,1 @@\n+  \/\/ SortOperation:       argument(6) is ignored\n@@ -5931,11 +5968,3 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType bt = elem_type->basic_type();\n-  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-  if (!Matcher::supports_simd_sort(bt)) {\n-    return false;\n-  }\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_arraysort_function();\n-  \/\/stub not loaded\n-  if (stubAddr == nullptr) {\n+  BasicType bt = T_ILLEGAL;\n+\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n@@ -5944,5 +5973,4 @@\n-\n-  \/\/ get address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":66,"deletions":38,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+  bool check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-  LoopLimitNode( Compile* C, Node *init, Node *limit, Node *stride ) : Node(0,init,limit,stride) {\n+  LoopLimitNode( Compile* C, Node *init, Node *limit, Node *stride ) : Node(nullptr,init,limit,stride) {\n@@ -614,1 +614,1 @@\n-    : _parent(0), _next(0), _child(0),\n+    : _parent(nullptr), _next(nullptr), _child(nullptr),\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1124,1 +1124,1 @@\n-  labelOper() : _label(0), _block_num(0) {}\n+  labelOper() : _label(nullptr), _block_num(0) {}\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3037,0 +3037,3 @@\n+  if (_store->is_unsafe_access()) {\n+    return nullptr;\n+  }\n@@ -3070,0 +3073,1 @@\n+  assert(!_store->is_unsafe_access(), \"no unsafe accesses\");\n@@ -3074,1 +3078,2 @@\n-      other_store->adr_type()->isa_aryptr() == nullptr) {\n+      other_store->adr_type()->isa_aryptr() == nullptr ||\n+      other_store->is_unsafe_access()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1695,1 +1695,1 @@\n-  PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}\n+  PrefetchAllocationNode(Node *mem, Node *adr) : Node(nullptr,mem,adr) {}\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  BinaryNode( Node *n1, Node *n2 ) : Node(0,n1,n2) { }\n+  BinaryNode( Node *n1, Node *n2 ) : Node(nullptr,n1,n2) { }\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,1 @@\n-  MulHiLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  MulHiLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -181,1 +181,1 @@\n-  UMulHiLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  UMulHiLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -294,1 +294,1 @@\n-  RShiftINode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  RShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -307,1 +307,1 @@\n-  RShiftLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  RShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -319,1 +319,1 @@\n-  URShiftBNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  URShiftBNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -329,1 +329,1 @@\n-  URShiftSNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  URShiftSNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -339,1 +339,1 @@\n-  URShiftINode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  URShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -352,1 +352,1 @@\n-  URShiftLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  URShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -399,1 +399,1 @@\n-  MulAddS2INode(Node* in1, Node *in2, Node *in3, Node* in4) : Node(0, in1, in2, in3, in4) {}\n+  MulAddS2INode(Node* in1, Node *in2, Node *in3, Node* in4) : Node(nullptr, in1, in2, in3, in4) {}\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  ProfileBooleanNode(Node *n, uint false_cnt, uint true_cnt) : Node(0, n),\n+  ProfileBooleanNode(Node *n, uint false_cnt, uint true_cnt) : Node(nullptr, n),\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  Type_Array(Arena *a) : _a(a), _max(0), _types(0) {}\n+  Type_Array(Arena *a) : _a(a), _max(0), _types(nullptr) {}\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  RootNode( ) : LoopNode(0,0) {\n+  RootNode( ) : LoopNode(nullptr, nullptr) {\n","filename":"src\/hotspot\/share\/opto\/rootnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  SubNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  SubNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -388,1 +388,1 @@\n-  AbsNode( Node *value ) : Node(0,value) {}\n+  AbsNode( Node *value ) : Node(nullptr,value) {}\n@@ -445,1 +445,1 @@\n-  CmpLTMaskNode( Node *p, Node *q ) : Node(0, p, q) {}\n+  CmpLTMaskNode( Node *p, Node *q ) : Node(nullptr, p, q) {}\n@@ -455,1 +455,1 @@\n-  NegNode(Node* in1) : Node(0, in1) {\n+  NegNode(Node* in1) : Node(nullptr, in1) {\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-#include \"libadt\/vectset.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -29,1 +26,0 @@\n-#include \"opto\/c2compiler.hpp\"\n@@ -32,5 +28,0 @@\n-#include \"opto\/matcher.hpp\"\n-#include \"opto\/memnode.hpp\"\n-#include \"opto\/opcodes.hpp\"\n-#include \"opto\/opaquenode.hpp\"\n-#include \"opto\/rootnode.hpp\"\n@@ -38,0 +29,1 @@\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n@@ -40,1 +32,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n@@ -710,1 +701,1 @@\n-  \/\/ and will still be vectorized by SuperWord::vector_opd.\n+  \/\/ and will still be vectorized by SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index.\n@@ -772,2 +763,3 @@\n-\/\/ Look for pattern n1 = (iv + c) and n2 = (iv + c + 1), which may lead to PopulateIndex vector node.\n-\/\/ We skip the pack creation of these nodes. They will be vectorized by SuperWord::vector_opd.\n+\/\/ Look for pattern n1 = (iv + c) and n2 = (iv + c + 1), which may lead to\n+\/\/ PopulateIndex vector node. We skip the pack creation of these nodes. They\n+\/\/ will be vectorized by SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index.\n@@ -1861,127 +1853,2 @@\n-\/\/ The PacksetGraph combines the dependency graph with the packset. In the PackSet\n-\/\/ graph, we have two kinds of nodes:\n-\/\/  (1) pack-node:   Represents all nodes of some pack p in a single node, which\n-\/\/                   shall later become a vector node.\n-\/\/  (2) scalar-node: Represents a node that is not in any pack.\n-\/\/ For any edge (n1, n2) in the dependency graph, we add an edge to the PacksetGraph for\n-\/\/ the PacksetGraph nodes corresponding to n1 and n2.\n-\/\/ We work from the dependency graph, because it gives us all the data-dependencies,\n-\/\/ as well as more refined memory-dependencies than the C2 graph. The dependency graph\n-\/\/ does not have cycles. But packing nodes can introduce cyclic dependencies. Example:\n-\/\/\n-\/\/                                                       +--------+\n-\/\/  A -> X                                               |        v\n-\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n-\/\/  Y -> B                                                 ^        |\n-\/\/                                                         +--------+\n-\/\/\n-class PacksetGraph {\n-private:\n-  \/\/ pid: packset graph node id.\n-  GrowableArray<int> _pid;                 \/\/ bb_idx(n) -> pid\n-  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via _packset.pack\n-  GrowableArray<GrowableArray<int>> _out;  \/\/ out-edges\n-  GrowableArray<int> _incnt;               \/\/ number of (implicit) in-edges\n-  int _max_pid = 0;\n-\n-  bool _schedule_success;\n-\n-  SuperWord* _slp;\n-public:\n-  PacksetGraph(SuperWord* slp)\n-  : _pid(8, 0, \/* default *\/ 0), _slp(slp) {\n-  }\n-  \/\/ Get pid, if there is a packset node that n belongs to. Else return 0.\n-  int get_pid_or_zero(const Node* n) const {\n-    if (!_slp->in_bb(n)) {\n-      return 0;\n-    }\n-    int idx = _slp->bb_idx(n);\n-    if (idx >= _pid.length()) {\n-      return 0;\n-    } else {\n-      return _pid.at(idx);\n-    }\n-  }\n-  int get_pid(const Node* n) {\n-    int poz = get_pid_or_zero(n);\n-    assert(poz != 0, \"pid should not be zero\");\n-    return poz;\n-  }\n-  void set_pid(Node* n, int pid) {\n-    assert(n != nullptr && pid > 0, \"sane inputs\");\n-    assert(_slp->in_bb(n), \"must be\");\n-    int idx = _slp->bb_idx(n);\n-    _pid.at_put_grow(idx, pid);\n-    _pid_to_node.at_put_grow(pid - 1, n, nullptr);\n-  }\n-  Node* get_node(int pid) {\n-    assert(pid > 0 && pid <= _pid_to_node.length(), \"pid must be mapped\");\n-    Node* n = _pid_to_node.at(pid - 1);\n-    assert(n != nullptr, \"sanity\");\n-    return n;\n-  }\n-  int new_pid() {\n-    _incnt.push(0);\n-    _out.push(GrowableArray<int>());\n-    return ++_max_pid;\n-  }\n-  int incnt(int pid) { return _incnt.at(pid - 1); }\n-  void incnt_set(int pid, int cnt) { return _incnt.at_put(pid - 1, cnt); }\n-  GrowableArray<int>& out(int pid) { return _out.at(pid - 1); }\n-  bool schedule_success() const { return _schedule_success; }\n-\n-  \/\/ Create nodes (from packs and scalar-nodes), and add edges, based on the dependency graph.\n-  void build() {\n-    const PackSet& packset = _slp->packset();\n-    const GrowableArray<Node*>& body = _slp->body();\n-    \/\/ Map nodes in packsets\n-    for (int i = 0; i < packset.length(); i++) {\n-      Node_List* p = packset.at(i);\n-      int pid = new_pid();\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        set_pid(n, pid);\n-        assert(packset.get_pack(n) == p, \"matching packset\");\n-      }\n-    }\n-\n-    int max_pid_packset = _max_pid;\n-\n-    \/\/ Map nodes not in packset\n-    for (int i = 0; i < body.length(); i++) {\n-      Node* n = body.at(i);\n-      if (n->is_Phi() || n->is_CFG()) {\n-        continue; \/\/ ignore control flow\n-      }\n-      int pid = get_pid_or_zero(n);\n-      if (pid == 0) {\n-        pid = new_pid();\n-        set_pid(n, pid);\n-        assert(packset.get_pack(n) == nullptr, \"no packset\");\n-      }\n-    }\n-\n-    \/\/ Map edges for packset nodes\n-    VectorSet set;\n-    for (int i = 0; i < packset.length(); i++) {\n-      Node_List* p = packset.at(i);\n-      set.clear();\n-      int pid = get_pid(p->at(0));\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        assert(pid == get_pid(n), \"all nodes in pack have same pid\");\n-        for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n-          Node* pred = preds.current();\n-          int pred_pid = get_pid_or_zero(pred);\n-          if (pred_pid == pid && _slp->is_marked_reduction(n)) {\n-            continue; \/\/ reduction -> self-cycle is not a cyclic dependency\n-          }\n-          \/\/ Only add edges once, and only for mapped nodes (in body)\n-          if (pred_pid > 0 && !set.test_set(pred_pid)) {\n-            incnt_set(pid, incnt(pid) + 1); \/\/ increment\n-            out(pred_pid).push(pid);\n-          }\n-        }\n-      }\n-    }\n+bool SuperWord::schedule_and_apply() const {\n+  if (_packset.is_empty()) { return false; }\n@@ -1989,82 +1856,1 @@\n-    \/\/ Map edges for nodes not in packset\n-    for (int i = 0; i < body.length(); i++) {\n-      Node* n = body.at(i);\n-      int pid = get_pid_or_zero(n); \/\/ zero for Phi or CFG\n-      if (pid <= max_pid_packset) {\n-        continue; \/\/ Only scalar-nodes\n-      }\n-      for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n-        Node* pred = preds.current();\n-        int pred_pid = get_pid_or_zero(pred);\n-        \/\/ Only add edges for mapped nodes (in body)\n-        if (pred_pid > 0) {\n-          incnt_set(pid, incnt(pid) + 1); \/\/ increment\n-          out(pred_pid).push(pid);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Schedule nodes of PacksetGraph to worklist, using topsort: schedule a node\n-  \/\/ that has zero incnt. If a PacksetGraph node corresponds to memops, then add\n-  \/\/ those to the memops_schedule. At the end, we return the memops_schedule, and\n-  \/\/ note if topsort was successful.\n-  Node_List schedule() {\n-    Node_List memops_schedule;\n-    GrowableArray<int> worklist;\n-    \/\/ Directly schedule all nodes without precedence\n-    for (int pid = 1; pid <= _max_pid; pid++) {\n-      if (incnt(pid) == 0) {\n-        worklist.push(pid);\n-      }\n-    }\n-    \/\/ Continue scheduling via topological sort\n-    for (int i = 0; i < worklist.length(); i++) {\n-      int pid = worklist.at(i);\n-\n-      \/\/ Add memops to memops_schedule\n-      Node* n = get_node(pid);\n-      Node_List* p = _slp->packset().get_pack(n);\n-      if (n->is_Mem()) {\n-        if (p == nullptr) {\n-          memops_schedule.push(n);\n-        } else {\n-          for (uint k = 0; k < p->size(); k++) {\n-            memops_schedule.push(p->at(k));\n-            assert(p->at(k)->is_Mem(), \"only schedule memops\");\n-          }\n-        }\n-      }\n-\n-      \/\/ Decrement incnt for all successors\n-      for (int j = 0; j < out(pid).length(); j++){\n-        int pid_use = out(pid).at(j);\n-        int incnt_use = incnt(pid_use) - 1;\n-        incnt_set(pid_use, incnt_use);\n-        \/\/ Did use lose its last input?\n-        if (incnt_use == 0) {\n-          worklist.push(pid_use);\n-        }\n-      }\n-    }\n-\n-    \/\/ Was every pid scheduled? If not, we found some cycles in the PacksetGraph.\n-    _schedule_success = (worklist.length() == _max_pid);\n-    return memops_schedule;\n-  }\n-\n-  \/\/ Print the PacksetGraph.\n-  \/\/ print_nodes = true: print all C2 nodes beloning to PacksetGrahp node.\n-  \/\/ print_zero_incnt = false: do not print nodes that have no in-edges (any more).\n-  void print(bool print_nodes, bool print_zero_incnt) {\n-    const GrowableArray<Node*> &body = _slp->body();\n-    tty->print_cr(\"PacksetGraph\");\n-    for (int pid = 1; pid <= _max_pid; pid++) {\n-      if (incnt(pid) == 0 && !print_zero_incnt) {\n-        continue;\n-      }\n-      tty->print(\"Node %d. incnt %d [\", pid, incnt(pid));\n-      for (int j = 0; j < out(pid).length(); j++) {\n-        tty->print(\"%d \", out(pid).at(j));\n-      }\n-      tty->print_cr(\"]\");\n+  \/\/ Make an empty transform.\n@@ -2072,9 +1858,4 @@\n-      if (print_nodes) {\n-        for (int i = 0; i < body.length(); i++) {\n-          Node* n = body.at(i);\n-          if (get_pid_or_zero(n) == pid) {\n-            tty->print(\"    \");\n-            n->dump();\n-          }\n-        }\n-      }\n+  VTransformTrace trace(_vloop.vtrace(),\n+                        is_trace_superword_rejections(),\n+                        is_trace_align_vector(),\n+                        is_trace_superword_info());\n@@ -2082,21 +1863,5 @@\n-    }\n-  }\n-};\n-\n-\/\/ We want to replace the packed scalars from the PackSet and replace them\n-\/\/ with vector operations. This requires scheduling and re-ordering the memory\n-\/\/ graph. We take these steps:\n-\/\/ (1) Build the PacksetGraph. It combines the dependency graph with the\n-\/\/     packset. The PacksetGraph gives us the dependencies that must be\n-\/\/     respected after scheduling.\n-\/\/ (2) Schedule the PacksetGraph to the memops_schedule, which represents\n-\/\/     a linear order of all memops in the body. The order respects the\n-\/\/     dependencies of the PacksetGraph.\n-\/\/ (3) If the PacksetGraph has cycles, we cannot schedule. Abort.\n-\/\/ (4) Apply the vectorization, including re-ordering the memops and replacing\n-\/\/     packed scalars with vector operations.\n-bool SuperWord::schedule_and_apply() {\n-  if (_packset.is_empty()) {\n-    return false;\n-  }\n-  ResourceMark rm;\n+  VTransform vtransform(_vloop_analyzer,\n+                        _mem_ref_for_main_loop_alignment,\n+                        _aw_for_main_loop_alignment\n+                        NOT_PRODUCT(COMMA trace)\n+                        );\n@@ -2104,3 +1869,5 @@\n-  \/\/ (1) Build the PacksetGraph.\n-  PacksetGraph graph(this);\n-  graph.build();\n+  \/\/ Build the transform from the packset.\n+  {\n+    ResourceMark rm;\n+    SuperWordVTransformBuilder builder(_packset, vtransform);\n+  }\n@@ -2108,2 +1875,4 @@\n-  \/\/ (2) Schedule the PacksetGraph.\n-  Node_List memops_schedule = graph.schedule();\n+  if (!vtransform.schedule()) { return false; }\n+  vtransform.apply();\n+  return true;\n+}\n@@ -2111,7 +1880,3 @@\n-  \/\/ (3) Check if the PacksetGraph schedule succeeded (had no cycles).\n-  \/\/ We now know that we only have independent packs, see verify_packs.\n-  \/\/ This is a necessary but not a sufficient condition for an acyclic\n-  \/\/ graph (DAG) after scheduling. Thus, we must check if the packs have\n-  \/\/ introduced a cycle. The SuperWord paper mentions the need for this\n-  \/\/ in \"3.7 Scheduling\".\n-  if (!graph.schedule_success()) {\n+\/\/ Apply the vectorization, i.e. we irreversibly edit the C2 graph. At this point, all\n+\/\/ correctness and profitability checks have passed, and the graph was successfully scheduled.\n+void VTransform::apply() {\n@@ -2119,8 +1884,4 @@\n-    if (is_trace_superword_rejections()) {\n-      tty->print_cr(\"SuperWord::schedule found cycle in PacksetGraph:\");\n-      graph.print(true, false);\n-      tty->print_cr(\"removing all packs from packset.\");\n-    }\n-#endif\n-    _packset.clear();\n-    return false;\n+  if (_trace._info || TraceLoopOpts) {\n+    tty->print_cr(\"\\nVTransform::apply:\");\n+    lpt()->dump_head();\n+    lpt()->head()->dump();\n@@ -2128,0 +1889,3 @@\n+  assert(cl()->is_main_loop(), \"auto vectorization only for main loops\");\n+  assert(_graph.is_scheduled(), \"must already be scheduled\");\n+#endif\n@@ -2129,5 +1893,0 @@\n-  \/\/ (4) Apply the vectorization, including re-ordering the memops.\n-  return apply(memops_schedule);\n-}\n-\n-bool SuperWord::apply(Node_List& memops_schedule) {\n@@ -2135,2 +1894,1 @@\n-  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n-  C->print_method(PHASE_AUTO_VECTORIZATION1_BEFORE_APPLY, 4, cl);\n+  C->print_method(PHASE_AUTO_VECTORIZATION1_BEFORE_APPLY, 4, cl());\n@@ -2138,2 +1896,2 @@\n-  apply_memops_reordering_with_schedule(memops_schedule);\n-  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl);\n+  _graph.apply_memops_reordering_with_schedule();\n+  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl());\n@@ -2142,1 +1900,1 @@\n-  C->print_method(PHASE_AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, 4, cl);\n+  C->print_method(PHASE_AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, 4, cl());\n@@ -2144,4 +1902,2 @@\n-  bool is_success = apply_vectorization();\n-  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_APPLY, 4, cl);\n-\n-  return is_success;\n+  apply_vectorization();\n+  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_APPLY, 4, cl());\n@@ -2150,3 +1906,5 @@\n-\/\/ Reorder the memory graph for all slices in parallel. We walk over the schedule once,\n-\/\/ and track the current memory state of each slice.\n-void SuperWord::apply_memops_reordering_with_schedule(Node_List& memops_schedule) {\n+\/\/ We prepare the memory graph for the replacement of scalar memops with vector memops.\n+\/\/ We reorder all slices in parallel, ensuring that the memops inside each slice are\n+\/\/ ordered according to the _schedule. This means that all packed memops are consecutive\n+\/\/ in the memory graph after the reordering.\n+void VTransformGraph::apply_memops_reordering_with_schedule() const {\n@@ -2154,3 +1912,3 @@\n-  if (is_trace_superword_info()) {\n-    tty->print_cr(\"\\nSuperWord::apply_memops_reordering_with_schedule:\");\n-    memops_schedule.dump();\n+  assert(is_scheduled(), \"must be already scheduled\");\n+  if (_trace._info) {\n+    print_memops_schedule();\n@@ -2160,0 +1918,1 @@\n+  ResourceMark rm;\n@@ -2161,1 +1920,1 @@\n-  \/\/ When iterating over the memops_schedule, we keep track of the current memory state,\n+  \/\/ When iterating over the schedule, we keep track of the current memory state,\n@@ -2182,1 +1941,1 @@\n-  \/\/ (2) Walk over memops_schedule, append memops to the current state\n+  \/\/ (2) Walk over schedule, append memops to the current state\n@@ -2184,2 +1943,1 @@\n-  for (uint i = 0; i < memops_schedule.size(); i++) {\n-    MemNode* n = memops_schedule.at(i)->as_Mem();\n+  for_each_memop_in_schedule([&] (MemNode* n) {\n@@ -2201,1 +1959,1 @@\n-  }\n+  });\n@@ -2206,1 +1964,1 @@\n-  Node_List uses_after_loop;\n+  GrowableArray<Node*> uses_after_loop;\n@@ -2228,1 +1986,1 @@\n-    for (uint k = 0; k < uses_after_loop.size(); k++) {\n+    for (int k = 0; k < uses_after_loop.length(); k++) {\n@@ -2240,60 +1998,7 @@\n-\/\/ Convert packs into vector node operations\n-\/\/ At this point, all correctness and profitability checks have passed.\n-\/\/ We start the irreversible process of editing the C2 graph. Should\n-\/\/ there be an unexpected situation (assert fails), then we can only\n-\/\/ bail out of the compilation, as the graph has already been partially\n-\/\/ modified. We bail out, and retry without SuperWord.\n-bool SuperWord::apply_vectorization() {\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n-  Compile* C = phase()->C;\n-  assert(!_packset.is_empty(), \"vectorization requires non-empty packset\");\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"SuperWord::apply_vectorization \");\n-    lpt()->dump_head();\n-  }\n-#endif\n-\n-  uint max_vlen_in_bytes = 0;\n-  uint max_vlen = 0;\n-\n-  for (int i = 0; i < body().length(); i++) {\n-    Node* n = body().at(i);\n-    Node_List* p = get_pack(n);\n-    if (p != nullptr && n == p->at(p->size()-1)) {\n-      \/\/ After apply_memops_reordering_with_schedule, we know that the memops have the same order in the pack\n-      \/\/ as in the memory slice. Hence, \"first\" is the first memop in the slice from the pack,\n-      \/\/ and \"n\" is the last node in the slice from the pack.\n-      Node* first = p->at(0);\n-      uint vlen = p->size();\n-      uint vlen_in_bytes = 0;\n-      Node* vn = nullptr;\n-      int   opc = n->Opcode();\n-      if (n->is_Load()) {\n-        Node* ctl = n->in(MemNode::Control);\n-        Node* mem = first->in(MemNode::Memory);\n-        \/\/ Set the memory dependency of the LoadVector as early as possible.\n-        \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n-        \/\/ does not have any memory dependency.\n-        while (mem->is_StoreVector()) {\n-          VPointer p_store(mem->as_Mem(), _vloop);\n-          if (p_store.overlap_possible_with_any_in(p)) {\n-            break;\n-          } else {\n-            mem = mem->in(MemNode::Memory);\n-          }\n-        }\n-        Node* adr = first->in(MemNode::Address);\n-        const TypePtr* atyp = n->adr_type();\n-        vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n-        vlen_in_bytes = vn->as_LoadVector()->memory_size();\n-      } else if (n->is_Store()) {\n-        \/\/ Promote value to be stored to vector\n-        Node* val = vector_opd(p, MemNode::ValueIn);\n-        if (val == nullptr) {\n-          assert(false, \"input to vector store was not created\");\n-          C->record_failure(C2Compiler::retry_no_superword());\n-          return false; \/\/ bailout\n-        }\n+void VTransformGraph::apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const {\n+  ResourceMark rm;\n+  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n+  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n+  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n+  int length = _vtnodes.length();\n+  GrowableArray<Node*> vtnode_idx_to_transformed_node(length, length, nullptr);\n@@ -2301,65 +2006,5 @@\n-        Node* ctl = n->in(MemNode::Control);\n-        Node* mem = first->in(MemNode::Memory);\n-        Node* adr = first->in(MemNode::Address);\n-        const TypePtr* atyp = n->adr_type();\n-        vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n-        vlen_in_bytes = vn->as_StoreVector()->memory_size();\n-      } else if (VectorNode::is_scalar_rotate(n)) {\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = first->in(2);\n-        \/\/ If rotation count is non-constant or greater than 8bit value create a vector.\n-        if (!in2->is_Con() || !Matcher::supports_vector_constant_rotates(in2->get_int())) {\n-          in2 =  vector_opd(p, 2);\n-        }\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_roundopD(n)) {\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = first->in(2);\n-        assert(in2->is_Con(), \"Constant rounding mode expected.\");\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_muladds2i(n)) {\n-        assert(n->req() == 5u, \"MulAddS2I should have 4 operands.\");\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = vector_opd(p, 2);\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (opc == Op_SignumF || opc == Op_SignumD) {\n-        assert(n->req() == 4, \"four inputs expected\");\n-        Node* in = vector_opd(p, 1);\n-        Node* zero = vector_opd(p, 2);\n-        Node* one = vector_opd(p, 3);\n-        vn = VectorNode::make(opc, in, zero, one, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (n->is_Cmp()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-        continue;\n-      } else if (n->is_Bool()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-        continue;\n-      } else if (n->is_CMove()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-\n-        BoolNode* bol = n->in(1)->as_Bool();\n-        assert(bol != nullptr, \"must have Bool above CMove\");\n-        Node_List* bool_pack = get_pack(bol);\n-        assert(bool_pack != nullptr, \"CMove must have matching Bool pack\");\n-\n-        CmpNode* cmp = bol->in(1)->as_Cmp();\n-        assert(cmp != nullptr, \"must have cmp above CMove\");\n-        Node_List* cmp_pack = get_pack(cmp);\n-        assert(cmp_pack != nullptr, \"Bool must have matching Cmp pack\");\n-\n-        Node* cmp_in1 = vector_opd(cmp_pack, 1);\n-        Node* cmp_in2 = vector_opd(cmp_pack, 2);\n-\n-        Node* blend_in1 = vector_opd(p, 2);\n-        Node* blend_in2 = vector_opd(p, 3);\n-\n-        VTransformBoolTest bool_test = _packset.get_bool_test(bool_pack);\n-        BoolTest::mask test_mask = bool_test._mask;\n-        if (bool_test._is_negated) {\n-           \/\/ We can cancel out the negation by swapping the blend inputs.\n-           swap(blend_in1, blend_in2);\n-        }\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+    VTransformApplyResult result = vtn->apply(_vloop_analyzer,\n+                                              vtnode_idx_to_transformed_node);\n+    NOT_PRODUCT( if (_trace._verbose) { result.trace(vtn); } )\n@@ -2367,90 +2012,5 @@\n-        \/\/ VectorMaskCmp\n-        ConINode* test_mask_node  = igvn().intcon((int)test_mask);\n-        BasicType bt = velt_basic_type(cmp);\n-        const TypeVect* vt = TypeVect::make(bt, vlen);\n-        VectorNode* mask = new VectorMaskCmpNode(test_mask, cmp_in1, cmp_in2, test_mask_node, vt);\n-        phase()->register_new_node_with_ctrl_of(mask, p->at(0));\n-        igvn()._worklist.push(mask);\n-\n-        \/\/ VectorBlend\n-        vn = new VectorBlendNode(blend_in1, blend_in2, mask);\n-      } else if (n->req() == 3) {\n-        \/\/ Promote operands to vector\n-        Node* in1 = nullptr;\n-        bool node_isa_reduction = is_marked_reduction(n);\n-        if (node_isa_reduction) {\n-          \/\/ the input to the first reduction operation is retained\n-          in1 = first->in(1);\n-        } else {\n-          in1 = vector_opd(p, 1);\n-          if (in1 == nullptr) {\n-            assert(false, \"input in1 to vector operand was not created\");\n-            C->record_failure(C2Compiler::retry_no_superword());\n-            return false; \/\/ bailout\n-          }\n-        }\n-        Node* in2 = vector_opd(p, 2);\n-        if (in2 == nullptr) {\n-          assert(false, \"input in2 to vector operand was not created\");\n-          C->record_failure(C2Compiler::retry_no_superword());\n-          return false; \/\/ bailout\n-        }\n-        if (in1->Opcode() == Op_Replicate && (node_isa_reduction == false) && (n->is_Add() || n->is_Mul())) {\n-          \/\/ Move invariant vector input into second position to avoid register spilling.\n-          Node* tmp = in1;\n-          in1 = in2;\n-          in2 = tmp;\n-        }\n-        if (node_isa_reduction) {\n-          const Type *arith_type = n->bottom_type();\n-          vn = ReductionNode::make(opc, nullptr, in1, in2, arith_type->basic_type());\n-          if (in2->is_Load()) {\n-            vlen_in_bytes = in2->as_LoadVector()->memory_size();\n-          } else {\n-            vlen_in_bytes = in2->as_Vector()->length_in_bytes();\n-          }\n-        } else {\n-          if (VectorNode::can_use_RShiftI_instead_of_URShiftI(n, velt_basic_type(n))) {\n-            opc = Op_RShiftI;\n-          }\n-          vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-          vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-        }\n-      } else if (VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        Node* in = vector_opd(p, 1);\n-        vn = VectorNode::make(opc, in, nullptr, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        Node* in = vector_opd(p, 1);\n-        Node* longval = VectorNode::make(opc, in, nullptr, vlen, T_LONG);\n-        phase()->register_new_node_with_ctrl_of(longval, first);\n-        \/\/ Requires extra vector long -> int conversion.\n-        vn = VectorCastNode::make(Op_VectorCastL2X, longval, T_INT, vlen);\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_convert_opcode(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        BasicType bt = velt_basic_type(n);\n-        Node* in = vector_opd(p, 1);\n-        int vopc = VectorCastNode::opcode(opc, in->bottom_type()->is_vect()->element_basic_type());\n-        vn = VectorCastNode::make(vopc, in, bt, vlen);\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (opc == Op_FmaD || opc == Op_FmaF) {\n-        \/\/ Promote operands to vector\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = vector_opd(p, 2);\n-        Node* in3 = vector_opd(p, 3);\n-        vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else {\n-        assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n-        C->record_failure(C2Compiler::retry_no_superword());\n-        return false; \/\/ bailout\n-      }\n-\n-      if (vn == nullptr) {\n-        assert(false, \"got null node instead of vector node\");\n-        C->record_failure(C2Compiler::retry_no_superword());\n-        return false; \/\/ bailout\n-      }\n+    vtnode_idx_to_transformed_node.at_put(vtn->_idx, result.node());\n+    max_vector_length = MAX2(max_vector_length, result.vector_length());\n+    max_vector_width  = MAX2(max_vector_width,  result.vector_width());\n+  }\n+}\n@@ -2458,9 +2018,7 @@\n-#ifdef ASSERT\n-      \/\/ Mark Load\/Store Vector for alignment verification\n-      if (VerifyAlignVector) {\n-        if (vn->Opcode() == Op_LoadVector) {\n-          vn->as_LoadVector()->set_must_verify_alignment();\n-        } else if (vn->Opcode() == Op_StoreVector) {\n-          vn->as_StoreVector()->set_must_verify_alignment();\n-        }\n-      }\n+\/\/ We call \"apply\" on every VTransformNode, which replaces the packed scalar nodes with vector nodes.\n+void VTransform::apply_vectorization() const {\n+  Compile* C = phase()->C;\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    tty->print_cr(\"\\nVTransform::apply_vectorization:\");\n+  }\n@@ -2469,6 +2027,3 @@\n-      phase()->register_new_node_with_ctrl_of(vn, first);\n-      for (uint j = 0; j < p->size(); j++) {\n-        Node* pm = p->at(j);\n-        igvn().replace_node(pm, vn);\n-      }\n-      igvn()._worklist.push(vn);\n+  uint max_vector_length = 0; \/\/ number of elements\n+  uint max_vector_width  = 0; \/\/ total width in bytes\n+  _graph.apply_vectorization_for_each_vtnode(max_vector_length, max_vector_width);\n@@ -2476,9 +2031,2 @@\n-      if (vlen > max_vlen) {\n-        max_vlen = vlen;\n-      }\n-      if (vlen_in_bytes > max_vlen_in_bytes) {\n-        max_vlen_in_bytes = vlen_in_bytes;\n-      }\n-      VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    }\n-  }\/\/for (int i = 0; i < body().length(); i++)\n+  assert(max_vector_length > 0 && max_vector_width > 0, \"must have vectorized\");\n+  cl()->mark_loop_vectorized();\n@@ -2486,5 +2034,2 @@\n-  if (max_vlen_in_bytes > C->max_vector_size()) {\n-    C->set_max_vector_size(max_vlen_in_bytes);\n-  }\n-  if (max_vlen_in_bytes > 0) {\n-    cl->mark_loop_vectorized();\n+  if (max_vector_width > C->max_vector_size()) {\n+    C->set_max_vector_size(max_vector_width);\n@@ -2494,3 +2039,3 @@\n-    if (cl->has_passed_slp()) {\n-      uint slp_max_unroll_factor = cl->slp_max_unroll();\n-      if (slp_max_unroll_factor == max_vlen) {\n+    if (cl()->has_passed_slp()) {\n+      uint slp_max_unroll_factor = cl()->slp_max_unroll();\n+      if (slp_max_unroll_factor == max_vector_length) {\n@@ -2499,1 +2044,1 @@\n-          tty->print_cr(\"vector loop(unroll=%d, len=%d)\\n\", max_vlen, max_vlen_in_bytes*BitsPerByte);\n+          tty->print_cr(\"vector loop(unroll=%d, len=%d)\\n\", max_vector_length, max_vector_width * BitsPerByte);\n@@ -2503,1 +2048,1 @@\n-        cl->set_notpassed_slp();\n+        cl()->set_notpassed_slp();\n@@ -2507,1 +2052,1 @@\n-          cl->mark_do_unroll_only();\n+          cl()->mark_do_unroll_only();\n@@ -2512,118 +2057,0 @@\n-\n-  return true;\n-}\n-\n-\/\/------------------------------vector_opd---------------------------\n-\/\/ Create a vector operand for the nodes in pack p for operand: in(opd_idx)\n-Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {\n-  Node* p0 = p->at(0);\n-  uint vlen = p->size();\n-  Node* opd = p0->in(opd_idx);\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  Node* same_input = _packset.same_inputs_at_index_or_null(p, opd_idx);\n-\n-  \/\/ Insert index population operation to create a vector of increasing\n-  \/\/ indices starting from the iv value. In some special unrolled loops\n-  \/\/ (see JDK-8286125), we need scalar replications of the iv value if\n-  \/\/ all inputs are the same iv, so we do a same inputs check here.\n-  if (opd == iv() && same_input == nullptr) {\n-    BasicType p0_bt = velt_basic_type(p0);\n-    BasicType iv_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n-    assert(VectorNode::is_populate_index_supported(iv_bt), \"Should support\");\n-    const TypeVect* vt = TypeVect::make(iv_bt, vlen);\n-    Node* vn = new PopulateIndexNode(iv(), igvn().intcon(1), vt);\n-    VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    phase()->register_new_node_with_ctrl_of(vn, opd);\n-    return vn;\n-  }\n-\n-  if (same_input != nullptr) {\n-    if (opd->is_Vector() || opd->is_LoadVector()) {\n-      if (opd_idx == 2 && VectorNode::is_shift(p0)) {\n-        assert(false, \"shift's count can't be vector\");\n-        return nullptr;\n-      }\n-      return opd; \/\/ input is matching vector\n-    }\n-    if ((opd_idx == 2) && VectorNode::is_shift(p0)) {\n-      Node* cnt = opd;\n-      \/\/ Vector instructions do not mask shift count, do it here.\n-      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n-      const TypeInt* t = opd->find_int_type();\n-      if (t != nullptr && t->is_con()) {\n-        juint shift = t->get_con();\n-        if (shift > mask) { \/\/ Unsigned cmp\n-          cnt = igvn().intcon(shift & mask);\n-          phase()->set_ctrl(cnt, phase()->C->root());\n-        }\n-      } else {\n-        if (t == nullptr || t->_lo < 0 || t->_hi > (int)mask) {\n-          cnt = igvn().intcon(mask);\n-          cnt = new AndINode(opd, cnt);\n-          phase()->register_new_node_with_ctrl_of(cnt, opd);\n-        }\n-        if (!opd->bottom_type()->isa_int()) {\n-          assert(false, \"int type only\");\n-          return nullptr;\n-        }\n-      }\n-      \/\/ Move shift count into vector register.\n-      cnt = VectorNode::shift_count(p0->Opcode(), cnt, vlen, velt_basic_type(p0));\n-      phase()->register_new_node_with_ctrl_of(cnt, opd);\n-      return cnt;\n-    }\n-    if (opd->is_StoreVector()) {\n-      assert(false, \"StoreVector is not expected here\");\n-      return nullptr;\n-    }\n-    \/\/ Convert scalar input to vector with the same number of elements as\n-    \/\/ p0's vector. Use p0's type because size of operand's container in\n-    \/\/ vector should match p0's size regardless operand's size.\n-    const Type* p0_t = nullptr;\n-    VectorNode* vn = nullptr;\n-    if (opd_idx == 2 && VectorNode::is_scalar_rotate(p0)) {\n-       Node* conv = opd;\n-       p0_t =  TypeInt::INT;\n-       if (p0->bottom_type()->isa_long()) {\n-         p0_t = TypeLong::LONG;\n-         conv = new ConvI2LNode(opd);\n-         phase()->register_new_node_with_ctrl_of(conv, opd);\n-       }\n-       vn = VectorNode::scalar2vector(conv, vlen, p0_t);\n-    } else {\n-       p0_t =  velt_type(p0);\n-       vn = VectorNode::scalar2vector(opd, vlen, p0_t);\n-    }\n-\n-    phase()->register_new_node_with_ctrl_of(vn, opd);\n-    VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    return vn;\n-  }\n-\n-  \/\/ Insert pack operation\n-  BasicType bt = velt_basic_type(p0);\n-  PackNode* pk = PackNode::make(opd, vlen, bt);\n-  DEBUG_ONLY( const BasicType opd_bt = opd->bottom_type()->basic_type(); )\n-\n-  for (uint i = 1; i < vlen; i++) {\n-    Node* pi = p->at(i);\n-    Node* in = pi->in(opd_idx);\n-    if (get_pack(in) != nullptr) {\n-      assert(false, \"Should already have been unpacked\");\n-      return nullptr;\n-    }\n-    assert(opd_bt == in->bottom_type()->basic_type(), \"all same type\");\n-    pk->add_opd(in);\n-    if (VectorNode::is_muladds2i(pi)) {\n-      Node* in2 = pi->in(opd_idx + 2);\n-      if (get_pack(in2) != nullptr) {\n-        assert(false, \"Should already have been unpacked\");\n-        return nullptr;\n-      }\n-      assert(opd_bt == in2->bottom_type()->basic_type(), \"all same type\");\n-      pk->add_opd(in2);\n-    }\n-  }\n-  phase()->register_new_node_with_ctrl_of(pk, opd);\n-  VectorNode::trace_new_vector(pk, \"SuperWord\");\n-  return pk;\n@@ -2800,12 +2227,1 @@\n-  if (u_pk->size() != d_pk->size()) {\n-    return false;\n-  }\n-\n-  for (uint i = 0; i < u_pk->size(); i++) {\n-    Node* ui = u_pk->at(i);\n-    Node* di = d_pk->at(i);\n-    if (ui->in(u_idx) != di) {\n-      return false;\n-    }\n-  }\n-  return true;\n+  return _packset.pack_input_at_index_or_null(u_pk, u_idx) != nullptr;\n@@ -3173,0 +2589,6 @@\n+    \/\/ Float to half float conversion may be succeeded by a conversion from\n+    \/\/ half float to float, in such a case back propagation of narrow type (SHORT)\n+    \/\/ may not be possible.\n+    if (n->Opcode() == Op_ConvF2HF) {\n+      return TypeInt::SHORT;\n+    }\n@@ -3185,1 +2607,1 @@\n-LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {\n+LoadNode::ControlDependency VTransformLoadVectorNode::control_dependency() const {\n@@ -3187,2 +2609,2 @@\n-  for (uint i = 0; i < p->size(); i++) {\n-    Node* n = p->at(i);\n+  for (int i = 0; i < nodes().length(); i++) {\n+    Node* n = nodes().at(i);\n@@ -3205,2 +2627,2 @@\n-\/\/ determined by SuperWord::filter_packs_for_alignment().\n-void SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n+\/\/ determined (e.g. by SuperWord::filter_packs_for_alignment()).\n+void VTransform::determine_mem_ref_and_aw_for_main_loop_alignment() {\n@@ -3214,4 +2636,0 @@\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    MemNode* first = pack->at(0)->isa_Mem();\n-    if (first == nullptr) { continue; }\n@@ -3219,1 +2637,8 @@\n-    int vw = first->memory_size() * pack->size();\n+  const GrowableArray<VTransformNode*>& vtnodes = _graph.vtnodes();\n+  for (int i = 0; i < vtnodes.length(); i++) {\n+    VTransformVectorNode* vtn = vtnodes.at(i)->isa_Vector();\n+    if (vtn == nullptr) { continue; }\n+    MemNode* p0 = vtn->nodes().at(0)->isa_Mem();\n+    if (p0 == nullptr) { continue; }\n+\n+    int vw = p0->memory_size() * vtn->nodes().length();\n@@ -3222,1 +2647,1 @@\n-      mem_ref = first;\n+      mem_ref = p0;\n@@ -3232,1 +2657,1 @@\n-    if (is_trace_align_vector()) {      \\\n+    if (_trace._align_vector) {         \\\n@@ -3243,1 +2668,1 @@\n-void SuperWord::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n+void VTransform::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n@@ -3400,2 +2825,2 @@\n-  if (is_trace_align_vector()) {\n-    tty->print_cr(\"\\nadjust_pre_loop_limit_to_align_main_loop_vectors:\");\n+  if (_trace._align_vector) {\n+    tty->print_cr(\"\\nVTransform::adjust_pre_loop_limit_to_align_main_loop_vectors:\");\n@@ -3427,1 +2852,1 @@\n-    if (is_trace_align_vector()) {\n+    if (_trace._align_vector) {\n@@ -3443,1 +2868,1 @@\n-  if (is_trace_align_vector()) {\n+  if (_trace._align_vector) {\n@@ -3598,1 +3023,1 @@\n-  tty->print_cr(\"\\nBlock\");\n+  tty->print_cr(\"\\nVLoopBody::print\");\n@@ -3601,1 +3026,1 @@\n-    tty->print(\"%d \", i);\n+    tty->print(\"%4d \", i);\n@@ -3618,0 +3043,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":124,"deletions":698,"binary":false,"changes":822,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/vtransform.hpp\"\n@@ -370,0 +371,4 @@\n+  Node_List* pack_input_at_index_or_null(const Node_List* pack, const int index) const {\n+    return strided_pack_input_at_index_or_null(pack, index, 1, 0);\n+  }\n+\n@@ -602,7 +607,0 @@\n-  bool schedule_and_apply();\n-  bool apply(Node_List& memops_schedule);\n-  void apply_memops_reordering_with_schedule(Node_List& memops_schedule);\n-  bool apply_vectorization();\n-  \/\/ Create a vector operand for the nodes in pack p for operand: in(opd_idx)\n-  Node* vector_opd(Node_List* p, int opd_idx);\n-\n@@ -633,5 +631,1 @@\n-  static LoadNode::ControlDependency control_dependency(Node_List* p);\n-\n-  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n-  void determine_mem_ref_and_aw_for_main_loop_alignment();\n-  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n+  bool schedule_and_apply() const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+\n+void SuperWordVTransformBuilder::build() {\n+  assert(!_packset.is_empty(), \"must have non-empty packset\");\n+  assert(!_vtransform.has_graph(), \"start with empty vtransform\");\n+\n+  \/\/ Create vtnodes for all nodes in the loop.\n+  build_vector_vtnodes_for_packed_nodes();\n+  build_scalar_vtnodes_for_non_packed_nodes();\n+\n+  \/\/ Connect all vtnodes with their inputs. Possibly create vtnodes for input\n+  \/\/ nodes that are outside the loop.\n+  VectorSet vtn_dependencies; \/\/ Shared, but cleared for every vtnode.\n+  build_inputs_for_vector_vtnodes(vtn_dependencies);\n+  build_inputs_for_scalar_vtnodes(vtn_dependencies);\n+}\n+\n+void SuperWordVTransformBuilder::build_vector_vtnodes_for_packed_nodes() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    VTransformVectorNode* vtn = make_vector_vtnode_for_pack(pack);\n+    for (uint k = 0; k < pack->size(); k++) {\n+      map_node_to_vtnode(pack->at(k), vtn);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_scalar_vtnodes_for_non_packed_nodes() {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    if (_packset.get_pack(n) != nullptr) { continue; }\n+    VTransformScalarNode* vtn = new (_vtransform.arena()) VTransformScalarNode(_vtransform, n);\n+    map_node_to_vtnode(n, vtn);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    Node* p0 = pack->at(0);\n+\n+    VTransformVectorNode* vtn = get_vtnode(p0)->isa_Vector();\n+    assert(vtn != nullptr, \"all packs must have vector vtnodes\");\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (p0->is_Load()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+    } else if (p0->is_Store()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_vector(pack, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (vtn->isa_ReductionVector() != nullptr) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, 1); \/\/ scalar init\n+      set_req_with_vector(pack, vtn, vtn_dependencies, 2); \/\/ vector\n+    } else {\n+      assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n+      if (VectorNode::is_scalar_rotate(p0) &&\n+          p0->in(2)->is_Con() &&\n+          Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rotation\n+      } else if (VectorNode::is_roundopD(p0)) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rounding mode\n+      } else if (p0->is_CMove()) {\n+        \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n+        if (vtn_mask_cmp->test()._is_negated) {\n+          vtn->swap_req(2, 3); \/\/ swap if test was negated.\n+        }\n+      } else {\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+      }\n+    }\n+\n+    for (uint k = 0; k < pack->size(); k++) {\n+      add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n+    if (vtn == nullptr) { continue; }\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (n->is_Load()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+    } else if (n->is_Store()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (n->is_CountedLoop()) {\n+      continue; \/\/ Is \"root\", has no dependency.\n+    } else if (n->is_Phi()) {\n+      \/\/ CountedLoop Phi's: ignore backedge (and entry value).\n+      assert(n->in(0) == _vloop.cl(), \"only Phi's from the CountedLoop allowed\");\n+      set_req_with_scalar(n, vtn, vtn_dependencies, 0);\n+      continue;\n+    } else {\n+      set_all_req_with_scalars(n, vtn, vtn_dependencies);\n+    }\n+\n+    add_dependencies_of_node_to_vtnode(n, vtn, vtn_dependencies);\n+  }\n+}\n+\n+\/\/ Create a vtnode for each pack. No in\/out edges set yet.\n+VTransformVectorNode* SuperWordVTransformBuilder::make_vector_vtnode_for_pack(const Node_List* pack) const {\n+  uint pack_size = pack->size();\n+  Node* p0 = pack->at(0);\n+  int opc = p0->Opcode();\n+  VTransformVectorNode* vtn = nullptr;\n+\n+  if (p0->is_Load()) {\n+    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, pack_size);\n+  } else if (p0->is_Store()) {\n+    vtn = new (_vtransform.arena()) VTransformStoreVectorNode(_vtransform, pack_size);\n+  } else if (p0->is_Bool()) {\n+    VTransformBoolTest kind = _packset.get_bool_test(pack);\n+    vtn = new (_vtransform.arena()) VTransformBoolVectorNode(_vtransform, pack_size, kind);\n+  } else if (_vloop_analyzer.reductions().is_marked_reduction(p0)) {\n+    vtn = new (_vtransform.arena()) VTransformReductionVectorNode(_vtransform, pack_size);\n+  } else if (VectorNode::is_muladds2i(p0)) {\n+    \/\/ A special kind of binary element-wise vector op: the inputs are \"ints\" a and b,\n+    \/\/ but reinterpreted as two \"shorts\" [a0, a1] and [b0, b1]:\n+    \/\/   v = MulAddS2I(a, b) = a0 * b0 + a1 + b1\n+    assert(p0->req() == 5, \"MulAddS2I should have 4 operands\");\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, pack_size);\n+  } else {\n+    assert(p0->req() == 3 ||\n+           p0->is_CMove() ||\n+           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc) ||\n+           VectorNode::is_convert_opcode(opc) ||\n+           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc) ||\n+           opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"pack type must be in this list\");\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), pack_size);\n+  }\n+  vtn->set_nodes(pack);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index) {\n+  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n+  vtn->set_req(index, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+\/\/ Either get the existing vtnode vector input (when input is a pack), or else make a\n+\/\/ new vector vtnode for the input (e.g. for Replicate or PopulateIndex).\n+VTransformNode* SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index) {\n+  Node* p0 = pack->at(0);\n+\n+  Node_List* pack_in = _packset.pack_input_at_index_or_null(pack, index);\n+  if (pack_in != nullptr) {\n+    \/\/ Input is a matching pack -> vtnode already exists.\n+    assert(index != 2 || !VectorNode::is_shift(p0), \"shift's count cannot be vector\");\n+    return get_vtnode(pack_in->at(0));\n+  }\n+\n+  if (VectorNode::is_muladds2i(p0)) {\n+    assert(_packset.is_muladds2i_pack_with_pack_inputs(pack), \"inputs must all be packs\");\n+    \/\/ All inputs are strided (stride = 2), either with offset 0 or 1.\n+    Node_List* pack_in0 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 0);\n+    if (pack_in0 != nullptr) {\n+      return get_vtnode(pack_in0->at(0));\n+    }\n+    Node_List* pack_in1 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 1);\n+    if (pack_in1 != nullptr) {\n+      return get_vtnode(pack_in1->at(0));\n+    }\n+  }\n+\n+  Node* same_input = _packset.same_inputs_at_index_or_null(pack, index);\n+  if (same_input == nullptr && p0->in(index) == _vloop.iv()) {\n+    \/\/ PopulateIndex: [iv+0, iv+1, iv+2, ...]\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    BasicType p0_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+    \/\/ If we have subword type, take that type directly. If p0 is some ConvI2L\/F\/D,\n+    \/\/ then the p0_bt can also be L\/F\/D but we need to produce ints for the input of\n+    \/\/ the ConvI2L\/F\/D.\n+    BasicType element_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n+    VTransformNode* populate_index = new (_vtransform.arena()) VTransformPopulateIndexNode(_vtransform, pack->size(), element_bt);\n+    populate_index->set_req(1, iv_vtn);\n+    return populate_index;\n+  }\n+\n+  if (same_input != nullptr) {\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    if (index == 2 && VectorNode::is_shift(p0)) {\n+      \/\/ Scalar shift count for vector shift operation: vec2 = shiftV(vec1, scalar_count)\n+      \/\/ Scalar shift operations masks the shift count, but the vector shift does not, so\n+      \/\/ create a special ShiftCount node.\n+      BasicType element_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n+      VTransformNode* shift_count = new (_vtransform.arena()) VTransformShiftCountNode(_vtransform, pack->size(), element_bt, mask, p0->Opcode());\n+      shift_count->set_req(1, same_input_vtn);\n+      return shift_count;\n+    } else {\n+      \/\/ Replicate the scalar same_input to every vector element.\n+      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+        \/\/ Scalar rotate has int rotation value, but the scalar rotate expects longs.\n+        assert(same_input->bottom_type()->isa_int(), \"scalar rotate expects int rotation\");\n+        VTransformNode* conv = new (_vtransform.arena()) VTransformConvI2LNode(_vtransform);\n+        conv->set_req(1, same_input_vtn);\n+        same_input_vtn = conv;\n+      }\n+      VTransformNode* replicate = new (_vtransform.arena()) VTransformReplicateNode(_vtransform, pack->size(), element_type);\n+      replicate->set_req(1, same_input_vtn);\n+      return replicate;\n+    }\n+  }\n+\n+  \/\/ The input is neither a pack not a same_input node. SuperWord::profitable does not allow\n+  \/\/ any other case. In the future, we could insert a PackNode.\n+#ifdef ASSERT\n+  tty->print_cr(\"\\nSuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index: index=%d\", index);\n+  pack->dump();\n+  assert(false, \"Pack input was neither a pack nor a same_input node\");\n+#endif\n+  ShouldNotReachHere();\n+}\n+\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+  VTransformNode* vtn = get_vtnode_or_null(n);\n+  if (vtn != nullptr) { return vtn; }\n+\n+  assert(!_vloop.in_bb(n), \"only nodes outside the loop can be input nodes to the loop\");\n+  vtn = new (_vtransform.arena()) VTransformInputScalarNode(_vtransform, n);\n+  map_node_to_vtnode(n, vtn);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, int j) {\n+  VTransformNode* req = get_or_make_vtnode_vector_input_at_index(pack, j);\n+  vtn->set_req(j, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  assert(vtn->req() == n->req(), \"scalars must have same number of reqs\");\n+  for (uint j = 0; j < n->req(); j++) {\n+    Node* def = n->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_scalar(n, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  Node* p0 = pack->at(0);\n+  assert(vtn->req() <= p0->req(), \"must have at at most as many reqs\");\n+  \/\/ Vectors have no ctrl, so ignore it.\n+  for (uint j = 1; j < vtn->req(); j++) {\n+    Node* def = p0->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_vector(pack, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::add_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  for (VLoopDependencyGraph::PredsIterator preds(_vloop_analyzer.dependency_graph(), n); !preds.done(); preds.next()) {\n+    Node* pred = preds.current();\n+    if (!_vloop.in_bb(pred)) { continue; }\n+\n+    \/\/ Only add memory dependencies to memory nodes. All others are taken care of with the req.\n+    if (n->is_Mem() && !pred->is_Mem()) { continue; }\n+\n+    VTransformNode* dependency = get_vtnode(pred);\n+\n+    \/\/ Reduction self-cycle?\n+    if (vtn == dependency && _vloop_analyzer.reductions().is_marked_reduction(n)) { continue; }\n+\n+    if (vtn_dependencies.test_set(dependency->_idx)) { continue; }\n+    vtn->add_dependency(dependency); \/\/ Add every dependency only once per vtn.\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/superword.hpp\"\n+\n+#ifndef SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+#define SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+\n+\/\/ Facility class that builds a VTransform from a SuperWord PackSet.\n+class SuperWordVTransformBuilder : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+  const PackSet& _packset;\n+  VTransform& _vtransform;\n+\n+  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n+\n+public:\n+  SuperWordVTransformBuilder(const PackSet& packset,\n+                             VTransform& vtransform) :\n+      _vloop_analyzer(vtransform.vloop_analyzer()),\n+      _vloop(_vloop_analyzer.vloop()),\n+      _packset(packset),\n+      _vtransform(vtransform)\n+  {\n+    assert(!_vtransform.has_graph(), \"constructor is passed an empty vtransform\");\n+    build();\n+    assert(_vtransform.has_graph(), \"vtransform must contain some vtnodes now\");\n+  }\n+\n+private:\n+  void build();\n+  void build_vector_vtnodes_for_packed_nodes();\n+  void build_scalar_vtnodes_for_non_packed_nodes();\n+  void build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies);\n+  void build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies);\n+\n+  \/\/ Helper methods for building VTransform.\n+  VTransformNode* get_vtnode_or_null(Node* n) const {\n+    VTransformNode** ptr = _idx_to_vtnode.get(n->_idx);\n+    return (ptr == nullptr) ? nullptr : *ptr;\n+  }\n+\n+  VTransformNode* get_vtnode(Node* n) const {\n+    VTransformNode* vtn = get_vtnode_or_null(n);\n+    assert(vtn != nullptr, \"expect non-null vtnode\");\n+    return vtn;\n+  }\n+\n+  void map_node_to_vtnode(Node* n, VTransformNode* vtn) {\n+    assert(vtn != nullptr, \"only set non-null vtnodes\");\n+    _idx_to_vtnode.put_when_absent(n->_idx, vtn);\n+  }\n+\n+  VTransformVectorNode* make_vector_vtnode_for_pack(const Node_List* pack) const;\n+  VTransformNode* get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index);\n+  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n+  void set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void add_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+};\n+\n+#endif \/\/ SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+  flags(VTRANSFORM,           \"Trace VTransform Graph\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"opto\/matcher.hpp\"\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"opto\/node.hpp\"\n+#include \"opto\/matcher.hpp\"\n@@ -766,3 +766,3 @@\n-  bool overlap_possible_with_any_in(const Node_List* p) const {\n-    for (uint k = 0; k < p->size(); k++) {\n-      MemNode* mem = p->at(k)->as_Mem();\n+  bool overlap_possible_with_any_in(const GrowableArray<Node*>& nodes) const {\n+    for (int i = 0; i < nodes.length(); i++) {\n+      MemNode* mem = nodes.at(i)->as_Mem();\n@@ -1326,8 +1326,0 @@\n-struct VTransformBoolTest {\n-  const BoolTest::mask _mask;\n-  const bool _is_negated;\n-\n-  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n-    _mask(mask), _is_negated(is_negated) {}\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+#include \"opto\/convertnode.hpp\"\n+\n+void VTransformGraph::add_vtnode(VTransformNode* vtnode) {\n+  assert(vtnode->_idx == _vtnodes.length(), \"position must match idx\");\n+  _vtnodes.push(vtnode);\n+}\n+\n+\/\/ Compute a linearization of the graph. We do this with a reverse-post-order of a DFS.\n+\/\/ This only works if the graph is a directed acyclic graph (DAG). The C2 graph, and\n+\/\/ the VLoopDependencyGraph are both DAGs, but after introduction of vectors\/packs, the\n+\/\/ graph has additional constraints which can introduce cycles. Example:\n+\/\/\n+\/\/                                                       +--------+\n+\/\/  A -> X                                               |        v\n+\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n+\/\/  Y -> B                                                 ^        |\n+\/\/                                                         +--------+\n+\/\/\n+\/\/ We return \"true\" IFF we find no cycle, i.e. if the linearization succeeds.\n+bool VTransformGraph::schedule() {\n+  assert(!is_scheduled(), \"not yet scheduled\");\n+\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    print_vtnodes();\n+  }\n+#endif\n+\n+  ResourceMark rm;\n+  GrowableArray<VTransformNode*> stack;\n+  VectorSet pre_visited;\n+  VectorSet post_visited;\n+\n+  collect_nodes_without_req_or_dependency(stack);\n+\n+  \/\/ We create a reverse-post-visit order. This gives us a linearization, if there are\n+  \/\/ no cycles. Then, we simply reverse the order, and we have a schedule.\n+  int rpo_idx = _vtnodes.length() - 1;\n+  while (!stack.is_empty()) {\n+    VTransformNode* vtn = stack.top();\n+    if (!pre_visited.test_set(vtn->_idx)) {\n+      \/\/ Forward arc in graph (pre-visit).\n+    } else if (!post_visited.test(vtn->_idx)) {\n+      \/\/ Forward arc in graph. Check if all uses were already visited:\n+      \/\/   Yes -> post-visit.\n+      \/\/   No  -> we are mid-visit.\n+      bool all_uses_already_visited = true;\n+\n+      for (int i = 0; i < vtn->outs(); i++) {\n+        VTransformNode* use = vtn->out(i);\n+        if (post_visited.test(use->_idx)) { continue; }\n+        if (pre_visited.test(use->_idx)) {\n+          \/\/ Cycle detected!\n+          \/\/ The nodes that are pre_visited but not yet post_visited form a path from\n+          \/\/ the \"root\" to the current vtn. Now, we are looking at an edge (vtn, use),\n+          \/\/ and discover that use is also pre_visited but not post_visited. Thus, use\n+          \/\/ lies on that path from \"root\" to vtn, and the edge (vtn, use) closes a\n+          \/\/ cycle.\n+          NOT_PRODUCT(if (_trace._rejections) { trace_schedule_cycle(stack, pre_visited, post_visited); } )\n+          return false;\n+        }\n+        stack.push(use);\n+        all_uses_already_visited = false;\n+      }\n+\n+      if (all_uses_already_visited) {\n+        stack.pop();\n+        post_visited.set(vtn->_idx);           \/\/ post-visit\n+        _schedule.at_put_grow(rpo_idx--, vtn); \/\/ assign rpo_idx\n+      }\n+    } else {\n+      stack.pop(); \/\/ Already post-visited. Ignore secondary edge.\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    print_schedule();\n+  }\n+#endif\n+\n+  assert(rpo_idx == -1, \"used up all rpo_idx, rpo_idx=%d\", rpo_idx);\n+  return true;\n+}\n+\n+\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n+void VTransformGraph::collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    VTransformNode* vtn = _vtnodes.at(i);\n+    if (!vtn->has_req_or_dependency()) {\n+      stack.push(vtn);\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                                           const VectorSet& pre_visited,\n+                                           const VectorSet& post_visited) const {\n+  tty->print_cr(\"\\nVTransform::schedule found a cycle on path (P), vectorization attempt fails.\");\n+  for (int j = 0; j < stack.length(); j++) {\n+    VTransformNode* n = stack.at(j);\n+    bool on_path = pre_visited.test(n->_idx) && !post_visited.test(n->_idx);\n+    tty->print(\"  %s \", on_path ? \"P\" : \"_\");\n+    n->print();\n+  }\n+}\n+\n+void VTransformApplyResult::trace(VTransformNode* vtnode) const {\n+  tty->print(\"  apply: \");\n+  vtnode->print();\n+  tty->print(\"    ->   \");\n+  if (_node == nullptr) {\n+    tty->print_cr(\"nullptr\");\n+  } else {\n+    _node->dump();\n+  }\n+}\n+#endif\n+\n+Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n+  assert(n != nullptr, \"must find input IR node\");\n+  return n;\n+}\n+\n+VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                  const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                     const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  VectorNode* vn = VectorNode::scalar2vector(val, _vlen, _element_type);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                   const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* n = new ConvI2LNode(val);\n+  register_new_node_from_vectorization(vloop_analyzer, n, val);\n+  return VTransformApplyResult::make_scalar(n);\n+}\n+\n+VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(shift_count_in->bottom_type()->isa_int(), \"int type only for shift count\");\n+  \/\/ The shift_count_in would be automatically truncated to the lowest _mask\n+  \/\/ bits in a scalar shift operation. But vector shift does not truncate, so\n+  \/\/ we must apply the mask now.\n+  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n+  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n+  \/\/ Now that masked value is \"boadcast\" (some platforms only set the lowest element).\n+  VectorNode* vn = VectorNode::shift_count(_shift_opcode, shift_count_masked, _vlen, _element_bt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+\n+VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                         const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(val->is_Phi(), \"expected to be iv\");\n+  assert(VectorNode::is_populate_index_supported(_element_bt), \"should support\");\n+  const TypeVect* vt = TypeVect::make(_element_bt, _vlen);\n+  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                             const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  if (first->is_Cmp()) {\n+    \/\/ Cmp + Bool -> VectorMaskCmp\n+    \/\/ Handled by Bool \/ VTransformBoolVectorNode, so we do not generate any nodes here.\n+    return VTransformApplyResult::make_empty();\n+  }\n+\n+  assert(2 <= req() && req() <= 4, \"Must have 1-3 inputs\");\n+  VectorNode* vn = nullptr;\n+  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n+  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n+\n+  if (first->is_CMove()) {\n+    assert(req() == 4, \"three inputs expected: mask, blend1, blend2\");\n+    vn = new VectorBlendNode(\/* blend1 *\/ in2, \/* blend2 *\/ in3, \/* mask *\/ in1);\n+  } else if (VectorNode::is_convert_opcode(opc)) {\n+    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n+    int vopc = VectorCastNode::opcode(opc, in1->bottom_type()->is_vect()->element_basic_type());\n+    vn = VectorCastNode::make(vopc, in1, bt, vlen);\n+  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(first, bt)) {\n+    opc = Op_RShiftI;\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt);\n+  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n+    \/\/ The scalar operation was a long -> int operation.\n+    \/\/ However, the vector operation is long -> long.\n+    VectorNode* long_vn = VectorNode::make(opc, in1, nullptr, vlen, T_LONG);\n+    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n+    \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n+    vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n+  } else if (req() == 3 ||\n+             VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n+    assert(!VectorNode::is_roundopD(first) || in2->is_Con(), \"rounding mode must be constant\");\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt); \/\/ unary and binary\n+  } else {\n+    assert(req() == 4, \"three inputs expected\");\n+    assert(opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"element wise operation must be from this list\");\n+    vn = VectorNode::make(opc, in1, in2, in3, vlen, bt); \/\/ ternary\n+  }\n+\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  BoolNode* first = nodes().at(0)->as_Bool();\n+  uint  vlen = nodes().length();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Cmp + Bool -> VectorMaskCmp\n+  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n+  assert(vtn_cmp != nullptr && vtn_cmp->nodes().at(0)->is_Cmp(),\n+         \"bool vtn expects cmp vtn as input\");\n+\n+  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n+  BoolTest::mask mask = test()._mask;\n+\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n+  VectorNode* vn = new VectorMaskCmpNode(mask, cmp_in1, cmp_in2, mask_node, vt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                           const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = first->bottom_type()->basic_type();\n+\n+  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n+\n+  ReductionNode* vn = ReductionNode::make(opc, nullptr, init, vec, bt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  LoadNode* first = nodes().at(0)->as_Load();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Set the memory dependency of the LoadVector as early as possible.\n+  \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n+  \/\/ does not have any memory dependency.\n+  while (mem->is_StoreVector()) {\n+    VPointer p_store(mem->as_Mem(), vloop_analyzer.vloop());\n+    if (p_store.overlap_possible_with_any_in(nodes())) {\n+      break;\n+    } else {\n+      mem = mem->in(MemNode::Memory);\n+    }\n+  }\n+\n+  LoadVectorNode* vn = LoadVectorNode::make(opc, ctrl, mem, adr, adr_type, vlen, bt,\n+                                            control_dependency());\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                       const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  StoreNode* first = nodes().at(0)->as_Store();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+\n+  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n+  StoreVectorNode* vn = StoreVectorNode::make(opc, ctrl, mem, adr, adr_type, value, vlen);\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* first = nodes().at(0);\n+\n+  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n+\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    phase->igvn().replace_node(n, vn);\n+  }\n+}\n+\n+void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  phase->register_new_node_with_ctrl_of(vn, old_node);\n+  phase->igvn()._worklist.push(vn);\n+  VectorNode::trace_new_vector(vn, \"AutoVectorization\");\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::print_vtnodes() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_vtnodes:\");\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    _vtnodes.at(i)->print();\n+  }\n+}\n+\n+void VTransformGraph::print_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_schedule:\");\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    tty->print(\" %3d: \", i);\n+    VTransformNode* vtn = _schedule.at(i);\n+    if (vtn == nullptr) {\n+      tty->print_cr(\"nullptr\");\n+    } else {\n+      vtn->print();\n+    }\n+  }\n+}\n+\n+void VTransformGraph::print_memops_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_memops_schedule:\");\n+  int i = 0;\n+  for_each_memop_in_schedule([&] (MemNode* mem) {\n+    tty->print(\" %3d: \", i++);\n+    mem->dump();\n+  });\n+}\n+\n+void VTransformNode::print() const {\n+  tty->print(\"%3d %s (\", _idx, name());\n+  for (uint i = 0; i < _req; i++) {\n+    print_node_idx(_in.at(i));\n+  }\n+  if ((uint)_in.length() > _req) {\n+    tty->print(\" |\");\n+    for (int i = _req; i < _in.length(); i++) {\n+      print_node_idx(_in.at(i));\n+    }\n+  }\n+  tty->print(\") [\");\n+  for (int i = 0; i < _out.length(); i++) {\n+    print_node_idx(_out.at(i));\n+  }\n+  tty->print(\"] \");\n+  print_spec();\n+  tty->cr();\n+}\n+\n+void VTransformNode::print_node_idx(const VTransformNode* vtn) {\n+  if (vtn == nullptr) {\n+    tty->print(\" _\");\n+  } else {\n+    tty->print(\" %d\", vtn->_idx);\n+  }\n+}\n+\n+void VTransformScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformReplicateNode::print_spec() const {\n+  tty->print(\"vlen=%d element_type=\", _vlen);\n+  _element_type->dump();\n+}\n+\n+void VTransformShiftCountNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s mask=%d shift_opcode=%s\",\n+             _vlen, type2name(_element_bt), _mask,\n+             NodeClassNames[_shift_opcode]);\n+}\n+\n+void VTransformPopulateIndexNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s\", _vlen, type2name(_element_bt));\n+}\n+\n+void VTransformVectorNode::print_spec() const {\n+  tty->print(\"%d-pack[\", _nodes.length());\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    if (i > 0) {\n+      tty->print(\", \");\n+    }\n+    tty->print(\"%d %s\", n->_idx, n->Name());\n+  }\n+  tty->print(\"]\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_OPTO_VTRANSFORM_HPP\n+#define SHARE_OPTO_VTRANSFORM_HPP\n+\n+#include \"opto\/node.hpp\"\n+#include \"opto\/vectorization.hpp\"\n+\n+\/\/ VTransform:\n+\/\/ - Models the transformation of the scalar loop to vectorized loop:\n+\/\/   It is a \"C2 subgraph\" -> \"C2 subgraph\" mapping.\n+\/\/ - The VTransform contains a graph (VTransformGraph), which consists of\n+\/\/   many vtnodes (VTransformNode).\n+\/\/ - Each vtnode models a part of the transformation, and is supposed\n+\/\/   to represent the output C2 nodes after the vectorization as closely\n+\/\/   as possible.\n+\/\/\n+\/\/ This is the life-cycle of a VTransform:\n+\/\/ - Construction:\n+\/\/   - From SuperWord, with the SuperWordVTransformBuilder.\n+\/\/\n+\/\/ - Future Plans: optimize, if-conversion, etc.\n+\/\/\n+\/\/ - Schedule:\n+\/\/   - Compute linearization of the VTransformGraph, into an order that respects\n+\/\/     all edges in the graph (bailout if cycle detected).\n+\/\/\n+\/\/ - Apply:\n+\/\/   - Changes to the C2 IR are only made once the \"apply\" method is called.\n+\/\/   - Each vtnode generates its corresponding scalar and vector C2 nodes,\n+\/\/     possibly replacing old scalar C2 nodes.\n+\/\/\n+\/\/ Future Plans with VTransform:\n+\/\/ - Cost model: estimate if vectorization is profitable.\n+\/\/ - Optimizations: moving unordered reductions out of the loop, whih decreases cost.\n+\/\/ - Pack\/Unpack\/Shuffle: introduce additional nodes not present in the scalar loop.\n+\/\/                        This is difficult to do with the SuperWord packset approach.\n+\/\/ - If-conversion: convert predicated nodes into CFG.\n+\n+typedef int VTransformNodeIDX;\n+class VTransformNode;\n+class VTransformScalarNode;\n+class VTransformInputScalarNode;\n+class VTransformVectorNode;\n+class VTransformElementWiseVectorNode;\n+class VTransformBoolVectorNode;\n+class VTransformReductionVectorNode;\n+\n+\/\/ Result from VTransformNode::apply\n+class VTransformApplyResult {\n+private:\n+  Node* const _node;\n+  const uint _vector_length; \/\/ number of elements\n+  const uint _vector_width;  \/\/ total width in bytes\n+\n+  VTransformApplyResult(Node* n, uint vector_length, uint vector_width) :\n+    _node(n),\n+    _vector_length(vector_length),\n+    _vector_width(vector_width) {}\n+\n+public:\n+  static VTransformApplyResult make_scalar(Node* n) {\n+    return VTransformApplyResult(n, 0, 0);\n+  }\n+\n+  static VTransformApplyResult make_vector(Node* n, uint vector_length, uint vector_width) {\n+    assert(vector_length > 0 && vector_width > 0, \"must have nonzero size\");\n+    return VTransformApplyResult(n, vector_length, vector_width);\n+  }\n+\n+  static VTransformApplyResult make_empty() {\n+    return VTransformApplyResult(nullptr, 0, 0);\n+  }\n+\n+  Node* node() const { return _node; }\n+  uint vector_length() const { return _vector_length; }\n+  uint vector_width() const { return _vector_width; }\n+  NOT_PRODUCT( void trace(VTransformNode* vtnode) const; )\n+};\n+\n+#ifndef PRODUCT\n+\/\/ Convenience class for tracing flags.\n+class VTransformTrace {\n+public:\n+  const bool _verbose;\n+  const bool _rejections;\n+  const bool _align_vector;\n+  const bool _info;\n+\n+  VTransformTrace(const VTrace& vtrace,\n+                  const bool is_trace_rejections,\n+                  const bool is_trace_align_vector,\n+                  const bool is_trace_info) :\n+    _verbose     (vtrace.is_trace(TraceAutoVectorizationTag::ALL)),\n+    _rejections  (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n+    _align_vector(_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n+    _info        (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n+\n+  static bool is_trace_vtransform(const VTrace& vtrace) {\n+    return vtrace.is_trace(TraceAutoVectorizationTag::VTRANSFORM);\n+  }\n+};\n+#endif\n+\n+\/\/ VTransformGraph: component of VTransform\n+\/\/ See description at top of this file.\n+class VTransformGraph : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  NOT_PRODUCT(const VTransformTrace _trace;)\n+\n+  VTransformNodeIDX _next_idx;\n+  GrowableArray<VTransformNode*> _vtnodes;\n+\n+  \/\/ Schedule (linearization) of the graph. We use this to reorder the memory graph\n+  \/\/ before inserting vector operations.\n+  GrowableArray<VTransformNode*> _schedule;\n+\n+public:\n+  VTransformGraph(const VLoopAnalyzer& vloop_analyzer,\n+                  Arena& arena\n+                  NOT_PRODUCT( COMMA const VTransformTrace trace)) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    NOT_PRODUCT(_trace(trace) COMMA)\n+    _next_idx(0),\n+    _vtnodes(&arena, _vloop.estimated_body_length(), 0, nullptr),\n+    _schedule(&arena, _vloop.estimated_body_length(), 0, nullptr) {}\n+\n+  VTransformNodeIDX new_idx() { return _next_idx++; }\n+  void add_vtnode(VTransformNode* vtnode);\n+  DEBUG_ONLY( bool is_empty() const { return _vtnodes.is_empty(); } )\n+  DEBUG_ONLY( bool is_scheduled() const { return _schedule.is_nonempty(); } )\n+  const GrowableArray<VTransformNode*>& vtnodes() const { return _vtnodes; }\n+\n+  bool schedule();\n+  void apply_memops_reordering_with_schedule() const;\n+  void apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const;\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  bool in_bb(const Node* n)   const { return _vloop.in_bb(n); }\n+\n+  void collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+\n+  template<typename Callback>\n+  void for_each_memop_in_schedule(Callback callback) const;\n+\n+#ifndef PRODUCT\n+  void print_vtnodes() const;\n+  void print_schedule() const;\n+  void print_memops_schedule() const;\n+  void trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                            const VectorSet& pre_visited,\n+                            const VectorSet& post_visited) const;\n+#endif\n+};\n+\n+\/\/ VTransform: models the transformation of the scalar loop to vectorized loop.\n+\/\/ It is a \"C2 subgraph\" to \"C2 subgraph\" mapping.\n+\/\/ See description at top of this file.\n+class VTransform : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  NOT_PRODUCT(const VTransformTrace _trace;)\n+\n+  \/\/ Everything in the vtransform is allocated from this arena, including all vtnodes.\n+  Arena _arena;\n+\n+  VTransformGraph _graph;\n+\n+  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ by adjusting the pre-loop limit.\n+  MemNode const* _mem_ref_for_main_loop_alignment;\n+  int _aw_for_main_loop_alignment;\n+\n+public:\n+  VTransform(const VLoopAnalyzer& vloop_analyzer,\n+             MemNode const* mem_ref_for_main_loop_alignment,\n+             int aw_for_main_loop_alignment\n+             NOT_PRODUCT( COMMA const VTransformTrace trace)\n+             ) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    NOT_PRODUCT(_trace(trace) COMMA)\n+    _arena(mtCompiler),\n+    _graph(_vloop_analyzer, _arena NOT_PRODUCT(COMMA _trace)),\n+    _mem_ref_for_main_loop_alignment(mem_ref_for_main_loop_alignment),\n+    _aw_for_main_loop_alignment(aw_for_main_loop_alignment) {}\n+\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+  Arena* arena() { return &_arena; }\n+  DEBUG_ONLY( bool has_graph() const { return !_graph.is_empty(); } )\n+  VTransformGraph& graph() { return _graph; }\n+\n+  bool schedule() { return _graph.schedule(); }\n+  void apply();\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  IdealLoopTree* lpt()        const { return _vloop.lpt(); }\n+  CountedLoopNode* cl()       const { return _vloop.cl(); }\n+  int iv_stride()             const { return cl()->stride_con(); }\n+\n+  \/\/ VLoopVPointers accessors\n+  const VPointer& vpointer(const MemNode* mem) const {\n+    return _vloop_analyzer.vpointers().vpointer(mem);\n+  }\n+\n+  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n+  void determine_mem_ref_and_aw_for_main_loop_alignment();\n+  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n+\n+  void apply_vectorization() const;\n+};\n+\n+\/\/ The vtnodes (VTransformNode) resemble the C2 IR Nodes, and model a part of the\n+\/\/ VTransform. Many such vtnodes make up the VTransformGraph. The vtnodes represent\n+\/\/ the resulting scalar and vector nodes as closely as possible.\n+\/\/ See description at top of this file.\n+class VTransformNode : public ArenaObj {\n+public:\n+  const VTransformNodeIDX _idx;\n+\n+private:\n+  \/\/ _in is split into required inputs (_req), and additional dependencies.\n+  const uint _req;\n+  GrowableArray<VTransformNode*> _in;\n+  GrowableArray<VTransformNode*> _out;\n+\n+public:\n+  VTransformNode(VTransform& vtransform, const uint req) :\n+    _idx(vtransform.graph().new_idx()),\n+    _req(req),\n+    _in(vtransform.arena(),  req, req, nullptr),\n+    _out(vtransform.arena(), 4, 0, nullptr)\n+  {\n+    vtransform.graph().add_vtnode(this);\n+  }\n+\n+  void set_req(uint i, VTransformNode* n) {\n+    assert(i < _req, \"must be a req\");\n+    assert(_in.at(i) == nullptr && n != nullptr, \"only set once\");\n+    _in.at_put(i, n);\n+    n->add_out(this);\n+  }\n+\n+  void swap_req(uint i, uint j) {\n+    assert(i < _req, \"must be a req\");\n+    assert(j < _req, \"must be a req\");\n+    VTransformNode* tmp = _in.at(i);\n+    _in.at_put(i, _in.at(j));\n+    _in.at_put(j, tmp);\n+  }\n+\n+  void add_dependency(VTransformNode* n) {\n+    assert(n != nullptr, \"no need to add nullptr\");\n+    _in.push(n);\n+    n->add_out(this);\n+  }\n+\n+  void add_out(VTransformNode* n) {\n+    _out.push(n);\n+  }\n+\n+  uint req() const { return _req; }\n+  VTransformNode* in(int i) const { return _in.at(i); }\n+  int outs() const { return _out.length(); }\n+  VTransformNode* out(int i) const { return _out.at(i); }\n+\n+  bool has_req_or_dependency() const {\n+    for (int i = 0; i < _in.length(); i++) {\n+      if (_in.at(i) != nullptr) { return true; }\n+    }\n+    return false;\n+  }\n+\n+  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n+  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformVectorNode* isa_Vector() { return nullptr; }\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() { return nullptr; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() { return nullptr; }\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() { return nullptr; }\n+\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n+\n+  Node* find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const;\n+\n+  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n+\n+  NOT_PRODUCT(virtual const char* name() const = 0;)\n+  NOT_PRODUCT(void print() const;)\n+  NOT_PRODUCT(virtual void print_spec() const {};)\n+  NOT_PRODUCT(static void print_node_idx(const VTransformNode* vtn);)\n+};\n+\n+\/\/ Identity transform for scalar nodes.\n+class VTransformScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n) {}\n+  Node* node() const { return _node; }\n+  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Wrapper node for nodes outside the loop that are inputs to nodes in the loop.\n+\/\/ Since we want the loop-internal nodes to be able to reference all inputs as vtnodes,\n+\/\/ we must wrap the inputs that are outside the loop into special vtnodes, too.\n+class VTransformInputScalarNode : public VTransformScalarNode {\n+public:\n+  VTransformInputScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformScalarNode(vtransform, n) {}\n+  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n+  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+};\n+\n+\/\/ Transform produces a ReplicateNode, replicating the input to all vector lanes.\n+class VTransformReplicateNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const Type* _element_type;\n+public:\n+  VTransformReplicateNode(VTransform& vtransform, int vlen, const Type* element_type) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_type(element_type) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Replicate\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a scalar ConvI2LNode that was not previously in the C2 graph.\n+class VTransformConvI2LNode : public VTransformNode {\n+public:\n+  VTransformConvI2LNode(VTransform& vtransform) : VTransformNode(vtransform, 2) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ConvI2L\"; };)\n+};\n+\n+\/\/ Transform introduces a shift-count node that truncates the shift count for a vector shift.\n+class VTransformShiftCountNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+  juint _mask;\n+  int _shift_opcode;\n+public:\n+  VTransformShiftCountNode(VTransform& vtransform, int vlen, BasicType element_bt, juint mask, int shift_opcode) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_bt(element_bt), _mask(mask), _shift_opcode(shift_opcode) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ShiftCount\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a PopulateIndex node: [phi, phi+1, phi+2, phi+3, ...].\n+class VTransformPopulateIndexNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+public:\n+  VTransformPopulateIndexNode(VTransform& vtransform, int vlen, const BasicType element_bt) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_bt(element_bt) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"PopulateIndex\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Base class for all vector vtnodes.\n+class VTransformVectorNode : public VTransformNode {\n+private:\n+  GrowableArray<Node*> _nodes;\n+public:\n+  VTransformVectorNode(VTransform& vtransform, const uint req, const uint number_of_nodes) :\n+    VTransformNode(vtransform, req), _nodes(vtransform.arena(), number_of_nodes, number_of_nodes, nullptr) {}\n+\n+  void set_nodes(const Node_List* pack) {\n+    for (uint k = 0; k < pack->size(); k++) {\n+      _nodes.at_put(k, pack->at(k));\n+    }\n+  }\n+\n+  const GrowableArray<Node*>& nodes() const { return _nodes; }\n+  virtual VTransformVectorNode* isa_Vector() override { return this; }\n+  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Catch all for all element-wise vector operations.\n+class VTransformElementWiseVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformElementWiseVectorNode(VTransform& vtransform, uint req, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, req, number_of_nodes) {}\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ElementWiseVector\"; };)\n+};\n+\n+struct VTransformBoolTest {\n+  const BoolTest::mask _mask;\n+  const bool _is_negated;\n+\n+  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n+    _mask(mask), _is_negated(is_negated) {}\n+};\n+\n+class VTransformBoolVectorNode : public VTransformElementWiseVectorNode {\n+private:\n+  const VTransformBoolTest _test;\n+public:\n+  VTransformBoolVectorNode(VTransform& vtransform, uint number_of_nodes, VTransformBoolTest test) :\n+    VTransformElementWiseVectorNode(vtransform, 2, number_of_nodes), _test(test) {}\n+  VTransformBoolTest test() const { return _test; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"BoolVector\"; };)\n+};\n+\n+class VTransformReductionVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, scalar init, vector]\n+  VTransformReductionVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ReductionVector\"; };)\n+};\n+\n+class VTransformLoadVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, mem, adr]\n+  VTransformLoadVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  LoadNode::ControlDependency control_dependency() const;\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoadVector\"; };)\n+};\n+\n+class VTransformStoreVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 4 -> [ctrl, mem, adr, val]\n+  VTransformStoreVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 4, number_of_nodes) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"StoreVector\"; };)\n+};\n+\n+\/\/ Invoke callback on all memops, in the order of the schedule.\n+template<typename Callback>\n+void VTransformGraph::for_each_memop_in_schedule(Callback callback) const {\n+  assert(_schedule.length() == _vtnodes.length(), \"schedule was computed\");\n+\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+\n+    \/\/ We can ignore input nodes, they are outside the loop.\n+    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+\n+    VTransformScalarNode* scalar = vtn->isa_Scalar();\n+    if (scalar != nullptr && scalar->node()->is_Mem()) {\n+      callback(scalar->node()->as_Mem());\n+    }\n+\n+    VTransformVectorNode* vector = vtn->isa_Vector();\n+    if (vector != nullptr && vector->nodes().at(0)->is_Mem()) {\n+      for (int j = 0; j < vector->nodes().length(); j++) {\n+        callback(vector->nodes().at(j)->as_Mem());\n+      }\n+    }\n+  }\n+}\n+\n+#endif \/\/ SHARE_OPTO_VTRANSFORM_HPP\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"},{"patch":"@@ -117,0 +117,3 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#endif\n@@ -523,0 +526,9 @@\n+JVM_LEAF(jboolean, JVM_IsContainerized(void))\n+#ifdef LINUX\n+  if (OSContainer::is_containerized()) {\n+    return JNI_TRUE;\n+  }\n+#endif\n+  return JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2342,1 +2342,1 @@\n-  ClassLoaderDataGraph::modules_do(&do_module);\n+  ClassLoaderDataGraph::modules_do_keepalive(&do_module);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    ClassLoaderDataGraph::loaded_classes_do(&closure);\n+    ClassLoaderDataGraph::loaded_classes_do_keepalive(&closure);\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-class OldRegionsLivenessClosure: public HeapRegionClosure {\n+class OldRegionsLivenessClosure: public G1HeapRegionClosure {\n@@ -1121,0 +1121,4 @@\n+size_t WhiteBox::get_in_use_monitor_count() {\n+  return ObjectSynchronizer::_in_use_list.count();\n+}\n+\n@@ -1856,0 +1860,4 @@\n+WB_ENTRY(jlong, WB_getInUseMonitorCount(JNIEnv* env, jobject wb))\n+  return (jlong) WhiteBox::get_in_use_monitor_count();\n+WB_END\n+\n@@ -2935,0 +2943,1 @@\n+  {CC\"getInUseMonitorCount\", CC\"()J\", (void*)&WB_getInUseMonitorCount  },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  static size_t get_in_use_monitor_count();\n","filename":"src\/hotspot\/share\/prims\/whitebox.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -526,0 +526,1 @@\n+  { \"UseVtableBasedCHA\",               JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -977,1 +977,0 @@\n-  ResourceMark rm(thread);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -992,3 +992,0 @@\n-  product(bool, UseVtableBasedCHA, true,  DIAGNOSTIC,                       \\\n-          \"Use vtable information during CHA\")                              \\\n-                                                                            \\\n@@ -1435,3 +1432,0 @@\n-  develop(bool, MetaspaceGuardAllocations, false,                           \\\n-          \"Metapace allocations are guarded.\")                              \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-    MemMapPrinter::print_all_mappings(tty, false);\n+    MemMapPrinter::print_all_mappings(tty);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1445,1 +1445,1 @@\n-  JFR_ONLY(return vmSymbols::jdk_jfr_internal_HiddenWait() == monitor_klass->name();)\n+  JFR_ONLY(return vmSymbols::jdk_jfr_internal_management_HiddenWait() == monitor_klass->name();)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -941,3 +941,4 @@\n-ATTRIBUTE_NO_ASAN static bool read_safely_from(intptr_t* p, intptr_t* result) {\n-  const intptr_t errval = 0x1717;\n-  intptr_t i = SafeFetchN(p, errval);\n+ATTRIBUTE_NO_ASAN static bool read_safely_from(const uintptr_t* p, uintptr_t* result) {\n+  DEBUG_ONLY(*result = 0xAAAA;)\n+  const uintptr_t errval = 0x1717;\n+  uintptr_t i = (uintptr_t)SafeFetchN((intptr_t*)p, errval);\n@@ -945,1 +946,1 @@\n-    i = SafeFetchN(p, ~errval);\n+    i = (uintptr_t)SafeFetchN((intptr_t*)p, ~errval);\n@@ -950,1 +951,1 @@\n-  (*result) = i;\n+  (*result) = (uintptr_t)i;\n@@ -954,1 +955,15 @@\n-static void print_hex_location(outputStream* st, address p, int unitsize) {\n+\/\/ Helper for os::print_hex_dump\n+static void print_ascii_form(stringStream& ascii_form, uint64_t value, int unitsize) {\n+  union {\n+    uint64_t v;\n+    uint8_t c[sizeof(v)];\n+  } u = { value };\n+  for (int i = 0; i < unitsize; i++) {\n+    const int idx = LITTLE_ENDIAN_ONLY(i) BIG_ENDIAN_ONLY(sizeof(u.v) - unitsize + i);\n+    const uint8_t c = u.c[idx];\n+    ascii_form.put(isprint(c) && isascii(c) ? c : '.');\n+  }\n+}\n+\n+\/\/ Helper for os::print_hex_dump\n+static void print_hex_location(outputStream* st, const_address p, int unitsize, stringStream& ascii_form) {\n@@ -956,1 +971,1 @@\n-  address pa = align_down(p, sizeof(intptr_t));\n+  const uintptr_t* pa = (const uintptr_t*) align_down(p, sizeof(intptr_t));\n@@ -960,3 +975,3 @@\n-    intptr_t i1, i2;\n-    if (read_safely_from((intptr_t*)pa, &i1) &&\n-        read_safely_from((intptr_t*)pa + 1, &i2)) {\n+    uintptr_t i1 = 0, i2 = 0;\n+    if (read_safely_from(pa, &i1) &&\n+        read_safely_from(pa + 1, &i2)) {\n@@ -967,0 +982,1 @@\n+      print_ascii_form(ascii_form, value, unitsize);\n@@ -973,2 +989,2 @@\n-  intptr_t i = 0;\n-  if (read_safely_from((intptr_t*)pa, &i)) {\n+  uintptr_t i = 0;\n+  if (read_safely_from(pa, &i)) {\n@@ -979,1 +995,1 @@\n-    const int offset = (int)(p - (address)pa);\n+    const int offset = (int)(p - (const_address)pa);\n@@ -984,1 +1000,1 @@\n-    intptr_t value = bitfield(i, bitoffset, bitfieldsize);\n+    uintptr_t value = bitfield(i, bitoffset, bitfieldsize);\n@@ -991,0 +1007,1 @@\n+    print_ascii_form(ascii_form, value, unitsize);\n@@ -1001,2 +1018,3 @@\n-void os::print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                        int bytes_per_line, address logical_start) {\n+void os::print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize,\n+                        bool print_ascii, int bytes_per_line, const_address logical_start) {\n+  constexpr int max_bytes_per_line = 64;\n@@ -1004,0 +1022,2 @@\n+  assert(bytes_per_line > 0 && bytes_per_line <= max_bytes_per_line &&\n+         is_power_of_2(bytes_per_line), \"invalid bytes_per_line\");\n@@ -1010,1 +1030,1 @@\n-  int cols_per_line = bytes_per_line \/ unitsize;\n+  const int cols_per_line = bytes_per_line \/ unitsize;\n@@ -1012,2 +1032,4 @@\n-  address p = start;\n-  address logical_p = logical_start;\n+  const_address p = start;\n+  const_address logical_p = logical_start;\n+\n+  stringStream ascii_form;\n@@ -1016,1 +1038,0 @@\n-  st->print(PTR_FORMAT \":   \", p2i(logical_p));\n@@ -1018,1 +1039,4 @@\n-    print_hex_location(st, p, unitsize);\n+    if (cols == 0) {\n+      st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+    }\n+    print_hex_location(st, p, unitsize, ascii_form);\n@@ -1022,2 +1046,5 @@\n-    if (cols >= cols_per_line && p < end) {\n-       cols = 0;\n+    if (cols >= cols_per_line) {\n+       if (print_ascii && !ascii_form.is_empty()) {\n+         st->print(\"   %s\", ascii_form.base());\n+       }\n+       ascii_form.reset();\n@@ -1025,1 +1052,1 @@\n-       st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+       cols = 0;\n@@ -1030,1 +1057,11 @@\n-  st->cr();\n+\n+  if (cols > 0) { \/\/ did not print a full line\n+    if (print_ascii) {\n+      \/\/ indent last ascii part to match that of full lines\n+      const int size_of_printed_unit = unitsize * 2;\n+      const int space_left = (cols_per_line - cols) * (size_of_printed_unit + 1);\n+      st->sp(space_left);\n+      st->print(\"  %s\", ascii_form.base());\n+    }\n+    st->cr();\n+  }\n@@ -1048,1 +1085,1 @@\n-  print_hex_dump(st, pc - 256, pc + 256, unitsize);\n+  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false);\n@@ -1924,2 +1961,1 @@\n-    AIX_ONLY(os::vm_page_size() == 4*K ? 4*K : 256*M)\n-    NOT_AIX(os::vm_allocation_granularity());\n+    AIX_ONLY((!os::Aix::supports_64K_mmap_pages() && os::vm_page_size() == 64*K) ? 256*M : ) os::vm_allocation_granularity();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":64,"deletions":28,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -859,4 +859,4 @@\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                             int bytes_per_line, address logical_start);\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize) {\n-    print_hex_dump(st, start, end, unitsize, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii,\n+                             int bytes_per_line, const_address logical_start);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true) {\n+    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  friend class WhiteBox;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#ifdef UNDEFINED_BEHAVIOR_SANITIZER\n@@ -38,0 +39,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/sanitizers\/ub.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,7 @@\n-    bufferedStream st;\n+    \/\/ jcmd output can get lengthy. As long as we miss jcmd continuous streaming output\n+    \/\/ and instead just send the output in bulk, make sure large command output does not\n+    \/\/ cause asserts. We still retain a max cap, but dimensioned in a way that makes it\n+    \/\/ highly unlikely we should ever hit it under normal conditions.\n+    constexpr size_t initial_size = 1 * M;\n+    constexpr size_t max_size = 3 * G;\n+    bufferedStream st(initial_size, max_size);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1019,1 +1019,1 @@\n-  VM_PrintClasses vmop(output(), _verbose.is_set());\n+  VM_PrintClasses vmop(output(), _verbose.value());\n@@ -1207,5 +1207,1 @@\n-SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) :\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n-}\n+SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -1214,1 +1210,1 @@\n-  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+  MemMapPrinter::print_all_mappings(output());\n@@ -1220,2 +1216,1 @@\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  DCmdWithParser(output, heap),\n@@ -1223,1 +1218,0 @@\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n@@ -1241,1 +1235,1 @@\n-    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+    MemMapPrinter::print_all_mappings(&fs);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1011,2 +1011,1 @@\n-class SystemMapDCmd : public DCmdWithParser {\n-  DCmdArgument<bool> _human_readable;\n+class SystemMapDCmd : public DCmd {\n@@ -1014,1 +1013,0 @@\n-  static int num_arguments() { return 1; }\n@@ -1020,1 +1018,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium; can be high for very large java heaps.\"; }\n@@ -1030,1 +1028,0 @@\n-  DCmdArgument<bool> _human_readable;\n@@ -1033,1 +1030,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 1; }\n@@ -1039,1 +1036,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium; can be high for very large java heaps.\"; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -403,0 +403,2 @@\n+      \/\/ Allow for \"<cmd> -h|-help|--help\" to enable the help diagnostic command.\n+      \/\/ Ignores any additional arguments.\n@@ -404,0 +406,6 @@\n+      stringStream updated_line;\n+      if (reorder_help_cmd(line, updated_line)) {\n+        CmdLine updated_cmd(updated_line.base(), updated_line.size(), false);\n+        line = updated_cmd;\n+      }\n+\n@@ -414,0 +422,19 @@\n+bool DCmd::reorder_help_cmd(CmdLine line, stringStream &updated_line) {\n+  stringStream args;\n+  args.print(\"%s\", line.args_addr());\n+  char* rest = args.as_string();\n+  char* token = strtok_r(rest, \" \", &rest);\n+  while (token != NULL) {\n+    if (strcmp(token, \"-h\") == 0 || strcmp(token, \"--help\") == 0 ||\n+        strcmp(token, \"-help\") == 0) {\n+      updated_line.print(\"%s\", \"help \");\n+      updated_line.write(line.cmd_addr(), line.cmd_len());\n+      updated_line.write(\"\\0\", 1);\n+      return true;\n+    }\n+    token = strtok_r(rest, \" \", &rest);\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,0 +315,3 @@\n+  \/\/ Helper method to substitute help options \"<cmd> -h|-help|--help\"\n+  \/\/ for \"help <cmd>\".\n+  static bool reorder_help_cmd(CmdLine line, stringStream& updated_line);\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-  _invisible_epoch = 0;\n+  _invisible_epoch = nullptr;\n@@ -348,1 +348,1 @@\n-  _invisible_epoch = 0;\n+  _invisible_epoch = nullptr;\n@@ -355,1 +355,1 @@\n-  _invisible_epoch = 0;\n+  _invisible_epoch = nullptr;\n@@ -1019,1 +1019,1 @@\n-      _invisible_epoch(0)\n+      _invisible_epoch(nullptr)\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+typedef const u_char* const_address;\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-void outputStream::fill_to(int col) {\n-  int need_fill = col - position();\n+int outputStream::fill_to(int col) {\n+  const int need_fill = MAX2(col - position(), 0);\n@@ -197,0 +197,1 @@\n+  return need_fill;\n@@ -1040,1 +1041,1 @@\n-      assert(false, \"Exceeded max buffer size for this string.\");\n+      assert(false, \"Exceeded max buffer size for this string (\\\"%.200s...\\\").\", buffer);\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-   void fill_to(int col);\n+   int fill_to(int col);\n@@ -270,0 +270,1 @@\n+  bool is_empty() const { return _buffer[0] == '\\0'; }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+    @Override\n+    public boolean isContainerized() {\n+        return isContainerized0();\n+    }\n+\n@@ -197,0 +202,1 @@\n+    private static native boolean isContainerized0();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\n+    default boolean isContainerized() {\n+        return false; \/\/ This default impl is never used\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isContainerized0(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsContainerized();\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.SecureRandom;\n-import java.security.InvalidParameterException;\n@@ -31,1 +29,2 @@\n-import java.security.InvalidKeyException;\n+import java.security.InvalidParameterException;\n+import java.security.SecureRandom;\n@@ -37,0 +36,1 @@\n+\n@@ -40,1 +40,1 @@\n- * This class generates a AES key.\n+ * This class generates an AES key.\n@@ -108,1 +108,1 @@\n-        SecretKeySpec aesKey = null;\n+        SecretKeySpec aesKey;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,5 @@\n-import java.util.Arrays;\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import javax.crypto.IllegalBlockSizeException;\n+\n@@ -69,1 +69,1 @@\n-    };\n+    }\n@@ -77,1 +77,1 @@\n-    };\n+    }\n@@ -115,1 +115,1 @@\n-    };\n+    }\n@@ -118,1 +118,1 @@\n-    \/\/ no support for multi-part encryption\n+    \/\/ no support for multipart encryption\n@@ -121,2 +121,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n@@ -124,1 +124,1 @@\n-    \/\/ no support for multi-part decryption\n+    \/\/ no support for multipart decryption\n@@ -127,2 +127,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrap.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n@@ -30,4 +32,2 @@\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.IllegalBlockSizeException;\n+\n@@ -52,1 +52,1 @@\n-    \/\/ set the first semiblock of dest with iv and inLen\n+    \/\/ set the first semi-block of dest with iv and inLen\n@@ -63,1 +63,1 @@\n-    \/\/ validate the recovered internal ivAndLen semiblock against iv and\n+    \/\/ validate the recovered internal ivAndLen semi-block against iv and\n@@ -106,1 +106,1 @@\n-    };\n+    }\n@@ -114,1 +114,1 @@\n-    };\n+    }\n@@ -154,1 +154,1 @@\n-    };\n+    }\n@@ -156,1 +156,1 @@\n-    \/\/ no support for multi-part encryption\n+    \/\/ no support for multipart encryption\n@@ -159,2 +159,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n@@ -162,1 +162,1 @@\n-    \/\/ no support for multi-part decryption\n+    \/\/ no support for multipart decryption\n@@ -165,2 +165,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n@@ -202,1 +202,1 @@\n-            \/\/ overwrite the first semiblock with iv and input length\n+            \/\/ overwrite the first semi-block with iv and input length\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-        if (mode.equalsIgnoreCase(\"ECB\") == false) {\n+        if (!mode.equalsIgnoreCase(\"ECB\")) {\n@@ -126,1 +126,1 @@\n-        if (padding.equalsIgnoreCase(\"NoPadding\") == false) {\n+        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n@@ -204,1 +204,1 @@\n-        if (\"RAW\".equals(key.getFormat()) == false) {\n+        if (!\"RAW\".equals(key.getFormat())) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ARCFOURCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,1 @@\n-        if (mode.equalsIgnoreCase(\"None\") == false) {\n+        if (!mode.equalsIgnoreCase(\"None\")) {\n@@ -177,1 +177,1 @@\n-        if (padding.equalsIgnoreCase(\"NoPadding\") == false) {\n+        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n@@ -329,1 +329,1 @@\n-        byte[] newNonce = null;\n+        byte[] newNonce;\n@@ -363,1 +363,1 @@\n-     * format.  This cipher does supports initialization with\n+     * format.  This cipher supports initialization with\n@@ -621,1 +621,1 @@\n-        if (\"RAW\".equals(key.getFormat()) == false) {\n+        if (!\"RAW\".equals(key.getFormat())) {\n@@ -678,1 +678,1 @@\n-        int bytesUpdated = 0;\n+        int bytesUpdated;\n@@ -694,1 +694,1 @@\n-     * @return the length in bytes of the data written into the {@code out}\n+     * @return the length in bytes of the data written into the {@code output}\n@@ -697,1 +697,1 @@\n-     * @throws ShortBufferException if the buffer {@code out} does not have\n+     * @throws ShortBufferException if the buffer {@code output} does not have\n@@ -766,1 +766,1 @@\n-        int bytesUpdated = 0;\n+        int bytesUpdated;\n@@ -788,0 +788,3 @@\n+     * @throws ShortBufferException if the buffer {@code output} does not have\n+     *      enough space to hold the resulting data.\n+     *\n@@ -950,4 +953,0 @@\n-     * @throws IllegalArgumentException if the key or nonce are not in\n-     *      their proper lengths (32 bytes for the key, 12 bytes for the\n-     *      nonce).\n-     * @throws InvalidKeyException if the key does not support an encoded form.\n@@ -955,1 +954,1 @@\n-    private void setInitialState() throws InvalidKeyException {\n+    private void setInitialState() {\n@@ -1260,1 +1259,1 @@\n-     * @throws ShortBufferException if there is insufficient room to\n+     * @throws ProviderException if there is insufficient room to\n@@ -1264,1 +1263,1 @@\n-            byte[] out, int outOff) throws ShortBufferException {\n+            byte[] out, int outOff) {\n@@ -1303,1 +1302,1 @@\n-     * @note it is the caller's responsibility to provide an array large\n+     * @implNote it is the caller's responsibility to provide an array large\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,3 +209,2 @@\n-        StringBuilder sb = new StringBuilder(LINE_SEP + \"nonce:\" +\n-                LINE_SEP + \"[\" + encoder.encodeBuffer(nonce) + \"]\");\n-        return sb.toString();\n+        return LINE_SEP + \"nonce:\" +\n+                LINE_SEP + \"[\" + encoder.encodeBuffer(nonce) + \"]\";\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Poly1305Parameters.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-     * (This check is omitted here, to avoid double checking.)\n+     * (This check is omitted here, to avoid double-checking.)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherBlockChaining.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    private int unitBytes = 0;\n+    private int unitBytes;\n@@ -94,1 +94,1 @@\n-    private int diffBlocksize = 0;\n+    private int diffBlocksize;\n@@ -99,1 +99,1 @@\n-    private Padding padding = null;\n+    private Padding padding;\n@@ -104,1 +104,1 @@\n-    private FeedbackCipher cipher = null;\n+    private FeedbackCipher cipher;\n@@ -139,1 +139,1 @@\n-         * In decryption mode, it also hold the possible padding block.\n+         * In decryption mode, it also holds the possible padding block.\n@@ -337,1 +337,1 @@\n-        AlgorithmParameters params = null;\n+        AlgorithmParameters params;\n@@ -548,1 +548,1 @@\n-        byte[] output = null;\n+        byte[] output;\n@@ -933,2 +933,1 @@\n-        throws ShortBufferException, BadPaddingException,\n-        IllegalBlockSizeException {\n+        throws BadPaddingException, IllegalBlockSizeException {\n@@ -970,1 +969,1 @@\n-        throws IllegalBlockSizeException, ShortBufferException {\n+        throws IllegalBlockSizeException {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import javax.crypto.ShortBufferException;\n@@ -156,1 +155,1 @@\n-     * (This check is omitted here, to avoid double checking.)\n+     * (This check is omitted here, to avoid double-checking.)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherTextStealing.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-        PublicKey key = null;\n+        PublicKey key;\n@@ -91,1 +91,1 @@\n-        PrivateKey key = null;\n+        PrivateKey key;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ConstructKeys.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    private static final int s0p[] = {\n+    private static final int[] s0p = {\n@@ -59,1 +59,1 @@\n-    private static final int s1p[] = {\n+    private static final int[] s1p = {\n@@ -75,1 +75,1 @@\n-    private static final int s2p[] = {\n+    private static final int[] s2p = {\n@@ -91,1 +91,1 @@\n-    private static final int s3p[] = {\n+    private static final int[] s3p = {\n@@ -107,1 +107,1 @@\n-    private static final int s4p[] = {\n+    private static final int[] s4p = {\n@@ -123,1 +123,1 @@\n-    private static final int s5p[] = {\n+    private static final int[] s5p = {\n@@ -139,1 +139,1 @@\n-    private static final int s6p[] = {\n+    private static final int[] s6p = {\n@@ -155,1 +155,1 @@\n-    private static final int s7p[] = {\n+    private static final int[] s7p = {\n@@ -171,1 +171,1 @@\n-    private static final int permRight0[] = {\n+    private static final int[] permRight0 = {\n@@ -178,1 +178,1 @@\n-    private static final int permLeft1[] = {\n+    private static final int[] permLeft1 = {\n@@ -185,1 +185,1 @@\n-    private static final int permRight2[] = {\n+    private static final int[] permRight2 = {\n@@ -192,1 +192,1 @@\n-    private static final int permLeft3[] = {\n+    private static final int[] permLeft3 = {\n@@ -199,1 +199,1 @@\n-    private static final int permRight4[] = {\n+    private static final int[] permRight4 = {\n@@ -206,1 +206,1 @@\n-    private static final int permLeft5[] = {\n+    private static final int[] permLeft5 = {\n@@ -213,1 +213,1 @@\n-    private static final int permRight6[] = {\n+    private static final int[] permRight6 = {\n@@ -220,1 +220,1 @@\n-    private static final int permLeft7[] = {\n+    private static final int[] permLeft7 = {\n@@ -227,1 +227,1 @@\n-    private static final int permRight8[] = {\n+    private static final int[] permRight8 = {\n@@ -234,1 +234,1 @@\n-    private static final int permLeft9[] = {\n+    private static final int[] permLeft9 = {\n@@ -241,1 +241,1 @@\n-    private static final int permRightA[] = {\n+    private static final int[] permRightA = {\n@@ -248,1 +248,1 @@\n-    private static final int permLeftB[] = {\n+    private static final int[] permLeftB = {\n@@ -255,1 +255,1 @@\n-    private static final int permRightC[] = {\n+    private static final int[] permRightC = {\n@@ -262,1 +262,1 @@\n-    private static final int permLeftD[] = {\n+    private static final int[] permLeftD = {\n@@ -269,1 +269,1 @@\n-    private static final int permRightE[] = {\n+    private static final int[] permRightE = {\n@@ -276,1 +276,1 @@\n-    private static final int permLeftF[] = {\n+    private static final int[] permLeftF = {\n@@ -286,1 +286,1 @@\n-    private static final int initPermLeft0[] = {\n+    private static final int[] initPermLeft0 = {\n@@ -293,1 +293,1 @@\n-    private static final int initPermRight0[] = {\n+    private static final int[] initPermRight0 = {\n@@ -300,1 +300,1 @@\n-    private static final int initPermLeft1[] = {\n+    private static final int[] initPermLeft1 = {\n@@ -307,1 +307,1 @@\n-    private static final int initPermRight1[] = {\n+    private static final int[] initPermRight1 = {\n@@ -314,1 +314,1 @@\n-    private static final int initPermLeft2[] = {\n+    private static final int[] initPermLeft2 = {\n@@ -321,1 +321,1 @@\n-    private static final int initPermRight2[] = {\n+    private static final int[] initPermRight2 = {\n@@ -328,1 +328,1 @@\n-    private static final int initPermLeft3[] = {\n+    private static final int[] initPermLeft3 = {\n@@ -335,1 +335,1 @@\n-    private static final int initPermRight3[] = {\n+    private static final int[] initPermRight3 = {\n@@ -342,1 +342,1 @@\n-    private static final int initPermLeft4[] = {\n+    private static final int[] initPermLeft4 = {\n@@ -349,1 +349,1 @@\n-    private static final int initPermRight4[] = {\n+    private static final int[] initPermRight4 = {\n@@ -356,1 +356,1 @@\n-    private static final int initPermLeft5[] = {\n+    private static final int[] initPermLeft5 = {\n@@ -363,1 +363,1 @@\n-    private static final int initPermRight5[] = {\n+    private static final int[] initPermRight5 = {\n@@ -370,1 +370,1 @@\n-    private static final int initPermLeft6[] = {\n+    private static final int[] initPermLeft6 = {\n@@ -377,1 +377,1 @@\n-    private static final int initPermRight6[] = {\n+    private static final int[] initPermRight6 = {\n@@ -384,1 +384,1 @@\n-    private static final int initPermLeft7[] = {\n+    private static final int[] initPermLeft7 = {\n@@ -391,1 +391,1 @@\n-    private static final int initPermRight7[] = {\n+    private static final int[] initPermRight7 = {\n@@ -398,1 +398,1 @@\n-    private static final int initPermLeft8[] = {\n+    private static final int[] initPermLeft8 = {\n@@ -405,1 +405,1 @@\n-    private static final int initPermRight8[] = {\n+    private static final int[] initPermRight8 = {\n@@ -412,1 +412,1 @@\n-    private static final int initPermLeft9[] = {\n+    private static final int[] initPermLeft9 = {\n@@ -419,1 +419,1 @@\n-    private static final int initPermRight9[] = {\n+    private static final int[] initPermRight9 = {\n@@ -426,1 +426,1 @@\n-    private static final int initPermLeftA[] = {\n+    private static final int[] initPermLeftA = {\n@@ -433,1 +433,1 @@\n-    private static final int initPermRightA[] = {\n+    private static final int[] initPermRightA = {\n@@ -440,1 +440,1 @@\n-    private static final int initPermLeftB[] = {\n+    private static final int[] initPermLeftB = {\n@@ -447,1 +447,1 @@\n-    private static final int initPermRightB[] = {\n+    private static final int[] initPermRightB = {\n@@ -454,1 +454,1 @@\n-    private static final int initPermLeftC[] = {\n+    private static final int[] initPermLeftC = {\n@@ -461,1 +461,1 @@\n-    private static final int initPermRightC[] = {\n+    private static final int[] initPermRightC = {\n@@ -468,1 +468,1 @@\n-    private static final int initPermLeftD[] = {\n+    private static final int[] initPermLeftD = {\n@@ -475,1 +475,1 @@\n-    private static final int initPermRightD[] = {\n+    private static final int[] initPermRightD = {\n@@ -482,1 +482,1 @@\n-    private static final int initPermLeftE[] = {\n+    private static final int[] initPermLeftE = {\n@@ -489,1 +489,1 @@\n-    private static final int initPermRightE[] = {\n+    private static final int[] initPermRightE = {\n@@ -496,1 +496,1 @@\n-    private static final int initPermLeftF[] = {\n+    private static final int[] initPermLeftF = {\n@@ -503,1 +503,1 @@\n-    private static final int initPermRightF[] = {\n+    private static final int[] initPermRightF = {\n@@ -589,1 +589,1 @@\n-        byte key[];\n+        byte[] key;\n@@ -641,1 +641,1 @@\n-                             byte out[], int offset) {\n+                             byte[] out, int offset) {\n@@ -690,1 +690,1 @@\n-    private static int initialPermutationLeft(byte block[], int offset) {\n+    private static int initialPermutationLeft(byte[] block, int offset) {\n@@ -712,1 +712,1 @@\n-    private static int initialPermutationRight(byte block[], int offset) {\n+    private static int initialPermutationRight(byte[] block, int offset) {\n@@ -734,1 +734,1 @@\n-    void expandKey(byte key[]) {\n+    void expandKey(byte[] key) {\n@@ -736,1 +736,1 @@\n-        byte ek[] = new byte[128];\n+        byte[] ek = new byte[128];\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESCrypt.java","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-            if ((key instanceof SecretKey)\n+            if ((key != null)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-            if ((key instanceof SecretKey)\n+            if ((key != null)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-        DESedeKey desEdeKey = null;\n+        DESedeKey desEdeKey;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKeyGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-        int result = 0;\n+        int result;\n@@ -146,1 +146,1 @@\n-        return (result < 0? 0:result);\n+        return (Math.max(result, 0));\n@@ -213,1 +213,1 @@\n-        byte[] currIv = null;\n+        byte[] currIv;\n@@ -383,1 +383,1 @@\n-     * parameters or when it has not be set, e.g. initialized with\n+     * parameters or when it has not been set, e.g. initialized with\n@@ -559,1 +559,0 @@\n-            int offset = keyValLen;\n@@ -561,1 +560,1 @@\n-                if (buffer2[offset + i] != cks[i]) {\n+                if (buffer2[keyValLen + i] != cks[i]) {\n@@ -591,1 +590,1 @@\n-        MessageDigest md = null;\n+        MessageDigest md;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeWrapCipher.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,0 @@\n-import sun.security.jca.JCAUtil;\n-import sun.security.ssl.HKDF;\n-import sun.security.util.*;\n-\n-import javax.crypto.*;\n-import javax.crypto.spec.SecretKeySpec;\n@@ -36,1 +30,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -38,1 +31,4 @@\n-import java.security.interfaces.*;\n+import java.security.interfaces.ECKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.interfaces.XECKey;\n+import java.security.interfaces.XECPublicKey;\n@@ -42,0 +38,6 @@\n+import javax.crypto.*;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import sun.security.jca.JCAUtil;\n+import sun.security.ssl.HKDF;\n+import sun.security.util.*;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.util.*;\n-import java.lang.*;\n@@ -31,8 +29,1 @@\n-import java.security.AccessController;\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import java.security.Key;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.SecureRandom;\n-import java.security.PrivilegedAction;\n-import java.security.ProviderException;\n+import java.security.*;\n@@ -40,1 +31,1 @@\n-import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n@@ -42,1 +33,0 @@\n-import javax.crypto.ShortBufferException;\n@@ -44,1 +34,3 @@\n-import javax.crypto.spec.*;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.DHParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -183,1 +175,1 @@\n-     * @param lastPhase flag which indicates whether or not this is the last\n+     * @param lastPhase flag which indicates if this is the last\n@@ -230,1 +222,1 @@\n-        if (lastPhase == false) {\n+        if (!lastPhase) {\n@@ -296,1 +288,1 @@\n-        if (generateSecret == false) {\n+        if (!generateSecret) {\n@@ -416,3 +408,1 @@\n-            SecretKeySpec skey = new SecretKeySpec(secret, 0, keysize,\n-                                                   \"Blowfish\");\n-            return skey;\n+            return new SecretKeySpec(secret, 0, keysize, \"Blowfish\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyAgreement.java","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.security.spec.InvalidParameterSpecException;\n@@ -33,1 +32,0 @@\n-import javax.crypto.spec.DHGenParameterSpec;\n@@ -36,0 +34,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyPairGenerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n-import sun.security.util.ArrayUtil;\n-import java.util.Objects;\n+\n@@ -33,0 +32,1 @@\n+import sun.security.util.ArrayUtil;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ElectronicCodeBook.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-         throws IllegalBlockSizeException, ShortBufferException {\n+         throws IllegalBlockSizeException {\n@@ -202,1 +202,1 @@\n-         throws IllegalBlockSizeException, ShortBufferException {\n+         throws IllegalBlockSizeException {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/FeedbackCipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,1 @@\n-        long blocksLeft = (1L << 32) - ctr32;\n-        return blocksLeft;\n+        return (1L << 32) - ctr32;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,0 @@\n-            int processed = inLen;\n@@ -195,1 +194,1 @@\n-            return processed;\n+            return inLen;\n@@ -276,1 +275,1 @@\n-     * throw exceptions or allocate arrays as it will breaking intrinsics\n+     * throw exceptions or allocate arrays as it will break intrinsics.\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,15 +28,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.Unsafe;\n-import sun.nio.ch.DirectBuffer;\n-import sun.security.jca.JCAUtil;\n-import sun.security.util.ArrayUtil;\n-\n-import javax.crypto.AEADBadTagException;\n-import javax.crypto.BadPaddingException;\n-import javax.crypto.Cipher;\n-import javax.crypto.CipherSpi;\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.NoSuchPaddingException;\n-import javax.crypto.ShortBufferException;\n-import javax.crypto.spec.GCMParameterSpec;\n@@ -47,8 +32,1 @@\n-import java.security.AlgorithmParameters;\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import java.security.Key;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.ProviderException;\n-import java.security.SecureRandom;\n+import java.security.*;\n@@ -58,0 +36,2 @@\n+import javax.crypto.*;\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -59,0 +39,3 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n@@ -60,0 +43,3 @@\n+import sun.nio.ch.DirectBuffer;\n+import sun.security.jca.JCAUtil;\n+import sun.security.util.ArrayUtil;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":10,"deletions":24,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.util.Arrays;\n-\n@@ -31,1 +29,3 @@\n-\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n@@ -34,4 +34,0 @@\n-import java.security.*;\n-import java.security.spec.*;\n-\n-import sun.security.x509.AlgorithmId;\n@@ -90,2 +86,1 @@\n-                    } catch (NoSuchAlgorithmException nsae) {\n-                        continue;\n+                    } catch (NoSuchAlgorithmException ignored) {\n@@ -172,1 +167,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -190,2 +185,2 @@\n-    protected void engineUpdate(byte input[], int offset, int len) {\n-        if (first == true) {\n+    protected void engineUpdate(byte[] input, int offset, int len) {\n+        if (first) {\n@@ -208,1 +203,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -224,1 +219,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -253,1 +248,1 @@\n-        if (first == false) {\n+        if (!first) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacCore.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,1 @@\n-import java.nio.ByteBuffer;\n-\n-import javax.crypto.MacSpi;\n-import javax.crypto.SecretKey;\n-import java.security.*;\n-import java.security.spec.*;\n+import java.security.NoSuchAlgorithmException;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacMD5.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.SecureRandom;\n-import java.security.InvalidParameterException;\n@@ -31,0 +29,1 @@\n+import java.security.SecureRandom;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacMD5KeyGenerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,1 @@\n-import java.nio.ByteBuffer;\n-\n-import javax.crypto.MacSpi;\n-import javax.crypto.SecretKey;\n-import java.security.*;\n-import java.security.spec.*;\n+import java.security.NoSuchAlgorithmException;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacSHA1.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.SecureRandom;\n-import java.security.InvalidParameterException;\n@@ -31,0 +29,1 @@\n+import java.security.SecureRandom;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacSHA1KeyGenerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,2 +122,1 @@\n-        int paddingOctet = blockSize - (len % blockSize);\n-        return paddingOctet;\n+        return blockSize - (len % blockSize);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ISO10126Padding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    };\n+    }\n@@ -96,1 +96,1 @@\n-    };\n+    }\n@@ -122,1 +122,1 @@\n-        Key key = null;\n+        Key key;\n@@ -655,1 +655,1 @@\n-                byte digest[] = md.digest();\n+                byte[] digest = md.digest();\n@@ -694,2 +694,2 @@\n-            ByteArrayInputStream bais = null;\n-            byte[] encoded = null;\n+            ByteArrayInputStream bais;\n+            byte[] encoded;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/JceKeyStore.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n@@ -61,1 +57,1 @@\n-        \/\/ overwrite the first block of in with the icv semiblock\n+        \/\/ overwrite the first block of in with the icv semi-block\n@@ -96,1 +92,1 @@\n-     * @param ivOut buffer for holding the recovered ICV semiblock\n+     * @param ivOut buffer for holding the recovered ICV semi-block\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWUtil.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-            } catch (NumberFormatException e) {}\n+            } catch (NumberFormatException ignored) {}\n@@ -372,1 +372,1 @@\n-            SealedObjectForKeyProtector soForKeyProtector = null;\n+            SealedObjectForKeyProtector soForKeyProtector;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,1 +288,1 @@\n-            \/\/ then add the first semiblock and padLen to result\n+            \/\/ then add the first semi-block and padLen to result\n@@ -342,1 +342,1 @@\n-            implInit(opmode, key, (byte[])null, random);\n+            implInit(opmode, key, null, random);\n@@ -397,1 +397,1 @@\n-                AlgorithmParameterSpec spec =\n+                IvParameterSpec spec =\n@@ -399,1 +399,1 @@\n-                iv = ((IvParameterSpec)spec).getIV();\n+                iv = spec.getIV();\n@@ -465,1 +465,1 @@\n-            \/\/ the first semiblock is for iv, store data after it\n+            \/\/ the first semi-block is for iv, store data after it\n@@ -598,2 +598,2 @@\n-    \/\/ 'inBuf' = semiblock | plain text | extra bytes if padding is used\n-    \/\/ 'inLen' = semiblock length + plain text length\n+    \/\/ 'inBuf' = semi-block | plain text | extra bytes if padding is used\n+    \/\/ 'inLen' = semi-block length + plain text length\n@@ -649,1 +649,1 @@\n-        AlgorithmParameters params = null;\n+        AlgorithmParameters params;\n@@ -714,1 +714,1 @@\n-        \/\/ reserve the first semiblock and do not write data\n+        \/\/ reserve the first semi-block and do not write data\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -228,6 +228,4 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"MD: \" + mdName + \"\\n\");\n-        sb.append(\"MGF: MGF1\" + mgfSpec.getDigestAlgorithm() + \"\\n\");\n-        sb.append(\"PSource: PSpecified \" +\n-            (p.length==0? \"\":Debug.toHexString(new BigInteger(p))) + \"\\n\");\n-        return sb.toString();\n+        return \"MD: \" + mdName + \"\\n\" +\n+                \"MGF: MGF1\" + mgfSpec.getDigestAlgorithm() + \"\\n\" +\n+                \"PSource: PSpecified \" +\n+                (p.length == 0 ? \"\" : Debug.toHexString(new BigInteger(p))) + \"\\n\";\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-     * number of bytes for each stream unit, defaults to the blocksize\n+     * number of bytes for each stream unit, defaults to the block size\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OutputFeedback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,1 @@\n-        if ((key instanceof SecretKey)\n+        if ((key != null)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,1 @@\n-        AlgorithmParameters params = null;\n+        AlgorithmParameters params;\n@@ -306,1 +306,1 @@\n-            byte[] toBeHashed = null;\n+            byte[] toBeHashed;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES1Core.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,2 @@\n-        String kdfAlgo = null;\n-        String cipherAlgo = null;\n+        String kdfAlgo;\n+        String cipherAlgo;\n@@ -213,3 +213,0 @@\n-        String kdfAlgo = null;\n-        String cipherAlgo = null;\n-\n@@ -234,1 +231,1 @@\n-        kdfAlgo = parseKDF(kdf);\n+        String kdfAlgo = parseKDF(kdf);\n@@ -240,1 +237,1 @@\n-        cipherAlgo = parseES(pBES2_params.data.getDerValue());\n+        String cipherAlgo = parseES(pBES2_params.data.getDerValue());\n@@ -242,2 +239,1 @@\n-        this.pbes2AlgorithmName = new StringBuilder().append(\"PBEWith\")\n-            .append(kdfAlgo).append(\"And\").append(cipherAlgo).toString();\n+        this.pbes2AlgorithmName = \"PBEWith\" + kdfAlgo + \"And\" + cipherAlgo;\n@@ -308,1 +304,1 @@\n-        String cipherAlgo = null;\n+        String cipherAlgo;\n@@ -402,1 +398,1 @@\n-     * The algorithn name pattern is: \"PBEWith<prf>And<encryption>\"\n+     * The algorithm name pattern is: \"PBEWith<prf>And<encryption>\"\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import java.io.*;\n-import java.lang.ref.Reference;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamException;\n@@ -31,0 +33,1 @@\n+import java.lang.ref.Reference;\n@@ -33,4 +36,0 @@\n-import java.util.Arrays;\n-import java.util.Locale;\n-import java.security.MessageDigest;\n-import java.security.KeyRep;\n@@ -38,0 +37,2 @@\n+import java.security.KeyRep;\n+import java.security.MessageDigest;\n@@ -40,0 +41,2 @@\n+import java.util.Arrays;\n+import java.util.Locale;\n@@ -44,2 +47,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -48,0 +49,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        PBKDF2Core kdf = null;\n+        PBKDF2Core kdf;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBMAC1Core.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,2 +123,1 @@\n-        int paddingOctet = blockSize - (len % blockSize);\n-        return paddingOctet;\n+        return blockSize - (len % blockSize);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS5Padding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.security.Key;\n@@ -31,0 +30,1 @@\n+import java.security.Key;\n@@ -35,3 +35,0 @@\n-import sun.security.util.math.*;\n-import sun.security.util.math.intpoly.*;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -39,0 +36,5 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import sun.security.util.math.IntegerFieldModuloP;\n+import sun.security.util.math.IntegerModuloP;\n+import sun.security.util.math.MutableIntegerModuloP;\n+import sun.security.util.math.intpoly.IntegerPolynomial1305;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-        if (algorithm.equals(\"RC2\") == false) {\n+        if (!algorithm.equals(\"RC2\")) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RC2Crypt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -129,1 +130,1 @@\n-        if (mode.equalsIgnoreCase(\"ECB\") == false) {\n+        if (!mode.equalsIgnoreCase(\"ECB\")) {\n@@ -471,1 +472,1 @@\n-        byte[] encoded = null;\n+        byte[] encoded;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-\n-import javax.crypto.MacSpi;\n-import javax.crypto.SecretKey;\n@@ -34,0 +31,2 @@\n+import javax.crypto.MacSpi;\n+import javax.crypto.SecretKey;\n@@ -112,1 +111,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -131,2 +130,2 @@\n-    void update(byte input[], int offset, int len) {\n-        if (first == true) {\n+    void update(byte[] input, int offset, int len) {\n+        if (first) {\n@@ -144,1 +143,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -161,1 +160,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -192,1 +191,1 @@\n-        if (first == false) {\n+        if (!first) {\n@@ -214,1 +213,1 @@\n-        protected void engineUpdate(byte input[], int offset, int len) {\n+        protected void engineUpdate(byte[] input, int offset, int len) {\n@@ -247,1 +246,1 @@\n-        protected void engineUpdate(byte input[], int offset, int len) {\n+        protected void engineUpdate(byte[] input, int offset, int len) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SslMacCore.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        if (params instanceof TlsKeyMaterialParameterSpec == false) {\n+        if (!(params instanceof TlsKeyMaterialParameterSpec)) {\n@@ -69,1 +69,1 @@\n-        if (\"RAW\".equals(spec.getMasterSecret().getFormat()) == false) {\n+        if (!\"RAW\".equals(spec.getMasterSecret().getFormat())) {\n@@ -108,2 +108,0 @@\n-        SecretKey clientCipherKey = null;\n-        SecretKey serverCipherKey = null;\n@@ -197,0 +195,2 @@\n+        SecretKey clientCipherKey;\n+        SecretKey serverCipherKey;\n@@ -198,1 +198,1 @@\n-            if (isExportable == false) {\n+            if (!isExportable) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsKeyMaterialGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-        if (params instanceof TlsPrfParameterSpec == false) {\n+        if (!(params instanceof TlsPrfParameterSpec)) {\n@@ -140,1 +140,1 @@\n-        if ((key != null) && (\"RAW\".equals(key.getFormat()) == false)) {\n+        if ((key != null) && (!\"RAW\".equals(key.getFormat()))) {\n@@ -381,1 +381,1 @@\n-     * we could use.  Therefore for TLS 1.2, we are updating JSSE to request\n+     * we could use.  Therefore, for TLS 1.2, we are updating JSSE to request\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsPrfGenerator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -374,0 +374,3 @@\n+    \/**\n+     * @since 11\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n@@ -60,1 +58,0 @@\n-import java.lang.classfile.attribute.ModuleAttribute;\n@@ -63,1 +60,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -1591,1 +1587,1 @@\n-        byte[] bytes = cc.transform(cc.parse(in.readAllBytes()), (clb, cle) -> {\n+        byte[] bytes = cc.transformClass(cc.parse(in.readAllBytes()), (clb, cle) -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -244,0 +244,4 @@\n+     *\n+     * Satisfying this method's contract implies a non-{@code null}\n+     * result must be returned.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.classfile.attribute.UnknownAttribute;\n@@ -438,1 +437,1 @@\n-     *                     b -> b.transform(model, transform));\n+     *                     clb -> clb.transform(model, transform));\n@@ -445,2 +444,2 @@\n-    default byte[] transform(ClassModel model, ClassTransform transform) {\n-        return transform(model, model.thisClass(), transform);\n+    default byte[] transformClass(ClassModel model, ClassTransform transform) {\n+        return transformClass(model, model.thisClass(), transform);\n@@ -461,2 +460,2 @@\n-    default byte[] transform(ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n-        return transform(model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n+    default byte[] transformClass(ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n+        return transformClass(model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n@@ -476,1 +475,1 @@\n-     *                     b -> b.transform(model, transform));\n+     *                     clb -> clb.transform(model, transform));\n@@ -484,1 +483,1 @@\n-    byte[] transform(ClassModel model, ClassEntry newClassName, ClassTransform transform);\n+    byte[] transformClass(ClassModel model, ClassEntry newClassName, ClassTransform transform);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * {@link ClassFile#transform(ClassModel, ClassTransform)}, and the elements of the class,\n+ * {@link ClassFile#transformClass(ClassModel, ClassTransform)}, and the elements of the class,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileTransform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,4 +30,0 @@\n-import java.lang.classfile.constantpool.MethodHandleEntry;\n-import java.lang.classfile.constantpool.ModuleEntry;\n-import java.lang.classfile.constantpool.NameAndTypeEntry;\n-import java.lang.classfile.constantpool.PackageEntry;\n@@ -133,71 +129,0 @@\n-    \/**\n-     * {@return the UTF8 entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a UTF8 entry\n-     *\/\n-    Utf8Entry readUtf8Entry(int offset);\n-\n-    \/**\n-     * {@return the UTF8 entry whose index is given at the specified\n-     * offset within the classfile, or null if the index at the specified\n-     * offset is zero}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or the index does not correspond to\n-     *         a UTF8 entry\n-     *\/\n-    Utf8Entry readUtf8EntryOrNull(int offset);\n-\n-    \/**\n-     * {@return the module entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a module entry\n-     *\/\n-    ModuleEntry readModuleEntry(int offset);\n-\n-    \/**\n-     * {@return the package entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a package entry\n-     *\/\n-    PackageEntry readPackageEntry(int offset);\n-\n-    \/**\n-     * {@return the class entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a class entry\n-     *\/\n-    ClassEntry readClassEntry(int offset);\n-\n-    \/**\n-     * {@return the name-and-type entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a name-and-type entry\n-     *\/\n-    NameAndTypeEntry readNameAndTypeEntry(int offset);\n-\n-    \/**\n-     * {@return the method handle entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a method handle entry\n-     *\/\n-    MethodHandleEntry readMethodHandleEntry(int offset);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassReader.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -44,1 +44,5 @@\n-    \/** {@return the instantiation of the superclass in this signature} *\/\n+    \/**\n+     * {@return the instantiation of the superclass in this signature}\n+     *\n+     * @since 23\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-import jdk.internal.classfile.impl.TransformingCodeBuilder;\n+\n@@ -100,0 +100,21 @@\n+ * <h2>Instruction Factories<\/h2>\n+ * {@code CodeBuilder} provides convenience methods to create instructions (See\n+ * JVMS {@jvms 6.5} Instructions) by their mnemonic, taking necessary operands.\n+ * <ul>\n+ * <li>Instructions that encode their operands in their opcode, such as {@code\n+ * aload_<n>}, share their factories with their generic version like {@link\n+ * #aload aload}. Note that some constant instructions, such as {@link #iconst_1\n+ * iconst_1}, do not have generic versions, and thus have their own factories.\n+ * <li>Instructions that accept wide operands, such as {@code ldc2_w} or {@code\n+ * wide}, share their factories with their regular version like {@link #ldc}. Note\n+ * that {@link #goto_w goto_w} has its own factory to avoid {@linkplain\n+ * ClassFile.ShortJumpsOption short jumps}.\n+ * <li>The {@code goto}, {@code instanceof}, {@code new}, and {@code return}\n+ * instructions' factories are named {@link #goto_ goto_}, {@link #instanceOf\n+ * instanceOf}, {@link #new_ new_}, and {@link #return_() return_} respectively,\n+ * due to clashes with keywords in the Java programming language.\n+ * <li>Factories are not provided for instructions {@code jsr}, {@code jsr_w},\n+ * {@code ret}, and {@code wide ret}, which cannot appear in class files with\n+ * major version {@value ClassFile#JAVA_7_VERSION} or higher. (JVMS {@jvms 4.9.1})\n+ * <\/ul>\n+ *\n@@ -133,1 +154,1 @@\n-     * @throws IllegalStateException if this is not a static method\n+     * @throws IllegalStateException if this is a static method\n@@ -174,1 +195,1 @@\n-        handler.accept(new TransformingCodeBuilder(this, resolved.consumer()));\n+        handler.accept(new ChainedCodeBuilder(this, resolved.consumer()));\n@@ -702,1 +723,1 @@\n-        return with(ExceptionCatch.of(handler, start, end, Optional.of(catchType)));\n+        return with(ExceptionCatch.of(handler, start, end, Optional.ofNullable(catchType)));\n@@ -840,0 +861,4 @@\n+     *\n+     * <p>This may also generate {@code aload_<N>} and\n+     * {@code wide aload} instructions.\n+     *\n@@ -884,0 +909,4 @@\n+     *\n+     * <p>This may also generate {@code astore_<N>} and\n+     * {@code wide astore} instructions.\n+     *\n@@ -1049,0 +1078,4 @@\n+     *\n+     * <p>This may also generate {@code dload_<N>} and\n+     * {@code wide dload} instructions.\n+     *\n@@ -1090,0 +1123,4 @@\n+     *\n+     * <p>This may also generate {@code dstore_<N>} and\n+     * {@code wide dstore} instructions.\n+     *\n@@ -1253,0 +1290,4 @@\n+     *\n+     * <p>This may also generate {@code fload_<N>} and\n+     * {@code wide fload} instructions.\n+     *\n@@ -1294,0 +1335,4 @@\n+     *\n+     * <p>This may also generate {@code fstore_<N>} and\n+     * {@code wide fstore} instructions.\n+     *\n@@ -1353,0 +1398,9 @@\n+     *\n+     * <p>This may also generate {@code goto_w} instructions if the {@link\n+     * ClassFile.ShortJumpsOption#FIX_SHORT_JUMPS FIX_SHORT_JUMPS} option\n+     * is set.\n+     *\n+     * @apiNote The instruction's name is {@code goto}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n@@ -1590,1 +1644,1 @@\n-    default CodeBuilder if_nonnull(Label target) {\n+    default CodeBuilder ifnonnull(Label target) {\n@@ -1599,1 +1653,1 @@\n-    default CodeBuilder if_null(Label target) {\n+    default CodeBuilder ifnull(Label target) {\n@@ -1669,0 +1723,4 @@\n+     *\n+     * <p>This may also generate {@code iload_<N>} and\n+     * {@code wide iload} instructions.\n+     *\n@@ -1694,0 +1752,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code instanceof}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with camel case instead.\n+     *\n@@ -1704,0 +1767,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code instanceof}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with camel case instead.\n+     *\n@@ -1913,0 +1981,4 @@\n+     *\n+     * <p>This may also generate {@code istore_<N>} and\n+     * {@code wide istore} instructions.\n+     *\n@@ -2036,0 +2108,6 @@\n+     *\n+     * <p>This may also generate {@code ldc_w} and {@code ldc2_w} instructions.\n+     *\n+     * @apiNote {@link #loadConstant(ConstantDesc) loadConstant} generates more optimal instructions\n+     * and should be used for general constants if an {@code ldc} instruction is not strictly required.\n+     *\n@@ -2045,0 +2123,3 @@\n+     *\n+     * <p>This may also generate {@code ldc_w} and {@code ldc2_w} instructions.\n+     *\n@@ -2065,0 +2146,4 @@\n+     *\n+     * <p>This may also generate {@code lload_<N>} and\n+     * {@code wide lload} instructions.\n+     *\n@@ -2130,0 +2215,4 @@\n+     *\n+     * <p>This may also generate {@code lstore_<N>} and\n+     * {@code wide lstore} instructions.\n+     *\n@@ -2200,0 +2289,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code new}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n@@ -2209,0 +2303,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code new}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n@@ -2286,0 +2385,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code return}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":111,"deletions":7,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,1 @@\n-     * {@return the position of the {@code Label} in the {@code codeArray}\n-     * or -1 if the {@code Label} does not point to the {@code codeArray}}\n+     * {@return the position of the {@code label} in the {@link #codeArray codeArray}}\n@@ -64,0 +63,1 @@\n+     * @throws IllegalArgumentException if the {@code label} is not from this attribute\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CodeAttribute.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-        return  mb.build();\n+        return mb.build();\n@@ -169,1 +169,1 @@\n-        return  mb.build();\n+        return mb.build();\n@@ -322,6 +322,0 @@\n-\n-        \/**\n-         * Builds module attribute.\n-         * @return the module attribute\n-         *\/\n-        ModuleAttribute build();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-        return context.transform(clm, map(clm.thisClass().asSymbol()), this);\n+        return context.transformClass(clm, map(clm.thisClass().asSymbol()), this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassRemapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,8 +77,0 @@\n-\n-    \/**\n-     * Access method to internal re-labeling function.\n-     * @param label source label\n-     * @param codeBuilder builder to create new labels\n-     * @return target label\n-     *\/\n-    Label relabel(Label label, CodeBuilder codeBuilder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeRelabeler.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-        byte[] newBytes = ClassFile.of().transform(\n+        byte[] newBytes = ClassFile.of().transformClass(\n@@ -148,1 +148,1 @@\n-        byte[] newBytes = ClassFile.of().transform(\n+        byte[] newBytes = ClassFile.of().transformClass(\n@@ -163,1 +163,1 @@\n-        return ClassFile.of().transform(target,\n+        return ClassFile.of().transformClass(target,\n@@ -194,1 +194,1 @@\n-                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                    .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,8 +95,0 @@\n-    \/**\n-     * Writes associated bootstrap method entries to the specified writer\n-     *\n-     * @param buf the writer\n-     * @return false when no bootstrap method entry has been written\n-     *\/\n-    boolean writeBootstrapMethods(BufWriter buf);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-        byte[] newBytes = cc.transform(cc.parse(bytes), ct);\n+        byte[] newBytes = cc.transformClass(cc.parse(bytes), ct);\n@@ -349,1 +349,1 @@\n-        byte[] newBytes = ClassFile.of().transform(classModel,\n+        byte[] newBytes = ClassFile.of().transformClass(classModel,\n@@ -363,1 +363,1 @@\n-        return ClassFile.of().transform(target,\n+        return ClassFile.of().transformClass(target,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -377,0 +377,3 @@\n+    \/**\n+     * @since 21\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,0 +210,3 @@\n+    \/**\n+     * @since 21\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -225,0 +225,2 @@\n+     *\n+     * @since 21\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -621,0 +621,2 @@\n+     *\n+     * @since 23\n@@ -634,0 +636,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -653,0 +658,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -680,0 +688,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -706,0 +717,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -722,0 +736,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -760,0 +777,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -808,0 +828,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -72,8 +72,8 @@\n-        if (type == int.class)     return TypeKind.IntType;\n-        if (type == long.class)    return TypeKind.LongType;\n-        if (type == boolean.class) return TypeKind.BooleanType;\n-        if (type == short.class)   return TypeKind.ShortType;\n-        if (type == byte.class)    return TypeKind.ByteType;\n-        if (type == char.class)    return TypeKind.CharType;\n-        if (type == float.class)   return TypeKind.FloatType;\n-        if (type == double.class)  return TypeKind.DoubleType;\n+        if (type == Integer.class)   return TypeKind.IntType;\n+        if (type == Long.class)      return TypeKind.LongType;\n+        if (type == Boolean.class)   return TypeKind.BooleanType;\n+        if (type == Short.class)     return TypeKind.ShortType;\n+        if (type == Byte.class)      return TypeKind.ByteType;\n+        if (type == Character.class) return TypeKind.CharType;\n+        if (type == Float.class)     return TypeKind.FloatType;\n+        if (type == Double.class)    return TypeKind.DoubleType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -529,2 +529,0 @@\n-     *\n-     * @since 11\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-        private Object[] resolvedEnum;\n+        private final Object[] resolvedEnum;\n@@ -425,1 +425,1 @@\n-            cb.if_nonnull(nonNullLabel);\n+            cb.ifnonnull(nonNullLabel);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -589,0 +589,3 @@\n+    \/**\n+     * @since 23\n+     *\/\n@@ -595,0 +598,3 @@\n+    \/**\n+     * @since 23\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4252,2 +4252,2 @@\n-            for (int i = 0; i < nzeros; i++) {\n-                sb.append('0');\n+            if (nzeros > 0) {\n+                sb.repeat('0', nzeros);\n@@ -4970,3 +4970,3 @@\n-                     LINE_SEPARATOR,\n-                     PERCENT_SIGN -> true;\n-                default -> false;\n+                     LINE_SEPARATOR -> true;\n+                \/\/ Don't put PERCENT_SIGN inside switch, as that will make the method size exceed 325 and cannot be inlined.\n+                default -> c == PERCENT_SIGN;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2181,0 +2181,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -2196,0 +2199,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -2443,0 +2449,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2448,0 +2457,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2453,0 +2465,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2458,0 +2473,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2463,0 +2481,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2588,0 +2609,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -330,0 +330,2 @@\n+     *\n+     * @since 21\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayQueue.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -890,0 +890,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -899,0 +902,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -913,0 +919,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -208,0 +208,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -224,0 +227,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -239,0 +245,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/FutureTask.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    int extraAttributes = -1; \/\/ e.g. POSIX permissions, sym links.\n+    int externalFileAttributes = -1; \/\/ File type, setuid, setgid, sticky, POSIX permissions\n@@ -137,1 +137,1 @@\n-        extraAttributes = e.extraAttributes;\n+        externalFileAttributes = e.externalFileAttributes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -700,1 +700,1 @@\n-            e.extraAttributes = CENATX_PERMS(cen, pos) & 0xFFFF;\n+            e.externalFileAttributes = CENATX_PERMS(cen, pos) & 0xFFFF;\n@@ -1168,2 +1168,2 @@\n-                public int getExtraAttributes(ZipEntry ze) {\n-                    return ze.extraAttributes;\n+                public int getExternalFileAttributes(ZipEntry ze) {\n+                    return ze.externalFileAttributes;\n@@ -1172,2 +1172,2 @@\n-                public void setExtraAttributes(ZipEntry ze, int extraAttrs) {\n-                    ze.extraAttributes = extraAttrs;\n+                public void setExternalFileAttributes(ZipEntry ze, int externalFileAttributes) {\n+                    ze.externalFileAttributes = externalFileAttributes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-        return (e.extraAttributes < 0) ? version :\n+        return (e.externalFileAttributes < 0) ? version :\n@@ -640,1 +640,1 @@\n-        writeInt(e.extraAttributes > 0 ? e.extraAttributes << 16 : 0);\n+        writeInt(e.externalFileAttributes > 0 ? e.externalFileAttributes << 16 : 0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,2 @@\n-    public void setExtraAttributes(ZipEntry ze, int extraAttrs);\n-    public int getExtraAttributes(ZipEntry ze);\n+    public void setExternalFileAttributes(ZipEntry ze, int externalFileAttributes);\n+    public int getExternalFileAttributes(ZipEntry ze);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilZipFileAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-                classEntry = code.classReader.readClassEntry(pos + 1);\n+                classEntry = code.classReader.readEntry(pos + 1, ClassEntry.class);\n@@ -579,1 +579,1 @@\n-            return code.classReader.readClassEntry(pos + 1);\n+            return code.classReader.readEntry(pos + 1, ClassEntry.class);\n@@ -610,1 +610,1 @@\n-            return code.classReader.readClassEntry(pos + 1);\n+            return code.classReader.readEntry(pos + 1, ClassEntry.class);\n@@ -639,1 +639,1 @@\n-                typeEntry = code.classReader.readClassEntry(pos + 1);\n+                typeEntry = code.classReader.readEntry(pos + 1, ClassEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,3 +69,4 @@\n-            case AEV_STRING -> new AnnotationImpl.OfStringImpl(classReader.readUtf8Entry(p));\n-            case AEV_ENUM -> new AnnotationImpl.OfEnumImpl(classReader.readUtf8Entry(p), classReader.readUtf8Entry(p + 2));\n-            case AEV_CLASS -> new AnnotationImpl.OfClassImpl(classReader.readUtf8Entry(p));\n+            case AEV_STRING -> new AnnotationImpl.OfStringImpl(classReader.readEntry(p, Utf8Entry.class));\n+            case AEV_ENUM -> new AnnotationImpl.OfEnumImpl(classReader.readEntry(p, Utf8Entry.class),\n+                    classReader.readEntry(p + 2, Utf8Entry.class));\n+            case AEV_CLASS -> new AnnotationImpl.OfClassImpl(classReader.readEntry(p, Utf8Entry.class));\n@@ -130,1 +131,1 @@\n-        Utf8Entry annotationClass = classReader.entryByIndex(classReader.readU2(p), Utf8Entry.class);\n+        Utf8Entry annotationClass = classReader.readEntry(p, Utf8Entry.class);\n@@ -153,1 +154,1 @@\n-            Utf8Entry elementName = classReader.readUtf8Entry(p);\n+            Utf8Entry elementName = classReader.readEntry(p, Utf8Entry.class);\n@@ -242,1 +243,1 @@\n-        Utf8Entry type = classReader.readUtf8Entry(p);\n+        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-        terminalMaxLocals = topLocal(terminal);\n-        terminal.with((LabelTarget) startLabel);\n+        terminalMaxLocals = terminal.curTopLocal();\n+        parent.with((LabelTarget) startLabel);\n@@ -59,2 +59,2 @@\n-        terminal.with((LabelTarget) endLabel);\n-        if (terminalMaxLocals != topLocal(terminal)) {\n+        parent.with((LabelTarget) endLabel);\n+        if (terminalMaxLocals != terminal.curTopLocal()) {\n@@ -76,4 +76,2 @@\n-            case ChainedCodeBuilder b -> topLocal(b.terminal);\n-            case DirectCodeBuilder b -> b.curTopLocal();\n-            case BufferedCodeBuilder b -> b.curTopLocal();\n-            case TransformingCodeBuilder b -> topLocal(b.delegate);\n+            case ChainedCodeBuilder b -> b.terminal.curTopLocal();\n+            case TerminalCodeBuilder b -> b.curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            Utf8Entry name = reader.readUtf8Entry(p);\n+            Utf8Entry name = reader.readEntry(p, Utf8Entry.class);\n@@ -350,1 +350,1 @@\n-                    Utf8Entry name = classReader.readUtf8EntryOrNull(p);\n+                    Utf8Entry name = classReader.readEntryOrNull(p, Utf8Entry.class);\n@@ -370,1 +370,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -381,1 +381,1 @@\n-                    ModuleEntry module = classReader.readModuleEntry(p);\n+                    ModuleEntry module = classReader.readEntry(p, ModuleEntry.class);\n@@ -433,1 +433,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -445,1 +445,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -457,1 +457,1 @@\n-            return classReader.readClassEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ClassEntry.class);\n@@ -469,1 +469,1 @@\n-            return classReader.readClassEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ClassEntry.class);\n@@ -501,1 +501,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -513,1 +513,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -525,1 +525,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -572,1 +572,1 @@\n-            return classReader.readModuleEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ModuleEntry.class);\n@@ -582,1 +582,1 @@\n-            return Optional.ofNullable(classReader.readUtf8EntryOrNull(payloadStart + 4));\n+            return Optional.ofNullable(classReader.readEntryOrNull(payloadStart + 4, Utf8Entry.class));\n@@ -633,1 +633,1 @@\n-                    elements[i] = ModuleRequireInfo.of(classReader.readModuleEntry(p),\n+                    elements[i] = ModuleRequireInfo.of(classReader.readEntry(p, ModuleEntry.class),\n@@ -645,1 +645,1 @@\n-                    PackageEntry pe = classReader.readPackageEntry(p);\n+                    PackageEntry pe = classReader.readEntry(p, PackageEntry.class);\n@@ -660,1 +660,1 @@\n-                    PackageEntry po = classReader.readPackageEntry(p);\n+                    PackageEntry po = classReader.readEntry(p, PackageEntry.class);\n@@ -678,1 +678,1 @@\n-                    ClassEntry c = classReader.readClassEntry(p);\n+                    ClassEntry c = classReader.readEntry(p, ClassEntry.class);\n@@ -746,2 +746,1 @@\n-                    final AbstractPoolEntry.MethodHandleEntryImpl handle\n-                            = (AbstractPoolEntry.MethodHandleEntryImpl) classReader.readMethodHandleEntry(p);\n+                    final var handle = classReader.readEntry(p, AbstractPoolEntry.MethodHandleEntryImpl.class);\n@@ -774,1 +773,1 @@\n-                    ClassEntry innerClass = classReader.readClassEntry(p);\n+                    ClassEntry innerClass = classReader.readEntry(p, ClassEntry.class);\n@@ -795,1 +794,1 @@\n-            return classReader.readClassEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ClassEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        return reader.readUtf8Entry(startPos);\n+        return reader.readEntry(startPos, Utf8Entry.class);\n@@ -54,1 +54,1 @@\n-        return reader.readUtf8Entry(startPos + 2);\n+        return reader.readEntry(startPos + 2, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundRecordComponentInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    private final ClassBuilder downstream;\n@@ -42,1 +41,0 @@\n-        this.downstream = downstream;\n@@ -63,1 +61,1 @@\n-        return downstream.with(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n@@ -67,0 +65,1 @@\n+        return this;\n@@ -75,1 +74,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n@@ -81,1 +81,1 @@\n-        return downstream.with(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n@@ -85,0 +85,1 @@\n+        return this;\n@@ -92,1 +93,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-    final MethodBuilder downstream;\n@@ -45,1 +44,0 @@\n-        this.downstream = downstream;\n@@ -61,1 +59,1 @@\n-        return downstream.with(terminal.bufferedCodeBuilder(null)\n+        consumer.accept(terminal.bufferedCodeBuilder(null)\n@@ -64,0 +62,1 @@\n+        return this;\n@@ -70,1 +69,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    public byte[] transform(ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n+    public byte[] transformClass(ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-                arr[i] = reader.readClassEntry(pos);\n+                arr[i] = reader.readEntry(pos, ClassEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-            thisClass = readClassEntry(thisClassPos);\n+            thisClass = readEntry(thisClassPos, ClassEntry.class);\n@@ -398,10 +398,10 @@\n-                case TAG_CLASS -> new AbstractPoolEntry.ClassEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_STRING -> new AbstractPoolEntry.StringEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_FIELDREF -> new AbstractPoolEntry.FieldRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n-                                                                             (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_METHODREF -> new AbstractPoolEntry.MethodRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n-                                                                               (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_INTERFACEMETHODREF -> new AbstractPoolEntry.InterfaceMethodRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n-                                                                                                 (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_NAMEANDTYPE -> new AbstractPoolEntry.NameAndTypeEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q),\n-                                                                                   (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q + 2));\n+                case TAG_CLASS -> new AbstractPoolEntry.ClassEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_STRING -> new AbstractPoolEntry.StringEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_FIELDREF -> new AbstractPoolEntry.FieldRefEntryImpl(this, index, readEntry(q, AbstractPoolEntry.ClassEntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_METHODREF -> new AbstractPoolEntry.MethodRefEntryImpl(this, index, readEntry(q, AbstractPoolEntry.ClassEntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_INTERFACEMETHODREF -> new AbstractPoolEntry.InterfaceMethodRefEntryImpl(this, index, readEntry(q, AbstractPoolEntry.ClassEntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_NAMEANDTYPE -> new AbstractPoolEntry.NameAndTypeEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.Utf8EntryImpl.class));\n@@ -410,5 +410,5 @@\n-                case TAG_METHODTYPE -> new AbstractPoolEntry.MethodTypeEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_CONSTANTDYNAMIC -> new AbstractPoolEntry.ConstantDynamicEntryImpl(this, index, readU2(q), (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_INVOKEDYNAMIC -> new AbstractPoolEntry.InvokeDynamicEntryImpl(this, index, readU2(q), (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_MODULE -> new AbstractPoolEntry.ModuleEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_PACKAGE -> new AbstractPoolEntry.PackageEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n+                case TAG_METHODTYPE -> new AbstractPoolEntry.MethodTypeEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_CONSTANTDYNAMIC -> new AbstractPoolEntry.ConstantDynamicEntryImpl(this, index, readU2(q), readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_INVOKEDYNAMIC -> new AbstractPoolEntry.InvokeDynamicEntryImpl(this, index, readU2(q), readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_MODULE -> new AbstractPoolEntry.ModuleEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_PACKAGE -> new AbstractPoolEntry.PackageEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n@@ -431,1 +431,1 @@\n-                throw new IllegalArgumentException(\"attribute \" + readUtf8Entry(p - 6).stringValue() + \" too big to handle\");\n+                throw new IllegalArgumentException(\"attribute \" + readEntry(p - 6, Utf8Entry.class).stringValue() + \" too big to handle\");\n@@ -468,35 +468,0 @@\n-    @Override\n-    public Utf8Entry readUtf8Entry(int pos) {\n-        return readEntry(pos, Utf8Entry.class);\n-    }\n-\n-    @Override\n-    public Utf8Entry readUtf8EntryOrNull(int pos) {\n-        return readEntryOrNull(pos, Utf8Entry.class);\n-    }\n-\n-    @Override\n-    public ModuleEntry readModuleEntry(int pos) {\n-        return readEntry(pos, ModuleEntry.class);\n-    }\n-\n-    @Override\n-    public PackageEntry readPackageEntry(int pos) {\n-        return readEntry(pos, PackageEntry.class);\n-    }\n-\n-    @Override\n-    public ClassEntry readClassEntry(int pos) {\n-        return readEntry(pos, ClassEntry.class);\n-    }\n-\n-    @Override\n-    public NameAndTypeEntry readNameAndTypeEntry(int pos) {\n-        return readEntry(pos, NameAndTypeEntry.class);\n-    }\n-\n-    @Override\n-    public MethodHandleEntry readMethodHandleEntry(int pos) {\n-        return readEntry(pos, MethodHandleEntry.class);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeRelabelerImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        return reader.readUtf8Entry(startPos + 2);\n+        return reader.readEntry(startPos + 2, Utf8Entry.class);\n@@ -69,1 +69,1 @@\n-        return reader.readUtf8Entry(startPos + 4);\n+        return reader.readEntry(startPos + 4, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-        permits BufferedCodeBuilder, CodeImpl, DirectCodeBuilder {\n+        permits TerminalCodeBuilder, CodeImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        public LabelImpl(LabelContext labelContext, int bci) {\n+    public LabelImpl(LabelContext labelContext, int bci) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-        return reader.readUtf8Entry(startPos + 2);\n+        return reader.readEntry(startPos + 2, Utf8Entry.class);\n@@ -72,1 +72,1 @@\n-        return reader.readUtf8Entry(startPos + 4);\n+        return reader.readEntry(startPos + 4, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1049,1 +1049,1 @@\n-            checkLocal(methodDesc.parameterCount() + (isStatic ? 0 : -1));\n+            checkLocal(methodDesc.parameterCount() + (isStatic ? -1 : 0));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,5 +193,0 @@\n-    @Override\n-    public boolean writeBootstrapMethods(BufWriter buf) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n-public sealed interface TerminalCodeBuilder extends CodeBuilder\n-        permits DirectCodeBuilder, BufferedCodeBuilder, TransformingCodeBuilder {\n-\n+public sealed interface TerminalCodeBuilder extends CodeBuilder, LabelContext\n+        permits DirectCodeBuilder, BufferedCodeBuilder {\n+    int curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeModel;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.TypeKind;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-\n-public final class TransformingCodeBuilder implements TerminalCodeBuilder {\n-\n-    final CodeBuilder delegate;\n-    final Consumer<CodeElement> consumer;\n-\n-    public TransformingCodeBuilder(CodeBuilder delegate, Consumer<CodeElement> consumer) {\n-        this.delegate = delegate;\n-        this.consumer = consumer;\n-    }\n-\n-    @Override\n-    public CodeBuilder with(CodeElement e) {\n-        consumer.accept(e);\n-        return this;\n-    }\n-\n-    @Override\n-    public Optional<CodeModel> original() {\n-        return delegate.original();\n-    }\n-\n-    @Override\n-    public Label newLabel() {\n-        return delegate.newLabel();\n-    }\n-\n-    @Override\n-    public Label startLabel() {\n-        return delegate.startLabel();\n-    }\n-\n-    @Override\n-    public Label endLabel() {\n-        return delegate.endLabel();\n-    }\n-\n-    @Override\n-    public int receiverSlot() {\n-        return delegate.receiverSlot();\n-    }\n-\n-    @Override\n-    public int parameterSlot(int paramNo) {\n-        return delegate.parameterSlot(paramNo);\n-    }\n-\n-    @Override\n-    public int allocateLocal(TypeKind typeKind) {\n-        return delegate.allocateLocal(typeKind);\n-    }\n-\n-    @Override\n-    public ConstantPoolBuilder constantPool() {\n-        return delegate.constantPool();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformingCodeBuilder.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -162,1 +162,1 @@\n-                (MemorySessionImpl)scope, action);\n+                (MemorySessionImpl)scope, readOnly, action);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,5 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n+    public static MemorySegment makeNativeSegmentUnchecked(long min,\n+                                                           long byteSize,\n+                                                           MemorySessionImpl sessionImpl,\n+                                                           boolean readOnly,\n+                                                           Runnable action) {\n@@ -67,1 +71,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+        return new NativeMemorySegmentImpl(min, byteSize, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-        return cc.transform(cm, ClassTransform.endHandler(clb -> {\n+        return cc.transformClass(cm, ClassTransform.endHandler(clb -> {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoExtender.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,17 @@\n+    \/**\n+     * Determines whether or not the underlying system\n+     * has useful metrics (a.k.a. is containerized).\n+     *\n+     * @implNote\n+     * Note that Metrics on some systems aren't useful.\n+     * For example on a regular Linux system with cgroups\n+     * present, with no limits enforced and not running in\n+     * a container, Metric aren't useful. This can be used\n+     * in order to determine if the system is containerized.\n+     *\n+     * @return true when the JVM runs in containerized mode.\n+     *         false otherwise.\n+     *\n+     *\/\n+    public boolean isContainerized();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -373,0 +373,4 @@\n+        if (!c.isContainerized()) {\n+            ostream.println(INDENT + \"System not containerized.\");\n+            return;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,3 @@\n+            if (expected > count) {\n+                throw new IOException(\"Premature EOF\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MeteredStream.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1713,1 +1713,1 @@\n-\\f[V]-XX:StartFlightRecording=\\f[R]\\f[I]parameter\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R]\n+\\f[V]-XX:StartFlightRecording:\\f[R]\\f[I]parameter\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R]\n@@ -1717,0 +1717,2 @@\n+\\f[V]-XX:StartFlightRecording:help\\f[R] prints available options and\n+example command lines.\n@@ -1763,0 +1765,2 @@\n+The filename may also be a directory in which case, the filename is\n+generated from the PID and the current date in the specified directory.\n@@ -1843,0 +1847,3 @@\n+.PP\n+To only see warnings and errors from JFR during startup set\n+-Xlog:jfr+startup=warning.\n","filename":"src\/java.base\/share\/man\/java.1","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import javax.swing.plaf.basic.BasicSplitPaneUI;\n@@ -364,0 +365,11 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @param enabled {@inheritDoc}\n+     *\/\n+    @Override\n+    public void setEnabled(boolean enabled) {\n+        super.setEnabled(enabled);\n+        if (this.getUI() instanceof BasicSplitPaneUI) {\n+            ((BasicSplitPaneUI)(this.getUI())).getDivider().setEnabled(enabled);\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSplitPane.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -363,0 +363,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @param enabled {@inheritDoc}\n+     *\/\n+    @Override\n+    public void setEnabled(boolean enabled) {\n+        if (splitPane.isOneTouchExpandable() &&\n+                rightButton != null &&\n+                leftButton != null) {\n+\n+            rightButton.setEnabled(enabled);\n+            leftButton.setEnabled(enabled);\n+        }\n+    }\n@@ -475,0 +489,1 @@\n+        b.setEnabled(splitPane.isEnabled());\n@@ -532,0 +547,1 @@\n+        b.setEnabled(splitPane.isEnabled());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Extends the {@code javax.naming} package to provide functionality\n+ * for accessing directory services.\n+ *\n+ * <p>\n+ * This package defines the directory operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * This package allows applications to retrieve and update attributes\n+ * associated with objects stored in a directory, and to search for\n+ * objects using specified attributes.\n+ *\n+ * <h2>The Directory Context<\/h2>\n+ *\n+ * The {@code DirContext}\n+ * interface represents a <em>directory context<\/em>.\n+ * It defines methods for examining and updating attributes associated with a\n+ * <em>directory object<\/em>, or <em>directory entry<\/em> as it is sometimes\n+ * called.\n+ * <p>\n+ * You use {@code getAttributes()} to retrieve the attributes\n+ * associated with a directory object (for which you supply the name).\n+ * Attributes are modified using {@code modifyAttributes()}.\n+ * You can add, replace, or remove attributes and\/or attribute values\n+ * using this operation.\n+ * <p>\n+ * {@code DirContext} also behaves as a naming context\n+ * by extending the {@code Context} interface in the {@code javax.naming} package.\n+ * This means that any directory object can also provide\n+ * a naming context.\n+ * For example, the directory object for a person might contain\n+ * the attributes of that person, and at the same time provide\n+ * a context for naming objects relative to that person\n+ * such as his printers and home directory.\n+ *\n+ * <h3>Searches<\/h3>\n+ * {@code DirContext} contains methods for\n+ * performing content-based searching of the directory.\n+ * In the simplest and most common form of usage, the application\n+ * specifies a set of attributes--possibly with specific\n+ * values--to match, and submits this attribute set, to the\n+ * {@code search()} method.\n+ * There are other overloaded forms of {@code search()}\n+ * that support more sophisticated <em>search filters<\/em>.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.directory;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/package-info.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Extends the <code>javax.naming<\/code> package to provide functionality\n-for accessing directory services.\n-\n-<p>\n-This package defines the directory operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-This package allows applications to retrieve and update attributes\n-associated with objects stored in a directory, and to search for\n-objects using specified attributes.\n-\n-<h2>The Directory Context<\/h2>\n-\n-The <code>DirContext<\/code>\n-interface represents a <em>directory context<\/em>.\n-It defines methods for examining and updating attributes associated with a\n-<em>directory object<\/em>, or <em>directory entry<\/em> as it is sometimes\n-called.\n-<p>\n-You use\t<code>getAttributes()<\/code> to retrieve the attributes\n-associated with a directory object (for which you supply the name).\n-Attributes are modified using <code>modifyAttributes()<\/code>.\n-You can add, replace, or remove attributes and\/or attribute values\n-using this operation.\n-<p>\n-<code>DirContext<\/code> also behaves as a naming context\n-by extending the <code>Context<\/code> interface in the <code>javax.naming<\/code> package.\n-This means that any directory object can also provide\n-a naming context. \n-For example, the directory object for a person might contain\n-the attributes of that person, and at the same time provide\n-a context for naming objects relative to that person\n-such as his printers and home directory.\n-\n-<h3>Searches<\/h3>\n-<code>DirContext<\/code> contains methods for\n-performing content-based searching of the directory.\n-In the simplest and most common form of usage, the application\n-specifies a set of attributes--possibly with specific\n-values--to match, and submits this attribute set, to the\n-<code>search()<\/code> method.\n-There are other overloaded forms of <code>search()<\/code>\n-that support more sophisticated <em>search filters<\/em>.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/package.html","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides support for event notification when accessing naming and\n+ * directory services.\n+ *\n+ * <p>\n+ * This package defines the event notification operations of the Java Naming\n+ * and Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <h2>Naming Events<\/h2>\n+ * <p>\n+ * This package defines a {@code NamingEvent} class to represent an event\n+ * that is generated by a naming\/directory service.\n+ * It also defines subinterfaces of {@code Context} and {@code DirContext},\n+ * called {@code EventContext} and {@code EventDirContext},\n+ * through which applications can register their interest in events\n+ * fired by the context.\n+ * <p>\n+ * {@code NamingEvent} represents an event that occurs in a\n+ * naming or directory service. There are two categories of naming events:\n+ * <ul>\n+ * <li>Those that affect the namespace (add\/remove\/rename an object)\n+ * <li>Those that affect the objects' contents.\n+ * <\/ul>\n+ * Each category of events is handled by a corresponding listener:\n+ * {@code NamespaceChangeListener}, {@code ObjectChangeListener}.\n+ * <p>\n+ * An application, for example, can register its interest in changes to\n+ * objects in a context as follows:\n+ * {@snippet :\n+ * EventContext src =\n+ *     (EventContext)(new InitialContext()).lookup(\"o=wiz,c=us\");\n+ * src.addNamingListener(\"ou=users\", EventContext.ONELEVEL_SCOPE,\n+ *     new ChangeHandler());\n+ * ...\n+ * class ChangeHandler implements ObjectChangeListener {\n+ *     public void objectChanged(NamingEvent evt) {\n+ *         System.out.println(evt.getNewBinding());\n+ *     }\n+ *     public void namingExceptionThrown(NamingExceptionEvent evt) {\n+ *         System.out.println(evt.getException());\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <a id=THREADING><\/a>\n+ * <h3>Threading Issues<\/h3>\n+ *\n+ * When an event is dispatched to a listener, the listener method (such\n+ * as {@code objectChanged()}) may be executed in a thread other than the\n+ * one in which the call to {@code addNamingListener()} was executed.\n+ * The choice of which thread to use is made by the service provider.\n+ * When an event is dispatched to multiple listeners, the service provider\n+ * may choose (and is generally encouraged) to execute the listener methods\n+ * concurrently in separate threads.\n+ * <p>\n+ * When a listener instance invokes {@code NamingEvent.getEventContext()},\n+ * it must take into account the possibility that other threads will be\n+ * working with that context concurrently. Likewise, when a listener is\n+ * registered via {@code addNamingListener()}, the registering thread\n+ * must take into account the likely possibility that the service provider\n+ * will later invoke the listeners in newly-created threads. As {@code Context}\n+ * instances are not guaranteed to be thread-safe in general, all context\n+ * operations must be synchronized as needed.\n+ *\n+ * <h3>Exception Handling<\/h3>\n+ *\n+ * When a listener registers for events with a context, the context might\n+ * need to do some internal processing in order to collect information\n+ * required to generate the events. The context, for example, might need\n+ * to make a request to the server to register interest in changes\n+ * on the server that will eventually be translated into events.\n+ * If an exception occurs that prevents information about the events from\n+ * being collected, the listener will never be notified of the events.\n+ * When such an exception occurs, a {@code NamingExceptionEvent} is\n+ * fired to notify the listener. The listener's\n+ * {@code namingExceptionThrown()} method is invoked, as shown in the\n+ * sample code above,\n+ * and the listener is automatically deregistered.\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.event;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/event\/package-info.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -1,125 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides support for event notification when accessing naming and\n-directory services.\n-\n-<p>\n-This package defines the event notification operations of the Java Naming\n-and Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<h2>Naming Events<\/h2>\n-<p>\n-This package defines a <code>NamingEvent<\/code> class to represent an event\n-that is generated by a naming\/directory service.\n-It also defines subinterfaces of <code>Context<\/code> and <code>DirContext<\/code>,\n-called <code>EventContext<\/code> and <code>EventDirContext<\/code>,\n-through which applications can register their interest in events\n-fired by the context.\n-<p>\n-<code>NamingEvent<\/code> represents an event that occurs in a \n-naming or directory service. There are two categories of naming events:\n-<ul>\n-<li>Those that affect the namespace (add\/remove\/rename an object)\n-<li>Those that affect the objects' contents.\n-<\/ul>\n-Each category of events is handled by a corresponding listener:\n-<code>NamespaceChangeListener<\/code>, <code>ObjectChangeListener<\/code>.\n-<p>\n-An application, for example, can register its interest in changes to\n-objects in a context as follows:\n-<blockquote>\n-<pre>\n-EventContext src = \n-    (EventContext)(new InitialContext()).lookup(\"o=wiz,c=us\");\n-src.addNamingListener(\"ou=users\", EventContext.ONELEVEL_SCOPE,\n-    new ChangeHandler());\n-...\n-class ChangeHandler implements ObjectChangeListener {\n-    public void objectChanged(NamingEvent evt) {\n-        System.out.println(evt.getNewBinding());\n-    }\n-    public void namingExceptionThrown(NamingExceptionEvent evt) {\n-        System.out.println(evt.getException());\n-    }\n-}\n-<\/pre>\n-<\/blockquote>\n-\n-<a id=THREADING><\/a>\n-<h3>Threading Issues<\/h3>\n-\n-When an event is dispatched to a listener, the listener method (such\n-as <code>objectChanged()<\/code>) may be executed in a thread other than the\n-one in which the call to <code>addNamingListener()<\/code> was executed.\n-The choice of which thread to use is made by the service provider.\n-When an event is dispatched to multiple listeners, the service provider\n-may choose (and is generally encouraged) to execute the listener methods\n-concurrently in separate threads.\n-<p>\n-When a listener instance invokes <code>NamingEvent.getEventContext()<\/code>,\n-it must take into account the possibility that other threads will be\n-working with that context concurrently.  Likewise, when a listener is\n-registered via <code>addNamingListener()<\/code>, the registering thread\n-must take into account the likely possibility that the service provider\n-will later invoke the listeners in newly-created threads.  As <code>Context<\/code>\n-instances are not guaranteed to be thread-safe in general, all context\n-operations must be synchronized as needed.\n-\n-<h3>Exception Handling<\/h3>\n-\n-When a listener registers for events with a context, the context might\n-need to do some internal processing in order to collect information\n-required to generate the events.  The context, for example, might need\n-to make a request to the server to register interest in changes\n-on the server that will eventually be translated into events.\n-If an exception occurs that prevents information about the events from\n-being collected, the listener will never be notified of the events.\n-When such an exception occurs, a <code>NamingExceptionEvent<\/code> is\n-fired to notify the listener. The listener's\n-<code>namingExceptionThrown()<\/code> method is invoked, as shown in the\n-sample code above,\n-and the listener is automatically deregistered.\n-\n-<h2>Package Specification<\/h2>\n-\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/event\/package.html","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides support for LDAPv3 extended operations and controls.\n+ *\n+ * <p>\n+ * This package extends the directory operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * This package is for applications and service providers that deal with\n+ * LDAPv3 extended operations and controls, as defined by\n+ * <a href=http:\/\/www.ietf.org\/rfc\/rfc2251.txt>RFC 2251<\/a>.\n+ * The core interface in this package is {@code LdapContext}, which defines\n+ * methods on a context for performing extended operations and handling\n+ * controls.\n+ *\n+ * <h2>Extended Operations<\/h2>\n+ * <p>\n+ * This package defines the interface {@code ExtendedRequest}\n+ * to represent the argument to an extended operation,\n+ * and the interface {@code ExtendedResponse} to represent the result\n+ * of the extended operation.\n+ * An extended response is always paired with an extended request\n+ * but not necessarily vice versa. That is, you can have an extended request\n+ * that has no corresponding extended response.\n+ * <p>\n+ * An application typically does not deal directly with these interfaces.\n+ * Instead, it deals with classes that <em>implement<\/em> these\n+ * interfaces.\n+ * The application gets these classes either as part of a\n+ * repertoire of extended operations standardized through the IETF, or\n+ * from directory vendors for vendor-specific extended operations.\n+ * The request classes should have constructors that accept\n+ * arguments in a type-safe and user-friendly manner, while the\n+ * response classes should have access methods for getting the data\n+ * of the response in a type-safe and user-friendly manner.\n+ * Internally, the request\/response classes deal with encoding and decoding\n+ * BER values.\n+ * <p>\n+ * For example, suppose an LDAP server supports a \"get time\" extended operation.\n+ * It would supply classes such as\n+ * {@code GetTimeRequest} and {@code GetTimeResponse},\n+ * so that applications can use this feature.\n+ * An application would use these classes as follows:\n+ * {@snippet :\n+ * GetTimeResponse resp =\n+ *     (GetTimeResponse) ectx.extendedOperation(new GetTimeRequest());\n+ * long time = resp.getTime();\n+ * }\n+ * <p>\n+ * The {@code GetTimeRequest} and {@code GetTimeResponse} classes might\n+ * be defined as follows:\n+ * {@snippet :\n+ * public class GetTimeRequest implements ExtendedRequest {\n+ *     \/\/ User-friendly constructor\n+ *     public GetTimeRequest() {\n+ *     };\n+ *\n+ *     \/\/ Methods used by service providers\n+ *     public String getID() {\n+ *         return GETTIME_REQ_OID;\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return null;  \/\/ no value needed for get time request\n+ *     }\n+ *     public ExtendedResponse createExtendedResponse(\n+ *         String id, byte[] berValue, int offset, int length) throws NamingException {\n+ *         return new GetTimeResponse(id, berValue, offset, length);\n+ *     }\n+ * }\n+ * public class GetTimeResponse implements ExtendedResponse {\n+ *     long time;\n+ *     \/\/ called by GetTimeRequest.createExtendedResponse()\n+ *     public GetTimeResponse(String id, byte[] berValue, int offset, int length)\n+ *         throws NamingException {\n+ *         \/\/ check validity of id\n+ *         long time =  ... \/\/ decode berValue to get time\n+ *     }\n+ *\n+ *     \/\/ Type-safe and User-friendly methods\n+ *     public java.util.Date getDate() { return new java.util.Date(time); }\n+ *     public long getTime() { return time; }\n+ *\n+ *     \/\/ Low level methods\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ berValue saved;\n+ *     }\n+ *     public String getID() {\n+ *         return GETTIME_RESP_OID;\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <h2>Controls<\/h2>\n+ *\n+ * This package defines the interface {@code Control} to represent an LDAPv3\n+ * control. It can be a control that is sent to an LDAP server\n+ * (<em>request control<\/em>) or a control returned by an LDAP server\n+ * (<em>response control<\/em>). Unlike extended requests and responses,\n+ * there is not necessarily any pairing between request controls and\n+ * response controls. You can send request controls and expect no\n+ * response controls back, or receive response controls without sending\n+ * any request controls.\n+ * <p>\n+ * An application typically does not deal directly with this interface.\n+ * Instead, it deals with classes that <em>implement<\/em> this interface.\n+ * The application gets control classes either as part of a repertoire of\n+ * controls standardized through the IETF, or from directory vendors for\n+ * vendor-specific controls. The request control classes should have\n+ * constructors that accept arguments in a type-safe and user-friendly\n+ * manner, while the response control classes should have access methods\n+ * for getting the data of the response in a type-safe and user-friendly\n+ * manner. Internally, the request\/response control classes deal with\n+ * encoding and decoding BER values.\n+ * <p>\n+ * For example, suppose an LDAP server supports a \"signed results\"\n+ * request control, which when sent with a request, asks the\n+ * server to digitally sign the results of an operation.\n+ * It would supply a class {@code SignedResultsControl} so that applications\n+ * can use this feature.\n+ * An application would use this class as follows:\n+ * {@snippet :\n+ * Control[] reqCtls = new Control[] {new SignedResultsControl(Control.CRITICAL)};\n+ * ectx.setRequestControls(reqCtls);\n+ * NamingEnumeration enum = ectx.search(...);\n+ * }\n+ * The {@code SignedResultsControl} class might be defined as follows:\n+ * {@snippet :\n+ * public class SignedResultsControl implements Control {\n+ *     \/\/ User-friendly constructor\n+ *     public SignedResultsControl(boolean criticality) {\n+ *  \/\/ assemble the components of the request control\n+ *     };\n+ *\n+ *     \/\/ Methods used by service providers\n+ *     public String getID() {\n+ *         return \/\/ control's object identifier\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ ASN.1 BER encoded control value\n+ *     }\n+ *     ...\n+ * }\n+ * }\n+ * <p>\n+ * When a service provider receives response controls, it uses\n+ * the {@code ControlFactory} class to produce specific classes\n+ * that implement the {@code Control} interface.\n+ * <p>\n+ * An LDAP server can send back response controls with an LDAP operation\n+ * and also with enumeration results, such as those returned\n+ * by a list or search operation.\n+ * The {@code LdapContext} provides a method ({@code getResponseControls()})\n+ * for getting the response controls sent with an LDAP operation,\n+ * while the {@code HasControls} interface is used to retrieve\n+ * response controls associated with enumeration results.\n+ * <p>\n+ * For example, suppose an LDAP server sends back a \"change ID\" control in response\n+ * to a successful modification. It would supply a class {@code ChangeIDControl}\n+ * so that the application can use this feature.\n+ * An application would perform an update, and then try to get the change ID.\n+ * {@snippet :\n+ * \/\/ Perform update\n+ * Context ctx = ectx.createSubsubcontext(\"cn=newobj\");\n+ *\n+ * \/\/ Get response controls\n+ * Control[] respCtls = ectx.getResponseControls();\n+ * if (respCtls != null) {\n+ *     \/\/ Find the one we want\n+ *     for (int i = 0; i < respCtls.length; i++) {\n+ *         if(respCtls[i] instanceof ChangeIDControl) {\n+ *      ChangeIDControl cctl = (ChangeIDControl)respCtls[i];\n+ *      System.out.println(cctl.getChangeID());\n+ *         }\n+ *     }\n+ * }\n+ * }\n+ * The vendor might supply the following {@code ChangeIDControl} and\n+ * {@code VendorXControlFactory} classes. The {@code VendorXControlFactory}\n+ * will be used by the service provider when the provider receives response\n+ * controls from the LDAP server.\n+ * {@snippet :\n+ * public class ChangeIDControl implements Control {\n+ *     long id;\n+ *\n+ *     \/\/ Constructor used by ControlFactory\n+ *     public ChangeIDControl(String OID, byte[] berVal) throws NamingException {\n+ *         \/\/ check validity of OID\n+ *         id = \/\/ extract change ID from berVal\n+ *     };\n+ *\n+ *     \/\/ Type-safe and User-friendly method\n+ *     public long getChangeID() {\n+ *         return id;\n+ *     }\n+ *\n+ *     \/\/ Low-level methods\n+ *     public String getID() {\n+ *         return CHANGEID_OID;\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ original berVal\n+ *     }\n+ *     ...\n+ * }\n+ * public class VendorXControlFactory extends ControlFactory {\n+ *     public VendorXControlFactory () {\n+ *     }\n+ *\n+ *     public Control getControlInstance(Control orig) throws NamingException {\n+ *         if (isOneOfMyControls(orig.getID())) {\n+ *      ...\n+ *\n+ *      \/\/ determine which of ours it is and call its constructor\n+ *      return (new ChangeIDControl(orig.getID(), orig.getEncodedValue()));\n+ *  }\n+ *         return null;  \/\/ not one of ours\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.ldap;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/package-info.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -1,266 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n- \n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides support for LDAPv3 extended operations and controls.\n-\n-<p>\n-This package extends the directory operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-This package is for applications and service providers that deal with\n-LDAPv3 extended operations and controls, as defined by\n-<a href=http:\/\/www.ietf.org\/rfc\/rfc2251.txt>RFC 2251<\/a>.\n-The core interface in this package is <code>LdapContext<\/code>, which defines\n-methods on a context for performing extended operations and handling\n-controls.\n-\n-<h2>Extended Operations<\/h2>\n-<p>\n-This package defines the interface <code>ExtendedRequest<\/code>\n-to represent the argument to an extended operation,\n-and the interface <code>ExtendedResponse<\/code> to represent the result\n-of the extended operation.\n-An extended response is always paired with an extended request\n-but not necessarily vice versa. That is, you can have an extended request\n-that has no corresponding extended response.\n-<p>\n-An application typically does not deal directly with these interfaces.\n-Instead, it deals with classes that <em>implement<\/em> these\n-interfaces.  \n-The application gets these classes either as part of a\n-repertoire of extended operations standardized through the IETF, or\n-from directory vendors for vendor-specific extended operations.\n-The request classes should have constructors that accept\n-arguments in a type-safe and user-friendly manner, while the\n-response classes should have access methods for getting the data\n-of the response in a type-safe and user-friendly manner.\n-Internally, the request\/response classes deal with encoding and decoding\n-BER values.\n-<p>\n-For example, suppose an LDAP server supports a \"get time\" extended operation.\n-It would supply classes such as\n-<code>GetTimeRequest<\/code> and <code>GetTimeResponse<\/code>,\n-so that applications can use this feature.\n-An application would use these classes as follows:\n-<blockquote><pre>\n-GetTimeResponse resp =\n-    (GetTimeResponse) ectx.extendedOperation(new GetTimeRequest());\n-long time = resp.getTime();\n-<\/pre><\/blockquote>\n-<p>\n-The <code>GetTimeRequest<\/code> and <code>GetTimeResponse<\/code> classes might\n-be defined as follows:\n-<blockquote><pre>\n-public class GetTimeRequest implements ExtendedRequest {\n-    \/\/ User-friendly constructor \n-    public GetTimeRequest() {\n-    };\n-\n-    \/\/ Methods used by service providers\n-    public String getID() {\n-        return GETTIME_REQ_OID;\n-    }\n-    public byte[] getEncodedValue() {\n-        return null;  \/\/ no value needed for get time request\n-    }\n-    public ExtendedResponse createExtendedResponse(\n-        String id, byte[] berValue, int offset, int length) throws NamingException {\n-        return new GetTimeResponse(id, berValue, offset, length);\n-    }\n-}\n-public class GetTimeResponse() implements ExtendedResponse {\n-    long time;\n-    \/\/ called by GetTimeRequest.createExtendedResponse()\n-    public GetTimeResponse(String id, byte[] berValue, int offset, int length)\n-        throws NamingException {\n-        \/\/ check validity of id\n-        long time =  ... \/\/ decode berValue to get time\n-    }\n-\n-    \/\/ Type-safe and User-friendly methods\n-    public java.util.Date getDate() { return new java.util.Date(time); }\n-    public long getTime() { return time; }\n-\n-    \/\/ Low level methods\n-    public byte[] getEncodedValue() {\n-        return \/\/ berValue saved;\n-    }\n-    public String getID() {\n-        return GETTIME_RESP_OID;\n-    }\n-}\n-<\/pre><\/blockquote>\n-\n-<h2>Controls<\/h2>\n-\n-This package defines the interface <code>Control<\/code> to represent an LDAPv3\n-control. It can be a control that is sent to an LDAP server\n-(<em>request control<\/em>) or a control returned by an LDAP server\n-(<em>response control<\/em>).  Unlike extended requests and responses,\n-there is not necessarily any pairing between request controls and\n-response controls.  You can send request controls and expect no\n-response controls back, or receive response controls without sending\n-any request controls.\n-<p>\n-An application typically does not deal directly with this interface.\n-Instead, it deals with classes that <em>implement<\/em> this interface.\n-The application gets control classes either as part of a repertoire of\n-controls standardized through the IETF, or from directory vendors for\n-vendor-specific controls.  The request control classes should have\n-constructors that accept arguments in a type-safe and user-friendly\n-manner, while the response control classes should have access methods\n-for getting the data of the response in a type-safe and user-friendly\n-manner.  Internally, the request\/response control classes deal with\n-encoding and decoding BER values.\n-<p>\n-For example, suppose an LDAP server supports a \"signed results\"\n-request control, which when sent with a request, asks the\n-server to digitally sign the results of an operation.\n-It would supply a class <code>SignedResultsControl<\/code>  so that applications\n-can use this feature.\n-An application  would use this class as follows:\n-<blockquote>\n-<pre>\n-Control[] reqCtls = new Control[] {new SignedResultsControl(Control.CRITICAL)};\n-ectx.setRequestControls(reqCtls);\n-NamingEnumeration enum = ectx.search(...);\n-<\/pre>\n-<\/blockquote>\n-The <code>SignedResultsControl<\/code> class might be defined as follows:\n-<blockquote><pre>\n-public class SignedResultsControl implements Control {\n-    \/\/ User-friendly constructor \n-    public SignedResultsControl(boolean criticality) {\n-\t\/\/ assemble the components of the request control\n-    };\n-\n-    \/\/ Methods used by service providers\n-    public String getID() {\n-        return \/\/ control's object identifier\n-    }\n-    public byte[] getEncodedValue() {\n-        return \/\/ ASN.1 BER encoded control value\n-    }\n-    ...\n-}\n-<\/pre><\/blockquote>\n-<p>\n-When a service provider receives response controls, it uses\n-the <code>ControlFactory<\/code> class to produce specific classes\n-that implement the <code>Control<\/code> interface.\n-<p>\n-An LDAP server can send back response controls with an LDAP operation\n-and also with enumeration results, such as those returned\n-by a list or search operation.\n-The <code>LdapContext<\/code> provides a method (<code>getResponseControls()<\/code>)\n-for getting the response controls sent with an LDAP operation,\n-while the <code>HasControls<\/code> interface is used to retrieve\n-response controls associated with enumeration results.\n-<p>\n-For example, suppose an LDAP server sends back a \"change ID\" control in response\n-to a successful modification. It would supply a class <code>ChangeIDControl<\/code>\n-so that the application can use this feature.\n-An application would perform an update, and then try to get the change ID.\n-<blockquote><pre>\n-\/\/ Perform update\n-Context ctx = ectx.createSubsubcontext(\"cn=newobj\");\n-\n-\/\/ Get response controls\n-Control[] respCtls = ectx.getResponseControls();\n-if (respCtls != null) {\n-    \/\/ Find the one we want\n-    for (int i = 0; i &lt; respCtls; i++) {\n-        if(respCtls[i] instanceof ChangeIDControl) {\n-\t    ChangeIDControl cctl = (ChangeIDControl)respCtls[i];\n-\t    System.out.println(cctl.getChangeID());\n-        }\n-    }\n-}\n-<\/pre><\/blockquote>\n-The vendor might supply the following <code>ChangeIDControl<\/code> and\n-<code>VendorXControlFactory<\/code> classes. The <code>VendorXControlFactory<\/code>\n-will be used by the service provider when the provider receives response\n-controls from the LDAP server.\n-<blockquote><pre>\n-public class ChangeIDControl implements Control {\n-    long id;\n-\n-    \/\/ Constructor used by ControlFactory\n-    public ChangeIDControl(String OID, byte[] berVal) throws NamingException {\n-        \/\/ check validity of OID\n-        id = \/\/ extract change ID from berVal\n-    };\n-\n-    \/\/ Type-safe and User-friendly method\n-    public long getChangeID() {\n-        return id;\n-    }\n-\n-    \/\/ Low-level methods\n-    public String getID() {\n-        return CHANGEID_OID;\n-    }\n-    public byte[] getEncodedValue() {\n-        return \/\/ original berVal\n-    }\n-    ...\n-}\n-public class VendorXControlFactory extends ControlFactory {\n-    public VendorXControlFactory () {\n-    }\n-\n-    public Control getControlInstance(Control orig) throws NamingException {\n-        if (isOneOfMyControls(orig.getID())) {\n-\t    ...\n-\n-\t    \/\/ determine which of ours it is and call its constructor\n-\t    return (new ChangeIDControl(orig.getID(), orig.getEncodedValue()));\n-\t}\n-        return null;  \/\/ not one of ours\n-    }\n-}\n-<\/pre><\/blockquote>\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/package.html","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides the Service Provider Interface for DNS lookups when\n+ * performing LDAP operations.\n+ *\n+ * @since 12\n+ *\/\n+package javax.naming.ldap.spi;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/spi\/package-info.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides the classes and interfaces for accessing naming services.\n+ *\n+ * <p>\n+ * This package defines the naming operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ *\n+ * <h2>Context<\/h2>\n+ * <p>\n+ * This package defines the notion of a <em>context<\/em>, represented\n+ * by the {@code Context} interface.\n+ * A context consists of a set of name-to-object <em>bindings<\/em>.\n+ * {@code Context} is the core interface for looking up, binding, unbinding,\n+ * and renaming objects, and for creating and destroying subcontexts.\n+ * <p>\n+ * {@code lookup()} is the most commonly used operation.\n+ * You supply {@code lookup()}\n+ * the name of the object you want\n+ * to look up, and it returns the object bound to that name.\n+ * For example, the following code fragment looks up\n+ * a printer and sends a document to the printer object\n+ * to be printed:\n+ *\n+ * {@snippet :\n+ * Printer printer = (Printer)ctx.lookup(\"treekiller\");\n+ * printer.print(report);\n+ * }\n+ *\n+ * <h2>Names<\/h2>\n+ * <p>\n+ * Every naming method in the {@code Context}\n+ * interface has two\n+ * overloads: one that accepts a\n+ * {@code Name} argument and one that accepts a string name.\n+ * {@code Name} is an interface that represents a generic\n+ * name--an ordered sequence of zero of more components.\n+ * For these methods, {@code Name} can be used to represent a\n+ * <em>composite name<\/em> ({@code CompositeName})\n+ * so that you can name an object using a name which spans multiple namespaces.\n+ * <p>\n+ * The overloads that accept {@code Name}\n+ * are useful for applications that need to manipulate names: composing\n+ * them, comparing components, and so on.\n+ * The overloads that accept string names are likely to be more useful\n+ * for simple applications, such as those that simply read in a name\n+ * and look up the corresponding object.\n+ *\n+ * <h2>Bindings<\/h2>\n+ *\n+ * The {@code Binding} class represents a name-to-object binding.\n+ * It is a tuple containing the name of the bound object,\n+ * the name of the object's class, and the object itself.\n+ * <p>\n+ * The {@code Binding} class is actually a subclass of\n+ * {@code NameClassPair}, which consists\n+ * simply of the object's name and the object's class name.\n+ * The {@code NameClassPair} is useful when you only want\n+ * information about the object's class and do not want to\n+ * pay the extra cost of getting the object.\n+ *\n+ * <h2>References<\/h2>\n+ * Objects are stored in naming and directory services in different ways.\n+ * If an object store supports storing Java objects,\n+ * it might support storing an object in its serialized form.\n+ * However, some naming and directory services do not support the\n+ * storing of Java objects. Furthermore, for some\n+ * objects in the directory, Java programs are but one group of applications\n+ * that access them. In this case, a serialized Java object might\n+ * not be the most appropriate representation.\n+ * JNDI defines a <em>reference<\/em>, represented by the {@code Reference}\n+ * class, which contains information on how to construct a copy of the object.\n+ * JNDI will attempt to turn references looked up from the directory\n+ * into the Java objects they represent, so that\n+ * JNDI clients have the illusion that what\n+ * is stored in the directory are Java objects.\n+ *\n+ *\n+ * <h2>The Initial Context<\/h2>\n+ *\n+ * In JNDI, all naming and directory operations are performed relative\n+ * to a context. There are no absolute roots.\n+ * Therefore JNDI defines an <em>initial context<\/em>,\n+ * {@code InitialContext},\n+ * which provides a starting point for naming and directory operations.\n+ * Once you have an initial context, you can use it to\n+ * look up other contexts and objects.\n+ *\n+ * <h2>Exceptions<\/h2>\n+ *\n+ * JNDI defines a class hierarchy for exceptions that can be thrown in\n+ * the course of performing naming and directory operations. The root of\n+ * this class hierarchy is {@code NamingException}.\n+ * Programs interested in dealing with a particular exception\n+ * can catch the corresponding subclass of the exception.\n+ * Otherwise, programs should catch {@code NamingException}.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/package-info.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -1,143 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides the classes and interfaces for accessing naming services.\n-\n-<p>\n-This package defines the naming operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-\n-<h2>Context<\/h2>\n-<p>\n-This package defines the notion of a <em>context<\/em>, represented\n-by the <code>Context<\/code> interface.\n-A context consists of a set of name-to-object <em>bindings<\/em>.\n-<code>Context<\/code> is the core interface for looking up, binding, unbinding,\n-and renaming objects, and for creating and destroying subcontexts.\n-<p>\n-<code>lookup()<\/code> is the most commonly used operation.\n-You supply <code>lookup()<\/code>\n-the name of the object you want\n-to look up, and it returns the object bound to that name.\n-For example, the following code fragment looks up \n-a printer and sends a document to the printer object\n-to be printed:\n-\n-<blockquote>\n-<pre>\n-Printer printer = (Printer)ctx.lookup(\"treekiller\");\n-printer.print(report);\n-<\/pre>\n-<\/blockquote>\n-\n-<h2>Names<\/h2>\n-<p>\n-Every naming method in the <code>Context<\/code>\n-interface has two\n-overloads: one that accepts a \n-<code>Name<\/code> argument and one that accepts a string name.\n-<code>Name<\/code> is an interface that represents a generic \n-name--an ordered sequence of zero of more components.\n-For these methods, <code>Name<\/code> can be used to represent a\n-<em>composite name<\/em> (<code>CompositeName<\/code>)\n-so that you can name an object using a name which spans multiple namespaces.\n-<p>\n-The overloads that accept <code>Name<\/code>\n-are useful for applications that need to manipulate names: composing\n-them, comparing components, and so on.\n-The overloads that accept string names are likely to be more useful\n-for simple applications, such as those that simply read in a name\n-and look up the corresponding object.\n-\n-<h2>Bindings<\/h2>\n-\n-The <code>Binding<\/code> class represents a name-to-object binding.\n-It is a tuple containing the name of the bound object,\n-the name of the object's class, and the object itself.\n-<p>\n-The <code>Binding<\/code> class is actually a subclass of\n-<code>NameClassPair<\/code>, which consists\n-simply of the object's name and the object's class name.\n-The <code>NameClassPair<\/code> is useful when you only want\n-information about the object's class and do not want to\n-pay the extra cost of getting the object.\n-\n-<h2>References<\/h2>\n-Objects are stored in naming and directory services in different ways.\n-If an object store supports storing Java objects, \n-it might support storing an object in its serialized form.\n-However, some naming and directory services do not support the\n-storing of Java objects. Furthermore, for some\n-objects in the directory, Java programs are but one group of applications \n-that access them. In this case, a serialized Java object might\n-not be the most appropriate representation.\n-JNDI defines a <em>reference<\/em>, represented by the <code>Reference<\/code>\n-class, which contains information on how to construct a copy of the object.\n-JNDI will attempt to turn references looked up from the directory\n-into the Java objects they represent, so that\n-JNDI clients have the illusion that what\n-is stored in the directory are Java objects. \n-\n-\n-<h2>The Initial Context<\/h2>\n-\n-In JNDI, all naming and directory operations are performed relative\n-to a context. There are no absolute roots.\n-Therefore JNDI defines an <em>initial context<\/em>, \n-<code>InitialContext<\/code>,\n-which provides a starting point for naming and directory operations.\n-Once you have an initial context, you can use it to\n-look up other contexts and objects.\n-\n-<h2>Exceptions<\/h2>\n-\n-JNDI defines a class hierarchy for exceptions that can be thrown in\n-the course of performing naming and directory operations.  The root of\n-this class hierarchy is <code>NamingException<\/code>.\n-Programs interested in dealing with a particular exception\n-can catch the corresponding subclass of the exception.\n-Otherwise, programs should catch <code>NamingException<\/code>.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/package.html","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides the means for dynamically plugging in support for accessing\n+ * naming and directory services through the {@code javax.naming}\n+ * and related packages.\n+ *\n+ * <p>\n+ * This package defines the service provider interface (SPI) of the Java Naming\n+ * and Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * The JNDI SPI provides the means for creating JNDI service providers,\n+ * through which JNDI applications access different naming and\n+ * directory services.\n+ *\n+ *\n+ * <h2>Plug-in Architecture<\/h2>\n+ *\n+ * The service provider package allows different implementations to be plugged in\n+ * dynamically.\n+ * These different implementations include those for the\n+ * <em>initial context<\/em>,\n+ * and implementations for contexts that can be reached\n+ * from the initial context.\n+ *\n+ * <h2>Java Object Support<\/h2>\n+ *\n+ * The service provider package provides support\n+ * for implementors of the\n+ * {@code javax.naming.Context.lookup()}\n+ * method and related methods to return Java objects that are natural\n+ * and intuitive for the Java programmer.\n+ * For example, when looking up a printer name from the directory,\n+ * it is natural for you to expect to get\n+ * back a printer object on which to operate.\n+ *\n+ *\n+ * <h2>Multiple Naming Systems (Federation)<\/h2>\n+ *\n+ * JNDI operations allow applications to supply names that span multiple\n+ * naming systems. So in the process of completing\n+ * an operation, one service provider might need to interact\n+ * with another service provider, for example, to pass on\n+ * the operation to be continued in the next naming system.\n+ * The service provider package provides support for\n+ * different providers to cooperate to complete JNDI operations.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI SPI Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.spi;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/package-info.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides the means for dynamically plugging in support for accessing\n-naming and directory services through the <code>javax.naming<\/code>\n-and related packages.\n-\n-<p>\n-This package defines the service provider interface (SPI) of the Java Naming\n-and Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-The JNDI SPI provides the means for creating JNDI service providers,\n-through which JNDI applications access different naming and\n-directory services.\n-\n-\n-<h2>Plug-in Architecture<\/h2>\n-\n-The service provider package allows different implementations to be plugged in\n-dynamically.\n-These different implementations include those for the\n-<em>initial context<\/em>,\n-and implementations for contexts that can be reached \n-from the initial context.\n-\n-<h2>Java Object Support<\/h2>\n-\n-The service provider package provides support\n-for implementors of the\n-<code>javax.naming.Context.lookup()<\/code>\n-method and related methods to return Java objects that are natural\n-and intuitive for the Java programmer.\n-For example, when looking up a printer name from the directory,\n-it is natural for you to expect to get\n-back a printer object on which to operate.\n-\n-\n-<h2>Multiple Naming Systems (Federation)<\/h2>\n-\n-JNDI operations allow applications to supply names that span multiple\n-naming systems.  So in the process of completing\n-an operation, one service provider might need to interact\n-with another service provider, for example, to pass on\n-the operation to be continued in the next naming system.\n-The service provider package provides support for\n-different providers to cooperate to complete JNDI operations.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI SPI Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/package.html","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -2434,1 +2434,8 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n+        try {\n+            return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n+        } catch (ClassFinder.BadClassFile err) {\n+            return new BadClassFileError(err);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return typeNotFound;\n+        }\n@@ -2506,1 +2513,8 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name));\n+        try {\n+            return checkNonExistentType(checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name));\n+        } catch (ClassFinder.BadClassFile err) {\n+            return new BadClassFileError(err);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return typeNotFound;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2935,1 +2935,1 @@\n-                    case NULL: case IDENTIFIER: case TRUE: case FALSE:\n+                    case NULL: case IDENTIFIER: case UNDERSCORE: case TRUE: case FALSE:\n@@ -3456,1 +3456,9 @@\n-                case RPAREN: parenDepth--; break;\n+                case RPAREN:\n+                    parenDepth--;\n+                    if (parenDepth == 0 &&\n+                        typeDepth == 0 &&\n+                        peekToken(lookahead, TokenKind.IDENTIFIER) &&\n+                        S.token(lookahead + 1).name() == names.when) {\n+                        return PatternResult.PATTERN;\n+                    }\n+                    break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,8 @@\n-    public PlatformDescription getPlatform(String platformName, String options) {\n+    public PlatformDescription getPlatform(String platformName, String options) throws PlatformNotSupported {\n+        if (!SUPPORTED_JAVA_PLATFORM_VERSIONS.contains(platformName)) {\n+            throw new PlatformNotSupported();\n+        }\n+        return getPlatformTrusted(platformName);\n+    }\n+\n+    public PlatformDescription getPlatformTrusted(String platformName) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -187,0 +187,3 @@\n+        else if (arg instanceof JCDiagnostic.AnnotatedType type) {\n+            preprocessType(type.type());\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+class name javax\/swing\/plaf\/basic\/BasicSliderUI\n+-method name <init> descriptor ()V\n+method name <init> descriptor ()V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"23\")\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.desktop-N.sym.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,0 +167,5 @@\n+    \/\/ CTS mode variant used by the token, as described in Addendum to NIST\n+    \/\/ Special Publication 800-38A, \"Recommendation for Block Cipher Modes\n+    \/\/ of Operation: Three Variants of Ciphertext Stealing for CBC Mode\".\n+    private Token.CTSVariant ctsVariant = null;\n+\n@@ -324,0 +329,4 @@\n+    Token.CTSVariant getCTSVariant() {\n+        return ctsVariant;\n+    }\n+\n@@ -475,0 +484,2 @@\n+            case \"cipherTextStealingVariant\"->\n+                ctsVariant = parseEnumEntry(Token.CTSVariant.class, st.sval);\n@@ -630,0 +641,11 @@\n+    private <E extends Enum<E>> E parseEnumEntry(Class<E> enumClass,\n+            String keyword) throws IOException {\n+        String value = parseStringEntry(keyword);\n+        try {\n+            return Enum.valueOf(enumClass, value);\n+        } catch (IllegalArgumentException ignored) {\n+            throw excToken(keyword + \" must be one of \" +\n+                    Arrays.toString(enumClass.getEnumConstants()) + \", read:\");\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * This class is designed to support ECB, CBC, CTR with NoPadding\n+ * This class is designed to support ECB, CBC, CTR, CTS with NoPadding\n@@ -63,11 +63,3 @@\n-    \/\/ mode constant for ECB mode\n-    private static final int MODE_ECB = 3;\n-    \/\/ mode constant for CBC mode\n-    private static final int MODE_CBC = 4;\n-    \/\/ mode constant for CTR mode\n-    private static final int MODE_CTR = 5;\n-\n-    \/\/ padding constant for NoPadding\n-    private static final int PAD_NONE = 5;\n-    \/\/ padding constant for PKCS5Padding\n-    private static final int PAD_PKCS5 = 6;\n+    \/\/ mode and padding constants\n+    private enum Mode {ECB \/* or stream ciphers *\/, CBC, CTR, CTS}\n+    private enum Pad {NONE, PKCS5}\n@@ -149,2 +141,2 @@\n-    \/\/ mode, one of MODE_* above (MODE_ECB for stream ciphers)\n-    private int blockMode;\n+    \/\/ mode, Mode.ECB for stream ciphers\n+    private final Mode blockMode;\n@@ -155,2 +147,2 @@\n-    \/\/ padding type, on of PAD_* above (PAD_NONE for stream ciphers)\n-    private int paddingType;\n+    \/\/ padding type, Pad.NONE for stream ciphers\n+    private Pad paddingType;\n@@ -166,1 +158,1 @@\n-    \/\/ original IV, if in MODE_CBC or MODE_CTR\n+    \/\/ original IV, if in Mode.CBC, Mode.CTR or Mode.CTS\n@@ -211,2 +203,1 @@\n-        this.blockMode =\n-            (algoParts.length > 1 ? parseMode(algoParts[1]) : MODE_ECB);\n+        blockMode = algoParts.length > 1 ? parseMode(algoParts[1]) : Mode.ECB;\n@@ -230,1 +221,1 @@\n-    private int parseMode(String mode) throws NoSuchAlgorithmException {\n+    private Mode parseMode(String mode) throws NoSuchAlgorithmException {\n@@ -232,12 +223,11 @@\n-        return switch (mode) {\n-            case \"ECB\" -> MODE_ECB;\n-            case \"CBC\" -> {\n-                if (blockSize == 0) {\n-                    throw new NoSuchAlgorithmException\n-                            (\"CBC mode not supported with stream ciphers\");\n-                }\n-                yield MODE_CBC;\n-            }\n-            case \"CTR\" -> MODE_CTR;\n-            default -> throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-        };\n+        Mode result;\n+        try {\n+            result = Mode.valueOf(mode);\n+        } catch (IllegalArgumentException ignored) {\n+            throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+        }\n+        if (blockSize == 0 && result != Mode.ECB) {\n+            throw new NoSuchAlgorithmException(\n+                    result + \" mode not supported with stream ciphers\");\n+        }\n+        return result;\n@@ -253,1 +243,10 @@\n-            paddingType = PAD_NONE;\n+            paddingType = Pad.NONE;\n+            if (blockMode == Mode.CTS) {\n+                \/\/ Buffer at least two blocks (where the last one may be\n+                \/\/ partial). When using NSS, buffer one more block to avoid\n+                \/\/ NSS Bug 1823875: \"AES CTS decryption does not update\n+                \/\/ its own context's IV on full blocks input\"\n+                \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1823875#c2\n+                int bufferedBlocks = P11Util.isNSS(token) ? 3 : 2;\n+                padBuffer = new byte[bufferedBlocks * blockSize];\n+            }\n@@ -255,3 +254,3 @@\n-            if (this.blockMode == MODE_CTR) {\n-                throw new NoSuchPaddingException\n-                    (\"PKCS#5 padding not supported with CTR mode\");\n+            if (blockMode == Mode.CTR || blockMode == Mode.CTS) {\n+                throw new NoSuchPaddingException(\"PKCS#5 padding not \" +\n+                        \"supported with \" + blockMode + \" mode\");\n@@ -259,1 +258,1 @@\n-            paddingType = PAD_PKCS5;\n+            paddingType = Pad.PKCS5;\n@@ -374,1 +373,1 @@\n-        if (blockMode == MODE_ECB) { \/\/ ECB or stream cipher\n+        if (blockMode == Mode.ECB) { \/\/ ECB or stream cipher\n@@ -384,1 +383,1 @@\n-        } else { \/\/ MODE_CBC or MODE_CTR\n+        } else { \/\/ Mode.CBC, Mode.CTR or Mode.CTS\n@@ -387,5 +386,3 @@\n-                    String exMsg =\n-                        (blockMode == MODE_CBC ?\n-                         \"IV must be specified for decryption in CBC mode\" :\n-                         \"IV must be specified for decryption in CTR mode\");\n-                    throw new InvalidAlgorithmParameterException(exMsg);\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"IV must be specified for decryption in \" +\n+                            blockMode + \" mode\");\n@@ -436,0 +433,3 @@\n+            if (padBuffer != null) {\n+                Arrays.fill(padBuffer, (byte) 0);\n+            }\n@@ -490,1 +490,1 @@\n-            CK_MECHANISM mechParams = (blockMode == MODE_CTR ?\n+            CK_MECHANISM mechParams = (blockMode == Mode.CTR ?\n@@ -515,1 +515,3 @@\n-        if (blockSize != 0 && blockMode != MODE_CTR) {\n+        if (blockMode == Mode.CTS) {\n+            result -= getCTSMustBeBuffered(result);\n+        } else if (blockSize != 0 && blockMode != Mode.CTR) {\n@@ -529,1 +531,1 @@\n-        if (blockSize != 0 && encrypt && paddingType != PAD_NONE) {\n+        if (blockSize != 0 && encrypt && paddingType != Pad.NONE) {\n@@ -607,1 +609,50 @@\n-            if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+            if (blockMode == Mode.CTS) {\n+                \/\/ decide how to split the total data (totalInLen) between\n+                \/\/ the token (dataForP11Update) and padBuffer\n+                \/\/ (newPadBufferLen)\n+                int totalInLen = padBufferLen + inLen;\n+                newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                int dataForP11Update = totalInLen - newPadBufferLen;\n+                if (dataForP11Update > 0 && padBufferLen > 0) {\n+                    \/\/ there is data for the token and part of it is in\n+                    \/\/ padBuffer\n+                    int flushFromPadBuffer;\n+                    int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                    if (dataForP11Update >= padBufferLen + fillLen) {\n+                        \/\/ flush the whole padBuffer\n+                        if (fillLen > 0) {\n+                            \/\/ complete the last padBuffer block from the\n+                            \/\/ input\n+                            bufferInputBytes(in, inOfs, fillLen);\n+                            inOfs += fillLen;\n+                            inLen -= fillLen;\n+                        }\n+                        flushFromPadBuffer = padBufferLen;\n+                    } else {\n+                        \/\/ There is not enough input data available to\n+                        \/\/ complete the padBuffer to a multiple of block\n+                        \/\/ size. Flush part of the padBuffer (up to a\n+                        \/\/ multiple of blockSize) now. Shift the remaining\n+                        \/\/ padBuffer data and buffer more up to completing\n+                        \/\/ newPadBufferLen later.\n+                        flushFromPadBuffer = dataForP11Update;\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    } else {\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    }\n+                    padBufferLen -= flushFromPadBuffer;\n+                    if (padBufferLen > 0) {\n+                        \/\/ shift remaining data to the padBuffer start\n+                        System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                padBuffer, 0, padBufferLen);\n+                    }\n+                }\n+                newPadBufferLen -= padBufferLen;\n+                inLen -= newPadBufferLen;\n+            } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -652,1 +703,2 @@\n-            if (paddingObj != null && newPadBufferLen > 0) {\n+            if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                    newPadBufferLen > 0) {\n@@ -718,1 +770,50 @@\n-                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                if (blockMode == Mode.CTS) {\n+                    \/\/ decide how to split the total data (totalInLen) between\n+                    \/\/ the token (dataForP11Update) and padBuffer\n+                    \/\/ (newPadBufferLen)\n+                    int totalInLen = padBufferLen + inLen;\n+                    newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                    int dataForP11Update = totalInLen - newPadBufferLen;\n+                    if (dataForP11Update > 0 && padBufferLen > 0) {\n+                        \/\/ there is data for the token and part of it is in\n+                        \/\/ padBuffer\n+                        int flushFromPadBuffer;\n+                        int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                        if (dataForP11Update >= padBufferLen + fillLen) {\n+                            \/\/ flush the whole padBuffer\n+                            if (fillLen > 0) {\n+                                \/\/ complete the last padBuffer block from the\n+                                \/\/ input\n+                                bufferInputBytes(inBuffer, fillLen);\n+                                inOfs += fillLen;\n+                                inLen -= fillLen;\n+                            }\n+                            flushFromPadBuffer = padBufferLen;\n+                        } else {\n+                            \/\/ There is not enough input data available to\n+                            \/\/ complete the padBuffer to a multiple of block\n+                            \/\/ size. Flush part of the padBuffer (up to a\n+                            \/\/ multiple of blockSize) now. Shift the remaining\n+                            \/\/ padBuffer data and buffer more up to completing\n+                            \/\/ newPadBufferLen later.\n+                            flushFromPadBuffer = dataForP11Update;\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        } else {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        }\n+                        padBufferLen -= flushFromPadBuffer;\n+                        if (padBufferLen > 0) {\n+                            \/\/ shift remaining data to the padBuffer start\n+                            System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                    padBuffer, 0, padBufferLen);\n+                        }\n+                    }\n+                    newPadBufferLen -= padBufferLen;\n+                    inLen -= newPadBufferLen;\n+                } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -771,1 +872,2 @@\n-                if (paddingObj != null && newPadBufferLen > 0) {\n+                if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                        newPadBufferLen > 0) {\n@@ -833,0 +935,4 @@\n+                } else if (blockMode == Mode.CTS) {\n+                    k = token.p11.C_EncryptUpdate(session.id(),\n+                            0, padBuffer, 0, padBufferLen,\n+                            0, out, outOfs, outLen);\n@@ -842,0 +948,3 @@\n+                if (blockMode == Mode.CTS) {\n+                    convertCTSVariant(null, out, outOfs + k);\n+                }\n@@ -866,0 +975,8 @@\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(null, padBuffer, padBufferLen);\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                0, out, outOfs, outLen);\n+                        outOfs += k;\n+                        outLen -= k;\n+                    }\n@@ -867,1 +984,1 @@\n-                    k = token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n+                    k += token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n@@ -931,0 +1048,4 @@\n+                    } else if (blockMode == Mode.CTS) {\n+                       k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                outAddr, outArray, outOfs, outLen);\n@@ -940,0 +1061,3 @@\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(outBuffer, outArray, outOfs + k);\n+                    }\n@@ -945,1 +1069,0 @@\n-\n@@ -967,0 +1090,8 @@\n+                        if (blockMode == Mode.CTS) {\n+                            convertCTSVariant(null, padBuffer, padBufferLen);\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    outAddr, outArray, outOfs, outLen);\n+                            outOfs += k;\n+                            outLen -= k;\n+                        }\n@@ -968,1 +1099,1 @@\n-                        k = token.p11.C_DecryptFinal(session.id(),\n+                        k += token.p11.C_DecryptFinal(session.id(),\n@@ -991,0 +1122,77 @@\n+    private int getBytesToCompleteBlock(int availableBytes) {\n+        int partBlock = availableBytes & (blockSize - 1);\n+        return partBlock == 0 ? 0 : blockSize - partBlock;\n+    }\n+\n+    private int getCTSMustBeBuffered(int availableBytes) {\n+        return Math.min(availableBytes,\n+                padBuffer.length - getBytesToCompleteBlock(availableBytes));\n+    }\n+\n+    \/**\n+     * The ciphertext ordering for the three variants can be depicted as\n+     * follows, where 'p' is the penultimate block (which may be partial\n+     * or full), and 'f' the full final block:\n+     *\n+     *                    'p' is a partial block   'p' is a full block\n+     *                   ------------------------ ---------------------\n+     *   CS1 (NIST)     |     .... pp ffff       |    .... pppp ffff\n+     *   CS2 (Schneier) |     .... ffff pp       |    .... pppp ffff\n+     *   CS3 (Kerberos) |     .... ffff pp       |    .... ffff pppp\n+     *\n+     * After encryption, we get the ciphertext from the token formatted as\n+     * specified in the SunPKCS11 'cipherTextStealingVariant' configuration\n+     * property. Conversely, before decryption, the ciphertext has to be passed\n+     * to the token according to the previous formatting. This method converts\n+     * the ciphertext between the format used by the token and the one used by\n+     * SunJCE's \"AES\/CTS\/NoPadding\" implementation (CS3 as described by RFC\n+     * 2040, section 8).\n+     *\/\n+    private void convertCTSVariant(ByteBuffer ciphertextBuf,\n+            byte[] ciphertextArr, int ciphertextEnd) {\n+        if (padBufferLen == blockSize) {\n+            \/\/ No reordering needed for a single block\n+            return;\n+        }\n+        assert token.ctsVariant != null : \"CTS algorithms should not be \" +\n+                \"registered if the CTS variant of the token is unknown\";\n+        if (token.ctsVariant == Token.CTSVariant.CS3) {\n+            \/\/ Already CS3\n+            return;\n+        }\n+        int pad = padBufferLen % blockSize;\n+        if (token.ctsVariant == Token.CTSVariant.CS2 && pad != 0) {\n+            \/\/ CS2 and 'p' is a partial block, equal to CS3\n+            return;\n+        }\n+        if (ciphertextArr != null) {\n+            ciphertextBuf = ByteBuffer.wrap(ciphertextArr);\n+        }\n+        if (ciphertextBuf != null) {\n+            \/\/ No assumptions should be made about the current ciphertextBuf\n+            \/\/ position. Additionally, if ciphertextBuf was not created here,\n+            \/\/ the position should not be altered. To ensure this, use offsets\n+            \/\/ to read and write bytes from the last two blocks (i.e. absolute\n+            \/\/ ByteBuffer operations). Other blocks should not be modified.\n+            pad = pad == 0 ? blockSize : pad;\n+            if (encrypt) {\n+                \/\/ .... pp[pp] ffff -> .... ffff pp[pp]\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, pad, blockSize);\n+            } else {\n+                \/\/ .... ffff pp[pp] -> .... pp[pp] ffff\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, blockSize, pad);\n+            }\n+        }\n+    }\n+\n+    private static void swapLastTwoBlocks(ByteBuffer ciphertextBuf,\n+            int ciphertextEnd, int prevBlockLen, int lastBlockLen) {\n+        \/\/ .... prevBlock lastBlock -> .... lastBlock prevBlock\n+        int prevBlockStart = ciphertextEnd - prevBlockLen - lastBlockLen;\n+        byte[] prevBlockBackup = new byte[prevBlockLen];\n+        ciphertextBuf.get(prevBlockStart, prevBlockBackup);\n+        ciphertextBuf.put(prevBlockStart, ciphertextBuf,\n+                ciphertextEnd - lastBlockLen, lastBlockLen);\n+        ciphertextBuf.put(ciphertextEnd - prevBlockLen, prevBlockBackup);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":263,"deletions":55,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -863,0 +863,9 @@\n+        d(CIP, \"AES\/CTS\/NoPadding\",             P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_128\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_192\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_256\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+\n@@ -1293,1 +1302,7 @@\n-\n+            if (longMech == CKM_AES_CTS && token.ctsVariant == null) {\n+                if (showInfo) {\n+                    System.out.println(\"DISABLED due to an unspecified \" +\n+                            \"cipherTextStealingVariant in configuration\");\n+                }\n+                continue;\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+    public enum CTSVariant {CS1, CS2, CS3}\n@@ -68,0 +69,2 @@\n+    final transient CTSVariant ctsVariant;\n+\n@@ -149,0 +152,1 @@\n+        ctsVariant = getCTSVariant();\n@@ -415,0 +419,13 @@\n+    private CTSVariant getCTSVariant() {\n+        CTSVariant ctsVariant = config.getCTSVariant();\n+        if (ctsVariant != null) {\n+            return ctsVariant;\n+        }\n+        \/\/ 'cipherTextStealingVariant' needs an explicit value for the\n+        \/\/ CKM_AES_CTS mechanism to be enabled. In the case of NSS we know\n+        \/\/ that this value is 'CS1', so we can set it for the user. See:\n+        \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=373108#c7\n+        \/\/ https:\/\/github.com\/nss-dev\/nss\/blob\/NSS_3_99_RTM\/lib\/freebl\/cts.c#L65\n+        return P11Util.isNSS(this) ? CTSVariant.CS1 : null;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-import sun.jvm.hotspot.gc.g1.HeapRegionClosure;\n-import sun.jvm.hotspot.gc.g1.PrintRegionClosure;\n+import sun.jvm.hotspot.gc.g1.G1HeapRegionClosure;\n+import sun.jvm.hotspot.gc.g1.G1PrintRegionClosure;\n@@ -50,1 +50,1 @@\n-    \/\/ HeapRegionManager _hrm;\n+    \/\/ G1HeapRegionManager _hrm;\n@@ -58,1 +58,1 @@\n-    \/\/ HeapRegionSet _old_set;\n+    \/\/ G1HeapRegionSet _old_set;\n@@ -60,1 +60,1 @@\n-    \/\/ HeapRegionSet _humongous_set;\n+    \/\/ G1HeapRegionSet _humongous_set;\n@@ -93,1 +93,1 @@\n-    public HeapRegionManager hrm() {\n+    public G1HeapRegionManager hrm() {\n@@ -95,1 +95,1 @@\n-        return VMObjectFactory.newObject(HeapRegionManager.class, hrmAddr);\n+        return VMObjectFactory.newObject(G1HeapRegionManager.class, hrmAddr);\n@@ -103,1 +103,1 @@\n-    public HeapRegionSetBase oldSet() {\n+    public G1HeapRegionSetBase oldSet() {\n@@ -105,1 +105,1 @@\n-        return VMObjectFactory.newObject(HeapRegionSetBase.class, oldSetAddr);\n+        return VMObjectFactory.newObject(G1HeapRegionSetBase.class, oldSetAddr);\n@@ -108,1 +108,1 @@\n-    public HeapRegionSetBase humongousSet() {\n+    public G1HeapRegionSetBase humongousSet() {\n@@ -110,1 +110,1 @@\n-        return VMObjectFactory.newObject(HeapRegionSetBase.class, humongousSetAddr);\n+        return VMObjectFactory.newObject(G1HeapRegionSetBase.class, humongousSetAddr);\n@@ -117,1 +117,1 @@\n-    public void heapRegionIterate(HeapRegionClosure hrcl) {\n+    public void heapRegionIterate(G1HeapRegionClosure hrcl) {\n@@ -162,1 +162,1 @@\n-        PrintRegionClosure prc = new PrintRegionClosure(tty);\n+        G1PrintRegionClosure prc = new G1PrintRegionClosure(tty);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1CollectedHeap.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private HeapRegionType type;\n+    private G1HeapRegionType type;\n@@ -91,1 +91,1 @@\n-        type = VMObjectFactory.newObject(HeapRegionType.class, typeAddr);\n+        type = VMObjectFactory.newObject(G1HeapRegionType.class, typeAddr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.g1;\n+\n+public interface G1HeapRegionClosure {\n+    public void doHeapRegion(G1HeapRegion hr);\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionClosure.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/ Mirror class for HeapRegionManager.\n+\/\/ Mirror class for G1HeapRegionManager.\n@@ -42,1 +42,1 @@\n-public class HeapRegionManager extends VMObject {\n+public class G1HeapRegionManager extends VMObject {\n@@ -55,1 +55,1 @@\n-        Type type = db.lookupType(\"HeapRegionManager\");\n+        Type type = db.lookupType(\"G1HeapRegionManager\");\n@@ -77,1 +77,1 @@\n-    public HeapRegionManager(Address addr) {\n+    public G1HeapRegionManager(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionManager.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionManager.java","status":"renamed"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/ Mirror class for HeapRegionSetBase. Represents a group of regions.\n+\/\/ Mirror class for G1HeapRegionSetBase. Represents a group of regions.\n@@ -42,1 +42,1 @@\n-public class HeapRegionSetBase extends VMObject {\n+public class G1HeapRegionSetBase extends VMObject {\n@@ -56,1 +56,1 @@\n-        Type type = db.lookupType(\"HeapRegionSetBase\");\n+        Type type = db.lookupType(\"G1HeapRegionSetBase\");\n@@ -65,1 +65,1 @@\n-    public HeapRegionSetBase(Address addr) {\n+    public G1HeapRegionSetBase(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionSetBase.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionSetBase.java","status":"renamed"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.g1;\n+\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+\/\/ Mirror class for G1HeapRegionType. Currently we don't actually include\n+\/\/ any of its fields but only iterate over it.\n+\n+public class G1HeapRegionType extends VMObject {\n+\n+    private static int freeTag;\n+    private static int youngMask;\n+    private static int edenTag;\n+    private static int survTag;\n+    private static int humongousMask;\n+    private static int startsHumongousTag;\n+    private static int continuesHumongousTag;\n+    private static int oldMask;\n+    private static CIntegerField tagField;\n+    private int tag;\n+\n+    static {\n+        VM.registerVMInitializedObserver(new Observer() {\n+                public void update(Observable o, Object data) {\n+                    initialize(VM.getVM().getTypeDataBase());\n+                }\n+        });\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"G1HeapRegionType\");\n+\n+        tagField = type.getCIntegerField(\"_tag\");\n+\n+        freeTag = db.lookupIntConstant(\"G1HeapRegionType::FreeTag\");\n+        youngMask = db.lookupIntConstant(\"G1HeapRegionType::YoungMask\");\n+        edenTag = db.lookupIntConstant(\"G1HeapRegionType::EdenTag\");\n+        survTag = db.lookupIntConstant(\"G1HeapRegionType::SurvTag\");\n+        startsHumongousTag = db.lookupIntConstant(\"G1HeapRegionType::StartsHumongousTag\");\n+        continuesHumongousTag = db.lookupIntConstant(\"G1HeapRegionType::ContinuesHumongousTag\");\n+        humongousMask = db.lookupIntConstant(\"G1HeapRegionType::HumongousMask\");\n+        oldMask = db.lookupIntConstant(\"G1HeapRegionType::OldMask\");\n+    }\n+\n+    public boolean isFree() {\n+        return tagField.getValue(addr) == freeTag;\n+    }\n+\n+    public boolean isEden() {\n+        return tagField.getValue(addr) == edenTag;\n+    }\n+\n+    public boolean isSurvivor() {\n+        return tagField.getValue(addr) == survTag;\n+    }\n+\n+    public boolean isYoung() {\n+        return (tagField.getValue(addr) & youngMask) != 0;\n+    }\n+\n+    public boolean isHumongous() {\n+        return (tagField.getValue(addr) & humongousMask) != 0;\n+    }\n+\n+    public boolean isStartsHumongous() {\n+        return tagField.getValue(addr) == startsHumongousTag;\n+    }\n+\n+    public boolean isContinuesHumongous() {\n+        return tagField.getValue(addr) == continuesHumongousTag;\n+    }\n+\n+    public boolean isOld() {\n+        return (tagField.getValue(addr) & oldMask) != 0;\n+    }\n+\n+    public G1HeapRegionType(Address addr) {\n+        super(addr);\n+    }\n+\n+    public String typeAnnotation() {\n+        if (isFree()) {\n+            return \"Free\";\n+        }\n+        if (isEden()) {\n+            return \"Eden\";\n+        }\n+        if (isSurvivor()) {\n+            return \"Survivor\";\n+        }\n+        if (isStartsHumongous()) {\n+            return \"StartsHumongous\";\n+        }\n+        if (isContinuesHumongous()) {\n+            return \"ContinuesHumongous\";\n+        }\n+        if (isOld()) {\n+            return \"Old\";\n+        }\n+        return \"Unknown Region Type\";\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionType.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-public class PrintRegionClosure implements HeapRegionClosure {\n+public class G1PrintRegionClosure implements G1HeapRegionClosure {\n@@ -33,1 +33,1 @@\n-    public PrintRegionClosure(PrintStream tty) {\n+    public G1PrintRegionClosure(PrintStream tty) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1PrintRegionClosure.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/PrintRegionClosure.java","status":"renamed"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.g1;\n-\n-public interface HeapRegionClosure {\n-    public void doHeapRegion(G1HeapRegion hr);\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionClosure.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.g1;\n-\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-import sun.jvm.hotspot.debugger.Address;\n-import sun.jvm.hotspot.runtime.VM;\n-import sun.jvm.hotspot.runtime.VMObject;\n-import sun.jvm.hotspot.types.CIntegerField;\n-import sun.jvm.hotspot.types.Type;\n-import sun.jvm.hotspot.types.TypeDataBase;\n-\n-\/\/ Mirror class for HeapRegionType. Currently we don't actually include\n-\/\/ any of its fields but only iterate over it.\n-\n-public class HeapRegionType extends VMObject {\n-\n-    private static int freeTag;\n-    private static int youngMask;\n-    private static int edenTag;\n-    private static int survTag;\n-    private static int humongousMask;\n-    private static int startsHumongousTag;\n-    private static int continuesHumongousTag;\n-    private static int oldMask;\n-    private static CIntegerField tagField;\n-    private int tag;\n-\n-    static {\n-        VM.registerVMInitializedObserver(new Observer() {\n-                public void update(Observable o, Object data) {\n-                    initialize(VM.getVM().getTypeDataBase());\n-                }\n-        });\n-    }\n-\n-    private static synchronized void initialize(TypeDataBase db) {\n-        Type type = db.lookupType(\"HeapRegionType\");\n-\n-        tagField = type.getCIntegerField(\"_tag\");\n-\n-        freeTag = db.lookupIntConstant(\"HeapRegionType::FreeTag\");\n-        youngMask = db.lookupIntConstant(\"HeapRegionType::YoungMask\");\n-        edenTag = db.lookupIntConstant(\"HeapRegionType::EdenTag\");\n-        survTag = db.lookupIntConstant(\"HeapRegionType::SurvTag\");\n-        startsHumongousTag = db.lookupIntConstant(\"HeapRegionType::StartsHumongousTag\");\n-        continuesHumongousTag = db.lookupIntConstant(\"HeapRegionType::ContinuesHumongousTag\");\n-        humongousMask = db.lookupIntConstant(\"HeapRegionType::HumongousMask\");\n-        oldMask = db.lookupIntConstant(\"HeapRegionType::OldMask\");\n-    }\n-\n-    public boolean isFree() {\n-        return tagField.getValue(addr) == freeTag;\n-    }\n-\n-    public boolean isEden() {\n-        return tagField.getValue(addr) == edenTag;\n-    }\n-\n-    public boolean isSurvivor() {\n-        return tagField.getValue(addr) == survTag;\n-    }\n-\n-    public boolean isYoung() {\n-        return (tagField.getValue(addr) & youngMask) != 0;\n-    }\n-\n-    public boolean isHumongous() {\n-        return (tagField.getValue(addr) & humongousMask) != 0;\n-    }\n-\n-    public boolean isStartsHumongous() {\n-        return tagField.getValue(addr) == startsHumongousTag;\n-    }\n-\n-    public boolean isContinuesHumongous() {\n-        return tagField.getValue(addr) == continuesHumongousTag;\n-    }\n-\n-    public boolean isOld() {\n-        return (tagField.getValue(addr) & oldMask) != 0;\n-    }\n-\n-    public HeapRegionType(Address addr) {\n-        super(addr);\n-    }\n-\n-    public String typeAnnotation() {\n-        if (isFree()) {\n-            return \"Free\";\n-        }\n-        if (isEden()) {\n-            return \"Eden\";\n-        }\n-        if (isSurvivor()) {\n-            return \"Survivor\";\n-        }\n-        if (isStartsHumongous()) {\n-            return \"StartsHumongous\";\n-        }\n-        if (isContinuesHumongous()) {\n-            return \"ContinuesHumongous\";\n-        }\n-        if (isOld()) {\n-            return \"Old\";\n-        }\n-        return \"Unknown Region Type\";\n-    }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionType.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-      if (getMethod().getName().asString().equals(\"wait\") &&\n+      if (getMethod().getName().asString().equals(\"wait0\") &&\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaVFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,2 +255,2 @@\n-      HeapRegionSetBase oldSet = g1h.oldSet();\n-      HeapRegionSetBase humongousSet = g1h.humongousSet();\n+      G1HeapRegionSetBase oldSet = g1h.oldSet();\n+      G1HeapRegionSetBase humongousSet = g1h.humongousSet();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        String path = System.getenv(\"PATH\");\n+        String path = \"\/usr\/bin\" + File.pathSeparator + \"\/bin\";\/\/was: System.getenv(\"PATH\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.jdeps;\n@@ -40,1 +41,2 @@\n-        jdk.jpackage;\n+        jdk.jpackage,\n+        jdk.jdeps;\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,3 +111,0 @@\n-    \/\/ This field is being kept around for compatibility with libgraal\n-    @SuppressWarnings(\"unused\") private long oopSizeOffset;\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJDKReflection.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -149,0 +149,2 @@\n+        } else if (intrinsicId == config.vmIntrinsicLinkToNative) {\n+            return IntrinsicMethod.LINK_TO_NATIVE;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodHandleAccessProvider.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+    final int vmIntrinsicLinkToNative = getConstant(\"vmIntrinsics::_linkToNative\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,3 @@\n-        LINK_TO_INTERFACE\n+        LINK_TO_INTERFACE,\n+        \/** The method {@code MethodHandle.linkToNative}. *\/\n+        LINK_TO_NATIVE\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/MethodHandleAccessProvider.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import sun.security.tools.PathList;\n@@ -42,1 +41,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -45,2 +43,0 @@\n-import java.net.URL;\n-import java.net.URLClassLoader;\n@@ -495,1 +491,1 @@\n-    private boolean extraAttrsDetected;\n+    private boolean externalFileAttributesDetected;\n@@ -939,3 +935,3 @@\n-        int extraAttrs = JUZFA.getExtraAttributes(ze);\n-        if (!extraAttrsDetected && extraAttrs != -1) {\n-            extraAttrsDetected = true;\n+        int externalFileAttributes = JUZFA.getExternalFileAttributes(ze);\n+        if (!externalFileAttributesDetected && externalFileAttributes != -1) {\n+            externalFileAttributesDetected = true;\n@@ -944,1 +940,1 @@\n-        JUZFA.setExtraAttributes(ze2, extraAttrs);\n+        JUZFA.setExternalFileAttributes(ze2, externalFileAttributes);\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-    private static boolean extraAttrsDetected;\n+    private static boolean externalFileAttributesDetected;\n@@ -826,2 +826,2 @@\n-                    if (!extraAttrsDetected && JUZFA.getExtraAttributes(je) != -1) {\n-                        extraAttrsDetected = true;\n+                    if (!externalFileAttributesDetected && JUZFA.getExternalFileAttributes(je) != -1) {\n+                        externalFileAttributesDetected = true;\n@@ -1314,2 +1314,2 @@\n-        if (extraAttrsDetected) {\n-            warnings.add(rb.getString(\"extra.attributes.detected\"));\n+        if (externalFileAttributesDetected) {\n+            warnings.add(rb.getString(\"external.file.attributes.detected\"));\n@@ -1949,1 +1949,1 @@\n-                    (t, o) -> extraAttrsDetected = true);\n+                    (t, o) -> externalFileAttributesDetected = true);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"POSIX file permission and\/or symlink attributes detected. These attributes are ignored when signing and are not protected by the signature.\"},\n+        {\"external.file.attributes.detected\", \"POSIX file permission and\/or symlink attributes detected. These attributes are ignored when signing and are not protected by the signature.\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"POSIX-Dateiberechtigung und\/oder Symlink-Attribute erkannt. Diese Attribute werden bei der Signatur ignoriert und sind nicht durch die Signatur gesch\\u00FCtzt.\"},\n+        {\"external.file.attributes.detected\", \"POSIX-Dateiberechtigung und\/oder Symlink-Attribute erkannt. Diese Attribute werden bei der Signatur ignoriert und sind nicht durch die Signatur gesch\\u00FCtzt.\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_de.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"POSIX\\u30D5\\u30A1\\u30A4\\u30EB\\u6A29\\u9650\\u307E\\u305F\\u306Fsymlink(\\u3042\\u308B\\u3044\\u306F\\u305D\\u306E\\u4E21\\u65B9)\\u306E\\u5C5E\\u6027\\u304C\\u691C\\u51FA\\u3055\\u308C\\u307E\\u3057\\u305F\\u3002\\u7F72\\u540D\\u4E2D\\u306F\\u3053\\u308C\\u3089\\u306E\\u5C5E\\u6027\\u306F\\u7121\\u8996\\u3055\\u308C\\u3001\\u7F72\\u540D\\u306B\\u3088\\u3063\\u3066\\u4FDD\\u8B77\\u3055\\u308C\\u307E\\u305B\\u3093\\u3002\"},\n+        {\"external.file.attributes.detected\", \"POSIX\\u30D5\\u30A1\\u30A4\\u30EB\\u6A29\\u9650\\u307E\\u305F\\u306Fsymlink(\\u3042\\u308B\\u3044\\u306F\\u305D\\u306E\\u4E21\\u65B9)\\u306E\\u5C5E\\u6027\\u304C\\u691C\\u51FA\\u3055\\u308C\\u307E\\u3057\\u305F\\u3002\\u7F72\\u540D\\u4E2D\\u306F\\u3053\\u308C\\u3089\\u306E\\u5C5E\\u6027\\u306F\\u7121\\u8996\\u3055\\u308C\\u3001\\u7F72\\u540D\\u306B\\u3088\\u3063\\u3066\\u4FDD\\u8B77\\u3055\\u308C\\u307E\\u305B\\u3093\\u3002\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_ja.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"\\u68C0\\u6D4B\\u5230 POSIX \\u6587\\u4EF6\\u6743\\u9650\\u548C\/\\u6216 symlink \\u5C5E\\u6027\\u3002\\u8FD9\\u4E9B\\u5C5E\\u6027\\u5728\\u8FDB\\u884C\\u7B7E\\u540D\\u65F6\\u4F1A\\u88AB\\u5FFD\\u7565\\uFF0C\\u4E0D\\u53D7\\u8BE5\\u7B7E\\u540D\\u7684\\u4FDD\\u62A4\\u3002\"},\n+        {\"external.file.attributes.detected\", \"\\u68C0\\u6D4B\\u5230 POSIX \\u6587\\u4EF6\\u6743\\u9650\\u548C\/\\u6216 symlink \\u5C5E\\u6027\\u3002\\u8FD9\\u4E9B\\u5C5E\\u6027\\u5728\\u8FDB\\u884C\\u7B7E\\u540D\\u65F6\\u4F1A\\u88AB\\u5FFD\\u7565\\uFF0C\\u4E0D\\u53D7\\u8BE5\\u7B7E\\u540D\\u7684\\u4FDD\\u62A4\\u3002\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_zh_CN.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-\\f[V]path-to-gc-root\\f[R]: (Optional) Flag for saving the path to\n+\\f[V]path-to-gc-roots\\f[R]: (Optional) Flag for saving the path to\n@@ -609,1 +609,1 @@\n-\\f[V]path-to-gc-root\\f[R]: (Optional) Flag for saving the path to\n+\\f[V]path-to-gc-roots\\f[R]: (Optional) Flag for saving the path to\n@@ -684,0 +684,49 @@\n+\\f[V]JFR.view\\f[R] [\\f[I]options\\f[R]]\n+Display event data in predefined views.\n+.RS\n+.PP\n+Impact: Medium\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The \\f[I]options\\f[R] must be specified using either \\f[I]key\\f[R] or\n+\\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+If no parameters are entered, then a list of available views are\n+displayed.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]cell-height\\f[R]: (Optional) Maximum number of rows in a table\n+cell.\n+(INT, default value depends on the view)\n+.IP \\[bu] 2\n+\\f[V]maxage\\f[R]: (Optional) Length of time for the view to span.\n+(INT followed by \\[aq]s\\[aq] for seconds \\[aq]m\\[aq] for minutes or\n+\\[aq]h\\[aq] for hours, default value is 10m)\n+.IP \\[bu] 2\n+\\f[V]maxsize\\f[R]: (Optional) Maximum size for the view to span in bytes\n+if one of the following suffixes is not used: \\[aq]m\\[aq] or \\[aq]M\\[aq]\n+for megabytes OR \\[aq]g\\[aq] or \\[aq]G\\[aq] for gigabytes.\n+(STRING, default value is 32MB)\n+.IP \\[bu] 2\n+\\f[V]truncate\\f[R]: (Optional) Maximum number of rows in a table cell.\n+(INT, default value depends on the view)\n+.IP \\[bu] 2\n+\\f[V]verbose\\f[R]: (Optional) Displays the query that makes up the view.\n+(BOOLEAN, default value is false)\n+.IP \\[bu] 2\n+\\f[V]width\\f[R]: (Optional) The width of the view in characters.\n+(INT, default value depends on the view)\n+.PP\n+\\f[I]arguments\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]view\\f[R]: Name of the view or event type to display.\n+Use \\f[V]help JFR.view\\f[R] to see a list of available views.\n+(STRING, no default value)\n+.PP\n+The view parameter can be an event type name.\n+Use \\f[V]JFR.view types\\f[R] to see a list.\n+To display all views, use \\f[V]JFR.view all-views\\f[R].\n+To display all events, use \\f[V]JFR.view all-events\\f[R].\n+.RE\n+.TP\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -870,1 +870,1 @@\n-                if (className.indexOf('.') > 0) {\n+                if (className.indexOf('.') > 0 || className.indexOf('\/') > 0) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -417,1 +417,1 @@\n-            JavaFileManager fm = pp.getPlatform(release, \"\").getFileManager();\n+            JavaFileManager fm = pp.getPlatformTrusted(release).getFileManager();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.JarFile;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipFile;\n+\n+sealed interface ClassFileSource {\n+    String moduleName();\n+    Path path();\n+\n+    Stream<byte[]> classFiles(Runtime.Version version) throws IOException;\n+\n+    record Module(ModuleReference reference) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return reference.descriptor().name();\n+        }\n+\n+        @Override\n+        public Path path() {\n+            URI location = reference.location().orElseThrow();\n+            return Path.of(location);\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            ModuleReader reader = reference().open();\n+            return reader.list()\n+                .filter(resourceName -> resourceName.endsWith(\".class\"))\n+                .map(resourceName -> {\n+                    try (InputStream stream = reader.open(resourceName).orElseThrow()) {\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).onClose(() -> {\n+                    try {\n+                        reader.close();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+\n+    record ClassPathJar(Path path) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return \"ALL-UNNAMED\";\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            JarFile jf = new JarFile(path().toFile(), false, ZipFile.OPEN_READ, version);\n+            return jf.versionedStream()\n+                .filter(je -> je.getName().endsWith(\".class\"))\n+                .map(je -> {\n+                    try (InputStream stream = jf.getInputStream(je)){\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).onClose(() -> {\n+                    try {\n+                        jf.close();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+\n+    record ClassPathDirectory(Path path) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return \"ALL-UNNAMED\";\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            return Files.walk(path)\n+                .filter(file -> Files.isRegularFile(file) && file.toString().endsWith(\".class\"))\n+                .map(file -> {\n+                    try (InputStream stream = Files.newInputStream(file)){\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassFileSource.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.javac.platform.PlatformDescription;\n+import com.sun.tools.javac.platform.PlatformProvider;\n+\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardLocation;\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Stream;\n+\n+abstract class ClassResolver implements AutoCloseable {\n+\n+    static ClassResolver forClassFileSources(List<ClassFileSource> sources, Runtime.Version version) throws IOException {\n+        Map<ClassDesc, Info> classMap = new HashMap<>();\n+        for (ClassFileSource source : sources) {\n+            try (Stream<byte[]> classFiles = source.classFiles(version)) {\n+                classFiles.forEach(bytes -> {\n+                    ClassModel model = ClassFile.of().parse(bytes);\n+                    ClassDesc desc = model.thisClass().asSymbol();\n+                    classMap.put(desc, new Info(source, model));\n+                });\n+            }\n+        }\n+        return new SimpleClassResolver(classMap);\n+    }\n+\n+    static ClassResolver forSystemModules(Runtime.Version version) {\n+        String platformName = String.valueOf(version.feature());\n+        PlatformProvider platformProvider = ServiceLoader.load(PlatformProvider.class).findFirst().orElseThrow();\n+        PlatformDescription platform;\n+        try {\n+            platform = platformProvider.getPlatform(platformName, null);\n+        } catch (PlatformProvider.PlatformNotSupported e) {\n+            throw new JNativeScanFatalError(\"Release: \" + platformName + \" not supported\", e);\n+        }\n+        JavaFileManager fm = platform.getFileManager();\n+        return new SystemModuleClassResolver(fm);\n+    }\n+\n+    record Info(ClassFileSource source, ClassModel model) {}\n+\n+    public abstract void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action);\n+    public abstract Optional<ClassResolver.Info> lookup(ClassDesc desc);\n+\n+    @Override\n+    public abstract void close() throws IOException;\n+\n+    private static class SimpleClassResolver extends ClassResolver {\n+\n+        private final Map<ClassDesc, ClassResolver.Info> classMap;\n+\n+        public SimpleClassResolver(Map<ClassDesc, Info> classMap) {\n+            this.classMap = classMap;\n+        }\n+\n+        public void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action) {\n+            classMap.forEach(action);\n+        }\n+\n+        public Optional<ClassResolver.Info> lookup(ClassDesc desc) {\n+            return Optional.ofNullable(classMap.get(desc));\n+        }\n+\n+        @Override\n+        public void close() {}\n+    }\n+\n+    private static class SystemModuleClassResolver extends ClassResolver {\n+\n+        private final JavaFileManager platformFileManager;\n+        private final Map<String, String> packageToSystemModule;\n+        private final Map<ClassDesc, Info> cache = new HashMap<>();\n+\n+        public SystemModuleClassResolver(JavaFileManager platformFileManager) {\n+            this.platformFileManager = platformFileManager;\n+            this.packageToSystemModule = packageToSystemModule(platformFileManager);\n+        }\n+\n+        private static Map<String, String> packageToSystemModule(JavaFileManager platformFileManager) {\n+            try {\n+                Set<JavaFileManager.Location> locations = platformFileManager.listLocationsForModules(\n+                        StandardLocation.SYSTEM_MODULES).iterator().next();\n+\n+                Map<String, String> result = new HashMap<>();\n+                for (JavaFileManager.Location loc : locations) {\n+                    JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, \"module-info\", JavaFileObject.Kind.CLASS);\n+                    ModuleDescriptor descriptor = ModuleDescriptor.read(jfo.openInputStream());\n+                    for (ModuleDescriptor.Exports export : descriptor.exports()) {\n+                        if (!export.isQualified()) {\n+                            result.put(export.source(), descriptor.name());\n+                        }\n+                    }\n+                }\n+                return result;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void forEach(BiConsumer<ClassDesc, Info> action) {\n+            throw new UnsupportedOperationException(\"NYI\");\n+        }\n+\n+        @Override\n+        public Optional<Info> lookup(ClassDesc desc) {\n+            return Optional.ofNullable(cache.computeIfAbsent(desc, _ -> {\n+                String qualName = JNativeScanTask.qualName(desc);\n+                String moduleName = packageToSystemModule.get(desc.packageName());\n+                if (moduleName != null) {\n+                    try {\n+                        JavaFileManager.Location loc = platformFileManager.getLocationForModule(StandardLocation.SYSTEM_MODULES, moduleName);\n+                        JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, qualName, JavaFileObject.Kind.CLASS);\n+                        if (jfo == null) {\n+                            throw new JNativeScanFatalError(\"System class can not be found: \" + qualName);\n+                        }\n+                        ClassModel model = ClassFile.of().parse(jfo.openInputStream().readAllBytes());\n+                        return new Info(null, model);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                return null;\n+            }));\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            platformFileManager.close();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassResolver.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.Serial;\n+\n+\/\/ Exception used in case of fatal error that is reasonably expected and handled.\n+public class JNativeScanFatalError extends RuntimeException {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    public JNativeScanFatalError(String message) {\n+        super(message);\n+    }\n+\n+    public JNativeScanFatalError(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public JNativeScanFatalError(Throwable cause) {\n+        super(cause);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanFatalError.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ResolvedModule;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+class JNativeScanTask {\n+\n+    private final PrintWriter out;\n+    private final List<Path> classPaths;\n+    private final List<Path> modulePaths;\n+    private final List<String> cmdRootModules;\n+    private final Runtime.Version version;\n+    private final Action action;\n+\n+    public JNativeScanTask(PrintWriter out, List<Path> classPaths, List<Path> modulePaths,\n+                           List<String> cmdRootModules, Runtime.Version version, Action action) {\n+        this.out = out;\n+        this.classPaths = classPaths;\n+        this.modulePaths = modulePaths;\n+        this.version = version;\n+        this.action = action;\n+        this.cmdRootModules = cmdRootModules;\n+    }\n+\n+    public void run() throws JNativeScanFatalError {\n+        List<ClassFileSource> toScan = new ArrayList<>(findAllClassPathJars());\n+\n+        ModuleFinder moduleFinder = ModuleFinder.of(modulePaths.toArray(Path[]::new));\n+        List<String> rootModules = cmdRootModules;\n+        if (rootModules.contains(\"ALL-MODULE-PATH\")) {\n+            rootModules = allModuleNames(moduleFinder);\n+        }\n+        Configuration config = systemConfiguration().resolveAndBind(ModuleFinder.of(), moduleFinder, rootModules);\n+        for (ResolvedModule m : config.modules()) {\n+            toScan.add(new ClassFileSource.Module(m.reference()));\n+        }\n+\n+        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods;\n+        try(ClassResolver classesToScan = ClassResolver.forClassFileSources(toScan, version);\n+            ClassResolver systemClassResolver = ClassResolver.forSystemModules(version)) {\n+            NativeMethodFinder finder = NativeMethodFinder.create(classesToScan, systemClassResolver);\n+            allRestrictedMethods = finder.findAll();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        switch (action) {\n+            case PRINT -> printNativeAccess(allRestrictedMethods);\n+            case DUMP_ALL -> dumpAll(allRestrictedMethods);\n+        }\n+    }\n+\n+    private List<ClassFileSource> findAllClassPathJars() throws JNativeScanFatalError {\n+        List<ClassFileSource> result = new ArrayList<>();\n+        for (Path path : classPaths) {\n+            if (isJarFile(path)) {\n+                Deque<Path> jarsToScan  = new ArrayDeque<>();\n+                jarsToScan.offer(path);\n+\n+                \/\/ recursively look for all class path jars, starting at the root jars\n+                \/\/ in this.classPaths, and recursively following all Class-Path manifest\n+                \/\/ attributes\n+                while (!jarsToScan.isEmpty()) {\n+                    Path jar = jarsToScan.poll();\n+                    String[] classPathAttribute = classPathAttribute(jar);\n+                    Path parentDir = jar.getParent();\n+                    for (String classPathEntry : classPathAttribute) {\n+                        Path otherJar = parentDir != null\n+                                ? parentDir.resolve(classPathEntry)\n+                                : Path.of(classPathEntry);\n+                        if (Files.exists(otherJar)) {\n+                            \/\/ Class-Path attribute specifies that jars that\n+                            \/\/ are not found are simply ignored. Do the same here\n+                            jarsToScan.offer(otherJar);\n+                        }\n+                    }\n+                    result.add(new ClassFileSource.ClassPathJar(jar));\n+                }\n+            } else if (Files.isDirectory(path)) {\n+                result.add(new ClassFileSource.ClassPathDirectory(path));\n+            } else {\n+                throw new JNativeScanFatalError(\n+                    \"Path does not appear to be a jar file, or directory containing classes: \" + path);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private String[] classPathAttribute(Path jar) {\n+        try (JarFile jf = new JarFile(jar.toFile(), false, ZipFile.OPEN_READ, version)) {\n+           Manifest manifest = jf.getManifest();\n+           if (manifest != null) {\n+               String attrib = manifest.getMainAttributes().getValue(\"Class-Path\");\n+               if (attrib != null) {\n+                   return attrib.split(\"\\\\s+\");\n+               }\n+           }\n+           return new String[0];\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private Configuration systemConfiguration() {\n+        ModuleFinder systemFinder = ModuleFinder.ofSystem();\n+        Configuration system = Configuration.resolve(systemFinder, List.of(Configuration.empty()), ModuleFinder.of(),\n+                allModuleNames(systemFinder)); \/\/ resolve all of them\n+        return system;\n+    }\n+\n+    private List<String> allModuleNames(ModuleFinder finder) {\n+        return finder.findAll().stream().map(mr -> mr.descriptor().name()).toList();\n+    }\n+\n+    private void printNativeAccess(SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+        String nativeAccess = allRestrictedMethods.keySet().stream()\n+                .map(ClassFileSource::moduleName)\n+                .distinct()\n+                .collect(Collectors.joining(\",\"));\n+        out.println(nativeAccess);\n+    }\n+\n+    private void dumpAll(SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+        if (allRestrictedMethods.isEmpty()) {\n+            out.println(\"  <no restricted methods>\");\n+        } else {\n+            allRestrictedMethods.forEach((module, perClass) -> {\n+                out.println(module.path() + \" (\" + module.moduleName() + \"):\");\n+                perClass.forEach((classDesc, restrictedUses) -> {\n+                    out.println(\"  \" + qualName(classDesc) + \":\");\n+                    restrictedUses.forEach(use -> {\n+                        switch (use) {\n+                            case RestrictedUse.NativeMethodDecl(MethodRef nmd) ->\n+                                out.println(\"    \" + nmd + \" is a native method declaration\");\n+                            case RestrictedUse.RestrictedMethodRefs(MethodRef referent, Set<MethodRef> referees) -> {\n+                                out.println(\"    \" + referent + \" references restricted methods:\");\n+                                referees.forEach(referee -> out.println(\"      \" + referee));\n+                            }\n+                        }\n+                    });\n+                });\n+            });\n+        }\n+    }\n+\n+    private static boolean isJarFile(Path path) throws JNativeScanFatalError {\n+        return Files.exists(path) && Files.isRegularFile(path) && path.toString().endsWith(\".jar\");\n+    }\n+\n+    public enum Action {\n+        DUMP_ALL,\n+        PRINT\n+    }\n+\n+    public static String qualName(ClassDesc desc) {\n+        String packagePrefix = desc.packageName().isEmpty() ? \"\" : desc.packageName() + \".\";\n+        return packagePrefix + desc.displayName();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanTask.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import jdk.internal.joptsimple.*;\n+import jdk.internal.opt.CommandLine;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.spi.ToolProvider;\n+\n+public class Main {\n+\n+    private static boolean DEBUG = Boolean.getBoolean(\"com.sun.tools.jnativescan.DEBUG\");\n+\n+    private static final int SUCCESS_CODE = 0;\n+    private static final int FATAL_ERROR_CODE = 1;\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    private Main(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    private void printError(String message) {\n+        err.println(\"ERROR: \" + message);\n+    }\n+\n+    private void printUsage()  {\n+        out.print(\"\"\"\n+            Use 'jnativescan --help' for help\n+            \"\"\");\n+    }\n+\n+    private void printVersion() {\n+        out.println(System.getProperty(\"java.version\"));\n+    }\n+\n+    public int run(String[] args) {\n+        if (args.length < 1) {\n+            printUsage();\n+            return FATAL_ERROR_CODE;\n+        }\n+\n+        try {\n+            String[] expandedArgs = expandArgFiles(args);\n+            parseOptionsAndRun(expandedArgs);\n+        } catch (JNativeScanFatalError fatalError) {\n+            printError(fatalError.getMessage());\n+            for (Throwable cause = fatalError.getCause();\n+                     cause instanceof JNativeScanFatalError jNativeScanFatalError;\n+                     cause = jNativeScanFatalError.getCause()) {\n+                err.println(\"CAUSED BY: \" + jNativeScanFatalError.getMessage());\n+            }\n+            if (DEBUG) {\n+                fatalError.printStackTrace(err);\n+            }\n+            return FATAL_ERROR_CODE;\n+        } catch (Throwable e) {\n+            printError(\"Unexpected exception encountered\");\n+            e.printStackTrace(err);\n+            return FATAL_ERROR_CODE;\n+        }\n+\n+        return SUCCESS_CODE;\n+    }\n+\n+    private void parseOptionsAndRun(String[] expandedArgs) throws JNativeScanFatalError {\n+        OptionParser parser = new OptionParser(false);\n+        OptionSpec<Void> helpOpt = parser.acceptsAll(List.of(\"?\", \"h\", \"help\"), \"help\").forHelp();\n+        OptionSpec<Void> versionOpt = parser.accepts(\"version\", \"Print version information and exit\");\n+        OptionSpec<Path> classPathOpt = parser.accepts(\n+                \"class-path\",\n+                \"The class path as used at runtime\")\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(File.pathSeparatorChar)\n+                .withValuesConvertedBy(PARSE_PATH);\n+        OptionSpec<Path> modulePathOpt = parser.accepts(\n+                \"module-path\",\n+                \"The module path as used at runtime\")\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(File.pathSeparatorChar)\n+                .withValuesConvertedBy(PARSE_PATH);\n+        OptionSpec<Runtime.Version> releaseOpt = parser.accepts(\n+                \"release\",\n+                \"The runtime version that will run the application\")\n+                .withRequiredArg()\n+                .withValuesConvertedBy(PARSE_VERSION);\n+        OptionSpec<String> addModulesOpt = parser.accepts(\n+                \"add-modules\",\n+                \"List of root modules to scan\")\n+                .requiredIf(modulePathOpt)\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(',');\n+        OptionSpec<Void> printNativeAccessOpt = parser.accepts(\n+                \"print-native-access\",\n+                \"print a comma separated list of modules that may perform native access operations.\" +\n+                        \" ALL-UNNAMED is used to indicate unnamed modules.\");\n+\n+        OptionSet optionSet;\n+        try {\n+            optionSet = parser.parse(expandedArgs);\n+        } catch (OptionException oe) {\n+            throw new JNativeScanFatalError(\"Parsing options failed: \" + oe.getMessage(), oe);\n+        }\n+\n+        if (optionSet.nonOptionArguments().size() != 0) {\n+            throw new JNativeScanFatalError(\"jnativescan does not accept positional arguments\");\n+        }\n+\n+        if (optionSet.has(helpOpt)) {\n+            out.println(\"\"\"\n+                The jnativescan tool can be used to find methods that may access native functionality when\n+                run. This includes restricted method calls and 'native' method declarations.\n+                \"\"\");\n+            try {\n+                parser.printHelpOn(out);\n+                return;\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        if (optionSet.has(versionOpt)) {\n+            printVersion();\n+            return;\n+        }\n+\n+        List<Path> classPathJars = optionSet.valuesOf(classPathOpt);\n+        List<Path> modulePaths = optionSet.valuesOf(modulePathOpt);\n+        List<String> rootModules = optionSet.valuesOf(addModulesOpt);\n+        Runtime.Version version = Optional.ofNullable(optionSet.valueOf(releaseOpt)).orElse(Runtime.version());\n+\n+        JNativeScanTask.Action action = JNativeScanTask.Action.DUMP_ALL;\n+        if (optionSet.has(printNativeAccessOpt)) {\n+            action = JNativeScanTask.Action.PRINT;\n+        }\n+\n+        new JNativeScanTask(out, classPathJars, modulePaths, rootModules, version, action).run();\n+    }\n+\n+    private static String[] expandArgFiles(String[] args) throws JNativeScanFatalError {\n+        try {\n+            return CommandLine.parse(args);\n+        } catch (IOException e) { \/\/ file not found\n+            throw new JNativeScanFatalError(e.getMessage(), e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.exit(new Main.Provider().run(System.out, System.err, args));\n+    }\n+\n+    public static class Provider implements ToolProvider {\n+\n+        @Override\n+        public String name() {\n+            return \"jnativescan\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            return new Main(out, err).run(args);\n+        }\n+    }\n+\n+    \/\/ where\n+    private static final ValueConverter<Path> PARSE_PATH = new ValueConverter<>() {\n+        @Override\n+        public Path convert(String value) {\n+            return Path.of(value);\n+        }\n+\n+        @Override\n+        public Class<? extends Path> valueType() {\n+            return Path.class;\n+        }\n+\n+        @Override\n+        public String valuePattern() {\n+            return \"Path\";\n+        }\n+    };\n+\n+    private static final ValueConverter<Runtime.Version> PARSE_VERSION = new ValueConverter<>() {\n+        @Override\n+        public Runtime.Version convert(String value) {\n+            try {\n+                return Runtime.Version.parse(value);\n+            } catch (IllegalArgumentException e) {\n+                throw new JNativeScanFatalError(\"Invalid release: \" + value + \": \" + e.getMessage());\n+            }\n+        }\n+\n+        @Override\n+        public Class<? extends Runtime.Version> valueType() {\n+            return Runtime.Version.class;\n+        }\n+\n+        @Override\n+        public String valuePattern() {\n+            return \"Version\";\n+        }\n+    };\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/Main.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+record MethodRef(ClassDesc owner, String name, MethodTypeDesc type) {\n+    public static MethodRef ofModel(MethodModel model) {\n+        return new MethodRef(model.parent().orElseThrow().thisClass().asSymbol(),\n+                model.methodName().stringValue(), model.methodTypeSymbol());\n+    }\n+\n+    public static MethodRef ofInvokeInstruction(InvokeInstruction instruction) {\n+        return new MethodRef(instruction.owner().asSymbol(),\n+                instruction.name().stringValue(), instruction.typeSymbol());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return JNativeScanTask.qualName(owner) + \"::\" + name + type.displayDescriptor();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/MethodRef.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.jnativescan.RestrictedUse.NativeMethodDecl;\n+import com.sun.tools.jnativescan.RestrictedUse.RestrictedMethodRefs;\n+\n+import java.io.IOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.*;\n+\n+class NativeMethodFinder {\n+\n+    \/\/ ct.sym uses this fake name for the restricted annotation instead\n+    \/\/ see make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java\n+    private static final String RESTRICTED_NAME = \"Ljdk\/internal\/javac\/Restricted+Annotation;\";\n+\n+    private final Map<MethodRef, Boolean> cache = new HashMap<>();\n+    private final ClassResolver classesToScan;\n+    private final ClassResolver systemClassResolver;\n+\n+    private NativeMethodFinder(ClassResolver classesToScan, ClassResolver systemClassResolver) {\n+        this.classesToScan = classesToScan;\n+        this.systemClassResolver = systemClassResolver;\n+    }\n+\n+    public static NativeMethodFinder create(ClassResolver classesToScan, ClassResolver systemClassResolver) throws JNativeScanFatalError, IOException {\n+        return new NativeMethodFinder(classesToScan, systemClassResolver);\n+    }\n+\n+    public SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n+        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> restrictedMethods\n+                = new TreeMap<>(Comparator.comparing(ClassFileSource::path));\n+        classesToScan.forEach((_, info) -> {\n+            ClassModel classModel = info.model();\n+            List<RestrictedUse> perClass = new ArrayList<>();\n+            classModel.methods().forEach(methodModel -> {\n+                if (methodModel.flags().has(AccessFlag.NATIVE)) {\n+                    perClass.add(new NativeMethodDecl(MethodRef.ofModel(methodModel)));\n+                } else {\n+                    SortedSet<MethodRef> perMethod = new TreeSet<>(Comparator.comparing(MethodRef::toString));\n+                    methodModel.code().ifPresent(code -> {\n+                         try {\n+                             code.forEach(e -> {\n+                                 switch (e) {\n+                                     case InvokeInstruction invoke -> {\n+                                         MethodRef ref = MethodRef.ofInvokeInstruction(invoke);\n+                                         if (isRestrictedMethod(ref)) {\n+                                             perMethod.add(ref);\n+                                         }\n+                                     }\n+                                     default -> {\n+                                     }\n+                                 }\n+                             });\n+                         } catch (JNativeScanFatalError e) {\n+                             throw new JNativeScanFatalError(\"Error while processing method: \" +\n+                                     MethodRef.ofModel(methodModel), e);\n+                         }\n+                    });\n+                    if (!perMethod.isEmpty()) {\n+                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel), perMethod));\n+                    }\n+                }\n+            });\n+            if (!perClass.isEmpty()) {\n+                restrictedMethods.computeIfAbsent(info.source(),\n+                                _ -> new TreeMap<>(Comparator.comparing(JNativeScanTask::qualName)))\n+                        .put(classModel.thisClass().asSymbol(), perClass);\n+            }\n+        });\n+        return restrictedMethods;\n+    }\n+\n+    private boolean isRestrictedMethod(MethodRef ref) throws JNativeScanFatalError {\n+        return cache.computeIfAbsent(ref, methodRef -> {\n+            if (methodRef.owner().isArray()) {\n+                \/\/ no restricted methods in arrays atm, and we can't look them up since they have no class file\n+                return false;\n+            }\n+            Optional<ClassResolver.Info> info = systemClassResolver.lookup(methodRef.owner());\n+            if (!info.isPresent()) {\n+                return false;\n+            }\n+            ClassModel classModel = info.get().model();\n+            Optional<MethodModel> methodModel = findMethod(classModel, methodRef.name(), methodRef.type());\n+            if (!methodModel.isPresent()) {\n+                \/\/ If we are here, the method was referenced through a subclass of the class containing the actual\n+                \/\/ method declaration. We could implement a method resolver (that needs to be version aware\n+                \/\/ as well) to find the method model of the declaration, but it's not really worth it.\n+                \/\/ None of the restricted methods (atm) are exposed through more than 1 public type, so it's not\n+                \/\/ possible for user code to reference them through a subclass.\n+                return false;\n+            }\n+\n+            return hasRestrictedAnnotation(methodModel.get());\n+        });\n+    }\n+\n+    private static boolean hasRestrictedAnnotation(MethodModel method) {\n+        return method.findAttribute(Attributes.runtimeVisibleAnnotations())\n+                .map(rva -> rva.annotations().stream().anyMatch(ann ->\n+                        ann.className().stringValue().equals(RESTRICTED_NAME)))\n+                .orElse(false);\n+    }\n+\n+    private static Optional<MethodModel> findMethod(ClassModel classModel, String name, MethodTypeDesc type) {\n+        return classModel.methods().stream()\n+                .filter(m -> m.methodName().stringValue().equals(name)\n+                        && m.methodType().stringValue().equals(type.descriptorString()))\n+                .findFirst();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/NativeMethodFinder.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.util.SortedSet;\n+\n+sealed interface RestrictedUse {\n+    record RestrictedMethodRefs(MethodRef referent, SortedSet<MethodRef> referees) implements RestrictedUse {}\n+    record NativeMethodDecl(MethodRef decl) implements RestrictedUse {}\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/RestrictedUse.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,3 @@\n- * <em>{@index javap javap tool}<\/em>, and\n- * <em>{@index jdeprscan jdeprscan tool}<\/em> tools.\n+ * <em>{@index javap javap tool}<\/em>,\n+ * <em>{@index jdeprscan jdeprscan tool}<\/em>, and\n+ * <em>{@index jnativescan jnativescan tool}<\/em> tools.\n@@ -36,1 +37,1 @@\n- * <em>javap<\/em> and <em>jdeps<\/em> tools via the\n+ * <em>javap<\/em>, <em>jdeps<\/em>, and <em>jnativescan<\/em> tools via the\n@@ -52,0 +53,1 @@\n+ * @toolGuide jnativescan\n@@ -54,2 +56,3 @@\n- *     Use {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"javap\")}\n- *     or {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jdeps\")}\n+ *     Use {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"javap\")},\n+ *     {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jdeps\")},\n+ *     or {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jnativescan\")}\n@@ -57,1 +60,1 @@\n- *     of command-line access to the {@code javap} or {@code jdeps} tool.\n+ *     of command-line access to the {@code javap}, {@code jdeps}, {@code jnativescan} tool.\n@@ -66,0 +69,3 @@\n+    requires jdk.internal.opt;\n+\n+    uses com.sun.tools.javac.platform.PlatformProvider;\n@@ -71,1 +77,2 @@\n-        com.sun.tools.jdeps.Main.JDepsToolProvider;\n+        com.sun.tools.jdeps.Main.JDepsToolProvider,\n+        com.sun.tools.jnativescan.Main.Provider;\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+.\\\" Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+.\\\"\n+.\\\" This code is free software; you can redistribute it and\/or modify it\n+.\\\" under the terms of the GNU General Public License version 2 only, as\n+.\\\" published by the Free Software Foundation.\n+.\\\"\n+.\\\" This code is distributed in the hope that it will be useful, but WITHOUT\n+.\\\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+.\\\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+.\\\" version 2 for more details (a copy is included in the LICENSE file that\n+.\\\" accompanied this code).\n+.\\\"\n+.\\\" You should have received a copy of the GNU General Public License version\n+.\\\" 2 along with this work; if not, write to the Free Software Foundation,\n+.\\\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+.\\\"\n+.\\\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+.\\\" or visit www.oracle.com if you need additional information or have any\n+.\\\" questions.\n+.\\\"\n+.\\\" Automatically generated by Pandoc 2.19.2\n+.\\\"\n+.\\\" Define V font for inline verbatim, using C font in formats\n+.\\\" that render this, and otherwise B font.\n+.ie \"\\f[CB]x\\f[R]\"x\" \\{\\\n+. ftr V B\n+. ftr VI BI\n+. ftr VB B\n+. ftr VBI BI\n+.\\}\n+.el \\{\\\n+. ftr V CR\n+. ftr VI CI\n+. ftr VB CB\n+. ftr VBI CBI\n+.\\}\n+.TH \"JNATIVESCAN\" \"1\" \"2025\" \"JDK 24-ea\" \"JDK Commands\"\n+.hy\n+.SH NAME\n+.PP\n+jnativescan - static analysis tool that scans one or more jar files for\n+uses of native functionalities, such as restricted method calls or\n+\\f[V]native\\f[R] method declarations.\n+.SH SYNOPSIS\n+.PP\n+\\f[V]jnativescan\\f[R] [\\f[I]options\\f[R]]\n+.TP\n+\\f[I]options\\f[R]\n+See \\f[B]Options for the jnativescan Command\\f[R]\n+.SH DESCRIPTION\n+.PP\n+The \\f[V]jnative\\f[R] tool is a static analysis tool provided by the JDK\n+that scans a JAR file for uses of native functionalities, such as\n+restricted method calls or \\f[V]native\\f[R] method declarations.\n+.PP\n+\\f[V]jnativescan\\f[R] accepts a runtime class path and module path\n+configuration, as well as a set of root modules, and a target release.\n+It scans the jars on the class and module paths, and reports uses of\n+native functionalities either in a tree like structure, which also\n+identifies that calling classes and methods, or as a list of module\n+names when the \\f[V]--print-native-access\\f[R] flag is specified.\n+.SH OPTIONS FOR THE JNATIVESCAN COMMAND\n+.PP\n+The following options are available:\n+.TP\n+\\f[V]--class-path\\f[R] \\f[I]path\\f[R]\n+Used to specify a list of paths pointing to jar files to be scanned.\n+.PP\n+All jar files specified through this list will be scanned.\n+If a jar file contains a \\f[V]Class-Path\\f[R] attribute in its manifest,\n+jar files listed there will be scanned as well.\n+Jar files listed in the \\f[V]Class-Path\\f[R] manifest attribute that can\n+not be found are ignored.\n+All the jar files found are treated as if they belonged to the unnamed\n+module.\n+.TP\n+\\f[V]--module-path\\f[R] \\f[I]path\\f[R]\n+Used to specify a list of paths pointing to jar files or directories\n+containing jar files, that the tool can use to find modules that need to\n+be scanned.\n+The list of jar files that will be scanned depends on the\n+\\f[V]--add-modules\\f[R] option.\n+.RS\n+.PP\n+For both the \\f[V]--class-path\\f[R] and \\f[V]--module-path\\f[R] options,\n+\\f[I]path\\f[R] should be a search path that consists of one or more jar\n+files, separated by the system-specific path separator.\n+For example:\n+.IP \\[bu] 2\n+\\f[B]Linux and macOS:\\f[R]\n+.RS 2\n+.RS\n+.PP\n+\\f[V]--class-path \/some\/foo.jar:\/another\/different\/bar.jar\\f[R]\n+.RE\n+.RE\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+On Windows, use a semicolon (\\f[V];\\f[R]) as the separator instead of a\n+colon (\\f[V]:\\f[R]).\n+.IP \\[bu] 2\n+\\f[B]Windows:\\f[R]\n+.RS 2\n+.RS\n+.PP\n+\\f[V]--class-path C:\\[rs]some\\[rs]foo.jar;C:\\[rs]another\\[rs]different\\[rs]bar.jar\\f[R]\n+.RE\n+.RE\n+.RE\n+.TP\n+\\f[V]--add-modules\\f[R] \\f[I]module[,module...]\\f[R]\n+Used to specify a comma-separated list of module names that indicate the\n+root modules to scan.\n+All the root modules will be scanned, as well as any modules that they\n+depend on.\n+This includes dependencies on service implementations specified through\n+the \\f[V]uses\\f[R] directive in a module\\[aq]s \\f[V]module-info\\f[R]\n+file.\n+All modules found on the module path that provide an implementation of\n+such a service will be scanned as well.\n+.TP\n+\\f[V]--release\\f[R] \\f[I]version\\f[R]\n+Used to specify the Java SE release that specifies the set of restricted\n+methods to scan for.\n+For multi-release jar files, this option also indicates the version of\n+class file that should be loaded from the jar.\n+This option should be set to the version of the runtime under which the\n+application is eventually intended to be run.\n+If this flag is omitted, the version of \\f[V]jnativescan\\f[R] is used as\n+release version, which is the same as the version of the JDK that the\n+tool belongs to.\n+.TP\n+\\f[V]--print-native-access\\f[R]\n+Print a comma-separated list of module names that use native\n+functionalities, instead of the default tree structure.\n+.TP\n+\\f[V]--help\\f[R] or \\f[V]-h\\f[R]\n+Prints out a full help message.\n+.TP\n+\\f[V]--version\\f[R]\n+Prints out the abbreviated version string of the tool.\n+.SH EXAMPLE OF \\f[V]jnativescan\\f[R] USE\n+.PP\n+\\f[V]jnativescan\\f[R] accepts a runtime configuration in the form of a\n+class path, module path, set of root modules, and a target release\n+version.\n+For the class path, the tool will scan all jar files, including those\n+found recursively through the \\f[V]Class-Path\\f[R] manifest attribute.\n+For the module path, the tool scans all root modules specified through\n+\\f[V]--add-modules\\f[R], and any (transitive) dependence of the root\n+modules, including any modules that contain service implementations that\n+are used by a scanned module.\n+.PP\n+By default, the tool prints out which jars, classes, and methods use\n+native functionalities, in a tree-like structure.\n+The following is an example output:\n+.IP\n+.nf\n+\\f[CB]\n+$ jnativescan --class-path app.jar\n+app.jar (ALL-UNNAMED):\n+  foo.Main:\n+    foo.Main::main(String[])void references restricted methods:\n+      java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\n+    foo.Main::nativeMethod()void is a native method declaration\n+\\f[R]\n+.fi\n+.PP\n+\\f[V]app.jar (ALL-UNNAMED)\\f[R] is the path to the jar file, with the\n+module name in parentheses behind it.\n+Since in this case the jar file appears on the class path,\n+\\f[V]ALL-UNNAMED\\f[R] is printed to indicate the unnamed module.\n+The second line of the output, \\f[V]foo.Main\\f[R], indicates that\n+methods using native functionalities were found in the\n+\\f[V]foo.Main\\f[R] class.\n+The next line:\n+.IP\n+.nf\n+\\f[CB]\n+    foo.Main::main(String[])void references restricted methods:\n+\\f[R]\n+.fi\n+.PP\n+Indicates that the \\f[V]main(String[])\\f[R] method in the\n+\\f[V]foo.Main\\f[R] class references a restricted method, which is listed\n+on the following line as:\n+.IP\n+.nf\n+\\f[CB]\n+      java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\n+\\f[R]\n+.fi\n+.PP\n+Lastly, the text:\n+.IP\n+.nf\n+\\f[CB]\n+    foo.Main::nativeMethod()void is a native method declaration\n+\\f[R]\n+.fi\n+.PP\n+Indicates that the \\f[V]foo.Main\\f[R] class contains a declaration of a\n+\\f[V]native\\f[R] method named \\f[V]nativeMethod\\f[R].\n+.PP\n+If we add \\f[V]--print-native-access\\f[R] to the example command line,\n+we instead get a list of the names of modules that contain accesses to\n+native functionalities:\n+.IP\n+.nf\n+\\f[CB]\n+$ jnativescan --class-path app.jar --print-native-access\n+ALL-UNNAMED\n+\\f[R]\n+.fi\n+.PP\n+In this case the output consists of just \\f[V]ALL-UNNAMED\\f[R], which\n+indicates a jar file on the class path, that is, in the unnamed module,\n+contains an access to native functionalities.\n","filename":"src\/jdk.jdeps\/share\/man\/jnativescan.1","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        return getTyped(\"modifiers\", Integer.class, -1);\n+        return getTyped(\"modifiers\", Integer.class, INTEGER_MINUS_ONE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        return getTyped(\"bytecodeIndex\", Integer.class, Integer.valueOf(-1));\n+        return getTyped(\"bytecodeIndex\", Integer.class, INTEGER_MINUS_ONE);\n@@ -78,1 +78,1 @@\n-        return getTyped(\"lineNumber\", Integer.class, Integer.valueOf(-1));\n+        return getTyped(\"lineNumber\", Integer.class, INTEGER_MINUS_ONE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedFrame.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-        return getTyped(\"modifiers\", Integer.class, Integer.valueOf(0));\n+        return getTyped(\"modifiers\", Integer.class, INTEGER_ZERO);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,3 @@\n+    static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n+    static final Integer INTEGER_ZERO = Integer.valueOf(0);\n+    static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        Long l = getTyped(\"osThreadId\", Long.class, -1L);\n+        Long l = getTyped(\"osThreadId\", Long.class, LONG_MINUS_ONE);\n@@ -95,1 +95,1 @@\n-        Long l = getTyped(\"javaThreadId\", Long.class, -1L);\n+        Long l = getTyped(\"javaThreadId\", Long.class, LONG_MINUS_ONE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedThread.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-public abstract class AbstractBufferStatisticsEvent extends AbstractPeriodicEvent {\n+abstract class AbstractBufferStatisticsEvent extends AbstractPeriodicEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/AbstractBufferStatisticsEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.jfr.StackTrace;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ActiveRecordingEvent.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.jfr.StackTrace;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ActiveSettingEvent.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.jfr.StackTrace;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ExceptionStatisticsEvent.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.jfr.internal.JVM;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-                    catchAllHandler.if_null(rethrow);\n+                    catchAllHandler.ifnull(rethrow);\n@@ -489,1 +489,1 @@\n-                codeBuilder.if_null(fail);\n+                codeBuilder.ifnull(fail);\n@@ -528,1 +528,1 @@\n-                    codeBuilder.if_null(fail);\n+                    codeBuilder.ifnull(fail);\n@@ -741,1 +741,1 @@\n-                codeBuilder.if_null(nullLabel);\n+                codeBuilder.ifnull(nullLabel);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal;\n-\n-\/**\n- * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n- * from being generated when Object.wait() is called on an object of this type.\n- *\/\n-public final class HiddenWait {\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/HiddenWait.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -106,1 +107,0 @@\n-        \/\/ JVM::getChunkStartNanos() may return a bumped timestamp, +1 ns or +2 ns.\n@@ -122,1 +122,2 @@\n-            Utils.takeNap(1);\n+            HiddenWait hiddenWait = new HiddenWait();\n+            hiddenWait.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-import jdk.jfr.StackTrace;\n-import jdk.jfr.Threshold;\n@@ -52,0 +50,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -62,0 +61,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -346,1 +346,1 @@\n-            Utils.takeNap(1);\n+            threadSleeper.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/OldObjectSample.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.time.Period;\n-import java.time.Duration;\n@@ -35,1 +33,0 @@\n-import java.util.Optional;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -35,1 +34,0 @@\n-import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -47,0 +48,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -198,1 +200,3 @@\n-            takeNap();\n+            if (!threadSleeper.takeNap(10)) {\n+                throw new IOException(\"Read operation interrupted\");\n+            }\n@@ -203,8 +207,0 @@\n-    private void takeNap() throws IOException {\n-        try {\n-            Thread.sleep(10);\n-        } catch (InterruptedException ie) {\n-            throw new IOException(\"Read operation interrupted\", ie);\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -70,0 +72,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -456,1 +459,1 @@\n-        Utils.takeNap(1);\n+        threadSleeper.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RecordingInput.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.jfr.internal.management.HiddenWait;;\n@@ -51,1 +52,1 @@\n-    private static final Object WAIT_OBJECT = new Object();\n+    private static final HiddenWait WAIT_OBJECT = new HiddenWait();\n@@ -62,1 +63,1 @@\n-    private final Object waitObject;\n+    private final HiddenWait waitObject;\n@@ -70,1 +71,1 @@\n-        this.waitObject = repository == null ? WAIT_OBJECT : new Object();\n+        this.waitObject = repository == null ? WAIT_OBJECT : new HiddenWait();\n@@ -111,1 +112,1 @@\n-                nap();\n+                waitObject.takeNap(1000);\n@@ -160,10 +161,0 @@\n-    private void nap() {\n-        try {\n-            synchronized (waitObject) {\n-                waitObject.wait(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            \/\/ ignore\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.ArrayList;\n@@ -40,2 +39,0 @@\n-import jdk.jfr.internal.query.QueryPrinter;\n-import jdk.jfr.internal.query.ViewPrinter;\n@@ -44,2 +41,0 @@\n-import jdk.jfr.internal.util.UserSyntaxException;\n-import jdk.jfr.internal.util.Output;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/QueryRecording.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,1 +296,1 @@\n-        if (e instanceof JFCModelException m) {\n+        if (e instanceof JFCModelException) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/JFC.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        if (getParent() instanceof XmlEvent event) {\n+        if (getParent() instanceof XmlEvent) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/model\/XmlSetting.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+\/**\n+ * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n+ * from being generated when Object.wait() is called on an object of this type.\n+ *\/\n+public final class HiddenWait {\n+\n+    public synchronized boolean takeNap(long timeoutMillis) {\n+        try {\n+            this.wait(timeoutMillis);\n+            return true;\n+        } catch (InterruptedException e) {\n+            \/\/ Ok, ignore\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/HiddenWait.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n-\n+    private final HiddenWait lock = new HiddenWait();\n@@ -48,6 +48,8 @@\n-    public synchronized void check() {\n-        while (activated) {\n-            try {\n-                this.wait();\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n+    public void check() {\n+        synchronized (lock) {\n+            while (activated) {\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n@@ -58,2 +60,4 @@\n-    public synchronized void setStreamEnd(long timestamp) {\n-        end = timestamp;\n+    public void setStreamEnd(long timestamp) {\n+        synchronized(lock) {\n+            end = timestamp;\n+        }\n@@ -62,2 +66,4 @@\n-    public synchronized long getStreamEnd() {\n-        return end;\n+    public long getStreamEnd() {\n+        synchronized(lock) {\n+            return end;\n+        }\n@@ -66,3 +72,5 @@\n-    public synchronized void activate() {\n-        activated = true;\n-        used = true;\n+    public void activate() {\n+        synchronized (lock) {\n+            activated = true;\n+            used = true;\n+        }\n@@ -73,2 +81,4 @@\n-        activated = false;\n-        this.notifyAll();\n+        synchronized (lock) {\n+            activated = false;\n+            lock.notifyAll();\n+        }\n@@ -80,2 +90,4 @@\n-    public synchronized boolean used() {\n-        return used;\n+    public boolean used() {\n+        synchronized (lock) {\n+            return used;\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":30,"deletions":18,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-        return Arrays.asList(values).toString();\n+        return Arrays.toString(values);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Row.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n@@ -30,1 +28,0 @@\n-import java.util.List;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/TableSorter.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-public class LevelSetting extends JDKSettingControl {\n+public final class LevelSetting extends JDKSettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/LevelSetting.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,3 +226,3 @@\n-                FileOutputStream fos = new FileOutputStream(splittedFile);\n-                fos.write(bytes);\n-                fos.close();\n+                try (var fos = new FileOutputStream(splittedFile)) {\n+                    fos.write(bytes);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Disassemble.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.ArrayList;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.jfr.internal.util.Columnizer;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/View.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import jdk.jfr.internal.HiddenWait;\n@@ -58,0 +57,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -63,1 +63,1 @@\n-    private static final Object flushObject = new Object();\n+    private static final HiddenWait flushObject = new HiddenWait();\n@@ -354,11 +354,0 @@\n-    public static void takeNap(long millis) {\n-        HiddenWait hiddenWait = new HiddenWait();\n-        try {\n-            synchronized(hiddenWait) {\n-                hiddenWait.wait(millis);\n-            }\n-        } catch (InterruptedException e) {\n-            \/\/ ok\n-        }\n-    }\n-\n@@ -372,7 +361,1 @@\n-        synchronized (flushObject) {\n-            try {\n-                flushObject.wait(timeOut);\n-            } catch (InterruptedException e) {\n-                \/\/ OK\n-            }\n-        }\n+        flushObject.takeNap(timeOut);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-public class ValueParser {\n+public final class ValueParser {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                        byte[] content = ClassFile.of().transform(clm, ClassTransform\n+                        byte[] content = ClassFile.of().transformClass(clm, ClassTransform\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        return ClassFile.of().transform(newClassReader(path, classFile),\n+        return ClassFile.of().transformClass(newClassReader(path, classFile),\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/VersionPropsPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,6 @@\n-            terminal = TerminalBuilder.builder().inputStreamWrapper(in -> {\n+            \/\/on platforms which are known to be fully supported by\n+            \/\/the FFMTerminalProvider, do not permit the ExecTerminalProvider:\n+            boolean allowExecTerminal = !OSUtils.IS_WINDOWS &&\n+                                        !OSUtils.IS_LINUX &&\n+                                        !OSUtils.IS_OSX;\n+            terminal = TerminalBuilder.builder().exec(allowExecTerminal).inputStreamWrapper(in -> {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        return cc.transform(cc.parse(classFile),\n+        return cc.transformClass(cc.parse(classFile),\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -39,0 +40,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -67,1 +69,1 @@\n-                    takeNap();\n+                    threadSleeper.takeNap(1000);\n@@ -76,8 +78,0 @@\n-\n-    private void takeNap() {\n-        try {\n-            Thread.sleep(1000);\n-        } catch (InterruptedException ie) {\n-            \/\/ ignore\n-        }\n-    }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DownLoadThread.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -37,0 +38,1 @@\n+    private final HiddenWait lock = new HiddenWait();\n@@ -45,9 +47,11 @@\n-    public synchronized void add(DiskChunk dc) {\n-        if (isComplete()) {\n-            return;\n-        }\n-        dc.acquire();\n-        chunks.addFirst(dc);\n-        long endMillis = dc.endTimeNanos \/ 1_000_000;\n-        if (endMillis >= stopTimeMillis) {\n-            setComplete();\n+    public void add(DiskChunk dc) {\n+        synchronized (lock) {\n+            if (isComplete()) {\n+                return;\n+            }\n+            dc.acquire();\n+            chunks.addFirst(dc);\n+            long endMillis = dc.endTimeNanos \/ 1_000_000;\n+            if (endMillis >= stopTimeMillis) {\n+                setComplete();\n+            }\n@@ -57,2 +61,4 @@\n-    public synchronized boolean isComplete() {\n-        return complete;\n+    public boolean isComplete() {\n+        synchronized (lock) {\n+            return complete;\n+        }\n@@ -61,3 +67,5 @@\n-    public synchronized void setComplete() {\n-        complete = true;\n-        this.notifyAll();\n+    public void setComplete() {\n+        synchronized (lock) {\n+            complete = true;\n+            lock.notifyAll();\n+        }\n@@ -66,3 +74,7 @@\n-    public synchronized void close() {\n-        for (DiskChunk dc : chunks) {\n-            dc.release();\n+    public void close() {\n+        synchronized (lock) {\n+            for (DiskChunk dc : chunks) {\n+                dc.release();\n+            }\n+            chunks.clear();\n+            complete = true;\n@@ -70,2 +82,0 @@\n-        chunks.clear();\n-        complete = true;\n@@ -76,1 +86,1 @@\n-            synchronized (this) {\n+            synchronized (lock) {\n@@ -83,1 +93,1 @@\n-                this.wait();\n+                lock.wait();\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FileDump.java","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -648,3 +648,3 @@\n-                e.posixPerms = -1;\n-            } else if (e.posixPerms == -1) {\n-                e.posixPerms = ZipUtils.permsToFlags(perms);\n+                e.externalFileAttributes = -1;\n+            } else if (e.externalFileAttributes == -1) {\n+                e.externalFileAttributes = ZipUtils.permsToFlags(perms);\n@@ -652,2 +652,2 @@\n-                e.posixPerms = ZipUtils.permsToFlags(perms) |\n-                        (e.posixPerms & 0xFE00); \/\/ Preserve unrelated bits\n+                e.externalFileAttributes = ZipUtils.permsToFlags(perms) |\n+                        (e.externalFileAttributes & 0xFE00); \/\/ Preserve unrelated bits\n@@ -2890,1 +2890,1 @@\n-        int    posixPerms = -1; \/\/ posix permissions\n+        int    externalFileAttributes = -1; \/\/ file type, setuid, setgid, sticky, posix permissions\n@@ -2926,1 +2926,1 @@\n-                    posixPerms = ZipUtils.permsToFlags((Set<PosixFilePermission>)attr.value());\n+                    externalFileAttributes = ZipUtils.permsToFlags((Set<PosixFilePermission>)attr.value());\n@@ -2961,1 +2961,1 @@\n-            this.posixPerms = e.posixPerms;\n+            this.externalFileAttributes = e.externalFileAttributes;\n@@ -2991,1 +2991,1 @@\n-            return (posixPerms < 0) ? version :\n+            return (externalFileAttributes < 0) ? version :\n@@ -3018,1 +3018,1 @@\n-                posixPerms = (CENATX_PERMS(cen, pos) & 0xFFFF); \/\/ 16 bits for file type, setuid, setgid, sticky + perms\n+                externalFileAttributes = (CENATX_PERMS(cen, pos) & 0xFFFF); \/\/ 16 bits for file type, setuid, setgid, sticky + perms\n@@ -3108,1 +3108,1 @@\n-            writeInt(os, posixPerms > 0 ? posixPerms << 16 : 0); \/\/ external file\n+            writeInt(os, externalFileAttributes > 0 ? externalFileAttributes << 16 : 0); \/\/ external file\n@@ -3531,1 +3531,1 @@\n-            if (posixPerms != -1) {\n+            if (externalFileAttributes != -1) {\n@@ -3534,1 +3534,1 @@\n-                    if ((posixPerms & ZipUtils.permToFlag(perm)) != 0) {\n+                    if ((externalFileAttributes & ZipUtils.permToFlag(perm)) != 0) {\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-TEST_OTHER_VM(FreeRegionList, length) {\n+TEST_OTHER_VM(G1FreeRegionList, length) {\n@@ -42,1 +42,1 @@\n-  FreeRegionList l(\"test\");\n+  G1FreeRegionList l(\"test\");\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,2 +239,2 @@\n-  uint const min = (uint)log2i(HeapRegionBounds::min_size());\n-  uint const max = (uint)log2i(HeapRegionBounds::max_size());\n+  uint const min = (uint)log2i(G1HeapRegionBounds::min_size());\n+  uint const max = (uint)log2i(G1HeapRegionBounds::max_size());\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    HeapRegionRange current = map->next_active_range(current_offset);\n+    G1HeapRegionRange current = map->next_active_range(current_offset);\n@@ -82,1 +82,1 @@\n-    HeapRegionRange current = map->next_inactive_range(current_offset);\n+    G1HeapRegionRange current = map->next_inactive_range(current_offset);\n@@ -97,1 +97,1 @@\n-    HeapRegionRange current = map->next_committable_range(current_offset);\n+    G1HeapRegionRange current = map->next_committable_range(current_offset);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1RegionMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/metaspace\/metaspaceArena.hpp\"\n-#include \"memory\/metaspace\/metaspaceSettings.hpp\"\n-#include \"memory\/metaspace\/testHelpers.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-\/\/#define LOG_PLEASE\n-#include \"metaspaceGtestCommon.hpp\"\n-#include \"metaspaceGtestContexts.hpp\"\n-\n-#ifdef ASSERT\n-\n-using metaspace::MetaspaceArena;\n-using metaspace::MetaspaceTestArena;\n-using metaspace::Settings;\n-\n-\/\/ Test that overwriting memory triggers an assert if allocation guards are enabled.\n-\/\/  Note: We use TEST_VM_ASSERT_MSG. However, an assert is only triggered if allocation\n-\/\/  guards are enabled; if guards are disabled for the gtests, this test would fail.\n-\/\/  So for that case, we trigger a fake assert.\n-TEST_VM_ASSERT_MSG(metaspace, test_overwriter, \".*Metaspace corruption.*\") {\n-\n-  if (Settings::use_allocation_guard()) {\n-    MetaspaceGtestContext context;\n-    MetaspaceTestArena* arena = context.create_arena(Metaspace::StandardMetaspaceType);\n-    \/\/ We allocate two blocks. We then write over the end of the first block, which\n-    \/\/  should corrupt the fence between the two blocks.\n-    \/\/ Note: there is of course no guarantee that blocks allocated sequentially are neighbors;\n-    \/\/  but in this case (clean standard-sized test arena and very small allocations) it can\n-    \/\/  be safely assumed).\n-    MetaWord* p1 = arena->allocate(8);\n-    MetaWord* p2 = arena->allocate(2);\n-    p1[8] = (MetaWord)0x9345; \/\/ Overwriter\n-    \/\/ Now we delete the arena (as happens during class unloading); this will check all\n-    \/\/ block canaries and should trigger an assert (see MetaspaceArena::verify_allocation_guards()).\n-    delete arena;\n-  } else {\n-    assert(false, \"Metaspace corruption - please ignore this, fake message to satisfy tests\");\n-  }\n-\n-}\n-\n-#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/metaspace\/test_allocationGuard.cpp","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -294,5 +294,0 @@\n-\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n@@ -340,5 +335,0 @@\n-\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n@@ -375,5 +365,0 @@\n-\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n@@ -402,3 +387,0 @@\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n@@ -508,4 +490,0 @@\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-    \/\/ - if +MetaspaceGuardAllocations, guard costs\n@@ -116,2 +115,1 @@\n-    const size_t max_word_overhead_per_alloc =\n-        4 + (metaspace::Settings::use_allocation_guard() ? 4 : 0);\n+    constexpr size_t max_word_overhead_per_alloc = 4;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+  bool is_read_only() override {\n+    return true; \/\/ doesn't matter\n+  }\n@@ -439,1 +442,2 @@\n-                                                       (char*)testCases[i]->mount_path);\n+                                                       (char*)testCases[i]->mount_path,\n+                                                       true \/* read-only mount *\/);\n@@ -463,1 +467,2 @@\n-                                                       (char*)testCases[i]->cgroup_path);\n+                                                       (char*)testCases[i]->cgroup_path,\n+                                                       true \/* read-only mount *\/);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -170,2 +170,6 @@\n-static void do_test_print_hex_dump(address addr, size_t len, int unitsize, const char* expected) {\n-  char buf[256];\n+#ifndef AIX\n+\/\/ Test relies on the ability to protect memory allocated with os::reserve_memory. AIX may not be able\n+\/\/ to do that (mprotect won't work on System V shm).\n+static void do_test_print_hex_dump(const_address from, const_address to, int unitsize, int bytes_per_line,\n+                                   const_address logical_start, const char* expected) {\n+  char buf[2048];\n@@ -174,4 +178,2 @@\n-  os::print_hex_dump(&ss, addr, addr + len, unitsize);\n-  \/\/ tty->print_cr(\"expected: %s\", expected);\n-  \/\/ tty->print_cr(\"result: %s\", buf);\n-  EXPECT_THAT(buf, HasSubstr(expected));\n+  os::print_hex_dump(&ss, from, to, unitsize, \/* print_ascii=*\/true, bytes_per_line, logical_start);\n+  EXPECT_STREQ(buf, expected);\n@@ -181,6 +183,5 @@\n-  const char* pattern [4] = {\n-#ifdef VM_LITTLE_ENDIAN\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0100 0302 0504 0706 0908 0b0a 0d0c 0f0e\",\n-    \"03020100 07060504 0b0a0908 0f0e0d0c\",\n-    \"0706050403020100 0f0e0d0c0b0a0908\"\n+\n+#ifdef _LP64\n+#define ADDRESS1 \"0x0000aaaaaaaaaa00\"\n+#define ADDRESS2 \"0x0000aaaaaaaaaa20\"\n+#define ADDRESS3 \"0x0000aaaaaaaaaa40\"\n@@ -188,4 +189,3 @@\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0001 0203 0405 0607 0809 0a0b 0c0d 0e0f\",\n-    \"00010203 04050607 08090a0b 0c0d0e0f\",\n-    \"0001020304050607 08090a0b0c0d0e0f\"\n+#define ADDRESS1 \"0xaaaaaa00\"\n+#define ADDRESS2 \"0xaaaaaa20\"\n+#define ADDRESS3 \"0xaaaaaa40\"\n@@ -193,1 +193,0 @@\n-  };\n@@ -195,6 +194,6 @@\n-  const char* pattern_not_readable [4] = {\n-    \"?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\",\n-    \"???? ???? ???? ???? ???? ???? ???? ????\",\n-    \"???????? ???????? ???????? ????????\",\n-    \"???????????????? ????????????????\"\n-  };\n+#define ASCII_1  \"....#.jdk\/internal\/loader\/Native\"\n+#define ASCII_2  \"Libraries.......\"\n+\n+#define PAT_1 ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n@@ -202,4 +201,12 @@\n-  \/\/ On AIX, zero page is readable.\n-  address unreadable =\n-#ifdef AIX\n-    (address) 0xFFFFFFFFFFFF0000ULL;\n+#ifdef VM_LITTLE_ENDIAN\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff dce0 0023 646a 2f6b 6e69 6574 6e72 6c61 6c2f 616f 6564 2f72 614e 6974 6576   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   694c 7262 7261 6569 0073 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   dce0ffff 646a0023 6e692f6b 6e726574 6c2f6c61 6564616f 614e2f72 65766974   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   7262694c 65697261 00000073 00000000                                       \" ASCII_2 \"\\n\"\n+\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   646a0023dce0ffff 6e7265746e692f6b 6564616f6c2f6c61 65766974614e2f72   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   656972617262694c 0000000000000073                                     \" ASCII_2 \"\\n\"\n@@ -207,3 +214,3 @@\n-    (address) 0\n-#endif\n-    ;\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff e0dc 2300 6a64 6b2f 696e 7465 726e 616c 2f6c 6f61 6465 722f 4e61 7469 7665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69 6272 6172 6965 7300 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n@@ -211,14 +218,7 @@\n-  ResourceMark rm;\n-  char buf[64];\n-  stringStream ss(buf, sizeof(buf));\n-  outputStream* out = &ss;\n-\/\/  outputStream* out = tty; \/\/ enable for printout\n-\n-  \/\/ Test dumping unreadable memory\n-  \/\/ Exclude test for Windows for now, since it needs SEH handling to work which cannot be\n-  \/\/ guaranteed when we call directly into VM code. (see JDK-8220220)\n-#ifndef _WIN32\n-  do_test_print_hex_dump(unreadable, 100, 1, pattern_not_readable[0]);\n-  do_test_print_hex_dump(unreadable, 100, 2, pattern_not_readable[1]);\n-  do_test_print_hex_dump(unreadable, 100, 4, pattern_not_readable[2]);\n-  do_test_print_hex_dump(unreadable, 100, 8, pattern_not_readable[3]);\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc 23006a64 6b2f696e 7465726e 616c2f6c 6f616465 722f4e61 74697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c696272 61726965 73000000 00000000                                       \" ASCII_2 \"\\n\"\n+\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc23006a64 6b2f696e7465726e 616c2f6c6f616465 722f4e6174697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69627261726965 7300000000000000                                     \" ASCII_2 \"\\n\"\n@@ -227,5 +227,13 @@\n-  \/\/ Test dumping readable memory\n-  address arr = (address)os::malloc(100, mtInternal);\n-  for (u1 c = 0; c < 100; c++) {\n-    arr[c] = c;\n-  }\n+  constexpr uint8_t bytes[] = {\n+    0xff, 0xff, 0xe0, 0xdc, 0x23, 0x00, 0x6a, 0x64, 0x6b, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+    0x61, 0x6c, 0x2f, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x2f, 0x4e, 0x61, 0x74, 0x69, 0x76, 0x65,\n+    0x4c, 0x69, 0x62, 0x72, 0x61, 0x72, 0x69, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+  };\n+\n+  \/\/ two pages, first one protected.\n+  const size_t ps = os::vm_page_size();\n+  char* two_pages = os::reserve_memory(ps * 2, false, mtTest);\n+  os::commit_memory(two_pages, ps * 2, false);\n+  os::protect_memory(two_pages, ps, os::MEM_PROT_NONE, true);\n+\n+  memcpy(two_pages + ps, bytes, sizeof(bytes));\n@@ -233,5 +241,4 @@\n-  \/\/ properly aligned\n-  do_test_print_hex_dump(arr, 100, 1, pattern[0]);\n-  do_test_print_hex_dump(arr, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr, 100, 8, pattern[3]);\n+  \/\/ print\n+  const const_address from = (const_address) two_pages + ps - 32;\n+  const const_address to = (const_address) from + 32 + sizeof(bytes);\n+  const const_address logical_start = (const_address) LP64_ONLY(0xAAAAAAAAAA00ULL) NOT_LP64(0xAAAAAA00ULL);\n@@ -239,4 +246,4 @@\n-  \/\/ Not properly aligned. Should automatically down-align by unitsize\n-  do_test_print_hex_dump(arr + 1, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr + 1, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr + 1, 100, 8, pattern[3]);\n+  do_test_print_hex_dump(from, to, 1, 32, logical_start, PAT_1);\n+  do_test_print_hex_dump(from, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from, to, 8, 32, logical_start, PAT_8);\n@@ -244,1 +251,6 @@\n-  os::free(arr);\n+  \/\/ unaligned printing, should align to next lower unitsize\n+  do_test_print_hex_dump(from + 1, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from + 1, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from + 1, to, 8, 32, logical_start, PAT_8);\n+\n+  os::release_memory(two_pages, ps * 2);\n@@ -246,0 +258,1 @@\n+#endif \/\/ not AIX\n@@ -957,12 +970,0 @@\n-#ifdef AIX\n-\/\/ On Aix, we should fail attach attempts not aligned to segment boundaries (256m)\n-TEST_VM(os, aix_reserve_at_non_shmlba_aligned_address) {\n-  if (Use64KPages) {\n-    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-  }\n-}\n-#endif \/\/ AIX\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":72,"deletions":71,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef AIX\n+\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ On Aix, when using shmget() in os::attempt_reserve_memory_at() we should fail with attach\n+\/\/ attempts not aligned to shmget() segment boundaries (256m)\n+\/\/ But shmget() is only used in cases we want to have 64K pages and mmap() does not provide it.\n+TEST_VM(os_aix, aix_reserve_at_non_shmlba_aligned_address) {\n+  if (os::vm_page_size() != 4*K && !os::Aix::supports_64K_mmap_pages()) {\n+    \/\/ With this condition true shmget() is used inside\n+    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+  }\n+}\n+\n+#endif \/\/ AIX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_aix.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -89,0 +89,5 @@\n+###\n+# Fails on Windows because of additional memory allocation.\n+\n+gc\/g1\/TestMixedGCLiveThreshold.java#25percent 8334759 windows-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -119,3 +119,0 @@\n-vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java 8298991 linux-x64\n-\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-\n-vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java 8298991 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-compiler\/c2\/irTests\/TestIfMinMax.java 8334816 generic-all\n@@ -73,0 +72,2 @@\n+compiler\/vectorization\/TestFloat16VectorConvChain.java 8335860 generic-all\n+\n@@ -74,0 +75,1 @@\n+\n@@ -114,1 +116,0 @@\n-runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8334545 generic-all\n@@ -118,1 +119,0 @@\n-containers\/cgroup\/PlainRead.java 8333967,8261242 linux-all\n@@ -141,7 +141,7 @@\n-serviceability\/sa\/ClhsdbCDSCore.java 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbPmap.java#core 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbPstack.java#core 8267433 macosx-x64\n-serviceability\/sa\/TestJmapCore.java 8267433 macosx-x64\n-serviceability\/sa\/TestJmapCoreMetaspace.java 8267433 macosx-x64\n+serviceability\/sa\/ClhsdbCDSCore.java              8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core    8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbPmap.java#core            8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbPstack.java#core          8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/TestJmapCore.java               8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/TestJmapCoreMetaspace.java      8267433,8318754 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-#  Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/generate.bash","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.incubator.vector module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.incubator.vector\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.incubator.vector\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_incubator_vector.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.internal.md module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.internal.md\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.internal.md\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_internal_md.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.jpackage module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.jpackage\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.jpackage\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_jpackage.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.nio.mapmode module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.nio.mapmode\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.nio.mapmode\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_nio_mapmode.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -29,2 +29,2 @@\n- * @requires vm.debug == true & vm.compiler1.enabled\n- * @run main\/othervm -XX:TraceLinearScanLevel=4 compiler.c1.TestTraceLinearScanLevel\n+ * @requires vm.debug == true & vm.compiler1.enabled & vm.compMode != \"Xcomp\"\n+ * @run main\/othervm -Xbatch -XX:TraceLinearScanLevel=4 compiler.c1.TestTraceLinearScanLevel\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestTraceLinearScanLevel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -614,2 +614,3 @@\n-    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    \/\/ Disabled by JDK-8335390, to be enabled again by JDK-8335392.\n+    \/\/ @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+    \/\/     applyIf = {\"UseUnalignedAccesses\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335390\n+ * @summary Test merge stores for some Unsafe store address patterns.\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires vm.bits == 64\n+ * @requires os.maxMemory > 8G\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresUnsafeArrayPointer::test*\n+ *                   -Xbatch\n+ *                   -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ * @run main\/othervm -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ *\/\n+\n+package compiler.c2;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestMergeStoresUnsafeArrayPointer {\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ We allocate a big int array of length:\n+    static final int SIZE = (1 << 30) + 100;\n+\n+    \/\/ This gives us a memory region of 4x as many bytes:\n+    static final long BYTE_SIZE = 4L * SIZE; \/\/ = 1L << 32 + 400L\n+\n+    \/\/ We set an \"anchor\" in the middle of this memory region, in bytes:\n+    static final long ANCHOR = BYTE_SIZE \/ 2;\n+\n+    static int four = 4;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Allocate big array of SIZE = \" + SIZE);\n+        int[] big = new int[SIZE];\n+\n+        \/\/ Each test is executed a few times, so that we can see the difference between\n+        \/\/ interpreter and compiler.\n+        int errors = 0;\n+\n+        long val = 0;\n+        System.out.println(\"test1\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test1(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test1 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        val = 0;\n+        System.out.println(\"test2\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test2(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test2 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(\"ERRORS: \" + errors);\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    \/\/ Only clear and sum over relevant parts of array to make the test fast.\n+    static void testClear(int[] a) {\n+        for (int j = 0               ; j <              100; j++) { a[j] = j; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { a[j] = j; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { a[j] = j; }\n+    }\n+\n+    static long testSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0               ; j <              100; j++) { sum += a[j]; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { sum += a[j]; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { sum += a[j]; }\n+        return sum;\n+    }\n+\n+    \/\/ Reference: expected to merge.\n+    static void test1(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putInt(a, base + 0, 0x42424242);\n+        UNSAFE.putInt(a, base + 4, 0x66666666);\n+    }\n+\n+    \/\/ Test: if MergeStores is applied this can lead to wrong results\n+    static void test2(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + ANCHOR;\n+        UNSAFE.putInt(a, base + 0                 + (long)(four + Integer.MAX_VALUE), 0x42424242);\n+        UNSAFE.putInt(a, base + Integer.MAX_VALUE + (long)(four + 4                ), 0x66666666);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresUnsafeArrayPointer.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -184,2 +184,2 @@\n-        \/\/ Fill from 1 to 50\n-        for (int i = 0; i < 50; i++) {\n+        \/\/ Fill from 1 to 125\n+        for (int i = 0; i < 125; i++) {\n@@ -190,3 +190,3 @@\n-        \/\/ Fill from -1 to -50\n-        for (int i = 50; i < 100; i++) {\n-            a[i] = -(i - 49);\n+        \/\/ Fill from -1 to -125\n+        for (int i = 125; i < 250; i++) {\n+            a[i] = -(i - 124);\n@@ -196,1 +196,1 @@\n-        for (int i = 100; i < 512; i++) {\n+        for (int i = 250; i < 512; i++) {\n@@ -209,2 +209,2 @@\n-        \/\/ Fill from 1 to 50\n-        for (int i = 0; i < 50; i++) {\n+        \/\/ Fill from 1 to 125\n+        for (int i = 0; i < 125; i++) {\n@@ -215,3 +215,3 @@\n-        \/\/ Fill from -1 to -50\n-        for (int i = 50; i < 100; i++) {\n-            a[i] = -(i - 49);\n+        \/\/ Fill from -1 to -125\n+        for (int i = 125; i < 250; i++) {\n+            a[i] = -(i - 124);\n@@ -221,1 +221,1 @@\n-        for (int i = 100; i < 512; i++) {\n+        for (int i = 250; i < 512; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-           root.array[i]= new Object[45];\n+           root.array[i]= new Object[4500];\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/DeoptReallocFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test Float16 vector conversion chain.\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorization.TestFloat16VectorConvChain\n+*\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+\n+public class TestFloat16VectorConvChain {\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n+    public static void test(short [] res, short [] src1, short [] src2) {\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = (short)Float.float16ToFloat(Float.floatToFloat16(Float.float16ToFloat(src1[i]) + Float.float16ToFloat(src2[i])));\n+        }\n+    }\n+\n+    @Run(test = {\"test\"})\n+    @Warmup(1000)\n+    public static void micro() {\n+        short [] res = new short[1024];\n+        short [] src1 = new short[1024];\n+        short [] src2 = new short[1024];\n+        Arrays.fill(src1, (short)Float.floatToFloat16(1.0f));\n+        Arrays.fill(src2, (short)Float.floatToFloat16(2.0f));\n+        for (int i = 0; i < 1000; i++) {\n+            test(res, src1, src2);\n+        }\n+    }\n+\n+    public static void main(String [] args) {\n+        TestFramework.run(TestFloat16VectorConvChain.class);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test PlainRead\n- * @key cgroups\n- * @requires os.family == \"linux\"\n- * @requires vm.flagless\n- * @library \/testlibrary \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PlainRead\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class PlainRead {\n-\n-    static public void match(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static public void noMatch(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldNotMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static final String good_value = \"(\\\\d+|-1|-2|Unlimited)\";\n-    static final String bad_value = \"(failed)\";\n-\n-    static final String[] variables = {\"Memory Limit is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n-\n-    static public void isContainer(OutputAnalyzer oa) {\n-        for (String v: variables) {\n-            match(oa, v, good_value);\n-        }\n-        for (String v: variables) {\n-            noMatch(oa, v, bad_value);\n-        }\n-    }\n-\n-    static public void isNotContainer(OutputAnalyzer oa) {\n-       oa.shouldMatch(\"^.*Can't open \/proc\/self\/mountinfo.*$\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:os+container=trace\", \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        if (wb.isContainerized()) {\n-            System.out.println(\"Inside a cgroup, testing...\");\n-            isContainer(output);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/PlainRead.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261242\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestContainerized\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestContainerized {\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        if (wb.isContainerized()) {\n+            throw new RuntimeException(\"Test failed! Expected not containerized on plain Linux.\");\n+        }\n+        System.out.println(\"Plain linux, no limits. Passed!\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/TestContainerized.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMinInitialErgonomics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.opt.UseLargePages == null | !vm.opt.UseLargePages\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCErgo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- *  are not tested explicitly in the standard gtests.\n- *\n+ *  are not tested explicitly in the standard gtest. Hence, there is no \"default-ndebug\"\n+ *  since that would be equivalent to the normal gtest for release builds.\n@@ -43,11 +43,1 @@\n-\/* @test id=balanced-with-guards\n- * @summary Run metaspace-related gtests with allocation guards enabled\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.xml\n- * @requires vm.debug\n- * @requires vm.flagless\n- * @run main\/native GTestWrapper --gtest_filter=metaspace* -XX:VerifyMetaspaceInterval=1 -XX:+MetaspaceGuardAllocations\n- *\/\n-\n-\/* @test id=balanced-no-ccs\n+\/* @test id=no-ccs\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceGtests.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8309034\n+ * @bug 8309034 8334545\n@@ -30,3 +30,0 @@\n- * @requires os.simpleArch == \"x64\"\n- * @comment The reproducer only fails in the desired way on x64.\n- * @requires vm.flagless\n@@ -34,2 +31,4 @@\n- *\n- * @run main\/othervm -Xss160K -Xint TestStackOverflowDuringInit\n+ * @requires vm.flagless\n+ * @comment Run with the smallest stack possible to limit the execution time.\n+ *          This is the smallest stack that is supported by all platforms.\n+ * @run main\/othervm -Xss384K -Xint TestStackOverflowDuringInit\n@@ -54,0 +53,22 @@\n+    \/\/ Later changes to the JDK meant that LongCache was initialized before\n+    \/\/ the test even started under jtreg so we define local versions.\n+\n+    static class LongCache {\n+        \/\/ Must have a static initializer\n+        static {\n+            System.out.println(\"LongCache is initializing\");\n+        }\n+        static java.lang.Long valueOf(long l) {\n+            return Long.valueOf(l);\n+        }\n+    }\n+\n+    static class MyLong {\n+        static java.lang.Long valueOf(long l) {\n+            if (l > -128 && l < 127) {\n+                return LongCache.valueOf(l);\n+            } else {\n+                return Long.valueOf(l);\n+            }\n+        }\n+    }\n@@ -57,2 +78,2 @@\n-            \/\/ This will initialize Long but not touch LongCache.\n-            Long.valueOf(1024L);\n+            \/\/ This will initialize MyLong but not touch LongCache.\n+            MyLong.valueOf(1024L);\n@@ -66,1 +87,1 @@\n-            Long.valueOf(0);\n+            MyLong.valueOf(0);\n@@ -71,1 +92,1 @@\n-        String expected = \"java.lang.NoClassDefFoundError: Could not initialize class java.lang.Long$LongCache\";\n+        String expected = \"java.lang.NoClassDefFoundError: Could not initialize class TestStackOverflowDuringInit$LongCache\";\n@@ -74,0 +95,6 @@\n+        \/\/ Pre-load, but not initialize, LongCache, else we will\n+        \/\/ hit SOE during class loading.\n+        System.out.println(\"Pre-loading ...\");\n+        Class<?> c = Class.forName(\"TestStackOverflowDuringInit$LongCache\",\n+                                   false,\n+                                   TestStackOverflowDuringInit.class.getClassLoader());\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=special\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokespecial\/Checker.java invokespecial\/ClassGenerator.java invokespecial\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests special\n- *\/\n-\n-\/*\n- * @test id=virtual\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokevirtual\/Checker.java invokevirtual\/ClassGenerator.java invokevirtual\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests virtual\n- *\/\n-\n-\/*\n- * @test id=interface\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokeinterface\/Checker.java invokeinterface\/ClassGenerator.java invokeinterface\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests interface\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-public class invocationOldCHATests {\n-\n-    public static void runTest(String whichTests, String classFileVersion) throws Throwable {\n-        System.out.println(\"\\nOld CHA invocation tests, Tests: \" + whichTests +\n-                           \", class file version: \" + classFileVersion);\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xmx128M\",\n-            \"-Xcomp\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseVtableBasedCHA\",\n-            \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n-            whichTests, \"--classfile_version=\" + classFileVersion);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        try {\n-            output.shouldContain(\"EXECUTION STATUS: PASSED\");\n-            output.shouldHaveExitValue(0);\n-        } catch (Throwable e) {\n-            System.out.println(\n-                \"\\nNote that an entry such as 'B.m\/C.m' in the failure chart means that\" +\n-                \" the test case failed because method B.m was invoked but the test \" +\n-                \"expected method C.m to be invoked. Similarly, a result such as 'AME\/C.m'\" +\n-                \" means that an AbstractMethodError exception was thrown but the test\" +\n-                \" case expected method C.m to be invoked.\");\n-            System.out.println(\n-                \"\\nAlso note that passing --dump to invoke*.Generator will\" +\n-                \" dump the generated classes (for debugging purposes).\\n\");\n-\n-            throw e;\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        if (args.length < 1) {\n-            throw new IllegalArgumentException(\"Should provide the test name\");\n-        }\n-        String testName = args[0];\n-\n-        \/\/ Get current major class file version and test with it.\n-        byte klassbuf[] = InMemoryJavaCompiler.compile(\"blah\", \"public class blah { }\");\n-        int major_version = klassbuf[6] << 8 | klassbuf[7];\n-\n-        switch (testName) {\n-            case \"special\":\n-                runTest(\"invokespecial.Generator\", String.valueOf(major_version));\n-                break;\n-            case \"virtual\":\n-                runTest(\"invokevirtual.Generator\", String.valueOf(major_version));\n-                break;\n-            case \"interface\":\n-                runTest(\"invokeinterface.Generator\", String.valueOf(major_version));\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unknown test name: \" + testName);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationOldCHATests.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,11 +39,0 @@\n-\/*\n- * @test id=test-64bit-ccs-guarded\n- * @summary Test the VM.metaspace command\n- * @requires vm.bits == \"64\"\n- * @requires vm.debug == true\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -Dwith-compressed-class-space -XX:MaxMetaspaceSize=201M -Xmx100M -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockDiagnosticVMOptions -XX:+MetaspaceGuardAllocations PrintMetaspaceDcmd\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/PrintMetaspaceDcmd.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-        \/\/ - overhead per allocation (padding for alignment, possibly allocation guards)\n+        \/\/ - overhead per allocation (padding for alignment)\n@@ -203,6 +203,0 @@\n-        if (Settings.settings().usesAllocationGuards) {\n-            \/\/ Guards need space.\n-            expectedMaxUsage += (numAllocated * 2);\n-            \/\/ Also, they disable the fbl, so deallocated still counts as used.\n-            expectedMaxUsage += deallocatedWords;\n-        }\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestContext.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-    public boolean usesAllocationGuards = WhiteBox.getWhiteBox().getBooleanVMFlag(\"MetaspaceGuardAllocations\");\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/Settings.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n+ * @modules java.base\/jdk.internal.misc java.management\n@@ -34,1 +33,0 @@\n- *\n@@ -36,1 +34,0 @@\n- *\n@@ -38,2 +35,0 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI  -XX:VerifyMetaspaceInterval=10  -XX:+MetaspaceGuardAllocations        TestMetaspaceAllocation\n- *\n@@ -46,2 +41,1 @@\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n+ * @modules java.base\/jdk.internal.misc java.management\n@@ -50,1 +44,0 @@\n- *\n@@ -52,2 +45,1 @@\n- *\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI                                        TestMetaspaceAllocation\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestMetaspaceAllocation\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/TestMetaspaceAllocation.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @test id=debug-default-strict\n+ * @test id=debug-default-long-manual\n@@ -77,18 +77,0 @@\n-\/*\n- * @test id=debug-guard\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @key randomness\n- * @requires (vm.debug == true)\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm\/timeout=400\n- *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:VerifyMetaspaceInterval=10\n- *      -XX:+MetaspaceGuardAllocations\n- *      TestMetaspaceAllocationMT1 3\n- *\/\n-\n@@ -133,1 +115,0 @@\n-            System.out.println(\"#### guards: \" + Settings.settings().usesAllocationGuards);\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT1.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @test id=debug-default-strict\n+ * @test id=debug-default-long-manual\n@@ -77,18 +77,0 @@\n-\/*\n- * @test id=debug-guard\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @key randomness\n- * @requires (vm.debug == true)\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm\/timeout=400\n- *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:VerifyMetaspaceInterval=10\n- *      -XX:+MetaspaceGuardAllocations\n- *      TestMetaspaceAllocationMT2 3\n- *\/\n-\n@@ -132,1 +114,0 @@\n-            System.out.println(\"#### guards: \" + Settings.settings().usesAllocationGuards);\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT2.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires vm.cds\n+ * @requires vm.cds & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+          \/\/ Class References ---\n+\n@@ -73,0 +75,2 @@\n+          \/\/ Field References ---\n+\n@@ -83,1 +87,0 @@\n-\n@@ -88,0 +91,35 @@\n+          \/\/ Method References ---\n+\n+            \/\/ Should resolve references to own constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp ResolvedConstantsApp.<init>:\")\n+            \/\/ Should resolve references to super constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp java\/lang\/Object.<init>:\")\n+\n+            \/\/ Should resolve interface methods in VM classes\n+            .shouldMatch(\"cds,resolve.*archived interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\")\n+\n+            \/\/ Should resolve references to own non-static method (private or public)\n+            .shouldMatch(\"archived method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\")\n+\n+            \/\/ Should not resolve references to static method\n+            .shouldNotMatch(\" archived method CP entry.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\")\n+\n+            \/\/ Should resolve references to method in super type\n+            .shouldMatch(\" archived method CP entry.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\")\n+\n+            \/\/ App class cannot resolve references to methods in boot classes:\n+            \/\/    When the app class loader tries to resolve a class X that's normally loaded by\n+            \/\/    the boot loader, it's possible for the app class loader to get a different copy of\n+            \/\/    X (by using MethodHandles.Lookup.defineClass(), etc). Therefore, let's be on\n+            \/\/    the side of safety and revert all such references.\n+            \/\/\n+            \/\/    This will be addressed in JDK-8315737.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\")\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsBar java\/lang\/Class.getName:\")\n+\n+            \/\/ Should not resolve methods in unrelated classes.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\")\n+\n+          \/\/ End ---\n@@ -95,1 +133,5 @@\n-        Object a = new ResolvedConstantsApp();\n+        ResolvedConstantsApp app = new ResolvedConstantsApp();\n+        ResolvedConstantsApp.staticCall();\n+        app.privateInstanceCall();\n+        app.publicInstanceCall();\n+        Object a = app;\n@@ -104,0 +146,4 @@\n+    private static void staticCall() {}\n+    private void privateInstanceCall() {}\n+    public void publicInstanceCall() {}\n+\n@@ -127,0 +173,2 @@\n+\n+        ((ResolvedConstantsFoo)this).doBar(this);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -24,7 +24,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.io.IOException;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n@@ -35,1 +28,6 @@\n- * @run driver TestRecursiveMonitorChurn\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xmx100M -XX:AsyncDeflationInterval=0 -XX:GuaranteedAsyncDeflationInterval=0\n+ *                   -Xlog:monitorinflation=trace\n+ *                   TestRecursiveMonitorChurn\n@@ -37,0 +35,4 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n@@ -49,20 +51,3 @@\n-    public static volatile Monitor monitor;\n-    public static void main(String[] args) throws IOException {\n-        if (args.length == 1 && args[0].equals(\"test\")) {\n-            \/\/ The actual test, in a forked JVM.\n-            for (int i = 0; i < 100000; i++) {\n-                monitor = new Monitor();\n-                monitor.doSomething();\n-            }\n-            System.out.println(\"i + j = \" + (Monitor.i + Monitor.j));\n-        } else {\n-            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                    \"-Xmx100M\", \"-XX:AsyncDeflationInterval=0\", \"-XX:GuaranteedAsyncDeflationInterval=0\",\n-                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\",\n-                    \"TestRecursiveMonitorChurn\",\n-                    \"test\");\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.reportDiagnosticSummary();\n-\n-            output.shouldHaveExitValue(0);\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final int LM_MONITOR = 0;\n+    static final int COUNT = 100000;\n@@ -70,8 +55,14 @@\n-            \/\/ We want to see, in the final NMT printout, a committed object monitor size that is reasonably low.\n-            \/\/ Like this:\n-            \/\/ -           Object Monitors (reserved=208, committed=208)\n-            \/\/                             (malloc=208 #1) (at peak)\n-            \/\/\n-            \/\/ Without recursive locking support, this would look more like this:\n-            \/\/ -           Object Monitors (reserved=20800624, committed=20800624)\n-            \/\/                             (malloc=20800624 #100003) (at peak)\n+    public static volatile Monitor monitor;\n+    public static void main(String[] args) {\n+        if (WB.getIntVMFlag(\"LockingMode\") == LM_MONITOR) {\n+            throw new SkippedException(\"LM_MONITOR always inflates. Invalid test.\");\n+        }\n+        final long pre_monitor_count = WB.getInUseMonitorCount();\n+        System.out.println(\" Precount = \" + pre_monitor_count);\n+        for (int i = 0; i < COUNT; i++) {\n+            monitor = new Monitor();\n+            monitor.doSomething();\n+        }\n+        System.out.println(\"i + j = \" + (Monitor.i + Monitor.j));\n+        final long post_monitor_count = WB.getInUseMonitorCount();\n+        System.out.println(\"Postcount = \" + post_monitor_count);\n@@ -79,12 +70,5 @@\n-            Pattern pat = Pattern.compile(\"- *Object Monitors.*reserved=(\\\\d+), committed=(\\\\d+).*\");\n-            for (String line : output.asLines()) {\n-                Matcher m = pat.matcher(line);\n-                if (m.matches()) {\n-                    long reserved = Long.parseLong(m.group(1));\n-                    long committed = Long.parseLong(m.group(2));\n-                    System.out.println(\">>>>> \" + line + \": \" + reserved + \" - \" + committed);\n-                    if (committed > 1000) {\n-                        throw new RuntimeException(\"Allocated too many monitors\");\n-                    }\n-                    return;\n-                }\n+        if (pre_monitor_count != post_monitor_count) {\n+            final long monitor_count_change = post_monitor_count - pre_monitor_count;\n+            System.out.println(\"Unexpected change in monitor count: \" + monitor_count_change);\n+            if (monitor_count_change < 0) {\n+                throw new RuntimeException(\"Unexpected Deflation\");\n@@ -92,1 +76,1 @@\n-            throw new RuntimeException(\"Did not find expected NMT output\");\n+            throw new RuntimeException(\"Unexpected Inflation\");\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":33,"deletions":49,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -31,1 +31,0 @@\n-import java.util.ArrayList;\n@@ -44,1 +43,1 @@\n- * @run testng SystemDumpMapTest\n+ * @run testng\/othervm -XX:+UsePerfData SystemDumpMapTest\n@@ -46,1 +45,1 @@\n-public class SystemDumpMapTest {\n+public class SystemDumpMapTest extends SystemMapTestBase {\n@@ -67,1 +66,3 @@\n-            patterns.add(Pattern.compile(regexBase + \".*jvm.*\"));\n+            for (String s: shouldMatchUnconditionally) {\n+                patterns.add(Pattern.compile(s));\n+            }\n@@ -69,4 +70,3 @@\n-                patterns.add(Pattern.compile(regexBase + \".*JAVAHEAP.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*META.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*CODE.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*STACK.*main.*\"));\n+                for (String s: shouldMatchIfNMTIsEnabled) {\n+                    patterns.add(Pattern.compile(s));\n+                }\n@@ -74,0 +74,1 @@\n+\n@@ -77,0 +78,1 @@\n+                    System.out.println(\"   \" + line);\n@@ -79,0 +81,1 @@\n+                            System.out.println(\">>> matches \" + pat);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -30,7 +30,0 @@\n-import java.io.*;\n-import java.util.ArrayDeque;\n-import java.util.Collections;\n-import java.util.Deque;\n-import java.util.HashSet;\n-import java.util.regex.Pattern;\n-\n@@ -46,1 +39,1 @@\n- * @run testng SystemMapTest\n+ * @run testng\/othervm -XX:+UsePerfData SystemMapTest\n@@ -48,1 +41,1 @@\n-public class SystemMapTest {\n+public class SystemMapTest extends SystemMapTestBase {\n@@ -51,1 +44,0 @@\n-        output.reportDiagnosticSummary();\n@@ -53,3 +45,3 @@\n-\n-        String regexBase = \".*0x\\\\p{XDigit}+ - 0x\\\\p{XDigit}+ +\\\\d+\";\n-        output.shouldMatch(regexBase + \".*jvm.*\");\n+        for (String s: shouldMatchUnconditionally) {\n+            output.shouldMatch(s);\n+        }\n@@ -57,4 +49,3 @@\n-            output.shouldMatch(regexBase + \".*JAVAHEAP.*\");\n-            output.shouldMatch(regexBase + \".*META.*\");\n-            output.shouldMatch(regexBase + \".*CODE.*\");\n-            output.shouldMatch(regexBase + \".*STACK.*main.*\");\n+            for (String s: shouldMatchIfNMTIsEnabled) {\n+                output.shouldMatch(s);\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class SystemMapTestBase {\n+\n+    \/\/ e.g.\n+    \/\/ 0x00000007ff800000-0x00000007ff91a000      1155072 rw-p      1155072            0 4K   com              JAVAHEAP                              \/shared\/projects\/openjdk\/jdk-jdk\/output-fastdebug\/images\/jdk\/lib\/server\/classes.jsa\n+    private static final String range = \"0x\\\\p{XDigit}+-0x\\\\p{XDigit}+\";\n+    private static final String space = \" +\";\n+    private static final String someSize = \"\\\\d+\";\n+    private static final String pagesize = \"(4K|8K|16K|64K|2M|16M|64M)\";\n+    private static final String prot = \"[rwsxp-]+\";\n+\n+    private static final String regexBase = range + space +\n+            someSize + space +\n+            prot + space +\n+            someSize + space +\n+            someSize + space +\n+            pagesize + space;\n+\n+    private static final String regexBase_committed = regexBase + \"com.*\";\n+    private static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n+\n+    \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n+    private static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n+    protected static final String shouldMatchUnconditionally[] = {\n+        \/\/ java launcher\n+        regexBase_committed + \"\/bin\/java\",\n+        \/\/ libjvm\n+        regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n+        \/\/ vdso library, should be part of all user space apps on all architectures OpenJDK supports.\n+        regexBase_committed + \"\\\\[vdso\\\\]\",\n+        \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+        regexBase_shared_and_committed + \"hsperfdata_.*\"\n+    };\n+\n+    protected static final String shouldMatchIfNMTIsEnabled[] = {\n+        regexBase_java_heap + \"JAVAHEAP.*\",\n+        \/\/ metaspace\n+        regexBase_committed + \"META.*\",\n+        \/\/ parts of metaspace should be uncommitted\n+        regexBase + \"-\" + space + \"META.*\",\n+        \/\/ code cache\n+        regexBase_committed + \"CODE.*\",\n+        \/\/ Main thread stack\n+        regexBase_committed + \"STACK.*main.*\"\n+    };\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-    fflush(0);\n+    fflush(NULL);\n@@ -278,1 +278,1 @@\n-    fflush(0);\n+    fflush(NULL);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/AddModuleUsesAndProvides\/libAddModuleUsesAndProvidesTest.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GenerateEvents\/libGenerateEvents1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n@@ -135,1 +135,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GenerateEvents\/libGenerateEvents2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -75,1 +75,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetClassFields\/FilteredFields\/libFilteredFieldsTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/libMissedStackMapFrames.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n@@ -234,1 +234,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop02\/libframepop02.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/get_stack_trace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n@@ -172,1 +172,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n@@ -213,1 +213,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume1\/libSuspendResume1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+    private static Object lockObj = new Object();\n@@ -39,0 +40,10 @@\n+    public static void waitMethod() {\n+        synchronized (lockObj) {\n+            try {\n+                lockObj.wait(300000);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n@@ -44,0 +55,1 @@\n+        Thread objectWait = new Thread(() -> waitMethod());\n@@ -49,0 +61,1 @@\n+        objectWait.start();\n@@ -56,1 +69,2 @@\n-               (primitiveLock.getState() != Thread.State.TIMED_WAITING)) {\n+               (primitiveLock.getState() != Thread.State.TIMED_WAITING) ||\n+               (objectWait.getState() != Thread.State.TIMED_WAITING)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithLock.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @bug 8185796 8335743\n@@ -60,1 +61,2 @@\n-                \"^\\\\s+- locked <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Class for int\\\\)$\"));\n+                \"^\\\\s+- locked <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Class for int\\\\)$\",\n+                \"^\\\\s+- waiting on <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)$\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestClhsdbJstackLock.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @bug 8185796 8335743\n@@ -67,0 +68,1 @@\n+            out.shouldMatch(\"^\\\\s+- waiting on <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)$\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLock.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        if (mid == 0) {\n+        if (mid == nullptr) {\n@@ -59,1 +59,1 @@\n-        if (mid2 == 0) {\n+        if (mid2 == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC01\/libnativeGC01.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        if (fid == 0) {\n+        if (fid == nullptr) {\n@@ -56,1 +56,1 @@\n-        if (mid == 0) {\n+        if (mid == nullptr) {\n@@ -69,1 +69,1 @@\n-        if (mid2 == 0) {\n+        if (mid2 == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC02\/libnativeGC02.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-                if (mid == 0) {\n+                if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC03\/libnativeGC03.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-        jclass matrixClass, stackClass, pairClass = 0;\n-        jmethodID stack_pop_mid, stack_empty_mid, matrix_repopulate_mid, pair_geti_mid = 0, pair_getj_mid = 0;\n+        jclass matrixClass, stackClass, pairClass = nullptr;\n+        jmethodID stack_pop_mid, stack_empty_mid, matrix_repopulate_mid, pair_geti_mid = nullptr, pair_getj_mid = nullptr;\n@@ -43,1 +43,1 @@\n-        if (stack_pop_mid == 0) {\n+        if (stack_pop_mid == nullptr) {\n@@ -48,1 +48,1 @@\n-        if (stack_empty_mid == 0) {\n+        if (stack_empty_mid == nullptr) {\n@@ -54,1 +54,1 @@\n-        if (matrix_repopulate_mid == 0) {\n+        if (matrix_repopulate_mid == nullptr) {\n@@ -65,1 +65,1 @@\n-                if (pairClass == 0) {\n+                if (pairClass == nullptr) {\n@@ -68,1 +68,1 @@\n-                        if (pair_geti_mid == 0) {\n+                        if (pair_geti_mid == nullptr) {\n@@ -73,1 +73,1 @@\n-                        if (pair_getj_mid == 0) {\n+                        if (pair_getj_mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC05\/libnativeGC05.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -101,1 +101,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -135,1 +135,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007\/getclfld007.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -147,1 +147,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -182,1 +182,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -197,1 +197,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -212,1 +212,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -237,1 +237,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -246,1 +246,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -256,1 +256,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -265,1 +265,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -273,1 +273,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -280,1 +280,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -321,1 +321,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -397,1 +397,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -456,1 +456,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -491,1 +491,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -517,1 +517,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -545,1 +545,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -570,1 +570,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -650,1 +650,1 @@\n-            fflush(0);\n+            fflush(nullptr);\n@@ -677,1 +677,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -697,1 +697,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -714,1 +714,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -728,1 +728,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -735,1 +735,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -748,1 +748,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -758,1 +758,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -770,1 +770,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -777,1 +777,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -782,1 +782,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref001\/followref001.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -173,1 +173,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -180,1 +180,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -194,1 +194,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -202,1 +202,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -215,1 +215,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -229,1 +229,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -238,1 +238,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -247,1 +247,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -256,1 +256,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -265,1 +265,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -272,1 +272,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -283,1 +283,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -298,1 +298,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -351,1 +351,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -386,1 +386,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -407,1 +407,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -459,1 +459,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -534,1 +534,1 @@\n-            fflush(0);\n+            fflush(nullptr);\n@@ -559,1 +559,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -577,1 +577,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -593,1 +593,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -605,1 +605,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -611,1 +611,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -621,1 +621,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -632,1 +632,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -646,1 +646,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -663,1 +663,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -679,1 +679,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -687,1 +687,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -695,1 +695,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref002\/followref002.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -176,1 +176,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -183,1 +183,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -197,1 +197,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -205,1 +205,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -219,1 +219,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -235,1 +235,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -244,1 +244,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -253,1 +253,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -262,1 +262,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -271,1 +271,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -278,1 +278,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -289,1 +289,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -301,1 +301,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -350,1 +350,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -385,1 +385,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -406,1 +406,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -649,1 +649,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -668,1 +668,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -751,1 +751,1 @@\n-                 fflush(0);\n+                 fflush(nullptr);\n@@ -821,1 +821,1 @@\n-            fflush(0);\n+            fflush(nullptr);\n@@ -843,1 +843,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -856,1 +856,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -868,1 +868,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -905,1 +905,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -911,1 +911,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -920,1 +920,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -936,1 +936,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -949,1 +949,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -971,1 +971,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -988,1 +988,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -997,1 +997,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -1006,1 +1006,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -1050,1 +1050,1 @@\n-                fflush(0);\n+                fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref003\/followref003.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -114,1 +114,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -135,1 +135,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -171,1 +171,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -178,1 +178,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -195,1 +195,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref004\/followref004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref005\/followref005.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref006\/followref006.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return errCode\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return errCode\n@@ -62,1 +62,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -73,1 +73,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -123,1 +123,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -179,1 +179,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -271,1 +271,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretbase\/earlyretbase.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -178,1 +178,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -223,1 +223,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -259,1 +259,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -292,1 +292,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -364,1 +364,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -434,1 +434,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -443,1 +443,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -454,1 +454,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretfp\/earlyretfp.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -187,1 +187,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -232,1 +232,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -273,1 +273,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -298,1 +298,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -455,1 +455,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -466,1 +466,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretint\/earlyretint.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -171,1 +171,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -216,1 +216,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -254,1 +254,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -279,1 +279,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -415,1 +415,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -426,1 +426,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretlong\/earlyretlong.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -171,1 +171,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -216,1 +216,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -254,1 +254,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -277,1 +277,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -413,1 +413,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -422,1 +422,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretobj\/earlyretobj.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -170,1 +170,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -215,1 +215,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -252,1 +252,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -276,1 +276,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -412,1 +412,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretstr\/earlyretstr.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -158,1 +158,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -195,1 +195,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -226,1 +226,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -342,1 +342,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -352,1 +352,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretvoid\/earlyretvoid.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -228,1 +228,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -294,1 +294,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetAllStackTraces\/getallstktr001\/getallstktr001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -66,1 +66,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -86,1 +86,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetConstantPool\/getcpool001\/getcpool001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/rawmonitor\/rawmonitor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-java\/lang\/instrument\/NativeMethodPrefixAgent.java 8307169 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -615,1 +615,0 @@\n-com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java 8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -635,1 +635,0 @@\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,9 @@\n-        System.out.println(\"Got BreakpointEvent: \" + bkptCount + \" for thread \" + event.thread());\n+        String threadInfo;\n+        try {\n+            threadInfo = event.thread().toString();\n+        } catch (ObjectCollectedException e) {\n+            \/\/ It's possible the Thread already terminated and was collected\n+            \/\/ if the SUSPEND_NONE policy was used.\n+            threadInfo = \"(thread collected)\";\n+        }\n+        System.out.println(\"Got BreakpointEvent: \" + bkptCount + \" for thread \" + threadInfo);\n","filename":"test\/jdk\/com\/sun\/jdi\/BreakpointOnClassPrepare.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-\n@@ -225,0 +224,2 @@\n+        \/\/ Account for threads using CPU for a few millis after their WAITING state is visible:\n+        goSleep(500);\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadCpuTimeArray.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8251496\n- * @summary Tests for methods in Authenticator\n- * @run testng\/othervm AuthenticatorTest\n- *\/\n-\n-import com.sun.net.httpserver.Authenticator;\n-import com.sun.net.httpserver.BasicAuthenticator;\n-import com.sun.net.httpserver.HttpPrincipal;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\n-public class AuthenticatorTest {\n-    @Test\n-    public void testFailure() {\n-        var failureResult = new Authenticator.Failure(666);\n-        assertEquals(failureResult.getResponseCode(), 666);\n-    }\n-\n-    @Test\n-    public void testRetry() {\n-        var retryResult = new Authenticator.Retry(333);\n-        assertEquals(retryResult.getResponseCode(), 333);\n-    }\n-\n-    @Test\n-    public void TestSuccess() {\n-        var principal = new HttpPrincipal(\"test\", \"123\");\n-        var successResult = new Authenticator.Success(principal);\n-        assertEquals(successResult.getPrincipal(), principal);\n-        assertEquals(\"test\", principal.getName());\n-        assertEquals(\"123\", principal.getRealm());\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8251496\n+ * @summary Tests for methods in Authenticator\n+ * @run junit AuthenticatorTest\n+ *\/\n+\n+import com.sun.net.httpserver.Authenticator;\n+import com.sun.net.httpserver.HttpPrincipal;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+public class AuthenticatorTest {\n+    @Test\n+    public void testFailure() {\n+        var failureResult = new Authenticator.Failure(666);\n+        assertEquals(666, failureResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testRetry() {\n+        var retryResult = new Authenticator.Retry(333);\n+        assertEquals(333, retryResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testSuccess() {\n+        var principal = new HttpPrincipal(\"test\", \"123\");\n+        var successResult = new Authenticator.Success(principal);\n+        assertEquals(principal, successResult.getPrincipal());\n+        assertEquals(\"test\", principal.getUsername());\n+        assertEquals(\"123\", principal.getRealm());\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib \/java\/security\/testlibrary\n@@ -28,1 +29,1 @@\n- * @run main\/manual Default\n+ * @run main\/othervm Default\n@@ -32,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -33,0 +36,1 @@\n+import java.io.*;\n@@ -35,16 +39,25 @@\n-   public static void main(String args[]) throws Exception {\n-        TextCallbackHandler h = new TextCallbackHandler();\n-        NameCallback nc = new NameCallback(\"Name: \", \"charlie\");\n-        ConfirmationCallback cc = new ConfirmationCallback\n-                        (\"Correct?\",\n-                        ConfirmationCallback.INFORMATION,\n-                        ConfirmationCallback.YES_NO_OPTION,\n-                        ConfirmationCallback.NO);\n-\n-        Callback[] callbacks = { nc, cc };\n-        h.handle(callbacks);\n-\n-        if (cc.getSelectedIndex() == ConfirmationCallback.YES) {\n-            System.out.println(\"yes\");\n-        } else {\n-            System.out.println(\"no\");\n+    public static void main(String args[]) throws Exception {\n+        InputStream in = System.in;\n+        PrintStream err = System.err;\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final String defaultName = \"charlie\";\n+        final String simulatedInput = \"-1\\n-1\\n\";\n+        HumanInputStream humanInputStream = new HumanInputStream(simulatedInput);\n+\n+        try (PrintStream prints = new PrintStream(baos)) {\n+            System.setIn(humanInputStream);\n+            System.setErr(prints);\n+            NameCallback nameCallback = new NameCallback(\"Name: \", defaultName);\n+            ConfirmationCallback confirmationCallback = new ConfirmationCallback(\n+                    \"Correct?\",\n+                    ConfirmationCallback.INFORMATION,\n+                    ConfirmationCallback.YES_NO_OPTION,\n+                    ConfirmationCallback.NO);\n+            new TextCallbackHandler().handle(new Callback[]{nameCallback, confirmationCallback});\n+\n+            Asserts.assertEquals(nameCallback.getDefaultName(), defaultName);\n+            Asserts.assertEquals(confirmationCallback.getSelectedIndex(), ConfirmationCallback.NO);\n+\n+        } finally {\n+            System.setIn(in);\n+            System.setErr(err);\n@@ -52,1 +65,5 @@\n-   }\n+\n+        \/\/ check that the default name and confirmation were visible in the output\n+        Asserts.assertTrue(baos.toString().contains(String.format(\"Name:  [%s]\", defaultName)));\n+        Asserts.assertTrue(baos.toString().contains(\"1. No [default]\"));\n+    }\n","filename":"test\/jdk\/com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- @ @key printer\n+ * @key printer\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/XparColor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -386,1 +385,6 @@\n-            assertEquals(MemorySegment.ofAddress(42).reinterpret(arena, s -> counter.incrementAndGet()).scope(), arena.scope());\n+            assertEquals(MemorySegment.ofAddress(42).reinterpret(arena, _ -> counter.incrementAndGet()).scope(), arena.scope());\n+            \/\/ check read-only state\n+            assertFalse(MemorySegment.ofAddress(42).reinterpret(100).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(100).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(100, Arena.ofAuto(), null).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(arena, _ -> counter.incrementAndGet()).isReadOnly());\n@@ -388,1 +392,1 @@\n-        assertEquals(counter.get(), 2);\n+        assertEquals(counter.get(), 3);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-        return cf.transform(cf.parse(classBytes), ClassTransform.dropping(ce ->\n+        return cf.transformClass(cf.parse(classBytes), ClassTransform.dropping(ce ->\n@@ -220,1 +220,1 @@\n-        return cf.transform(cf.parse(classBytes), ClassTransform.dropping(ce ->\n+        return cf.transformClass(cf.parse(classBytes), ClassTransform.dropping(ce ->\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BadCanonicalCtrTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-        return cf.transform(cf.parse(classBytes), ClassTransform.endHandler(clb -> {\n+        return cf.transformClass(cf.parse(classBytes), ClassTransform.endHandler(clb -> {\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ProhibitedMethods.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,1 +234,1 @@\n-        return cf.transform(model, new SerialPersistentFieldsVisitor(model.thisClass().asSymbol(), spf));\n+        return cf.transformClass(model, new SerialPersistentFieldsVisitor(model.thisClass().asSymbol(), spf));\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialPersistentFieldsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-        return cf.transform(oldModel, new ClassTransform() {\n+        return cf.transformClass(oldModel, new ClassTransform() {\n","filename":"test\/jdk\/java\/lang\/ModuleTests\/AnnotationsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-        var bytes = ClassFile.of().transform(model, transform);\n+        var bytes = ClassFile.of().transformClass(model, transform);\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-                    classData = cf.transform(cf.parse(classData), replaced.get(name));\n+                    classData = cf.transformClass(cf.parse(classData), replaced.get(name));\n","filename":"test\/jdk\/java\/lang\/invoke\/8022701\/BogoLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,0 @@\n-        if (vstr == null)\n-            vstr = System.getProperty(\"test.verbose\");\n","filename":"test\/jdk\/java\/lang\/invoke\/PrivateInvokeTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,798 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/* @test\n+ * @bug 8335060\n+ * @summary unit tests of TypeConvertingMethodAdapter\n+ * @run junit TypeConvertingTest\n+ *\/\n+public class TypeConvertingTest {\n+\n+    static void smallBooleanC(boolean b) {\n+        assertTrue(b);\n+    }\n+\n+    static void bigBooleanC(Boolean b) {\n+        assertTrue(b);\n+    }\n+\n+    static void smallByteC(byte b) {\n+        assertEquals(1, b);\n+    }\n+\n+    static void bigByteC(Byte b) {\n+        assertEquals((byte)1, b);\n+    }\n+\n+    static void smallShortC(short s) {\n+        assertEquals(1, s);\n+    }\n+\n+    static void bigShortC(Short s) {\n+        assertEquals((short)1, s);\n+    }\n+\n+    static void smallCharC(char c) {\n+        assertEquals(1, c);\n+    }\n+\n+    static void bigCharC(Character c) {\n+        assertEquals((char)1, c);\n+    }\n+\n+    static void smallIntC(int i) {\n+        assertEquals(1, i);\n+    }\n+\n+    static void bigIntC(Integer i) {\n+        assertEquals(1, i);\n+    }\n+\n+    static void smallLongC(long l) {\n+        assertEquals(1, l);\n+    }\n+\n+    static void bigLongC(Long l) {\n+        assertEquals(1, l);\n+    }\n+\n+    static void smallFloatC(float f) {\n+        assertEquals(1.0f, f);\n+    }\n+\n+    static void bigFloatC(Float f) {\n+        assertEquals(1.0f, f);\n+    }\n+\n+    static void smallDoubleC(double d) {\n+        assertEquals(1.0, d);\n+    }\n+\n+    static void bigDoubleC(Double d) {\n+        assertEquals(1.0, d);\n+    }\n+\n+    static void numberC(Number n) {\n+        assertEquals(1, n.intValue());\n+    }\n+\n+\n+    static boolean smallBooleanS() {return true;}\n+\n+    static Boolean bigBooleanS() {return true;}\n+\n+    static byte smallByteS() {return 1;}\n+\n+    static Byte bigByteS() {return 1;}\n+\n+    static short smallShortS() {return 1;}\n+\n+    static Short bigShortS() {return 1;}\n+\n+    static char smallCharS() {return 1;}\n+\n+    static Character bigCharS() {return 1;}\n+\n+    static int smallIntS() {return 1;}\n+\n+    static Integer bigIntS() {return 1;}\n+\n+    static long smallLongS() {return 1;}\n+\n+    static Long bigLongS() {return 1l;}\n+\n+    static float smallFloatS() {return 1;}\n+\n+    static Float bigFloatS() {return 1f;}\n+\n+    static double smallDoubleS() {return 1;}\n+\n+    static Double bigDoubleS() {return 1d;}\n+\n+    static Number numberS() {return 1;}\n+\n+\n+    interface GenericC<T> {\n+        void m(T t);\n+    }\n+\n+    interface SmallBooleanC {\n+        void m(boolean b);\n+    }\n+\n+    interface BigBooleanC {\n+        void m(Boolean b);\n+    }\n+\n+    interface SmallByteC {\n+        void m(byte b);\n+    }\n+\n+    interface BigByteC {\n+        void m(Byte b);\n+    }\n+\n+    interface SmallShortC {\n+        void m(short s);\n+    }\n+\n+    interface BigShortC {\n+        void m(Short s);\n+    }\n+\n+    interface SmallCharC {\n+        void m(char c);\n+    }\n+\n+    interface BigCharC {\n+        void m(Character c);\n+    }\n+\n+    interface SmallIntC {\n+        void m(int i);\n+    }\n+\n+    interface BigIntC {\n+        void m(Integer i);\n+    }\n+\n+    interface SmallLongC {\n+        void m(long l);\n+    }\n+\n+    interface BigLongC {\n+        void m(Long l);\n+    }\n+\n+    interface SmallFloatC {\n+        void m(float f);\n+    }\n+\n+    interface BigFloatC {\n+        void m(Float f);\n+    }\n+\n+    interface SmallDoubleC {\n+        void m(double d);\n+    }\n+\n+    interface BigDoubleC {\n+        void m(Double d);\n+    }\n+\n+    interface BigNumberC {\n+        void m(Number n);\n+    }\n+\n+\n+    interface GenericS<T> {\n+        T m();\n+    }\n+\n+    interface SmallBooleanS {\n+        boolean m();\n+    }\n+\n+    interface BigBooleanS {\n+        Boolean m();\n+    }\n+\n+    interface SmallByteS {\n+        byte m();\n+    }\n+\n+    interface BigByteS {\n+        Byte m();\n+    }\n+\n+    interface SmallShortS {\n+        short m();\n+    }\n+\n+    interface BigShortS {\n+        Short m();\n+    }\n+\n+    interface SmallCharS {\n+        char m();\n+    }\n+\n+    interface BigCharS {\n+        Character m();\n+    }\n+\n+    interface SmallIntS {\n+        int m();\n+    }\n+\n+    interface BigIntS {\n+        Integer m();\n+    }\n+\n+    interface SmallLongS {\n+        long m();\n+    }\n+\n+    interface BigLongS {\n+        Long m();\n+    }\n+\n+    interface SmallFloatS {\n+        float m();\n+    }\n+\n+    interface BigFloatS {\n+        Float m();\n+    }\n+\n+    interface SmallDoubleS {\n+        double m();\n+    }\n+\n+    interface BigDoubleS {\n+        Double m();\n+    }\n+\n+    interface BigNumberS {\n+        Number m();\n+    }\n+\n+\n+    static void testGenericBoolean(GenericC<Boolean> t) {\n+        t.m(true);\n+    }\n+\n+    static void testGenericByte(GenericC<Byte> t) {\n+        t.m((byte)1);\n+    }\n+\n+    static void testGenericShort(GenericC<Short> t) {\n+        t.m((short)1);\n+    }\n+\n+    static void testGenericChar(GenericC<Character> t) {\n+        t.m((char)1);\n+    }\n+\n+    static void testGenericInt(GenericC<Integer> t) {\n+        t.m(1);\n+    }\n+\n+    static void testGenericLong(GenericC<Long> t) {\n+        t.m(1l);\n+    }\n+\n+    static void testGenericFloat(GenericC<Float> t) {\n+        t.m(1.0f);\n+    }\n+\n+    static void testGenericDouble(GenericC<Double> t) {\n+        t.m(1.0d);\n+    }\n+\n+    static void testGenericNumber(GenericC<Number> t) {\n+        t.m(1);\n+    }\n+\n+    static void testSmallBoolean(SmallBooleanC t) {\n+        t.m(true);\n+    }\n+\n+    static void testSmallByte(SmallByteC t) {\n+        t.m((byte)1);\n+    }\n+\n+    static void testSmallShort(SmallShortC t) {\n+        t.m((short)1);\n+    }\n+\n+    static void testSmallChar(SmallCharC t) {\n+        t.m((char)1);\n+    }\n+\n+    static void testSmallInt(SmallIntC t) {\n+        t.m(1);\n+    }\n+\n+    static void testSmallLong(SmallLongC t) {\n+        t.m(1l);\n+    }\n+\n+    static void testSmallFloat(SmallFloatC t) {\n+        t.m(1.0f);\n+    }\n+\n+    static void testSmallDouble(SmallDoubleC t) {\n+        t.m(1.0d);\n+    }\n+\n+    static void testBigBoolean(BigBooleanC t) {\n+        t.m(true);\n+    }\n+\n+    static void testBigByte(BigByteC t) {\n+        t.m((byte)1);\n+    }\n+\n+    static void testBigShort(BigShortC t) {\n+        t.m((short)1);\n+    }\n+\n+    static void testBigChar(BigCharC t) {\n+        t.m((char)1);\n+    }\n+\n+    static void testBigInt(BigIntC t) {\n+        t.m(1);\n+    }\n+\n+    static void testBigLong(BigLongC t) {\n+        t.m(1l);\n+    }\n+\n+    static void testBigFloat(BigFloatC t) {\n+        t.m(1.0f);\n+    }\n+\n+    static void testBigDouble(BigDoubleC t) {\n+        t.m(1.0d);\n+    }\n+\n+    static void testBigNumber(BigNumberC t) {\n+        t.m(1);\n+    }\n+\n+\n+    static void testGenericBoolean(GenericS<Boolean> t) {\n+        assertEquals(true, t.m());\n+    }\n+\n+    static void testGenericByte(GenericS<Byte> t) {\n+        assertEquals((byte)1, t.m());\n+    }\n+\n+    static void testGenericShort(GenericS<Short> t) {\n+        assertEquals((short)1, t.m());\n+    }\n+\n+    static void testGenericChar(GenericS<Character> t) {\n+        assertEquals((char)1, t.m());\n+    }\n+\n+    static void testGenericInt(GenericS<Integer> t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testGenericLong(GenericS<Long> t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testGenericFloat(GenericS<Float> t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testGenericDouble(GenericS<Double> t) {\n+        assertEquals(1.0d, t.m());\n+    }\n+\n+    static void testGenericNumber(GenericS<Number> t) {\n+        assertEquals(1, t.m().intValue());\n+    }\n+\n+    static void testSmallBoolean(SmallBooleanS t) {\n+        assertEquals(true, t.m());\n+    }\n+\n+    static void testSmallByte(SmallByteS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallShort(SmallShortS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallChar(SmallCharS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallInt(SmallIntS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallLong(SmallLongS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallFloat(SmallFloatS t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testSmallDouble(SmallDoubleS t) {\n+        assertEquals(1.0d, t.m());\n+    }\n+\n+    static void testBigBoolean(BigBooleanS t) {\n+        assertEquals(true, t.m());\n+    }\n+\n+    static void testBigByte(BigByteS t) {\n+        assertEquals((byte)1, t.m());\n+    }\n+\n+    static void testBigShort(BigShortS t) {\n+        assertEquals((short)1, t.m());\n+    }\n+\n+    static void testBigChar(BigCharS t) {\n+        assertEquals((char)1, t.m());\n+    }\n+\n+    static void testBigInt(BigIntS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testBigLong(BigLongS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testBigFloat(BigFloatS t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testBigDouble(BigDoubleS t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testBigNumber(BigNumberS t) {\n+        assertEquals(1, t.m().intValue());\n+    }\n+\n+\n+    @Test\n+    void testGenericBoolean() {\n+        testGenericBoolean(TypeConvertingTest::smallBooleanC);\n+        testGenericBoolean(TypeConvertingTest::bigBooleanC);\n+\n+        testGenericBoolean(TypeConvertingTest::smallBooleanS);\n+        testGenericBoolean(TypeConvertingTest::bigBooleanS);\n+    }\n+\n+    @Test\n+    void testGenericByte() {\n+        testGenericByte(TypeConvertingTest::smallByteC);\n+        testGenericByte(TypeConvertingTest::bigByteC);\n+        testGenericByte(TypeConvertingTest::smallShortC);\n+        testGenericByte(TypeConvertingTest::smallIntC);\n+        testGenericByte(TypeConvertingTest::smallLongC);\n+        testGenericByte(TypeConvertingTest::smallFloatC);\n+        testGenericByte(TypeConvertingTest::smallDoubleC);\n+        testGenericByte(TypeConvertingTest::numberC);\n+\n+        testGenericByte(TypeConvertingTest::smallByteS);\n+        testGenericByte(TypeConvertingTest::bigByteS);\n+    }\n+\n+    @Test\n+    void testGenericShort() {\n+        testGenericShort(TypeConvertingTest::smallShortC);\n+        testGenericShort(TypeConvertingTest::bigShortC);\n+        testGenericShort(TypeConvertingTest::smallIntC);\n+        testGenericShort(TypeConvertingTest::smallLongC);\n+        testGenericShort(TypeConvertingTest::smallFloatC);\n+        testGenericShort(TypeConvertingTest::smallDoubleC);\n+        testGenericShort(TypeConvertingTest::numberC);\n+\n+        testGenericShort(TypeConvertingTest::smallShortS);\n+        testGenericShort(TypeConvertingTest::bigShortS);\n+    }\n+\n+    @Test\n+    void testGenericChar() {\n+        testGenericChar(TypeConvertingTest::smallCharC);\n+        testGenericChar(TypeConvertingTest::bigCharC);\n+        testGenericChar(TypeConvertingTest::smallIntC);\n+        testGenericChar(TypeConvertingTest::smallLongC);\n+        testGenericChar(TypeConvertingTest::smallFloatC);\n+        testGenericChar(TypeConvertingTest::smallDoubleC);\n+\n+        testGenericChar(TypeConvertingTest::smallCharS);\n+        testGenericChar(TypeConvertingTest::bigCharS);\n+    }\n+\n+    @Test\n+    void testGenericInt() {\n+        testGenericInt(TypeConvertingTest::smallIntC);\n+        testGenericInt(TypeConvertingTest::bigIntC);\n+        testGenericInt(TypeConvertingTest::smallLongC);\n+        testGenericInt(TypeConvertingTest::smallFloatC);\n+        testGenericInt(TypeConvertingTest::smallDoubleC);\n+        testGenericInt(TypeConvertingTest::numberC);\n+\n+        testGenericInt(TypeConvertingTest::smallIntS);\n+        testGenericInt(TypeConvertingTest::bigIntS);\n+    }\n+\n+    @Test\n+    void testGenericLong() {\n+        testGenericLong(TypeConvertingTest::smallLongC);\n+        testGenericLong(TypeConvertingTest::bigLongC);\n+        testGenericLong(TypeConvertingTest::smallFloatC);\n+        testGenericLong(TypeConvertingTest::smallDoubleC);\n+        testGenericLong(TypeConvertingTest::numberC);\n+\n+        testGenericLong(TypeConvertingTest::smallLongS);\n+        testGenericLong(TypeConvertingTest::bigLongS);\n+    }\n+\n+    @Test\n+    void testGenericFloat() {\n+        testGenericFloat(TypeConvertingTest::smallFloatC);\n+        testGenericFloat(TypeConvertingTest::bigFloatC);\n+        testGenericFloat(TypeConvertingTest::smallDoubleC);\n+        testGenericFloat(TypeConvertingTest::numberC);\n+\n+        testGenericFloat(TypeConvertingTest::smallFloatS);\n+        testGenericFloat(TypeConvertingTest::bigFloatS);\n+    }\n+\n+    @Test\n+    void testGenericDouble() {\n+        testGenericDouble(TypeConvertingTest::smallDoubleC);\n+        testGenericDouble(TypeConvertingTest::bigDoubleC);\n+        testGenericDouble(TypeConvertingTest::numberC);\n+\n+        testGenericDouble(TypeConvertingTest::smallDoubleS);\n+        testGenericDouble(TypeConvertingTest::bigDoubleS);\n+    }\n+\n+    @Test\n+    void testGenericNumber() {\n+        testGenericNumber(TypeConvertingTest::numberC);\n+\n+        testGenericNumber(TypeConvertingTest::numberS);\n+    }\n+\n+    @Test\n+    void testSmallBoolean() {\n+        testSmallBoolean(TypeConvertingTest::smallBooleanC);\n+        testSmallBoolean(TypeConvertingTest::bigBooleanC);\n+\n+        testSmallBoolean(TypeConvertingTest::smallBooleanS);\n+        testSmallBoolean(TypeConvertingTest::bigBooleanS);\n+    }\n+\n+    @Test\n+    void testSmallByte() {\n+        testSmallByte(TypeConvertingTest::smallByteC);\n+        testSmallByte(TypeConvertingTest::bigByteC);\n+        testSmallByte(TypeConvertingTest::smallShortC);\n+        testSmallByte(TypeConvertingTest::smallIntC);\n+        testSmallByte(TypeConvertingTest::smallLongC);\n+        testSmallByte(TypeConvertingTest::smallFloatC);\n+        testSmallByte(TypeConvertingTest::smallDoubleC);\n+        testSmallByte(TypeConvertingTest::numberC);\n+\n+        testSmallByte(TypeConvertingTest::smallByteS);\n+        testSmallByte(TypeConvertingTest::bigByteS);\n+    }\n+\n+    @Test\n+    void testSmallShort() {\n+        testSmallShort(TypeConvertingTest::smallShortC);\n+        testSmallShort(TypeConvertingTest::bigShortC);\n+        testSmallShort(TypeConvertingTest::smallIntC);\n+        testSmallShort(TypeConvertingTest::smallLongC);\n+        testSmallShort(TypeConvertingTest::smallFloatC);\n+        testSmallShort(TypeConvertingTest::smallDoubleC);\n+        testSmallShort(TypeConvertingTest::numberC);\n+\n+        testSmallShort(TypeConvertingTest::smallShortS);\n+        testSmallShort(TypeConvertingTest::bigShortS);\n+    }\n+\n+    @Test\n+    void testSmallChar() {\n+        testSmallChar(TypeConvertingTest::smallCharC);\n+        testSmallChar(TypeConvertingTest::bigCharC);\n+        testSmallChar(TypeConvertingTest::smallIntC);\n+        testSmallChar(TypeConvertingTest::smallLongC);\n+        testSmallChar(TypeConvertingTest::smallFloatC);\n+        testSmallChar(TypeConvertingTest::smallDoubleC);\n+\n+        testSmallChar(TypeConvertingTest::smallCharS);\n+        testSmallChar(TypeConvertingTest::bigCharS);\n+    }\n+\n+    @Test\n+    void testSmallInt() {\n+        testSmallInt(TypeConvertingTest::smallIntC);\n+        testSmallInt(TypeConvertingTest::bigIntC);\n+        testSmallInt(TypeConvertingTest::smallLongC);\n+        testSmallInt(TypeConvertingTest::smallFloatC);\n+        testSmallInt(TypeConvertingTest::smallDoubleC);\n+        testSmallInt(TypeConvertingTest::numberC);\n+\n+        testSmallInt(TypeConvertingTest::smallIntS);\n+        testSmallInt(TypeConvertingTest::bigIntS);\n+    }\n+\n+    @Test\n+    void testSmallLong() {\n+        testSmallLong(TypeConvertingTest::smallLongC);\n+        testSmallLong(TypeConvertingTest::bigLongC);\n+        testSmallLong(TypeConvertingTest::smallFloatC);\n+        testSmallLong(TypeConvertingTest::smallDoubleC);\n+        testSmallLong(TypeConvertingTest::numberC);\n+\n+        testSmallLong(TypeConvertingTest::smallLongS);\n+        testSmallLong(TypeConvertingTest::bigLongS);\n+    }\n+\n+    @Test\n+    void testSmallFloat() {\n+        testSmallFloat(TypeConvertingTest::smallFloatC);\n+        testSmallFloat(TypeConvertingTest::bigFloatC);\n+        testSmallFloat(TypeConvertingTest::smallDoubleC);\n+        testSmallFloat(TypeConvertingTest::numberC);\n+\n+        testSmallFloat(TypeConvertingTest::smallFloatS);\n+        testSmallFloat(TypeConvertingTest::bigFloatS);\n+    }\n+\n+    @Test\n+    void testSmallDouble() {\n+        testSmallDouble(TypeConvertingTest::smallDoubleC);\n+        testSmallDouble(TypeConvertingTest::bigDoubleC);\n+        testSmallDouble(TypeConvertingTest::numberC);\n+\n+        testSmallDouble(TypeConvertingTest::smallDoubleS);\n+        testSmallDouble(TypeConvertingTest::bigDoubleS);\n+    }\n+\n+    @Test\n+    void testBigBoolean() {\n+        testBigBoolean(TypeConvertingTest::smallBooleanC);\n+        testBigBoolean(TypeConvertingTest::bigBooleanC);\n+\n+        testBigBoolean(TypeConvertingTest::smallBooleanS);\n+        testBigBoolean(TypeConvertingTest::bigBooleanS);\n+    }\n+\n+    @Test\n+    void testBigByte() {\n+        testBigByte(TypeConvertingTest::smallByteC);\n+        testBigByte(TypeConvertingTest::bigByteC);\n+        testBigByte(TypeConvertingTest::smallShortC);\n+        testBigByte(TypeConvertingTest::smallIntC);\n+        testBigByte(TypeConvertingTest::smallLongC);\n+        testBigByte(TypeConvertingTest::smallFloatC);\n+        testBigByte(TypeConvertingTest::smallDoubleC);\n+        testBigByte(TypeConvertingTest::numberC);\n+\n+        testBigByte(TypeConvertingTest::smallByteS);\n+        testBigByte(TypeConvertingTest::bigByteS);\n+    }\n+\n+    @Test\n+    void testBigShort() {\n+        testBigShort(TypeConvertingTest::smallShortC);\n+        testBigShort(TypeConvertingTest::bigShortC);\n+        testBigShort(TypeConvertingTest::smallIntC);\n+        testBigShort(TypeConvertingTest::smallLongC);\n+        testBigShort(TypeConvertingTest::smallFloatC);\n+        testBigShort(TypeConvertingTest::smallDoubleC);\n+        testBigShort(TypeConvertingTest::numberC);\n+\n+        testBigShort(TypeConvertingTest::smallShortS);\n+        testBigShort(TypeConvertingTest::bigShortS);\n+    }\n+\n+    @Test\n+    void testBigChar() {\n+        testBigChar(TypeConvertingTest::smallCharC);\n+        testBigChar(TypeConvertingTest::bigCharC);\n+        testBigChar(TypeConvertingTest::smallIntC);\n+        testBigChar(TypeConvertingTest::smallLongC);\n+        testBigChar(TypeConvertingTest::smallFloatC);\n+        testBigChar(TypeConvertingTest::smallDoubleC);\n+\n+        testBigChar(TypeConvertingTest::smallCharS);\n+        testBigChar(TypeConvertingTest::bigCharS);\n+    }\n+\n+    @Test\n+    void testBigInt() {\n+        testBigInt(TypeConvertingTest::smallIntC);\n+        testBigInt(TypeConvertingTest::bigIntC);\n+        testBigInt(TypeConvertingTest::smallLongC);\n+        testBigInt(TypeConvertingTest::smallFloatC);\n+        testBigInt(TypeConvertingTest::smallDoubleC);\n+        testBigInt(TypeConvertingTest::numberC);\n+\n+        testBigInt(TypeConvertingTest::smallIntS);\n+        testBigInt(TypeConvertingTest::bigIntS);\n+    }\n+\n+    @Test\n+    void testBigLong() {\n+        testBigLong(TypeConvertingTest::smallLongC);\n+        testBigLong(TypeConvertingTest::bigLongC);\n+        testBigLong(TypeConvertingTest::smallFloatC);\n+        testBigLong(TypeConvertingTest::smallDoubleC);\n+        testBigLong(TypeConvertingTest::numberC);\n+\n+        testBigLong(TypeConvertingTest::smallLongS);\n+        testBigLong(TypeConvertingTest::bigLongS);\n+    }\n+\n+    @Test\n+    void testBigFloat() {\n+        testBigFloat(TypeConvertingTest::smallFloatC);\n+        testBigFloat(TypeConvertingTest::bigFloatC);\n+        testBigFloat(TypeConvertingTest::smallDoubleC);\n+        testBigFloat(TypeConvertingTest::numberC);\n+\n+        testBigFloat(TypeConvertingTest::smallFloatS);\n+        testBigFloat(TypeConvertingTest::bigFloatS);\n+    }\n+\n+    @Test\n+    void testBigDouble() {\n+        testBigDouble(TypeConvertingTest::smallDoubleC);\n+        testBigDouble(TypeConvertingTest::bigDoubleC);\n+        testBigDouble(TypeConvertingTest::numberC);\n+\n+        testBigDouble(TypeConvertingTest::smallDoubleS);\n+        testBigDouble(TypeConvertingTest::bigDoubleS);\n+    }\n+\n+    @Test\n+    void testBigNumber() {\n+        testBigNumber(TypeConvertingTest::numberC);\n+\n+        testBigNumber(TypeConvertingTest::numberS);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/TypeConvertingTest.java","additions":798,"deletions":0,"binary":false,"changes":798,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-                    classData = cf.transform(cf.parse(classData), replaced.get(name));\n+                    classData = cf.transformClass(cf.parse(classData), replaced.get(name));\n","filename":"test\/jdk\/java\/lang\/invoke\/accessProtectedSuper\/BogoLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-                os.write (reply2.getBytes());\n+                os.write ((reply2+\"HelloAgain\").getBytes());\n","filename":"test\/jdk\/java\/net\/Authenticator\/BasicTest4.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335135\n+ * @library \/test\/lib\n+ * @summary Check that reading from inputStream throws an IOException\n+ *          if the fixed response stream is closed before reading all bytes.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+\n+public class TruncatedFixedResponse implements Runnable {\n+\n+    ServerSocket ss;\n+\n+    \/*\n+     * Our \"http\" server to return a truncated fixed response\n+     *\/\n+    public void run() {\n+        try {\n+            Socket s = ss.accept();\n+\n+            BufferedReader in = new BufferedReader(\n+                    new InputStreamReader(s.getInputStream()));\n+            while (true) {\n+                String req = in.readLine();\n+                if (req.isEmpty()) {\n+                    break;\n+                }\n+            }\n+            PrintStream out = new PrintStream(\n+                    new BufferedOutputStream(s.getOutputStream()));\n+\n+            \/* send the header *\/\n+            out.print(\"HTTP\/1.1 200\\r\\n\");\n+            out.print(\"Content-Length: 100\\r\\n\");\n+            out.print(\"Content-Type: text\/html\\r\\n\");\n+            out.print(\"\\r\\n\");\n+            out.print(\"Some content, but too short\");\n+            out.close();\n+            s.close();\n+            ss.close();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    TruncatedFixedResponse() throws Exception {\n+        \/* start the server *\/\n+        ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        new Thread(this).start();\n+\n+        \/* establish http connection to server *\/\n+        URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(ss.getLocalPort())\n+                .path(\"\/foo\")\n+                .toURL();\n+        HttpURLConnection http = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);\n+\n+        try (InputStream in = http.getInputStream()) {\n+            while (in.read() != -1) {\n+                \/\/ discard response\n+            }\n+            throw new AssertionError(\"Expected IOException was not thrown\");\n+        } catch (IOException ex) {\n+            System.out.println(\"Got expected exception: \" + ex);\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        new TruncatedFixedResponse();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLConnection\/TruncatedFixedResponse.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -72,0 +74,2 @@\n+                \/\/ weed off stray datagrams\n+                if (ip.getPort() != dst.getPort()) continue;\n@@ -114,3 +118,26 @@\n-            DatagramChannel dc = DatagramChannel.open();\n-            ds = dc.socket();\n-            ds.bind(new InetSocketAddress(0));\n+            int attempts = 0;\n+            DatagramChannel toclose = null;\n+            while (true) {\n+                DatagramChannel dc = DatagramChannel.open();\n+                ds = dc.socket();\n+                if (Platform.isOSX() && dst.getAddress().isLoopbackAddress()) {\n+                    \/\/ avoid binding to the wildcard on macOS if possible, in order to limit\n+                    \/\/ potential port conflict issues\n+                    ds.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+                } else {\n+                    ds.bind(new InetSocketAddress(0));\n+                }\n+                \/\/ on some systems it may be possible to bind two sockets\n+                \/\/ to the same port if one of them is bound to the wildcard,\n+                \/\/ if that happens, try again...\n+                if (ds.getLocalPort() == dst.getPort()) {\n+                    if (toclose != null) toclose.close();\n+                    toclose = dc;\n+                    if (++attempts == 10) {\n+                        throw new AssertionError(\"Couldn't allocate port for client socket\");\n+                    }\n+                    continue;\n+                }\n+                if (toclose != null) toclose.close();\n+                break;\n+            }\n@@ -119,1 +146,2 @@\n-        out.println(\"socket: \" + ds);\n+        out.println(\"socket: \" + ds + \" bound to src: \"\n+                + ds.getLocalSocketAddress() + \", dst: \" + dst);\n@@ -144,1 +172,1 @@\n-                = TestServers.UdpEchoServer.startNewServer(100)) {\n+                = TestServers.UdpEchoServer.startNewServer(100, InetAddress.getLoopbackAddress())) {\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorBasic.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+\n@@ -45,2 +46,4 @@\n-            test(dc);\n-            test(dc);\n+            InetAddress lo = InetAddress.getLoopbackAddress();\n+            System.out.println(\"Testing with default family and \" + lo);\n+            test(dc, lo);\n+            test(dc, lo);\n@@ -52,2 +55,4 @@\n-                test(dc);\n-                test(dc);\n+                InetAddress lo4 = InetAddress.ofLiteral(\"127.0.0.1\");\n+                System.out.println(\"Testing with INET family and \" + lo4);\n+                test(dc, lo4);\n+                test(dc, lo4);\n@@ -60,2 +65,4 @@\n-                test(dc);\n-                test(dc);\n+                InetAddress lo6 = InetAddress.ofLiteral(\"::1\");\n+                System.out.println(\"Testing with INET6 family and \" + lo6);\n+                test(dc, lo6);\n+                test(dc, lo6);\n@@ -66,0 +73,4 @@\n+    static int getLocalPort(DatagramChannel ch) throws IOException {\n+        return ((InetSocketAddress) ch.getLocalAddress()).getPort();\n+    }\n+\n@@ -71,1 +82,1 @@\n-    static void test(DatagramChannel dc) throws IOException {\n+    static void test(DatagramChannel dc, InetAddress lo) throws IOException {\n@@ -73,1 +84,1 @@\n-            server.bind(new InetSocketAddress(0));\n+            server.bind(new InetSocketAddress(lo, 0));\n@@ -75,2 +86,4 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n-            dc.connect(new InetSocketAddress(lh, server.socket().getLocalPort()));\n+            SocketAddress dcbound = dc.getLocalAddress();\n+            dc.connect(new InetSocketAddress(lo, server.socket().getLocalPort()));\n+            System.out.println(\"dc bound to \" + dcbound + \" and connected from \" +\n+                    dc.getLocalAddress() + \" to \" + dc.getRemoteAddress());\n@@ -80,2 +93,8 @@\n-            ByteBuffer bb = ByteBuffer.allocate(100);\n-            server.receive(bb);\n+            if (getLocalPort(dc) != getLocalPort(server)) {\n+                ByteBuffer bb = ByteBuffer.allocate(100);\n+                server.receive(bb);\n+            } else {\n+                \/\/ some systems may allow dc and server to bind to the same port.\n+                \/\/ when that happen the datagram may never be received\n+                System.out.println(\"Server and clients are bound to the same port: skipping receive\");\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Disconnect.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-            ByteBuffer src = ByteBuffer.wrap(\"hello\".getBytes(\"UTF-8\"));\n+            String str = \"hello \" + System.nanoTime();\n+            ByteBuffer src = ByteBuffer.wrap(str.getBytes(\"UTF-8\"));\n@@ -145,0 +146,1 @@\n+            src.flip();\n@@ -160,0 +162,5 @@\n+                        if (src.mismatch(dst) != -1) {\n+                            System.out.println(\"src: \" + src + \"not equal to dst: \" + dst);\n+                            dst.clear();\n+                            continue;\n+                        }\n@@ -163,1 +170,2 @@\n-                            assertTrue(senderPort != localPort, \"Unexpected message\");\n+                            assertTrue(senderPort != localPort,\n+                                    \"Unexpected message: localPort=\" + localPort);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Loopback.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -500,0 +500,1 @@\n+        protected final InetAddress bindAddress; \/\/local address to bind to; can be null.\n@@ -512,0 +513,12 @@\n+            this(linger, null);\n+        }\n+\n+        \/**\n+         * Creates a new abstract UDP server.\n+         *\n+         * @param linger the amount of time the server should wait before\n+         *          responding to requests.\n+         * @param bindAddress the address to bind to. If {@code null}, will\n+         *                    bind to InetAddress.getLocalHost();\n+         *\/\n+        protected AbstractUdpServer(long linger, InetAddress bindAddress) {\n@@ -513,0 +526,1 @@\n+            this.bindAddress = bindAddress;\n@@ -577,0 +591,1 @@\n+            InetAddress lh = bindAddress == null ? InetAddress.getLocalHost() : bindAddress;\n@@ -578,1 +593,1 @@\n-                    newDatagramSocket(0, InetAddress.getLocalHost());\n+                    newDatagramSocket(0, lh);\n@@ -762,1 +777,5 @@\n-            super(linger);\n+            this(linger, null);\n+        }\n+\n+        public UdpEchoServer(long linger, InetAddress bindAddress) {\n+            super(linger, bindAddress);\n@@ -798,1 +817,5 @@\n-            final UdpEchoServer echoServer = new UdpEchoServer(linger);\n+            return startNewServer(0, InetAddress.getLocalHost());\n+        }\n+\n+        public static UdpEchoServer startNewServer(long linger, InetAddress bindAddress) throws IOException {\n+            final UdpEchoServer echoServer = new UdpEchoServer(linger, bindAddress);\n","filename":"test\/jdk\/java\/nio\/channels\/TestServers.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+\/**\n+ * HumanInputStream tries to act like a human sitting in front of a computer\n+ * terminal typing on the keyboard while a program is running.\n+ * <p>\n+ * The program may call InputStream.read() and BufferedReader.readLine() in\n+ * various places. a call to B.readLine() will try to buffer as much input as\n+ * possible. Thus, a trivial InputStream will find it impossible to feed\n+ * anything to I.read() after a B.readLine() call.\n+ * <p>\n+ * This is why HumanInputStream was created, which will only send a single line\n+ * to B.readLine(), no more, no less, and the next I.read() can have a chance\n+ * to read the exact character right after \"\\n\".\n+ *\n+ *\/\n+\n+public class HumanInputStream extends InputStream {\n+    byte[] src;\n+    int pos;\n+    int length;\n+    boolean inLine;\n+    int stopIt;\n+\n+    public HumanInputStream(String input) {\n+        src = input.getBytes();\n+        pos = 0;\n+        length = src.length;\n+        stopIt = 0;\n+        inLine = false;\n+    }\n+\n+    \/\/ the trick: when called through read(byte[], int, int),\n+    \/\/ return -1 twice after \"\\n\"\n+\n+    @Override public int read() throws IOException {\n+        int re;\n+        if(pos < length) {\n+            re = src[pos];\n+            if(inLine) {\n+                if(stopIt > 0) {\n+                    stopIt--;\n+                    re = -1;\n+                } else {\n+                    if(re == '\\n') {\n+                        stopIt = 2;\n+                    }\n+                    pos++;\n+                }\n+            } else {\n+                pos++;\n+            }\n+        } else {\n+            re = -1; \/\/throws new IOException(\"NO MORE TO READ\");\n+        }\n+        return re;\n+    }\n+    @Override public int read(byte[] buffer, int offset, int len) {\n+        inLine = true;\n+        try {\n+            return super.read(buffer, offset, len);\n+        } catch(Exception e) {\n+            throw new RuntimeException(\"HumanInputStream error\");\n+        } finally {\n+            inLine = false;\n+        }\n+    }\n+    @Override public int available() {\n+        if (pos < length) return 1;\n+        return 0;\n+    }\n+\n+    \/\/ test part\n+    static void assertTrue(boolean bool) {\n+        if (!bool)\n+            throw new RuntimeException();\n+    }\n+\n+    public static void test() throws Exception {\n+        class Tester {\n+            HumanInputStream is;\n+            BufferedReader reader;\n+            Tester(String s) {\n+                is = new HumanInputStream(s);\n+                reader = new BufferedReader(new InputStreamReader(is));\n+            }\n+\n+            \/\/ three kinds of test method\n+            \/\/ 1. read byte by byte from InputStream\n+            void testStreamReadOnce(int expection) throws Exception {\n+                assertTrue(is.read() == expection);\n+            }\n+            void testStreamReadMany(String expectation) throws Exception {\n+                char[] keys = expectation.toCharArray();\n+                for (char key : keys) {\n+                    assertTrue(is.read() == key);\n+                }\n+            }\n+            \/\/ 2. read a line with a newly created Reader\n+            void testReaderReadline(String expectation) throws Exception {\n+                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+            \/\/ 3. read a line with the old Reader\n+            void testReaderReadline2(String expectation) throws Exception  {\n+                String s = reader.readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+        }\n+\n+        Tester test;\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline2(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"1\\n2\");\n+        test.testStreamReadMany(\"1\\n2\");\n+        test.testStreamReadOnce(-1);\n+\n+        test = new Tester(\"12\\n234\");\n+        test.testStreamReadOnce('1');\n+        test.testReaderReadline(\"2\");\n+        test.testStreamReadOnce('2');\n+        test.testReaderReadline2(\"34\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"changeit\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(\"Name\");\n+        test.testReaderReadline(\"Country\");\n+        test.testReaderReadline(\"Yes\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"Me\\nHere\\n\");\n+        test.testReaderReadline2(\"Me\");\n+        test.testReaderReadline2(\"Here\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/testlibrary\/HumanInputStream.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -259,1 +259,1 @@\n-                    throw new RuntimeException();\n+                    throw new RuntimeException(\"Execution time limit exceeded!\");\n@@ -269,1 +269,1 @@\n-                            throw new RuntimeException();\n+                            throw new RuntimeException(\"Execution time limit exceeded!\");\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/WhileOpStatefulTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @comment Running with -Xcomp is likely to cause a timeout from ServerCommunicatorAdmin\n+ *          before addNotificationListener can complete.\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotifReconnectDeadlockTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5021949\n+ * @summary  Verifies JSplitPane setEnabled(false) disables one touch expandable clicks\n+ * @run main TestSplitPaneEnableTest\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.event.InputEvent;\n+import javax.swing.JButton;\n+import javax.swing.JSplitPane;\n+import javax.swing.plaf.basic.BasicSplitPaneDivider;\n+import javax.swing.plaf.basic.BasicSplitPaneUI;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class TestSplitPaneEnableTest {\n+    private static JButton leftOneTouchButton;\n+    private static JButton rightOneTouchButton;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            if (laf.getClassName().toLowerCase().contains(\"gtk\")) {\n+                continue;\n+            }\n+            System.out.println(\"Testing LAF : \" + laf.getClassName());\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                setLookAndFeel(laf);\n+                JSplitPane jsp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n+                                                new JButton(\"Left\"), new JButton(\"Right\"));\n+                jsp.setUI(new TestSplitPaneUI());\n+                jsp.setOneTouchExpandable(true);\n+                jsp.setEnabled(false);\n+                if (leftOneTouchButton.isEnabled()) {\n+                    throw new RuntimeException(\"leftButton is enabled for disabled JSplitPane\");\n+                }\n+                if (rightOneTouchButton.isEnabled()) {\n+                    throw new RuntimeException(\"rightButton is enabled for disabled JSplitPane\");\n+                }\n+\n+            });\n+        }\n+    }\n+\n+    static class TestSplitPaneUI extends BasicSplitPaneUI {\n+\n+        public TestSplitPaneUI() {\n+            super();\n+        }\n+\n+        public BasicSplitPaneDivider createDefaultDivider() {\n+            return new TestSplitPaneDivider(this);\n+        }\n+    }\n+\n+    static class TestSplitPaneDivider extends BasicSplitPaneDivider {\n+\n+        public TestSplitPaneDivider(BasicSplitPaneUI ui) {\n+            super(ui);\n+        }\n+\n+        protected JButton createLeftOneTouchButton() {\n+            leftOneTouchButton = super.createLeftOneTouchButton();\n+            return leftOneTouchButton;\n+        }\n+\n+        protected JButton createRightOneTouchButton() {\n+            rightOneTouchButton = super.createRightOneTouchButton();\n+            return rightOneTouchButton;\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JSplitPane\/TestSplitPaneEnableTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-            byte[] newBytes = cc.transform(cm, t);\n+            byte[] newBytes = cc.transformClass(cm, t);\n@@ -82,1 +82,1 @@\n-            byte[] newBytes = cc.transform(cm, t);\n+            byte[] newBytes = cc.transformClass(cm, t);\n@@ -104,1 +104,1 @@\n-        byte[] newBytes = cc.transform(cm, transform);\n+        byte[] newBytes = cc.transformClass(cm, transform);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            cc.verify(cc.transform(clm, (clb, cle) -> {\n+            cc.verify(cc.transformClass(clm, (clb, cle) -> {\n@@ -306,1 +306,1 @@\n-        return ClassFile.of().transform(target,\n+        return ClassFile.of().transformClass(target,\n@@ -337,1 +337,1 @@\n-                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                    .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-        byte[] newBytes = cc.transform(cm, (cb, ce) -> {\n+        byte[] newBytes = cc.transformClass(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/BSMTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        MethodHandles.lookup().defineClass(cc.transform(cm, transform));\n+        MethodHandles.lookup().defineClass(cc.transformClass(cm, transform));\n","filename":"test\/jdk\/jdk\/classfile\/ClassBuildingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-        byte[] newBytes = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(res)).transform(classModel,\n+        byte[] newBytes = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(res)).transformClass(classModel,\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        Files.write(root.resolve(targetClassFile), cc.transform(cc.parse(root.resolve(sourceClassFile)), ClassTransform.transformingMethodBodies((cob, coe) -> {\n+        Files.write(root.resolve(targetClassFile), cc.transformClass(cc.parse(root.resolve(sourceClassFile)), ClassTransform.transformingMethodBodies((cob, coe) -> {\n@@ -150,1 +150,1 @@\n-                                                .transform(ClassFile.of().parse(bytes), m.classTransform)\n+                                                .transformClass(ClassFile.of().parse(bytes), m.classTransform)\n@@ -213,1 +213,1 @@\n-                                      .transform(newModel,\n+                                      .transformClass(newModel,\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        bytes = cc.transform(cc.parse(bytes), ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+        bytes = cc.transformClass(cc.parse(bytes), ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n@@ -87,1 +87,1 @@\n-        cc.transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+        cc.transformClass(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n@@ -92,1 +92,1 @@\n-                cc.transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                cc.transformClass(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n@@ -98,1 +98,1 @@\n-                         .transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)));\n+                         .transformClass(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)));\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-        byte[] newClass = cc.transform(c, Transforms.threeLevelNoop);\n+        byte[] newClass = cc.transformClass(c, Transforms.threeLevelNoop);\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyCodeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-                cc.transform(cm, (cb, e) -> {\n+                cc.transformClass(cm, (cb, e) -> {\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyPrimitiveMatchCodeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNSTABLE_ATRIBUTES).transform(\n+                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNSTABLE_ATRIBUTES).transformClass(\n@@ -111,1 +111,1 @@\n-                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNKNOWN_ATTRIBUTES).transform(\n+                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNKNOWN_ATTRIBUTES).transformClass(\n","filename":"test\/jdk\/jdk\/classfile\/OptionsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -148,1 +148,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -157,1 +157,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n@@ -166,1 +166,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n@@ -175,1 +175,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -184,1 +184,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -193,1 +193,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n@@ -202,1 +202,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n","filename":"test\/jdk\/jdk\/classfile\/ShortJumpsFixTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222 8320618\n+ * @bug 8305990 8320222 8320618 8335475\n@@ -39,0 +39,4 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -224,1 +228,1 @@\n-        var version49 = cc.parse(cc.transform(\n+        var version49 = cc.parse(cc.transformClass(\n@@ -232,1 +236,1 @@\n-         assertEmpty(cc.verify(cc.transform(\n+         assertEmpty(cc.verify(cc.transformClass(\n@@ -241,1 +245,1 @@\n-                -> clb.withMethodBody(\"test\", ConstantDescs.MTD_void, 0, cob\n+                -> clb.withMethodBody(\"test\", MTD_void, 0, cob\n@@ -315,0 +319,24 @@\n+\n+    @ParameterizedTest\n+    @EnumSource(ClassFile.StackMapsOption.class)\n+    void testEmptyCounters(ClassFile.StackMapsOption option) {\n+        var cf = ClassFile.of(option);\n+        var bytes = cf.build(ClassDesc.of(\"Test\"), clb -> clb\n+            .withMethodBody(\"a\", MTD_void, ACC_STATIC, CodeBuilder::return_)\n+            .withMethodBody(\"b\", MTD_void, 0, CodeBuilder::return_)\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        for (var method : cm.methods()) {\n+            var name = method.methodName();\n+            var code = method.code().orElseThrow();\n+            if (name.equalsString(\"a\")) {\n+                assertEquals(0, code.maxLocals()); \/\/ static method\n+                assertEquals(0, code.maxStack());\n+            } else {\n+                assertTrue(name.equalsString(\"b\"));\n+                assertEquals(1, code.maxLocals()); \/\/ instance method\n+                assertEquals(0, code.maxStack());\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n+        ClassModel newModel = cc.parse(cc.transformClass(cm, xform));\n@@ -77,1 +77,1 @@\n-        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n+        ClassModel newModel = cc.parse(cc.transformClass(cm, xform));\n@@ -95,1 +95,1 @@\n-        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n+        ClassModel newModel = cc.parse(cc.transformClass(cm, xform));\n","filename":"test\/jdk\/jdk\/classfile\/TestRecordComponent.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8336010\n@@ -29,0 +30,12 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.FieldTransform;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -42,0 +55,3 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+\n@@ -44,0 +60,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -100,2 +118,2 @@\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2foo))), \"foo\");\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar))), \"bar\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2foo))), \"foo\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar))), \"bar\");\n@@ -113,1 +131,1 @@\n-        assertEquals(invoke(cc.transform(cm, transform)), \"baz\");\n+        assertEquals(invoke(cc.transformClass(cm, transform)), \"baz\");\n@@ -124,3 +142,148 @@\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n+    }\n+\n+    \/**\n+     * Test to ensure class elements, such as field and\n+     * methods defined with transform\/with, are visible\n+     * to next transforms.\n+     *\/\n+    @Test\n+    void testClassChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+        var otherCm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethodBody(\"baz\", MTD_void, ACC_STATIC, CodeBuilder::return_)\n+            .withField(\"baz\", CD_long, ACC_STATIC)));\n+\n+        var methodBaz = otherCm.methods().getFirst();\n+        var fieldBaz = otherCm.fields().getFirst();\n+\n+        ClassTransform transform1 = ClassTransform.endHandler(cb -> {\n+            ClassBuilder ret;\n+            ret = cb.withMethodBody(\"bar\", MTD_void, ACC_STATIC, CodeBuilder::return_);\n+            assertSame(cb, ret);\n+            ret = cb.transformMethod(methodBaz, MethodTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+            ret = cb.withField(\"bar\", CD_int, ACC_STATIC);\n+            assertSame(cb, ret);\n+            ret = cb.transformField(fieldBaz, FieldTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+        });\n+\n+        Set<String> methodNames = new HashSet<>();\n+        Set<String> fieldNames = new HashSet<>();\n+        ClassTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof MethodModel mm) {\n+                methodNames.add(mm.methodName().stringValue());\n+            }\n+            if (ce instanceof FieldModel fm) {\n+                fieldNames.add(fm.fieldName().stringValue());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transformClass(cm, transform1.andThen(transform2));\n+\n+        assertEquals(Set.of(INIT_NAME, \"foo\", \"bar\", \"baz\"), methodNames);\n+        assertEquals(Set.of(\"bar\", \"baz\"), fieldNames);\n+    }\n+\n+    \/**\n+     * Test to ensure method elements, such as generated\n+     * or transformed code, are visible to transforms.\n+     *\/\n+    @Test\n+    void testMethodChaining() throws Exception {\n+        var mtd = MethodTypeDesc.of(CD_String);\n+\n+        var cf = ClassFile.of();\n+\n+        \/\/ withCode\n+        var cm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethod(\"baz\", mtd, ACC_STATIC | ACC_NATIVE, _ -> {})));\n+\n+        MethodTransform transform1 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.withCode(cob -> cob.loadConstant(\"foo\").areturn());\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawWithCode = { false };\n+        MethodTransform transform2 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawWithCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(transform1.andThen(transform2)));\n+\n+        assertTrue(sawWithCode[0], \"Code attribute generated not visible\");\n+\n+        \/\/ transformCode\n+        var outerCm = cf.parse(testClassPath);\n+        var foo = outerCm.methods().stream()\n+            .filter(m -> m.flags().has(AccessFlag.STATIC))\n+            .findFirst().orElseThrow();\n+\n+        MethodTransform transform3 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.transformCode(foo.code().orElseThrow(), CodeTransform.ACCEPT_ALL);\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawTransformCode = { false };\n+        MethodTransform transform4 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawTransformCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(transform3.andThen(transform4)));\n+\n+        assertTrue(sawTransformCode[0], \"Code attribute transformed not visible\");\n+    }\n+\n+    \/**\n+     * Test to ensure code elements, such as code block\n+     * begin and end labels, are visible to transforms.\n+     *\/\n+    @Test\n+    void testCodeChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+\n+        CodeTransform transform1 = new CodeTransform() {\n+            @Override\n+            public void atStart(CodeBuilder builder) {\n+                builder.block(bcb -> {\n+                    bcb.loadConstant(9876L);\n+                    bcb.goto_(bcb.endLabel());\n+                });\n+            }\n+\n+            @Override\n+            public void accept(CodeBuilder builder, CodeElement element) {\n+                builder.with(element);\n+            }\n+        };\n+        Set<Label> leaveLabels = new HashSet<>();\n+        Set<Label> targetedLabels = new HashSet<>();\n+        CodeTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof BranchInstruction bi) {\n+                leaveLabels.add(bi.target());\n+            }\n+            if (ce instanceof LabelTarget lt) {\n+                targetedLabels.add(lt.label());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(MethodTransform\n+            .transformingCode(transform1.andThen(transform2))));\n+\n+        leaveLabels.removeIf(targetedLabels::contains);\n+        assertTrue(leaveLabels.isEmpty(), () -> \"Some labels are not bounded: \" + leaveLabels);\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":170,"deletions":7,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        byte[] brokenClassBytes = cc.transform(classModel,\n+        byte[] brokenClassBytes = cc.transformClass(classModel,\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-        return ClassFile.of().transform(m, ClassTransform.endHandler(cb -> cb.with(RuntimeVisibleAnnotationsAttribute.of(annos))));\n+        return ClassFile.of().transformClass(m, ClassTransform.endHandler(cb -> cb.with(RuntimeVisibleAnnotationsAttribute.of(annos))));\n@@ -78,1 +78,1 @@\n-                    m2 = cc.parse(cc.transform(m, SWAP_ANNO_TRANSFORM));\n+                    m2 = cc.parse(cc.transformClass(m, SWAP_ANNO_TRANSFORM));\n@@ -122,1 +122,1 @@\n-                    m2 = cc.parse(cc.transform(m, (cb, ce) -> {\n+                    m2 = cc.parse(cc.transformClass(m, (cb, ce) -> {\n@@ -148,1 +148,1 @@\n-        return ClassFile.of().transform(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n+        return ClassFile.of().transformClass(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n@@ -175,1 +175,1 @@\n-        return ClassFile.of().transform(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n+        return ClassFile.of().transformClass(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/AnnotationsExamples.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -74,1 +74,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -83,1 +83,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -92,1 +92,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withSuperclass(superclass)));\n+        return ClassFile.of().transformClass(cm, ClassTransform.endHandler(cb -> cb.withSuperclass(superclass)));\n@@ -96,1 +96,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -107,1 +107,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n+        return ClassFile.of().transformClass(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n@@ -136,1 +136,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n+        return ClassFile.of().transformClass(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n@@ -163,1 +163,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute));\n+        return ClassFile.of().transformClass(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute));\n@@ -167,1 +167,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -179,1 +179,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute)\n+        return ClassFile.of().transformClass(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute)\n@@ -190,1 +190,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.dropping(e -> e instanceof FieldModel fm\n+        return ClassFile.of().transformClass(cm, ClassTransform.dropping(e -> e instanceof FieldModel fm\n@@ -195,1 +195,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withField(\"cool\", ClassDesc.ofDescriptor(\"(I)D\"), ClassFile.ACC_PUBLIC)));\n+        return ClassFile.of().transformClass(cm, ClassTransform.endHandler(cb -> cb.withField(\"cool\", ClassDesc.ofDescriptor(\"(I)D\"), ClassFile.ACC_PUBLIC)));\n@@ -199,1 +199,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingFields((fb, fe) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingFields((fb, fe) -> {\n@@ -208,1 +208,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingFields((fb, fe) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingFields((fb, fe) -> {\n@@ -217,1 +217,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethods(\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethods(\n@@ -261,1 +261,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethodBodies(transform));\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethodBodies(transform));\n@@ -265,1 +265,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n@@ -277,1 +277,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExperimentalTransformExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.ACCEPT_ALL);\n+        return ClassFile.of().transformClass(cm, ClassTransform.ACCEPT_ALL);\n@@ -45,1 +45,1 @@\n-        return ClassFile.of().transform(cm, (b, e) -> {\n+        return ClassFile.of().transformClass(cm, (b, e) -> {\n@@ -52,1 +52,1 @@\n-        return ClassFile.of().transform(cm, (b, e) ->\n+        return ClassFile.of().transformClass(cm, (b, e) ->\n@@ -60,1 +60,1 @@\n-        return ClassFile.of().transform(cm, (b, e) -> {\n+        return ClassFile.of().transformClass(cm, (b, e) -> {\n@@ -67,1 +67,1 @@\n-        return ClassFile.of().transform(cm, (b, e) -> {\n+        return ClassFile.of().transformClass(cm, (b, e) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/TransformExamples.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -261,2 +261,2 @@\n-                        case IFNONNULL -> cob.if_nonnull(target);\n-                        case IFNULL -> cob.if_null(target);\n+                        case IFNONNULL -> cob.ifnonnull(target);\n+                        case IFNULL -> cob.ifnull(target);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-            this.transform = bytes -> cc.transform(cc.parse(bytes), classTransform);\n+            this.transform = bytes -> cc.transformClass(cc.parse(bytes), classTransform);\n@@ -215,1 +215,1 @@\n-            return cc.transform(cm, (cb, ce) -> {\n+            return cc.transformClass(cm, (cb, ce) -> {\n@@ -256,1 +256,1 @@\n-            return cc.transform(cm, new ClassTransform() {\n+            return cc.transformClass(cm, new ClassTransform() {\n@@ -294,1 +294,1 @@\n-            return cc.transform(cm, (builder, element) -> {\n+            return cc.transformClass(cm, (builder, element) -> {\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @requires (os.family == \"linux\" & !vm.musl)\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build TestSystemSettings\n+ * @run main\/othervm TestSystemSettings\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSystemSettings {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XshowSettings:system\", \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"System not containerized.\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestSystemSettings.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+ * @build jdk.jfr.api.consumer.streaming.TestProcess\n@@ -43,0 +44,16 @@\n+        while (true) {\n+            try {\n+                testExit();\n+                return;\n+            } catch (RuntimeException e) {\n+                String message = String.valueOf(e.getMessage());\n+                \/\/ If the test application crashes during startup, retry.\n+                if (!message.contains(\"is no longer alive\")) {\n+                    throw e;\n+                }\n+                System.out.println(\"Application not alive when trying to get repository. Retrying.\");\n+            }\n+        }\n+    }\n+\n+    private static void testExit() throws Exception {\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestJVMExit.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-        return cf.transform(cf.parse(bytes), (clb, ce) -> {\n+        return cf.transformClass(cf.parse(bytes), (clb, ce) -> {\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestInstrumentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                result = cf.transform(cf.parse(bytes), (clb, ce) -> {\n+                result = cf.transformClass(cf.parse(bytes), (clb, ce) -> {\n","filename":"test\/jdk\/jdk\/jfr\/javaagent\/TestEventInstrumentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.Name;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test TestHiddenWait\n+ * @key jfr\n+ * @summary Checks that JFR code don't emit noise in the form of ThreadSleep and JavaMonitorWait events.\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestHiddenWait\n+ *\/\n+public class TestHiddenWait {\n+    static final String PERIODIC_EVENT_NAME = \"test.Periodic\";\n+\n+    @Name(PERIODIC_EVENT_NAME)\n+    public static class PeriodicEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        FlightRecorder.addPeriodicEvent(PeriodicEvent.class,  () -> {\n+            PeriodicEvent event = new PeriodicEvent();\n+            event.commit();\n+        });\n+        try (Recording r = new Recording()) {\n+            AtomicLong counter = new AtomicLong();\n+            r.enable(\"jdk.ThreadSleep\").withoutThreshold();\n+            r.enable(\"jdk.JavaMonitorWait\").withoutThreshold();\n+            r.enable(PERIODIC_EVENT_NAME).withPeriod(Duration.ofMillis(100));\n+            r.start();\n+            \/\/ Triggers Object.wait() in stream barrier\n+            try (RecordingStream b = new RecordingStream()) {\n+                b.startAsync();\n+                b.stop();\n+            }\n+            \/\/ Wait for for periodic events\n+            try (RecordingStream s = new RecordingStream()) {\n+                s.onEvent(PERIODIC_EVENT_NAME, e -> {\n+                    if (counter.incrementAndGet() >= 2) {\n+                        s.close();\n+                    }\n+                });\n+                s.start();\n+            }\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (RecordedEvent event : events) {\n+                if (!event.getEventType().getName().equals(PERIODIC_EVENT_NAME)) {\n+                    System.out.println(event);\n+                    throw new Exception(\"Didn't expect ThreadSleep or JavaMonitorWait events\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestHiddenWait.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return ClassFile.of().transform(classModel,\n+        return ClassFile.of().transformClass(classModel,\n","filename":"test\/jdk\/jdk\/lambda\/separate\/ClassToInterfaceConverter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,1 +176,1 @@\n-                    is.read ();\n+                    System.out.println(\"client got expected exception: \"+ioe);\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamCloseWithWrongContentLength.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @bug 8330842\n+ * @summary test AES CTS multipart operations with SunPKCS11\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=120 TestCipherTextStealingMultipart\n+ *\/\n+\n+public class TestCipherTextStealingMultipart extends PKCS11Test {\n+    private static final String LF = System.lineSeparator();\n+    private static final String ALGORITHM = \"AES\/CTS\/NoPadding\";\n+    private static final int BLOCK_SIZE = 16;\n+    private static final Key KEY =\n+            new SecretKeySpec(\"AbCdEfGhIjKlMnOp\".getBytes(), \"AES\");\n+    private static final IvParameterSpec IV =\n+            new IvParameterSpec(\"1234567890aBcDeF\".getBytes());\n+\n+    private static final StringBuilder chunksDesc = new StringBuilder();\n+    private static Provider sunPKCS11;\n+    private static Cipher sunJCECipher;\n+\n+    private static byte[][] generateChunks(int totalLength, int[] chunkSizes) {\n+        chunksDesc.setLength(0);\n+        chunksDesc.append(\"Testing with \").append(totalLength)\n+                .append(\" bytes distributed in \").append(chunkSizes.length)\n+                .append(\" multipart updates:\").append(LF);\n+        int byteIdx = 0;\n+        byte[][] plaintextChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            for (int i = 0; i < chunk.length; i++) {\n+                chunk[i] = (byte) ('A' + byteIdx++ \/ BLOCK_SIZE);\n+            }\n+            chunksDesc.append(\"  \").append(repr(chunk)).append(LF);\n+            plaintextChunks[chunkIdx] = chunk;\n+        }\n+        return plaintextChunks;\n+    }\n+\n+    private static byte[] computeExpected(byte[] jointPlaintext)\n+            throws Exception {\n+        byte[] ciphertext = sunJCECipher.doFinal(jointPlaintext);\n+        if (ciphertext.length != jointPlaintext.length) {\n+            throw new Exception(\"In CTS mode, ciphertext and plaintext should\" +\n+                    \" have the same length. However, SunJCE's CTS cipher \" +\n+                    \"returned a ciphertext of \" + ciphertext.length + \" bytes\" +\n+                    \" and plaintext has \" + jointPlaintext.length + \" bytes.\");\n+        }\n+        return ciphertext;\n+    }\n+\n+    private static byte[] join(byte[][] inputChunks, int totalLength) {\n+        ByteBuffer outputBuf = ByteBuffer.allocate(totalLength);\n+        for (byte[] inputChunk : inputChunks) {\n+            outputBuf.put(inputChunk);\n+        }\n+        return outputBuf.array();\n+    }\n+\n+    private static byte[][] split(byte[] input, int[] chunkSizes) {\n+        ByteBuffer inputBuf = ByteBuffer.wrap(input);\n+        byte[][] outputChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            inputBuf.get(chunk);\n+            outputChunks[chunkIdx] = chunk;\n+        }\n+        return outputChunks;\n+    }\n+\n+    private enum CheckType {CIPHERTEXT, PLAINTEXT}\n+\n+    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER}\n+\n+    private static void check(CheckType checkType, OutputType outputType,\n+            byte[] expected, ByteBuffer actualBuf) throws Exception {\n+        byte[] actual;\n+        if (actualBuf.hasArray()) {\n+            actual = actualBuf.array();\n+        } else {\n+            actual = new byte[actualBuf.position()];\n+            actualBuf.position(0).get(actual);\n+        }\n+        if (!Arrays.equals(actual, expected)) {\n+            throw new Exception(\"After \" + switch (checkType) {\n+                case CIPHERTEXT -> \"encrypting\";\n+                case PLAINTEXT -> \"decrypting\";\n+            } + \" into a \" + switch (outputType) {\n+                case BYTE_ARRAY -> \"byte[]\";\n+                case DIRECT_BYTE_BUFFER -> \"direct ByteBuffer\";\n+            } + \", \" + checkType.name().toLowerCase() + \"s don't match:\" + LF +\n+                    \"  Expected: \" + repr(expected) + LF +\n+                    \"    Actual: \" + repr(actual));\n+        }\n+    }\n+\n+    private static ByteBuffer encryptOrDecryptMultipart(int operation,\n+            OutputType outputType, byte[][] inputChunks, int totalLength)\n+            throws Exception {\n+        Cipher cipher = Cipher.getInstance(ALGORITHM, sunPKCS11);\n+        cipher.init(operation, KEY, IV);\n+        ByteBuffer output = null;\n+        int outOfs = 1;\n+        switch (outputType) {\n+            case BYTE_ARRAY -> {\n+                output = ByteBuffer.allocate(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    output.put(cipher.update(inputChunk));\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                byte[] tmpOut = new byte[cipher.getOutputSize(0) + outOfs];\n+                cipher.doFinal(tmpOut, outOfs);\n+                output.put(tmpOut, outOfs, tmpOut.length - outOfs);\n+            }\n+            case DIRECT_BYTE_BUFFER -> {\n+                output = ByteBuffer.allocateDirect(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    cipher.update(ByteBuffer.wrap(inputChunk), output);\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                ByteBuffer tmpOut = ByteBuffer.allocateDirect(\n+                        cipher.getOutputSize(0) + outOfs);\n+                tmpOut.position(outOfs);\n+                cipher.doFinal(ByteBuffer.allocate(0), tmpOut);\n+                tmpOut.position(outOfs);\n+                output.put(tmpOut);\n+            }\n+        }\n+        return output;\n+    }\n+\n+    private static void doMultipart(int... chunkSizes) throws Exception {\n+        int totalLength = IntStream.of(chunkSizes).sum();\n+        byte[][] plaintextChunks = generateChunks(totalLength, chunkSizes);\n+        byte[] jointPlaintext = join(plaintextChunks, totalLength);\n+        byte[] expectedCiphertext = computeExpected(jointPlaintext);\n+        byte[][] ciphertextChunks = split(expectedCiphertext, chunkSizes);\n+\n+        for (OutputType outputType : OutputType.values()) {\n+            \/\/ Encryption test\n+            check(CheckType.CIPHERTEXT, outputType, expectedCiphertext,\n+                    encryptOrDecryptMultipart(Cipher.ENCRYPT_MODE, outputType,\n+                            plaintextChunks, totalLength));\n+            \/\/ Decryption test\n+            check(CheckType.PLAINTEXT, outputType, jointPlaintext,\n+                    encryptOrDecryptMultipart(Cipher.DECRYPT_MODE, outputType,\n+                            ciphertextChunks, totalLength));\n+        }\n+    }\n+\n+    private static String repr(byte[] data) {\n+        if (data == null) {\n+            return \"<null>\";\n+        }\n+        if (data.length == 0) {\n+            return \"<empty []>\";\n+        }\n+        String lenRepr = \" (\" + data.length + \" bytes)\";\n+        for (byte b : data) {\n+            if (b < 32 || b > 126) {\n+                return HexFormat.ofDelimiter(\":\").formatHex(data) + lenRepr;\n+            }\n+        }\n+        return new String(data, StandardCharsets.US_ASCII) + lenRepr;\n+    }\n+\n+    private static void initialize() throws Exception {\n+        sunJCECipher = Cipher.getInstance(ALGORITHM, \"SunJCE\");\n+        sunJCECipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        initialize();\n+        main(new TestCipherTextStealingMultipart(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        sunPKCS11 = p;\n+        try {\n+            \/\/ Test relevant combinations for 2, 3, and 4 update operations\n+            int aesBSize = 16;\n+            int[] points = new int[]{1, aesBSize - 1, aesBSize, aesBSize + 1};\n+            for (int size1 : points) {\n+                for (int size2 : points) {\n+                    if (size1 + size2 >= aesBSize) {\n+                        doMultipart(size1, size2);\n+                    }\n+                    for (int size3 : points) {\n+                        if (size1 + size2 + size3 >= aesBSize) {\n+                            doMultipart(size1, size2, size3);\n+                        }\n+                        for (int size4 : points) {\n+                            if (size1 + size2 + size3 + size4 >= aesBSize) {\n+                                doMultipart(size1, size2, size3, size4);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            doMultipart(17, 17, 17, 17, 17);\n+            doMultipart(4, 2, 7, 1, 6, 12);\n+            doMultipart(2, 15, 21, 26, 31, 26, 5, 30);\n+            doMultipart(7, 12, 26, 8, 15, 2, 17, 16, 21, 2, 32, 29);\n+            doMultipart(6, 7, 6, 1, 5, 16, 14, 1, 10, 16, 17, 8, 1, 13, 12);\n+            doMultipart(16, 125, 19, 32, 32, 16, 17,\n+                    31, 19, 13, 16, 16, 32, 16, 16);\n+            doMultipart(5, 30, 11, 9, 6, 14, 20, 6,\n+                    5, 18, 31, 33, 15, 29, 7, 9);\n+            doMultipart(105, 8, 21, 27, 30, 101, 15, 20,\n+                    23, 33, 26, 6, 8, 2, 13, 17);\n+        } catch (Exception e) {\n+            System.out.print(chunksDesc);\n+            throw e;\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherTextStealingMultipart.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898461 6604496\n+ * @bug 4898461 6604496 8330842\n@@ -83,1 +83,2 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n@@ -86,1 +87,1 @@\n-    private static StringBuffer debugBuf = new StringBuffer();\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -131,4 +132,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-                debugBuf = new StringBuffer();\n-            }\n+            System.out.println(debugBuf);\n@@ -174,2 +172,1 @@\n-        perfOut(\"stream InBuf + stream OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n@@ -187,2 +184,1 @@\n-        perfOut(\"non-direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -200,2 +196,1 @@\n-        perfOut(\"direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -218,2 +213,1 @@\n-        perfOut(\"direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -234,2 +228,1 @@\n-        perfOut(\"non-direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -241,1 +234,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n@@ -244,4 +237,2 @@\n-    private static void perfOut(String msg) {\n-        if (debugBuf != null) {\n-            debugBuf.append(\"PERF>\" + msg);\n-        }\n+    private static void perfOut(String msg, long elapsed) {\n+        debugOut(\"PERF> \" + msg + \", elapsed: \" + elapsed + \" ns\\n\");\n@@ -251,3 +242,1 @@\n-        if (debugBuf != null) {\n-            debugBuf.append(msg);\n-        }\n+        debugBuf.append(msg);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898484 6604496 8001284\n+ * @bug 4898484 6604496 8001284 8330842\n@@ -71,1 +71,3 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n@@ -74,1 +76,1 @@\n-    private static StringBuffer debugBuf;\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -114,3 +116,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-            }\n+            System.out.println(debugBuf);\n@@ -125,1 +125,0 @@\n-        debugBuf = new StringBuffer();\n@@ -217,1 +216,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-        verifyExtraAttrs(ZIPFILENAME);\n+        verifyExternalFileAttributes(ZIPFILENAME);\n@@ -85,1 +85,1 @@\n-        verifyExtraAttrs(ZIPFILENAME);\n+        verifyExternalFileAttributes(ZIPFILENAME);\n@@ -98,2 +98,2 @@\n-    private static void verifyExtraAttrs(String zipFileName) throws IOException {\n-        \/\/ the 16 bit extra attributes value should equal 0xa1ff - look for that pattern.\n+    private static void verifyExternalFileAttributes(String zipFileName) throws IOException {\n+        \/\/ the 16 bit 'external file attributes' value should equal 0xa1ff - look for that pattern.\n@@ -110,1 +110,1 @@\n-            throw new RuntimeException(\"extra attribute value not detected\");\n+            throw new RuntimeException(\"external file attribute value not detected\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/SymLinkTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/java\/security\/testlibrary\n@@ -1868,169 +1869,1 @@\n-}\n-\n-\/**\n- * HumanInputStream tries to act like a human sitting in front of a computer\n- * terminal typing on the keyboard while the keytool program is running.\n- *\n- * keytool has called InputStream.read() and BufferedReader.readLine() in\n- * various places. a call to B.readLine() will try to buffer as much input as\n- * possible. Thus, a trivial InputStream will find it impossible to feed\n- * anything to I.read() after a B.readLine() call.\n- *\n- * This is why i create HumanInputStream, which will only send a single line\n- * to B.readLine(), no more, no less, and the next I.read() can have a chance\n- * to read the exact character right after \"\\n\".\n- *\n- * I don't know why HumanInputStream works.\n- *\/\n-class HumanInputStream extends InputStream {\n-    byte[] src;\n-    int pos;\n-    int length;\n-    boolean inLine;\n-    int stopIt;\n-\n-    public HumanInputStream(String input) {\n-        src = input.getBytes();\n-        pos = 0;\n-        length = src.length;\n-        stopIt = 0;\n-        inLine = false;\n-    }\n-\n-    \/\/ the trick: when called through read(byte[], int, int),\n-    \/\/ return -1 twice after \"\\n\"\n-\n-    @Override public int read() throws IOException {\n-        int re;\n-        if(pos < length) {\n-            re = src[pos];\n-            if(inLine) {\n-                if(stopIt > 0) {\n-                    stopIt--;\n-                    re = -1;\n-                } else {\n-                    if(re == '\\n') {\n-                        stopIt = 2;\n-                    }\n-                    pos++;\n-                }\n-            } else {\n-                pos++;\n-            }\n-        } else {\n-            re = -1;\/\/throw new IOException(\"NO MORE TO READ\");\n-        }\n-        \/\/if (re < 32) System.err.printf(\"[%02d]\", re);\n-        \/\/else System.err.printf(\"[%c]\", (char)re);\n-        return re;\n-    }\n-    @Override public int read(byte[] buffer, int offset, int len) {\n-        inLine = true;\n-        try {\n-            int re = super.read(buffer, offset, len);\n-            return re;\n-        } catch(Exception e) {\n-            throw new RuntimeException(\"HumanInputStream error\");\n-        } finally {\n-            inLine = false;\n-        }\n-    }\n-    @Override public int available() {\n-        if(pos < length) return 1;\n-        return 0;\n-    }\n-\n-    \/\/ test part\n-    static void assertTrue(boolean bool) {\n-        if(!bool)\n-            throw new RuntimeException();\n-    }\n-\n-    public static void test() throws Exception {\n-\n-        class Tester {\n-            HumanInputStream is;\n-            BufferedReader reader;\n-            Tester(String s) {\n-                is = new HumanInputStream(s);\n-                reader = new BufferedReader(new InputStreamReader(is));\n-            }\n-\n-            \/\/ three kinds of test method\n-            \/\/ 1. read byte by byte from InputStream\n-            void testStreamReadOnce(int expection) throws Exception {\n-                assertTrue(is.read() == expection);\n-            }\n-            void testStreamReadMany(String expection) throws Exception {\n-                char[] keys = expection.toCharArray();\n-                for(int i=0; i<keys.length; i++) {\n-                    assertTrue(is.read() == keys[i]);\n-                }\n-            }\n-            \/\/ 2. read a line with a newly created Reader\n-            void testReaderReadline(String expection) throws Exception {\n-                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-            \/\/ 3. read a line with the old Reader\n-            void testReaderReadline2(String expection) throws Exception  {\n-                String s = reader.readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-        }\n-\n-        Tester test;\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline2(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"1\\n2\");\n-        test.testStreamReadMany(\"1\\n2\");\n-        test.testStreamReadOnce(-1);\n-\n-        test = new Tester(\"12\\n234\");\n-        test.testStreamReadOnce('1');\n-        test.testReaderReadline(\"2\");\n-        test.testStreamReadOnce('2');\n-        test.testReaderReadline2(\"34\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"changeit\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(\"Name\");\n-        test.testReaderReadline(\"Country\");\n-        test.testReaderReadline(\"Yes\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"Me\\nHere\\n\");\n-        test.testReaderReadline2(\"Me\");\n-        test.testReaderReadline2(\"Here\");\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/KeyToolTest.java","additions":3,"deletions":170,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11\n+ * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11 \/java\/security\/testlibrary\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/NssTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332124\n+ * @summary Test to verify jcmd accepts the \"-help\", \"--help\" and \"-h\" suboptions as a command argument\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm TestJcmdSubcommandHelp\n+ *\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\n+public class TestJcmdSubcommandHelp {\n+\n+    private static final String HELP_ONE_DASH = \"-help\";\n+    private static final String HELP_TWO_DASH = \"--help\";\n+    private static final String SINGLE_H = \"-h\";\n+    private static final String CMD = \"VM.metaspace\";\n+    private static final String ILLEGAL = \"IllegalArgumentException: Unknown argument\";\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Sanity check with empty input\n+        OutputAnalyzer output = JcmdBase.jcmd();\n+        output.shouldContain(\"The following commands are available:\");\n+\n+        \/\/ Sanity check with existing usage for \"help <cmd>\"\n+        output = JcmdBase.jcmd(\"help\", CMD);\n+        String expectedOutput = output.getOutput();\n+        output.shouldNotContain(\"Unknown diagnostic command\");\n+\n+        testExpectedUsage(HELP_ONE_DASH, expectedOutput);\n+        testExpectedUsage(HELP_TWO_DASH, expectedOutput);\n+        testExpectedUsage(SINGLE_H, expectedOutput);\n+\n+        testIgnoreAdditionalArgs(HELP_ONE_DASH, expectedOutput);\n+        testIgnoreAdditionalArgs(HELP_TWO_DASH, expectedOutput);\n+        testIgnoreAdditionalArgs(SINGLE_H, expectedOutput);\n+\n+        testIgnoreTrailingSpaces(HELP_ONE_DASH, expectedOutput);\n+        testIgnoreTrailingSpaces(HELP_TWO_DASH, expectedOutput);\n+        testIgnoreTrailingSpaces(SINGLE_H, expectedOutput);\n+\n+        testSimilarCommand(HELP_ONE_DASH + \"less\", ILLEGAL);\n+        testSimilarCommand(HELP_TWO_DASH + \"me\", ILLEGAL);\n+        testSimilarCommand(SINGLE_H + \"ello\", ILLEGAL);\n+    }\n+\n+    private static void testExpectedUsage(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutput(new String[] {CMD, helpOption}, expectedOutput,\n+                \"Expected jcmd to accept '%s' suboption as a command argument and issue the same help output.\".formatted(helpOption));\n+    }\n+\n+    private static void testIgnoreAdditionalArgs(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutput(new String[] {CMD, helpOption, \"basic\"}, expectedOutput,\n+                \"Expected jcmd to accept '%s' suboption with additional arguments after help.\".formatted(helpOption));\n+    }\n+\n+    private static void testIgnoreTrailingSpaces(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutput(new String[] {CMD, \"%s    \".formatted(helpOption)}, expectedOutput,\n+                \"Expected jcmd to accept '%s' suboption with trailing spaces\".formatted(helpOption));\n+    }\n+\n+    private static void testSimilarCommand(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutputContains(new String[] {CMD, helpOption}, expectedOutput,\n+                \"Expected jcmd to NOT accept '%s' suboption with trailing content\".formatted(helpOption));\n+    }\n+\n+    private static void verifyOutputContains(String[] args, String expectedOutput, String errorMessage) throws Exception {\n+        OutputAnalyzer output = JcmdBase.jcmd(args);\n+        String issuedOutput = output.getOutput();\n+        if (!issuedOutput.contains(expectedOutput)) {\n+            printDifferingOutputs(expectedOutput, issuedOutput);\n+            throw new Exception(errorMessage);\n+        }\n+    }\n+\n+    private static void verifyOutput(String[] args, String expectedOutput, String errorMessage) throws Exception {\n+        OutputAnalyzer output = JcmdBase.jcmd(args);\n+        String issuedOutput = output.getOutput();\n+        if (!expectedOutput.equals(issuedOutput)) {\n+            printDifferingOutputs(expectedOutput, issuedOutput);\n+            throw new Exception(errorMessage);\n+        }\n+    }\n+\n+    private static void printDifferingOutputs(String expectedOutput, String issuedOutput) {\n+        System.out.println(\"Expected output: \");\n+        System.out.println(expectedOutput);\n+        System.out.println(\"Issued output: \");\n+        System.out.println(issuedOutput);\n+    }\n+}\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdSubcommandHelp.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -144,0 +144,1 @@\n+        new ToolHelpSpec(\"jnativescan\", 1,   1,   1,   0,         1,    0,     1),     \/\/ -?, -h, --help, -help accepted but not documented.\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -390,1 +390,0 @@\n-        vmOptFinalFlag(map, \"UseVtableBasedCHA\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+langtools_jnativescan = \\\n+    tools\/all \\\n+    tools\/jnativescan\n+\n","filename":"test\/langtools\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334433\n+ * @summary Verify that when running JShell on platforms that support FFMTerminalProvider,\n+ *          no new processes are spawned.\n+ * @requires os.family == \"windows\" | os.family == \"mac\" | os.family == \"linux\"\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavaTask TerminalNoExecTest\n+ * @run main TerminalNoExecTest\n+ *\/\n+\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jshell.tool.JavaShellToolBuilder;\n+\n+import toolbox.ToolBox;\n+\n+public class TerminalNoExecTest {\n+\n+    public static void main(String... args) throws Exception {\n+        if (args.length > 0) {\n+            AtomicBoolean spawnedNewProcess = new AtomicBoolean();\n+            try (var rs = new RecordingStream()) {\n+                rs.enable(\"jdk.ProcessStart\").withoutThreshold();\n+                rs.onEvent(evt -> {\n+                    System.err.println(\"evt: \" + evt);\n+                    spawnedNewProcess.set(true);\n+                });\n+                rs.startAsync();\n+                JavaShellToolBuilder.builder().run(\"--execution=local\", \"--no-startup\");\n+                rs.stop();\n+            }\n+            if (spawnedNewProcess.get()) {\n+                System.err.println(\"Spawned a new process!\");\n+                System.exit(1);\n+            }\n+            System.exit(0);\n+        } else {\n+            Path testScript = Paths.get(\"do-exit\");\n+            try (Writer w = Files.newBufferedWriter(testScript)) {\n+                w.append(\"\/exit\\n\");\n+            }\n+\n+            ToolBox tb = new ToolBox();\n+            Process target =\n+                new ProcessBuilder(tb.getJDKTool(\"java\").toString(),\n+                                   \"-classpath\", System.getProperty(\"java.class.path\"),\n+                                   TerminalNoExecTest.class.getName(),\n+                                   \"run-test\")\n+                        .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectInput(testScript.toFile())\n+                        .start();\n+\n+            target.waitFor();\n+\n+            int exitCode = target.exitValue();\n+\n+            if (exitCode != 0) {\n+                throw new AssertionError(\"Incorrect exit value, expected 0, got: \" + exitCode);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/TerminalNoExecTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-        byte[] bazBytes = ClassFile.of().transform(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n+        byte[] bazBytes = ClassFile.of().transformClass(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n@@ -203,1 +203,1 @@\n-            bazBytes = ClassFile.of().transform(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n+            bazBytes = ClassFile.of().transformClass(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n","filename":"test\/langtools\/tools\/javac\/MethodParametersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334757\n+ * @compile\/fail\/ref=CantAnnotateClassWithTypeVariable.out -XDrawDiagnostics CantAnnotateClassWithTypeVariable.java\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+public class CantAnnotateClassWithTypeVariable {\n+  @Target(ElementType.TYPE_USE)\n+  @interface TA {}\n+\n+  static class A {\n+    static class B<T> {}\n+  }\n+\n+  <T> @TA A.B<T> f() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateClassWithTypeVariable.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CantAnnotateClassWithTypeVariable.java:18:14: compiler.err.type.annotation.inadmissible: (compiler.misc.type.annotation.1: @CantAnnotateClassWithTypeVariable.TA), CantAnnotateClassWithTypeVariable.A, @CantAnnotateClassWithTypeVariable.TA CantAnnotateClassWithTypeVariable.A.B<T>\n+1 error\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateClassWithTypeVariable.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +188,1 @@\n-        byte[] Bytes = ClassFile.of().transform(cf, ClassTransform\n+        byte[] Bytes = ClassFile.of().transformClass(cf, ClassTransform\n","filename":"test\/langtools\/tools\/javac\/classreader\/8171132\/BadConstantValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +152,1 @@\n-        bytes = cf.transform(classModel, classTransform);\n+        bytes = cf.transformClass(classModel, classTransform);\n","filename":"test\/langtools\/tools\/javac\/classreader\/BadMethodParameter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        ClassFile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof ClassFileVersion)\n+        ClassFile.of().transformClass(cf, ClassTransform.dropping(ce -> ce instanceof ClassFileVersion)\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/BadClassfile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8198378\n+ * @bug 8198378 8335385\n@@ -56,1 +56,3 @@\n-                   \"package p; public class B { public static class I { } }\")\n+                   \"package p; public class B { public static class I { } }\",\n+                   \"package m; public class A { }\",\n+                   \"package m; public class B { public static class I { } }\")\n@@ -68,0 +70,3 @@\n+        Files.delete(Paths.get(\".\", \"m\", \"A.class\"));\n+        Files.delete(Paths.get(\".\", \"m\", \"B$I.class\"));\n+\n@@ -72,0 +77,4 @@\n+        doTest(\"import m.A;\",\n+               \"\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"1 error\");\n@@ -77,0 +86,5 @@\n+        doTest(\"import m.A;\",\n+               \"A a;\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"Test.java:2:33: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -82,0 +96,5 @@\n+        doTest(\"import m.A;\",\n+               \"void test() { A a; }\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"Test.java:2:47: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -85,0 +104,3 @@\n+        doTest(\"import m.*;\",\n+               \"\",\n+               (String[]) null);\n@@ -89,0 +111,4 @@\n+        doTest(\"import m.*;\",\n+               \"A a;\",\n+               \"Test.java:2:33: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -93,0 +119,4 @@\n+        doTest(\"import m.*;\",\n+               \"void test() { A a; }\",\n+               \"Test.java:2:47: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -98,0 +128,4 @@\n+        doTest(\"import m.B.I;\",\n+               \"\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -101,1 +135,7 @@\n-               \"1 error\");\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"import m.B.I;\",\n+               \"I i;\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -105,1 +145,7 @@\n-               \"1 error\");\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"import m.B.I;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -109,0 +155,3 @@\n+        doTest(\"import m.B.*;\",\n+               \"\",\n+               (String[]) null);\n@@ -113,0 +162,8 @@\n+        doTest(\"import m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n+        doTest(\"import m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -117,0 +174,4 @@\n+        doTest(\"import m.B.*;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -122,0 +183,4 @@\n+        doTest(\"import static m.B.I;\",\n+               \"\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -126,0 +191,4 @@\n+        doTest(\"import static m.B.I;\",\n+               \"I i;\",\n+               \"Test.java:2:42: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -130,0 +199,5 @@\n+        doTest(\"import static m.B.I;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:56: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -134,0 +208,4 @@\n+        doTest(\"import static m.B.*;\",\n+               \"\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -138,0 +216,4 @@\n+        doTest(\"import static m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:42: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -142,0 +224,5 @@\n+        doTest(\"import static m.B.*;\",\n+               \"void test() { M m; }\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:56: compiler.err.cant.resolve.location: kindname.class, M, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -149,1 +236,2 @@\n-                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS,\n+                     expectedOutput != null ? 1 : 0)\n","filename":"test\/langtools\/tools\/javac\/importscope\/BadClassFileDuringImport.java","additions":94,"deletions":6,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-            byte[] newBytes = ClassFile.of().transform(cf,\n+            byte[] newBytes = ClassFile.of().transformClass(cf,\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,1 @@\n-        byte[] newBytes = ClassFile.of().transform(cm, ClassTransform.dropping(ce -> ce instanceof ModuleResolutionAttribute).\n+        byte[] newBytes = ClassFile.of().transformClass(cm, ClassTransform.dropping(ce -> ce instanceof ModuleResolutionAttribute).\n","filename":"test\/langtools\/tools\/javac\/modules\/IncubatingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,1 @@\n-        byte[] newBytes = ClassFile.of().transform(cm1, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n+        byte[] newBytes = ClassFile.of().transformClass(cm1, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n","filename":"test\/langtools\/tools\/javac\/modules\/JavaBaseTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-        byte[] newBytes = ClassFile.of().transform(cm, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n+        byte[] newBytes = ClassFile.of().transformClass(cm, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n","filename":"test\/langtools\/tools\/javac\/modules\/OpenModulesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,4 @@\n+        test.disambiguationTest(\"R r when (x > 0)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"R(int x) when (x > 0)\",\n+                                 ExpressionType.PATTERN);\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1073,1 +1073,1 @@\n-                                       cf.transform(cf.parse(moduleInfo),\n+                                       cf.transformClass(cf.parse(moduleInfo),\n@@ -1182,1 +1182,1 @@\n-            byte[] newData = cf.transform(cm, (builder, element) -> {\n+            byte[] newData = cf.transformClass(cm, (builder, element) -> {\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,1 @@\n-        byte[] newClassFileBytes = ClassFile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute)\n+        byte[] newClassFileBytes = ClassFile.of().transformClass(cf, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute)\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestOrigin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335136\n+ * @summary Underscore as parameter name in one-parameter functional types fails to compile in yield statement if not enclosed in parentheses\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.JavacTask toolbox.ToolBox toolbox.Task\n+ * @run main ExpressionSwitchUnderscoreAfterYield\n+ *\/\n+\n+import toolbox.*;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class ExpressionSwitchUnderscoreAfterYield extends TestRunner {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    private final Path ROOT = Path.of(\".\");\n+\n+    public ExpressionSwitchUnderscoreAfterYield() {\n+        super(System.err);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new ExpressionSwitchUnderscoreAfterYield().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(f -> {\n+            if (f.getName().endsWith(\"_ShouldFailToCompile\")) {\n+                return new Object[]{\n+                        List.of(\n+                                FailParams.UNDERSCORE_YIELDED,\n+                                FailParams.ASSIGNMENT_TO_UNDERSCORE_IN_YIELD\n+                        )\n+                };\n+            }\n+            return new Object[0];\n+        });\n+    }\n+\n+    @Test\n+    public void testUnderscoreAsParameterNameInLambda_ShouldCompileFine() throws Exception {\n+        var code = \"\"\"\n+                        import java.util.function.*;\n+                        \\s\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Consumer<Object> result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _ -> {};\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\";\n+        tb.writeJavaFiles(ROOT, code);\n+        new toolbox.JavacTask(tb)\n+                .files(tb.findJavaFiles(ROOT))\n+                .run(Task.Expect.SUCCESS);\n+    }\n+\n+    public record FailParams(String code, List<String> expectedDiagnosticMessage) {\n+        public static FailParams UNDERSCORE_YIELDED = new FailParams(\n+                \"\"\"\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Object result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _;\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\",\n+                List.of(\"Test.java:5:23: compiler.err.use.of.underscore.not.allowed.non.variable\", \"1 error\")\n+        );\n+\n+        public static FailParams ASSIGNMENT_TO_UNDERSCORE_IN_YIELD = new FailParams(\n+                \"\"\"\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Object result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _ = 1;\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\",\n+                List.of(\"Test.java:5:23: compiler.err.use.of.underscore.not.allowed.non.variable\", \"1 error\")\n+        );\n+    }\n+\n+    @Test\n+    public void testUnderscoreAsParameterNameInLambda_ShouldFailToCompile(List<FailParams> params) throws Exception {\n+        for (var param : params) {\n+            tb.writeJavaFiles(ROOT, param.code);\n+            Task.Result result = new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\")\n+                    .files(tb.findJavaFiles(ROOT))\n+                    .run(Task.Expect.FAIL);\n+            tb.checkEqual(param.expectedDiagnosticMessage, result.getOutputLines(Task.OutputKind.DIRECT));\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchUnderscoreAfterYield.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335385\n+ * @summary Verify that BadClassFile related to imports are handled properly.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ASTAttributesFilledForReferencesOnMissingTypes\n+ *\/\n+\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.Element;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class ASTAttributesFilledForReferencesOnMissingTypes {\n+    public static void main(String... args) throws Exception {\n+        new ASTAttributesFilledForReferencesOnMissingTypes().run();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    void run() throws Exception {\n+        new JavacTask(tb)\n+          .outdir(\".\")\n+          .sources(\"package p; public class A { }\",\n+                   \"package p; public class B { public static class I { } public static class M { } }\",\n+                   \"package p; public class C { }\")\n+          .run()\n+          .writeAll();\n+\n+        try (OutputStream out = Files.newOutputStream(Paths.get(\".\", \"p\", \"A.class\"))) {\n+            out.write(\"broken\".getBytes(\"UTF-8\"));\n+        }\n+\n+        try (OutputStream out = Files.newOutputStream(Paths.get(\".\", \"p\", \"B$I.class\"))) {\n+            out.write(\"broken\".getBytes(\"UTF-8\"));\n+        }\n+\n+        Files.delete(Paths.get(\".\", \"p\", \"C.class\"));\n+        Files.delete(Paths.get(\".\", \"p\", \"B$M.class\"));\n+\n+        \/\/tests for findIdent (must be in some global scope):\n+        doTest(\"\"\"\n+               package p;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.*;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               package p;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, p.Test, null)\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.*;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n+\n+        \/\/tests for findIdentInPackage:\n+        doTest(\"\"\"\n+               import p.A;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:1:9: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.A a;\n+               }\n+               \"\"\",\n+               \"Test.java:2:6: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.C;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:1:9: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.package, p, null)\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.C c;\n+               }\n+               \"\"\",\n+               \"Test.java:2:6: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.package, p, null)\",\n+               \"1 error\");\n+\n+        \/\/tests for findIdentInType:\n+        doTest(\"\"\"\n+               import p.B.I;\n+               public class Test {\n+                   I i;\n+               }\n+               \"\"\",\n+               \"Test.java:1:11: compiler.err.cant.access: p.B.I, (compiler.misc.bad.class.file.header: B$I.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               import p.B.M;\n+               public class Test {\n+                   M m;\n+               }\n+               \"\"\",\n+               \"Test.java:1:11: compiler.err.cant.access: p.B.M, (compiler.misc.class.file.not.found: p.B$M)\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, M, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.B.I i;\n+               }\n+               \"\"\",\n+               \"Test.java:2:8: compiler.err.cant.access: p.B.I, (compiler.misc.bad.class.file.header: B$I.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.B.M m;\n+               }\n+               \"\"\",\n+               \"Test.java:2:8: compiler.err.cant.access: p.B.M, (compiler.misc.class.file.not.found: p.B$M)\",\n+               \"1 error\");\n+    }\n+\n+    void doTest(String code, String... expectedOutput) {\n+        List<String> log = new JavacTask(tb)\n+                .classpath(\".\")\n+                .sources(code)\n+                .options(\"-XDrawDiagnostics\")\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            if (e.getKind() != TaskEvent.Kind.ANALYZE) {\n+                                return ;\n+                            }\n+                            Trees trees = Trees.instance(task);\n+                            new TreePathScanner<Void, Void>() {\n+                                @Override\n+                                public Void visitIdentifier(IdentifierTree node, Void p) {\n+                                    validateAttributes();\n+                                    return super.visitIdentifier(node, p);\n+                                }\n+                                @Override\n+                                public Void visitMemberSelect(MemberSelectTree node, Void p) {\n+                                    if (!node.getIdentifier().contentEquals(\"*\")) {\n+                                        validateAttributes();\n+                                    }\n+                                    return super.visitMemberSelect(node, p);\n+                                }\n+                                void validateAttributes() {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    if (el == null) {\n+                                        throw new AssertionError(\"A null sym attribute for: \" + getCurrentPath().getLeaf() + \"!\");\n+                                    }\n+                                }\n+                            }.scan(e.getCompilationUnit(), null);\n+                        }\n+                    });\n+                })\n+                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS,\n+                     expectedOutput != null ? 1 : 0)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (expectedOutput != null && !log.equals(Arrays.asList(expectedOutput))) {\n+            throw new AssertionError(\"Unexpected output: \" + log);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/tree\/ASTAttributesFilledForReferencesOnMissingTypes.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-        var bytes = cf.transform(cm, (cb, ce) -> {\n+        var bytes = cf.transformClass(cm, (cb, ce) -> {\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+import java.io.StringWriter;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+public class JNativeScanTestBase {\n+\n+    public static final String MODULE_PATH = \"mods\";\n+\n+    private static final ToolProvider JNATIVESCAN_TOOL = ToolProvider.findFirst(\"jnativescan\")\n+            .orElseThrow(() -> new RuntimeException(\"jnativescan tool not found\"));\n+\n+    public static OutputAnalyzer jnativescan(String... args) {\n+        return run(JNATIVESCAN_TOOL, args);\n+    }\n+\n+    private static OutputAnalyzer run(ToolProvider tp, String[] commands) {\n+        int rc;\n+        StringWriter sw = new StringWriter();\n+        StringWriter esw = new StringWriter();\n+\n+        try (PrintWriter pw = new PrintWriter(sw);\n+             PrintWriter epw = new PrintWriter(esw)) {\n+            System.out.println(\"Running \" + tp.name() + \", Command: \" + Arrays.toString(commands));\n+            rc = tp.run(pw, epw, commands);\n+        }\n+        OutputAnalyzer output = new OutputAnalyzer(sw.toString(), esw.toString(), rc);\n+        output.outputTo(System.out);\n+        output.errorTo(System.err);\n+        return output;\n+    }\n+\n+    public static Path makeModularJar(String moduleName) throws IOException {\n+        Path jarPath = Path.of(MODULE_PATH, moduleName + \".jar\");\n+        Path moduleRoot = moduleRoot(moduleName);\n+        JarUtils.createJarFile(jarPath, moduleRoot);\n+        return jarPath;\n+    }\n+\n+    public static Path moduleRoot(String name) {\n+        return Path.of(System.getProperty(\"test.module.path\")).resolve(name);\n+    }\n+\n+    public static OutputAnalyzer assertSuccess(OutputAnalyzer output) {\n+        if (output.getExitValue() != 0) {\n+            throw new IllegalStateException(\"tool run failed\");\n+        }\n+        return output;\n+    }\n+\n+    public static OutputAnalyzer assertFailure(OutputAnalyzer output) {\n+        if (output.getExitValue() == 0) {\n+            throw new IllegalStateException(\"tool run succeeded\");\n+        }\n+        return output;\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/JNativeScanTestBase.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     cases.classpath.arrayref.App\n+ * @run junit TestArrayTypeRefs\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestArrayTypeRefs extends JNativeScanTestBase {\n+\n+    static Path ARRAY_REF;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        ARRAY_REF = Path.of(\"arrayref.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(ARRAY_REF, testClasses, Path.of(\"arrayref\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", ARRAY_REF.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"<no restricted methods>\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestArrayTypeRefs.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     org.singlejar\/* org.lib\/* org.myapp\/* org.service\/*\n+ *     cases.classpath.singlejar.main.Main\n+ *     cases.classpath.lib.Lib\n+ *     cases.classpath.app.App\n+ *     cases.classpath.unnamed_package.UnnamedPackage\n+ * @run junit TestJNativeScan\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class TestJNativeScan extends JNativeScanTestBase {\n+\n+    static Path TEST_CLASSES;\n+\n+    static Path CLASS_PATH_APP;\n+    static Path SINGLE_JAR_CLASS_PATH;\n+    static Path SINGLE_JAR_MODULAR;\n+    static Path ORG_MYAPP;\n+    static Path ORG_LIB;\n+    static Path UNNAMED_PACKAGE_JAR;\n+    static Path LIB_JAR;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        SINGLE_JAR_CLASS_PATH = Path.of(\"singleJar.jar\");\n+        TEST_CLASSES = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(SINGLE_JAR_CLASS_PATH, TEST_CLASSES, Path.of(\"main\", \"Main.class\"));\n+\n+        LIB_JAR = Path.of(\"lib.jar\");\n+        JarUtils.createJarFile(LIB_JAR, TEST_CLASSES, Path.of(\"lib\", \"Lib.class\"));\n+        Manifest manifest = new Manifest();\n+        Attributes mainAttrs = manifest.getMainAttributes();\n+        mainAttrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\"); \/\/ need version or other attributes will be ignored\n+        mainAttrs.putValue(\"Class-Path\", \"lib.jar non-existent.jar\");\n+        CLASS_PATH_APP = Path.of(\"app.jar\");\n+        JarUtils.createJarFile(CLASS_PATH_APP, manifest, TEST_CLASSES, Path.of(\"app\", \"App.class\"));\n+\n+        SINGLE_JAR_MODULAR = makeModularJar(\"org.singlejar\");\n+        ORG_MYAPP = makeModularJar(\"org.myapp\");\n+        ORG_LIB = makeModularJar(\"org.lib\");\n+        makeModularJar(\"org.service\");\n+\n+        UNNAMED_PACKAGE_JAR = Path.of(\"unnamed_package.jar\");\n+        JarUtils.createJarFile(UNNAMED_PACKAGE_JAR, TEST_CLASSES, Path.of(\"UnnamedPackage.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", SINGLE_JAR_CLASS_PATH.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(\"main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testSingleJarModulePath() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"org.singlejar\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.singlejar\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testWithDepModule() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"org.myapp\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.lib\")\n+                .stdoutShouldContain(\"org.lib.Lib\")\n+                .stdoutShouldContain(\"org.lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\")\n+                .stdoutShouldContain(\"org.service\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testAllModulePath() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.singlejar\")\n+                .stdoutShouldContain(\"org.lib\")\n+                .stdoutShouldContain(\"org.service\");\n+    }\n+\n+    @Test\n+    public void testClassPathAttribute() {\n+        assertSuccess(jnativescan(\"--class-path\", CLASS_PATH_APP.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testInvalidRelease() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\", \"--release\", \"asdf\"))\n+                .stderrShouldContain(\"Invalid release\");\n+    }\n+\n+    @Test\n+    public void testReleaseNotSupported() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\", \"--release\", \"9999999\"))\n+                .stderrShouldContain(\"Release: 9999999 not supported\");\n+    }\n+\n+    @Test\n+    public void testFileDoesNotExist() {\n+        assertFailure(jnativescan(\"--class-path\", \"non-existent.jar\"))\n+                .stderrShouldContain(\"Path does not appear to be a jar file, or directory containing classes\");\n+    }\n+\n+    @Test\n+    public void testModuleNotAJarFile() {\n+        String modulePath = moduleRoot(\"org.myapp\").toString() + File.pathSeparator + ORG_LIB.toString();\n+        assertSuccess(jnativescan(\"--module-path\", modulePath,\n+                        \"--add-modules\", \"ALL-MODULE-PATH\"))\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testPrintNativeAccess() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH,\n+                                  \"-add-modules\", \"org.singlejar,org.myapp\",\n+                                  \"--print-native-access\"))\n+                .stdoutShouldMatch(\"org.lib,org.service,org.singlejar\");\n+    }\n+\n+    @Test\n+    public void testNoDuplicateNames() {\n+        String classPath = SINGLE_JAR_CLASS_PATH + File.pathSeparator + CLASS_PATH_APP;\n+        OutputAnalyzer output = assertSuccess(jnativescan(\"--class-path\", classPath, \"--print-native-access\"));\n+        String[] moduleNames = output.getStdout().split(\",\");\n+        Set<String> names = new HashSet<>();\n+        for (String name : moduleNames) {\n+            assertTrue(names.add(name.strip()));\n+        }\n+    }\n+\n+    @Test\n+    public void testUnnamedPackage() {\n+        assertSuccess(jnativescan(\"--class-path\", UNNAMED_PACKAGE_JAR.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldNotContain(\".UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"UnnamedPackage::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testPositionalArguments() {\n+        assertFailure(jnativescan(\"foo\"))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"jnativescan does not accept positional arguments\");\n+    }\n+\n+    @Test\n+    public void testMissingRootModules() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"Missing required option(s) [add-modules]\");\n+    }\n+\n+    @Test\n+    public void testClassPathDirectory() {\n+        assertSuccess(jnativescan(\"--class-path\", TEST_CLASSES.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"UnnamedPackage::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(\"main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testMultipleClassPathJars() {\n+        \/\/ make sure all of these are reported, even when they are all in the ALL-UNNAMED module\n+        String classPath = UNNAMED_PACKAGE_JAR\n+                + File.pathSeparator + SINGLE_JAR_CLASS_PATH\n+                + File.pathSeparator + LIB_JAR;\n+        assertSuccess(jnativescan(\"--class-path\", classPath))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(UNNAMED_PACKAGE_JAR.toString())\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(LIB_JAR.toString())\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(SINGLE_JAR_CLASS_PATH.toString());\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestJNativeScan.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ * @compile --release 20 cases\/classpath\/missingsystem\/App.java\n+ * @run junit TestMissingSystemClass\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestMissingSystemClass extends JNativeScanTestBase {\n+\n+    static Path MISSING_SYSTEM;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        MISSING_SYSTEM = Path.of(\"missingsystem.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(MISSING_SYSTEM, testClasses, Path.of(\"missingsystem\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertFailure(jnativescan(\"--class-path\", MISSING_SYSTEM.toString(), \"--release\", \"21\"))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"Error while processing method\")\n+                .stderrShouldContain(\"missingsystem.App::main(String[])void\")\n+                .stderrShouldContain(\"CAUSED BY:\")\n+                .stderrShouldContain(\"System class can not be found\")\n+                .stderrShouldContain(\"java.lang.Compiler\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestMissingSystemClass.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     cases.classpath.subclassref.App\n+ * @run junit TestSubclassRefs\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestSubclassRefs extends JNativeScanTestBase {\n+\n+    static Path SUBCLASS_REF;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        SUBCLASS_REF = Path.of(\"subclassref.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(SUBCLASS_REF, testClasses, Path.of(\"subclassref\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", SUBCLASS_REF.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"<no restricted methods>\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestSubclassRefs.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package app;\n+\n+import lib.Lib;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        Lib.doIt();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/app\/App.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package arrayref;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        \/\/ reference an array method to see that\n+        \/\/ RestrictedMethodFinder correctly handles\n+        \/\/ references to array methods\n+        args.clone();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/arrayref\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package lib;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+public class Lib {\n+    public static void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/lib\/Lib.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package missingsystem;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        \/\/ this class was present in Java 20, but removed in 21\n+        \/\/ if we compile with --release 20, but run jnativescan\n+        \/\/ with --release 21, we should get an error\n+        java.lang.Compiler.enable();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/missingsystem\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package main;\n+\n+import java.lang.foreign.*;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/singlejar\/main\/Main.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package subclassref;\n+\n+import java.util.List;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        List<String> l = List.of(args);\n+        l.stream(); \/\/ List does not declare stream()\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/subclassref\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.*;\n+\n+public class UnnamedPackage {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/unnamed_package\/UnnamedPackage.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module org.lib {\n+    exports org.lib;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.lib;\n+\n+import java.lang.foreign.*;\n+\n+public class Lib {\n+    public static void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/org\/lib\/Lib.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.lib;\n+\n+public interface Service {\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/org\/lib\/Service.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module org.myapp {\n+    requires org.lib;\n+\n+    uses org.lib.Service;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.myapp\/module-info.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.myapp.main;\n+\n+import org.lib.Lib;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        Lib.doIt();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.myapp\/org\/myapp\/main\/Main.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.service {\n+    requires org.lib;\n+\n+    provides org.lib.Service with org.service.ServiceImpl;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.service\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.service;\n+\n+import org.lib.Service;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+public class ServiceImpl implements Service {\n+    public void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.service\/org\/service\/ServiceImpl.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.singlejar {\n+\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.singlejar\/module-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.singlejar.main;\n+\n+import java.lang.foreign.*;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.singlejar\/org\/singlejar\/main\/Main.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -72,0 +72,10 @@\n+        testContainerized(m, inContainer);\n+    }\n+\n+    private void testContainerized(Metrics m, boolean inContainer) {\n+        if (m.isContainerized() != inContainer) {\n+            throw new RuntimeException(\"containerized test failed. \" +\n+                                       \"Expected isContainerized()==\" + inContainer +\n+                                       \" but got '\" + m.isContainerized() + \"'\");\n+        }\n+        System.out.println(\"testContainerized() PASSED!\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,0 +122,2 @@\n+  public native long getInUseMonitorCount();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-            bh.consume(cc.transform(cc.parse(bytes), transform.transform));\n+            bh.consume(cc.transformClass(cc.parse(bytes), transform.transform));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdHocAdapt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-        bh.consume(sharedCP.transform(benchModel, threeLevelNoop));\n+        bh.consume(sharedCP.transformClass(benchModel, threeLevelNoop));\n@@ -108,1 +108,1 @@\n-        bh.consume(newCP.transform(benchModel, threeLevelNoop));\n+        bh.consume(newCP.transformClass(benchModel, threeLevelNoop));\n@@ -114,1 +114,1 @@\n-        bh.consume(sharedCP.transform(benchModel, addNOP));\n+        bh.consume(sharedCP.transformClass(benchModel, addNOP));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ClassfileBenchmark.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-            bh.consume(cc.transform(cm, threeLevelNoop));\n+            bh.consume(cc.transformClass(cm, threeLevelNoop));\n@@ -55,1 +55,1 @@\n-            bh.consume(cc.transform(cm, threeLevelNoop));\n+            bh.consume(cc.transformClass(cm, threeLevelNoop));\n@@ -65,1 +65,1 @@\n-            bh.consume(cc.transform(cm, threeLevelNoop));\n+            bh.consume(cc.transformClass(cm, threeLevelNoop));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ParseOptions.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-        cc.transform(clm, ClassTransform.transformingMethodBodies((cob, coe) -> {\n+        cc.transformClass(clm, ClassTransform.transformingMethodBodies((cob, coe) -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RebuildMethodBodies.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-            this.transform = bytes -> cc.transform(cc.parse(bytes), classTransform);\n+            this.transform = bytes -> cc.transformClass(cc.parse(bytes), classTransform);\n@@ -201,1 +201,1 @@\n-            return cc.transform(cm, (cb, ce) -> {\n+            return cc.transformClass(cm, (cb, ce) -> {\n@@ -242,1 +242,1 @@\n-            return cc.transform(cm, new ClassTransform() {\n+            return cc.transformClass(cm, new ClassTransform() {\n@@ -280,1 +280,1 @@\n-            return cc.transform(cm, (builder, element) -> {\n+            return cc.transformClass(cm, (builder, element) -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}