{"files":[{"patch":"@@ -2995,1 +2995,1 @@\n-    offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;\n+    offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size_rex;\n@@ -3032,1 +3032,1 @@\n-  __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);\n+  __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size_rex + NativeCall::displacement_offset);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -423,1 +423,6 @@\n-  __ pusha();         \/\/ integer registers\n+  \/\/ Push CPU state in multiple of 16 bytes\n+#ifdef _LP64\n+  __ save_legacy_gprs();\n+#else\n+  __ pusha();\n+#endif\n@@ -563,0 +568,3 @@\n+#ifdef _LP64\n+  __ restore_legacy_gprs();\n+#else\n@@ -564,0 +572,2 @@\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -601,0 +601,19 @@\n+  if (UseAPX) {\n+    caller_saved.Insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-                                                                            \\\n@@ -198,1 +197,0 @@\n-                                                                            \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4340,0 +4340,5 @@\n+#endif\n+#ifdef _LP64\n+  if (UseAPX) {\n+    regs += RegSet::range(r16, as_Register(Register::number_of_registers - 1));\n+  }\n@@ -5444,1 +5449,1 @@\n-  ExternalAddress buffer((address) b);\n+  AddressLiteral buffer((address) b, external_word_Relocation::spec_for_immediate());\n@@ -5518,1 +5523,1 @@\n-  ExternalAddress buffer((address) b);\n+  AddressLiteral buffer((address) b, external_word_Relocation::spec_for_immediate());\n@@ -11147,0 +11152,42 @@\n+\n+#ifdef _LP64\n+\/\/ Saves legacy GPRs state on stack.\n+void MacroAssembler::save_legacy_gprs() {\n+  subq(rsp, 16 * wordSize);\n+  movq(Address(rsp, 15 * wordSize), rax);\n+  movq(Address(rsp, 14 * wordSize), rcx);\n+  movq(Address(rsp, 13 * wordSize), rdx);\n+  movq(Address(rsp, 12 * wordSize), rbx);\n+  movq(Address(rsp, 10 * wordSize), rbp);\n+  movq(Address(rsp, 9 * wordSize), rsi);\n+  movq(Address(rsp, 8 * wordSize), rdi);\n+  movq(Address(rsp, 7 * wordSize), r8);\n+  movq(Address(rsp, 6 * wordSize), r9);\n+  movq(Address(rsp, 5 * wordSize), r10);\n+  movq(Address(rsp, 4 * wordSize), r11);\n+  movq(Address(rsp, 3 * wordSize), r12);\n+  movq(Address(rsp, 2 * wordSize), r13);\n+  movq(Address(rsp, wordSize), r14);\n+  movq(Address(rsp, 0), r15);\n+}\n+\n+\/\/ Resotres back legacy GPRs state from stack.\n+void MacroAssembler::restore_legacy_gprs() {\n+  movq(r15, Address(rsp, 0));\n+  movq(r14, Address(rsp, wordSize));\n+  movq(r13, Address(rsp, 2 * wordSize));\n+  movq(r12, Address(rsp, 3 * wordSize));\n+  movq(r11, Address(rsp, 4 * wordSize));\n+  movq(r10, Address(rsp, 5 * wordSize));\n+  movq(r9,  Address(rsp, 6 * wordSize));\n+  movq(r8,  Address(rsp, 7 * wordSize));\n+  movq(rdi, Address(rsp, 8 * wordSize));\n+  movq(rsi, Address(rsp, 9 * wordSize));\n+  movq(rbp, Address(rsp, 10 * wordSize));\n+  movq(rbx, Address(rsp, 12 * wordSize));\n+  movq(rdx, Address(rsp, 13 * wordSize));\n+  movq(rcx, Address(rsp, 14 * wordSize));\n+  movq(rax, Address(rsp, 15 * wordSize));\n+  addq(rsp, 16 * wordSize);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2226,0 +2226,5 @@\n+\n+#ifdef _LP64\n+  void save_legacy_gprs();\n+  void restore_legacy_gprs();\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -543,1 +543,2 @@\n-      assert(Register::number_of_registers == 16, \"sanity\");\n+      int num_regs = UseAPX ? 32 : 16;\n+      assert(Register::available_gp_registers() == num_regs, \"sanity\");\n@@ -546,1 +547,1 @@\n-        ls.print(\"%3s=\" PTR_FORMAT, r->name(), (intptr_t)(&saved_regs[16]));\n+        ls.print(\"%3s=\" PTR_FORMAT, r->name(), (intptr_t)(&saved_regs[num_regs]));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+#define XSAVE_AREA_EGPRS 960\n@@ -108,2 +109,2 @@\n-    fpu_state_off = frame::arg_reg_save_area_bytes\/BytesPerInt, \/\/ fxsave save area\n-    xmm_off       = fpu_state_off + XSAVE_AREA_BEGIN\/BytesPerInt,            \/\/ offset in fxsave save area\n+    fpu_state_off = frame::arg_reg_save_area_bytes\/BytesPerInt,    \/\/ fxsave save area\n+    xmm_off       = fpu_state_off + XSAVE_AREA_BEGIN\/BytesPerInt,  \/\/ offset in fxsave save area\n@@ -117,1 +118,18 @@\n-    opmask_off         = xmm_off + (XSAVE_AREA_OPMASK_BEGIN - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    r31_off = xmm_off + (XSAVE_AREA_EGPRS - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    r31H_off,\n+    r30_off, r30H_off,\n+    r29_off, r29H_off,\n+    r28_off, r28H_off,\n+    r27_off, r27H_off,\n+    r26_off, r26H_off,\n+    r25_off, r25H_off,\n+    r24_off, r24H_off,\n+    r23_off, r23H_off,\n+    r22_off, r22H_off,\n+    r21_off, r21H_off,\n+    r20_off, r20H_off,\n+    r19_off, r19H_off,\n+    r18_off, r18H_off,\n+    r17_off, r17H_off,\n+    r16_off, r16H_off,\n+    opmask_off   = xmm_off + (XSAVE_AREA_OPMASK_BEGIN - XSAVE_AREA_BEGIN)\/BytesPerInt,\n@@ -203,1 +221,7 @@\n-  __ push_CPU_state(); \/\/ Push a multiple of 16 bytes\n+  __ pushf();\n+  \/\/ Make sure rsp stays 16-byte aligned\n+  __ subq(rsp, 8);\n+  \/\/ Push CPU state in multiple of 16 bytes\n+  __ save_legacy_gprs();\n+  __ push_FPU_state();\n+\n@@ -251,0 +275,11 @@\n+\n+#if COMPILER2_OR_JVMCI\n+  if (UseAPX) {\n+      int base_addr = XSAVE_AREA_EGPRS;\n+      off = 0;\n+      for(int n = 16; n < Register::number_of_registers; n++) {\n+        __ movq(Address(rsp, base_addr+(off++*8)), as_Register(n));\n+      }\n+  }\n+#endif\n+\n@@ -283,0 +318,19 @@\n+\n+  if (UseAPX) {\n+    map->set_callee_saved(STACK_OFFSET( r16_off ), r16->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r17_off ), r17->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r18_off ), r18->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r19_off ), r19->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r20_off ), r20->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r21_off ), r21->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r22_off ), r22->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r23_off ), r23->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r24_off ), r24->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r25_off ), r25->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r26_off ), r26->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r27_off ), r27->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r28_off ), r28->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r29_off ), r29->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r30_off ), r30->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r31_off ), r31->as_VMReg());\n+  }\n@@ -343,0 +397,18 @@\n+    if (UseAPX) {\n+      map->set_callee_saved(STACK_OFFSET( r16H_off ), r16->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r17H_off ), r17->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r18H_off ), r18->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r19H_off ), r19->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r20H_off ), r20->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r21H_off ), r21->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r22H_off ), r22->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r23H_off ), r23->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r24H_off ), r24->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r25H_off ), r25->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r26H_off ), r26->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r27H_off ), r27->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r28H_off ), r28->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r29H_off ), r29->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r30H_off ), r30->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r31H_off ), r31->as_VMReg()->next());\n+    }\n@@ -432,0 +504,10 @@\n+#if COMPILER2_OR_JVMCI\n+  if (UseAPX) {\n+    int base_addr = XSAVE_AREA_EGPRS;\n+    int off = 0;\n+    for (int n = 16; n < Register::number_of_registers; n++) {\n+      __ movq(as_Register(n), Address(rsp, base_addr+(off++*8)));\n+    }\n+  }\n+#endif\n+\n@@ -433,1 +515,4 @@\n-  __ pop_CPU_state();\n+  __ pop_FPU_state();\n+  __ restore_legacy_gprs();\n+  __ addq(rsp, 8);\n+  __ popf();\n@@ -2820,0 +2905,3 @@\n+  if (UseAPX) {\n+    pad += 1024;\n+  }\n@@ -3368,1 +3456,1 @@\n-  CodeBuffer buffer(\"handler_blob\", 2048, 1024);\n+  CodeBuffer buffer(\"handler_blob\", 2348, 1024);\n@@ -3524,1 +3612,1 @@\n-  CodeBuffer buffer(name, 1200, 512);\n+  CodeBuffer buffer(name, 1552, 512);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":95,"deletions":7,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+#if defined(_LP64)\n@@ -118,1 +119,0 @@\n-    \/* FIXME Uncomment following code after OS enablement of\n@@ -127,1 +127,0 @@\n-    *\/\n@@ -131,0 +130,1 @@\n+#endif\n@@ -422,1 +422,1 @@\n-#ifndef PRODUCT\n+#if defined(_LP64)\n@@ -440,1 +440,0 @@\n-    \/* FIXME: Uncomment while integrating JDK-8329032\n@@ -446,1 +445,0 @@\n-    *\/\n@@ -453,1 +451,0 @@\n-    \/* FIXME: Uncomment after integration of JDK-8329032\n@@ -459,1 +456,0 @@\n-    *\/\n@@ -2173,0 +2169,1 @@\n+#if defined(_LP64)\n@@ -2176,0 +2173,1 @@\n+#endif\n@@ -2194,0 +2192,1 @@\n+#if defined(_LP64)\n@@ -2196,0 +2195,1 @@\n+#endif\n@@ -3186,0 +3186,3 @@\n+  \/\/ Enable APX support for product builds after\n+  \/\/ completion of planned features listed in JDK-8329030.\n+#if !defined(PRODUCT)\n@@ -3191,0 +3194,3 @@\n+#else\n+  return false;\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -131,0 +131,47 @@\n+reg_def R16  (SOC, SOC, Op_RegI, 16, r16->as_VMReg());\n+reg_def R16_H(SOC, SOC, Op_RegI, 16, r16->as_VMReg()->next());\n+\n+reg_def R17  (SOC, SOC, Op_RegI, 17, r17->as_VMReg());\n+reg_def R17_H(SOC, SOC, Op_RegI, 17, r17->as_VMReg()->next());\n+\n+reg_def R18  (SOC, SOC, Op_RegI, 18, r18->as_VMReg());\n+reg_def R18_H(SOC, SOC, Op_RegI, 18, r18->as_VMReg()->next());\n+\n+reg_def R19  (SOC, SOC, Op_RegI, 19, r19->as_VMReg());\n+reg_def R19_H(SOC, SOC, Op_RegI, 19, r19->as_VMReg()->next());\n+\n+reg_def R20  (SOC, SOC, Op_RegI, 20, r20->as_VMReg());\n+reg_def R20_H(SOC, SOC, Op_RegI, 20, r20->as_VMReg()->next());\n+\n+reg_def R21  (SOC, SOC, Op_RegI, 21, r21->as_VMReg());\n+reg_def R21_H(SOC, SOC, Op_RegI, 21, r21->as_VMReg()->next());\n+\n+reg_def R22  (SOC, SOC, Op_RegI, 22, r22->as_VMReg());\n+reg_def R22_H(SOC, SOC, Op_RegI, 22, r22->as_VMReg()->next());\n+\n+reg_def R23  (SOC, SOC, Op_RegI, 23, r23->as_VMReg());\n+reg_def R23_H(SOC, SOC, Op_RegI, 23, r23->as_VMReg()->next());\n+\n+reg_def R24  (SOC, SOC, Op_RegI, 24, r24->as_VMReg());\n+reg_def R24_H(SOC, SOC, Op_RegI, 24, r24->as_VMReg()->next());\n+\n+reg_def R25  (SOC, SOC, Op_RegI, 25, r25->as_VMReg());\n+reg_def R25_H(SOC, SOC, Op_RegI, 25, r25->as_VMReg()->next());\n+\n+reg_def R26  (SOC, SOC, Op_RegI, 26, r26->as_VMReg());\n+reg_def R26_H(SOC, SOC, Op_RegI, 26, r26->as_VMReg()->next());\n+\n+reg_def R27  (SOC, SOC, Op_RegI, 27, r27->as_VMReg());\n+reg_def R27_H(SOC, SOC, Op_RegI, 27, r27->as_VMReg()->next());\n+\n+reg_def R28  (SOC, SOC, Op_RegI, 28, r28->as_VMReg());\n+reg_def R28_H(SOC, SOC, Op_RegI, 28, r28->as_VMReg()->next());\n+\n+reg_def R29  (SOC, SOC, Op_RegI, 29, r29->as_VMReg());\n+reg_def R29_H(SOC, SOC, Op_RegI, 29, r29->as_VMReg()->next());\n+\n+reg_def R30  (SOC, SOC, Op_RegI, 30, r30->as_VMReg());\n+reg_def R30_H(SOC, SOC, Op_RegI, 30, r30->as_VMReg()->next());\n+\n+reg_def R31  (SOC, SOC, Op_RegI, 31, r31->as_VMReg());\n+reg_def R31_H(SOC, SOC, Op_RegI, 31, r31->as_VMReg()->next());\n@@ -157,0 +204,16 @@\n+                   R16,         R16_H,\n+                   R17,         R17_H,\n+                   R18,         R18_H,\n+                   R19,         R19_H,\n+                   R20,         R20_H,\n+                   R21,         R21_H,\n+                   R22,         R22_H,\n+                   R23,         R23_H,\n+                   R24,         R24_H,\n+                   R25,         R25_H,\n+                   R26,         R26_H,\n+                   R27,         R27_H,\n+                   R28,         R28_H,\n+                   R29,         R29_H,\n+                   R30,         R30_H,\n+                   R31,         R31_H,\n@@ -170,1 +233,1 @@\n-\/\/ Class for all pointer\/long registers\n+\/\/ Class for all pointer\/long registers including APX extended GPRs.\n@@ -186,3 +249,19 @@\n-                  R15, R15_H);\n-\n-\/\/ Class for all int registers\n+                  R15, R15_H,\n+                  R16, R16_H,\n+                  R17, R17_H,\n+                  R18, R18_H,\n+                  R19, R19_H,\n+                  R20, R20_H,\n+                  R21, R21_H,\n+                  R22, R22_H,\n+                  R23, R23_H,\n+                  R24, R24_H,\n+                  R25, R25_H,\n+                  R26, R26_H,\n+                  R27, R27_H,\n+                  R28, R28_H,\n+                  R29, R29_H,\n+                  R30, R30_H,\n+                  R31, R31_H);\n+\n+\/\/ Class for all int registers including APX extended GPRs.\n@@ -202,1 +281,17 @@\n-                      R14);\n+                      R14,\n+                      R16,\n+                      R17,\n+                      R18,\n+                      R19,\n+                      R20,\n+                      R21,\n+                      R22,\n+                      R23,\n+                      R24,\n+                      R25,\n+                      R26,\n+                      R27,\n+                      R28,\n+                      R29,\n+                      R30,\n+                      R31);\n@@ -389,0 +484,2 @@\n+  constexpr Register egprs[] = {r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31};\n+\n@@ -407,0 +504,6 @@\n+  if (!UseAPX) {\n+    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n+      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n+    }\n+  }\n@@ -423,0 +526,1 @@\n+\n@@ -444,0 +548,6 @@\n+  if (!UseAPX) {\n+    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n+      _INT_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+    }\n+  }\n+\n@@ -12574,1 +12684,0 @@\n-  size(4); \/* setting an explicit size will cause debug builds to assert if size is incorrect *\/\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":115,"deletions":6,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1481,1 +1481,2 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    MetaspaceShared::writing_error();\n+    return;\n@@ -1734,1 +1735,1 @@\n-    MetaspaceShared::unrecoverable_writing_error(\"Unable to write to shared archive file.\");\n+    MetaspaceShared::writing_error(\"Unable to write to shared archive file.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -449,0 +449,2 @@\n+  FileMapInfo* _map_info;\n+  StaticArchiveBuilder& _builder;\n@@ -459,1 +461,2 @@\n-  VM_PopulateDumpSharedSpace() : VM_Operation(), _heap_info() {}\n+  VM_PopulateDumpSharedSpace(StaticArchiveBuilder& b) :\n+    VM_Operation(), _heap_info(), _map_info(nullptr), _builder(b) {}\n@@ -464,0 +467,2 @@\n+  ArchiveHeapInfo* heap_info()  { return &_heap_info; }\n+  FileMapInfo* map_info() const { return _map_info; }\n@@ -520,3 +525,2 @@\n-  StaticArchiveBuilder builder;\n-  builder.gather_source_objs();\n-  builder.reserve_buffer();\n+  _builder.gather_source_objs();\n+  _builder.reserve_buffer();\n@@ -524,1 +528,1 @@\n-  CppVtables::dumptime_init(&builder);\n+  CppVtables::dumptime_init(&_builder);\n@@ -526,4 +530,4 @@\n-  builder.sort_metadata_objs();\n-  builder.dump_rw_metadata();\n-  builder.dump_ro_metadata();\n-  builder.relocate_metaspaceobj_embedded_pointers();\n+  _builder.sort_metadata_objs();\n+  _builder.dump_rw_metadata();\n+  _builder.dump_ro_metadata();\n+  _builder.relocate_metaspaceobj_embedded_pointers();\n@@ -531,2 +535,2 @@\n-  dump_java_heap_objects(builder.klasses());\n-  dump_shared_symbol_table(builder.symbols());\n+  dump_java_heap_objects(_builder.klasses());\n+  dump_shared_symbol_table(_builder.symbols());\n@@ -535,1 +539,1 @@\n-  builder.make_klasses_shareable();\n+  _builder.make_klasses_shareable();\n@@ -545,4 +549,0 @@\n-  \/\/ relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()\n-  \/\/ without runtime relocation.\n-  builder.relocate_to_requested();\n-\n@@ -552,15 +552,4 @@\n-  FileMapInfo* mapinfo = new FileMapInfo(static_archive, true);\n-  mapinfo->populate_header(MetaspaceShared::core_region_alignment());\n-  mapinfo->set_serialized_data(serialized_data);\n-  mapinfo->set_cloned_vtables(CppVtables::vtables_serialized_base());\n-  mapinfo->open_for_write();\n-  builder.write_archive(mapinfo, &_heap_info);\n-\n-  if (PrintSystemDictionaryAtExit) {\n-    SystemDictionary::print();\n-  }\n-\n-  if (AllowArchivingWithJavaAgent) {\n-    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-            \"for testing purposes only and should not be used in a production environment\");\n-  }\n+  _map_info = new FileMapInfo(static_archive, true);\n+  _map_info->populate_header(MetaspaceShared::core_region_alignment());\n+  _map_info->set_serialized_data(serialized_data);\n+  _map_info->set_cloned_vtables(CppVtables::vtables_serialized_base());\n@@ -668,2 +657,1 @@\n-void MetaspaceShared::preload_and_dump() {\n-  EXCEPTION_MARK;\n+void MetaspaceShared::preload_and_dump(TRAPS) {\n@@ -671,1 +659,2 @@\n-  preload_and_dump_impl(THREAD);\n+  StaticArchiveBuilder builder;\n+  preload_and_dump_impl(builder, THREAD);\n@@ -676,2 +665,1 @@\n-      CLEAR_PENDING_EXCEPTION;\n-      MetaspaceShared::unrecoverable_writing_error();\n+      MetaspaceShared::writing_error();\n@@ -681,2 +669,1 @@\n-      CLEAR_PENDING_EXCEPTION;\n-      MetaspaceShared::unrecoverable_writing_error(\"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+      MetaspaceShared::writing_error(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n@@ -773,1 +760,1 @@\n-void MetaspaceShared::preload_and_dump_impl(TRAPS) {\n+void MetaspaceShared::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n@@ -810,1 +797,1 @@\n-  VM_PopulateDumpSharedSpace op;\n+  VM_PopulateDumpSharedSpace op(builder);\n@@ -812,0 +799,22 @@\n+\n+  if (!write_static_archive(&builder, op.map_info(), op.heap_info())) {\n+    THROW_MSG(vmSymbols::java_io_IOException(), \"Encountered error while dumping\");\n+  }\n+}\n+\n+bool MetaspaceShared::write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info) {\n+  \/\/ relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()\n+  \/\/ without runtime relocation.\n+  builder->relocate_to_requested();\n+\n+  map_info->open_for_write();\n+  if (!map_info->is_open()) {\n+    return false;\n+  }\n+  builder->write_archive(map_info, heap_info);\n+\n+  if (AllowArchivingWithJavaAgent) {\n+    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+            \"for testing purposes only and should not be used in a production environment\");\n+  }\n+  return true;\n@@ -925,0 +934,7 @@\n+  writing_error(message);\n+  vm_direct_exit(1);\n+}\n+\n+\/\/ This function is called when the JVM is unable to write the specified CDS archive due to a\n+\/\/ an error. The error will be propagated\n+void MetaspaceShared::writing_error(const char* message) {\n@@ -929,1 +945,0 @@\n-  vm_direct_exit(1);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":56,"deletions":41,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+class ArchiveBuilder;\n+class ArchiveHeapInfo;\n@@ -37,0 +39,1 @@\n+class StaticArchiveBuilder;\n@@ -69,1 +72,1 @@\n-  static void preload_and_dump() NOT_CDS_RETURN;\n+  static void preload_and_dump(TRAPS) NOT_CDS_RETURN;\n@@ -75,1 +78,1 @@\n-  static void preload_and_dump_impl(TRAPS) NOT_CDS_RETURN;\n+  static void preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n@@ -108,0 +111,1 @@\n+  static void writing_error(const char* message = nullptr);\n@@ -169,0 +173,1 @@\n+  static bool write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,3 +183,2 @@\n-    if ((UseEmptySlotsInSupers && !super_klass->has_contended_annotations()) || !_super_has_fields) {\n-      _start = _blocks; \/\/ Setting _start to _blocks instead of _last would allow subclasses\n-      \/\/ to allocate fields in empty slots of their super classes\n+    if ((!super_klass->has_contended_annotations()) || !_super_has_fields) {\n+      _start = _blocks;  \/\/ start allocating fields from the first empty block\n@@ -440,13 +439,1 @@\n-  if (!UseEmptySlotsInSupers) {\n-    \/\/ Add an empty slots to align fields of the subclass on a heapOopSize boundary\n-    \/\/ in order to emulate the behavior of the previous algorithm\n-    int align = (b->offset() + b->size()) % heapOopSize;\n-    if (align != 0) {\n-      int sz = heapOopSize - align;\n-      LayoutRawBlock* p = new LayoutRawBlock(LayoutRawBlock::EMPTY, sz);\n-      p->set_offset(b->offset() + b->size());\n-      b->set_next_block(p);\n-      p->set_prev_block(b);\n-      b = p;\n-    }\n-  }\n+\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -793,1 +793,1 @@\n-\n+int java_lang_Class::_init_lock_offset;\n@@ -917,0 +917,6 @@\n+  \/\/ Allocate a simple java object for a lock.\n+  \/\/ This needs to be a java object because during class initialization\n+  \/\/ it can be held across a java call.\n+  typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);\n+  set_init_lock(mirror(), r);\n+\n@@ -1148,0 +1154,4 @@\n+    \/\/ create the init_lock\n+    typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));\n+    set_init_lock(mirror(), r);\n+\n@@ -1212,0 +1222,9 @@\n+oop java_lang_Class::init_lock(oop java_class) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  return java_class->obj_field(_init_lock_offset);\n+}\n+void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_init_lock_offset, init_lock);\n+}\n+\n@@ -1437,0 +1456,5 @@\n+  \/\/ Init lock is a C union with component_mirror.  Only instanceKlass mirrors have\n+  \/\/ init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops\n+  \/\/ GC treats them the same.\n+  _init_lock_offset = _component_mirror_offset;\n+\n@@ -1443,0 +1467,1 @@\n+  f->do_u4((u4*)&_init_lock_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,1 @@\n+  static int _init_lock_offset;\n@@ -244,0 +245,1 @@\n+  static void set_init_lock(oop java_class, oop init_lock);\n@@ -299,0 +301,4 @@\n+  static oop  init_lock(oop java_class);\n+  static void clear_init_lock(oop java_class) {\n+    set_init_lock(java_class, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -535,2 +535,2 @@\n-  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n-  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+  do_name(intPolyMult_name, \"multImpl\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)V\")                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+  template(int_array_signature,                       \"[I\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -858,4 +858,2 @@\n-    if (bs_nm->is_armed(nm)) {\n-      bool alive = bs_nm->nmethod_entry_barrier(nm);\n-      assert(alive, \"should be alive\");\n-    }\n+    bool alive = bs_nm->nmethod_entry_barrier(nm);\n+    assert(alive, \"should be alive\");\n@@ -3659,0 +3657,9 @@\n+        case relocInfo::entry_guard_type:      return \"entry_guard\";\n+        case relocInfo::post_call_nop_type:    return \"post_call_nop\";\n+        case relocInfo::barrier_type: {\n+          barrier_Relocation* const reloc = iter.barrier_reloc();\n+          stringStream st;\n+          st.print(\"barrier format=%d\", reloc->format());\n+          return st.as_string();\n+        }\n+\n@@ -3661,2 +3668,5 @@\n-        default:\n-          break;\n+        default: {\n+          stringStream st;\n+          st.print(\"unknown relocInfo=%d\", (int) iter.type());\n+          return st.as_string();\n+        }\n@@ -4034,0 +4044,1 @@\n+  ExternalsRecorder::print_statistics();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -726,0 +726,1 @@\n+  void copy_values(GrowableArray<address>* metadata) {} \/\/ Nothing to do\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+    mem_zap_start_padding(mem);\n@@ -403,0 +404,14 @@\n+void ObjArrayAllocator::mem_zap_start_padding(HeapWord* mem) const {\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t header_size_in_bytes = arrayOopDesc::header_size_in_bytes();\n+\n+  const address base = reinterpret_cast<address>(mem) + base_offset_in_bytes;\n+  const address header_end = reinterpret_cast<address>(mem) + header_size_in_bytes;\n+\n+  if (header_end < base) {\n+    const size_t padding_in_bytes = base - header_end;\n+    Copy::fill_to_bytes(header_end, padding_in_bytes, heapPaddingByteVal);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  void mem_zap_start_padding(HeapWord* mem) const PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -155,0 +155,2 @@\n+  static void load_barrier_on_oop_array(volatile zpointer* p, size_t length);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,0 +143,2 @@\n+  mem_zap_start_padding(mem);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-  if (klass->is_being_initialized() && klass->is_init_thread(THREAD)) {\n+  if (klass->is_being_initialized() && klass->is_reentrant_initialization(THREAD)) {\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1831,1 +1831,1 @@\n-  \/\/ a lock to do the final serialization of updates\n+  \/\/ an ObjectLocker to do the final serialization of updates\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -595,3 +595,5 @@\n-void OopMapCache::trigger_cleanup() {\n-  if (has_cleanup_work()) {\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+void OopMapCache::try_trigger_cleanup() {\n+  \/\/ See we can take the lock for the notification without blocking.\n+  \/\/ This allows triggering the cleanup from GC paths, that can hold\n+  \/\/ the service lock for e.g. oop iteration in service thread.\n+  if (has_cleanup_work() && Service_lock->try_lock_without_rank_check()) {\n@@ -599,0 +601,1 @@\n+    Service_lock->unlock();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1301,0 +1301,4 @@\n+  if (pd_relocate(pc, id)) {\n+    return;\n+  }\n+\n@@ -1336,6 +1340,0 @@\n-    case POLL_NEAR:\n-    case POLL_FAR:\n-    case POLL_RETURN_NEAR:\n-    case POLL_RETURN_FAR:\n-      pd_relocate_poll(pc, id, JVMCI_CHECK);\n-      break;\n@@ -1356,0 +1354,1 @@\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1211,4 +1211,12 @@\n-  JVMCINMethodHandle nmethod_handle(THREAD);\n-  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n-  if (nm == nullptr || !nm->is_in_use()) {\n-    JVMCI_THROW_NULL(InvalidInstalledCodeException);\n+  methodHandle mh;\n+  {\n+    \/\/ Reduce the scope of JVMCINMethodHandle so that it isn't alive across the Java call.  Once the\n+    \/\/ nmethod has been validated and the method is fetched from the nmethod it's fine for the\n+    \/\/ nmethod to be reclaimed if necessary.\n+    JVMCINMethodHandle nmethod_handle(THREAD);\n+    nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n+    if (nm == nullptr || !nm->is_in_use()) {\n+      JVMCI_THROW_NULL(InvalidInstalledCodeException);\n+    }\n+    methodHandle nmh(THREAD, nm->method());\n+    mh = nmh;\n@@ -1216,1 +1224,0 @@\n-  methodHandle mh(THREAD, nm->method());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n@@ -49,0 +50,6 @@\n+#if INCLUDE_ZGC\n+#include \"gc\/x\/xBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n+#endif\n@@ -69,0 +76,1 @@\n+  AARCH64_ONLY(static_field(CompilerToVM::Data, BarrierSetAssembler_patching_epoch_addr, address))                                   \\\n@@ -79,0 +87,4 @@\n+  static_field(CompilerToVM::Data,             ZPointerVectorLoadBadMask_address, address)                                           \\\n+  static_field(CompilerToVM::Data,             ZPointerVectorStoreBadMask_address, address)                                          \\\n+  static_field(CompilerToVM::Data,             ZPointerVectorStoreGoodMask_address, address)                                         \\\n+                                                                                                                                     \\\n@@ -112,0 +124,1 @@\n+  ZGC_ONLY(static_field(CompilerToVM::Data,    sizeof_ZStoreBarrierEntry,              int))                                         \\\n@@ -790,1 +803,6 @@\n-#define VM_ADDRESSES(declare_address, declare_preprocessor_address, declare_function) \\\n+\/\/ Helper macro to support ZGC pattern where the function itself isn't exported\n+#define DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, name) \\\n+  declare_function_with_value(name, name##_addr())\n+\n+\n+#define VM_ADDRESSES(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -807,0 +825,20 @@\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_field_preloaded))                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded))              \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded))            \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded))         \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_array))                                \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::clone))                                                    \\\n+                                                                                                                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded))                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded))              \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_store_good))           \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_load_barrier_on_weak_oop_field_preloaded))    \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_load_barrier_on_phantom_oop_field_preloaded)) \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing))        \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_oop_field_with_healing))                  \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_oop_field_without_healing))               \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_array))                                \\\n+                                                                          \\\n@@ -857,0 +895,26 @@\n+#if INCLUDE_ZGC\n+\n+#define VM_INT_CONSTANTS_JVMCI_ZGC(declare_constant, declare_constant_with_value, declare_preprocessor_constant)                           \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_good_mask_offset\" , in_bytes(ZThreadLocalData::store_good_mask_offset()))           \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_bad_mask_offset\" , in_bytes(ZThreadLocalData::store_bad_mask_offset()))             \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_barrier_buffer_offset\" , in_bytes(ZThreadLocalData::store_barrier_buffer_offset())) \\\n+  declare_constant_with_value(\"ZStoreBarrierBuffer::current_offset\" , in_bytes(ZStoreBarrierBuffer::current_offset()))                     \\\n+  declare_constant_with_value(\"ZStoreBarrierBuffer::buffer_offset\" , in_bytes(ZStoreBarrierBuffer::buffer_offset()))                       \\\n+  declare_constant_with_value(\"ZStoreBarrierEntry::p_offset\" , in_bytes(ZStoreBarrierEntry::p_offset()))                                   \\\n+  declare_constant_with_value(\"ZStoreBarrierEntry::prev_offset\" , in_bytes(ZStoreBarrierEntry::prev_offset()))                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_SHL))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_BAD_AFTER_TEST))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_AFTER_TEST))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_CMP))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_AFTER_TEST))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_OR))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_MOV))                                            \\\n+  AARCH64_ONLY(declare_constant(ZPointerLoadShift))                                                                                        \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_TB_X))                                         \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_BEFORE_MOV))                                           \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_BEFORE_MOV))                                         \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_BEFORE_MOV))\n+\n+#endif \/\/ INCLUDE_ZGC\n+\n+\n@@ -859,1 +923,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function) \\\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -867,1 +931,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function) \\\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -918,1 +982,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function)\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value)\n@@ -925,0 +989,4 @@\n+#define GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY(name, value) \\\n+  { QUOTE(name), CAST_FROM_FN_PTR(void*, value) },\n+\n+\n@@ -975,0 +1043,5 @@\n+#if INCLUDE_ZGC\n+  VM_INT_CONSTANTS_JVMCI_ZGC(GENERATE_VM_INT_CONSTANT_ENTRY,\n+                              GENERATE_VM_INT_CONSTANT_WITH_VALUE_ENTRY,\n+                              GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+#endif\n@@ -1000,1 +1073,2 @@\n-               GENERATE_VM_FUNCTION_ENTRY)\n+               GENERATE_VM_FUNCTION_ENTRY,\n+               GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY)\n@@ -1003,1 +1077,2 @@\n-                  GENERATE_VM_FUNCTION_ENTRY)\n+                  GENERATE_VM_FUNCTION_ENTRY,\n+                  GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":81,"deletions":6,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -177,1 +178,1 @@\n-             method->method_holder()->is_init_thread(JavaThread::current()),\n+             method->method_holder()->is_reentrant_initialization(JavaThread::current()),\n@@ -273,0 +274,1 @@\n+\n@@ -275,2 +277,10 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n-  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle resolved_references(current, constant_pool()->resolved_references());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n+\n+  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -315,1 +325,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n@@ -591,1 +600,8 @@\n-  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = THREAD;\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -614,1 +630,11 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n+\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = JavaThread::current();\n+  constantPoolHandle cp(current, constant_pool());\n+\n+  objArrayHandle resolved_references(current, cp->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -618,1 +644,1 @@\n-    return constant_pool()->resolved_reference_from_indy(index);\n+    return cp->resolved_reference_from_indy(index);\n@@ -626,3 +652,1 @@\n-    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-    constantPoolHandle cp(THREAD, constant_pool());\n-    ConstantPool::throw_resolution_error(cp, encoded_index, THREAD);\n+    ConstantPool::throw_resolution_error(cp, encoded_index, current);\n@@ -652,1 +676,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":34,"deletions":11,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -547,3 +548,0 @@\n-static Monitor* create_init_monitor(const char* name) {\n-  return new Monitor(Mutex::safepoint, name);\n-}\n@@ -567,1 +565,0 @@\n-  _init_monitor(create_init_monitor(\"InstanceKlassInitMonitor_lock\")),\n@@ -819,0 +816,22 @@\n+oop InstanceKlass::init_lock() const {\n+  \/\/ return the init lock from the mirror\n+  oop lock = java_lang_Class::init_lock(java_mirror());\n+  \/\/ Prevent reordering with any access of initialization state\n+  OrderAccess::loadload();\n+  assert(lock != nullptr || !is_not_initialized(), \/\/ initialized or in_error state\n+         \"only fully initialized state can have a null lock\");\n+  return lock;\n+}\n+\n+\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n+\/\/ threads to get this lock will see a null lock and will not lock.\n+\/\/ That's okay because they all check for initialized state after getting\n+\/\/ the lock and return.\n+void InstanceKlass::fence_and_clear_init_lock() {\n+  \/\/ make sure previous stores are all done, notably the init_state.\n+  OrderAccess::storestore();\n+  java_lang_Class::clear_init_lock(java_mirror());\n+  assert(!is_not_initialized(), \"class must be initialized now\");\n+}\n+\n+\n@@ -846,43 +865,0 @@\n-void InstanceKlass::check_link_state_and_wait(JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n-\n-  \/\/ Another thread is linking this class, wait.\n-  while (is_being_linked() && !is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" waiting for linking of %s by thread \\\"%s\\\"\",\n-                             current->name(), external_name(), init_thread_name());\n-    }\n-    ml.wait();\n-  }\n-\n-  \/\/ This thread is recursively linking this class, continue\n-  if (is_being_linked() && is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" recursively linking %s\",\n-                             current->name(), external_name());\n-    }\n-    return;\n-  }\n-\n-  \/\/ If this class wasn't linked already, set state to being_linked\n-  if (!is_linked()) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" linking %s\",\n-                             current->name(), external_name());\n-    }\n-    set_init_state(being_linked);\n-    set_init_thread(current);\n-  } else {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" found %s already linked\",\n-                             current->name(), external_name());\n-      }\n-  }\n-}\n-\n@@ -1069,2 +1045,3 @@\n-    LockLinkState init_lock(this, jt);\n-\n+    HandleMark hm(THREAD);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1128,1 +1105,15 @@\n-      set_initialization_state_and_notify(linked, THREAD);\n+      if (UseVtableBasedCHA && Universe::is_fully_initialized()) {\n+        DeoptimizationScope deopt_scope;\n+        {\n+          \/\/ Now mark all code that assumes the class is not linked.\n+          \/\/ Set state under the Compile_lock also.\n+          MutexLocker ml(THREAD, Compile_lock);\n+\n+          set_init_state(linked);\n+          CodeCache::mark_dependents_on(&deopt_scope, this);\n+        }\n+        \/\/ Perform the deopt handshake outside Compile_lock.\n+        deopt_scope.deoptimize_marked();\n+      } else {\n+        set_init_state(linked);\n+      }\n@@ -1260,1 +1251,0 @@\n-  bool throw_error = false;\n@@ -1269,1 +1259,2 @@\n-    MonitorLocker ml(jt, _init_monitor);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1272,1 +1263,4 @@\n-    while (is_being_initialized() && !is_init_thread(jt)) {\n+    \/\/ If we were to use wait() instead of waitInterruptibly() then\n+    \/\/ we might end up throwing IE from link\/symbol resolution sites\n+    \/\/ that aren't expected to throw.  This would wreak havoc.  See 6320309.\n+    while (is_being_initialized() && !is_reentrant_initialization(jt)) {\n@@ -1278,1 +1272,0 @@\n-\n@@ -1281,1 +1274,1 @@\n-      ml.wait();\n+      ol.wait_uninterruptibly(jt);\n@@ -1286,1 +1279,1 @@\n-    if (is_being_initialized() && is_init_thread(jt)) {\n+    if (is_being_initialized() && is_reentrant_initialization(jt)) {\n@@ -1314,1 +1307,13 @@\n-      throw_error = true;\n+\n+      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n+      ResourceMark rm(THREAD);\n+      Handle cause(THREAD, get_initialization_error(THREAD));\n+\n+      stringStream ss;\n+      ss.print(\"Could not initialize class %s\", external_name());\n+      if (cause.is_null()) {\n+        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n+      } else {\n+        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                        ss.as_string(), cause);\n+      }\n@@ -1328,16 +1333,0 @@\n-  \/\/ Throw error outside lock\n-  if (throw_error) {\n-    DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n-    ResourceMark rm(THREAD);\n-    Handle cause(THREAD, get_initialization_error(THREAD));\n-\n-    stringStream ss;\n-    ss.print(\"Could not initialize class %s\", external_name());\n-    if (cause.is_null()) {\n-      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n-    } else {\n-      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n-                      ss.as_string(), cause);\n-    }\n-  }\n-\n@@ -1452,1 +1441,1 @@\n-    set_initialization_state_and_notify(fully_initialized, THREAD);\n+    set_initialization_state_and_notify(fully_initialized, CHECK);\n@@ -1485,17 +1474,8 @@\n-void InstanceKlass::set_initialization_state_and_notify(ClassState state, JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  if (state == linked && UseVtableBasedCHA && Universe::is_fully_initialized()) {\n-    DeoptimizationScope deopt_scope;\n-    {\n-      \/\/ Now mark all code that assumes the class is not linked.\n-      \/\/ Set state under the Compile_lock also.\n-      MutexLocker ml(current, Compile_lock);\n-\n-      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-      set_init_state(state);\n-\n-      CodeCache::mark_dependents_on(&deopt_scope, this);\n-    }\n-    \/\/ Perform the deopt handshake outside Compile_lock.\n-    deopt_scope.deoptimize_marked();\n+void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {\n+  Handle h_init_lock(THREAD, init_lock());\n+  if (h_init_lock() != nullptr) {\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+    set_init_state(state);\n+    fence_and_clear_init_lock();\n+    ol.notify_all(CHECK);\n@@ -1503,0 +1483,1 @@\n+    assert(h_init_lock() != nullptr, \"The initialization state should never be set twice\");\n@@ -1506,1 +1487,0 @@\n-  ml.notify_all();\n@@ -1511,1 +1491,1 @@\n-void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n+void InstanceKlass::add_to_hierarchy_impl(JavaThread* current) {\n@@ -1514,8 +1494,0 @@\n-  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n-  \/\/ deopt is completed before anyone links this class.\n-  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n-  \/\/ held we make sure the deopt is completed before linking.\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->lock();\n-  }\n-\n@@ -1543,0 +1515,14 @@\n+}\n+\n+void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n+\n+  if (UseVtableBasedCHA || !Universe::is_fully_initialized()) {\n+    add_to_hierarchy_impl(current);\n+  } else {\n+    \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n+    \/\/ deopt is completed before anyone links this class.\n+    \/\/ Linking is done with init_lock held, by loading and deopting with it\n+    \/\/ held we make sure the deopt is completed before linking.\n+    Handle h_init_lock(current, init_lock());\n+    ObjectLocker ol(h_init_lock, current);\n+    add_to_hierarchy_impl(current);\n@@ -1544,2 +1530,1 @@\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->unlock();\n+    \/\/ This doesn't need a notify because the wait is only on the class initialization path.\n@@ -1549,0 +1534,1 @@\n+\n@@ -2829,1 +2815,0 @@\n-  _init_monitor = nullptr;\n@@ -2937,3 +2922,0 @@\n-\n-  \/\/ restore the monitor\n-  _init_monitor = create_init_monitor(\"InstanceKlassInitMonitorRestored_lock\");\n@@ -3035,3 +3017,0 @@\n-  \/\/ Destroy the init_monitor\n-  delete _init_monitor;\n-\n@@ -3731,1 +3710,1 @@\n-  \"allocated\", \"loaded\", \"being_linked\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n+  \"allocated\", \"loaded\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n@@ -3828,5 +3807,3 @@\n-  if (default_vtable_indices() != nullptr) {\n-    st->print(BULLET\"default vtable indices:   \"); print_array_on(st, default_vtable_indices());\n-  }\n-  st->print(BULLET\"local interfaces:  \"); print_array_on(st, local_interfaces());\n-  st->print(BULLET\"trans. interfaces: \"); print_array_on(st, transitive_interfaces());\n+  print_on_maybe_null(st, BULLET\"default vtable indices:   \", default_vtable_indices());\n+  st->print(BULLET\"local interfaces:  \"); local_interfaces()->print_value_on(st);      st->cr();\n+  st->print(BULLET\"trans. interfaces: \"); transitive_interfaces()->print_value_on(st); st->cr();\n@@ -3857,10 +3834,3 @@\n-  if (class_loader_data() != nullptr) {\n-    st->print(BULLET\"class loader data:  \");\n-    class_loader_data()->print_value_on(st);\n-    st->cr();\n-  }\n-  if (source_file_name() != nullptr) {\n-    st->print(BULLET\"source file:       \");\n-    source_file_name()->print_value_on(st);\n-    st->cr();\n-  }\n+\n+  print_on_maybe_null(st, BULLET\"class loader data:  \", class_loader_data());\n+  print_on_maybe_null(st, BULLET\"source file:       \", source_file_name());\n@@ -3872,4 +3842,4 @@\n-  st->print(BULLET\"class annotations:       \"); class_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"class type annotations:  \"); class_type_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"field annotations:       \"); fields_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"field type annotations:  \"); fields_type_annotations()->print_value_on(st); st->cr();\n+  print_on_maybe_null(st, BULLET\"class annotations:       \", class_annotations());\n+  print_on_maybe_null(st, BULLET\"class type annotations:  \", class_type_annotations());\n+  print_on_maybe_null(st, BULLET\"field annotations:       \", fields_annotations());\n+  print_on_maybe_null(st, BULLET\"field type annotations:  \", fields_type_annotations());\n@@ -3890,5 +3860,1 @@\n-  if (generic_signature() != nullptr) {\n-    st->print(BULLET\"generic signature: \");\n-    generic_signature()->print_value_on(st);\n-    st->cr();\n-  }\n+  print_on_maybe_null(st, BULLET\"generic signature: \", generic_signature());\n@@ -3897,3 +3863,1 @@\n-  if (record_components() != nullptr) {\n-    st->print(BULLET\"record components:     \"); record_components()->print_value_on(st);     st->cr();\n-  }\n+  print_on_maybe_null(st, BULLET\"record components:     \", record_components());\n@@ -4405,3 +4369,0 @@\n-  if (state > loaded) {\n-    assert_lock_strong(_init_monitor);\n-  }\n@@ -4411,2 +4372,1 @@\n-  bool link_failed = _init_state == being_linked && state == loaded;\n-  assert(good_state || state == allocated || link_failed, \"illegal state transition\");\n+  assert(good_state || state == allocated, \"illegal state transition\");\n@@ -4415,1 +4375,1 @@\n-  Atomic::store(&_init_state, state);\n+  _init_state = state;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":104,"deletions":144,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-    being_linked,                       \/\/ currently running verifier and rewriter\n@@ -251,0 +250,7 @@\n+  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n+  \/\/ _misc_flags.\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n+\n+  \/\/ Class states are defined as ClassState (see above).\n+  \/\/ Place the _init_state here to utilize the unused 2-byte after\n+  \/\/ _idnum_allocated_count.\n@@ -253,1 +259,1 @@\n-  u1              _reference_type;          \/\/ reference type\n+  u1              _reference_type;                \/\/ reference type\n@@ -258,1 +264,0 @@\n-  Monitor*             _init_monitor;       \/\/ mutual exclusion to _init_state and _init_thread.\n@@ -558,2 +563,0 @@\n-  \/\/ We can safely access the name as long as we hold the _init_monitor.\n-    assert(_init_monitor->owned_by_self(), \"Must hold _init_monitor here\");\n@@ -566,9 +569,8 @@\n-  bool is_loaded() const                   { return init_state() >= loaded; }\n-  bool is_linked() const                   { return init_state() >= linked; }\n-  bool is_being_linked() const             { return init_state() == being_linked; }\n-  bool is_initialized() const              { return init_state() == fully_initialized; }\n-  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n-  bool is_being_initialized() const        { return init_state() == being_initialized; }\n-  bool is_in_error_state() const           { return init_state() == initialization_error; }\n-  bool is_init_thread(JavaThread *thread)  { return thread == init_thread(); }\n-  ClassState  init_state() const           { return Atomic::load(&_init_state); }\n+  bool is_loaded() const                   { return _init_state >= loaded; }\n+  bool is_linked() const                   { return _init_state >= linked; }\n+  bool is_initialized() const              { return _init_state == fully_initialized; }\n+  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n+  bool is_being_initialized() const        { return _init_state == being_initialized; }\n+  bool is_in_error_state() const           { return _init_state == initialization_error; }\n+  bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }\n+  ClassState  init_state() const           { return _init_state; }\n@@ -578,15 +580,0 @@\n-  class LockLinkState : public StackObj {\n-    InstanceKlass* _ik;\n-    JavaThread*    _current;\n-   public:\n-    LockLinkState(InstanceKlass* ik, JavaThread* current) : _ik(ik), _current(current) {\n-      ik->check_link_state_and_wait(current);\n-    }\n-    ~LockLinkState() {\n-      if (!_ik->is_linked()) {\n-        \/\/ Reset to loaded if linking failed.\n-        _ik->set_initialization_state_and_notify(loaded, _current);\n-      }\n-    }\n-  };\n-\n@@ -893,1 +880,1 @@\n-  void set_initialization_state_and_notify(ClassState state, JavaThread* current);\n+  void set_initialization_state_and_notify(ClassState state, TRAPS);\n@@ -905,0 +892,4 @@\n+ private:\n+  void add_to_hierarchy_impl(JavaThread* current);\n+\n+ public:\n@@ -1139,1 +1130,1 @@\n- private:\n+private:\n@@ -1156,0 +1147,6 @@\n+  \/\/ Lock for (1) initialization; (2) access to the ConstantPool of this class.\n+  \/\/ Must be one per class and it has to be a VM internal object so java code\n+  \/\/ cannot lock it (like the mirror).\n+  \/\/ It has to be an object not a Mutex because it's held through java calls.\n+  oop init_lock() const;\n+\n@@ -1165,3 +1162,2 @@\n-\n-  Monitor* init_monitor() const { return _init_monitor; }\n-  void check_link_state_and_wait(JavaThread* current);\n+  void fence_and_clear_init_lock();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":30,"deletions":34,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1795,1 +1795,1 @@\n-      QuickSort::sort(methods->data(), length, func, \/*idempotent=*\/false);\n+      QuickSort::sort(methods->data(), length, func);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2172,0 +2172,16 @@\n+\/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+bool AbstractLockNode::is_balanced() {\n+  Node* obj = obj_node();\n+  for (uint j = 0; j < obj->outcnt(); j++) {\n+    Node* n = obj->raw_out(j);\n+    if (n->is_AbstractLock() &&\n+        n->as_AbstractLock()->obj_node()->eqv_uncast(obj)) {\n+      BoxLockNode* n_box = n->as_AbstractLock()->box_node()->as_BoxLock();\n+      if (n_box->is_unbalanced()) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2279,0 +2295,2 @@\n+            tty->print(\"Obj: \");\n+            obj_node()->dump();\n@@ -2287,0 +2305,2 @@\n+              tty->print(\"Box %d: \", i);\n+              box_node()->dump();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1203,0 +1203,4 @@\n+  \/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+  \/\/ They can become unbalanced after coarsening optimization or on OSR entry.\n+  bool is_balanced();\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+enum class AssertionPredicateType;\n@@ -331,0 +332,13 @@\n+ public:\n+  float _prob;                           \/\/ Probability of true path being taken.\n+  float _fcnt;                           \/\/ Frequency counter\n+\n+ private:\n+  NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+\n+  void init_node(Node* control, Node* bol) {\n+    init_class_id(Class_If);\n+    init_req(0, control);\n+    init_req(1, bol);\n+  }\n+\n@@ -335,1 +349,0 @@\n-private:\n@@ -426,8 +439,2 @@\n-  float _prob;                  \/\/ Probability of true path being taken.\n-  float _fcnt;                  \/\/ Frequency counter\n-  IfNode( Node *control, Node *b, float p, float fcnt )\n-    : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {\n-    init_class_id(Class_If);\n-    init_req(0,control);\n-    init_req(1,b);\n-  }\n+  IfNode(Node* control, Node* bol, float p, float fcnt);\n+  NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n@@ -465,1 +472,1 @@\n-  int is_range_check(Node* &range, Node* &index, jint &offset);\n+  int is_range_check(Node*& range, Node*& index, jint& offset);\n@@ -468,2 +475,7 @@\n-  RangeCheckNode(Node* control, Node *b, float p, float fcnt)\n-    : IfNode(control, b, p, fcnt) {\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt) : IfNode(control, bol, p, fcnt) {\n+    init_class_id(Class_RangeCheck);\n+  }\n+\n+#ifndef PRODUCT\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+      : IfNode(control, bol, p, fcnt, assertion_predicate_type) {\n@@ -472,0 +484,1 @@\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3585,2 +3585,1 @@\n-  BoxLockNode* box = alock->box_node()->as_BoxLock();\n-  if (!box->is_unbalanced() && not_global_escape(alock->obj_node())) {\n+  if (alock->is_balanced() && not_global_escape(alock->obj_node())) {\n@@ -3590,1 +3589,1 @@\n-      box->set_local();\n+      alock->box_node()->as_BoxLock()->set_local();\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,18 @@\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt)\n+      NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+  init_node(control, bol);\n+}\n+\n+#ifndef PRODUCT\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt),\n+      _assertion_predicate_type(assertion_predicate_type) {\n+  init_node(control, bol);\n+}\n+#endif \/\/ NOT_PRODUCT\n+\n@@ -1842,3 +1860,15 @@\n-\/\/------------------------------dump_spec--------------------------------------\n-void IfNode::dump_spec(outputStream *st) const {\n-  st->print(\"P=%f, C=%f\",_prob,_fcnt);\n+void IfNode::dump_spec(outputStream* st) const {\n+  switch (_assertion_predicate_type) {\n+    case AssertionPredicateType::Init_value:\n+      st->print(\"#Init Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::Last_value:\n+      st->print(\"#Last Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::None:\n+      \/\/ No Assertion Predicate\n+      break;\n+    default:\n+      fatal(\"Unknown Assertion Predicate type\");\n+  }\n+  st->print(\"P=%f, C=%f\", _prob, _fcnt);\n@@ -1846,1 +1876,1 @@\n-#endif\n+#endif \/\/ NOT PRODUCT\n@@ -2201,0 +2231,3 @@\n+  if (_useless) {\n+    st->print(\"#useless \");\n+  }\n@@ -2202,1 +2235,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -7971,2 +7971,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n@@ -8072,1 +8070,1 @@\n-    state = get_state_from_digest_object(digestBase_obj, T_BYTE);\n+    state = get_state_from_digest_object(digestBase_obj, T_LONG);\n@@ -8172,1 +8170,1 @@\n-      elem_type = T_BYTE;\n+      elem_type = T_LONG;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -125,1 +125,3 @@\n-  virtual void dump_spec(outputStream *st) const { st->print(\"  Lock %d\",_slot); }\n+  virtual void dump_spec(outputStream *st) const {\n+    st->print(\"  Lock slot: %d, Kind: %s\", _slot, _kind_name[(int)_kind]);\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1347,3 +1347,4 @@\n-  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                          Deoptimization::DeoptReason reason, int opcode,\n-                                          bool rewire_uncommon_proj_phi_inputs = false);\n+  IfTrueNode* create_new_if_for_predicate(\n+      ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n+      bool rewire_uncommon_proj_phi_inputs = false\n+      NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n@@ -1385,1 +1386,1 @@\n-  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+  IfTrueNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n@@ -1389,3 +1390,4 @@\n-  Node* add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* predicate_proj, int scale_con,\n-                                                        Node* offset, Node* limit, int stride_con, Node* value,\n-                                                        bool is_template);\n+  void eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj, IfTrueNode* template_assertion_predicate_proj);\n+  Node* add_range_check_elimination_assertion_predicate(\n+      IdealLoopTree* loop, Node* predicate_proj, int scale_con, Node* offset, Node* limit, int stride_con, Node* value,\n+      bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n@@ -1545,0 +1547,1 @@\n+  void rewire_safe_outputs_to_dominator(Node* source, Node* dominator, bool pin_array_access_nodes);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -350,1 +350,3 @@\n-  if (iff->outcnt() != 2) return;\n+  if (iff->outcnt() != 2) {\n+    return;\n+  }\n@@ -357,1 +359,1 @@\n-  if (dp == nullptr)\n+  if (dp == nullptr) {\n@@ -359,0 +361,4 @@\n+  }\n+\n+  rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n+}\n@@ -360,1 +366,2 @@\n-  IdealLoopTree* old_loop = get_loop(dp);\n+void PhaseIdealLoop::rewire_safe_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n+  IdealLoopTree* old_loop = get_loop(source);\n@@ -362,2 +369,2 @@\n-  for (DUIterator_Fast imax, i = dp->fast_outs(imax); i < imax; i++) {\n-    Node* cd = dp->fast_out(i); \/\/ Control-dependent node\n+  for (DUIterator_Fast imax, i = source->fast_outs(imax); i < imax; i++) {\n+    Node* out = source->fast_out(i); \/\/ Control-dependent node\n@@ -365,3 +372,3 @@\n-    if (cd->depends_only_on_test() && _igvn.no_dependent_zero_check(cd)) {\n-      assert(cd->in(0) == dp, \"\");\n-      _igvn.replace_input_of(cd, 0, prevdom);\n+    if (out->depends_only_on_test() && _igvn.no_dependent_zero_check(out)) {\n+      assert(out->in(0) == source, \"must be control dependent on source\");\n+      _igvn.replace_input_of(out, 0, dominator);\n@@ -375,1 +382,1 @@\n-        Node* clone = cd->pin_array_access_node();\n+        Node* clone = out->pin_array_access_node();\n@@ -377,3 +384,3 @@\n-          clone = _igvn.register_new_node_with_optimizer(clone, cd);\n-          _igvn.replace_node(cd, clone);\n-          cd = clone;\n+          clone = _igvn.register_new_node_with_optimizer(clone, out);\n+          _igvn.replace_node(out, clone);\n+          out = clone;\n@@ -382,2 +389,2 @@\n-      set_early_ctrl(cd, false);\n-      IdealLoopTree* new_loop = get_loop(get_ctrl(cd));\n+      set_early_ctrl(out, false);\n+      IdealLoopTree* new_loop = get_loop(get_ctrl(out));\n@@ -386,1 +393,1 @@\n-          old_loop->_body.yank(cd);\n+          old_loop->_body.yank(out);\n@@ -389,1 +396,1 @@\n-          new_loop->_body.push(cd);\n+          new_loop->_body.push(out);\n@@ -809,3 +816,11 @@\n-  \/\/ Ignore cost if CMOVE can be moved outside the loop.\n-  if (used_inside_loop && cost >= ConditionalMoveLimit) {\n-    return nullptr;\n+  float infrequent_prob = PROB_UNLIKELY_MAG(3);\n+  \/\/ Ignore cost and blocks frequency if CMOVE can be moved outside the loop.\n+  if (used_inside_loop) {\n+    if (cost >= ConditionalMoveLimit) return nullptr; \/\/ Too much goo\n+\n+    \/\/ BlockLayoutByFrequency optimization moves infrequent branch\n+    \/\/ from hot path. No point in CMOV'ing in such case (110 is used\n+    \/\/ instead of 100 to take into account not exactness of float value).\n+    if (BlockLayoutByFrequency) {\n+      infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage\/110.0f);\n+    }\n@@ -815,1 +830,0 @@\n-  constexpr float infrequent_prob = PROB_UNLIKELY_MAG(2);\n@@ -818,1 +832,2 @@\n-  } else if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n+  } else if (iff->_prob < infrequent_prob ||\n+      iff->_prob > (1.0f - infrequent_prob))\n@@ -820,1 +835,0 @@\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2225,1 +2225,1 @@\n-  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+  if (!alock->is_balanced()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1444,2 +1444,2 @@\n-  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n-  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n@@ -1464,1 +1464,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 Red Hat, Inc.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 Red Hat, Inc.\n@@ -3872,1 +3872,1 @@\n-  JavaThread* thread = new JavaThread(true);\n+  JavaThread* thread = JavaThread::create_attaching_thread();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  { \"UseEmptySlotsInSupers\",        JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"LockingMode\",                  JDK_Version::jdk(24), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n@@ -517,0 +517,1 @@\n+  { \"UseEmptySlotsInSupers\",        JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1989,4 +1989,0 @@\n-  product(bool, UseEmptySlotsInSupers, true,                                \\\n-          \"(Deprecated) Allow allocating fields in empty slots of \"         \\\n-          \"super-classes\")                                                  \\\n-                                                                            \\\n@@ -2002,3 +1998,3 @@\n-          \"Select locking mode: \"                                           \\\n-          \"0: monitors only (LM_MONITOR), \"                                 \\\n-          \"1: monitors & legacy stack-locking (LM_LEGACY), \"                \\\n+          \"(Deprecated) Select locking mode: \"                              \\\n+          \"0: (Deprecated) monitors only (LM_MONITOR), \"                    \\\n+          \"1: (Deprecated) monitors & legacy stack-locking (LM_LEGACY), \"   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,1 +192,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n+  HandleArea(MEMFLAGS flags, HandleArea* prev) : Arena(flags, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+void ExternalsRecorder_init(); \/\/ After mutex_init() and before CodeCache_init\n@@ -110,0 +111,1 @@\n+  ExternalsRecorder_init(); \/\/ After mutex_init() and before CodeCache_init\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -413,1 +413,2 @@\n-JavaThread::JavaThread() :\n+JavaThread::JavaThread(MEMFLAGS flags) :\n+  Thread(flags),\n@@ -415,1 +416,0 @@\n-\n@@ -529,4 +529,4 @@\n-JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n-  if (is_attaching_via_jni) {\n-    _jni_attach_state = _attaching_via_jni;\n-  }\n+JavaThread* JavaThread::create_attaching_thread() {\n+  JavaThread* jt = new JavaThread();\n+  jt->_jni_attach_state = _attaching_via_jni;\n+  return jt;\n@@ -535,1 +535,0 @@\n-\n@@ -638,2 +637,1 @@\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n-  _jni_attach_state = _not_attaching_via_jni;\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MEMFLAGS flags) : JavaThread(flags) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,3 +482,2 @@\n-  JavaThread();                            \/\/ delegating constructor\n-  JavaThread(bool is_attaching_via_jni);   \/\/ for main thread and JNI attached threads\n-  JavaThread(ThreadFunction entry_point, size_t stack_size = 0);\n+  JavaThread(MEMFLAGS flags = mtThread);   \/\/ delegating constructor\n+  JavaThread(ThreadFunction entry_point, size_t stack_size = 0, MEMFLAGS flags = mtThread);\n@@ -487,0 +486,3 @@\n+  \/\/ Factory method to create a new JavaThread whose attach state is \"is attaching\"\n+  static JavaThread* create_attaching_thread();\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1383,1 +1383,1 @@\n-           callee_method->method_holder()->is_init_thread(current),\n+           callee_method->method_holder()->is_reentrant_initialization(current),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -860,0 +860,10 @@\n+void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {\n+  if (millis < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n+  }\n+  ObjectSynchronizer::inflate(THREAD,\n+                              obj(),\n+                              inflate_cause_wait)->wait(millis, false, THREAD);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -822,1 +822,1 @@\n-    MetaspaceShared::preload_and_dump();\n+    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -2171,1 +2172,0 @@\n-  declare_constant(InstanceKlass::being_linked)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1229,0 +1229,8 @@\n+  \/\/ Also provide a pointer to the init_lock if present, so there aren't unreferenced int[0]\n+  \/\/ arrays.\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    field_count++;\n+    size += sizeof(address);\n+  }\n+\n@@ -1268,0 +1276,8 @@\n+\n+  \/\/ Add init lock to the end if the class is not yet initialized\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    writer->write_symbolID(vmSymbols::init_lock_name());         \/\/ name\n+    writer->write_u1(sig2tag(vmSymbols::int_array_signature())); \/\/ type\n+    writer->write_objectID(init_lock);\n+  }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -42,0 +43,1 @@\n+import java.util.function.Consumer;\n@@ -69,0 +71,2 @@\n+    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n+    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -616,56 +620,61 @@\n-            return ClassFile.of().build(classDesc, clb -> {\n-                clb.withFlags(ACC_FINAL | ACC_SUPER)\n-                   .withSuperclass(superClassDesc)\n-                   .with(SourceFileAttribute.of(classDesc.displayName()))\n-\n-                \/\/ emit static types and BMH_SPECIES fields\n-                   .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n-\n-                \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n-                class Var {\n-                    final int index;\n-                    final String name;\n-                    final Class<?> type;\n-                    final ClassDesc desc;\n-                    final BasicType basicType;\n-                    final int slotIndex;\n-                    Var(int index, int slotIndex) {\n-                        this.index = index;\n-                        this.slotIndex = slotIndex;\n-                        name = null; type = null; desc = null;\n-                        basicType = BasicType.V_TYPE;\n-                    }\n-                    Var(String name, Class<?> type, Var prev) {\n-                        int slotIndex = prev.nextSlotIndex();\n-                        int index = prev.nextIndex();\n-                        if (name == null)  name = \"x\";\n-                        if (name.endsWith(\"#\"))\n-                            name = name.substring(0, name.length()-1) + index;\n-                        assert(!type.equals(void.class));\n-                        this.index = index;\n-                        this.name = name;\n-                        this.type = type;\n-                        this.desc = classDesc(type);\n-                        this.basicType = BasicType.basicType(type);\n-                        this.slotIndex = slotIndex;\n-                    }\n-                    Var lastOf(List<Var> vars) {\n-                        int n = vars.size();\n-                        return (n == 0 ? this : vars.get(n-1));\n-                    }\n-                    <X> List<Var> fromTypes(List<X> types) {\n-                        Var prev = this;\n-                        ArrayList<Var> result = new ArrayList<>(types.size());\n-                        int i = 0;\n-                        for (X x : types) {\n-                            String vn = name;\n-                            Class<?> vt;\n-                            if (x instanceof Class<?> cl) {\n-                                vt = cl;\n-                                \/\/ make the names friendlier if debugging\n-                                assert((vn = vn + \"_\" + (i++)) != null);\n-                            } else {\n-                                @SuppressWarnings(\"unchecked\")\n-                                Var v = (Var) x;\n-                                vn = v.name;\n-                                vt = v.type;\n+            return ClassFile.of().build(classDesc, new Consumer<ClassBuilder>() {\n+                @Override\n+                public void accept(ClassBuilder clb) {\n+                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                       .withSuperclass(superClassDesc)\n+                       .with(SourceFileAttribute.of(classDesc.displayName()))\n+\n+                    \/\/ emit static types and BMH_SPECIES fields\n+                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+\n+                    \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n+                    class Var {\n+                        final int index;\n+                        final String name;\n+                        final Class<?> type;\n+                        final ClassDesc desc;\n+                        final BasicType basicType;\n+                        final int slotIndex;\n+                        Var(int index, int slotIndex) {\n+                            this.index = index;\n+                            this.slotIndex = slotIndex;\n+                            name = null; type = null; desc = null;\n+                            basicType = BasicType.V_TYPE;\n+                        }\n+                        Var(String name, Class<?> type, Var prev) {\n+                            int slotIndex = prev.nextSlotIndex();\n+                            int index = prev.nextIndex();\n+                            if (name == null)  name = \"x\";\n+                            if (name.endsWith(\"#\"))\n+                                name = name.substring(0, name.length()-1) + index;\n+                            assert(!type.equals(void.class));\n+                            this.index = index;\n+                            this.name = name;\n+                            this.type = type;\n+                            this.desc = classDesc(type);\n+                            this.basicType = BasicType.basicType(type);\n+                            this.slotIndex = slotIndex;\n+                        }\n+                        Var lastOf(List<Var> vars) {\n+                            int n = vars.size();\n+                            return (n == 0 ? this : vars.get(n-1));\n+                        }\n+                        <X> List<Var> fromTypes(List<X> types) {\n+                            Var prev = this;\n+                            ArrayList<Var> result = new ArrayList<>(types.size());\n+                            int i = 0;\n+                            for (X x : types) {\n+                                String vn = name;\n+                                Class<?> vt;\n+                                if (x instanceof Class<?> cl) {\n+                                    vt = cl;\n+                                    \/\/ make the names friendlier if debugging\n+                                    assert((vn = vn + \"_\" + (i++)) != null);\n+                                } else {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Var v = (Var) x;\n+                                    vn = v.name;\n+                                    vt = v.type;\n+                                }\n+                                prev = new Var(vn, vt, prev);\n+                                result.add(prev);\n@@ -673,2 +682,1 @@\n-                            prev = new Var(vn, vt, prev);\n-                            result.add(prev);\n+                            return result;\n@@ -676,48 +684,7 @@\n-                        return result;\n-                    }\n-\n-                    int slotSize() { return basicType.basicTypeSlots(); }\n-                    int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n-                    int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n-                    boolean isInHeap() { return slotIndex < 0; }\n-                    void emitLoadInstruction(CodeBuilder cob) {\n-                        cob.loadLocal(basicType.btKind, slotIndex);\n-                    }\n-                }\n-\n-                final Var NO_THIS = new Var(0, 0),\n-                        AFTER_THIS = new Var(0, 1),\n-                        IN_HEAP = new Var(0, -1);\n-\n-                \/\/ figure out the field types\n-                final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n-                final List<Var> fields = new ArrayList<>(fieldTypes.size());\n-                {\n-                    Var nextF = IN_HEAP;\n-                    for (Class<?> ft : fieldTypes) {\n-                        String fn = chooseFieldName(ft, nextF.nextIndex());\n-                        nextF = new Var(fn, ft, nextF);\n-                        fields.add(nextF);\n-                    }\n-                }\n-\n-                \/\/ emit bound argument fields\n-                for (Var field : fields) {\n-                    clb.withField(field.name, field.desc, ACC_FINAL);\n-                }\n-\n-                \/\/ emit implementation of speciesData()\n-                clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                        cob -> cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                                  .areturn());\n-                \/\/ figure out the constructor arguments\n-                MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n-                MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n-\n-                \/\/ emit constructor\n-                clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE, cob -> {\n-                    cob.aload(0); \/\/ this\n-\n-                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n-                    for (Var ca : ctorArgs) {\n-                        ca.emitLoadInstruction(cob);\n+                        int slotSize() { return basicType.basicTypeSlots(); }\n+                        int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n+                        int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n+                        boolean isInHeap() { return slotIndex < 0; }\n+                        void emitLoadInstruction(CodeBuilder cob) {\n+                            cob.loadLocal(basicType.btKind, slotIndex);\n+                        }\n@@ -727,11 +694,14 @@\n-                    \/\/ super(ca...)\n-                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n-\n-                    \/\/ store down fields\n-                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n-                    for (Var f : fields) {\n-                        \/\/ this.argL1 = argL1\n-                        cob.aload(0);  \/\/ this\n-                        lastFV = new Var(f.name, f.type, lastFV);\n-                        lastFV.emitLoadInstruction(cob);\n-                        cob.putfield(classDesc, f.name, f.desc);\n+                    final Var NO_THIS = new Var(0, 0),\n+                            AFTER_THIS = new Var(0, 1),\n+                            IN_HEAP = new Var(0, -1);\n+\n+                    \/\/ figure out the field types\n+                    final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n+                    final List<Var> fields = new ArrayList<>(fieldTypes.size());\n+                    {\n+                        Var nextF = IN_HEAP;\n+                        for (Class<?> ft : fieldTypes) {\n+                            String fn = chooseFieldName(ft, nextF.nextIndex());\n+                            nextF = new Var(fn, ft, nextF);\n+                            fields.add(nextF);\n+                        }\n@@ -740,12 +710,3 @@\n-                    cob.return_();\n-                });\n-\n-                \/\/ emit make()  ...factory method wrapping constructor\n-                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n-                clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC, cob -> {\n-                    \/\/ make instance\n-                    cob.new_(classDesc)\n-                       .dup();\n-                    \/\/ load factory method arguments:  ctarg... and arg...\n-                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n-                        v.emitLoadInstruction(cob);\n+                    \/\/ emit bound argument fields\n+                    for (Var field : fields) {\n+                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n@@ -754,40 +715,7 @@\n-                    \/\/ finally, invoke the constructor and return\n-                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n-                       .areturn();\n-                });\n-\n-                \/\/ For each transform, emit the customized override of the transform method.\n-                \/\/ This method mixes together some incoming arguments (from the transform's\n-                \/\/ static type signature) with the field types themselves, and passes\n-                \/\/ the resulting mish-mosh of values to a method handle produced by\n-                \/\/ the species itself.  (Typically this method handle is the factory\n-                \/\/ method of this species or a related one.)\n-                for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n-                    final int whichtm = i;\n-                    final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n-                    final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n-                    final int        TMODS = TRANSFORM_MODS.get(whichtm);\n-                    clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, mb -> {\n-                        mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n-                          .withCode(cob -> {\n-                            \/\/ return a call to the corresponding \"transform helper\", something like this:\n-                            \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n-                            cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                               .loadConstant(whichtm)\n-                               .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n-\n-                            List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n-                            List<Var> tfields = new ArrayList<>(fields);\n-                            \/\/ mix them up and load them for the transform helper:\n-                            List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n-                            ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n-                            for (int hi = 0; hi < helperTypes.length; hi++) {\n-                                Var ha = helperArgs.get(hi);\n-                                helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n-                                if (ha.isInHeap()) {\n-                                    assert(tfields.contains(ha));\n-                                    cob.aload(0);\n-                                    cob.getfield(classDesc, ha.name, ha.desc);\n-                                } else {\n-                                    assert(targs.contains(ha));\n-                                    ha.emitLoadInstruction(cob);\n+                    \/\/ emit implementation of speciesData()\n+                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                            .areturn();\n@@ -795,10 +723,108 @@\n-                            }\n-\n-                            \/\/ jump into the helper (which is probably a factory method)\n-                            final Class<?> rtype = TTYPE.returnType();\n-                            if (!rtype.isPrimitive()) {\n-                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n-                                   .checkcast(classDesc(rtype))\n-                                   .areturn();\n-                            } else {\n-                                throw newInternalError(\"NYI: transform of type \"+rtype);\n+                            }));\n+\n+                    \/\/ figure out the constructor arguments\n+                    MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n+                    MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n+\n+                    \/\/ emit constructor\n+                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.aload(0); \/\/ this\n+\n+                                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n+                                    for (Var ca : ctorArgs) {\n+                                        ca.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ super(ca...)\n+                                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n+\n+                                    \/\/ store down fields\n+                                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n+                                    for (Var f : fields) {\n+                                        \/\/ this.argL1 = argL1\n+                                        cob.aload(0);  \/\/ this\n+                                        lastFV = new Var(f.name, f.type, lastFV);\n+                                        lastFV.emitLoadInstruction(cob);\n+                                        cob.putfield(classDesc, f.name, f.desc);\n+                                    }\n+\n+                                    cob.return_();\n+                                }\n+                            }));\n+\n+                    \/\/ emit make()  ...factory method wrapping constructor\n+                    MethodType ftryType = thisCtorType.changeReturnType(topClass());\n+                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    \/\/ make instance\n+                                    cob.new_(classDesc)\n+                                            .dup();\n+                                    \/\/ load factory method arguments:  ctarg... and arg...\n+                                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n+                                        v.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ finally, invoke the constructor and return\n+                                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n+                                            .areturn();\n+                                }\n+                            }));\n+\n+                    \/\/ For each transform, emit the customized override of the transform method.\n+                    \/\/ This method mixes together some incoming arguments (from the transform's\n+                    \/\/ static type signature) with the field types themselves, and passes\n+                    \/\/ the resulting mish-mosh of values to a method handle produced by\n+                    \/\/ the species itself.  (Typically this method handle is the factory\n+                    \/\/ method of this species or a related one.)\n+                    for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n+                        final int whichtm = i;\n+                        final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n+                        final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n+                        final int        TMODS = TRANSFORM_MODS.get(whichtm);\n+                        clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, new Consumer<MethodBuilder>() {\n+                            @Override\n+                            public void accept(MethodBuilder mb) {\n+                                mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n+                                  .withCode(new Consumer<CodeBuilder>() {\n+                                    @Override\n+                                    public void accept(CodeBuilder cob) {\n+                                        \/\/ return a call to the corresponding \"transform helper\", something like this:\n+                                        \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n+                                        cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                                .loadConstant(whichtm)\n+                                                .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n+\n+                                        List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n+                                        List<Var> tfields = new ArrayList<>(fields);\n+                                        \/\/ mix them up and load them for the transform helper:\n+                                        List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n+                                        ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n+                                        for (int hi = 0; hi < helperTypes.length; hi++) {\n+                                            Var ha = helperArgs.get(hi);\n+                                            helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n+                                            if (ha.isInHeap()) {\n+                                                assert(tfields.contains(ha));\n+                                                cob.aload(0);\n+                                                cob.getfield(classDesc, ha.name, ha.desc);\n+                                            } else {\n+                                                assert(targs.contains(ha));\n+                                                ha.emitLoadInstruction(cob);\n+                                            }\n+                                        }\n+\n+                                        \/\/ jump into the helper (which is probably a factory method)\n+                                        final Class<?> rtype = TTYPE.returnType();\n+                                        if (!rtype.isPrimitive()) {\n+                                            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n+                                                    .checkcast(classDesc(rtype))\n+                                                    .areturn();\n+                                        } else {\n+                                            throw newInternalError(\"NYI: transform of type \"+rtype);\n+                                        }\n+                                    }\n+                                });\n@@ -807,1 +833,1 @@\n-                    });\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":206,"deletions":180,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -517,2 +517,1 @@\n-        List<ProxyMethod> sigmethods = proxyMethods.computeIfAbsent(sig,\n-                _ -> new ArrayList<>(3));\n+        List<ProxyMethod> sigmethods = proxyMethodsFor(sig);\n@@ -540,0 +539,4 @@\n+    private List<ProxyMethod> proxyMethodsFor(String sig) {\n+        return proxyMethods.computeIfAbsent(sig, _ -> new ArrayList<>(3));\n+    }\n+\n@@ -546,4 +549,1 @@\n-        String sig = pm.shortSignature;\n-        List<ProxyMethod> sigmethods = proxyMethods.computeIfAbsent(sig,\n-                _ -> new ArrayList<>(3));\n-        sigmethods.add(pm);\n+        proxyMethodsFor(pm.shortSignature).add(pm);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4678,3 +4678,0 @@\n-            if (pt.isErroneous()) {\n-                return types.createErrorType(site);\n-            }\n@@ -4789,0 +4786,4 @@\n+            if (pt.isErroneous()) {\n+                owntype = types.createErrorType(owntype);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -38,0 +40,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -39,0 +42,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n@@ -65,0 +69,3 @@\n+\n+import javax.lang.model.type.TypeKind;\n+\n@@ -107,0 +114,1 @@\n+    private int variableIndex = 0;\n@@ -176,0 +184,5 @@\n+    \/**\n+     * The current expected return type.\n+     *\/\n+    Type currentRestype;\n+\n@@ -192,6 +205,0 @@\n-    \/** A map from local variable symbols to their translation (as per LambdaToMethod).\n-     * This is required when a capturing local class is created from a lambda (in which\n-     * case the captured symbols should be replaced with the translated lambda symbols).\n-     *\/\n-    Map<Symbol, Symbol> lambdaTranslationMap = null;\n-\n@@ -1244,8 +1251,4 @@\n-            if (lambdaTranslationMap != null && lambdaTranslationMap.get(sym) != null) {\n-                return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));\n-            } else {\n-                \/\/ Otherwise replace the variable by its proxy.\n-                sym = proxies.get(sym);\n-                Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n-                tree = make.at(tree.pos).Ident(sym);\n-            }\n+            \/\/ Otherwise replace the variable by its proxy.\n+            sym = proxies.get(sym);\n+            Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n+            tree = make.at(tree.pos).Ident(sym);\n@@ -1336,8 +1339,0 @@\n-            } else if (sym.owner.kind == MTH && lambdaTranslationMap != null) {\n-                \/\/sym is a local variable - check the lambda translation map to\n-                \/\/see if sym has been translated to something else in the current\n-                \/\/scope (by LambdaToMethod)\n-                Symbol translatedSym = lambdaTranslationMap.get(sym.baseSymbol());\n-                if (translatedSym != null) {\n-                    tree = make.at(tree.pos).Ident(translatedSym);\n-                }\n@@ -2790,0 +2785,1 @@\n+        Type prevRestype = currentRestype;\n@@ -2792,0 +2788,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -2793,0 +2790,1 @@\n+            currentRestype = types.erasure(tree.type.getReturnType());\n@@ -2795,0 +2793,1 @@\n+            variableIndex = 0;\n@@ -2797,0 +2796,1 @@\n+            currentRestype = prevRestype;\n@@ -2799,0 +2799,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -2877,10 +2878,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap =\n-                    lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = (tree.sym.flags() & SYNTHETIC) != 0 &&\n-                        tree.sym.name.startsWith(names.lambda) ?\n-                        makeTranslationMap(tree) : null;\n-                super.visitMethodDef(tree);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            super.visitMethodDef(tree);\n@@ -2918,11 +2910,0 @@\n-    \/\/where\n-        private Map<Symbol, Symbol> makeTranslationMap(JCMethodDecl tree) {\n-            Map<Symbol, Symbol> translationMap = new HashMap<>();\n-            for (JCVariableDecl vd : tree.params) {\n-                Symbol p = vd.sym;\n-                if (p != p.baseSymbol()) {\n-                    translationMap.put(p.baseSymbol(), p);\n-                }\n-            }\n-            return translationMap;\n-        }\n@@ -2990,1 +2971,1 @@\n-                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -3160,7 +3141,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap = lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = null;\n-                translate(tree.def);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            translate(tree.def);\n@@ -3386,0 +3361,3 @@\n+        if (tree.args.stream().anyMatch(c -> c == null)) {\n+            throw new AssertionError(\"Whooops before: \" + tree);\n+        }\n@@ -3873,0 +3851,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -3882,3 +3861,7 @@\n-        if (tree.init != null) tree.init = translate(tree.init, tree.type);\n-        result = tree;\n-        currentMethodSym = oldMethodSym;\n+        try {\n+            if (tree.init != null) tree.init = translate(tree.init, tree.type);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3896,2 +3879,8 @@\n-        super.visitBlock(tree);\n-        currentMethodSym = oldMethodSym;\n+        int prevVariableIndex = variableIndex;\n+        try {\n+            variableIndex = 0;\n+            super.visitBlock(tree);\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3924,2 +3913,1 @@\n-                                  types.erasure(currentMethodDef\n-                                                .restype.type));\n+                                  currentRestype);\n@@ -3929,0 +3917,345 @@\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        Type prevRestype = currentRestype;\n+        try {\n+            currentRestype = types.erasure(tree.getDescriptorType(types)).getReturnType();\n+            tree.body = tree.getBodyKind() == BodyKind.EXPRESSION ?\n+                    translate((JCExpression) tree.body, currentRestype) :\n+                    translate(tree.body);\n+        } finally {\n+            currentRestype = prevRestype;\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+    \/\/ where\n+        boolean needsVarArgsConversion(JCMemberReference tree) {\n+            return tree.varargsElement != null;\n+        }\n+\n+        \/**\n+         * @return Is this an array operation like clone()\n+         *\/\n+        boolean isArrayOp(JCMemberReference tree) {\n+            return tree.sym.owner == syms.arrayClass;\n+        }\n+\n+        boolean receiverAccessible(JCMemberReference tree) {\n+            \/\/hack needed to workaround 292 bug (7087658)\n+            \/\/when 292 issue is fixed we should remove this and change the backend\n+            \/\/code to always generate a method handle to an accessible method\n+            return tree.ownerAccessible;\n+        }\n+\n+        \/**\n+         * Erasure destroys the implementation parameter subtype\n+         * relationship for intersection types.\n+         * Have similar problems for union types too.\n+         *\/\n+        boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+            List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+            for (; tl.nonEmpty(); tl = tl.tail) {\n+                Type pt = tl.head;\n+                if (isIntersectionOrUnionType(pt))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        boolean isIntersectionOrUnionType(Type t) {\n+            switch (t.getKind()) {\n+                case INTERSECTION:\n+                case UNION:\n+                    return true;\n+                case TYPEVAR:\n+                    TypeVar tv = (TypeVar) t;\n+                    return isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            return false;\n+        }\n+\n+        private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                              Symbol currentClass) {\n+            return ((targetReference.flags() & PROTECTED) != 0 &&\n+                    targetReference.packge() != currentClass.packge());\n+        }\n+\n+        \/**\n+         * This method should be called only when target release <= 14\n+         * where LambdaMetaFactory does not spin nestmate classes.\n+         *\n+         * This method should be removed when --release 14 is not supported.\n+         *\/\n+        boolean isPrivateInOtherClass(JCMemberReference tree) {\n+            assert !target.runtimeUseNestAccess();\n+            return  (tree.sym.flags() & PRIVATE) != 0 &&\n+                    !types.isSameType(\n+                            types.erasure(tree.sym.enclClass().asType()),\n+                            types.erasure(currentClass.asType()));\n+        }\n+\n+        \/**\n+         * Does this reference need to be converted to a lambda\n+         * (i.e. var args need to be expanded or \"super\" is used)\n+         *\/\n+        boolean needsConversionToLambda(JCMemberReference tree) {\n+            return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                    tree.hasKind(ReferenceKind.SUPER) ||\n+                    needsVarArgsConversion(tree) ||\n+                    isArrayOp(tree) ||\n+                    (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass) ||\n+                    !receiverAccessible(tree) ||\n+                    (tree.getMode() == ReferenceMode.NEW &&\n+                            tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                            (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+        }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, currentClass);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, translate(receiverExpression)), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            Type samDesc = types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n+            List<Type> samPTypes = samDesc.getParameterTypes();\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n+                    samPTypes = samPTypes.tail;\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = samPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            \/\/ Failsafe -- assure match-up\n+            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n+\n+            \/\/ Use parameter types of the implementation method unless the unerased\n+            \/\/ SAM parameter type is an intersection type, in that case use the\n+            \/\/ erased SAM parameter type so that the supertype relationship\n+            \/\/ the implementation method parameters is not obscured.\n+            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n+            \/\/ are used as pointers to the current parameter type information\n+            \/\/ and are thus not usable afterwards.\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = implPTypes.head;\n+                if (checkForIntersection) {\n+                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n+                        parmType = samPTypes.head;\n+                    }\n+                    \/\/ If the unerased parameter type is a type variable whose\n+                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n+                    \/\/ use the SAM parameter type\n+                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n+                        TypeVar tv = (TypeVar) descPTypes.head;\n+                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n+                            parmType = samPTypes.head;\n+                        }\n+                    }\n+                }\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                samPTypes = samPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        private JCExpression makeReceiver(VarSymbol rcvr) {\n+            if (rcvr == null) return null;\n+            JCExpression rcvrExpr = make.Ident(rcvr);\n+            boolean protAccess =\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass);\n+            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n+                    : tree.expr.type;\n+            if (rcvrType == syms.arrayClass.type) {\n+                \/\/ Map the receiver type to the actually type, not just \"array\"\n+                rcvrType = tree.getQualifierExpression().type;\n+            }\n+            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n+                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n+            }\n+            return rcvrExpr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            makeReceiver(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.sym.erasure(types);\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n+                    setType(tree.sym.erasure(types).getReturnType());\n+\n+            apply = transTypes.coerce(attrEnv, apply,\n+                    types.erasure(tree.referentType.getReturnType()));\n+\n+            setVarargsIfNeeded(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                setVarargsIfNeeded(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n+    \/**\n+     * Convert method\/constructor arguments by inserting appropriate cast\n+     * as required by type-erasure - this is needed when bridging a lambda\/method\n+     * reference, as the bridged signature might require downcast to be compatible\n+     * with the generated signature.\n+     *\/\n+    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n+        Assert.check(meth.kind == MTH);\n+        List<Type> formals = types.erasure(meth.type).getParameterTypes();\n+        if (varargsElement != null) {\n+            Assert.check((meth.flags() & VARARGS) != 0);\n+        }\n+        return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n+    }\n+\n+    \/**\n+     * Set varargsElement field on a given tree (must be either a new class tree\n+     * or a method call tree)\n+     *\/\n+    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n+        if (varargsElement != null) {\n+            switch (tree.getTag()) {\n+                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n+                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n+                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n+                default: throw new AssertionError();\n+            }\n+        }\n+    }\n+\n@@ -4046,1 +4379,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4203,1 +4536,1 @@\n-                                               names.fromString(\"s\" + tree.pos + target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4209,1 +4542,1 @@\n-                                                 names.fromString(\"tmp\" + tree.pos + target.syntheticNameChar()),\n+                                                 names.fromString(\"tmp\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4351,1 +4684,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4409,1 +4742,1 @@\n-        if (tree.name == names._class) {\n+        if (tree.name == names._class && tree.selected.type.isPrimitiveOrVoid()) {\n@@ -4485,0 +4818,1 @@\n+            currentRestype = null;\n@@ -4514,0 +4848,1 @@\n+            currentRestype = null;\n@@ -4533,0 +4868,19 @@\n+\n+    \/\/ needed for the lambda deserialization method, which is expressed as a big switch on strings\n+    public JCMethodDecl translateMethod(Env<AttrContext> env, JCMethodDecl methodDecl, TreeMaker make) {\n+        try {\n+            this.attrEnv = env;\n+            this.make = make;\n+            this.currentClass = methodDecl.sym.enclClass();\n+            proxies = new HashMap<>();\n+            return translate(methodDecl);\n+        } finally {\n+            this.attrEnv = null;\n+            this.make = null;\n+            this.currentClass = null;\n+            \/\/ the two fields below are set when visiting the method\n+            this.currentMethodSym = null;\n+            this.currentMethodDef = null;\n+            this.proxies = null;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":417,"deletions":63,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-                        for (var flag : info.flags()) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n@@ -451,1 +451,1 @@\n-                    flags.flags().stream().map(fl -> \"ACC_\" + fl.toString()).toList(),\n+                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.toString()).toList(),\n@@ -483,1 +483,1 @@\n-        for (var f : AccessFlags.ofMethod(flags).flags())\n+        for (var f : flagsReportUnknown(m.flags()))\n@@ -566,1 +566,1 @@\n-            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+            for (var f : flagsReportUnknown(m.flags())) {\n@@ -799,3 +799,3 @@\n-    private static Set<String> getClassModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n+    private Set<String> getClassModifiers(int mask) {\n+        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask)));\n@@ -814,8 +814,0 @@\n-    private static Set<String> getMethodModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofMethod(mask).flags());\n-    }\n-\n-    private static Set<String> getFieldModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofField(mask).flags());\n-    }\n-\n@@ -829,2 +821,2 @@\n-    private static Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+    private Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n@@ -833,2 +825,2 @@\n-    private static Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+    private Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n@@ -837,2 +829,2 @@\n-    private static Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+    private Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n@@ -855,36 +847,0 @@\n-    public static enum AccessFlag {\n-        ACC_PUBLIC      (ClassFile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n-        ACC_PRIVATE     (ClassFile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n-        ACC_PROTECTED   (ClassFile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n-        ACC_STATIC      (ClassFile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n-        ACC_FINAL       (ClassFile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n-        ACC_SUPER       (ClassFile.ACC_SUPER,        null,           true,  false, false, false),\n-        ACC_SYNCHRONIZED(ClassFile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n-        ACC_VOLATILE    (ClassFile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n-        ACC_BRIDGE      (ClassFile.ACC_BRIDGE,       null,           false, false, false, true ),\n-        ACC_TRANSIENT   (ClassFile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n-        ACC_VARARGS     (ClassFile.ACC_VARARGS,      null,           false, false, false, true ),\n-        ACC_NATIVE      (ClassFile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n-        ACC_INTERFACE   (ClassFile.ACC_INTERFACE,    null,           true,   true, false, false),\n-        ACC_ABSTRACT    (ClassFile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n-        ACC_STRICT      (ClassFile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n-        ACC_SYNTHETIC   (ClassFile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n-        ACC_ANNOTATION  (ClassFile.ACC_ANNOTATION,   null,           true,   true, false, false),\n-        ACC_ENUM        (ClassFile.ACC_ENUM,         null,           true,   true, true,  false),\n-        ACC_MODULE      (ClassFile.ACC_MODULE,       null,           true,  false, false, false);\n-\n-        public final int flag;\n-        public final String modifier;\n-        public final boolean isClass, isInnerClass, isField, isMethod;\n-\n-        AccessFlag(int flag, String modifier, boolean isClass,\n-                boolean isInnerClass, boolean isField, boolean isMethod) {\n-            this.flag = flag;\n-            this.modifier = modifier;\n-            this.isClass = isClass;\n-            this.isInnerClass = isInnerClass;\n-            this.isField = isField;\n-            this.isMethod = isMethod;\n-        }\n-    }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+compiler\/c2\/irTests\/TestIfMinMax.java 8334816 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -622,1 +622,0 @@\n-javax\/net\/ssl\/SSLSession\/CertMsgCheck.java                      8326705 generic-all\n@@ -626,2 +625,0 @@\n-security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java#teliasonerarootcav1  8333640 generic-all\n-\n@@ -729,3 +726,0 @@\n-java\/util\/Locale\/LocaleProvidersRun.java                        8268379 macosx-x64\n-sun\/util\/locale\/provider\/CalendarDataRegression.java            8268379 macosx-x64\n-\n@@ -799,1 +793,0 @@\n-java\/awt\/print\/Dialog\/RestoreActiveWindowTest\/RestoreActiveWindowTest.java 8185429 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -262,0 +262,2 @@\n+# Tests in this group are manual as they depend on external infra\n+# and may fail with external reasons, for instance - change in CA test portal.\n@@ -629,0 +631,1 @@\n+    :jdk_security_infra \\\n@@ -672,1 +675,1 @@\n-   -:jdk_security\n+   -:jdk_security\n","filename":"test\/jdk\/TEST.groups","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}