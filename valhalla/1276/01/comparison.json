{"files":[{"patch":"@@ -66,5 +66,6 @@\n-currently possible to generate configuration for two such indexers, <a\n-href=\"https:\/\/clang.llvm.org\/extra\/clangd\/\">clangd<\/a> and <a\n-href=\"https:\/\/github.com\/Andersbakken\/rtags\">rtags<\/a>. These can be\n-configured by appending the name of the indexer to the make target, such\n-as:<\/p>\n+currently possible to generate configuration for three such indexers, <a\n+href=\"https:\/\/clang.llvm.org\/extra\/clangd\/\">clangd<\/a>, <a\n+href=\"https:\/\/github.com\/MaskRay\/ccls\/wiki\/Visual-Studio-Code\">ccls<\/a>\n+and <a href=\"https:\/\/github.com\/Andersbakken\/rtags\">rtags<\/a>. These can\n+be configured by appending the name of the indexer to the make target,\n+such as:<\/p>\n","filename":"doc\/ide.html","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-configuration for two such indexers, [clangd](https:\/\/clang.llvm.org\/extra\/clangd\/)\n+configuration for three such indexers, [clangd](https:\/\/clang.llvm.org\/extra\/clangd\/),\n+[ccls](https:\/\/github.com\/MaskRay\/ccls\/wiki\/Visual-Studio-Code)\n","filename":"doc\/ide.md","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-# These are needed for deterministic classlist:\n+# To make the classlist deterministic:\n@@ -67,2 +67,4 @@\n-# - Run with -Xint, as the compiler can speculatively resolve constant pool entries.\n-# - ForkJoinPool parallelism can cause constant pool resolution to be non-deterministic.\n+# - Concurrency in the core libraries can cause constant pool resolution\n+#   to be non-deterministic. Since the benefits of resolved CP references in the\n+#   default classlist is minimal, let's filter out the '@cp' lines until we can\n+#   find a proper solution.\n@@ -70,3 +72,1 @@\n-    -Duser.language=en -Duser.country=US \\\n-    -Xint \\\n-    -Djava.util.concurrent.ForkJoinPool.common.parallelism=0\n+    -Duser.language=en -Duser.country=US\n@@ -104,0 +104,1 @@\n+\t$(GREP) -v @cp $@.raw.3 > $@.raw.4\n@@ -106,1 +107,1 @@\n-\t    build.tools.classlist.SortClasslist $@.raw.3 > $@\n+\t    build.tools.classlist.SortClasslist $@.raw.4 > $@\n","filename":"make\/GenerateLinkOptData.gmk","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=true\n+    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=auto\n@@ -202,1 +202,0 @@\n-  AC_SUBST(COMPATIBLE_CDS_ALIGNMENT_DEFAULT)\n@@ -441,0 +440,9 @@\n+          # detect_stack_use_after_return causes ASAN to offload stack-local\n+          # variables to c-heap and therefore breaks assumptions in hotspot\n+          # that rely on data (e.g. Marks) living in thread stacks.\n+          if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+            ASAN_CFLAGS=\"$ASAN_CFLAGS --param asan-use-after-return=0\"\n+          fi\n+          if test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+            ASAN_CFLAGS=\"$ASAN_CFLAGS -fsanitize-address-use-after-return=never\"\n+          fi\n@@ -447,0 +455,2 @@\n+          # -fsanitize-address-use-after-return is off by default in MS Visual Studio 22 (19.37.32824).\n+          # cl : Command line warning D9002 : ignoring unknown option '-fno-sanitize-address-use-after-return'\n@@ -499,0 +509,5 @@\n+  UTIL_ARG_WITH(NAME: additional-ubsan-checks, TYPE: string,\n+      DEFAULT: [],\n+      DESC: [Customizes the ubsan checks],\n+      OPTIONAL: true)\n+\n@@ -501,1 +516,2 @@\n-  UBSAN_CHECKS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero -fno-sanitize=shift-base -fno-sanitize=alignment\"\n+  UBSAN_CHECKS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero -fno-sanitize=shift-base -fno-sanitize=alignment \\\n+      $ADDITIONAL_UBSAN_CHECKS\"\n@@ -669,1 +685,1 @@\n-      DEFAULT_DESC: [disabled],\n+      DEFAULT_DESC: [disabled except on linux-aarch64],\n","filename":"make\/autoconf\/jdk-options.m4","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -781,1 +781,1 @@\n-        result.appendLine(\"protected int mult(long[] a, long[] b, long[] r) {\");\n+        result.appendLine(\"protected void mult(long[] a, long[] b, long[] r) {\");\n@@ -807,3 +807,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n@@ -839,1 +836,1 @@\n-        result.appendLine(\"protected int square(long[] a, long[] r) {\");\n+        result.appendLine(\"protected void square(long[] a, long[] r) {\");\n@@ -880,3 +877,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,0 +54,9 @@\n+\n+################################################################################\n+## Build jnativescan\n+################################################################################\n+\n+$(eval $(call SetupBuildLauncher, jnativescan, \\\n+    MAIN_CLASS := com.sun.tools.jnativescan.Main, \\\n+    CFLAGS := -DEXPAND_CLASSPATH_WILDCARDS, \\\n+))\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-            for (TypeElement t : metadata.getEventsAndStructs()) {\n+            for (TypeElement t : metadata.getEvents()) {\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1185,1 +1185,1 @@\n-  \/\/ Bizzarely, the counts are passed in bytes, regardless of whether they\n+  \/\/ Bizarrely, the counts are passed in bytes, regardless of whether they\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1639,2 +1639,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n@@ -1679,2 +1678,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n+#endif\n@@ -167,1 +170,1 @@\n-void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+bool CodeInstaller::pd_relocate(address pc, jint mark) {\n@@ -170,2 +173,2 @@\n-      JVMCI_ERROR(\"unimplemented\");\n-      break;\n+      \/\/ This is unhandled and will be reported by the caller\n+      return false;\n@@ -174,1 +177,1 @@\n-      break;\n+      return true;\n@@ -176,2 +179,2 @@\n-      JVMCI_ERROR(\"unimplemented\");\n-      break;\n+      \/\/ This is unhandled and will be reported by the caller\n+      return false;\n@@ -180,4 +183,14 @@\n-      break;\n-    default:\n-      JVMCI_ERROR(\"invalid mark value\");\n-      break;\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_TB_X:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatLoadGoodBeforeTbX);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_BEFORE_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatMarkBadBeforeMov);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_BEFORE_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodBeforeMov);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_BEFORE_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreBadBeforeMov);\n+      return true;\n+\n@@ -185,0 +198,1 @@\n+  return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2032,5 +2032,2 @@\n-  {\n-    uint64_t offset;\n-    __ adrp(rscratch1, ExternalAddress((address)&DTraceMethodProbes), offset);\n-    __ ldrb(rscratch1, Address(rscratch1, offset));\n-    __ cbnzw(rscratch1, dtrace_method_entry);\n+  if (DTraceMethodProbes) {\n+    __ b(dtrace_method_entry);\n@@ -2272,5 +2269,2 @@\n-  {\n-    uint64_t offset;\n-    __ adrp(rscratch1, ExternalAddress((address)&DTraceMethodProbes), offset);\n-    __ ldrb(rscratch1, Address(rscratch1, offset));\n-    __ cbnzw(rscratch1, dtrace_method_exit);\n+  if (DTraceMethodProbes) {\n+    __ b(dtrace_method_exit);\n@@ -2420,16 +2414,17 @@\n-  {\n-    __ block_comment(\"dtrace entry {\");\n-    __ bind(dtrace_method_entry);\n-\n-    \/\/ We have all of the arguments setup at this point. We must not touch any register\n-    \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n-\n-    save_args(masm, total_c_args, c_arg, out_regs);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-      CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n-      rthread, c_rarg1);\n-    restore_args(masm, total_c_args, c_arg, out_regs);\n-    __ b(dtrace_method_entry_done);\n-    __ block_comment(\"} dtrace entry\");\n-  }\n+  if (DTraceMethodProbes) {\n+    {\n+      __ block_comment(\"dtrace entry {\");\n+      __ bind(dtrace_method_entry);\n+\n+      \/\/ We have all of the arguments setup at this point. We must not touch any register\n+      \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n+\n+      save_args(masm, total_c_args, c_arg, out_regs);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+        CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n+        rthread, c_rarg1);\n+      restore_args(masm, total_c_args, c_arg, out_regs);\n+      __ b(dtrace_method_entry_done);\n+      __ block_comment(\"} dtrace entry\");\n+    }\n@@ -2437,11 +2432,12 @@\n-  {\n-    __ block_comment(\"dtrace exit {\");\n-    __ bind(dtrace_method_exit);\n-    save_native_result(masm, ret_type, stack_slots);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-         CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n-         rthread, c_rarg1);\n-    restore_native_result(masm, ret_type, stack_slots);\n-    __ b(dtrace_method_exit_done);\n-    __ block_comment(\"} dtrace exit\");\n+    {\n+      __ block_comment(\"dtrace exit {\");\n+      __ bind(dtrace_method_exit);\n+      save_native_result(masm, ret_type, stack_slots);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+        CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n+        rthread, c_rarg1);\n+      restore_native_result(masm, ret_type, stack_slots);\n+      __ b(dtrace_method_exit_done);\n+      __ block_comment(\"} dtrace exit\");\n+    }\n@@ -2450,1 +2446,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":33,"deletions":38,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -3916,0 +3916,8 @@\n+    if (DTraceAllocProbes) {\n+      \/\/ Trigger dtrace event for fastpath\n+      __ push(atos); \/\/ save the return value\n+      __ call_VM_leaf(\n+           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), r0);\n+      __ pop(atos); \/\/ restore the return value\n+\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,2 +155,8 @@\n-    __ ldr(R1, Address(OSR_buf, slot_offset + 0*BytesPerWord));\n-    __ ldr(R2, Address(OSR_buf, slot_offset + 1*BytesPerWord));\n+    if (slot_offset >= 4096 - BytesPerWord) {\n+      __ add_slow(R2, OSR_buf, slot_offset);\n+      __ ldr(R1, Address(R2, 0*BytesPerWord));\n+      __ ldr(R2, Address(R2, 1*BytesPerWord));\n+    } else {\n+      __ ldr(R1, Address(OSR_buf, slot_offset + 0*BytesPerWord));\n+      __ ldr(R2, Address(OSR_buf, slot_offset + 1*BytesPerWord));\n+    }\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -353,0 +353,1 @@\n+    SETBCR_OPCODE = (31u << OPCODE_SHIFT | 416u << 1),\n@@ -1783,0 +1784,2 @@\n+  inline void setbcr(Register d, int biint);\n+  inline void setbcr(Register d, ConditionRegister cr, Condition cc);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -422,0 +422,5 @@\n+inline void Assembler::setbcr(Register d, int biint)\n+                                                  { emit_int32(SETBCR_OPCODE | rt(d) | bi(biint)); }\n+inline void Assembler::setbcr(Register d, ConditionRegister cr, Condition cc) {\n+  setbcr(d, bi0(cr, cc));\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2386,4 +2386,1 @@\n-  neg(R0, result);\n-  orr(result, result, R0);\n-  srdi(result, result, 63);\n-\n+  normalize_bool(result, R0, true);\n@@ -2398,3 +2395,1 @@\n-  neg(R0, linear_result);\n-  orr(linear_result, linear_result, R0);\n-  srdi(linear_result, linear_result, 63);\n+  normalize_bool(linear_result, R0, true);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -181,0 +181,2 @@\n+  \/\/ Branch-free implementation to convert !=0 to 1.\n+  void inline normalize_bool(Register dst, Register temp = R0, bool is_64bit = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -267,0 +267,23 @@\n+\/\/ Branch-free implementation to convert !=0 to 1\n+\/\/ Set register dst to 1 if dst is non-zero. Uses setbcr instruction on Power10.\n+inline void MacroAssembler::normalize_bool(Register dst, Register temp, bool is_64bit) {\n+\n+  if (VM_Version::has_brw()) {\n+    if (is_64bit) {\n+      cmpdi(CCR0, dst, 0);\n+    } else {\n+      cmpwi(CCR0, dst, 0);\n+    }\n+    setbcr(dst, CCR0, Assembler::equal);\n+  } else {\n+    assert_different_registers(temp, dst);\n+    neg(temp, dst);\n+    orr(temp, dst, temp);\n+    if (is_64bit) {\n+      srdi(dst, temp, 63);\n+    } else {\n+      srwi(dst, temp, 31);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3432,0 +3432,1 @@\n+    call->_has_ea_local_in_scope = _has_ea_local_in_scope;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2475,5 +2475,1 @@\n-      Label skip_modify;\n-      __ cmpwi(CCR0, R3_RET, 0);\n-      __ beq(CCR0, skip_modify);\n-      __ li(R3_RET, 1);\n-      __ bind(skip_modify);\n+      __ normalize_bool(R3_RET);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -375,3 +375,1 @@\n-    __ neg(R0, R3_RET);\n-    __ orr(R0, R3_RET, R0);\n-    __ srwi(R3_RET, R0, 31);\n+    __ normalize_bool(R3_RET);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3862,4 +3862,5 @@\n-    SkipIfEqualZero::skip_to_label_if_equal_zero(_masm, Rscratch, &DTraceAllocProbes, Ldone);\n-    __ push(atos);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)));\n-    __ pop(atos);\n+    if (DTraceAllocProbes) {\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)));\n+      __ pop(atos);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1610,1 +1610,16 @@\n-void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) { Unimplemented(); }\n+void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {\n+  assert(op->crc()->is_single_cpu(),  \"crc must be register\");\n+  assert(op->val()->is_single_cpu(),  \"byte value must be register\");\n+  assert(op->result_opr()->is_single_cpu(), \"result must be register\");\n+  Register crc = op->crc()->as_register();\n+  Register val = op->val()->as_register();\n+  Register res = op->result_opr()->as_register();\n+\n+  assert_different_registers(val, crc, res);\n+  __ la(res, ExternalAddress(StubRoutines::crc_table_addr()));\n+\n+  __ notr(crc, crc); \/\/ ~crc\n+  __ zero_extend(crc, crc, 32);\n+  __ update_byte_crc32(crc, val, res);\n+  __ notr(res, crc); \/\/ ~crc\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -784,1 +784,73 @@\n-  ShouldNotReachHere();\n+  assert(UseCRC32Intrinsics, \"why are we here?\");\n+  \/\/ Make all state_for calls early since they can emit code\n+  LIR_Opr result = rlock_result(x);\n+  switch (x->id()) {\n+    case vmIntrinsics::_updateCRC32: {\n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem val(x->argument_at(1), this);\n+      \/\/ val is destroyed by update_crc32\n+      val.set_destroys_register();\n+      crc.load_item();\n+      val.load_item();\n+      __ update_crc32(crc.result(), val.result(), result);\n+      break;\n+    }\n+    case vmIntrinsics::_updateBytesCRC32:\n+    case vmIntrinsics::_updateByteBufferCRC32: {\n+      bool is_updateBytes = (x->id() == vmIntrinsics::_updateBytesCRC32);\n+\n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem buf(x->argument_at(1), this);\n+      LIRItem off(x->argument_at(2), this);\n+      LIRItem len(x->argument_at(3), this);\n+      buf.load_item();\n+      off.load_nonconstant();\n+\n+      LIR_Opr index = off.result();\n+      int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;\n+      if (off.result()->is_constant()) {\n+        index = LIR_OprFact::illegalOpr;\n+        offset += off.result()->as_jint();\n+      }\n+      LIR_Opr base_op = buf.result();\n+\n+      if (index->is_valid()) {\n+        LIR_Opr tmp = new_register(T_LONG);\n+        __ convert(Bytecodes::_i2l, index, tmp);\n+        index = tmp;\n+      }\n+\n+      if (offset) {\n+        LIR_Opr tmp = new_pointer_register();\n+        __ add(base_op, LIR_OprFact::intConst(offset), tmp);\n+        base_op = tmp;\n+        offset = 0;\n+      }\n+\n+      LIR_Address* a = new LIR_Address(base_op,\n+                                       index,\n+                                       offset,\n+                                       T_BYTE);\n+      BasicTypeList signature(3);\n+      signature.append(T_INT);\n+      signature.append(T_ADDRESS);\n+      signature.append(T_INT);\n+      CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+      const LIR_Opr result_reg = result_register_for(x->type());\n+\n+      LIR_Opr addr = new_pointer_register();\n+      __ leal(LIR_OprFact::address(a), addr);\n+\n+      crc.load_item_force(cc->at(0));\n+      __ move(addr, cc->at(1));\n+      len.load_item_force(cc->at(2));\n+\n+      __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc->args());\n+      __ move(result_reg, result);\n+\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1325,1 +1325,1 @@\n-  \/\/ Bizzarely, the counts are passed in bytes, regardless of whether they\n+  \/\/ Bizarrely, the counts are passed in bytes, regardless of whether they\n@@ -2329,1 +2329,2 @@\n-                                        VectorRegister vr1, VectorRegister vr2, VectorRegister vrs, bool islatin, Label &DONE) {\n+                                        VectorRegister vr1, VectorRegister vr2, VectorRegister vrs, bool islatin, Label &DONE,\n+                                        Assembler::LMUL lmul) {\n@@ -2334,1 +2335,1 @@\n-  vsetvli(tmp1, cnt, sew, Assembler::m2);\n+  vsetvli(tmp1, cnt, sew, lmul);\n@@ -2360,1 +2361,1 @@\n-  element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, true, DONE);\n+  element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, true, DONE, Assembler::m2);\n@@ -2413,1 +2414,1 @@\n-  element_compare(a1, a2, result, cnt1, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE);\n+  element_compare(a1, a2, result, cnt1, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE, Assembler::m2);\n@@ -2448,0 +2449,3 @@\n+  \/\/ We focus on the optimization of small sized string.\n+  \/\/ Please check below document for string size distribution statistics.\n+  \/\/ https:\/\/cr.openjdk.org\/~shade\/density\/string-density-report.pdf\n@@ -2449,1 +2453,8 @@\n-    element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v2, v4, v2, encLL, DIFFERENCE);\n+    \/\/ Below construction of v regs and lmul is based on test on 2 different boards,\n+    \/\/ vlen == 128 and vlen == 256 respectively.\n+    if (!encLL && MaxVectorSize == 16) { \/\/ UU\n+      element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v4, v8, v4, encLL, DIFFERENCE, Assembler::m4);\n+    } else { \/\/ UU + MaxVectorSize or LL\n+      element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v2, v4, v2, encLL, DIFFERENCE, Assembler::m2);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-                       bool is_latin, Label& DONE);\n+                       bool is_latin, Label& DONE, Assembler::LMUL lmul);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1470,2 +1470,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n@@ -1509,2 +1508,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+bool CodeInstaller::pd_relocate(address pc, jint mark) {\n@@ -110,0 +110,1 @@\n+  return false;\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -1431,0 +1431,168 @@\n+static const int64_t right_32_bits = right_n_bits(32);\n+static const int64_t right_8_bits = right_n_bits(8);\n+\n+\/**\n+ * Emits code to update CRC-32 with a byte value according to constants in table\n+ *\n+ * @param [in,out]crc   Register containing the crc.\n+ * @param [in]val       Register containing the byte to fold into the CRC.\n+ * @param [in]table     Register containing the table of crc constants.\n+ *\n+ * uint32_t crc;\n+ * val = crc_table[(val ^ crc) & 0xFF];\n+ * crc = val ^ (crc >> 8);\n+ *\n+ *\/\n+void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {\n+  assert_different_registers(crc, val, table);\n+\n+  xorr(val, val, crc);\n+  andi(val, val, right_8_bits);\n+  shadd(val, val, table, val, 2);\n+  lwu(val, Address(val));\n+  srli(crc, crc, 8);\n+  xorr(crc, val, crc);\n+}\n+\n+\/**\n+ * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3\n+ *\n+ * @param [in,out]crc   Register containing the crc.\n+ * @param [in]v         Register containing the 32-bit to fold into the CRC.\n+ * @param [in]table0    Register containing table 0 of crc constants.\n+ * @param [in]table1    Register containing table 1 of crc constants.\n+ * @param [in]table2    Register containing table 2 of crc constants.\n+ * @param [in]table3    Register containing table 3 of crc constants.\n+ *\n+ * uint32_t crc;\n+ *   v = crc ^ v\n+ *   crc = table3[v&0xff]^table2[(v>>8)&0xff]^table1[(v>>16)&0xff]^table0[v>>24]\n+ *\n+ *\/\n+void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2, Register tmp3,\n+        Register table0, Register table1, Register table2, Register table3, bool upper) {\n+  assert_different_registers(crc, v, tmp1, tmp2, tmp3, table0, table1, table2, table3);\n+\n+  if (upper)\n+    srli(v, v, 32);\n+  xorr(v, v, crc);\n+\n+  andi(tmp1, v, right_8_bits);\n+  shadd(tmp1, tmp1, table3, tmp2, 2);\n+  lwu(crc, Address(tmp1));\n+\n+  slli(tmp1, v, 16);\n+  slli(tmp3, v, 8);\n+\n+  srliw(tmp1, tmp1, 24);\n+  srliw(tmp3, tmp3, 24);\n+\n+  shadd(tmp1, tmp1, table2, tmp1, 2);\n+  lwu(tmp2, Address(tmp1));\n+\n+  shadd(tmp3, tmp3, table1, tmp3, 2);\n+  xorr(crc, crc, tmp2);\n+\n+  lwu(tmp2, Address(tmp3));\n+  \/\/ It is more optimal to use 'srli' instead of 'srliw' for case when it is not necessary to clean upper bits\n+  if (upper)\n+    srli(tmp1, v, 24);\n+  else\n+    srliw(tmp1, v, 24);\n+\n+  \/\/ no need to clear bits other than lowest two\n+  shadd(tmp1, tmp1, table0, tmp1, 2);\n+  xorr(crc, crc, tmp2);\n+  lwu(tmp2, Address(tmp1));\n+  xorr(crc, crc, tmp2);\n+}\n+\n+\/**\n+ * @param crc   register containing existing CRC (32-bit)\n+ * @param buf   register pointing to input byte buffer (byte*)\n+ * @param len   register containing number of bytes\n+ * @param table register that will contain address of CRC table\n+ * @param tmp   scratch registers\n+ *\/\n+void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6) {\n+  assert_different_registers(crc, buf, len, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+  Label L_by16_loop, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+\n+  const int64_t unroll = 16;\n+  const int64_t unroll_words = unroll*wordSize;\n+  mv(tmp5, right_32_bits);\n+  subw(len, len, unroll_words);\n+  andn(crc, tmp5, crc);\n+\n+  const ExternalAddress table_addr = StubRoutines::crc_table_addr();\n+  la(table0, table_addr);\n+  add(table1, table0, 1*256*sizeof(juint), tmp1);\n+  add(table2, table0, 2*256*sizeof(juint), tmp1);\n+  add(table3, table2, 1*256*sizeof(juint), tmp1);\n+\n+  bge(len, zr, L_unroll_loop_entry);\n+  addiw(len, len, unroll_words-4);\n+  bge(len, zr, L_by4_loop);\n+  addiw(len, len, 4);\n+  bgt(len, zr, L_by1_loop);\n+  j(L_exit);\n+\n+  align(CodeEntryAlignment);\n+  bind(L_unroll_loop_entry);\n+    const Register buf_end = tmp3;\n+    add(buf_end, buf, len); \/\/ buf_end will be used as endpoint for loop below\n+    andi(len, len, unroll_words-1); \/\/ len = (len % unroll_words)\n+    sub(len, len, unroll_words); \/\/ Length after all iterations\n+  bind(L_unroll_loop);\n+    for (int i = 0; i < unroll; i++) {\n+      ld(tmp1, Address(buf, i*wordSize));\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, false);\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, true);\n+    }\n+\n+    addi(buf, buf, unroll_words);\n+    ble(buf, buf_end, L_unroll_loop);\n+    addiw(len, len, unroll_words-4);\n+    bge(len, zr, L_by4_loop);\n+    addiw(len, len, 4);\n+    bgt(len, zr, L_by1_loop);\n+    j(L_exit);\n+\n+  bind(L_by4_loop);\n+    lwu(tmp1, Address(buf));\n+    update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, false);\n+    subw(len, len, 4);\n+    addi(buf, buf, 4);\n+    bge(len, zr, L_by4_loop);\n+    addiw(len, len, 4);\n+    ble(len, zr, L_exit);\n+\n+  bind(L_by1_loop);\n+    subw(len, len, 1);\n+    lwu(tmp1, Address(buf));\n+    andi(tmp2, tmp1, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    subw(len, len, 1);\n+    srli(tmp2, tmp1, 8);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    subw(len, len, 1);\n+    srli(tmp2, tmp1, 16);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    srli(tmp2, tmp1, 24);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+\n+  bind(L_exit);\n+    andn(crc, tmp5, crc);\n+}\n+\n@@ -2498,0 +2666,45 @@\n+void MacroAssembler::encode_heap_oop_not_null(Register r) {\n+#ifdef ASSERT\n+  if (CheckCompressedOops) {\n+    Label ok;\n+    bnez(r, ok);\n+    stop(\"null oop passed to encode_heap_oop_not_null\");\n+    bind(ok);\n+  }\n+#endif\n+  verify_oop_msg(r, \"broken oop in encode_heap_oop_not_null\");\n+  if (CompressedOops::base() != nullptr) {\n+    sub(r, r, xheapbase);\n+  }\n+  if (CompressedOops::shift() != 0) {\n+    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n+    srli(r, r, LogMinObjAlignmentInBytes);\n+  }\n+}\n+\n+void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {\n+#ifdef ASSERT\n+  if (CheckCompressedOops) {\n+    Label ok;\n+    bnez(src, ok);\n+    stop(\"null oop passed to encode_heap_oop_not_null2\");\n+    bind(ok);\n+  }\n+#endif\n+  verify_oop_msg(src, \"broken oop in encode_heap_oop_not_null2\");\n+\n+  Register data = src;\n+  if (CompressedOops::base() != nullptr) {\n+    sub(dst, src, xheapbase);\n+    data = dst;\n+  }\n+  if (CompressedOops::shift() != 0) {\n+    assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), \"decode alg wrong\");\n+    srli(dst, data, LogMinObjAlignmentInBytes);\n+    data = dst;\n+  }\n+  if (data == src) {\n+    mv(dst, src);\n+  }\n+}\n+\n@@ -3614,0 +3827,272 @@\n+\/\/ population_count variant for running without the CPOP\n+\/\/ instruction, which was introduced with Zbb extension.\n+void MacroAssembler::population_count(Register dst, Register src,\n+                                      Register tmp1, Register tmp2) {\n+  if (UsePopCountInstruction) {\n+    cpop(dst, src);\n+  } else {\n+    assert_different_registers(src, tmp1, tmp2);\n+    assert_different_registers(dst, tmp1, tmp2);\n+    Label loop, done;\n+\n+    mv(tmp1, src);\n+    \/\/ dst = 0;\n+    \/\/ while(tmp1 != 0) {\n+    \/\/   dst++;\n+    \/\/   tmp1 &= (tmp1 - 1);\n+    \/\/ }\n+    mv(dst, zr);\n+    beqz(tmp1, done);\n+    {\n+      bind(loop);\n+      addi(dst, dst, 1);\n+      addi(tmp2, tmp1, -1);\n+      andr(tmp1, tmp1, tmp2);\n+      bnez(tmp1, loop);\n+    }\n+    bind(done);\n+  }\n+}\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers\n+\/\/ as we need to call the stub from inline code when there is a collision\n+\/\/ in the hashed lookup in the secondary supers array.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,  \\\n+                                                r_array_index, r_sub_klass, result, r_bitmap) \\\n+do {                                                                                          \\\n+  assert(r_super_klass  == x10                             &&                                 \\\n+         r_array_base   == x11                             &&                                 \\\n+         r_array_length == x12                             &&                                 \\\n+         (r_array_index == x13  || r_array_index == noreg) &&                                 \\\n+         (r_sub_klass   == x14  || r_sub_klass   == noreg) &&                                 \\\n+         (result        == x15  || result        == noreg) &&                                 \\\n+         (r_bitmap      == x16  || r_bitmap      == noreg), \"registers must match riscv.ad\"); \\\n+} while(0)\n+\n+\/\/ Return true: we succeeded in generating this code\n+bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register tmp1,\n+                                                   Register tmp2,\n+                                                   Register tmp3,\n+                                                   Register tmp4,\n+                                                   u1 super_klass_slot,\n+                                                   bool stub_is_near) {\n+  assert_different_registers(r_sub_klass, r_super_klass, result, tmp1, tmp2, tmp3, tmp4, t0);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = tmp1, \/\/ x11\n+    r_array_length = tmp2, \/\/ x12\n+    r_array_index  = tmp3, \/\/ x13\n+    r_bitmap       = tmp4; \/\/ x16\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n+                                          r_array_index, r_sub_klass, result, r_bitmap);\n+\n+  u1 bit = super_klass_slot;\n+\n+  \/\/ Initialize result value to 1 which means mismatch.\n+  mv(result, 1);\n+\n+  ld(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  test_bit(t0, r_bitmap, bit);\n+  beqz(t0, L_fallthrough);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    slli(r_array_index, r_bitmap, (Klass::SECONDARY_SUPERS_TABLE_MASK - bit));\n+    population_count(r_array_index, r_array_index, tmp1, tmp2);\n+  } else {\n+    mv(r_array_index, (u1)1);\n+  }\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  shadd(result, r_array_index, r_array_base, result, LogBytesPerWord);\n+  ld(result, Address(result));\n+  xorr(result, result, r_super_klass);\n+  beqz(result, L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  test_bit(t0, r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  beqz(t0, L_fallthrough);\n+\n+  \/\/ Linear probe.\n+  if (bit != 0) {\n+    ror_imm(r_bitmap, r_bitmap, bit);\n+  }\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the stub we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  Address stub = RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n+  if (stub_is_near) {\n+    jump_link(stub, t0);\n+  } else {\n+    address call = trampoline_call(stub);\n+    if (call == nullptr) {\n+      return false; \/\/ trampoline allocation failed\n+    }\n+  }\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, \/\/ x14, x10\n+                                  result, tmp1, tmp2, tmp3);  \/\/ x15, x11, x12, x13\n+  }\n+  return true;\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register result,\n+                                                             Register tmp1) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, tmp1, result, t0);\n+\n+  const Register\n+    r_array_length = tmp1,\n+    r_sub_klass    = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n+                                          r_array_index, r_sub_klass, result, r_bitmap);\n+\n+  Label L_matched, L_fallthrough, L_bitmap_full;\n+\n+  \/\/ Initialize result value to 1 which means mismatch.\n+  mv(result, 1);\n+\n+  \/\/ Load the array length.\n+  lwu(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  addi(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Check if bitmap is SECONDARY_SUPERS_BITMAP_FULL\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"Adjust this code\");\n+  addi(t0, r_bitmap, (u1)1);\n+  beqz(t0, L_bitmap_full);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+    Label L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    Label skip;\n+    blt(r_array_index, r_array_length, skip);\n+    mv(r_array_index, zr);\n+    bind(skip);\n+\n+    shadd(t0, r_array_index, r_array_base, t0, LogBytesPerWord);\n+    ld(t0, Address(t0));\n+    beq(t0, r_super_klass, L_matched);\n+\n+    test_bit(t0, r_bitmap, 2);  \/\/ look-ahead check (Bit 2); result is non-zero\n+    beqz(t0, L_fallthrough);\n+\n+    ror_imm(r_bitmap, r_bitmap, 1);\n+    addi(r_array_index, r_array_index, 1);\n+    j(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_bitmap_full);\n+    repne_scan(r_array_base, r_super_klass, r_array_length, t0);\n+    bne(r_super_klass, t0, L_fallthrough);\n+  }\n+\n+  bind(L_matched);\n+  mv(result, zr);\n+\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register tmp1,\n+                                                   Register tmp2,\n+                                                   Register tmp3) {\n+  assert_different_registers(r_sub_klass, r_super_klass, tmp1, tmp2, tmp3, result, t0);\n+\n+  const Register\n+    r_array_base   = tmp1,  \/\/ X11\n+    r_array_length = tmp2,  \/\/ X12\n+    r_array_index  = noreg, \/\/ unused\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS(r_super_klass, r_array_base, r_array_length,\n+                                          r_array_index, r_sub_klass, result, r_bitmap);\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ Load the array length.\n+  lwu(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  addi(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  repne_scan(r_array_base, r_super_klass, r_array_length, t0);\n+  Label failed;\n+  mv(tmp3, 1);\n+  bne(r_super_klass, t0, failed);\n+  mv(tmp3, zr);\n+  bind(failed);\n+\n+  snez(result, result); \/\/ normalize result to 0\/1 for comparison\n+\n+  Label passed;\n+  beq(tmp3, result, passed);\n+  {\n+    mv(x10, r_super_klass);\n+    mv(x11, r_sub_klass);\n+    mv(x12, tmp3);\n+    mv(x13, result);\n+    mv(x14, (address)(\"mismatch\"));\n+    rt_call(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure));\n+    should_not_reach_here();\n+  }\n+  bind(passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":486,"deletions":1,"binary":false,"changes":487,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -209,0 +209,2 @@\n+  void encode_heap_oop_not_null(Register r);\n+  void encode_heap_oop_not_null(Register dst, Register src);\n@@ -325,0 +327,28 @@\n+  void population_count(Register dst, Register src, Register tmp1, Register tmp2);\n+\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  bool lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register result,\n+                                     Register tmp1,\n+                                     Register tmp2,\n+                                     Register tmp3,\n+                                     Register tmp4,\n+                                     u1 super_klass_slot,\n+                                     bool stub_is_near = false);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register result,\n+                                     Register tmp1,\n+                                     Register tmp2,\n+                                     Register tmp3);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register result,\n+                                               Register tmp1);\n+\n@@ -1263,0 +1293,9 @@\n+  \/\/ CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.\n+  void kernel_crc32(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register tmp6);\n+  void update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2, Register tmp3,\n+        Register table0, Register table1, Register table2, Register table3,\n+        bool upper);\n+  void update_byte_crc32(Register crc, Register val, Register table);\n+\n@@ -1292,0 +1331,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-\/\/ Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -245,1 +245,1 @@\n-reg_def V1    ( SOC, SOC, Op_VecA, 1,  v1->as_VMReg() \t        );\n+reg_def V1    ( SOC, SOC, Op_VecA, 1,  v1->as_VMReg()           );\n@@ -265,1 +265,1 @@\n-reg_def V5    ( SOC, SOC, Op_VecA, 5,  v5->as_VMReg() \t        );\n+reg_def V5    ( SOC, SOC, Op_VecA, 5,  v5->as_VMReg()           );\n@@ -275,1 +275,1 @@\n-reg_def V7    ( SOC, SOC, Op_VecA, 7,  v7->as_VMReg() \t        );\n+reg_def V7    ( SOC, SOC, Op_VecA, 7,  v7->as_VMReg()           );\n@@ -1917,0 +1917,4 @@\n+    case Op_ReverseBytesI:\n+    case Op_ReverseBytesL:\n+    case Op_ReverseBytesS:\n+    case Op_ReverseBytesUS:\n@@ -1924,0 +1928,1 @@\n+\n@@ -3313,0 +3318,10 @@\n+operand iRegP_R16()\n+%{\n+  constraint(ALLOC_IN_RC(r16_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -7856,57 +7871,0 @@\n-\/\/ ============================================================================\n-\/\/ BSWAP Instructions\n-\n-instruct bytes_reverse_int(iRegINoSp dst, iRegIorL2I src, rFlagsReg cr) %{\n-  match(Set dst (ReverseBytesI src));\n-  effect(KILL cr);\n-\n-  ins_cost(ALU_COST * 13);\n-  format %{ \"revb_w_w  $dst, $src\\t#@bytes_reverse_int\" %}\n-\n-  ins_encode %{\n-    __ revb_w_w(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct bytes_reverse_long(iRegLNoSp dst, iRegL src, rFlagsReg cr) %{\n-  match(Set dst (ReverseBytesL src));\n-  effect(KILL cr);\n-\n-  ins_cost(ALU_COST * 29);\n-  format %{ \"revb  $dst, $src\\t#@bytes_reverse_long\" %}\n-\n-  ins_encode %{\n-    __ revb(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct bytes_reverse_unsigned_short(iRegINoSp dst, iRegIorL2I src) %{\n-  match(Set dst (ReverseBytesUS src));\n-\n-  ins_cost(ALU_COST * 5);\n-  format %{ \"revb_h_h_u  $dst, $src\\t#@bytes_reverse_unsigned_short\" %}\n-\n-  ins_encode %{\n-    __ revb_h_h_u(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct bytes_reverse_short(iRegINoSp dst, iRegIorL2I src) %{\n-  match(Set dst (ReverseBytesS src));\n-\n-  ins_cost(ALU_COST * 5);\n-  format %{ \"revb_h_h  $dst, $src\\t#@bytes_reverse_short\" %}\n-\n-  ins_encode %{\n-    __ revb_h_h(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -8449,0 +8407,1 @@\n+  predicate(n->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);\n@@ -8460,0 +8419,11 @@\n+instruct encodeHeapOop_not_null(iRegNNoSp dst, iRegP src) %{\n+  predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n+  match(Set dst (EncodeP src));\n+  ins_cost(ALU_COST);\n+  format %{ \"encode_heap_oop_not_null $dst, $src\\t#@encodeHeapOop_not_null\" %}\n+  ins_encode %{\n+    __ encode_heap_oop_not_null($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -10103,1 +10073,1 @@\n-  ins_cost(2 * STORE_COST + 3 * LOAD_COST + 4 * ALU_COST + BRANCH_COST * 4);\n+  ins_cost(11 * DEFAULT_COST);\n@@ -10113,0 +10083,30 @@\n+instruct partialSubtypeCheckConstSuper(iRegP_R14 sub, iRegP_R10 super_reg, immP super_con, iRegP_R15 result,\n+                                       iRegP_R11 tmpR11, iRegP_R12 tmpR12, iRegP_R13 tmpR13, iRegP_R16 tmpR16)\n+%{\n+  predicate(UseSecondarySupersTable);\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  effect(TEMP tmpR11, TEMP tmpR12, TEMP tmpR13, TEMP tmpR16);\n+\n+  ins_cost(7 * DEFAULT_COST); \/\/ needs to be less than competing nodes\n+  format %{ \"partialSubtypeCheck $result, $sub, $super_reg, $super_con\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register, $result$$Register,\n+                                                 $tmpR11$$Register, $tmpR12$$Register, $tmpR13$$Register,\n+                                                 $tmpR16$$Register, super_klass_slot);\n+    } else {\n+      address call = __ trampoline_call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+      success = (call != nullptr);\n+    }\n+    if (!success) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -10119,1 +10119,1 @@\n-  ins_cost(2 * STORE_COST + 3 * LOAD_COST + 4 * ALU_COST + BRANCH_COST * 4);\n+  ins_cost(11 * DEFAULT_COST);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  predicate(UseZbb);\n@@ -188,0 +187,1 @@\n+    assert(UseZbb, \"must be\");\n@@ -195,1 +195,0 @@\n-  predicate(UseZbb);\n@@ -202,0 +201,1 @@\n+    assert(UseZbb, \"must be\");\n@@ -209,1 +209,0 @@\n-  predicate(UseZbb);\n@@ -216,0 +215,1 @@\n+    assert(UseZbb, \"must be\");\n@@ -223,1 +223,0 @@\n-  predicate(UseZbb);\n@@ -230,0 +229,1 @@\n+    assert(UseZbb, \"must be\");\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3608,0 +3608,22 @@\n+instruct vstring_compareU_128b(iRegP_R11 str1, iRegI_R12 cnt1, iRegP_R13 str2, iRegI_R14 cnt2,\n+                          iRegI_R10 result, vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7,\n+                          vReg_V8 v8, vReg_V9 v9, vReg_V10 v10, vReg_V11 v11,\n+                          iRegP_R28 tmp1, iRegL_R29 tmp2)\n+%{\n+  predicate(UseRVV && ((StrCompNode *)n)->encoding() == StrIntrinsicNode::UU &&\n+            MaxVectorSize == 16);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(KILL tmp1, KILL tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2,\n+        TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v8, TEMP v9, TEMP v10, TEMP v11);\n+\n+  format %{ \"String Compare $str1, $cnt1, $str2, $cnt2 -> $result\\t#@string_compareU\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare_v($str1$$Register, $str2$$Register,\n+                        $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                        $tmp1$$Register, $tmp2$$Register,\n+                        StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -3612,1 +3634,2 @@\n-  predicate(UseRVV && ((StrCompNode *)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(UseRVV && ((StrCompNode *)n)->encoding() == StrIntrinsicNode::UU &&\n+            MaxVectorSize > 16);\n@@ -3615,1 +3638,1 @@\n-         TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n+        TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n@@ -3627,0 +3650,1 @@\n+\n@@ -3634,1 +3658,1 @@\n-         TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n+        TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1641,8 +1641,2 @@\n-  {\n-    ExternalAddress target((address)&DTraceMethodProbes);\n-    __ relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      __ la(t0, target.target(), offset);\n-      __ lbu(t0, Address(t0, offset));\n-    });\n-    __ bnez(t0, dtrace_method_entry);\n+  if (DTraceMethodProbes) {\n+    __ j(dtrace_method_entry);\n@@ -1864,8 +1858,2 @@\n-  {\n-    ExternalAddress target((address)&DTraceMethodProbes);\n-    __ relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      __ la(t0, target.target(), offset);\n-      __ lbu(t0, Address(t0, offset));\n-    });\n-    __ bnez(t0, dtrace_method_exit);\n+  if (DTraceMethodProbes) {\n+    __ j(dtrace_method_exit);\n@@ -2012,16 +2000,17 @@\n-  {\n-    __ block_comment(\"dtrace entry {\");\n-    __ bind(dtrace_method_entry);\n-\n-    \/\/ We have all of the arguments setup at this point. We must not touch any register\n-    \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n-\n-    save_args(masm, total_c_args, c_arg, out_regs);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-      CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n-      xthread, c_rarg1);\n-    restore_args(masm, total_c_args, c_arg, out_regs);\n-    __ j(dtrace_method_entry_done);\n-    __ block_comment(\"} dtrace entry\");\n-  }\n+  if (DTraceMethodProbes) {\n+    {\n+      __ block_comment(\"dtrace entry {\");\n+      __ bind(dtrace_method_entry);\n+\n+      \/\/ We have all of the arguments setup at this point. We must not touch any register\n+      \/\/ argument registers at this point (what if we save\/restore them there are no oop?\n+\n+      save_args(masm, total_c_args, c_arg, out_regs);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+        CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),\n+        xthread, c_rarg1);\n+      restore_args(masm, total_c_args, c_arg, out_regs);\n+      __ j(dtrace_method_entry_done);\n+      __ block_comment(\"} dtrace entry\");\n+    }\n@@ -2029,11 +2018,12 @@\n-  {\n-    __ block_comment(\"dtrace exit {\");\n-    __ bind(dtrace_method_exit);\n-    save_native_result(masm, ret_type, stack_slots);\n-    __ mov_metadata(c_rarg1, method());\n-    __ call_VM_leaf(\n-         CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n-         xthread, c_rarg1);\n-    restore_native_result(masm, ret_type, stack_slots);\n-    __ j(dtrace_method_exit_done);\n-    __ block_comment(\"} dtrace exit\");\n+    {\n+      __ block_comment(\"dtrace exit {\");\n+      __ bind(dtrace_method_exit);\n+      save_native_result(masm, ret_type, stack_slots);\n+      __ mov_metadata(c_rarg1, method());\n+      __ call_VM_leaf(\n+           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n+           xthread, c_rarg1);\n+      restore_native_result(masm, ret_type, stack_slots);\n+      __ j(dtrace_method_exit_done);\n+      __ block_comment(\"} dtrace exit\");\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":33,"deletions":43,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2811,0 +2811,44 @@\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = x10,\n+      r_array_base   = x11,\n+      r_array_length = x12,\n+      r_array_index  = x13,\n+      r_sub_klass    = x14,\n+      result         = x15,\n+      r_bitmap       = x16;\n+\n+    Label L_success;\n+    __ enter();\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     r_bitmap, super_klass_index, \/*stub_is_near*\/true);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = x10,        \/\/ argument\n+      r_array_base   = x11,        \/\/ argument\n+      temp1          = x12,        \/\/ tmp\n+      r_array_index  = x13,        \/\/ argument\n+      result         = x15,        \/\/ argument\n+      r_bitmap       = x16;        \/\/ argument\n+\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap, result, temp1);\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -5272,0 +5316,46 @@\n+  \/**\n+   *  Arguments:\n+   *\n+   * Inputs:\n+   *   c_rarg0   - int crc\n+   *   c_rarg1   - byte* buf\n+   *   c_rarg2   - int length\n+   *\n+   * Output:\n+   *   c_rarg0   - int crc result\n+   *\/\n+  address generate_updateBytesCRC32() {\n+    assert(UseCRC32Intrinsics, \"what are we doing here?\");\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesCRC32\");\n+\n+    address start = __ pc();\n+\n+    const Register crc    = c_rarg0;  \/\/ crc\n+    const Register buf    = c_rarg1;  \/\/ source java byte array address\n+    const Register len    = c_rarg2;  \/\/ length\n+    const Register table0 = c_rarg3;  \/\/ crc_table address\n+    const Register table1 = c_rarg4;\n+    const Register table2 = c_rarg5;\n+    const Register table3 = c_rarg6;\n+\n+    const Register tmp1 = c_rarg7;\n+    const Register tmp2 = t2;\n+    const Register tmp3 = x28; \/\/ t3\n+    const Register tmp4 = x29; \/\/ t4\n+    const Register tmp5 = x30; \/\/ t5\n+    const Register tmp6 = x31; \/\/ t6\n+\n+    BLOCK_COMMENT(\"Entry:\");\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    __ kernel_crc32(crc, buf, len, table0, table1, table2,\n+                    table3, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -5518,0 +5608,6 @@\n+\n+    if (UseCRC32Intrinsics) {\n+      \/\/ set table address before stub generation which use it\n+      StubRoutines::_crc_table_adr = (address)StubRoutines::riscv::_crc_table;\n+      StubRoutines::_updateBytesCRC32 = generate_updateBytesCRC32();\n+    }\n@@ -5569,0 +5665,12 @@\n+#ifdef COMPILER2\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (!InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n+            = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -58,0 +58,222 @@\n+\n+\/**\n+ *  crc_table[] from jdk\/src\/java.base\/share\/native\/libzip\/zlib\/crc32.h\n+ *\/\n+ATTRIBUTE_ALIGNED(4096) juint StubRoutines::riscv::_crc_table[] =\n+{\n+    \/\/ Table 0\n+    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,\n+    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,\n+    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,\n+    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,\n+    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,\n+    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,\n+    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,\n+    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,\n+    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,\n+    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,\n+    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,\n+    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,\n+    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,\n+    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,\n+    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,\n+    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,\n+    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,\n+    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,\n+    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,\n+    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,\n+    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,\n+    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,\n+    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,\n+    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,\n+    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,\n+    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,\n+    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,\n+    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,\n+    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,\n+    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,\n+    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,\n+    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,\n+    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,\n+    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,\n+    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,\n+    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,\n+    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,\n+    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,\n+    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,\n+    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,\n+    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,\n+    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,\n+    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,\n+    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,\n+    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,\n+    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,\n+    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,\n+    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,\n+    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,\n+    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,\n+    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,\n+    0x2d02ef8dUL,\n+\n+    \/\/ Table 1\n+    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,\n+    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,\n+    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,\n+    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,\n+    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,\n+    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,\n+    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,\n+    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,\n+    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,\n+    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,\n+    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,\n+    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,\n+    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,\n+    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,\n+    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,\n+    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,\n+    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,\n+    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,\n+    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,\n+    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,\n+    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,\n+    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,\n+    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,\n+    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,\n+    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,\n+    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,\n+    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,\n+    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,\n+    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,\n+    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,\n+    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,\n+    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,\n+    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,\n+    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,\n+    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,\n+    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,\n+    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,\n+    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,\n+    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,\n+    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,\n+    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,\n+    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,\n+    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,\n+    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,\n+    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,\n+    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,\n+    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,\n+    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,\n+    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,\n+    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,\n+    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,\n+    0x9324fd72UL,\n+\n+    \/\/ Table 2\n+    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,\n+    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,\n+    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,\n+    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,\n+    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,\n+    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,\n+    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,\n+    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,\n+    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,\n+    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,\n+    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,\n+    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,\n+    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,\n+    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,\n+    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,\n+    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,\n+    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,\n+    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,\n+    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,\n+    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,\n+    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,\n+    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,\n+    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,\n+    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,\n+    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,\n+    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,\n+    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,\n+    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,\n+    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,\n+    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,\n+    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,\n+    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,\n+    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,\n+    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,\n+    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,\n+    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,\n+    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,\n+    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,\n+    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,\n+    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,\n+    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,\n+    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,\n+    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,\n+    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,\n+    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,\n+    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,\n+    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,\n+    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,\n+    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,\n+    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,\n+    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,\n+    0xbe9834edUL,\n+\n+    \/\/ Table 3\n+    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,\n+    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,\n+    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,\n+    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,\n+    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,\n+    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,\n+    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,\n+    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,\n+    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,\n+    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,\n+    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,\n+    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,\n+    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,\n+    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,\n+    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,\n+    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,\n+    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,\n+    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,\n+    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,\n+    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,\n+    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,\n+    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,\n+    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,\n+    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,\n+    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,\n+    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,\n+    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,\n+    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,\n+    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,\n+    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,\n+    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,\n+    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,\n+    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,\n+    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,\n+    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,\n+    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,\n+    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,\n+    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,\n+    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,\n+    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,\n+    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,\n+    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,\n+    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,\n+    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,\n+    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,\n+    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,\n+    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,\n+    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,\n+    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,\n+    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,\n+    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,\n+    0xde0506f1UL,\n+};\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":222,"deletions":0,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+\n+private:\n+  static juint    _crc_table[];\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3595,2 +3595,1 @@\n-    {\n-      SkipIfEqual skip(_masm, &DTraceAllocProbes, false);\n+    if (DTraceAllocProbes) {\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,2 +134,8 @@\n-  if (UseCRC32Intrinsics) {\n-    warning(\"CRC32 intrinsics are not available on this CPU.\");\n+  if (UseZba) {\n+    if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);\n+    }\n+  } else {\n+    if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {\n+      warning(\"CRC32 intrinsic requires Zba instructions (not available on this CPU)\");\n+    }\n@@ -330,8 +336,3 @@\n-    if (FLAG_IS_DEFAULT(MaxVectorSize)) {\n-      MaxVectorSize = _initial_vector_length;\n-    } else if (!is_power_of_2(MaxVectorSize)) {\n-      vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d, must be a power of 2\", (int)MaxVectorSize));\n-    } else if (MaxVectorSize > _initial_vector_length) {\n-      warning(\"Current system only supports max RVV vector length %d. Set MaxVectorSize to %d\",\n-              _initial_vector_length, _initial_vector_length);\n-      MaxVectorSize = _initial_vector_length;\n+    if (!FLAG_IS_DEFAULT(MaxVectorSize) && MaxVectorSize != _initial_vector_length) {\n+      warning(\"Current system does not support RVV vector length for MaxVectorSize %d. Set MaxVectorSize to %d\",\n+               (int)MaxVectorSize, _initial_vector_length);\n@@ -339,0 +340,1 @@\n+    MaxVectorSize = _initial_vector_length;\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -280,0 +280,2 @@\n+  constexpr static bool supports_secondary_supers_table() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  \/\/ Load object header.\n-  z_lg(Rmark, Address(Roop, hdr_offset));\n-\n@@ -88,0 +85,4 @@\n+\n+    \/\/ Load object header.\n+    z_lg(Rmark, Address(Roop, hdr_offset));\n+\n@@ -144,6 +145,1 @@\n-    const Register tmp = Z_R1_scratch;\n-    z_lg(Rmark, Address(Roop, hdr_offset));\n-    z_lgr(tmp, Rmark);\n-    z_nill(tmp, markWord::monitor_value);\n-    branch_optimized(Assembler::bcondNotZero, slow_case);\n-    lightweight_unlock(Roop, Rmark, tmp, slow_case);\n+    lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -36,0 +36,9 @@\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_lock_lightweight_object(obj, temp1, temp2);\n+}\n+\n+\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_unlock_lightweight_object(obj, temp1, temp2);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -32,0 +32,4 @@\n+  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in s390.ad file.\n+  void fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n+  void fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1008,3 +1008,0 @@\n-  \/\/ Load markWord from object into header.\n-  z_lg(header, hdr_offset, object);\n-\n@@ -1018,1 +1015,1 @@\n-    lightweight_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+    lightweight_lock(object, header, tmp, slow_case);\n@@ -1021,0 +1018,3 @@\n+    \/\/ Load markWord from object into header.\n+    z_lg(header, hdr_offset, object);\n+\n@@ -1156,18 +1156,0 @@\n-    \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-    \/\/ must handle it.\n-\n-    Register tmp = current_header;\n-\n-    \/\/ First check for lock-stack underflow.\n-    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondNotHigh, slow_case);\n-\n-    \/\/ Then check if the top of the lock-stack matches the unlocked object.\n-    z_aghi(tmp, -oopSize);\n-    z_lg(tmp, Address(Z_thread, tmp));\n-    compare64_and_branch(tmp, object, Assembler::bcondNotEqual, slow_case);\n-\n-    z_lg(header, Address(object, hdr_offset));\n-    z_lgr(tmp, header);\n-    z_nill(tmp, markWord::monitor_value);\n-    z_brne(slow_case);\n@@ -1175,1 +1157,1 @@\n-    lightweight_unlock(object, header, tmp, slow_case);\n+    lightweight_unlock(object, header, current_header, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3193,0 +3193,1 @@\n+\/\/ \"The box\" is the space on the stack where we copy the object mark.\n@@ -3194,0 +3195,4 @@\n+\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n+  assert_different_registers(oop, box, temp1, temp2);\n+\n@@ -3195,2 +3200,3 @@\n-  Register currentHeader = temp1;\n-  Register temp = temp2;\n+  Register currentHeader   = temp1;\n+  Register temp            = temp2;\n+\n@@ -3201,2 +3207,0 @@\n-  assert_different_registers(temp1, temp2, oop, box);\n-\n@@ -3210,2 +3214,4 @@\n-    testbit(Address(temp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n-    z_btrue(done);\n+    z_l(temp, Address(temp, Klass::access_flags_offset()));\n+    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n+    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_brne(done);\n@@ -3225,1 +3231,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -3254,4 +3261,0 @@\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-    lightweight_lock(oop, displacedHeader, temp, done);\n@@ -3273,4 +3276,3 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Store a non-null value into the box.\n-    z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  }\n+\n+  \/\/ Store a non-null value into the box.\n+  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n@@ -3298,0 +3300,4 @@\n+\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n+  assert_different_registers(oop, box, temp1, temp2);\n+\n@@ -3299,2 +3305,2 @@\n-  Register currentHeader = temp2;\n-  Register temp = temp1;\n+  Register currentHeader   = temp2;\n+  Register temp            = temp1;\n@@ -3304,2 +3310,0 @@\n-  assert_different_registers(temp1, temp2, oop, box);\n-\n@@ -3329,1 +3333,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -3336,5 +3341,0 @@\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n-    lightweight_unlock(oop, currentHeader, displacedHeader, done);\n-    z_bru(done);\n@@ -5708,3 +5708,0 @@\n-\/\/ Branches to slow upon failure to lock the object.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5712,1 +5709,1 @@\n-\/\/  - hdr: the header, already loaded from obj, contents destroyed.\n+\/\/  - temp1, temp2: temporary registers, contents destroyed.\n@@ -5714,1 +5711,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register temp, Label& slow_case) {\n+void MacroAssembler::lightweight_lock(Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -5717,1 +5714,12 @@\n-  assert_different_registers(obj, hdr, temp);\n+  assert_different_registers(obj, temp1, temp2);\n+\n+  Label push;\n+  const Register top           = temp1;\n+  const Register mark          = temp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  \/\/ Preload the markWord. It is important that this is the first\n+  \/\/ instruction emitted as it is part of C1's null check semantics.\n+  z_lg(mark, Address(obj, mark_offset));\n+\n@@ -5720,1 +5728,1 @@\n-  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n@@ -5722,1 +5730,1 @@\n-  compareU32_and_branch(temp, (unsigned)LockStack::end_offset()-1, bcondHigh, slow_case);\n+  compareU32_and_branch(top, (unsigned)LockStack::end_offset(), bcondNotLow, slow);\n@@ -5724,3 +5732,2 @@\n-  \/\/ attempting a lightweight_lock\n-  \/\/ Load (object->mark() | 1) into hdr\n-  z_oill(hdr, markWord::unlocked_value);\n+  \/\/ The underflow check is elided. The recursive check will always fail\n+  \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n@@ -5728,1 +5735,4 @@\n-  z_lgr(temp, hdr);\n+  \/\/ Check for recursion:\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  z_bre(push);\n@@ -5730,2 +5740,3 @@\n-  \/\/ Clear lock-bits from hdr (locked state)\n-  z_xilf(temp, markWord::unlocked_value);\n+  \/\/ Check header for monitor (0b10).\n+  z_tmll(mark, markWord::monitor_value);\n+  branch_optimized(bcondNotAllZero, slow);\n@@ -5733,2 +5744,9 @@\n-  z_csg(hdr, temp, oopDesc::mark_offset_in_bytes(), obj);\n-  branch_optimized(Assembler::bcondNotEqual, slow_case);\n+  { \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+    const Register locked_obj = top;\n+    z_oill(mark, markWord::unlocked_value);\n+    z_lgr(locked_obj, mark);\n+    \/\/ Clear lock-bits from locked_obj (locked state)\n+    z_xilf(locked_obj, markWord::unlocked_value);\n+    z_csg(mark, locked_obj, mark_offset, obj);\n+    branch_optimized(Assembler::bcondNotEqual, slow);\n+  }\n@@ -5736,5 +5754,1 @@\n-  \/\/ After successful lock, push object on lock-stack\n-  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-  z_stg(obj, Address(Z_thread, temp));\n-  z_ahi(temp, oopSize);\n-  z_st(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  bind(push);\n@@ -5742,2 +5756,4 @@\n-  \/\/ as locking was successful, set CC to EQ\n-  z_cr(temp, temp);\n+  \/\/ After successful lock, push object on lock-stack\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  z_stg(obj, Address(Z_thread, top));\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n@@ -5747,3 +5763,0 @@\n-\/\/ Branches to slow upon failure.\n-\/\/ Falls through upon success.\n-\/\/\n@@ -5751,1 +5764,1 @@\n-\/\/ - hdr: the (pre-loaded) header of the object, will be destroyed\n+\/\/ - temp1, temp2: temporary registers, will be destroyed\n@@ -5753,1 +5766,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -5756,1 +5769,7 @@\n-  assert_different_registers(obj, hdr, tmp);\n+  assert_different_registers(obj, temp1, temp2);\n+\n+  Label unlocked, push_and_slow;\n+  const Register mark          = temp1;\n+  const Register top           = temp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n@@ -5759,9 +5778,0 @@\n-  {\n-    \/\/ Check that hdr is lightweight-locked.\n-    Label hdr_ok;\n-    z_lgr(tmp, hdr);\n-    z_nill(tmp, markWord::lock_mask_in_place);\n-    z_bre(hdr_ok);\n-    stop(\"Header is not lightweight-locked\");\n-    bind(hdr_ok);\n-  }\n@@ -5774,3 +5784,3 @@\n-    Label stack_ok;\n-    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondHigh, stack_ok);\n+    NearLabel stack_ok;\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    compareU32_and_branch(top, (unsigned)LockStack::start_offset(), bcondNotLow, stack_ok);\n@@ -5780,8 +5790,155 @@\n-  {\n-    \/\/ Check if the top of the lock-stack matches the unlocked object.\n-    Label tos_ok;\n-    z_aghi(tmp, -oopSize);\n-    z_lg(tmp, Address(Z_thread, tmp));\n-    compare64_and_branch(tmp, obj, Assembler::bcondEqual, tos_ok);\n-    stop(\"Top of lock-stack does not match the unlocked object\");\n-    bind(tos_ok);\n+#endif \/\/ ASSERT\n+\n+  \/\/ Check if obj is top of lock-stack.\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  branch_optimized(bcondNotEqual, slow);\n+\n+  \/\/ pop object from lock-stack\n+#ifdef ASSERT\n+  const Register temp_top = temp1; \/\/ mark is not yet loaded, but be careful\n+  z_agrk(temp_top, top, Z_thread);\n+  z_xc(0, oopSize-1, temp_top, 0, temp_top);  \/\/ wipe out lock-stack entry\n+#endif \/\/ ASSERT\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, -oopSize);  \/\/ pop object\n+\n+  \/\/ The underflow check is elided. The recursive check will always fail\n+  \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+  \/\/ Check if recursive. (this is a check for the 2nd object on the stack)\n+  z_aghi(top, -oopSize);\n+  z_cg(obj, Address(Z_thread, top));\n+  branch_optimized(bcondEqual, unlocked);\n+\n+  \/\/ Not recursive. Check header for monitor (0b10).\n+  z_lg(mark, Address(obj, mark_offset));\n+  z_tmll(mark, markWord::monitor_value);\n+  z_brnaz(push_and_slow);\n+\n+#ifdef ASSERT\n+  \/\/ Check header not unlocked (0b01).\n+  NearLabel not_unlocked;\n+  z_tmll(mark, markWord::unlocked_value);\n+  z_braz(not_unlocked);\n+  stop(\"lightweight_unlock already unlocked\");\n+  bind(not_unlocked);\n+#endif \/\/ ASSERT\n+\n+  { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+    Register unlocked_obj = top;\n+    z_lgr(unlocked_obj, mark);\n+    z_oill(unlocked_obj, markWord::unlocked_value);\n+    z_csg(mark, unlocked_obj, mark_offset, obj);\n+    branch_optimized(Assembler::bcondEqual, unlocked);\n+  }\n+\n+  bind(push_and_slow);\n+\n+  \/\/ Restore lock-stack and handle the unlock in runtime.\n+  z_lgf(top, Address(Z_thread, ls_top_offset));\n+  DEBUG_ONLY(z_stg(obj, Address(Z_thread, top));)\n+  z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+  \/\/ set CC to NE\n+  z_ltgr(obj, obj); \/\/ object shouldn't be null at this point\n+  branch_optimized(bcondAlways, slow);\n+\n+  bind(unlocked);\n+}\n+\n+void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, tmp1, tmp2);\n+\n+  \/\/ Handle inflated monitor.\n+  NearLabel inflated;\n+  \/\/ Finish fast lock successfully. MUST reach to with flag == NE\n+  NearLabel locked;\n+  \/\/ Finish fast lock unsuccessfully. MUST branch to with flag == EQ\n+  NearLabel slow_path;\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp1, obj);\n+    z_l(tmp1, Address(tmp1, Klass::access_flags_offset()));\n+    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n+    z_nilh(tmp1, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_brne(slow_path);\n+  }\n+\n+  const Register mark          = tmp1;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  BLOCK_COMMENT(\"compiler_fast_lightweight_locking {\");\n+  { \/\/ lightweight locking\n+\n+    \/\/ Push lock to the lock stack and finish successfully. MUST reach to with flag == EQ\n+    NearLabel push;\n+\n+    const Register top = tmp2;\n+\n+    \/\/ Check if lock-stack is full.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    compareU32_and_branch(top, (unsigned) LockStack::end_offset() - 1, bcondHigh, slow_path);\n+\n+    \/\/ The underflow check is elided. The recursive check will always fail\n+    \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+    \/\/ Check if recursive.\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_bre(push);\n+\n+    \/\/ Check for monitor (0b10)\n+    z_lg(mark, Address(obj, mark_offset));\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+\n+    \/\/ not inflated\n+\n+    { \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+      assert(mark_offset == 0, \"required to avoid a lea\");\n+      const Register locked_obj = top;\n+      z_oill(mark, markWord::unlocked_value);\n+      z_lgr(locked_obj, mark);\n+      \/\/ Clear lock-bits from locked_obj (locked state)\n+      z_xilf(locked_obj, markWord::unlocked_value);\n+      z_csg(mark, locked_obj, mark_offset, obj);\n+      branch_optimized(Assembler::bcondNotEqual, slow_path);\n+    }\n+\n+    bind(push);\n+\n+    \/\/ After successful lock, push object on lock-stack.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    z_stg(obj, Address(Z_thread, top));\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+\n+    z_cgr(obj, obj); \/\/ set the CC to EQ, as it could be changed by alsi\n+    z_bru(locked);\n+  }\n+  BLOCK_COMMENT(\"} compiler_fast_lightweight_locking\");\n+\n+  BLOCK_COMMENT(\"handle_inflated_monitor_lightweight_locking {\");\n+  { \/\/ Handle inflated monitor.\n+    bind(inflated);\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register tagged_monitor = mark;\n+    const Register zero           = tmp2;\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n+    z_bre(locked);\n+\n+    \/\/ Check if recursive.\n+    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+    z_brne(slow_path);\n+\n+    \/\/ Recursive\n+    z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+    z_cgr(zero, zero);\n+    \/\/ z_bru(locked);\n+    \/\/ Uncomment above line in the future, for now jump address is right next to us.\n@@ -5789,0 +5946,18 @@\n+  BLOCK_COMMENT(\"} handle_inflated_monitor_lightweight_locking\");\n+\n+  bind(locked);\n+\n+#ifdef ASSERT\n+  \/\/ Check that locked label is reached with flag == EQ.\n+  NearLabel flag_correct;\n+  z_bre(flag_correct);\n+  stop(\"CC is not set to EQ, it should be - lock\");\n+#endif \/\/ ASSERT\n+\n+  bind(slow_path);\n+\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  z_brne(flag_correct);\n+  stop(\"CC is not set to NE, it should be - lock\");\n+  bind(flag_correct);\n@@ -5791,4 +5966,5 @@\n-  z_lgr(tmp, hdr);\n-  z_oill(tmp, markWord::unlocked_value);\n-  z_csg(hdr, tmp, oopDesc::mark_offset_in_bytes(), obj);\n-  branch_optimized(Assembler::bcondNotEqual, slow);\n+  \/\/ C2 uses the value of flag (NE vs EQ) to determine the continuation.\n+}\n+\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, tmp1, tmp2);\n@@ -5796,1 +5972,23 @@\n-  \/\/ After successful unlock, pop object from lock-stack\n+  \/\/ Handle inflated monitor.\n+  NearLabel inflated, inflated_load_monitor;\n+  \/\/ Finish fast unlock successfully. MUST reach to with flag == EQ.\n+  NearLabel unlocked;\n+  \/\/ Finish fast unlock unsuccessfully. MUST branch to with flag == NE.\n+  NearLabel slow_path;\n+\n+  const Register mark          = tmp1;\n+  const Register top           = tmp2;\n+  const int mark_offset        = oopDesc::mark_offset_in_bytes();\n+  const ByteSize ls_top_offset = JavaThread::lock_stack_top_offset();\n+\n+  BLOCK_COMMENT(\"compiler_fast_lightweight_unlock {\");\n+  { \/\/ Lightweight Unlock\n+\n+    \/\/ Check if obj is top of lock-stack.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    branch_optimized(bcondNotEqual, inflated_load_monitor);\n+\n+    \/\/ Pop lock-stack.\n@@ -5798,4 +5996,3 @@\n-  z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n-  z_aghi(tmp, -oopSize);\n-  z_agr(tmp, Z_thread);\n-  z_xc(0, oopSize-1, tmp, 0, tmp);  \/\/ wipe out lock-stack entry\n+    const Register temp_top = tmp1; \/\/ let's not kill top here, we can use for recursive check\n+    z_agrk(temp_top, top, Z_thread);\n+    z_xc(0, oopSize-1, temp_top, 0, temp_top);  \/\/ wipe out lock-stack entry\n@@ -5803,2 +6000,128 @@\n-  z_alsi(in_bytes(JavaThread::lock_stack_top_offset()), Z_thread, -oopSize);  \/\/ pop object\n-  z_cr(tmp, tmp); \/\/ set CC to EQ\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, -oopSize);  \/\/ pop object\n+\n+    \/\/ The underflow check is elided. The recursive check will always fail\n+    \/\/ when the lock stack is empty because of the _bad_oop_sentinel field.\n+\n+    \/\/ Check if recursive.\n+    z_aghi(top, -oopSize);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_bre(unlocked);\n+\n+    \/\/ Not recursive\n+\n+    \/\/ Check for monitor (0b10).\n+    z_lg(mark, Address(obj, mark_offset));\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+\n+#ifdef ASSERT\n+    \/\/ Check header not unlocked (0b01).\n+    NearLabel not_unlocked;\n+    z_tmll(mark, markWord::unlocked_value);\n+    z_braz(not_unlocked);\n+    stop(\"lightweight_unlock already unlocked\");\n+    bind(not_unlocked);\n+#endif \/\/ ASSERT\n+\n+    { \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+      Register unlocked_obj = top;\n+      z_lgr(unlocked_obj, mark);\n+      z_oill(unlocked_obj, markWord::unlocked_value);\n+      z_csg(mark, unlocked_obj, mark_offset, obj);\n+      branch_optimized(Assembler::bcondEqual, unlocked);\n+    }\n+\n+    \/\/ Restore lock-stack and handle the unlock in runtime.\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    DEBUG_ONLY(z_stg(obj, Address(Z_thread, top));)\n+    z_alsi(in_bytes(ls_top_offset), Z_thread, oopSize);\n+    \/\/ set CC to NE\n+    z_ltgr(obj, obj); \/\/ object is not null here\n+    z_bru(slow_path);\n+  }\n+  BLOCK_COMMENT(\"} compiler_fast_lightweight_unlock\");\n+\n+  { \/\/ Handle inflated monitor.\n+\n+    bind(inflated_load_monitor);\n+\n+    z_lg(mark, Address(obj, mark_offset));\n+\n+#ifdef ASSERT\n+    z_tmll(mark, markWord::monitor_value);\n+    z_brnaz(inflated);\n+    stop(\"Fast Unlock not monitor\");\n+#endif \/\/ ASSERT\n+\n+    bind(inflated);\n+\n+#ifdef ASSERT\n+    NearLabel check_done, loop;\n+    z_lgf(top, Address(Z_thread, ls_top_offset));\n+    bind(loop);\n+    z_aghi(top, -oopSize);\n+    compareU32_and_branch(top, in_bytes(JavaThread::lock_stack_base_offset()),\n+                          bcondLow, check_done);\n+    z_cg(obj, Address(Z_thread, top));\n+    z_brne(loop);\n+    stop(\"Fast Unlock lock on stack\");\n+    bind(check_done);\n+#endif \/\/ ASSERT\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n+\n+    NearLabel not_recursive;\n+    const Register recursions = tmp2;\n+\n+    \/\/ Check if recursive.\n+    load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+\n+    \/\/ Recursive unlock\n+    z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+    z_bru(unlocked);\n+\n+    bind(not_recursive);\n+\n+    NearLabel not_ok;\n+    \/\/ Check if the entry lists are empty.\n+    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    z_brne(not_ok);\n+    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+    z_brne(not_ok);\n+\n+    z_release();\n+    z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+\n+    z_bru(unlocked); \/\/ CC = EQ here\n+\n+    bind(not_ok);\n+\n+    \/\/ The owner may be anonymous, and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+    z_bru(slow_path); \/\/ CC = NE here\n+  }\n+\n+  bind(unlocked);\n+\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with flag == EQ.\n+  NearLabel flag_correct;\n+  z_bre(flag_correct);\n+  stop(\"CC is not set to EQ, it should be - unlock\");\n+#endif \/\/ ASSERT\n+\n+  bind(slow_path);\n+\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  z_brne(flag_correct);\n+  stop(\"CC is not set to NE, it should be - unlock\");\n+  bind(flag_correct);\n+#endif \/\/ ASSERT\n+\n+  \/\/ C2 uses the value of flag (NE vs EQ) to determine the continuation.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":408,"deletions":85,"binary":false,"changes":493,"status":"modified"},{"patch":"@@ -730,2 +730,4 @@\n-  void lightweight_lock(Register obj, Register hdr, Register tmp, Label& slow);\n-  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void lightweight_unlock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n+  void compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9582,0 +9582,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -9592,0 +9593,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -9601,0 +9603,32 @@\n+instruct cmpFastLockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set pcc (FastLock oop box));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_cost(100);\n+  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n+  format %{ \"FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n+  ins_encode %{\n+    __ fast_lock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    \/\/ If locking was successful, cc should indicate 'EQ'.\n+    \/\/ The compiler generates a branch to the runtime call to\n+    \/\/ _complete_monitor_locking_Java for the case where cc is 'NE'.\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct cmpFastUnlockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set pcc (FastUnlock oop box));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_cost(100);\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n+  format %{ \"FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n+  ins_encode %{\n+    __ fast_unlock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    \/\/ If unlocking was successful, cc should indicate 'EQ'.\n+    \/\/ The compiler generates a branch to the runtime call to\n+    \/\/ _complete_monitor_unlocking_Java for the case where cc is 'NE'.\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1714,2 +1714,7 @@\n-    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-    __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+      __ compiler_fast_lock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+    } else {\n+      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+      __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    }\n@@ -1913,2 +1918,7 @@\n-    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-    __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+      __ compiler_fast_unlock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+    } else {\n+      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+      __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3979,2 +3979,1 @@\n-    {\n-      SkipIfEqual skip(_masm, &DTraceAllocProbes, false, Z_ARG5 \/*scratch*\/);\n+    if (DTraceAllocProbes) {\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  constexpr static bool supports_recursive_lightweight_locking() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -845,1 +845,1 @@\n-    if ((0xFF & *ip++) & REXBIT_W) {\n+    if ((0xFF & *ip++) & REX2BIT_W) {\n@@ -902,1 +902,1 @@\n-      if ((0xFF & *ip++) & REXBIT_W) {\n+      if ((0xFF & *ip++) & REX2BIT_W) {\n@@ -4501,1 +4501,1 @@\n-  assert(!needs_eevex(src.base(), src.index()), \"does not support extended gprs\");\n+  assert(!needs_eevex(src.base(), src.index()), \"does not support extended gprs as BASE or INDEX of address operand\");\n@@ -5896,0 +5896,65 @@\n+#ifdef _LP64\n+void Assembler::push2(Register src1, Register src2, bool with_ppx) {\n+  assert(VM_Version::supports_apx_f(), \"requires APX\");\n+  InstructionAttr attributes(0, \/* rex_w *\/ with_ppx, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  \/* EVEX.BASE *\/\n+  int src_enc = src1->encoding();\n+  \/* EVEX.VVVV *\/\n+  int nds_enc = src2->encoding();\n+\n+  bool vex_b = (src_enc & 8) == 8;\n+  bool evex_v = (nds_enc >= 16);\n+  bool evex_b = (src_enc >= 16);\n+\n+  \/\/ EVEX.ND = 1;\n+  attributes.set_extended_context();\n+  attributes.set_is_evex_instruction();\n+  set_attributes(&attributes);\n+\n+  evex_prefix(0, vex_b, 0, 0, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, VEX_SIMD_NONE, \/* map4 *\/ VEX_OPCODE_0F_3C);\n+  emit_int16(0xFF, (0xC0 | (0x6 << 3) | (src_enc & 7)));\n+}\n+\n+void Assembler::pop2(Register src1, Register src2, bool with_ppx) {\n+  assert(VM_Version::supports_apx_f(), \"requires APX\");\n+  InstructionAttr attributes(0, \/* rex_w *\/ with_ppx, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  \/* EVEX.BASE *\/\n+  int src_enc = src1->encoding();\n+  \/* EVEX.VVVV *\/\n+  int nds_enc = src2->encoding();\n+\n+  bool vex_b = (src_enc & 8) == 8;\n+  bool evex_v = (nds_enc >= 16);\n+  bool evex_b = (src_enc >= 16);\n+\n+  \/\/ EVEX.ND = 1;\n+  attributes.set_extended_context();\n+  attributes.set_is_evex_instruction();\n+  set_attributes(&attributes);\n+\n+  evex_prefix(0, vex_b, 0, 0, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, VEX_SIMD_NONE, \/* map4 *\/ VEX_OPCODE_0F_3C);\n+  emit_int16(0x8F, (0xC0 | (src_enc & 7)));\n+}\n+\n+void Assembler::push2p(Register src1, Register src2) {\n+  push2(src1, src2, true);\n+}\n+\n+void Assembler::pop2p(Register src1, Register src2) {\n+  pop2(src1, src2, true);\n+}\n+\n+void Assembler::pushp(Register src) {\n+  assert(VM_Version::supports_apx_f(), \"requires APX\");\n+  int encode = prefixq_and_encode_rex2(src->encoding());\n+  emit_int8(0x50 | encode);\n+}\n+\n+void Assembler::popp(Register dst) {\n+  assert(VM_Version::supports_apx_f(), \"requires APX\");\n+  int encode = prefixq_and_encode_rex2(dst->encoding());\n+  emit_int8((unsigned char)0x58 | encode);\n+}\n+#endif \/\/_LP64\n+\n+\n@@ -7210,0 +7275,1 @@\n+  assert(!needs_eevex(src.base(), src.index()), \"does not support extended gprs as BASE or INDEX of address operand\");\n@@ -11014,0 +11080,1 @@\n+  assert(!needs_eevex(src.base()), \"does not support extended gprs as BASE of address operand\");\n@@ -11027,0 +11094,1 @@\n+  assert(!needs_eevex(src.base()), \"does not support extended gprs as BASE of address operand\");\n@@ -11040,0 +11108,1 @@\n+  assert(!needs_eevex(src.base()), \"does not support extended gprs as BASE of address operand\");\n@@ -11053,0 +11122,1 @@\n+  assert(!needs_eevex(src.base()), \"does not support extended gprs as BASE of address operand\");\n@@ -11811,1 +11881,0 @@\n-\n@@ -12924,1 +12993,1 @@\n-  if (enc & 8) bits |= REXBIT_B;\n+  if (enc & 8) bits |= REX2BIT_B;\n@@ -12931,1 +13000,1 @@\n-  if (enc & 8) bits |= REXBIT_X;\n+  if (enc & 8) bits |= REX2BIT_X;\n@@ -12946,1 +13015,1 @@\n-  if (enc & 8) bits |= REXBIT_R;\n+  if (enc & 8) bits |= REX2BIT_R;\n@@ -13184,0 +13253,9 @@\n+int Assembler::get_prefixq_rex2(Address adr, bool is_map1) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  int bits = REX2BIT_W;\n+  if (is_map1) bits |= REX2BIT_M0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  return WREX2 | bits;\n+}\n+\n@@ -13193,9 +13271,0 @@\n-int Assembler::get_prefixq_rex2(Address adr, bool is_map1) {\n-  assert(UseAPX, \"APX features not enabled\");\n-  int bits = REXBIT_W;\n-  if (is_map1) bits |= REX2BIT_M0;\n-  bits |= get_base_prefix_bits(adr.base());\n-  bits |= get_index_prefix_bits(adr.index());\n-  return WREX2 | bits;\n-}\n-\n@@ -13246,1 +13315,1 @@\n-  int bits = REXBIT_W;\n+  int bits = REX2BIT_W;\n@@ -13309,1 +13378,1 @@\n-  int bits = REXBIT_W;\n+  int bits = REX2BIT_W;\n@@ -13332,1 +13401,1 @@\n-  prefix16(WREX2 | REXBIT_W | (is_map1 ? REX2BIT_M0: 0) | get_base_prefix_bits(reg_enc));\n+  prefix16(WREX2 | REX2BIT_W | (is_map1 ? REX2BIT_M0: 0) | get_base_prefix_bits(reg_enc));\n@@ -13361,1 +13430,1 @@\n-  int init_bits = REXBIT_W | (is_map1 ? REX2BIT_M0 : 0);\n+  int init_bits = REX2BIT_W | (is_map1 ? REX2BIT_M0 : 0);\n@@ -14171,1 +14240,1 @@\n-  int size = 256;\n+  int size = UseAPX ? 512 : 256;\n@@ -14215,25 +14284,0 @@\n-void Assembler::popa() { \/\/ 64bit\n-  emit_copy(code_section(), popa_code, popa_len);\n-}\n-\n-void Assembler::popa_uncached() { \/\/ 64bit\n-  movq(r15, Address(rsp, 0));\n-  movq(r14, Address(rsp, wordSize));\n-  movq(r13, Address(rsp, 2 * wordSize));\n-  movq(r12, Address(rsp, 3 * wordSize));\n-  movq(r11, Address(rsp, 4 * wordSize));\n-  movq(r10, Address(rsp, 5 * wordSize));\n-  movq(r9,  Address(rsp, 6 * wordSize));\n-  movq(r8,  Address(rsp, 7 * wordSize));\n-  movq(rdi, Address(rsp, 8 * wordSize));\n-  movq(rsi, Address(rsp, 9 * wordSize));\n-  movq(rbp, Address(rsp, 10 * wordSize));\n-  \/\/ Skip rsp as it is restored automatically to the value\n-  \/\/ before the corresponding pusha when popa is done.\n-  movq(rbx, Address(rsp, 12 * wordSize));\n-  movq(rdx, Address(rsp, 13 * wordSize));\n-  movq(rcx, Address(rsp, 14 * wordSize));\n-  movq(rax, Address(rsp, 15 * wordSize));\n-\n-  addq(rsp, 16 * wordSize);\n-}\n@@ -14250,20 +14294,101 @@\n-  subq(rsp, 16 * wordSize);\n-\n-  movq(Address(rsp, 15 * wordSize), rax);\n-  movq(Address(rsp, 14 * wordSize), rcx);\n-  movq(Address(rsp, 13 * wordSize), rdx);\n-  movq(Address(rsp, 12 * wordSize), rbx);\n-  \/\/ Skip rsp as the value is normally not used. There are a few places where\n-  \/\/ the original value of rsp needs to be known but that can be computed\n-  \/\/ from the value of rsp immediately after pusha (rsp + 16 * wordSize).\n-  movq(Address(rsp, 10 * wordSize), rbp);\n-  movq(Address(rsp, 9 * wordSize), rsi);\n-  movq(Address(rsp, 8 * wordSize), rdi);\n-  movq(Address(rsp, 7 * wordSize), r8);\n-  movq(Address(rsp, 6 * wordSize), r9);\n-  movq(Address(rsp, 5 * wordSize), r10);\n-  movq(Address(rsp, 4 * wordSize), r11);\n-  movq(Address(rsp, 3 * wordSize), r12);\n-  movq(Address(rsp, 2 * wordSize), r13);\n-  movq(Address(rsp, wordSize), r14);\n-  movq(Address(rsp, 0), r15);\n+  if (UseAPX) {\n+    \/\/ Data being pushed by PUSH2 must be 16B-aligned on the stack, for this push rax upfront\n+    \/\/ and use it as a temporary register for stack alignment.\n+    pushp(rax);\n+    \/\/ Move original stack pointer to RAX and align stack pointer to 16B boundary.\n+    movq(rax, rsp);\n+    andq(rsp, -(StackAlignmentInBytes));\n+    \/\/ Push pair of original stack pointer along with remaining registers\n+    \/\/ at 16B aligned boundary.\n+    push2p(rax, r31);\n+    push2p(r30, r29);\n+    push2p(r28, r27);\n+    push2p(r26, r25);\n+    push2p(r24, r23);\n+    push2p(r22, r21);\n+    push2p(r20, r19);\n+    push2p(r18, r17);\n+    push2p(r16, r15);\n+    push2p(r14, r13);\n+    push2p(r12, r11);\n+    push2p(r10, r9);\n+    push2p(r8, rdi);\n+    push2p(rsi, rbp);\n+    push2p(rbx, rdx);\n+    \/\/ To maintain 16 byte alignment after rcx is pushed.\n+    subq(rsp, 8);\n+    pushp(rcx);\n+  } else {\n+    subq(rsp, 16 * wordSize);\n+    movq(Address(rsp, 15 * wordSize), rax);\n+    movq(Address(rsp, 14 * wordSize), rcx);\n+    movq(Address(rsp, 13 * wordSize), rdx);\n+    movq(Address(rsp, 12 * wordSize), rbx);\n+    \/\/ Skip rsp as the value is normally not used. There are a few places where\n+    \/\/ the original value of rsp needs to be known but that can be computed\n+    \/\/ from the value of rsp immediately after pusha (rsp + 16 * wordSize).\n+    \/\/ FIXME: For APX any such direct access should also consider EGPR size\n+    \/\/ during address compution.\n+    movq(Address(rsp, 10 * wordSize), rbp);\n+    movq(Address(rsp, 9 * wordSize), rsi);\n+    movq(Address(rsp, 8 * wordSize), rdi);\n+    movq(Address(rsp, 7 * wordSize), r8);\n+    movq(Address(rsp, 6 * wordSize), r9);\n+    movq(Address(rsp, 5 * wordSize), r10);\n+    movq(Address(rsp, 4 * wordSize), r11);\n+    movq(Address(rsp, 3 * wordSize), r12);\n+    movq(Address(rsp, 2 * wordSize), r13);\n+    movq(Address(rsp, wordSize), r14);\n+    movq(Address(rsp, 0), r15);\n+  }\n+}\n+\n+void Assembler::popa() { \/\/ 64bit\n+  emit_copy(code_section(), popa_code, popa_len);\n+}\n+\n+void Assembler::popa_uncached() { \/\/ 64bit\n+  if (UseAPX) {\n+    popp(rcx);\n+    addq(rsp, 8);\n+    \/\/ Data being popped by POP2 must be 16B-aligned on the stack.\n+    pop2p(rdx, rbx);\n+    pop2p(rbp, rsi);\n+    pop2p(rdi, r8);\n+    pop2p(r9, r10);\n+    pop2p(r11, r12);\n+    pop2p(r13, r14);\n+    pop2p(r15, r16);\n+    pop2p(r17, r18);\n+    pop2p(r19, r20);\n+    pop2p(r21, r22);\n+    pop2p(r23, r24);\n+    pop2p(r25, r26);\n+    pop2p(r27, r28);\n+    pop2p(r29, r30);\n+    \/\/ Popped value in RAX holds original unaligned stack pointer.\n+    pop2p(r31, rax);\n+    \/\/ Reinstantiate original stack pointer.\n+    movq(rsp, rax);\n+    popp(rax);\n+  } else {\n+    movq(r15, Address(rsp, 0));\n+    movq(r14, Address(rsp, wordSize));\n+    movq(r13, Address(rsp, 2 * wordSize));\n+    movq(r12, Address(rsp, 3 * wordSize));\n+    movq(r11, Address(rsp, 4 * wordSize));\n+    movq(r10, Address(rsp, 5 * wordSize));\n+    movq(r9,  Address(rsp, 6 * wordSize));\n+    movq(r8,  Address(rsp, 7 * wordSize));\n+    movq(rdi, Address(rsp, 8 * wordSize));\n+    movq(rsi, Address(rsp, 9 * wordSize));\n+    movq(rbp, Address(rsp, 10 * wordSize));\n+    \/\/ Skip rsp as it is restored automatically to the value\n+    \/\/ before the corresponding pusha when popa is done.\n+    movq(rbx, Address(rsp, 12 * wordSize));\n+    movq(rdx, Address(rsp, 13 * wordSize));\n+    movq(rcx, Address(rsp, 14 * wordSize));\n+    movq(rax, Address(rsp, 15 * wordSize));\n+\n+    addq(rsp, 16 * wordSize);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":191,"deletions":66,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -533,4 +533,4 @@\n-    REXBIT_B  = 0x01,\n-    REXBIT_X  = 0x02,\n-    REXBIT_R  = 0x04,\n-    REXBIT_W  = 0x08,\n+    REX2BIT_B  = 0x01,\n+    REX2BIT_X  = 0x02,\n+    REX2BIT_R  = 0x04,\n+    REX2BIT_W  = 0x08,\n@@ -540,1 +540,3 @@\n-    REX2BIT_M0 = 0x80\n+    REX2BIT_M0 = 0x80,\n+    REX2BIT_WB = 0x09,\n+    REX2BIT_WB4 = 0x18,\n@@ -1020,0 +1022,9 @@\n+\n+  \/\/ APX ISA extensions for register save\/restore optimizations.\n+  void push2(Register src1, Register src2, bool with_ppx = false);\n+  void pop2(Register src1, Register src2, bool with_ppx = false);\n+  void push2p(Register src1, Register src2);\n+  void pop2p(Register src1, Register src2);\n+  void pushp(Register src);\n+  void popp(Register src);\n+\n@@ -3073,1 +3084,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  pd_nof_cpu_regs_frame_map = Register::number_of_registers,       \/\/ number of registers used during code emission\n+  pd_nof_cpu_regs_frame_map = NOT_LP64(8) LP64_ONLY(16),           \/\/ number of registers used during code emission\n","filename":"src\/hotspot\/cpu\/x86\/c1_Defs_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2995,1 +2995,1 @@\n-    offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;\n+    offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size_rex;\n@@ -3032,1 +3032,1 @@\n-  __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);\n+  __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size_rex + NativeCall::displacement_offset);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -423,1 +423,6 @@\n-  __ pusha();         \/\/ integer registers\n+  \/\/ Push CPU state in multiple of 16 bytes\n+#ifdef _LP64\n+  __ save_legacy_gprs();\n+#else\n+  __ pusha();\n+#endif\n@@ -563,0 +568,3 @@\n+#ifdef _LP64\n+  __ restore_legacy_gprs();\n+#else\n@@ -564,0 +572,2 @@\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -601,0 +601,19 @@\n+  if (UseAPX) {\n+    caller_saved.Insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -487,0 +487,19 @@\n+    if (UseAPX) {\n+      caller_saved.Insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n+      caller_saved.Insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/x\/xBarrierSetAssembler_x86.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-                                                                            \\\n@@ -198,1 +197,0 @@\n-                                                                            \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2222,2 +2222,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n@@ -2267,2 +2266,1 @@\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,3 @@\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n+#endif\n@@ -49,1 +52,1 @@\n-    jint offset = pc_offset + NativeMovConstReg::instruction_size;\n+    jint offset = pc_offset + ((NativeMovConstReg*)inst)->instruction_size();\n@@ -55,0 +58,5 @@\n+    if (call[0] == Assembler::REX2) {\n+      offset += 2; \/* prefix byte for APX extended GPR register R16-R31 *\/\n+      call+=2;\n+    }\n+    \/\/ Register indirect call.\n@@ -200,1 +208,1 @@\n-void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+bool CodeInstaller::pd_relocate(address pc, jint mark) {\n@@ -209,1 +217,1 @@\n-      break;\n+      return true;\n@@ -214,1 +222,24 @@\n-      break;\n+      return true;\n+#if INCLUDE_ZGC\n+    case Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_SHL:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatLoadGoodBeforeShl);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_LOAD_BAD_AFTER_TEST:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatLoadBadAfterTest);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_AFTER_TEST:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatMarkBadAfterTest);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_CMP:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodAfterCmp);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_AFTER_TEST:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreBadAfterTest);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_OR:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodAfterOr);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodAfterMov);\n+      return true;\n+#endif\n@@ -216,2 +247,1 @@\n-      JVMCI_ERROR(\"invalid mark value: %d\", mark);\n-      break;\n+      return false;\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -4340,0 +4340,5 @@\n+#endif\n+#ifdef _LP64\n+  if (UseAPX) {\n+    regs += RegSet::range(r16, as_Register(Register::number_of_registers - 1));\n+  }\n@@ -5444,1 +5449,1 @@\n-  ExternalAddress buffer((address) b);\n+  AddressLiteral buffer((address) b, external_word_Relocation::spec_for_immediate());\n@@ -5518,1 +5523,1 @@\n-  ExternalAddress buffer((address) b);\n+  AddressLiteral buffer((address) b, external_word_Relocation::spec_for_immediate());\n@@ -11147,0 +11152,42 @@\n+\n+#ifdef _LP64\n+\/\/ Saves legacy GPRs state on stack.\n+void MacroAssembler::save_legacy_gprs() {\n+  subq(rsp, 16 * wordSize);\n+  movq(Address(rsp, 15 * wordSize), rax);\n+  movq(Address(rsp, 14 * wordSize), rcx);\n+  movq(Address(rsp, 13 * wordSize), rdx);\n+  movq(Address(rsp, 12 * wordSize), rbx);\n+  movq(Address(rsp, 10 * wordSize), rbp);\n+  movq(Address(rsp, 9 * wordSize), rsi);\n+  movq(Address(rsp, 8 * wordSize), rdi);\n+  movq(Address(rsp, 7 * wordSize), r8);\n+  movq(Address(rsp, 6 * wordSize), r9);\n+  movq(Address(rsp, 5 * wordSize), r10);\n+  movq(Address(rsp, 4 * wordSize), r11);\n+  movq(Address(rsp, 3 * wordSize), r12);\n+  movq(Address(rsp, 2 * wordSize), r13);\n+  movq(Address(rsp, wordSize), r14);\n+  movq(Address(rsp, 0), r15);\n+}\n+\n+\/\/ Resotres back legacy GPRs state from stack.\n+void MacroAssembler::restore_legacy_gprs() {\n+  movq(r15, Address(rsp, 0));\n+  movq(r14, Address(rsp, wordSize));\n+  movq(r13, Address(rsp, 2 * wordSize));\n+  movq(r12, Address(rsp, 3 * wordSize));\n+  movq(r11, Address(rsp, 4 * wordSize));\n+  movq(r10, Address(rsp, 5 * wordSize));\n+  movq(r9,  Address(rsp, 6 * wordSize));\n+  movq(r8,  Address(rsp, 7 * wordSize));\n+  movq(rdi, Address(rsp, 8 * wordSize));\n+  movq(rsi, Address(rsp, 9 * wordSize));\n+  movq(rbp, Address(rsp, 10 * wordSize));\n+  movq(rbx, Address(rsp, 12 * wordSize));\n+  movq(rdx, Address(rsp, 13 * wordSize));\n+  movq(rcx, Address(rsp, 14 * wordSize));\n+  movq(rax, Address(rsp, 15 * wordSize));\n+  addq(rsp, 16 * wordSize);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2226,0 +2226,5 @@\n+\n+#ifdef _LP64\n+  void save_legacy_gprs();\n+  void restore_legacy_gprs();\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -543,1 +543,2 @@\n-      assert(Register::number_of_registers == 16, \"sanity\");\n+      int num_regs = UseAPX ? 32 : 16;\n+      assert(Register::available_gp_registers() == num_regs, \"sanity\");\n@@ -546,1 +547,1 @@\n-        ls.print(\"%3s=\" PTR_FORMAT, r->name(), (intptr_t)(&saved_regs[16]));\n+        ls.print(\"%3s=\" PTR_FORMAT, r->name(), (intptr_t)(&saved_regs[num_regs]));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -163,2 +163,7 @@\n-  if ((ubyte_at(0) != Assembler::REX_W && ubyte_at(0) != Assembler::REX_WB) ||\n-      (ubyte_at(1) & (0xff ^ register_mask)) != 0xB8) {\n+  bool valid_rex_prefix  = ubyte_at(0) == Assembler::REX_W || ubyte_at(0) == Assembler::REX_WB;\n+  bool valid_rex2_prefix = ubyte_at(0) == Assembler::REX2  &&\n+       (ubyte_at(1) == Assembler::REX2BIT_W  ||\n+        ubyte_at(1) == Assembler::REX2BIT_WB ||\n+        ubyte_at(1) == Assembler::REX2BIT_WB4);\n+  int opcode = has_rex2_prefix() ? ubyte_at(2) : ubyte_at(1);\n+  if ((!valid_rex_prefix || !valid_rex2_prefix) && (opcode & (0xff ^ register_mask)) != 0xB8) {\n@@ -211,0 +216,5 @@\n+  if (instr_0 == instruction_REX2_prefix) {\n+    off+=2;\n+    instr_0 = ubyte_at(off);\n+  }\n+\n@@ -229,0 +239,5 @@\n+  if (instr_0 == instruction_REX2_prefix) {\n+    off+=2;\n+    instr_0 = ubyte_at(off);\n+  }\n+\n@@ -235,1 +250,2 @@\n-\n+  \/\/ Extended prefixes can only follow REX prefixes,\n+  \/\/ REX2 is directly followed by main opcode.\n@@ -240,0 +256,1 @@\n+  \/\/ Offset of instruction opcode.\n@@ -243,0 +260,1 @@\n+\/\/ Format [REX\/REX2] [OPCODE] [ModRM] [SIB] [IMM\/DISP32]\n@@ -249,0 +267,1 @@\n+  \/\/ ModRM Byte Format = Mod[2] REG[3] RM[3]\n@@ -252,0 +271,1 @@\n+  \/\/ Displacement offset.\n@@ -297,6 +317,0 @@\n-#ifdef _LP64\n-  if ( (test_byte == instruction_prefix_wide ||\n-        test_byte == instruction_prefix_wide_extended) ) {\n-    test_byte = *(u_char*)(instruction_address() + 1);\n-  }\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  bool has_rex2_prefix() const { return ubyte_at(0) == Assembler::REX2; }\n@@ -181,0 +182,5 @@\n+\/\/ Call with target address in a general purpose register(indirect absolute addressing).\n+\/\/ Encoding : FF \/2  CALL r\/m32\n+\/\/ Primary Opcode: FF\n+\/\/ Opcode Extension(part of ModRM.REG): \/2\n+\/\/ Operand ModRM.RM  = r\/m32\n@@ -187,1 +193,2 @@\n-    return_address_offset_rex   =    3\n+    return_address_offset_rex   =    3,\n+    return_address_offset_rex2  =    4\n@@ -193,0 +200,2 @@\n+    } else if (has_rex2_prefix()) {\n+      return return_address_offset_rex2;\n@@ -194,0 +203,1 @@\n+      assert((ubyte_at(0) & 0xF0) ==  Assembler::REX, \"\");\n@@ -201,0 +211,2 @@\n+\/\/ Instruction format for implied addressing mode immediate operand move to register instruction:\n+\/\/  [REX\/REX2] [OPCODE] [IMM32]\n@@ -205,0 +217,1 @@\n+  static const int rex2_size = 2;\n@@ -208,0 +221,1 @@\n+  static const int rex2_size = 0;\n@@ -211,6 +225,9 @@\n-    instruction_code            = 0xB8,\n-    instruction_size            =    1 + rex_size + wordSize,\n-    instruction_offset          =    0,\n-    data_offset                 =    1 + rex_size,\n-    next_instruction_offset     =    instruction_size,\n-    register_mask               = 0x07\n+    instruction_code             = 0xB8,\n+    instruction_offset           =    0,\n+    instruction_size_rex         =    1 + rex_size + wordSize,\n+    instruction_size_rex2        =    1 + rex2_size + wordSize,\n+    data_offset_rex              =    1 + rex_size,\n+    data_offset_rex2             =    1 + rex2_size,\n+    next_instruction_offset_rex  =    instruction_size_rex,\n+    next_instruction_offset_rex2 =    instruction_size_rex2,\n+    register_mask                = 0x07\n@@ -219,0 +236,3 @@\n+  int instruction_size() const              { return has_rex2_prefix() ? instruction_size_rex2 : instruction_size_rex; }\n+  int next_inst_offset() const              { return has_rex2_prefix() ? next_instruction_offset_rex2 : next_instruction_offset_rex; }\n+  int data_byte_offset() const              { return has_rex2_prefix() ? data_offset_rex2 : data_offset_rex;}\n@@ -220,3 +240,3 @@\n-  address next_instruction_address() const  { return addr_at(next_instruction_offset); }\n-  intptr_t data() const                     { return ptr_at(data_offset); }\n-  void  set_data(intptr_t x)                { set_ptr_at(data_offset, x); }\n+  address next_instruction_address() const  { return addr_at(next_inst_offset()); }\n+  intptr_t data() const                     { return ptr_at(data_byte_offset()); }\n+  void  set_data(intptr_t x)                { set_ptr_at(data_byte_offset(), x); }\n@@ -241,1 +261,4 @@\n-  NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_size - NativeMovConstReg::instruction_offset);\n+  int instruction_size = ((NativeInstruction*)(address))->has_rex2_prefix() ?\n+                                  NativeMovConstReg::instruction_size_rex2 :\n+                                  NativeMovConstReg::instruction_size_rex;\n+  NativeMovConstReg* test = (NativeMovConstReg*)(address - instruction_size - NativeMovConstReg::instruction_offset);\n@@ -282,0 +305,2 @@\n+\n+    \/\/ Legacy encoding MAP1 instructions promotable to REX2 encoding.\n@@ -288,0 +313,2 @@\n+\n+    \/\/ Legacy encoding MAP0 instructions promotable to REX2 encoding.\n@@ -292,0 +319,2 @@\n+    instruction_code_lea                = 0x8d,\n+\n@@ -295,0 +324,2 @@\n+\n+    \/\/ VEX\/EVEX\/Legacy encodeded MAP1 instructions promotable to REX2 encoding.\n@@ -297,0 +328,1 @@\n+\n@@ -298,0 +330,3 @@\n+\n+    \/\/ Address operand load\/store\/ldp are promotable to REX2 to accomodate\n+    \/\/ extended SIB encoding.\n@@ -302,2 +337,0 @@\n-    instruction_code_lea                = 0x8d,\n-\n@@ -307,0 +340,1 @@\n+    instruction_REX2_prefix             = Assembler::REX2,\n@@ -310,1 +344,2 @@\n-    next_instruction_offset             = 4\n+    next_instruction_offset_rex         = 4,\n+    next_instruction_offset_rex2        = 5\n@@ -441,1 +476,2 @@\n-\/\/ Handles all kinds of jump on Intel. Long\/far, conditional\/unconditional\n+\/\/ Handles all kinds of jump on Intel. Long\/far, conditional\/unconditional with relative offsets\n+\/\/ barring register indirect jumps.\n@@ -541,1 +577,1 @@\n-  const int test_offset = has_rex_prefix ? 1 : 0;\n+  const int test_offset = has_rex2_prefix() ? 2 : (has_rex_prefix ? 1 : 0);\n@@ -552,2 +588,8 @@\n-  return ((ubyte_at(0) == Assembler::REX_W || ubyte_at(0) == Assembler::REX_WB) &&\n-          (ubyte_at(1) & (0xff ^ NativeMovConstReg::register_mask)) == 0xB8);\n+  bool valid_rex_prefix  = ubyte_at(0) == Assembler::REX_W || ubyte_at(0) == Assembler::REX_WB;\n+  bool valid_rex2_prefix = ubyte_at(0) == Assembler::REX2  &&\n+       (ubyte_at(1) == Assembler::REX2BIT_W  ||\n+        ubyte_at(1) == Assembler::REX2BIT_WB ||\n+        ubyte_at(1) == Assembler::REX2BIT_WB4);\n+\n+  int opcode = has_rex2_prefix() ? ubyte_at(2) : ubyte_at(1);\n+  return ((valid_rex_prefix || valid_rex2_prefix) &&  (opcode & (0xff ^ NativeMovConstReg::register_mask)) == 0xB8);\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":60,"deletions":18,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -38,1 +38,3 @@\n-    \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n+    \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n+    \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n+    \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\"\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-    number_of_registers      = LP64_ONLY( 16 ) NOT_LP64( 8 ),\n-    number_of_byte_registers = LP64_ONLY( 16 ) NOT_LP64( 4 ),\n+    number_of_registers      = LP64_ONLY( 32 ) NOT_LP64( 8 ),\n+    number_of_byte_registers = LP64_ONLY( 32 ) NOT_LP64( 4 ),\n@@ -79,0 +79,10 @@\n+\n+  \/\/ Actually available GP registers for use, depending on actual CPU capabilities and flags.\n+  static int available_gp_registers() {\n+#ifdef _LP64\n+    if (!UseAPX) {\n+      return number_of_registers \/ 2;\n+    }\n+#endif \/\/ _LP64\n+    return number_of_registers;\n+  }\n@@ -118,0 +128,16 @@\n+constexpr Register r16 = as_Register(16);\n+constexpr Register r17 = as_Register(17);\n+constexpr Register r18 = as_Register(18);\n+constexpr Register r19 = as_Register(19);\n+constexpr Register r20 = as_Register(20);\n+constexpr Register r21 = as_Register(21);\n+constexpr Register r22 = as_Register(22);\n+constexpr Register r23 = as_Register(23);\n+constexpr Register r24 = as_Register(24);\n+constexpr Register r25 = as_Register(25);\n+constexpr Register r26 = as_Register(26);\n+constexpr Register r27 = as_Register(27);\n+constexpr Register r28 = as_Register(28);\n+constexpr Register r29 = as_Register(29);\n+constexpr Register r30 = as_Register(30);\n+constexpr Register r31 = as_Register(31);\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1630,2 +1630,1 @@\n-  {\n-    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0, noreg);\n+  if (DTraceMethodProbes) {\n@@ -1875,2 +1874,1 @@\n-  {\n-    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0, noreg);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+#define XSAVE_AREA_EGPRS 960\n@@ -108,2 +109,2 @@\n-    fpu_state_off = frame::arg_reg_save_area_bytes\/BytesPerInt, \/\/ fxsave save area\n-    xmm_off       = fpu_state_off + XSAVE_AREA_BEGIN\/BytesPerInt,            \/\/ offset in fxsave save area\n+    fpu_state_off = frame::arg_reg_save_area_bytes\/BytesPerInt,    \/\/ fxsave save area\n+    xmm_off       = fpu_state_off + XSAVE_AREA_BEGIN\/BytesPerInt,  \/\/ offset in fxsave save area\n@@ -117,1 +118,18 @@\n-    opmask_off         = xmm_off + (XSAVE_AREA_OPMASK_BEGIN - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    r31_off = xmm_off + (XSAVE_AREA_EGPRS - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    r31H_off,\n+    r30_off, r30H_off,\n+    r29_off, r29H_off,\n+    r28_off, r28H_off,\n+    r27_off, r27H_off,\n+    r26_off, r26H_off,\n+    r25_off, r25H_off,\n+    r24_off, r24H_off,\n+    r23_off, r23H_off,\n+    r22_off, r22H_off,\n+    r21_off, r21H_off,\n+    r20_off, r20H_off,\n+    r19_off, r19H_off,\n+    r18_off, r18H_off,\n+    r17_off, r17H_off,\n+    r16_off, r16H_off,\n+    opmask_off   = xmm_off + (XSAVE_AREA_OPMASK_BEGIN - XSAVE_AREA_BEGIN)\/BytesPerInt,\n@@ -203,1 +221,7 @@\n-  __ push_CPU_state(); \/\/ Push a multiple of 16 bytes\n+  __ pushf();\n+  \/\/ Make sure rsp stays 16-byte aligned\n+  __ subq(rsp, 8);\n+  \/\/ Push CPU state in multiple of 16 bytes\n+  __ save_legacy_gprs();\n+  __ push_FPU_state();\n+\n@@ -251,0 +275,11 @@\n+\n+#if COMPILER2_OR_JVMCI\n+  if (UseAPX) {\n+      int base_addr = XSAVE_AREA_EGPRS;\n+      off = 0;\n+      for(int n = 16; n < Register::number_of_registers; n++) {\n+        __ movq(Address(rsp, base_addr+(off++*8)), as_Register(n));\n+      }\n+  }\n+#endif\n+\n@@ -283,0 +318,19 @@\n+\n+  if (UseAPX) {\n+    map->set_callee_saved(STACK_OFFSET( r16_off ), r16->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r17_off ), r17->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r18_off ), r18->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r19_off ), r19->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r20_off ), r20->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r21_off ), r21->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r22_off ), r22->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r23_off ), r23->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r24_off ), r24->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r25_off ), r25->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r26_off ), r26->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r27_off ), r27->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r28_off ), r28->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r29_off ), r29->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r30_off ), r30->as_VMReg());\n+    map->set_callee_saved(STACK_OFFSET( r31_off ), r31->as_VMReg());\n+  }\n@@ -343,0 +397,18 @@\n+    if (UseAPX) {\n+      map->set_callee_saved(STACK_OFFSET( r16H_off ), r16->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r17H_off ), r17->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r18H_off ), r18->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r19H_off ), r19->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r20H_off ), r20->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r21H_off ), r21->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r22H_off ), r22->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r23H_off ), r23->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r24H_off ), r24->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r25H_off ), r25->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r26H_off ), r26->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r27H_off ), r27->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r28H_off ), r28->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r29H_off ), r29->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r30H_off ), r30->as_VMReg()->next());\n+      map->set_callee_saved(STACK_OFFSET( r31H_off ), r31->as_VMReg()->next());\n+    }\n@@ -432,0 +504,10 @@\n+#if COMPILER2_OR_JVMCI\n+  if (UseAPX) {\n+    int base_addr = XSAVE_AREA_EGPRS;\n+    int off = 0;\n+    for (int n = 16; n < Register::number_of_registers; n++) {\n+      __ movq(as_Register(n), Address(rsp, base_addr+(off++*8)));\n+    }\n+  }\n+#endif\n+\n@@ -433,1 +515,4 @@\n-  __ pop_CPU_state();\n+  __ pop_FPU_state();\n+  __ restore_legacy_gprs();\n+  __ addq(rsp, 8);\n+  __ popf();\n@@ -2388,2 +2473,1 @@\n-  {\n-    SkipIfEqual skip(masm, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n@@ -2631,2 +2715,1 @@\n-  {\n-    SkipIfEqual skip(masm, &DTraceMethodProbes, false, rscratch1);\n+  if (DTraceMethodProbes) {\n@@ -2820,0 +2903,3 @@\n+  if (UseAPX) {\n+    pad += 1024;\n+  }\n@@ -3368,1 +3454,1 @@\n-  CodeBuffer buffer(\"handler_blob\", 2048, 1024);\n+  CodeBuffer buffer(\"handler_blob\", 2348, 1024);\n@@ -3524,1 +3610,1 @@\n-  CodeBuffer buffer(name, 1200, 512);\n+  CodeBuffer buffer(name, 1552, 512);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":97,"deletions":11,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  __ mov64(rax, 0x1); \/\/ Return 1 (Fig. 5, Step 6 [1] skipped in montgomeryMultiply)\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4380,0 +4380,7 @@\n+    if (DTraceAllocProbes) {\n+      \/\/ Trigger dtrace event for fastpath\n+      __ push(atos);\n+      __ call_VM_leaf(\n+           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), rax);\n+      __ pop(atos);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,1 +43,5 @@\n-  return reg->is_valid() && (UseAVX >= 3 || (reg->encoding() < 16)); \/\/ why is this not covered by is_valid()?\n+  return reg->is_valid() && (reg->encoding() < (UseAVX >= 3 ? 32 : 16)); \/\/ why is this not covered by is_valid()?\n+}\n+\n+static bool is_valid_gp(Register reg) {\n+  return reg->is_valid() && (reg->encoding() < (UseAPX ? 32 : 16));\n@@ -49,1 +53,1 @@\n-  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+  for (Register reg = as_Register(0); is_valid_gp(reg); reg = reg->successor()) {\n@@ -87,1 +91,1 @@\n-  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+  for (Register reg = as_Register(0); is_valid_gp(reg); reg = reg->successor()) {\n@@ -137,1 +141,1 @@\n-  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+  for (Register reg = as_Register(0); is_valid_gp(reg); reg = reg->successor()) {\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+#if defined(_LP64)\n@@ -118,1 +119,0 @@\n-    \/* FIXME Uncomment following code after OS enablement of\n@@ -127,1 +127,0 @@\n-    *\/\n@@ -131,0 +130,1 @@\n+#endif\n@@ -422,1 +422,1 @@\n-#ifndef PRODUCT\n+#if defined(_LP64)\n@@ -440,1 +440,0 @@\n-    \/* FIXME: Uncomment while integrating JDK-8329032\n@@ -446,1 +445,0 @@\n-    *\/\n@@ -453,1 +451,0 @@\n-    \/* FIXME: Uncomment after integration of JDK-8329032\n@@ -459,1 +456,0 @@\n-    *\/\n@@ -2173,0 +2169,1 @@\n+#if defined(_LP64)\n@@ -2176,0 +2173,1 @@\n+#endif\n@@ -2194,0 +2192,1 @@\n+#if defined(_LP64)\n@@ -2196,0 +2195,1 @@\n+#endif\n@@ -3186,0 +3186,3 @@\n+  \/\/ Enable APX support for product builds after\n+  \/\/ completion of planned features listed in JDK-8329030.\n+#if !defined(PRODUCT)\n@@ -3191,0 +3194,3 @@\n+#else\n+  return false;\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-  static void clear_apx_test_state();\n+  LP64_ONLY(static void clear_apx_test_state());\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n-  return (unsigned int) value() < (unsigned int) ConcreteRegisterImpl::max_gpr;\n+  int uarch_max_gpr = Register::max_slots_per_register * Register::available_gp_registers();\n+  return (unsigned int) value() < (unsigned int) uarch_max_gpr;\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,0 +131,47 @@\n+reg_def R16  (SOC, SOC, Op_RegI, 16, r16->as_VMReg());\n+reg_def R16_H(SOC, SOC, Op_RegI, 16, r16->as_VMReg()->next());\n+\n+reg_def R17  (SOC, SOC, Op_RegI, 17, r17->as_VMReg());\n+reg_def R17_H(SOC, SOC, Op_RegI, 17, r17->as_VMReg()->next());\n+\n+reg_def R18  (SOC, SOC, Op_RegI, 18, r18->as_VMReg());\n+reg_def R18_H(SOC, SOC, Op_RegI, 18, r18->as_VMReg()->next());\n+\n+reg_def R19  (SOC, SOC, Op_RegI, 19, r19->as_VMReg());\n+reg_def R19_H(SOC, SOC, Op_RegI, 19, r19->as_VMReg()->next());\n+\n+reg_def R20  (SOC, SOC, Op_RegI, 20, r20->as_VMReg());\n+reg_def R20_H(SOC, SOC, Op_RegI, 20, r20->as_VMReg()->next());\n+\n+reg_def R21  (SOC, SOC, Op_RegI, 21, r21->as_VMReg());\n+reg_def R21_H(SOC, SOC, Op_RegI, 21, r21->as_VMReg()->next());\n+\n+reg_def R22  (SOC, SOC, Op_RegI, 22, r22->as_VMReg());\n+reg_def R22_H(SOC, SOC, Op_RegI, 22, r22->as_VMReg()->next());\n+\n+reg_def R23  (SOC, SOC, Op_RegI, 23, r23->as_VMReg());\n+reg_def R23_H(SOC, SOC, Op_RegI, 23, r23->as_VMReg()->next());\n+\n+reg_def R24  (SOC, SOC, Op_RegI, 24, r24->as_VMReg());\n+reg_def R24_H(SOC, SOC, Op_RegI, 24, r24->as_VMReg()->next());\n+\n+reg_def R25  (SOC, SOC, Op_RegI, 25, r25->as_VMReg());\n+reg_def R25_H(SOC, SOC, Op_RegI, 25, r25->as_VMReg()->next());\n+\n+reg_def R26  (SOC, SOC, Op_RegI, 26, r26->as_VMReg());\n+reg_def R26_H(SOC, SOC, Op_RegI, 26, r26->as_VMReg()->next());\n+\n+reg_def R27  (SOC, SOC, Op_RegI, 27, r27->as_VMReg());\n+reg_def R27_H(SOC, SOC, Op_RegI, 27, r27->as_VMReg()->next());\n+\n+reg_def R28  (SOC, SOC, Op_RegI, 28, r28->as_VMReg());\n+reg_def R28_H(SOC, SOC, Op_RegI, 28, r28->as_VMReg()->next());\n+\n+reg_def R29  (SOC, SOC, Op_RegI, 29, r29->as_VMReg());\n+reg_def R29_H(SOC, SOC, Op_RegI, 29, r29->as_VMReg()->next());\n+\n+reg_def R30  (SOC, SOC, Op_RegI, 30, r30->as_VMReg());\n+reg_def R30_H(SOC, SOC, Op_RegI, 30, r30->as_VMReg()->next());\n+\n+reg_def R31  (SOC, SOC, Op_RegI, 31, r31->as_VMReg());\n+reg_def R31_H(SOC, SOC, Op_RegI, 31, r31->as_VMReg()->next());\n@@ -157,0 +204,16 @@\n+                   R16,         R16_H,\n+                   R17,         R17_H,\n+                   R18,         R18_H,\n+                   R19,         R19_H,\n+                   R20,         R20_H,\n+                   R21,         R21_H,\n+                   R22,         R22_H,\n+                   R23,         R23_H,\n+                   R24,         R24_H,\n+                   R25,         R25_H,\n+                   R26,         R26_H,\n+                   R27,         R27_H,\n+                   R28,         R28_H,\n+                   R29,         R29_H,\n+                   R30,         R30_H,\n+                   R31,         R31_H,\n@@ -170,1 +233,1 @@\n-\/\/ Class for all pointer\/long registers\n+\/\/ Class for all pointer\/long registers including APX extended GPRs.\n@@ -186,3 +249,19 @@\n-                  R15, R15_H);\n-\n-\/\/ Class for all int registers\n+                  R15, R15_H,\n+                  R16, R16_H,\n+                  R17, R17_H,\n+                  R18, R18_H,\n+                  R19, R19_H,\n+                  R20, R20_H,\n+                  R21, R21_H,\n+                  R22, R22_H,\n+                  R23, R23_H,\n+                  R24, R24_H,\n+                  R25, R25_H,\n+                  R26, R26_H,\n+                  R27, R27_H,\n+                  R28, R28_H,\n+                  R29, R29_H,\n+                  R30, R30_H,\n+                  R31, R31_H);\n+\n+\/\/ Class for all int registers including APX extended GPRs.\n@@ -202,1 +281,17 @@\n-                      R14);\n+                      R14,\n+                      R16,\n+                      R17,\n+                      R18,\n+                      R19,\n+                      R20,\n+                      R21,\n+                      R22,\n+                      R23,\n+                      R24,\n+                      R25,\n+                      R26,\n+                      R27,\n+                      R28,\n+                      R29,\n+                      R30,\n+                      R31);\n@@ -389,0 +484,2 @@\n+  constexpr Register egprs[] = {r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31};\n+\n@@ -407,0 +504,6 @@\n+  if (!UseAPX) {\n+    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n+      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n+    }\n+  }\n@@ -423,0 +526,1 @@\n+\n@@ -444,0 +548,6 @@\n+  if (!UseAPX) {\n+    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n+      _INT_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+    }\n+  }\n+\n@@ -12574,1 +12684,0 @@\n-  size(4); \/* setting an explicit size will cause debug builds to assert if size is incorrect *\/\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":115,"deletions":6,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,0 @@\n-#ifndef DONT_USE_REGISTER_DEFINES\n@@ -119,1 +118,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/zero\/register_zero.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -99,0 +100,6 @@\n+\/\/ sys\/mman.h defines MAP_ANON_64K beginning with AIX7.3 TL1\n+#ifndef MAP_ANON_64K\n+  #define MAP_ANON_64K 0x400\n+#else\n+  STATIC_ASSERT(MAP_ANON_64K == 0x400);\n+#endif\n@@ -220,8 +227,9 @@\n-  size_t pagesize;            \/\/ sysconf _SC_PAGESIZE (4K)\n-  size_t datapsize;           \/\/ default data page size (LDR_CNTRL DATAPSIZE)\n-  size_t shmpsize;            \/\/ default shared memory page size (LDR_CNTRL SHMPSIZE)\n-  size_t pthr_stack_pagesize; \/\/ stack page size of pthread threads\n-  size_t textpsize;           \/\/ default text page size (LDR_CNTRL STACKPSIZE)\n-  bool can_use_64K_pages;     \/\/ True if we can alloc 64K pages dynamically with Sys V shm.\n-  bool can_use_16M_pages;     \/\/ True if we can alloc 16M pages dynamically with Sys V shm.\n-  int error;                  \/\/ Error describing if something went wrong at multipage init.\n+  size_t pagesize;             \/\/ sysconf _SC_PAGESIZE (4K)\n+  size_t datapsize;            \/\/ default data page size (LDR_CNTRL DATAPSIZE)\n+  size_t shmpsize;             \/\/ default shared memory page size (LDR_CNTRL SHMPSIZE)\n+  size_t pthr_stack_pagesize;  \/\/ stack page size of pthread threads\n+  size_t textpsize;            \/\/ default text page size (LDR_CNTRL STACKPSIZE)\n+  bool can_use_64K_pages;      \/\/ True if we can alloc 64K pages dynamically with Sys V shm.\n+  bool can_use_16M_pages;      \/\/ True if we can alloc 16M pages dynamically with Sys V shm.\n+  bool can_use_64K_mmap_pages; \/\/ True if we can alloc 64K pages dynamically with mmap.\n+  int error;                   \/\/ Error describing if something went wrong at multipage init.\n@@ -234,1 +242,1 @@\n-  false, false,\n+  false, false, false,\n@@ -369,6 +377,10 @@\n-    guarantee(shmid != -1, \"shmget failed\");\n-    void* p = ::shmat(shmid, nullptr, 0);\n-    ::shmctl(shmid, IPC_RMID, nullptr);\n-    guarantee(p != (void*) -1, \"shmat failed\");\n-    g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n-    ::shmdt(p);\n+    assert(shmid != -1, \"shmget failed\");\n+    if (shmid != -1) {\n+      void* p = ::shmat(shmid, nullptr, 0);\n+      ::shmctl(shmid, IPC_RMID, nullptr);\n+      assert(p != (void*) -1, \"shmat failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.shmpsize = os::Aix::query_pagesize(p);\n+        ::shmdt(p);\n+      }\n+    }\n@@ -424,16 +436,9 @@\n-      guarantee0(shmid != -1); \/\/ Should always work.\n-      \/\/ Try to set pagesize.\n-      struct shmid_ds shm_buf = { };\n-      shm_buf.shm_pagesize = pagesize;\n-      if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n-        const int en = errno;\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n-      } else {\n-        \/\/ Attach and double check pageisze.\n-        void* p = ::shmat(shmid, nullptr, 0);\n-        ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n-        guarantee0(p != (void*) -1); \/\/ Should always work.\n-        const size_t real_pagesize = os::Aix::query_pagesize(p);\n-        if (real_pagesize != pagesize) {\n-          log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+      assert(shmid != -1, \"shmget failed\");\n+      if (shmid != -1) {\n+        \/\/ Try to set pagesize.\n+        struct shmid_ds shm_buf = { };\n+        shm_buf.shm_pagesize = pagesize;\n+        if (::shmctl(shmid, SHM_PAGESIZE, &shm_buf) != 0) {\n+          const int en = errno;\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n@@ -441,1 +446,13 @@\n-          can_use = true;\n+          \/\/ Attach and double check pageisze.\n+          void* p = ::shmat(shmid, nullptr, 0);\n+          ::shmctl(shmid, IPC_RMID, nullptr); \/\/ As early as possible!\n+          assert(p != (void*) -1, \"shmat failed\");\n+          if (p != (void*) -1) {\n+            const size_t real_pagesize = os::Aix::query_pagesize(p);\n+            if (real_pagesize != pagesize) {\n+              log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+            } else {\n+              can_use = true;\n+            }\n+            ::shmdt(p);\n+          }\n@@ -443,1 +460,0 @@\n-        ::shmdt(p);\n@@ -453,0 +469,10 @@\n+    \/\/ Can we use mmap with 64K pages? (Should be available with AIX7.3 TL1)\n+    {\n+      void* p = mmap(NULL, 64*K, PROT_READ | PROT_WRITE, MAP_ANON_64K | MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n+      assert(p != (void*) -1, \"mmap failed\");\n+      if (p != (void*) -1) {\n+        g_multipage_support.can_use_64K_mmap_pages = (64*K == os::Aix::query_pagesize(p));\n+        munmap(p, 64*K);\n+      }\n+    }\n+\n@@ -465,0 +491,2 @@\n+  trcVerbose(\"Can use 64K pages with mmap memory: %s\",\n+      (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1136,0 +1164,2 @@\n+  st->print_cr(\"  Can use 64K pages with mmap memory:     %s\",\n+    (g_multipage_support.can_use_64K_mmap_pages ? \"yes\" :\"no\"));\n@@ -1615,0 +1645,4 @@\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    flags |= MAP_ANON_64K;\n+  }\n+\n@@ -1664,1 +1698,5 @@\n-  vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  if (os::vm_page_size() == 64*K && g_multipage_support.can_use_64K_mmap_pages) {\n+    vmembk_add(addr, size, 64*K, VMEM_MAPPED);\n+  } else {\n+    vmembk_add(addr, size, 4*K, VMEM_MAPPED);\n+  }\n@@ -1857,2 +1895,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2045,2 +2083,2 @@\n-  \/\/ In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.\n-  if (os::vm_page_size() == 4*K) {\n+  \/\/ In 64K mode allocate with mmap if it supports 64K pages, otherwise use 64K shmatted.\n+  if (os::vm_page_size() == 4*K || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2186,3 +2224,3 @@\n-  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically       what we do                      remarks\n-  \/\/ 4K           no                                  4K                              old systems (aix 5.2) or new systems with AME activated\n-  \/\/ 4k           yes                                 64k (treat 4k stacks as 64k)    different loader than java and standard settings\n+  \/\/ LDR_CNTRL    can_use_64K_pages_dynamically(mmap or shm)       what we do                      remarks\n+  \/\/ 4K           no                                               4K                              old systems (aix 5.2) or new systems with AME activated\n+  \/\/ 4k           yes                                              64k (treat 4k stacks as 64k)    different loader than java and standard settings\n@@ -2190,1 +2228,1 @@\n-  \/\/ 64k          yes                                 64k                             new systems and standard java loader (we set datapsize=64k when linking)\n+  \/\/ 64k          yes                                              64k                             new systems and standard java loader (we set datapsize=64k when linking)\n@@ -2197,1 +2235,1 @@\n-    if (g_multipage_support.can_use_64K_pages) {\n+    if (g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages) {\n@@ -2227,1 +2265,1 @@\n-    assert0(g_multipage_support.can_use_64K_pages);\n+    assert0(g_multipage_support.can_use_64K_pages || g_multipage_support.can_use_64K_mmap_pages);\n@@ -2712,0 +2750,4 @@\n+bool os::Aix::supports_64K_mmap_pages() {\n+  return g_multipage_support.can_use_64K_mmap_pages;\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":86,"deletions":44,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  static bool supports_64K_mmap_pages();\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -64,3 +65,9 @@\n-    \/\/ Note: any index in cg_infos will do as the path is the same for\n-    \/\/       all controllers.\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    \/\/ Note: We use the memory for non-cpu non-memory controller look-ups.\n+    \/\/       Perhaps we ought to have separate controllers for all.\n+    CgroupV2Controller mem_other = CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n+                                                      cg_infos[MEMORY_IDX]._cgroup_path,\n+                                                      cg_infos[MEMORY_IDX]._read_only);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(mem_other);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_infos[CPU_IDX]._mount_path,\n+                                                                              cg_infos[CPU_IDX]._cgroup_path,\n+                                                                              cg_infos[CPU_IDX]._read_only));\n@@ -69,1 +76,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu, mem_other);\n@@ -103,1 +110,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory = new CgroupV1MemoryController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -106,1 +113,1 @@\n-        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -109,1 +116,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1CpuController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -112,1 +119,1 @@\n-        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -115,1 +122,1 @@\n-        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -130,1 +137,2 @@\n-                                                  char* root_path) {\n+                                                  char* root_path,\n+                                                  bool read_only) {\n@@ -142,0 +150,1 @@\n+      cg_infos[controller]._read_only = read_only;\n@@ -149,0 +158,1 @@\n+    cg_infos[controller]._read_only = read_only;\n@@ -152,0 +162,56 @@\n+\/*\n+ * Determine whether or not the mount options, which are comma separated,\n+ * contain the 'ro' string.\n+ *\/\n+static bool find_ro_opt(char* mount_opts) {\n+  char* token;\n+  char* mo_ptr = mount_opts;\n+  \/\/ mount options are comma-separated (man proc).\n+  while ((token = strsep(&mo_ptr, \",\")) != NULL) {\n+    if (strcmp(token, \"ro\") == 0) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/*\n+ * Read values of a \/proc\/self\/mountinfo line into variables. For cgroups v1\n+ * super options are needed. On cgroups v2 super options are not used.\n+ *\n+ * The scanning of a single mountinfo line entry is as follows:\n+ *\n+ * 36  35  98:0      \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+ * (1) (2) (3):(4)   (5)   (6)      (7)      (8)   (9) (10)   (11)         (12)\n+ *\n+ * The numbers in parentheses are labels for the descriptions below:\n+ *\n+ *  (1)   mount ID:        matched with '%*d' and discarded\n+ *  (2)   parent ID:       matched with '%*d' and discarded\n+ *  (3)   major:           ---,---> major, minor separated by ':'. matched with '%*d:%*d' and discarded\n+ *  (4)   minor:           ---'\n+ *  (5)   root:            matched with '%s' and captured in 'tmproot'. Must be non-empty.\n+ *  (6)   mount point:     matched with '%s' and captured in 'tmpmount'. Must be non-empty.\n+ *  (7)   mount options:   matched with '%s' and captured in 'mount_opts'. Must be non-empty.\n+ *  (8)   optional fields: ---,---> matched with '%*[^-]-'. Anything not a hyphen, followed by a hyphen\n+ *  (9)   separator:       ---'     and discarded. Note: The discarded match is space characters if there\n+ *                                  are no optionals. Otherwise it includes the optional fields as well.\n+ * (10)   filesystem type: matched with '%s' and captured in 'tmp_fs_type'\n+ * (11)   mount source:    matched with '%*s' and discarded\n+ * (12)   super options:   matched with '%s' and captured in 'tmpcgroups'\n+ *\/\n+static inline bool match_mount_info_line(char* line,\n+                                         char* tmproot,\n+                                         char* tmpmount,\n+                                         char* mount_opts,\n+                                         char* tmp_fs_type,\n+                                         char* tmpcgroups) {\n+ return sscanf(line,\n+               \"%*d %*d %*d:%*d %s %s %s%*[^-]- %s %*s %s\",\n+               tmproot,\n+               tmpmount,\n+               mount_opts,\n+               tmp_fs_type,\n+               tmpcgroups) == 5;\n+}\n+\n@@ -321,0 +387,1 @@\n+    char mount_opts[MAXPATHLEN+1];\n@@ -324,4 +391,13 @@\n-    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n-    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n-    \/\/ block in the hybrid case.\n-    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %*s\", tmproot, tmpmount, tmp_fs_type) == 3) {\n+    \/* Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+     * as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+     * block in the hybrid case.\n+     *\n+     * We collect the read only mount option in the cgroup infos so as to have that\n+     * info ready when determining is_containerized().\n+     *\/\n+    if (is_cgroupsV2 && match_mount_info_line(p,\n+                                              tmproot,\n+                                              tmpmount,\n+                                              mount_opts,\n+                                              tmp_fs_type,\n+                                              tmpcgroups \/* unused *\/)) {\n@@ -332,0 +408,3 @@\n+        \/\/ For unified we only have a single line with cgroup2 fs type.\n+        \/\/ Therefore use that option for all CG info structs.\n+        bool ro_option = find_ro_opt(mount_opts);\n@@ -333,1 +412,1 @@\n-          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot);\n+          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot, ro_option);\n@@ -340,1 +419,2 @@\n-     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids. For each controller\n+     * determine whether or not they show up as mounted read only or not.\n@@ -349,0 +429,1 @@\n+     *\n@@ -350,1 +431,1 @@\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+    if (match_mount_info_line(p, tmproot, tmpmount, mount_opts, tmp_fs_type, tmpcgroups)) {\n@@ -358,1 +439,2 @@\n-          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot, ro_option);\n@@ -362,1 +444,2 @@\n-          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot, ro_option);\n@@ -366,1 +449,2 @@\n-          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot, ro_option);\n@@ -370,1 +454,2 @@\n-          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot, ro_option);\n@@ -374,1 +459,2 @@\n-          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot, ro_option);\n@@ -478,1 +564,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -484,1 +570,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController>* contrl = cpu_controller();\n@@ -492,17 +578,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -525,1 +596,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController>* contrl = memory_controller();\n@@ -532,22 +603,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -718,0 +768,52 @@\n+\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n+}\n+\n+void CgroupSubsystem::print_version_specific_info(outputStream* st) {\n+  julong phys_mem = os::Linux::physical_memory();\n+  memory_controller()->controller()->print_version_specific_info(st, phys_mem);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":167,"deletions":65,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    virtual bool is_read_only() = 0;\n@@ -182,0 +183,1 @@\n+template <class T>\n@@ -184,1 +186,1 @@\n-    CgroupController* _controller;\n+    T* _controller;\n@@ -188,1 +190,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T* cont) {\n@@ -194,1 +196,1 @@\n-    CgroupController* controller() { return _controller; }\n+    T* controller() { return _controller; }\n@@ -197,1 +199,2 @@\n-class CgroupSubsystem: public CHeapObj<mtInternal> {\n+\/\/ Pure virtual class representing version agnostic CPU controllers\n+class CgroupCpuController: public CHeapObj<mtInternal> {\n@@ -199,3 +202,0 @@\n-    jlong memory_limit_in_bytes();\n-    int active_processor_count();\n-\n@@ -205,2 +205,7 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual bool is_read_only() = 0;\n+};\n+\n+\/\/ Pure virtual class representing version agnostic memory controllers\n+class CgroupMemoryController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n@@ -208,3 +213,3 @@\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n@@ -214,0 +219,12 @@\n+    virtual void print_version_specific_info(outputStream* st, julong host_mem) = 0;\n+    virtual bool is_read_only() = 0;\n+};\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual jlong pids_max() = 0;\n+    virtual jlong pids_current() = 0;\n+    virtual bool is_containerized() = 0;\n@@ -217,1 +234,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -219,4 +235,15 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n-\n-    virtual void print_version_specific_info(outputStream* st) = 0;\n+    virtual CachingCgroupController<CgroupMemoryController>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController>* cpu_controller() = 0;\n+\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_and_swap_usage_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st);\n@@ -236,0 +263,1 @@\n+    bool _read_only;            \/\/ whether or not the mount path is mounted read-only\n@@ -246,0 +274,1 @@\n+      _read_only = false;\n@@ -277,1 +306,2 @@\n-                                     char* root_path);\n+                                     char* root_path,\n+                                     bool read_only);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -79,1 +80,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n@@ -84,1 +85,1 @@\n-  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  reader()->set_subsystem_path(cgroup_path);\n@@ -91,1 +92,23 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+static inline\n+void verbose_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n+      } else {\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n+    }\n+  }\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n@@ -93,2 +116,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n-  if (memlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n+  if (memlimit >= phys_mem) {\n@@ -96,2 +119,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -99,3 +121,1 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   \"hierarchical_memory_limit\",\n-                                                                   &hier_memlimit);\n+      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n@@ -106,3 +126,2 @@\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n+      if (hier_memlimit < phys_mem) {\n+        verbose_log(hier_memlimit, phys_mem);\n@@ -111,0 +130,1 @@\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n@@ -112,0 +132,1 @@\n+    verbose_log(memlimit, phys_mem);\n@@ -113,2 +134,2 @@\n-  }\n-  else {\n+  } else {\n+    verbose_log(memlimit, phys_mem);\n@@ -131,2 +152,1 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n@@ -135,2 +155,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -139,2 +158,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -142,3 +160,3 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   matchline,\n-                                                                   &hier_memswlimit);\n+      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n+                                                           matchline,\n+                                                           &hier_memswlimit);\n@@ -161,2 +179,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -171,1 +189,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -189,3 +207,3 @@\n-jlong CgroupV1Subsystem::memory_and_swap_usage_in_bytes() {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes();\n-  jlong memory_limit = CgroupSubsystem::memory_limit_in_bytes();\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -195,1 +213,1 @@\n-      return memory_swap_usage_impl(_memory->controller());\n+      return memory_swap_usage_impl(reader());\n@@ -201,1 +219,1 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n@@ -203,1 +221,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n@@ -207,1 +225,1 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -209,2 +227,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n+  if (memsoftlimit >= phys_mem) {\n@@ -218,0 +236,11 @@\n+bool CgroupV1Subsystem::is_containerized() {\n+  \/\/ containerized iff all required controllers are mounted\n+  \/\/ read-only. See OSContainer::is_containerized() for\n+  \/\/ the full logic.\n+  \/\/\n+  return _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only() &&\n+         _cpuacct->is_read_only() &&\n+         _cpuset->is_read_only();\n+}\n+\n@@ -227,1 +256,1 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n@@ -229,1 +258,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n@@ -241,1 +270,1 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n@@ -243,1 +272,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n@@ -247,1 +276,1 @@\n-jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n@@ -249,3 +278,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                               \"rss\",\n-                                                               &rss);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n@@ -259,1 +286,1 @@\n-jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n@@ -261,3 +288,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                               \"cache\",\n-                                                               &cache);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n@@ -271,1 +296,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n@@ -273,1 +298,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n@@ -277,1 +302,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n@@ -279,2 +304,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+  if (kmem_limit >= phys_mem) {\n@@ -286,1 +311,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n@@ -288,1 +313,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n@@ -292,1 +317,1 @@\n-void CgroupV1Subsystem::print_version_specific_info(outputStream* st) {\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n@@ -294,1 +319,1 @@\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n+  jlong kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n@@ -324,1 +349,1 @@\n-int CgroupV1Subsystem::cpu_quota() {\n+int CgroupV1CpuController::cpu_quota() {\n@@ -326,2 +351,1 @@\n-  bool is_ok = _cpu->controller()->\n-                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", &quota);\n@@ -339,1 +363,1 @@\n-int CgroupV1Subsystem::cpu_period() {\n+int CgroupV1CpuController::cpu_period() {\n@@ -341,1 +365,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n@@ -355,1 +379,1 @@\n-int CgroupV1Subsystem::cpu_shares() {\n+int CgroupV1CpuController::cpu_shares() {\n@@ -357,1 +381,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", shares);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":88,"deletions":64,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -37,2 +37,3 @@\n-    char *_root;\n-    char *_mount_point;\n+    char* _root;\n+    char* _mount_point;\n+    bool _read_only;\n@@ -41,1 +42,1 @@\n-    char *_path;\n+    char* _path;\n@@ -44,4 +45,16 @@\n-    CgroupV1Controller(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = nullptr;\n+    CgroupV1Controller(char *root,\n+                       char *mountpoint,\n+                       bool ro) : _root(os::strdup(root)),\n+                                  _mount_point(os::strdup(mountpoint)),\n+                                  _read_only(ro),\n+                                  _path(nullptr) {\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV1Controller(const CgroupV1Controller& o) : _root(o._root),\n+                                                      _mount_point(o._mount_point),\n+                                                      _read_only(o._read_only),\n+                                                      _path(o._path) {\n+    }\n+    ~CgroupV1Controller() {\n+      \/\/ At least one subsystem controller exists with paths to malloc'd path\n+      \/\/ names\n@@ -50,2 +63,3 @@\n-    virtual void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() { return _path; }\n+    void set_subsystem_path(char *cgroup_path);\n+    char *subsystem_path() override { return _path; }\n+    bool is_read_only() { return _read_only; }\n@@ -54,1 +68,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController final : public CgroupMemoryController {\n@@ -56,0 +70,3 @@\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n@@ -59,0 +76,15 @@\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -66,0 +98,2 @@\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -68,2 +102,3 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n+    CgroupV1MemoryController(const CgroupV1Controller& reader)\n+      : _reader(reader),\n+        _uses_mem_hierarchy(false) {\n@@ -74,1 +109,15 @@\n-class CgroupV1Subsystem: public CgroupSubsystem {\n+class CgroupV1CpuController final : public CgroupCpuController {\n+\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n+  public:\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    void set_subsystem_path(char *cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -77,8 +126,5 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    CgroupV1CpuController(const CgroupV1Controller& reader) : _reader(reader) {\n+    }\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n@@ -86,0 +132,1 @@\n+  public:\n@@ -93,5 +140,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -100,2 +142,1 @@\n-\n-    void print_version_specific_info(outputStream* st);\n+    bool is_containerized();\n@@ -106,2 +147,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n@@ -111,1 +152,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n@@ -113,1 +154,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -117,3 +158,0 @@\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n@@ -122,1 +160,1 @@\n-                      CgroupV1Controller* cpu,\n+                      CgroupV1CpuController* cpu,\n@@ -125,6 +163,6 @@\n-                      CgroupV1MemoryController* memory) {\n-      _cpuset = cpuset;\n-      _cpu = new CachingCgroupController(cpu);\n-      _cpuacct = cpuacct;\n-      _pids = pids;\n-      _memory = new CachingCgroupController(memory);\n+                      CgroupV1MemoryController* memory) :\n+      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+      _cpuset(cpuset),\n+      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n+      _cpuacct(cpuacct),\n+      _pids(pids) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":80,"deletions":42,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,1 +38,1 @@\n-int CgroupV2Subsystem::cpu_shares() {\n+int CgroupV2CpuController::cpu_shares() {\n@@ -39,1 +40,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n@@ -86,1 +87,1 @@\n-int CgroupV2Subsystem::cpu_quota() {\n+int CgroupV2CpuController::cpu_quota() {\n@@ -88,1 +89,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n@@ -97,0 +98,6 @@\n+bool CgroupV2Subsystem::is_containerized() {\n+  return _unified.is_read_only() &&\n+         _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only();\n+}\n+\n@@ -99,1 +106,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -105,1 +112,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -109,1 +116,1 @@\n-int CgroupV2Subsystem::cpu_period() {\n+int CgroupV2CpuController::cpu_period() {\n@@ -111,1 +118,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n@@ -130,1 +137,1 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n@@ -132,1 +139,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", memusage);\n@@ -136,1 +143,1 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -138,1 +145,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n@@ -142,1 +149,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -148,1 +155,1 @@\n-jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n@@ -150,2 +157,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n@@ -159,1 +165,1 @@\n-jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n@@ -161,2 +167,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n@@ -175,1 +180,2 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem,\n+                                                               julong host_swap \/* unused in cg v2 *\/) {\n@@ -177,1 +183,1 @@\n-  bool is_ok = _memory->controller()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n@@ -182,1 +188,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -186,1 +192,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -194,7 +200,6 @@\n-jlong CgroupV2Subsystem::memory_and_swap_usage_in_bytes() {\n-    jlong memory_usage = memory_usage_in_bytes();\n-    if (memory_usage >= 0) {\n-        jlong swap_current = mem_swp_current_val();\n-        return memory_usage + (swap_current >= 0 ? swap_current : 0);\n-    }\n-    return memory_usage; \/\/ not supported or unlimited case\n+\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n+static\n+jlong memory_swap_current_value(CgroupV2Controller* ctrl) {\n+  julong swap_current;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  return (jlong)swap_current;\n@@ -203,4 +208,7 @@\n-jlong CgroupV2Subsystem::mem_swp_limit_val() {\n-  jlong swap_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n-  return swap_limit;\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_usage = memory_usage_in_bytes();\n+  if (memory_usage >= 0) {\n+      jlong swap_current = memory_swap_current_value(reader());\n+      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+  }\n+  return memory_usage; \/\/ not supported or unlimited case\n@@ -209,5 +217,5 @@\n-\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n-jlong CgroupV2Subsystem::mem_swp_current_val() {\n-  julong swap_current;\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n-  return (jlong)swap_current;\n+static\n+jlong memory_limit_value(CgroupV2Controller* ctrl) {\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n@@ -216,1 +224,1 @@\n-\/* memory_limit_in_bytes\n+\/* read_memory_limit_in_bytes\n@@ -224,4 +232,33 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  jlong memory_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.max\", \"Memory Limit\", memory_limit);\n-  return memory_limit;\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  jlong limit = memory_limit_value(reader());\n+  if (log_is_enabled(Trace, os, container)) {\n+    if (limit == -1) {\n+      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+    } else {\n+      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n+  return limit;\n+}\n+\n+static\n+jlong memory_swap_limit_value(CgroupV2Controller* ctrl) {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -230,3 +267,3 @@\n-void CgroupV2Subsystem::print_version_specific_info(outputStream* st) {\n-  jlong swap_current = mem_swp_current_val();\n-  jlong swap_limit = mem_swp_limit_val();\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n+  jlong swap_current = memory_swap_current_value(reader());\n+  jlong swap_limit = memory_swap_limit_value(reader());\n@@ -258,1 +295,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n@@ -272,1 +309,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":86,"deletions":49,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    bool _read_only;\n@@ -42,4 +43,16 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n-      _mount_path = mount_path;\n-      _cgroup_path = os::strdup(cgroup_path);\n-      _path = construct_path(mount_path, cgroup_path);\n+    CgroupV2Controller(char* mount_path,\n+                       char *cgroup_path,\n+                       bool ro) :  _mount_path(os::strdup(mount_path)),\n+                                   _cgroup_path(os::strdup(cgroup_path)),\n+                                   _read_only(ro),\n+                                   _path(construct_path(mount_path, cgroup_path)) {\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV2Controller(const CgroupV2Controller& o) :\n+                                            _mount_path(o._mount_path),\n+                                            _cgroup_path(o._cgroup_path),\n+                                            _read_only(o._read_only),\n+                                            _path(o._path) {\n+    }\n+    ~CgroupV2Controller() {\n+      \/\/ At least one controller exists with references to the paths\n@@ -48,1 +61,39 @@\n-    char *subsystem_path() { return _path; }\n+    char *subsystem_path() override { return _path; }\n+    bool is_read_only() override { return _read_only; }\n+};\n+\n+class CgroupV2CpuController: public CgroupCpuController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2CpuController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n+};\n+\n+class CgroupV2MemoryController final: public CgroupMemoryController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2MemoryController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -54,1 +105,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2Controller _unified;\n@@ -56,2 +107,2 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -59,2 +110,1 @@\n-    jlong mem_swp_limit_val();\n-    jlong mem_swp_current_val();\n+    CgroupV2Controller* unified() { return &_unified; }\n@@ -63,4 +113,6 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n+    CgroupV2Subsystem(CgroupV2MemoryController* memory,\n+                      CgroupV2CpuController* cpu,\n+                      CgroupV2Controller unified) :\n+        _unified(unified),\n+        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n@@ -69,20 +121,8 @@\n-    jlong read_memory_limit_in_bytes();\n-    int cpu_quota();\n-    int cpu_period();\n-    int cpu_shares();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n-\n-    char * cpu_cpuset_cpus();\n-    char * cpu_cpuset_memory_nodes();\n-    jlong pids_max();\n-    jlong pids_current();\n-\n-    void print_version_specific_info(outputStream* st);\n-\n-    const char * container_type() {\n+    char * cpu_cpuset_cpus() override;\n+    char * cpu_cpuset_memory_nodes() override;\n+    jlong pids_max() override;\n+    jlong pids_current() override;\n+\n+    bool is_containerized() override;\n+\n+    const char * container_type() override {\n@@ -91,2 +131,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":76,"deletions":36,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,1 +392,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n@@ -442,1 +442,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, offset);\n","filename":"src\/hotspot\/os\/linux\/gc\/x\/xPhysicalMemoryBacking_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,1 +394,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n@@ -444,1 +444,1 @@\n-  void* const addr = mmap(0, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n+  void* const addr = mmap(nullptr, length, PROT_READ|PROT_WRITE, MAP_SHARED, _fd, untype(offset));\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -28,1 +28,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -30,0 +29,3 @@\n+#include \"procMapsParser.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -31,0 +33,2 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n@@ -33,14 +37,33 @@\n-struct ProcMapsInfo {\n-  void* from = 0;\n-  void* to = 0;\n-  char prot[20 + 1];\n-  char offset[20 + 1];\n-  char dev[20 + 1];\n-  char inode[20 + 1];\n-  char filename[1024 + 1];\n-\n-  bool scan_proc_maps_line(const char* line) {\n-    prot[0] = offset[0] = dev[0] = inode[0] = filename[0] = '\\0';\n-    const int items_read = ::sscanf(line, \"%p-%p %20s %20s %20s %20s %1024s\",\n-        &from, &to, prot, offset, dev, inode, filename);\n-    return items_read >= 2; \/\/ need at least from and to\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _vsize;        \/\/ combined virtual size\n+  size_t _rss;          \/\/ combined resident set size\n+  size_t _committed;    \/\/ combined committed size\n+  size_t _shared;       \/\/ combined shared size\n+  size_t _swapped_out;  \/\/ combined amount of swapped-out memory\n+  size_t _hugetlb;      \/\/ combined amount of memory backed by explicit huge pages\n+  size_t _thp;          \/\/ combined amount of memory backed by THPs\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _vsize(0), _rss(0), _committed(0), _shared(0),\n+                     _swapped_out(0), _hugetlb(0), _thp(0) {}\n+  void add_mapping(const ProcSmapsInfo& info) {\n+    _num_mappings++;\n+    _vsize += info.vsize();\n+    _rss += info.rss;\n+    _committed += info.nr ? 0 : info.vsize();\n+    _shared += info.sh ? info.vsize() : 0;\n+    _swapped_out += info.swap;\n+    _hugetlb += info.private_hugetlb + info.shared_hugetlb;\n+    _thp += info.anonhugepages;\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+    st->print_cr(\"             vsize: %zu (\" PROPERFMT \")\", _vsize, PROPERFMTARGS(_vsize));\n+    st->print_cr(\"               rss: %zu (\" PROPERFMT \")\", _rss, PROPERFMTARGS(_rss));\n+    st->print_cr(\"         committed: %zu (\" PROPERFMT \")\", _committed, PROPERFMTARGS(_committed));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out, PROPERFMTARGS(_swapped_out));\n+    st->print_cr(\"         using thp: %zu (\" PROPERFMT \")\", _thp, PROPERFMTARGS(_thp));\n+    st->print_cr(\"           hugetlb: %zu (\" PROPERFMT \")\", _hugetlb, PROPERFMTARGS(_hugetlb));\n@@ -50,2 +73,2 @@\n-class LinuxMappingPrintInformation : public MappingPrintInformation {\n-  const ProcMapsInfo _info;\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n@@ -53,0 +76,3 @@\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n@@ -54,2 +80,46 @@\n-  LinuxMappingPrintInformation(const void* from, const void* to, const ProcMapsInfo* info) :\n-    MappingPrintInformation(from, to), _info(*info) {}\n+  void print_single_mapping(const ProcSmapsInfo& info) const {\n+    outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(PTR_FORMAT \"-\" PTR_FORMAT, p2i(info.from), p2i(info.to));\n+    INDENT_BY(38);\n+    st->print(\"%12zu\", info.vsize());\n+    INDENT_BY(51);\n+    st->print(\"%s\", info.prot);\n+    INDENT_BY(56);\n+    st->print(\"%12zu\", info.rss);\n+    INDENT_BY(69);\n+    st->print(\"%12zu\", info.private_hugetlb);\n+    INDENT_BY(82);\n+    st->print(EXACTFMT, EXACTFMTARGS(info.kernelpagesize));\n+    {\n+      INDENT_BY(87);\n+      int num_printed = 0;\n+#define PRINTIF(cond, s)                                    \\\n+      if (cond) {                                           \\\n+        st->print(\"%s%s\", (num_printed > 0 ? \",\" : \"\"), s); \\\n+        num_printed++;                                      \\\n+      }\n+      PRINTIF(info.sh, \"shrd\");\n+      PRINTIF(!info.nr, \"com\");\n+      PRINTIF(info.swap > 0, \"swap\");\n+      PRINTIF(info.ht, \"huge\");\n+      PRINTIF(info.anonhugepages > 0, \"thp\");\n+      PRINTIF(info.hg, \"thpad\");\n+      PRINTIF(info.nh, \"nothp\");\n+      if (num_printed == 0) {\n+        st->print(\"-\");\n+      }\n+#undef PRINTIF\n+    }\n+    INDENT_BY(104);\n+    if (!_session.print_nmt_info_for_region(info.from, info.to)) {\n+      st->print(\"-\");\n+    }\n+    INDENT_BY(142);\n+    st->print_raw(info.filename[0] == '\\0' ? \"-\" : info.filename);\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n@@ -57,2 +127,21 @@\n-  void print_OS_specific_details(outputStream* st) const override {\n-    st->print(\"%s %s \", _info.prot, _info.offset);\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:            protection\");\n+    st->print_cr(\"rss:             resident set size\");\n+    st->print_cr(\"hugetlb:         size of private hugetlb pages\");\n+    st->print_cr(\"pgsz:            page size\");\n+    st->print_cr(\"notes:           mapping information  (detail mode only)\");\n+    st->print_cr(\"                      shrd: mapping is shared\");\n+    st->print_cr(\"                       com: mapping committed (swap space reserved)\");\n+    st->print_cr(\"                      swap: mapping partly or completely swapped out\");\n+    st->print_cr(\"                       thp: mapping uses THP\");\n+    st->print_cr(\"                     thpad: mapping is THP-madvised\");\n+    st->print_cr(\"                     nothp: mapping is forbidden to use THP\");\n+    st->print_cr(\"                      huge: mapping uses hugetlb pages\");\n+    st->print_cr(\"vm info:         VM information (requires NMT)\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n@@ -61,1 +150,8 @@\n-  const char* filename() const override { return _info.filename; }\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x0000000414000000-0x0000000453000000 123456789012 rw-p 123456789012 123456789012 16g  thp,thpadv       STACK-340754-Monitor-Deflation-Thread \/shared\/tmp.txt\n+    st->print_cr(\"from               to                        vsize prot          rss      hugetlb pgsz notes            info                                  file\");\n+    st->print_cr(\"========================================================================================================================================================================\");\n+  }\n@@ -64,6 +160,3 @@\n-void MemMapPrinter::pd_print_header(outputStream* st) {\n-  st->print_cr(\"size          prot offset  What\");\n-}\n-\n-void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n-  FILE* f = os::fopen(\"\/proc\/self\/maps\", \"r\");\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+  constexpr char filename[] = \"\/proc\/self\/smaps\";\n+  FILE* f = os::fopen(filename, \"r\");\n@@ -71,0 +164,1 @@\n+    session.out()->print_cr(\"Cannot open %s\", filename);\n@@ -73,9 +167,15 @@\n-  constexpr size_t linesize = sizeof(ProcMapsInfo);\n-  char line[linesize];\n-  while (fgets(line, sizeof(line), f) == line) {\n-    line[sizeof(line) - 1] = '\\0';\n-    ProcMapsInfo info;\n-    if (info.scan_proc_maps_line(line)) {\n-      LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n-      closure.do_it(&mapinfo);\n-    }\n+\n+  ProcSmapsPrinter printer(session);\n+  ProcSmapsSummary summary;\n+\n+  outputStream* const st = session.out();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  ProcSmapsInfo info;\n+  ProcSmapsParser parser(f);\n+  while (parser.parse_next(info)) {\n+    printer.print_single_mapping(info);\n+    summary.add_mapping(info);\n@@ -83,0 +183,5 @@\n+  st->cr();\n+\n+  summary.print_on(session);\n+  st->cr();\n+\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":144,"deletions":39,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -61,2 +61,37 @@\n-\n-  _is_containerized = true;\n+  \/*\n+   * In order to avoid a false positive on is_containerized() on\n+   * Linux systems outside a container *and* to ensure compatibility\n+   * with in-container usage, we detemine is_containerized() by two\n+   * steps:\n+   * 1.) Determine if all the cgroup controllers are mounted read only.\n+   *     If yes, is_containerized() == true. Otherwise, do the fallback\n+   *     in 2.)\n+   * 2.) Query for memory and cpu limits. If any limit is set, we set\n+   *     is_containerized() == true.\n+   *\n+   * Step 1.) covers the basic in container use-cases. Step 2.) ensures\n+   * that limits enforced by other means (e.g. systemd slice) are properly\n+   * detected.\n+   *\/\n+  const char *reason;\n+  bool any_mem_cpu_limit_present = false;\n+  bool controllers_read_only = cgroup_subsystem->is_containerized();\n+  if (controllers_read_only) {\n+    \/\/ in-container case\n+    reason = \" because all controllers are mounted read-only (container case)\";\n+  } else {\n+    \/\/ We can be in one of two cases:\n+    \/\/  1.) On a physical Linux system without any limit\n+    \/\/  2.) On a physical Linux system with a limit enforced by other means (like systemd slice)\n+    any_mem_cpu_limit_present = cgroup_subsystem->memory_limit_in_bytes() > 0 ||\n+                                     os::Linux::active_processor_count() != cgroup_subsystem->active_processor_count();\n+    if (any_mem_cpu_limit_present) {\n+      reason = \" because either a cpu or a memory limit is present\";\n+    } else {\n+      reason = \" because no cpu or memory limit is present\";\n+    }\n+  }\n+  _is_containerized = controllers_read_only || any_mem_cpu_limit_present;\n+  log_debug(os, container)(\"OSContainer::init: is_containerized() = %s%s\",\n+                                                            _is_containerized ? \"true\" : \"false\",\n+                                                            reason);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3528,75 +3528,0 @@\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  int mincore_return_value;\n-  const size_t stripe = 1024;  \/\/ query this many pages each time\n-  unsigned char vec[stripe + 1];\n-  \/\/ set a guard\n-  vec[stripe] = 'X';\n-\n-  const size_t page_sz = os::vm_page_size();\n-  uintx pages = size \/ page_sz;\n-\n-  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n-  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n-\n-  committed_start = nullptr;\n-\n-  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n-  int committed_pages = 0;\n-  address loop_base = start;\n-  bool found_range = false;\n-\n-  for (int index = 0; index < loops && !found_range; index ++) {\n-    assert(pages > 0, \"Nothing to do\");\n-    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n-    pages -= pages_to_query;\n-\n-    \/\/ Get stable read\n-    while ((mincore_return_value = mincore(loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN);\n-\n-    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n-    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n-    \/\/ Bailout and return as not committed for now.\n-    if (mincore_return_value == -1 && errno == ENOMEM) {\n-      return false;\n-    }\n-\n-    \/\/ If mincore is not supported.\n-    if (mincore_return_value == -1 && errno == ENOSYS) {\n-      return false;\n-    }\n-\n-    assert(vec[stripe] == 'X', \"overflow guard\");\n-    assert(mincore_return_value == 0, \"Range must be valid\");\n-    \/\/ Process this stripe\n-    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n-      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n-        \/\/ End of current contiguous region\n-        if (committed_start != nullptr) {\n-          found_range = true;\n-          break;\n-        }\n-      } else { \/\/ committed\n-        \/\/ Start of region\n-        if (committed_start == nullptr) {\n-          committed_start = loop_base + page_sz * vecIdx;\n-        }\n-        committed_pages ++;\n-      }\n-    }\n-\n-    loop_base += pages_to_query * page_sz;\n-  }\n-\n-  if (committed_start != nullptr) {\n-    assert(committed_pages > 0, \"Must have committed region\");\n-    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n-    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n-    committed_size = page_sz * committed_pages;\n-    return true;\n-  } else {\n-    assert(committed_pages == 0, \"Should not have committed region\");\n-    return false;\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"procMapsParser.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static bool is_lowercase_hex(char c) {\n+  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');\n+}\n+\n+static size_t max_mapping_line_len() {\n+  return 100 + \/\/ everything but the file name\n+         os::vm_page_size() \/\/ the file name (kernel limits \/proc\/pid\/cmdline to one page\n+         ;\n+}\n+\n+ProcSmapsParser::ProcSmapsParser(FILE* f) :\n+  _f(f), _linelen(max_mapping_line_len()), _line(nullptr) {\n+  assert(_f != nullptr, \"Invalid file handle given\");\n+  _line = NEW_C_HEAP_ARRAY(char, max_mapping_line_len(), mtInternal);\n+  _line[0] = '\\0';\n+}\n+\n+ProcSmapsParser::~ProcSmapsParser() {\n+  FREE_C_HEAP_ARRAY(char, _line);\n+}\n+\n+bool ProcSmapsParser::read_line() {\n+  _line[0] = '\\0';\n+  return ::fgets(_line, _linelen, _f) != nullptr;\n+}\n+\n+bool ProcSmapsParser::is_header_line() {\n+  \/\/ e.g. ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\n+  return is_lowercase_hex(_line[0]); \/\/ All non-header lines in \/proc\/pid\/smaps start with upper-case letters.\n+}\n+\n+void ProcSmapsParser::scan_header_line(ProcSmapsInfo& out) {\n+  const int items_read = ::sscanf(_line, \"%p-%p %20s %*s %*s %*s %1024s\",\n+                                  &out.from, &out.to, out.prot, out.filename);\n+  assert(items_read >= 2, \"Expected header_line\");\n+}\n+\n+void ProcSmapsParser::scan_additional_line(ProcSmapsInfo& out) {\n+#define SCAN(key, var) \\\n+ if (::sscanf(_line, key \": %zu kB\", &var) == 1) { \\\n+     var *= K; \\\n+     return; \\\n+ }\n+  SCAN(\"KernelPageSize\", out.kernelpagesize);\n+  SCAN(\"Rss\", out.rss);\n+  SCAN(\"AnonHugePages\", out.anonhugepages);\n+  SCAN(\"Private_Hugetlb\", out.private_hugetlb);\n+  SCAN(\"Shared_Hugetlb\", out.shared_hugetlb);\n+  SCAN(\"Swap\", out.swap);\n+  int i = 0;\n+#undef SCAN\n+  \/\/ scan some flags too\n+  if (strncmp(_line, \"VmFlags:\", 8) == 0) {\n+#define SCAN(flag) { out.flag = (::strstr(_line + 8, \" \" #flag) != nullptr); }\n+    SCAN(rd);\n+    SCAN(wr);\n+    SCAN(ex);\n+    SCAN(nr);\n+    SCAN(sh);\n+    SCAN(hg);\n+    SCAN(ht);\n+    SCAN(nh);\n+#undef SCAN\n+  }\n+}\n+\n+\/\/ Starts or continues parsing. Returns true on success,\n+\/\/ false on EOF or on error.\n+bool ProcSmapsParser::parse_next(ProcSmapsInfo& out) {\n+\n+  \/\/ Information about a single mapping reaches across several lines.\n+  out.reset();\n+\n+  \/\/ Read header line, unless we already read it\n+  if (_line[0] == '\\0') {\n+    if (!read_line()) {\n+      return false;\n+    }\n+  }\n+  assert(is_header_line(), \"Not a header line: \\\"%s\\\".\", _line);\n+  scan_header_line(out);\n+\n+  \/\/ Now read until we encounter the next header line or EOF or an error.\n+  bool ok = false, stop = false;\n+  do {\n+    ok = read_line();\n+    stop = !ok || is_header_line();\n+    if (!stop) {\n+      scan_additional_line(out);\n+    }\n+  } while (!stop);\n+\n+  return ok;\n+}\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.cpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PROCMAPSPARSER_HPP\n+#define OS_LINUX_PROCMAPSPARSER_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ This header exposes two simple parsers for \/proc\/pid\/maps and\n+\/\/ \/proc\/pid\/smaps.\n+\/\/\n+\/\/ Usage:\n+\/\/\n+\/\/ FILE* f = fopen(...)\n+\/\/ ProcSMapsParser parser(f);\n+\/\/ ProcSMapsInfo info;\n+\/\/ while (parser.parse_next(info)) { ... }\n+\n+struct ProcSmapsInfo {\n+  void* from;\n+  void* to;\n+  char prot[20 + 1];\n+  char filename[1024 + 1];\n+  size_t kernelpagesize;\n+  size_t rss;\n+  size_t private_hugetlb;\n+  size_t shared_hugetlb;\n+  size_t anonhugepages;\n+  size_t swap;\n+  bool rd, wr, ex;\n+  bool sh; \/\/ shared\n+  bool nr; \/\/ no reserve\n+  bool hg; \/\/ thp-advised\n+  bool ht; \/\/ uses hugetlb pages\n+  bool nh; \/\/ thp forbidden\n+\n+  size_t vsize() const {\n+    return from < to ? pointer_delta(to, from, 1) : 0;\n+  }\n+\n+  void reset() {\n+    from = to = nullptr;\n+    prot[0] = filename[0] = '\\0';\n+    kernelpagesize = rss = private_hugetlb = shared_hugetlb = anonhugepages = swap = 0;\n+    rd = wr = ex = sh = nr = hg = ht = nh = false;\n+  }\n+};\n+\n+class ProcSmapsParser {\n+  FILE* _f;\n+  const size_t _linelen;\n+  char* _line;\n+\n+  bool read_line(); \/\/ sets had_error in case of error\n+  bool is_header_line();\n+  void scan_header_line(ProcSmapsInfo& out);\n+  void scan_additional_line(ProcSmapsInfo& out);\n+\n+public:\n+\n+  ProcSmapsParser(FILE* f);\n+  ~ProcSmapsParser();\n+\n+  \/\/ Starts or continues parsing. Returns true on success,\n+  \/\/ false on EOF or on error.\n+  bool parse_next(ProcSmapsInfo& out);\n+};\n+\n+#endif \/\/ OS_LINUX_PROCMAPSPARSER_HPP\n","filename":"src\/hotspot\/os\/linux\/procMapsParser.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -96,0 +96,3 @@\n+\/* Input\/Output types for mincore(2) *\/\n+typedef LINUX_ONLY(unsigned) char mincore_vec_t;\n+\n@@ -149,0 +152,88 @@\n+bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n+\n+#ifdef _AIX\n+  committed_start = start;\n+  committed_size = size;\n+  return true;\n+#else\n+\n+  int mincore_return_value;\n+  constexpr size_t stripe = 1024;  \/\/ query this many pages each time\n+  mincore_vec_t vec [stripe + 1];\n+\n+  \/\/ set a guard\n+  DEBUG_ONLY(vec[stripe] = 'X');\n+\n+  size_t page_sz = os::vm_page_size();\n+  uintx pages = size \/ page_sz;\n+\n+  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n+  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n+\n+  committed_start = nullptr;\n+\n+  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n+  int committed_pages = 0;\n+  address loop_base = start;\n+  bool found_range = false;\n+\n+  for (int index = 0; index < loops && !found_range; index ++) {\n+    assert(pages > 0, \"Nothing to do\");\n+    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n+    pages -= pages_to_query;\n+\n+    \/\/ Get stable read\n+    int fail_count = 0;\n+    while ((mincore_return_value = mincore(loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN){\n+      if (++fail_count == 1000){\n+        return false;\n+      }\n+    }\n+\n+    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n+    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n+    \/\/ Bailout and return as not committed for now.\n+    if (mincore_return_value == -1 && errno == ENOMEM) {\n+      return false;\n+    }\n+\n+    \/\/ If mincore is not supported.\n+    if (mincore_return_value == -1 && errno == ENOSYS) {\n+      return false;\n+    }\n+\n+    assert(vec[stripe] == 'X', \"overflow guard\");\n+    assert(mincore_return_value == 0, \"Range must be valid\");\n+    \/\/ Process this stripe\n+    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n+      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n+        \/\/ End of current contiguous region\n+        if (committed_start != nullptr) {\n+          found_range = true;\n+          break;\n+        }\n+      } else { \/\/ committed\n+        \/\/ Start of region\n+        if (committed_start == nullptr) {\n+          committed_start = loop_base + page_sz * vecIdx;\n+        }\n+        committed_pages ++;\n+      }\n+    }\n+\n+    loop_base += pages_to_query * page_sz;\n+  }\n+\n+  if (committed_start != nullptr) {\n+    assert(committed_pages > 0, \"Must have committed region\");\n+    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n+    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n+    committed_size = page_sz * committed_pages;\n+    return true;\n+  } else {\n+    assert(committed_pages == 0, \"Should not have committed region\");\n+    return false;\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2761,1 +2761,1 @@\n-#ifndef PRODUCT\n+#if !defined(PRODUCT) && defined(_LP64)\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -419,1 +419,1 @@\n-#ifndef PRODUCT\n+#if !defined(PRODUCT) && defined(_LP64)\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-#ifndef PRODUCT\n+#if !defined(PRODUCT) && defined(_LP64)\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n+  print_hex_dump(st, pc - 32, pc + 32, sizeof(char), \/* print_ascii=*\/false);\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1276,1 +1276,1 @@\n-      os::print_hex_dump(&lsh, base, top, unitsize, 32, requested_base);\n+      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n@@ -1415,7 +1415,0 @@\n-\n-\n-#ifndef PRODUCT\n-void ArchiveBuilder::assert_is_vm_thread() {\n-  assert(Thread::current()->is_VM_thread(), \"ArchiveBuilder should be used only inside the VMThread\");\n-}\n-#endif\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -346,2 +346,0 @@\n-  static void assert_is_vm_thread() PRODUCT_RETURN;\n-\n@@ -435,1 +433,0 @@\n-    assert_is_vm_thread();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/cdsEnumKlass.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+bool CDSEnumKlass::is_enum_obj(oop orig_obj) {\n+  Klass* k = orig_obj->klass();\n+  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n+  return k->is_instance_klass() &&\n+         InstanceKlass::cast(k)->java_super() == vmClasses::Enum_klass();\n+}\n+\n+\/\/ -- Handling of Enum objects\n+\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n+\/\/     enum MyEnum {FOO, BAR}\n+\/\/     MyEnum::<clinint> {\n+\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n+\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n+\/\/     }\n+\/\/\n+\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n+\/\/ ensure the archived value equals (in object address) to the runtime value of\n+\/\/ MyEnum::FOO.\n+\/\/\n+\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n+\/\/ no way of programmatically handling this inside the Java code (as you would handle\n+\/\/ ModuleLayer::EMPTY_LAYER, for example).\n+\/\/\n+\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n+\/\/ HeapShared::initialize_enum_klass() skips the <clinit> method and instead pulls\n+\/\/ the static fields out of the archived heap.\n+void CDSEnumKlass::handle_enum_obj(int level,\n+                                   KlassSubGraphInfo* subgraph_info,\n+                                   oop orig_obj) {\n+  assert(level > 1, \"must never be called at the first (outermost) level\");\n+  assert(is_enum_obj(orig_obj), \"must be\");\n+\n+  InstanceKlass* ik = InstanceKlass::cast(orig_obj->klass());\n+  if (ik->has_archived_enum_objs()) {\n+    return;\n+  }\n+\n+  ik->set_has_archived_enum_objs();\n+  ArchiveBuilder::get_buffered_klass(ik)->set_has_archived_enum_objs();\n+\n+  oop mirror = ik->java_mirror();\n+  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      archive_static_field(level, subgraph_info, ik, mirror, fs);\n+    }\n+  }\n+}\n+\n+void CDSEnumKlass::archive_static_field(int level, KlassSubGraphInfo* subgraph_info,\n+                                        InstanceKlass* ik, oop mirror, JavaFieldStream& fs) {\n+  ResourceMark rm;\n+  fieldDescriptor& fd = fs.field_descriptor();\n+  if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+    guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  }\n+  oop oop_field = mirror->obj_field(fd.offset());\n+  if (oop_field == nullptr) {\n+    guarantee(false, \"static field %s::%s must not be null\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+    guarantee(false, \"static field %s::%s is of the wrong type\",\n+              ik->external_name(), fd.name()->as_C_string());\n+  }\n+  bool success = HeapShared::archive_reachable_objects_from(level, subgraph_info, oop_field);\n+  assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n+  int root_index = HeapShared::append_root(oop_field);\n+  log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \")\",\n+                      root_index, ik->external_name(), fd.name()->as_C_string(),\n+                      p2i((oopDesc*)oop_field));\n+  SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n+}\n+\n+bool CDSEnumKlass::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n+    return false;\n+  }\n+\n+  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n+  assert(info != nullptr, \"sanity\");\n+\n+  if (log_is_enabled(Info, cds, heap)) {\n+    ResourceMark rm;\n+    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n+  }\n+\n+  oop mirror = k->java_mirror();\n+  int i = 0;\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      int root_index = info->enum_klass_static_field_root_index_at(i++);\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n+      mirror->obj_field_put(fd.offset(), HeapShared::get_root(root_index, \/*clear=*\/true));\n+    }\n+  }\n+  return true;\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_CDSENUMKLASS_HPP\n+#define SHARE_CDS_CDSENUMKLASS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class InstanceKlass;\n+class JavaFieldStream;\n+class KlassSubGraphInfo;\n+\n+class CDSEnumKlass: AllStatic {\n+public:\n+  static bool is_enum_obj(oop orig_obj);\n+  static void handle_enum_obj(int level,\n+                              KlassSubGraphInfo* subgraph_info,\n+                              oop orig_obj);\n+  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+\n+private:\n+  static void archive_static_field(int level, KlassSubGraphInfo* subgraph_info,\n+                                   InstanceKlass* ik, oop mirror, JavaFieldStream& fs);\n+};\n+\n+#endif \/\/ SHARE_CDS_CDSENUMKLASS_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -837,0 +837,2 @@\n+    case JVM_CONSTANT_Methodref:\n+    case JVM_CONSTANT_InterfaceMethodref:\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,3 +261,1 @@\n-        if (rfe->is_resolved(Bytecodes::_getstatic) ||\n-            rfe->is_resolved(Bytecodes::_putstatic) ||\n-            rfe->is_resolved(Bytecodes::_getfield) ||\n+        if (rfe->is_resolved(Bytecodes::_getfield) ||\n@@ -270,0 +268,13 @@\n+\n+    Array<ResolvedMethodEntry>* method_entries = cp->cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokevirtual) ||\n+            rme->is_resolved(Bytecodes::_invokespecial) ||\n+            rme->is_resolved(Bytecodes::_invokeinterface)) {\n+          list.at_put(rme->constant_pool_index(), true);\n+          print = true;\n+        }\n+      }\n+    }\n@@ -279,1 +290,3 @@\n-               cp_tag.value() == JVM_CONSTANT_Fieldref, \"sanity\");\n+               cp_tag.value() == JVM_CONSTANT_Fieldref ||\n+               cp_tag.value() == JVM_CONSTANT_Methodref||\n+               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -92,1 +92,3 @@\n-  } else if (cp->tag_at(cp_index).is_field()) {\n+  } else if (cp->tag_at(cp_index).is_field() ||\n+             cp->tag_at(cp_index).is_method() ||\n+             cp->tag_at(cp_index).is_interface_method()) {\n@@ -266,0 +268,8 @@\n+      case Bytecodes::_invokespecial:\n+      case Bytecodes::_invokevirtual:\n+      case Bytecodes::_invokeinterface:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n@@ -304,0 +314,6 @@\n+  case Bytecodes::_invokevirtual:\n+  case Bytecodes::_invokespecial:\n+  case Bytecodes::_invokeinterface:\n+    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n+    break;\n+\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  msg.info(\"Method CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_method_cp_entries, _num_method_cp_entries_archived,\n+           percent_of(_num_method_cp_entries_archived, _num_method_cp_entries),\n+           _num_method_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+  int _num_method_cp_entries;\n+  int _num_method_cp_entries_archived;\n+  int _num_method_cp_entries_reverted;\n@@ -87,0 +90,3 @@\n+    _num_method_cp_entries          = 0;\n+    _num_method_cp_entries_archived = 0;\n+    _num_method_cp_entries_reverted = 0;\n@@ -125,0 +131,6 @@\n+  void record_method_cp_entry(bool archived, bool reverted) {\n+    _num_method_cp_entries ++;\n+    _num_method_cp_entries_archived += archived ? 1 : 0;\n+    _num_method_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1481,1 +1481,2 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    MetaspaceShared::writing_error();\n+    return;\n@@ -1734,1 +1735,1 @@\n-    MetaspaceShared::unrecoverable_writing_error(\"Unable to write to shared archive file.\");\n+    MetaspaceShared::writing_error(\"Unable to write to shared archive file.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/cdsEnumKlass.hpp\"\n@@ -454,89 +455,0 @@\n-\/\/ -- Handling of Enum objects\n-\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n-\/\/     enum MyEnum {FOO, BAR}\n-\/\/     MyEnum::<clinint> {\n-\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n-\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n-\/\/     }\n-\/\/\n-\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n-\/\/ ensure the archived value equals (in object address) to the runtime value of\n-\/\/ MyEnum::FOO.\n-\/\/\n-\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n-\/\/ no way of programmatically handling this inside the Java code (as you would handle\n-\/\/ ModuleLayer::EMPTY_LAYER, for example).\n-\/\/\n-\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n-\/\/ HeapShared::initialize_enum_klass() will skip the <clinit> method and pull\n-\/\/ the static fields out of the archived heap.\n-void HeapShared::check_enum_obj(int level,\n-                                KlassSubGraphInfo* subgraph_info,\n-                                oop orig_obj) {\n-  assert(level > 1, \"must never be called at the first (outermost) level\");\n-  Klass* k = orig_obj->klass();\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n-  if (!k->is_instance_klass()) {\n-    return;\n-  }\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->java_super() == vmClasses::Enum_klass() && !ik->has_archived_enum_objs()) {\n-    ResourceMark rm;\n-    ik->set_has_archived_enum_objs();\n-    buffered_k->set_has_archived_enum_objs();\n-    oop mirror = ik->java_mirror();\n-\n-    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n-      if (fs.access_flags().is_static()) {\n-        fieldDescriptor& fd = fs.field_descriptor();\n-        if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n-          guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        }\n-        oop oop_field = mirror->obj_field(fd.offset());\n-        if (oop_field == nullptr) {\n-          guarantee(false, \"static field %s::%s must not be null\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n-          guarantee(false, \"static field %s::%s is of the wrong type\",\n-                    ik->external_name(), fd.name()->as_C_string());\n-        }\n-        bool success = archive_reachable_objects_from(level, subgraph_info, oop_field);\n-        assert(success, \"VM should have exited with unarchivable objects for _level > 1\");\n-        int root_index = append_root(oop_field);\n-        log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \")\",\n-                            root_index, ik->external_name(), fd.name()->as_C_string(),\n-                            p2i((oopDesc*)oop_field));\n-        SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ See comments in HeapShared::check_enum_obj()\n-bool HeapShared::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n-  if (!ArchiveHeapLoader::is_in_use()) {\n-    return false;\n-  }\n-\n-  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n-  assert(info != nullptr, \"sanity\");\n-\n-  if (log_is_enabled(Info, cds, heap)) {\n-    ResourceMark rm;\n-    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n-  }\n-\n-  oop mirror = k->java_mirror();\n-  int i = 0;\n-  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static()) {\n-      int root_index = info->enum_klass_static_field_root_index_at(i++);\n-      fieldDescriptor& fd = fs.field_descriptor();\n-      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n-      mirror->obj_field_put(fd.offset(), get_root(root_index, \/*clear=*\/true));\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1244,1 +1156,3 @@\n-  check_enum_obj(level + 1, subgraph_info, orig_obj);\n+  if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n+    CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":90,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -215,3 +215,0 @@\n-  static void check_enum_obj(int level, KlassSubGraphInfo* subgraph_info,\n-                             oop orig_obj);\n-\n@@ -431,1 +428,0 @@\n-  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -449,0 +449,2 @@\n+  FileMapInfo* _map_info;\n+  StaticArchiveBuilder& _builder;\n@@ -459,1 +461,2 @@\n-  VM_PopulateDumpSharedSpace() : VM_Operation(), _heap_info() {}\n+  VM_PopulateDumpSharedSpace(StaticArchiveBuilder& b) :\n+    VM_Operation(), _heap_info(), _map_info(nullptr), _builder(b) {}\n@@ -464,0 +467,2 @@\n+  ArchiveHeapInfo* heap_info()  { return &_heap_info; }\n+  FileMapInfo* map_info() const { return _map_info; }\n@@ -510,0 +515,2 @@\n+  guarantee(!CDSConfig::is_using_archive(), \"We should not be using an archive when we dump\");\n+\n@@ -520,3 +527,2 @@\n-  StaticArchiveBuilder builder;\n-  builder.gather_source_objs();\n-  builder.reserve_buffer();\n+  _builder.gather_source_objs();\n+  _builder.reserve_buffer();\n@@ -524,1 +530,1 @@\n-  CppVtables::dumptime_init(&builder);\n+  CppVtables::dumptime_init(&_builder);\n@@ -526,4 +532,4 @@\n-  builder.sort_metadata_objs();\n-  builder.dump_rw_metadata();\n-  builder.dump_ro_metadata();\n-  builder.relocate_metaspaceobj_embedded_pointers();\n+  _builder.sort_metadata_objs();\n+  _builder.dump_rw_metadata();\n+  _builder.dump_ro_metadata();\n+  _builder.relocate_metaspaceobj_embedded_pointers();\n@@ -531,2 +537,2 @@\n-  dump_java_heap_objects(builder.klasses());\n-  dump_shared_symbol_table(builder.symbols());\n+  dump_java_heap_objects(_builder.klasses());\n+  dump_shared_symbol_table(_builder.symbols());\n@@ -535,1 +541,1 @@\n-  builder.make_klasses_shareable();\n+  _builder.make_klasses_shareable();\n@@ -545,4 +551,0 @@\n-  \/\/ relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()\n-  \/\/ without runtime relocation.\n-  builder.relocate_to_requested();\n-\n@@ -552,15 +554,4 @@\n-  FileMapInfo* mapinfo = new FileMapInfo(static_archive, true);\n-  mapinfo->populate_header(MetaspaceShared::core_region_alignment());\n-  mapinfo->set_serialized_data(serialized_data);\n-  mapinfo->set_cloned_vtables(CppVtables::vtables_serialized_base());\n-  mapinfo->open_for_write();\n-  builder.write_archive(mapinfo, &_heap_info);\n-\n-  if (PrintSystemDictionaryAtExit) {\n-    SystemDictionary::print();\n-  }\n-\n-  if (AllowArchivingWithJavaAgent) {\n-    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-            \"for testing purposes only and should not be used in a production environment\");\n-  }\n+  _map_info = new FileMapInfo(static_archive, true);\n+  _map_info->populate_header(MetaspaceShared::core_region_alignment());\n+  _map_info->set_serialized_data(serialized_data);\n+  _map_info->set_cloned_vtables(CppVtables::vtables_serialized_base());\n@@ -668,2 +659,1 @@\n-void MetaspaceShared::preload_and_dump() {\n-  EXCEPTION_MARK;\n+void MetaspaceShared::preload_and_dump(TRAPS) {\n@@ -671,1 +661,2 @@\n-  preload_and_dump_impl(THREAD);\n+  StaticArchiveBuilder builder;\n+  preload_and_dump_impl(builder, THREAD);\n@@ -676,2 +667,1 @@\n-      CLEAR_PENDING_EXCEPTION;\n-      MetaspaceShared::unrecoverable_writing_error();\n+      MetaspaceShared::writing_error();\n@@ -681,2 +671,1 @@\n-      CLEAR_PENDING_EXCEPTION;\n-      MetaspaceShared::unrecoverable_writing_error(\"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+      MetaspaceShared::writing_error(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n@@ -773,1 +762,1 @@\n-void MetaspaceShared::preload_and_dump_impl(TRAPS) {\n+void MetaspaceShared::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n@@ -810,1 +799,1 @@\n-  VM_PopulateDumpSharedSpace op;\n+  VM_PopulateDumpSharedSpace op(builder);\n@@ -812,0 +801,22 @@\n+\n+  if (!write_static_archive(&builder, op.map_info(), op.heap_info())) {\n+    THROW_MSG(vmSymbols::java_io_IOException(), \"Encountered error while dumping\");\n+  }\n+}\n+\n+bool MetaspaceShared::write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info) {\n+  \/\/ relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()\n+  \/\/ without runtime relocation.\n+  builder->relocate_to_requested();\n+\n+  map_info->open_for_write();\n+  if (!map_info->is_open()) {\n+    return false;\n+  }\n+  builder->write_archive(map_info, heap_info);\n+\n+  if (AllowArchivingWithJavaAgent) {\n+    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+            \"for testing purposes only and should not be used in a production environment\");\n+  }\n+  return true;\n@@ -925,0 +936,7 @@\n+  writing_error(message);\n+  vm_direct_exit(1);\n+}\n+\n+\/\/ This function is called when the JVM is unable to write the specified CDS archive due to a\n+\/\/ an error. The error will be propagated\n+void MetaspaceShared::writing_error(const char* message) {\n@@ -929,1 +947,0 @@\n-  vm_direct_exit(1);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":58,"deletions":41,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+class ArchiveBuilder;\n+class ArchiveHeapInfo;\n@@ -37,0 +39,1 @@\n+class StaticArchiveBuilder;\n@@ -69,1 +72,1 @@\n-  static void preload_and_dump() NOT_CDS_RETURN;\n+  static void preload_and_dump(TRAPS) NOT_CDS_RETURN;\n@@ -75,1 +78,1 @@\n-  static void preload_and_dump_impl(TRAPS) NOT_CDS_RETURN;\n+  static void preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n@@ -108,0 +111,1 @@\n+  static void writing_error(const char* message = nullptr);\n@@ -169,0 +173,1 @@\n+  static bool write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -776,11 +776,4 @@\n-    if (UseVtableBasedCHA) {\n-      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n-                                                                              root_m->get_Method(),\n-                                                                              callee_holder->get_Klass(),\n-                                                                              this->get_Method()));\n-    } else {\n-      if (root_m->is_abstract()) {\n-        return nullptr; \/\/ not supported\n-      }\n-      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n-    }\n+    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n+                                                                            root_m->get_Method(),\n+                                                                            callee_holder->get_Klass(),\n+                                                                            this->get_Method()));\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-    _bc_start =_was_wide = 0;\n+    _bc_start = _was_wide = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  vm_exit_during_initialization(error, message);\n+  vm_exit_during_cds_dumping(error, message);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-  Chunk* chunk = _head;\n+  Chunk* chunk = Atomic::load_acquire(&_head);\n@@ -208,1 +208,1 @@\n-    count += chunk->_size;\n+    count += Atomic::load(&chunk->_size);\n@@ -262,1 +262,1 @@\n-  Chunk* chunk = _head;\n+  Chunk* chunk = Atomic::load_acquire(&_head);\n@@ -264,1 +264,1 @@\n-    if (&(chunk->_data[0]) <= oop_handle && oop_handle < &(chunk->_data[chunk->_size])) {\n+    if (&(chunk->_data[0]) <= oop_handle && oop_handle < &(chunk->_data[Atomic::load(&chunk->_size)])) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,3 +244,8 @@\n-\/\/ unloading can remove entries concurrently soon.\n-template <bool keep_alive = true>\n-class ClassLoaderDataGraphIteratorBase : public StackObj {\n+\/\/ unloading can remove entries concurrently.\n+\/\/ This iterator does not keep the CLD alive.\n+\/\/ Any CLD OopHandles (modules, mirrors, resolved refs)\n+\/\/ resolved must be treated as no keepalive. And requires\n+\/\/ that its CLD's holder is kept alive if they escape the\n+\/\/ caller's safepoint or ClassLoaderDataGraph_lock\n+\/\/ critical section.\n+class ClassLoaderDataGraph::ClassLoaderDataGraphIterator : public StackObj {\n@@ -254,6 +259,2 @@\n-  ClassLoaderDataGraphIteratorBase() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n-    if (keep_alive) {\n-      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-    } else {\n-      assert_at_safepoint();\n-    }\n+  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n+    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -269,4 +270,0 @@\n-      if (keep_alive) {\n-        \/\/ Keep cld that is being returned alive.\n-        Handle(_thread, cld->holder());\n-      }\n@@ -281,3 +278,0 @@\n-using ClassLoaderDataGraphIterator = ClassLoaderDataGraphIteratorBase<true \/* keep_alive *\/>;\n-using ClassLoaderDataGraphIteratorNoKeepAlive = ClassLoaderDataGraphIteratorBase<false \/* keep_alive *\/>;\n-\n@@ -291,7 +285,0 @@\n-void ClassLoaderDataGraph::loaded_cld_do_no_keepalive(CLDClosure* cl) {\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n-  while (ClassLoaderData* cld = iter.get_next()) {\n-    cl->do_cld(cld);\n-  }\n-}\n-\n@@ -321,0 +308,10 @@\n+void ClassLoaderDataGraph::modules_do_keepalive(void f(ModuleEntry*)) {\n+  assert_locked_or_safepoint(Module_lock);\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n+    cld->modules_do(f);\n+  }\n+}\n+\n@@ -337,1 +334,1 @@\n-void ClassLoaderDataGraph::loaded_classes_do(KlassClosure* klass_closure) {\n+void ClassLoaderDataGraph::loaded_classes_do_keepalive(KlassClosure* klass_closure) {\n@@ -340,0 +337,2 @@\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n@@ -349,1 +348,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n@@ -357,4 +356,0 @@\n-#define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \\\n-                                while (ClassLoaderData* X = iter.get_next()) \\\n-                                  if (X->dictionary() != nullptr)\n-\n@@ -362,6 +357,9 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    st->print(\"Dictionary for \");\n-    cld->print_value_on(st);\n-    st->cr();\n-    cld->dictionary()->print_on(st);\n-    st->cr();\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      st->print(\"Dictionary for \");\n+      cld->print_value_on(st);\n+      st->cr();\n+      cld->dictionary()->print_on(st);\n+      st->cr();\n+    }\n@@ -372,5 +370,8 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    ResourceMark rm; \/\/ loader_name_and_id\n-    stringStream tempst;\n-    tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n-    cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      ResourceMark rm; \/\/ loader_name_and_id\n+      stringStream tempst;\n+      tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n+      cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+    }\n@@ -553,1 +554,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-  template <bool keep_alive>\n-  friend class ClassLoaderDataGraphIteratorBase;\n@@ -44,0 +42,2 @@\n+  class ClassLoaderDataGraphIterator;\n+\n@@ -74,0 +74,5 @@\n+  \/\/ All the do suffixed functions do not keep the CLD alive. Any CLD OopHandles\n+  \/\/ (modules, mirrors, resolved refs) resolved must be treated as no keepalive.\n+  \/\/ And requires that its CLD's holder is kept alive if they escape the\n+  \/\/ caller's safepoint or ClassLoaderDataGraph_lock critical section.\n+  \/\/ The do_keepalive suffixed functions will keep all CLDs alive.\n@@ -75,1 +80,0 @@\n-  static void loaded_cld_do_no_keepalive(CLDClosure* cl);\n@@ -84,0 +88,1 @@\n+  static void modules_do_keepalive(void f(ModuleEntry*));\n@@ -86,1 +91,1 @@\n-  static void loaded_classes_do(KlassClosure* klass_closure);\n+  static void loaded_classes_do_keepalive(KlassClosure* klass_closure);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  _fold(\"fold\", \"Show loaders of the same name and class as one.\", \"BOOLEAN\", true, \"true\") {\n+  _fold(\"fold\", \"Show loaders of the same name and class as one.\", \"BOOLEAN\", false, \"true\") {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  ClassLoaderDataGraph::loaded_cld_do_no_keepalive(&clsc);\n+  ClassLoaderDataGraph::loaded_cld_do(&clsc);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,3 +183,2 @@\n-    if ((UseEmptySlotsInSupers && !super_klass->has_contended_annotations()) || !_super_has_fields) {\n-      _start = _blocks; \/\/ Setting _start to _blocks instead of _last would allow subclasses\n-      \/\/ to allocate fields in empty slots of their super classes\n+    if ((!super_klass->has_contended_annotations()) || !_super_has_fields) {\n+      _start = _blocks;  \/\/ start allocating fields from the first empty block\n@@ -440,13 +439,1 @@\n-  if (!UseEmptySlotsInSupers) {\n-    \/\/ Add an empty slots to align fields of the subclass on a heapOopSize boundary\n-    \/\/ in order to emulate the behavior of the previous algorithm\n-    int align = (b->offset() + b->size()) % heapOopSize;\n-    if (align != 0) {\n-      int sz = heapOopSize - align;\n-      LayoutRawBlock* p = new LayoutRawBlock(LayoutRawBlock::EMPTY, sz);\n-      p->set_offset(b->offset() + b->size());\n-      b->set_next_block(p);\n-      p->set_prev_block(b);\n-      b = p;\n-    }\n-  }\n+\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -793,1 +793,1 @@\n-\n+int java_lang_Class::_init_lock_offset;\n@@ -917,0 +917,6 @@\n+  \/\/ Allocate a simple java object for a lock.\n+  \/\/ This needs to be a java object because during class initialization\n+  \/\/ it can be held across a java call.\n+  typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);\n+  set_init_lock(mirror(), r);\n+\n@@ -1148,0 +1154,4 @@\n+    \/\/ create the init_lock\n+    typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));\n+    set_init_lock(mirror(), r);\n+\n@@ -1212,0 +1222,9 @@\n+oop java_lang_Class::init_lock(oop java_class) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  return java_class->obj_field(_init_lock_offset);\n+}\n+void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_init_lock_offset, init_lock);\n+}\n+\n@@ -1437,0 +1456,5 @@\n+  \/\/ Init lock is a C union with component_mirror.  Only instanceKlass mirrors have\n+  \/\/ init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops\n+  \/\/ GC treats them the same.\n+  _init_lock_offset = _component_mirror_offset;\n+\n@@ -1443,0 +1467,1 @@\n+  f->do_u4((u4*)&_init_lock_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,1 @@\n+  static int _init_lock_offset;\n@@ -244,0 +245,1 @@\n+  static void set_init_lock(oop java_class, oop init_lock);\n@@ -299,0 +301,4 @@\n+  static oop  init_lock(oop java_class);\n+  static void clear_init_lock(oop java_class) {\n+    set_init_lock(java_class, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-    return _reads->contains(m);\n+    return reads()->contains(m);\n@@ -167,1 +167,1 @@\n-    if (_reads == nullptr) {\n+    if (reads() == nullptr) {\n@@ -169,1 +169,2 @@\n-      _reads = new (mtModule) GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);\n+      GrowableArray<ModuleEntry*>* new_reads = new (mtModule) GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);\n+      set_reads(new_reads);\n@@ -177,1 +178,1 @@\n-    _reads->append_if_missing(m);\n+    reads()->append_if_missing(m);\n@@ -211,1 +212,1 @@\n-  return ((_reads != nullptr) && !_reads->is_empty());\n+  return ((reads() != nullptr) && !reads()->is_empty());\n@@ -230,1 +231,1 @@\n-    int len = _reads->length();\n+    int len = reads()->length();\n@@ -232,1 +233,1 @@\n-      ModuleEntry* module_idx = _reads->at(idx);\n+      ModuleEntry* module_idx = reads()->at(idx);\n@@ -235,1 +236,1 @@\n-        _reads->delete_at(idx);\n+        reads()->delete_at(idx);\n@@ -249,3 +250,3 @@\n-    int reads_len = _reads->length();\n-    for (int i = 0; i < reads_len; ++i) {\n-      f->do_module(_reads->at(i));\n+    int reads_len = reads()->length();\n+    for (ModuleEntry* m : *reads()) {\n+      f->do_module(m);\n@@ -257,1 +258,1 @@\n-  delete _reads;\n+  delete reads();\n@@ -275,1 +276,2 @@\n-    _is_patched(false) {\n+    _is_patched(false)\n+    DEBUG_ONLY(COMMA _reads_is_archived(false)) {\n@@ -469,1 +471,1 @@\n-  Array<ModuleEntry*>* archived_reads = write_growable_array(_reads);\n+  set_archived_reads(write_growable_array(reads()));\n@@ -477,1 +479,0 @@\n-  _reads = (GrowableArray<ModuleEntry*>*)archived_reads;\n@@ -518,1 +519,1 @@\n-  _reads = restore_growable_array((Array<ModuleEntry*>*)_reads);\n+  set_reads(restore_growable_array(archived_reads()));\n@@ -570,1 +571,1 @@\n-    QuickSort::sort(archived_modules->data(), n, (_sort_Fn)compare_module_by_name, true);\n+    QuickSort::sort(archived_modules->data(), n, compare_module_by_name);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -71,1 +71,5 @@\n-  GrowableArray<ModuleEntry*>* _reads; \/\/ list of modules that are readable by this module\n+\n+  union {\n+    GrowableArray<ModuleEntry*>* _reads;  \/\/ list of modules that are readable by this module\n+    Array<ModuleEntry*>* _archived_reads; \/\/ List of readable modules stored in the CDS archive\n+  };\n@@ -80,0 +84,1 @@\n+  DEBUG_ONLY(bool _reads_is_archived);\n@@ -118,0 +123,16 @@\n+  GrowableArray<ModuleEntry*>* reads() const {\n+    assert(!_reads_is_archived, \"sanity\");\n+    return _reads;\n+  }\n+  void set_reads(GrowableArray<ModuleEntry*>* r) {\n+    _reads = r;\n+    DEBUG_ONLY(_reads_is_archived = false);\n+  }\n+  Array<ModuleEntry*>* archived_reads() const {\n+    assert(_reads_is_archived, \"sanity\");\n+    return _archived_reads;\n+  }\n+  void set_archived_reads(Array<ModuleEntry*>* r) {\n+    _archived_reads = r;\n+    DEBUG_ONLY(_reads_is_archived = true);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -303,1 +303,2 @@\n-    QuickSort::sort(archived_packages->data(), n, (_sort_Fn)compare_package_by_name, true);\n+    \/\/ Always allocate in the same order to produce deterministic archive.\n+    QuickSort::sort(archived_packages->data(), n, compare_package_by_name);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-\n+  \/\/ Will not keep metadata alive. See ClassLoaderDataGraph::methods_do.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,2 +535,2 @@\n-  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n-  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+  do_name(intPolyMult_name, \"multImpl\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)V\")                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+  template(int_array_signature,                       \"[I\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -230,0 +230,5 @@\n+    \/\/ Further down, just before FLAG_SET_ERGO(), all segment sizes are\n+    \/\/ aligned down to the next lower multiple of min_size. For large page\n+    \/\/ sizes, this may result in (non_nmethod.size == 0) which is not acceptable.\n+    \/\/ Therefore, force non_nmethod.size to at least min_size.\n+    non_nmethod.size = MAX2(non_nmethod.size, min_size);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -116,5 +116,1 @@\n-  if (UseVtableBasedCHA) {\n-    assert_common_4(unique_concrete_method_4, ctxk, uniqm, resolved_klass, resolved_method);\n-  } else {\n-    assert_common_2(unique_concrete_method_2, ctxk, uniqm);\n-  }\n+  assert_common_4(unique_concrete_method_4, ctxk, uniqm, resolved_klass, resolved_method);\n@@ -1477,1 +1473,0 @@\n-    assert(UseVtableBasedCHA, \"required\");\n@@ -1952,1 +1947,0 @@\n-  assert(UseVtableBasedCHA, \"required\");\n@@ -2133,1 +2127,1 @@\n-    if (UseVtableBasedCHA && changes->is_klass_init_change()) {\n+    if (changes->is_klass_init_change()) {\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  ImplicitExceptionTable( ) :  _size(0), _len(0), _data(0) { }\n+  ImplicitExceptionTable( ) :  _size(0), _len(0), _data(nullptr) { }\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -858,4 +858,2 @@\n-    if (bs_nm->is_armed(nm)) {\n-      bool alive = bs_nm->nmethod_entry_barrier(nm);\n-      assert(alive, \"should be alive\");\n-    }\n+    bool alive = bs_nm->nmethod_entry_barrier(nm);\n+    assert(alive, \"should be alive\");\n@@ -3659,0 +3657,9 @@\n+        case relocInfo::entry_guard_type:      return \"entry_guard\";\n+        case relocInfo::post_call_nop_type:    return \"post_call_nop\";\n+        case relocInfo::barrier_type: {\n+          barrier_Relocation* const reloc = iter.barrier_reloc();\n+          stringStream st;\n+          st.print(\"barrier format=%d\", reloc->format());\n+          return st.as_string();\n+        }\n+\n@@ -3661,2 +3668,5 @@\n-        default:\n-          break;\n+        default: {\n+          stringStream st;\n+          st.print(\"unknown relocInfo=%d\", (int) iter.type());\n+          return st.as_string();\n+        }\n@@ -4034,0 +4044,1 @@\n+  ExternalsRecorder::print_statistics();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -726,0 +726,1 @@\n+  void copy_values(GrowableArray<address>* metadata) {} \/\/ Nothing to do\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -214,0 +215,43 @@\n+\n+\/\/ Explicitly instantiate\n+template class ValueRecorder<address>;\n+\n+ExternalsRecorder* ExternalsRecorder::_recorder = nullptr;\n+\n+ExternalsRecorder::ExternalsRecorder(): _arena(mtCode), _externals(&_arena) {}\n+\n+void ExternalsRecorder_init() {\n+  ExternalsRecorder::initialize();\n+}\n+\n+void ExternalsRecorder::initialize() {\n+  \/\/ After Mutex and before CodeCache are initialized\n+  assert(_recorder == nullptr, \"should initialize only once\");\n+  _recorder = new ExternalsRecorder();\n+}\n+\n+int ExternalsRecorder::find_index(address adr) {\n+  MutexLocker ml(ExternalsRecorder_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_recorder != nullptr, \"sanity\");\n+  return _recorder->_externals.find_index(adr);\n+}\n+\n+address ExternalsRecorder::at(int index) {\n+  \/\/ find_index() may resize array by reallocating it and freeing old,\n+  \/\/ we need loock here to make sure we not accessing to old freed array.\n+  MutexLocker ml(ExternalsRecorder_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_recorder != nullptr, \"sanity\");\n+  return _recorder->_externals.at(index);\n+}\n+\n+int ExternalsRecorder::count() {\n+  MutexLocker ml(ExternalsRecorder_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_recorder != nullptr, \"sanity\");\n+  return _recorder->_externals.count();\n+}\n+\n+#ifndef PRODUCT\n+void ExternalsRecorder::print_statistics() {\n+  tty->print_cr(\"External addresses table: %d entries\", count());\n+}\n+#endif\n","filename":"src\/hotspot\/share\/code\/oopRecorder.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-  GrowableArray<int>*       _no_finds; \/\/ all unfindable indexes; usually empty\n+  GrowableArray<int>*      _no_finds; \/\/ all unfindable indexes; usually empty\n@@ -138,2 +138,2 @@\n-  Arena*                    _arena;\n-  bool                      _complete;\n+  Arena*                   _arena;\n+  bool                     _complete;\n@@ -189,1 +189,1 @@\n-  virtual int find_index(jobject h) {\n+  int find_index(jobject h) {\n@@ -206,1 +206,1 @@\n-  virtual int find_index(Metadata* h) {\n+  int find_index(Metadata* h) {\n@@ -246,0 +246,15 @@\n+\/\/ Class is used to record and retrive external addresses\n+\/\/ for Relocation info in compiled code and stubs.\n+class ExternalsRecorder : public CHeapObj<mtCode> {\n+ private:\n+  Arena  _arena;\n+  ValueRecorder<address> _externals;\n+  static ExternalsRecorder* _recorder;\n+  ExternalsRecorder();\n+ public:\n+  static void initialize();\n+  static int find_index(address adr);\n+  static address at(int index);\n+  static int count();\n+  static void print_statistics() PRODUCT_RETURN;\n+};\n","filename":"src\/hotspot\/share\/code\/oopRecorder.hpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -457,8 +457,2 @@\n-#ifndef _LP64\n-  p = pack_1_int_to(p, (int32_t) (intptr_t)_target);\n-#else\n-  jlong t = (jlong) _target;\n-  int32_t lo = low(t);\n-  int32_t hi = high(t);\n-  p = pack_2_ints_to(p, lo, hi);\n-#endif \/* _LP64 *\/\n+  int index = ExternalsRecorder::find_index(_target);\n+  p = pack_1_int_to(p, index);\n@@ -470,8 +464,2 @@\n-#ifndef _LP64\n-  _target = (address) (intptr_t)unpack_1_int();\n-#else\n-  jint lo, hi;\n-  unpack_2_ints(lo, hi);\n-  jlong t = jlong_from(hi, lo);;\n-  _target = (address) t;\n-#endif \/* _LP64 *\/\n+  int index = unpack_1_int();\n+  _target = ExternalsRecorder::at(index);\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -262,0 +262,12 @@\n+inline uint VtableStubs::unsafe_hash(address entry_point, bool caller_is_c1) {\n+  \/\/ The entrypoint may or may not be a VtableStub. Generate a hash as if it was.\n+  address vtable_stub_addr = entry_point - VtableStub::entry_offset();\n+  assert(CodeCache::contains(vtable_stub_addr), \"assumed to always be the case\");\n+  address vtable_type_addr = vtable_stub_addr + offset_of(VtableStub, _type);\n+  address vtable_index_addr = vtable_stub_addr + offset_of(VtableStub, _index);\n+  bool is_vtable_stub = *vtable_type_addr == static_cast<uint8_t>(VtableStub::Type::vtable_stub);\n+  int vtable_index;\n+  memcpy(&vtable_index, vtable_index_addr, sizeof(vtable_index));\n+  return hash(is_vtable_stub, vtable_index, caller_is_c1);\n+}\n+\n@@ -282,0 +294,4 @@\n+  \/\/ The pc may or may not be the entry point for a VtableStub. Use unsafe_hash\n+  \/\/ to generate the hash that would have been used if it was. The lookup in the\n+  \/\/ _table will only succeed if there is a VtableStub with an entry point at\n+  \/\/ the pc.\n@@ -284,1 +300,1 @@\n-  uint hash = VtableStubs::hash(stub->is_vtable_stub(), stub->index(), stub->caller_is_c1());\n+  uint hash = VtableStubs::unsafe_hash(pc, stub->caller_is_c1());\n@@ -286,2 +302,2 @@\n-  for (s = Atomic::load(&_table[hash]); s != nullptr && s != stub; s = s->next()) {}\n-  return (s == stub) ? s : nullptr;\n+  for (s = Atomic::load(&_table[hash]); s != nullptr && s->entry_point() != pc; s = s->next()) {}\n+  return (s != nullptr && s->entry_point() == pc) ? s : nullptr;\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,1 @@\n+  static inline uint unsafe_hash       (address entry_point, bool caller_is_c1);\n@@ -121,0 +122,6 @@\n+  enum class Type : uint8_t {\n+    itable_stub,\n+    vtable_stub,\n+  };\n+\n+\n@@ -129,1 +136,1 @@\n-  bool           _is_vtable_stub;    \/\/ True if vtable stub, false, is itable stub\n+  Type           _type;              \/\/ Type, either vtable stub or itable stub\n@@ -138,1 +145,1 @@\n-          _is_vtable_stub(is_vtable_stub), _caller_is_c1(caller_is_c1) {}\n+          _type(is_vtable_stub ? Type::vtable_stub : Type::itable_stub), _caller_is_c1(caller_is_c1) {}\n@@ -146,1 +153,1 @@\n-  address code_end() const                       { return code_begin() + VtableStubs::code_size_limit(_is_vtable_stub); }\n+  address code_end() const                       { return code_begin() + VtableStubs::code_size_limit(is_vtable_stub()); }\n@@ -151,1 +158,1 @@\n-    return _index == index && _is_vtable_stub == is_vtable_stub && _caller_is_c1 == caller_is_c1;\n+    return _index == index && this->is_vtable_stub() == is_vtable_stub && _caller_is_c1 == caller_is_c1;\n@@ -177,2 +184,2 @@\n-  bool is_itable_stub()                          { return !_is_vtable_stub; }\n-  bool is_vtable_stub()                          { return  _is_vtable_stub; }\n+  bool is_itable_stub() const                    { return _type == Type::itable_stub; }\n+  bool is_vtable_stub() const                    { return _type == Type::vtable_stub; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-      QuickSort::sort(filtered, num, diff_entries_by_size, false);\n+      QuickSort::sort(filtered, num, diff_entries_by_size);\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-                               : JavaThread(&CompilerThread::thread_entry) {\n+  : JavaThread(&CompilerThread::thread_entry, 0, mtCompiler) {\n@@ -46,3 +46,0 @@\n-  \/\/ Compiler uses resource area for compilation, let's bias it to mtCompiler\n-  resource_area()->bias_to(mtCompiler);\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -414,1 +414,1 @@\n-    void set(kind_t kind, int offset, int size, const OopMap* map = 0, const OopMap* other = 0) {\n+    void set(kind_t kind, int offset, int size, const OopMap* map, const OopMap* other = nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-      \"the alloc region should never be empty\");\n+                      \"the alloc region should never be empty\");\n@@ -109,4 +109,1 @@\n-  assert_alloc_region(alloc_region->used() >= _used_bytes_before, \"invariant\");\n-  size_t allocated_bytes = alloc_region->used() - _used_bytes_before;\n-  retire_region(alloc_region, allocated_bytes);\n-  _used_bytes_before = 0;\n+  retire_region(alloc_region);\n@@ -135,1 +132,0 @@\n-  assert_alloc_region(_used_bytes_before == 0, \"pre-condition\");\n@@ -141,3 +137,3 @@\n-    \/\/ Need to do this before the allocation\n-    _used_bytes_before = new_alloc_region->used();\n-    HeapWord* result = allocate(new_alloc_region, word_size);\n+\n+    assert(new_alloc_region->is_empty(), \"new regions should be empty\");\n+    HeapWord* result = new_alloc_region->allocate(word_size);\n@@ -162,1 +158,1 @@\n-  assert_alloc_region(_alloc_region == nullptr && _used_bytes_before == 0, \"pre-condition\");\n+  assert_alloc_region(_alloc_region == nullptr, \"pre-condition\");\n@@ -171,6 +167,1 @@\n-  \/\/ We explicitly check that the region is not empty to make sure we\n-  \/\/ maintain the \"the alloc region cannot be empty\" invariant.\n-  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"pre-condition\");\n-  assert_alloc_region(_alloc_region == _dummy_region &&\n-                         _used_bytes_before == 0 && _count == 0,\n-                         \"pre-condition\");\n+  assert_alloc_region(_alloc_region == _dummy_region && _count == 0, \"pre-condition\");\n@@ -178,3 +169,1 @@\n-  _used_bytes_before = alloc_region->used();\n-  _alloc_region = alloc_region;\n-  _count += 1;\n+  update_alloc_region(alloc_region);\n@@ -240,1 +229,1 @@\n-                     min_word_size, desired_word_size, actual_word_size, p2i(result));\n+                   min_word_size, desired_word_size, actual_word_size, p2i(result));\n@@ -250,3 +239,1 @@\n-G1AllocRegion::G1AllocRegion(const char* name,\n-                             bool bot_updates,\n-                             uint node_index)\n+G1AllocRegion::G1AllocRegion(const char* name, uint node_index)\n@@ -255,1 +242,0 @@\n-    _used_bytes_before(0),\n@@ -264,3 +250,2 @@\n-void MutatorAllocRegion::retire_region(G1HeapRegion* alloc_region,\n-                                       size_t allocated_bytes) {\n-  _g1h->retire_mutator_alloc_region(alloc_region, allocated_bytes);\n+void MutatorAllocRegion::retire_region(G1HeapRegion* alloc_region) {\n+  _g1h->retire_mutator_alloc_region(alloc_region, alloc_region->used());\n@@ -349,2 +334,3 @@\n-void G1GCAllocRegion::retire_region(G1HeapRegion* alloc_region,\n-                                    size_t allocated_bytes) {\n+void G1GCAllocRegion::retire_region(G1HeapRegion* alloc_region) {\n+  assert(alloc_region->used() >= _used_bytes_before, \"invariant\");\n+  size_t allocated_bytes = alloc_region->used() - _used_bytes_before;\n@@ -352,0 +338,1 @@\n+  _used_bytes_before = 0;\n@@ -363,0 +350,5 @@\n+\n+void G1GCAllocRegion::reuse(G1HeapRegion* alloc_region) {\n+  _used_bytes_before = alloc_region->used();\n+  set(alloc_region);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -66,5 +66,0 @@\n-  \/\/ When we set up a new active region we save its used bytes in this\n-  \/\/ field so that, when we retire it, we can calculate how much space\n-  \/\/ we allocated in it.\n-  size_t _used_bytes_before;\n-\n@@ -97,0 +92,2 @@\n+  void set(G1HeapRegion* alloc_region);\n+\n@@ -100,4 +97,0 @@\n-  \/\/ Perform a non-MT-safe allocation out of the given region.\n-  inline HeapWord* allocate(G1HeapRegion* alloc_region,\n-                            size_t word_size);\n-\n@@ -107,8 +100,0 @@\n-  \/\/ Perform a MT-safe allocation out of the given region, with the given\n-  \/\/ minimum and desired size. Returns the actual size allocated (between\n-  \/\/ minimum and desired size) in actual_word_size if the allocation has been\n-  \/\/ successful.\n-  inline HeapWord* par_allocate(G1HeapRegion* alloc_region,\n-                                size_t min_word_size,\n-                                size_t desired_word_size,\n-                                size_t* actual_word_size);\n@@ -134,2 +119,1 @@\n-  virtual void retire_region(G1HeapRegion* alloc_region,\n-                             size_t allocated_bytes) = 0;\n+  virtual void retire_region(G1HeapRegion* alloc_region) = 0;\n@@ -137,1 +121,1 @@\n-  G1AllocRegion(const char* name, bool bot_updates, uint node_index);\n+  G1AllocRegion(const char* name, uint node_index);\n@@ -176,6 +160,0 @@\n-  \/\/ This can be used to set the active region to a specific\n-  \/\/ region. (Use Example: we try to retain the last old GC alloc\n-  \/\/ region that we've used during a GC and we can use set() to\n-  \/\/ re-instate it at the beginning of the next GC.)\n-  void set(G1HeapRegion* alloc_region);\n-\n@@ -208,4 +186,3 @@\n-  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n-  virtual size_t retire(bool fill_up);\n-\n+  G1HeapRegion* allocate_new_region(size_t word_size) override;\n+  void retire_region(G1HeapRegion* alloc_region) override;\n+  size_t retire(bool fill_up) override;\n@@ -214,1 +191,1 @@\n-    : G1AllocRegion(\"Mutator Alloc Region\", false \/* bot_updates *\/, node_index),\n+    : G1AllocRegion(\"Mutator Alloc Region\", node_index),\n@@ -234,1 +211,1 @@\n-  virtual G1HeapRegion* release();\n+  G1HeapRegion* release() override;\n@@ -236,1 +213,1 @@\n-  virtual void init();\n+  void init() override;\n@@ -241,0 +218,4 @@\n+  \/\/ When we set up a new active region we save its used bytes in this\n+  \/\/ field so that, when we retire it, we can calculate how much space\n+  \/\/ we allocated in it.\n+  size_t _used_bytes_before;\n@@ -245,2 +226,2 @@\n-  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n+  G1HeapRegion* allocate_new_region(size_t word_size) override;\n+  void retire_region(G1HeapRegion* alloc_region) override;\n@@ -248,1 +229,1 @@\n-  virtual size_t retire(bool fill_up);\n+  size_t retire(bool fill_up) override;\n@@ -250,1 +231,1 @@\n-  G1GCAllocRegion(const char* name, bool bot_updates, G1EvacStats* stats,\n+  G1GCAllocRegion(const char* name, G1EvacStats* stats,\n@@ -252,1 +233,1 @@\n-  : G1AllocRegion(name, bot_updates, node_index), _stats(stats), _purpose(purpose) {\n+    : G1AllocRegion(name, node_index), _used_bytes_before(0), _stats(stats), _purpose(purpose) {\n@@ -255,0 +236,5 @@\n+public:\n+  \/\/ This can be used to reuse a specific region. (Use Example: we try to retain the\n+  \/\/ last old GC alloc region that we've used during a GC and we can use reuse() to\n+  \/\/ re-instate it at the beginning of the next GC.)\n+  void reuse(G1HeapRegion* alloc_region);\n@@ -260,1 +246,1 @@\n-  : G1GCAllocRegion(\"Survivor GC Alloc Region\", false \/* bot_updates *\/, stats, G1HeapRegionAttr::Young, node_index) { }\n+  : G1GCAllocRegion(\"Survivor GC Alloc Region\", stats, G1HeapRegionAttr::Young, node_index) { }\n@@ -266,1 +252,1 @@\n-  : G1GCAllocRegion(\"Old GC Alloc Region\", true \/* bot_updates *\/, stats, G1HeapRegionAttr::Old) { }\n+  : G1GCAllocRegion(\"Old GC Alloc Region\", stats, G1HeapRegionAttr::Old) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":26,"deletions":40,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-    assert((p), \"[%s] %s c: %u r: \" PTR_FORMAT \" u: \" SIZE_FORMAT,       \\\n-           _name, (message), _count, p2i(_alloc_region),                 \\\n-           _used_bytes_before);                                          \\\n+    assert((p), \"[%s] %s c: %u r: \" PTR_FORMAT,                          \\\n+           _name, (message), _count, p2i(_alloc_region)                  \\\n+          );                                                             \\\n@@ -44,7 +44,0 @@\n-inline HeapWord* G1AllocRegion::allocate(G1HeapRegion* alloc_region,\n-                                         size_t word_size) {\n-  assert(alloc_region != nullptr, \"pre-condition\");\n-\n-  return alloc_region->allocate(word_size);\n-}\n-\n@@ -52,8 +45,0 @@\n-  size_t temp;\n-  return par_allocate(alloc_region, word_size, word_size, &temp);\n-}\n-\n-inline HeapWord* G1AllocRegion::par_allocate(G1HeapRegion* alloc_region,\n-                                             size_t min_word_size,\n-                                             size_t desired_word_size,\n-                                             size_t* actual_word_size) {\n@@ -62,2 +47,2 @@\n-\n-  return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n+  size_t temp;\n+  return alloc_region->par_allocate(word_size, word_size, &temp);\n@@ -70,1 +55,3 @@\n-  assert_alloc_region(alloc_region != nullptr, \"not initialized properly\");\n+  assert_alloc_region(alloc_region != nullptr && !alloc_region->is_empty(), \"not initialized properly\");\n+\n+  HeapWord* result = alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n@@ -72,1 +59,0 @@\n-  HeapWord* result = par_allocate(alloc_region, min_word_size, desired_word_size, actual_word_size);\n@@ -75,1 +61,2 @@\n-    return result;\n+  } else {\n+    trace(\"alloc failed\", min_word_size, desired_word_size);\n@@ -77,2 +64,1 @@\n-  trace(\"alloc failed\", min_word_size, desired_word_size);\n-  return nullptr;\n+  return result;\n@@ -115,1 +101,1 @@\n-    HeapWord* result = par_allocate(_retained_alloc_region, min_word_size, desired_word_size, actual_word_size);\n+    HeapWord* result = _retained_alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    old->set(retained_region);\n+    old->reuse(retained_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,0 @@\n-\n@@ -131,1 +130,0 @@\n-\n@@ -136,1 +134,1 @@\n-  assert(log2i_exact(HeapRegionBounds::min_size()) == LOG_M, \"inv\");\n+  assert(log2i_exact(G1HeapRegionBounds::min_size()) == LOG_M, \"inv\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,11 @@\n+  static ContainerPtr empty_card_set() {\n+    \/\/ Work around https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=114573\n+    \/\/ gcc issues -Wzero-as-null-pointer-constant here, even though\n+    \/\/ ContainerInlinePtr is a *non-literal* constant 0.  We cast a non-const\n+    \/\/ copy, and let the compiler's constant propagation optimize into\n+    \/\/ equivalent code.\n+    static_assert(G1CardSet::ContainerInlinePtr == 0, \"unnecessary warning dodge\");\n+    auto value = G1CardSet::ContainerInlinePtr;\n+    return reinterpret_cast<ContainerPtr>(value);\n+  }\n+\n@@ -90,1 +101,1 @@\n-  G1CardSetInlinePtr() : _value_addr(nullptr), _value((ContainerPtr)G1CardSet::ContainerInlinePtr) { }\n+  G1CardSetInlinePtr() : G1CardSetInlinePtr(empty_card_set()) {}\n@@ -92,3 +103,2 @@\n-  G1CardSetInlinePtr(ContainerPtr value) : _value_addr(nullptr), _value(value) {\n-    assert(G1CardSet::container_type(_value) == G1CardSet::ContainerInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInlinePtr.\", p2i(_value));\n-  }\n+  explicit G1CardSetInlinePtr(ContainerPtr value) :\n+    G1CardSetInlinePtr(nullptr, value) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  HeapRegionRemSet::invalidate_from_card_cache(start_idx, num_regions);\n+  G1HeapRegionRemSet::invalidate_from_card_cache(start_idx, num_regions);\n@@ -165,1 +165,1 @@\n-                                          HeapRegionType type,\n+                                          G1HeapRegionType type,\n@@ -713,1 +713,1 @@\n-class PostCompactionPrinterClosure: public HeapRegionClosure {\n+class PostCompactionPrinterClosure: public G1HeapRegionClosure {\n@@ -1073,1 +1073,1 @@\n-class OldRegionSetChecker : public HeapRegionSetChecker {\n+class OldRegionSetChecker : public G1HeapRegionSetChecker {\n@@ -1101,1 +1101,1 @@\n-class HumongousRegionSetChecker : public HeapRegionSetChecker {\n+class HumongousRegionSetChecker : public G1HeapRegionSetChecker {\n@@ -1355,1 +1355,1 @@\n-  HeapRegionRemSet::initialize(_reserved);\n+  G1HeapRegionRemSet::initialize(_reserved);\n@@ -1357,1 +1357,1 @@\n-  FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n+  G1FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n@@ -1539,1 +1539,1 @@\n-class SumUsedClosure: public HeapRegionClosure {\n+class SumUsedClosure: public G1HeapRegionClosure {\n@@ -1890,1 +1890,1 @@\n-class IterateObjectClosureRegionClosure: public HeapRegionClosure {\n+class IterateObjectClosureRegionClosure: public G1HeapRegionClosure {\n@@ -1910,1 +1910,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -1926,1 +1926,1 @@\n-void G1CollectedHeap::object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer) {\n+void G1CollectedHeap::object_iterate_parallel(ObjectClosure* cl, uint worker_id, G1HeapRegionClaimer* claimer) {\n@@ -1935,1 +1935,1 @@\n-void G1CollectedHeap::heap_region_iterate(HeapRegionClosure* cl) const {\n+void G1CollectedHeap::heap_region_iterate(G1HeapRegionClosure* cl) const {\n@@ -1939,1 +1939,1 @@\n-void G1CollectedHeap::heap_region_iterate(HeapRegionIndexClosure* cl) const {\n+void G1CollectedHeap::heap_region_iterate(G1HeapRegionIndexClosure* cl) const {\n@@ -1943,2 +1943,2 @@\n-void G1CollectedHeap::heap_region_par_iterate_from_worker_offset(HeapRegionClosure* cl,\n-                                                                 HeapRegionClaimer *hrclaimer,\n+void G1CollectedHeap::heap_region_par_iterate_from_worker_offset(G1HeapRegionClosure* cl,\n+                                                                 G1HeapRegionClaimer *hrclaimer,\n@@ -1949,2 +1949,2 @@\n-void G1CollectedHeap::heap_region_par_iterate_from_start(HeapRegionClosure* cl,\n-                                                         HeapRegionClaimer *hrclaimer) const {\n+void G1CollectedHeap::heap_region_par_iterate_from_start(G1HeapRegionClosure* cl,\n+                                                         G1HeapRegionClaimer *hrclaimer) const {\n@@ -1954,1 +1954,1 @@\n-void G1CollectedHeap::collection_set_iterate_all(HeapRegionClosure* cl) {\n+void G1CollectedHeap::collection_set_iterate_all(G1HeapRegionClosure* cl) {\n@@ -1958,2 +1958,2 @@\n-void G1CollectedHeap::collection_set_par_iterate_all(HeapRegionClosure* cl,\n-                                                     HeapRegionClaimer* hr_claimer,\n+void G1CollectedHeap::collection_set_par_iterate_all(G1HeapRegionClosure* cl,\n+                                                     G1HeapRegionClaimer* hr_claimer,\n@@ -1964,2 +1964,2 @@\n-void G1CollectedHeap::collection_set_iterate_increment_from(HeapRegionClosure *cl,\n-                                                            HeapRegionClaimer* hr_claimer,\n+void G1CollectedHeap::collection_set_iterate_increment_from(G1HeapRegionClosure *cl,\n+                                                            G1HeapRegionClaimer* hr_claimer,\n@@ -1970,2 +1970,2 @@\n-void G1CollectedHeap::par_iterate_regions_array(HeapRegionClosure* cl,\n-                                                HeapRegionClaimer* hr_claimer,\n+void G1CollectedHeap::par_iterate_regions_array(G1HeapRegionClosure* cl,\n+                                                G1HeapRegionClaimer* hr_claimer,\n@@ -2049,1 +2049,1 @@\n-class PrintRegionClosure: public HeapRegionClosure {\n+class G1PrintRegionClosure: public G1HeapRegionClosure {\n@@ -2052,1 +2052,1 @@\n-  PrintRegionClosure(outputStream* st) : _st(st) {}\n+  G1PrintRegionClosure(outputStream* st) : _st(st) {}\n@@ -2124,1 +2124,1 @@\n-  PrintRegionClosure blk(st);\n+  G1PrintRegionClosure blk(st);\n@@ -2284,1 +2284,1 @@\n-  HeapRegionRemSet* rem_set = r->rem_set();\n+  G1HeapRegionRemSet* rem_set = r->rem_set();\n@@ -2291,1 +2291,1 @@\n-  class VerifyRegionAttrRemSet : public HeapRegionClosure {\n+  class VerifyRegionAttrRemSet : public G1HeapRegionClosure {\n@@ -2541,1 +2541,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -2543,1 +2543,1 @@\n-  class UnregisterNMethodsHeapRegionClosure : public HeapRegionClosure {\n+  class UnregisterNMethodsHeapRegionClosure : public G1HeapRegionClosure {\n@@ -2617,1 +2617,1 @@\n-void G1CollectedHeap::free_region(G1HeapRegion* hr, FreeRegionList* free_list) {\n+void G1CollectedHeap::free_region(G1HeapRegion* hr, G1FreeRegionList* free_list) {\n@@ -2639,1 +2639,1 @@\n-                                            FreeRegionList* free_list) {\n+                                            G1FreeRegionList* free_list) {\n@@ -2655,1 +2655,1 @@\n-void G1CollectedHeap::prepend_to_freelist(FreeRegionList* list) {\n+void G1CollectedHeap::prepend_to_freelist(G1FreeRegionList* list) {\n@@ -2681,1 +2681,1 @@\n-class G1AbandonCollectionSetClosure : public HeapRegionClosure {\n+class G1AbandonCollectionSetClosure : public G1HeapRegionClosure {\n@@ -2710,1 +2710,1 @@\n-class NoYoungRegionsClosure: public HeapRegionClosure {\n+class NoYoungRegionsClosure: public G1HeapRegionClosure {\n@@ -2771,1 +2771,1 @@\n-class RebuildRegionSetsClosure : public HeapRegionClosure {\n+class RebuildRegionSetsClosure : public G1HeapRegionClosure {\n@@ -2775,2 +2775,2 @@\n-  HeapRegionSet* _old_set;\n-  HeapRegionSet* _humongous_set;\n+  G1HeapRegionSet* _old_set;\n+  G1HeapRegionSet* _humongous_set;\n@@ -2778,1 +2778,1 @@\n-  HeapRegionManager* _hrm;\n+  G1HeapRegionManager* _hrm;\n@@ -2784,3 +2784,3 @@\n-                           HeapRegionSet* old_set,\n-                           HeapRegionSet* humongous_set,\n-                           HeapRegionManager* hrm) :\n+                           G1HeapRegionSet* old_set,\n+                           G1HeapRegionSet* humongous_set,\n+                           G1HeapRegionManager* hrm) :\n@@ -2852,1 +2852,1 @@\n-                                                HeapRegionType::Eden,\n+                                                G1HeapRegionType::Eden,\n@@ -2898,1 +2898,1 @@\n-  HeapRegionType type;\n+  G1HeapRegionType type;\n@@ -2900,1 +2900,1 @@\n-    type = HeapRegionType::Survivor;\n+    type = G1HeapRegionType::Survivor;\n@@ -2902,1 +2902,1 @@\n-    type = HeapRegionType::Old;\n+    type = G1HeapRegionType::Old;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":47,"deletions":47,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  friend class HeapRegionClaimer;\n+  friend class G1HeapRegionClaimer;\n@@ -183,2 +183,2 @@\n-  HeapRegionSet _old_set;\n-  HeapRegionSet _humongous_set;\n+  G1HeapRegionSet _old_set;\n+  G1HeapRegionSet _humongous_set;\n@@ -215,1 +215,1 @@\n-  HeapRegionManager _hrm;\n+  G1HeapRegionManager _hrm;\n@@ -389,1 +389,1 @@\n-  \/\/ Old, Eden, Humongous, Survivor defined in HeapRegionType.)\n+  \/\/ Old, Eden, Humongous, Survivor defined in G1HeapRegionType.)\n@@ -391,1 +391,1 @@\n-                           HeapRegionType type,\n+                           G1HeapRegionType type,\n@@ -682,1 +682,1 @@\n-  void free_region(G1HeapRegion* hr, FreeRegionList* free_list);\n+  void free_region(G1HeapRegion* hr, G1FreeRegionList* free_list);\n@@ -700,1 +700,1 @@\n-                             FreeRegionList* free_list);\n+                             G1FreeRegionList* free_list);\n@@ -1025,1 +1025,1 @@\n-  void prepend_to_freelist(FreeRegionList* list);\n+  void prepend_to_freelist(G1FreeRegionList* list);\n@@ -1063,1 +1063,1 @@\n-  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer);\n+  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, G1HeapRegionClaimer* claimer);\n@@ -1075,2 +1075,2 @@\n-  void heap_region_iterate(HeapRegionClosure* blk) const;\n-  void heap_region_iterate(HeapRegionIndexClosure* blk) const;\n+  void heap_region_iterate(G1HeapRegionClosure* blk) const;\n+  void heap_region_iterate(G1HeapRegionIndexClosure* blk) const;\n@@ -1094,1 +1094,1 @@\n-  \/\/ compete using the HeapRegionClaimer to claim the regions before\n+  \/\/ compete using the G1HeapRegionClaimer to claim the regions before\n@@ -1096,1 +1096,1 @@\n-  \/\/ The _from_worker_offset version uses the HeapRegionClaimer and\n+  \/\/ The _from_worker_offset version uses the G1HeapRegionClaimer and\n@@ -1099,2 +1099,2 @@\n-  void heap_region_par_iterate_from_worker_offset(HeapRegionClosure* cl,\n-                                                  HeapRegionClaimer* hrclaimer,\n+  void heap_region_par_iterate_from_worker_offset(G1HeapRegionClosure* cl,\n+                                                  G1HeapRegionClaimer* hrclaimer,\n@@ -1103,2 +1103,2 @@\n-  void heap_region_par_iterate_from_start(HeapRegionClosure* cl,\n-                                          HeapRegionClaimer* hrclaimer) const;\n+  void heap_region_par_iterate_from_start(G1HeapRegionClosure* cl,\n+                                          G1HeapRegionClaimer* hrclaimer) const;\n@@ -1107,2 +1107,2 @@\n-  void collection_set_par_iterate_all(HeapRegionClosure* cl,\n-                                      HeapRegionClaimer* hr_claimer,\n+  void collection_set_par_iterate_all(G1HeapRegionClosure* cl,\n+                                      G1HeapRegionClaimer* hr_claimer,\n@@ -1112,1 +1112,1 @@\n-  void collection_set_iterate_all(HeapRegionClosure* blk);\n+  void collection_set_iterate_all(G1HeapRegionClosure* blk);\n@@ -1118,1 +1118,1 @@\n-  \/\/ The variant with the HeapRegionClaimer guarantees that the closure will be\n+  \/\/ The variant with the G1HeapRegionClaimer guarantees that the closure will be\n@@ -1120,1 +1120,1 @@\n-  void collection_set_iterate_increment_from(HeapRegionClosure *blk, uint worker_id) {\n+  void collection_set_iterate_increment_from(G1HeapRegionClosure *blk, uint worker_id) {\n@@ -1123,1 +1123,1 @@\n-  void collection_set_iterate_increment_from(HeapRegionClosure *blk, HeapRegionClaimer* hr_claimer, uint worker_id);\n+  void collection_set_iterate_increment_from(G1HeapRegionClosure *blk, G1HeapRegionClaimer* hr_claimer, uint worker_id);\n@@ -1125,1 +1125,1 @@\n-  \/\/ the given HeapRegionClosure on each region. The worker_id will determine where\n+  \/\/ the given G1HeapRegionClosure on each region. The worker_id will determine where\n@@ -1127,2 +1127,2 @@\n-  void par_iterate_regions_array(HeapRegionClosure* cl,\n-                                 HeapRegionClaimer* hr_claimer,\n+  void par_iterate_regions_array(G1HeapRegionClosure* cl,\n+                                 G1HeapRegionClaimer* hr_claimer,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+  assert(!hr->is_free(), \"looking up obj \" PTR_FORMAT \" in Free region %u\", p2i(obj), hr->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-void G1CollectionSet::iterate(HeapRegionClosure* cl) const {\n+void G1CollectionSet::iterate(G1HeapRegionClosure* cl) const {\n@@ -146,2 +146,2 @@\n-void G1CollectionSet::par_iterate(HeapRegionClosure* cl,\n-                                  HeapRegionClaimer* hr_claimer,\n+void G1CollectionSet::par_iterate(G1HeapRegionClosure* cl,\n+                                  G1HeapRegionClaimer* hr_claimer,\n@@ -152,1 +152,1 @@\n-void G1CollectionSet::iterate_optional(HeapRegionClosure* cl) const {\n+void G1CollectionSet::iterate_optional(G1HeapRegionClosure* cl) const {\n@@ -161,2 +161,2 @@\n-void G1CollectionSet::iterate_incremental_part_from(HeapRegionClosure* cl,\n-                                                    HeapRegionClaimer* hr_claimer,\n+void G1CollectionSet::iterate_incremental_part_from(G1HeapRegionClosure* cl,\n+                                                    G1HeapRegionClaimer* hr_claimer,\n@@ -167,2 +167,2 @@\n-void G1CollectionSet::iterate_part_from(HeapRegionClosure* cl,\n-                                        HeapRegionClaimer* hr_claimer,\n+void G1CollectionSet::iterate_part_from(G1HeapRegionClosure* cl,\n+                                        G1HeapRegionClaimer* hr_claimer,\n@@ -210,1 +210,1 @@\n-class G1VerifyYoungAgesClosure : public HeapRegionClosure {\n+class G1VerifyYoungAgesClosure : public G1HeapRegionClosure {\n@@ -214,1 +214,1 @@\n-  G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }\n+  G1VerifyYoungAgesClosure() : G1HeapRegionClosure(), _valid(true) { }\n@@ -249,1 +249,1 @@\n-class G1PrintCollectionSetDetailClosure : public HeapRegionClosure {\n+class G1PrintCollectionSetDetailClosure : public G1HeapRegionClosure {\n@@ -252,1 +252,1 @@\n-  G1PrintCollectionSetDetailClosure(outputStream* st) : HeapRegionClosure(), _st(st) { }\n+  G1PrintCollectionSetDetailClosure(outputStream* st) : G1HeapRegionClosure(), _st(st) { }\n@@ -386,1 +386,1 @@\n-  QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);\n+  QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx);\n@@ -474,1 +474,1 @@\n-class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {\n+class G1VerifyYoungCSetIndicesClosure : public G1HeapRegionClosure {\n@@ -479,1 +479,1 @@\n-  G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {\n+  G1VerifyYoungCSetIndicesClosure(size_t young_length) : G1HeapRegionClosure(), _young_length(young_length) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-class HeapRegionClaimer;\n-class HeapRegionClosure;\n+class G1HeapRegionClaimer;\n+class G1HeapRegionClosure;\n@@ -200,1 +200,1 @@\n-  \/\/ HeapRegionClosure. The worker_id will determine where in the part to start the iteration\n+  \/\/ G1HeapRegionClosure. The worker_id will determine where in the part to start the iteration\n@@ -202,2 +202,2 @@\n-  void iterate_part_from(HeapRegionClosure* cl,\n-                         HeapRegionClaimer* hr_claimer,\n+  void iterate_part_from(G1HeapRegionClosure* cl,\n+                         G1HeapRegionClaimer* hr_claimer,\n@@ -246,1 +246,1 @@\n-  \/\/ Iterate over the current collection set increment applying the given HeapRegionClosure\n+  \/\/ Iterate over the current collection set increment applying the given G1HeapRegionClosure\n@@ -248,1 +248,1 @@\n-  void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id) const;\n+  void iterate_incremental_part_from(G1HeapRegionClosure* cl, G1HeapRegionClaimer* hr_claimer, uint worker_id) const;\n@@ -256,4 +256,4 @@\n-  \/\/ the given HeapRegionClosure on all of them.\n-  void iterate(HeapRegionClosure* cl) const;\n-  void par_iterate(HeapRegionClosure* cl,\n-                   HeapRegionClaimer* hr_claimer,\n+  \/\/ the given G1HeapRegionClosure on all of them.\n+  void iterate(G1HeapRegionClosure* cl) const;\n+  void par_iterate(G1HeapRegionClosure* cl,\n+                   G1HeapRegionClaimer* hr_claimer,\n@@ -262,1 +262,1 @@\n-  void iterate_optional(HeapRegionClosure* cl) const;\n+  void iterate_optional(G1HeapRegionClosure* cl) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-class HeapRegionClosure;\n+class G1HeapRegionClosure;\n@@ -113,1 +113,1 @@\n-  \/\/ Removes any HeapRegions stored in this list also in the other list. The other\n+  \/\/ Removes any heap regions stored in this list also in the other list. The other\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  class G1BuildCandidateRegionsClosure : public HeapRegionClosure {\n+  class G1BuildCandidateRegionsClosure : public G1HeapRegionClosure {\n@@ -180,1 +180,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-HeapRegionRange::HeapRegionRange(uint start, uint end) :\n+G1HeapRegionRange::G1HeapRegionRange(uint start, uint end) :\n@@ -100,1 +100,1 @@\n-HeapRegionRange G1CommittedRegionMap::next_active_range(uint offset) const {\n+G1HeapRegionRange G1CommittedRegionMap::next_active_range(uint offset) const {\n@@ -105,1 +105,1 @@\n-    return HeapRegionRange(max_length(), max_length());\n+    return G1HeapRegionRange(max_length(), max_length());\n@@ -111,1 +111,1 @@\n-  return HeapRegionRange(start, end);\n+  return G1HeapRegionRange(start, end);\n@@ -114,1 +114,1 @@\n-HeapRegionRange G1CommittedRegionMap::next_committable_range(uint offset) const {\n+G1HeapRegionRange G1CommittedRegionMap::next_committable_range(uint offset) const {\n@@ -122,1 +122,1 @@\n-    return HeapRegionRange(max_length(), max_length());\n+    return G1HeapRegionRange(max_length(), max_length());\n@@ -128,1 +128,1 @@\n-  return HeapRegionRange(start, end);\n+  return G1HeapRegionRange(start, end);\n@@ -131,1 +131,1 @@\n-HeapRegionRange G1CommittedRegionMap::next_inactive_range(uint offset) const {\n+G1HeapRegionRange G1CommittedRegionMap::next_inactive_range(uint offset) const {\n@@ -137,1 +137,1 @@\n-    return HeapRegionRange(max_length(), max_length());\n+    return G1HeapRegionRange(max_length(), max_length());\n@@ -143,1 +143,1 @@\n-  return HeapRegionRange(start, end);\n+  return G1HeapRegionRange(start, end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-class HeapRegionRange : public StackObj {\n+class G1HeapRegionRange : public StackObj {\n@@ -39,1 +39,1 @@\n-  HeapRegionRange(uint start, uint end);\n+  G1HeapRegionRange(uint start, uint end);\n@@ -104,1 +104,1 @@\n-  HeapRegionRange next_active_range(uint offset) const;\n+  G1HeapRegionRange next_active_range(uint offset) const;\n@@ -106,1 +106,1 @@\n-  HeapRegionRange next_inactive_range(uint offset) const;\n+  G1HeapRegionRange next_inactive_range(uint offset) const;\n@@ -110,1 +110,1 @@\n-  HeapRegionRange next_committable_range(uint offset) const;\n+  G1HeapRegionRange next_committable_range(uint offset) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-  class G1ClearBitmapHRClosure : public HeapRegionClosure {\n+  class G1ClearBitmapHRClosure : public G1HeapRegionClosure {\n@@ -718,1 +718,1 @@\n-      HeapRegionClosure(),\n+      G1HeapRegionClosure(),\n@@ -762,1 +762,1 @@\n-  HeapRegionClaimer _hr_claimer;\n+  G1HeapRegionClaimer _hr_claimer;\n@@ -846,1 +846,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -866,1 +866,1 @@\n-class NoteStartOfMarkHRClosure : public HeapRegionClosure {\n+class NoteStartOfMarkHRClosure : public G1HeapRegionClosure {\n@@ -870,1 +870,1 @@\n-  NoteStartOfMarkHRClosure() : HeapRegionClosure(), _cm(G1CollectedHeap::heap()->concurrent_mark()) { }\n+  NoteStartOfMarkHRClosure() : G1HeapRegionClosure(), _cm(G1CollectedHeap::heap()->concurrent_mark()) { }\n@@ -1207,1 +1207,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -1212,1 +1212,1 @@\n-  FreeRegionList _cleanup_list;\n+  G1FreeRegionList _cleanup_list;\n@@ -1214,1 +1214,1 @@\n-  struct G1OnRegionClosure : public HeapRegionClosure {\n+  struct G1OnRegionClosure : public G1HeapRegionClosure {\n@@ -1223,1 +1223,1 @@\n-    FreeRegionList* _local_cleanup_list;\n+    G1FreeRegionList* _local_cleanup_list;\n@@ -1227,1 +1227,1 @@\n-                      FreeRegionList* local_cleanup_list) :\n+                      G1FreeRegionList* local_cleanup_list) :\n@@ -1328,1 +1328,1 @@\n-    FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n+    G1FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n@@ -1355,1 +1355,1 @@\n-class G1UpdateRegionsAfterRebuild : public HeapRegionClosure {\n+class G1UpdateRegionsAfterRebuild : public G1HeapRegionClosure {\n@@ -3081,1 +3081,1 @@\n-  _total_remset_bytes += HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -952,1 +952,1 @@\n-class G1PrintRegionLivenessInfoClosure : public HeapRegionClosure {\n+class G1PrintRegionLivenessInfoClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  HeapRegionClaimer _hr_claimer;\n+  G1HeapRegionClaimer _hr_claimer;\n@@ -70,1 +70,1 @@\n-  class G1RebuildRSAndScrubRegionClosure : public HeapRegionClosure {\n+  class G1RebuildRSAndScrubRegionClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,2 +256,1 @@\n-class G1ConcurrentRefine::RemSetSamplingClosure : public HeapRegionClosure {\n-  G1CollectionSet* _cset;\n+class G1ConcurrentRefine::RemSetSamplingClosure : public G1HeapRegionClosure {\n@@ -262,2 +261,2 @@\n-  explicit RemSetSamplingClosure(G1CollectionSet* cset) :\n-    _cset(cset), _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n+  RemSetSamplingClosure() :\n+    _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n@@ -266,1 +265,1 @@\n-    HeapRegionRemSet* rem_set = r->rem_set();\n+    G1HeapRegionRemSet* rem_set = r->rem_set();\n@@ -290,0 +289,1 @@\n+    RemSetSamplingClosure cl;\n@@ -291,1 +291,0 @@\n-    RemSetSamplingClosure cl{cset};\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -362,2 +362,1 @@\n-                    compare_cards,\n-                    false);\n+                    compare_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-void G1EvacFailureRegions::par_iterate(HeapRegionClosure* closure,\n-                                       HeapRegionClaimer* hrclaimer,\n+void G1EvacFailureRegions::par_iterate(G1HeapRegionClosure* closure,\n+                                       G1HeapRegionClaimer* hrclaimer,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-class HeapRegionClosure;\n-class HeapRegionClaimer;\n+class G1HeapRegionClaimer;\n+class G1HeapRegionClosure;\n@@ -73,2 +73,2 @@\n-  void par_iterate(HeapRegionClosure* closure,\n-                   HeapRegionClaimer* hrclaimer,\n+  void par_iterate(G1HeapRegionClosure* closure,\n+                   G1HeapRegionClaimer* hrclaimer,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-class PrepareRegionsClosure : public HeapRegionClosure {\n+class PrepareRegionsClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-class G1AdjustRegionClosure : public HeapRegionClosure {\n+class G1AdjustRegionClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  HeapRegionClaimer        _hrclaimer;\n+  G1HeapRegionClaimer      _hrclaimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-\/\/ This table is used to store attribute values of all HeapRegions that need\n+\/\/ This table is used to store attribute values of all heap regions that need\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-class G1DetermineCompactionQueueClosure : public HeapRegionClosure {\n+class G1DetermineCompactionQueueClosure : public G1HeapRegionClosure {\n@@ -65,1 +65,1 @@\n-  HeapRegionClaimer _hrclaimer;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -77,1 +77,1 @@\n-  class G1CalculatePointersClosure : public HeapRegionClosure {\n+  class G1CalculatePointersClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -34,1 +34,1 @@\n-  class G1ResetMetadataClosure : public HeapRegionClosure {\n+  class G1ResetMetadataClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  return HeapRegionBounds::max_size();\n+  return G1HeapRegionBounds::max_size();\n@@ -62,1 +62,1 @@\n-  return HeapRegionBounds::min_size() >> LogHeapWordSize;\n+  return G1HeapRegionBounds::min_size() >> LogHeapWordSize;\n@@ -69,3 +69,3 @@\n-    region_size = clamp(max_heap_size \/ HeapRegionBounds::target_number(),\n-                        HeapRegionBounds::min_size(),\n-                        HeapRegionBounds::max_ergonomics_size());\n+    region_size = clamp(max_heap_size \/ G1HeapRegionBounds::target_number(),\n+                        G1HeapRegionBounds::min_size(),\n+                        G1HeapRegionBounds::max_ergonomics_size());\n@@ -79,1 +79,1 @@\n-  region_size = clamp(region_size, HeapRegionBounds::min_size(), HeapRegionBounds::max_size());\n+  region_size = clamp(region_size, G1HeapRegionBounds::min_size(), G1HeapRegionBounds::max_size());\n@@ -250,1 +250,1 @@\n-  _rem_set = new HeapRegionRemSet(this, config);\n+  _rem_set = new G1HeapRegionRemSet(this, config);\n@@ -267,5 +267,5 @@\n-  HeapRegionTracer::send_region_type_change(_hrm_index,\n-                                            get_trace_type(),\n-                                            to,\n-                                            (uintptr_t)bottom(),\n-                                            used());\n+  G1HeapRegionTracer::send_region_type_change(_hrm_index,\n+                                              get_trace_type(),\n+                                              to,\n+                                              (uintptr_t)bottom(),\n+                                              used());\n@@ -380,1 +380,1 @@\n-  HeapRegionRemSet* hrrs = rem_set();\n+  G1HeapRegionRemSet* hrrs = rem_set();\n@@ -550,1 +550,4 @@\n-      return !_is_in_heap || this->_g1h->is_obj_dead_cond(this->_obj, _vo);\n+      return !_is_in_heap ||\n+             \/\/ is_obj_dead* assume that obj is not in a Free region.\n+             this->_g1h->heap_region_containing(this->_obj)->is_free() ||\n+             this->_g1h->is_obj_dead_cond(this->_obj, _vo);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-class HeapRegionRemSet;\n@@ -45,1 +44,2 @@\n-class HeapRegionSetBase;\n+class G1HeapRegionRemSet;\n+class G1HeapRegionSetBase;\n@@ -130,12 +130,0 @@\n-  \/\/ Try to allocate at least min_word_size and up to desired_size from this region.\n-  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n-  \/\/ space allocated.\n-  \/\/ This version assumes that all allocation requests to this G1HeapRegion are properly\n-  \/\/ synchronized.\n-  inline HeapWord* allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-  \/\/ Try to allocate at least min_word_size and up to desired_size from this G1HeapRegion.\n-  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n-  \/\/ space allocated.\n-  \/\/ This version synchronizes with other calls to par_allocate_impl().\n-  inline HeapWord* par_allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-\n@@ -166,0 +154,5 @@\n+\n+  \/\/ Try to allocate at least min_word_size and up to desired_size from this HeapRegion.\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ space allocated.\n+  \/\/ This version synchronizes with other calls to par_allocate().\n@@ -168,0 +161,5 @@\n+  \/\/ Try to allocate at least min_word_size and up to desired_size from this region.\n+  \/\/ Returns null if not possible, otherwise sets actual_word_size to the amount of\n+  \/\/ space allocated.\n+  \/\/ This version assumes that all allocation requests to this HeapRegion are properly\n+  \/\/ synchronized.\n@@ -200,1 +198,1 @@\n-  HeapRegionRemSet* _rem_set;\n+  G1HeapRegionRemSet* _rem_set;\n@@ -205,1 +203,1 @@\n-  HeapRegionType _type;\n+  G1HeapRegionType _type;\n@@ -216,1 +214,1 @@\n-  \/\/ Fields used by the HeapRegionSetBase class and subclasses.\n+  \/\/ Fields used by the G1HeapRegionSetBase class and subclasses.\n@@ -220,1 +218,1 @@\n-  HeapRegionSetBase* _containing_set;\n+  G1HeapRegionSetBase* _containing_set;\n@@ -281,1 +279,1 @@\n-  \/\/ If this region is a member of a HeapRegionManager, the index in that\n+  \/\/ If this region is a member of a G1HeapRegionManager, the index in that\n@@ -423,1 +421,1 @@\n-  void set_rem_set(HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n+  void set_rem_set(G1HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n@@ -425,1 +423,1 @@\n-  HeapRegionRemSet* rem_set() const {\n+  G1HeapRegionRemSet* rem_set() const {\n@@ -433,1 +431,1 @@\n-  \/\/ Methods used by the HeapRegionSetBase class and subclasses.\n+  \/\/ Methods used by the G1HeapRegionSetBase class and subclasses.\n@@ -450,1 +448,1 @@\n-  void set_containing_set(HeapRegionSetBase* containing_set) {\n+  void set_containing_set(G1HeapRegionSetBase* containing_set) {\n@@ -460,1 +458,1 @@\n-  HeapRegionSetBase* containing_set() { return _containing_set; }\n+  G1HeapRegionSetBase* containing_set() { return _containing_set; }\n@@ -462,1 +460,1 @@\n-  void set_containing_set(HeapRegionSetBase* containing_set) { }\n+  void set_containing_set(G1HeapRegionSetBase* containing_set) { }\n@@ -557,1 +555,1 @@\n-\/\/ HeapRegionClosure is used for iterating over regions.\n+\/\/ G1HeapRegionClosure is used for iterating over regions.\n@@ -559,2 +557,2 @@\n-class HeapRegionClosure : public StackObj {\n-  friend class HeapRegionManager;\n+class G1HeapRegionClosure : public StackObj {\n+  friend class G1HeapRegionManager;\n@@ -568,1 +566,1 @@\n-  HeapRegionClosure(): _is_complete(true) {}\n+  G1HeapRegionClosure(): _is_complete(true) {}\n@@ -578,2 +576,2 @@\n-class HeapRegionIndexClosure : public StackObj {\n-  friend class HeapRegionManager;\n+class G1HeapRegionIndexClosure : public StackObj {\n+  friend class G1HeapRegionManager;\n@@ -587,1 +585,1 @@\n-  HeapRegionIndexClosure(): _is_complete(true) {}\n+  G1HeapRegionIndexClosure(): _is_complete(true) {}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":30,"deletions":32,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -45,41 +45,0 @@\n-inline HeapWord* G1HeapRegion::allocate_impl(size_t min_word_size,\n-                                           size_t desired_word_size,\n-                                           size_t* actual_size) {\n-  HeapWord* obj = top();\n-  size_t available = pointer_delta(end(), obj);\n-  size_t want_to_allocate = MIN2(available, desired_word_size);\n-  if (want_to_allocate >= min_word_size) {\n-    HeapWord* new_top = obj + want_to_allocate;\n-    set_top(new_top);\n-    assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n-    *actual_size = want_to_allocate;\n-    return obj;\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-inline HeapWord* G1HeapRegion::par_allocate_impl(size_t min_word_size,\n-                                               size_t desired_word_size,\n-                                               size_t* actual_size) {\n-  do {\n-    HeapWord* obj = top();\n-    size_t available = pointer_delta(end(), obj);\n-    size_t want_to_allocate = MIN2(available, desired_word_size);\n-    if (want_to_allocate >= min_word_size) {\n-      HeapWord* new_top = obj + want_to_allocate;\n-      HeapWord* result = Atomic::cmpxchg(&_top, obj, new_top);\n-      \/\/ result can be one of two:\n-      \/\/  the old top value: the exchange succeeded\n-      \/\/  otherwise: the new value of the top is returned.\n-      if (result == obj) {\n-        assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n-        *actual_size = want_to_allocate;\n-        return obj;\n-      }\n-    } else {\n-      return nullptr;\n-    }\n-  } while (true);\n-}\n-\n@@ -228,3 +187,21 @@\n-                                          size_t desired_word_size,\n-                                          size_t* actual_word_size) {\n-  return par_allocate_impl(min_word_size, desired_word_size, actual_word_size);\n+                                            size_t desired_word_size,\n+                                            size_t* actual_word_size) {\n+  do {\n+    HeapWord* obj = top();\n+    size_t available = pointer_delta(end(), obj);\n+    size_t want_to_allocate = MIN2(available, desired_word_size);\n+    if (want_to_allocate >= min_word_size) {\n+      HeapWord* new_top = obj + want_to_allocate;\n+      HeapWord* result = Atomic::cmpxchg(&_top, obj, new_top);\n+      \/\/ result can be one of two:\n+      \/\/ the old top value: the exchange succeeded\n+      \/\/ otherwise: the new value of the top is returned.\n+      if (result == obj) {\n+        assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n+        *actual_word_size = want_to_allocate;\n+        return obj;\n+      }\n+    } else {\n+      return nullptr;\n+    }\n+  } while (true);\n@@ -239,3 +216,14 @@\n-                                      size_t desired_word_size,\n-                                      size_t* actual_word_size) {\n-  return allocate_impl(min_word_size, desired_word_size, actual_word_size);\n+                                        size_t desired_word_size,\n+                                        size_t* actual_word_size) {\n+  HeapWord* obj = top();\n+  size_t available = pointer_delta(end(), obj);\n+  size_t want_to_allocate = MIN2(available, desired_word_size);\n+  if (want_to_allocate >= min_word_size) {\n+    HeapWord* new_top = obj + want_to_allocate;\n+    set_top(new_top);\n+    assert(is_object_aligned(obj) && is_object_aligned(new_top), \"checking alignment\");\n+    *actual_word_size = want_to_allocate;\n+    return obj;\n+  } else {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":35,"deletions":47,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-class HeapRegionBounds : public AllStatic {\n+class G1HeapRegionBounds : public AllStatic {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionBounds.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-size_t HeapRegionBounds::min_size() {\n+size_t G1HeapRegionBounds::min_size() {\n@@ -34,1 +34,1 @@\n-size_t HeapRegionBounds::max_ergonomics_size() {\n+size_t G1HeapRegionBounds::max_ergonomics_size() {\n@@ -38,1 +38,1 @@\n-size_t HeapRegionBounds::max_size() {\n+size_t G1HeapRegionBounds::max_size() {\n@@ -42,1 +42,1 @@\n-size_t HeapRegionBounds::target_number() {\n+size_t G1HeapRegionBounds::target_number() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionBounds.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-class DumpEventInfoClosure : public HeapRegionClosure {\n+class DumpEventInfoClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionEventSender.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-class MasterFreeRegionListChecker : public HeapRegionSetChecker {\n+class G1MasterFreeRegionListChecker : public G1HeapRegionSetChecker {\n@@ -65,1 +65,1 @@\n-HeapRegionManager::HeapRegionManager() :\n+G1HeapRegionManager::G1HeapRegionManager() :\n@@ -72,1 +72,1 @@\n-  _free_list(\"Free list\", new MasterFreeRegionListChecker())\n+  _free_list(\"Free list\", new G1MasterFreeRegionListChecker())\n@@ -75,4 +75,4 @@\n-void HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,\n-                                   G1RegionToSpaceMapper* bitmap,\n-                                   G1RegionToSpaceMapper* bot,\n-                                   G1RegionToSpaceMapper* cardtable) {\n+void G1HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,\n+                                     G1RegionToSpaceMapper* bitmap,\n+                                     G1RegionToSpaceMapper* bot,\n+                                     G1RegionToSpaceMapper* cardtable) {\n@@ -93,1 +93,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_free_region(HeapRegionType type, uint requested_node_index) {\n+G1HeapRegion* G1HeapRegionManager::allocate_free_region(G1HeapRegionType type, uint requested_node_index) {\n@@ -121,1 +121,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_humongous_from_free_list(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::allocate_humongous_from_free_list(uint num_regions) {\n@@ -129,1 +129,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_humongous_allow_expand(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::allocate_humongous_allow_expand(uint num_regions) {\n@@ -138,1 +138,1 @@\n-G1HeapRegion* HeapRegionManager::allocate_humongous(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::allocate_humongous(uint num_regions) {\n@@ -141,1 +141,1 @@\n-    return allocate_free_region(HeapRegionType::Humongous, G1NUMA::AnyNodeIndex);\n+    return allocate_free_region(G1HeapRegionType::Humongous, G1NUMA::AnyNodeIndex);\n@@ -146,1 +146,1 @@\n-G1HeapRegion* HeapRegionManager::expand_and_allocate_humongous(uint num_regions) {\n+G1HeapRegion* G1HeapRegionManager::expand_and_allocate_humongous(uint num_regions) {\n@@ -151,1 +151,1 @@\n-bool HeapRegionManager::is_free(G1HeapRegion* hr) const {\n+bool G1HeapRegionManager::is_free(G1HeapRegion* hr) const {\n@@ -156,1 +156,1 @@\n-G1HeapRegion* HeapRegionManager::new_heap_region(uint hrm_index) {\n+G1HeapRegion* G1HeapRegionManager::new_heap_region(uint hrm_index) {\n@@ -164,1 +164,1 @@\n-void HeapRegionManager::expand(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+void G1HeapRegionManager::expand(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -179,1 +179,1 @@\n-void HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkerThreads* pretouch_workers) {\n+void G1HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkerThreads* pretouch_workers) {\n@@ -193,1 +193,1 @@\n-void HeapRegionManager::uncommit_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::uncommit_regions(uint start, uint num_regions) {\n@@ -218,1 +218,1 @@\n-void HeapRegionManager::initialize_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::initialize_regions(uint start, uint num_regions) {\n@@ -230,1 +230,1 @@\n-void HeapRegionManager::activate_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::activate_regions(uint start, uint num_regions) {\n@@ -235,1 +235,1 @@\n-void HeapRegionManager::reactivate_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::reactivate_regions(uint start, uint num_regions) {\n@@ -244,1 +244,1 @@\n-void HeapRegionManager::deactivate_regions(uint start, uint num_regions) {\n+void G1HeapRegionManager::deactivate_regions(uint start, uint num_regions) {\n@@ -259,1 +259,1 @@\n-void HeapRegionManager::clear_auxiliary_data_structures(uint start, uint num_regions) {\n+void G1HeapRegionManager::clear_auxiliary_data_structures(uint start, uint num_regions) {\n@@ -268,1 +268,1 @@\n-MemoryUsage HeapRegionManager::get_auxiliary_data_memory_usage() const {\n+MemoryUsage G1HeapRegionManager::get_auxiliary_data_memory_usage() const {\n@@ -282,1 +282,1 @@\n-bool HeapRegionManager::has_inactive_regions() const {\n+bool G1HeapRegionManager::has_inactive_regions() const {\n@@ -286,1 +286,1 @@\n-uint HeapRegionManager::uncommit_inactive_regions(uint limit) {\n+uint G1HeapRegionManager::uncommit_inactive_regions(uint limit) {\n@@ -293,1 +293,1 @@\n-    HeapRegionRange range = _committed_map.next_inactive_range(offset);\n+    G1HeapRegionRange range = _committed_map.next_inactive_range(offset);\n@@ -310,1 +310,1 @@\n-uint HeapRegionManager::expand_inactive(uint num_regions) {\n+uint G1HeapRegionManager::expand_inactive(uint num_regions) {\n@@ -315,1 +315,1 @@\n-    HeapRegionRange regions = _committed_map.next_inactive_range(offset);\n+    G1HeapRegionRange regions = _committed_map.next_inactive_range(offset);\n@@ -330,1 +330,1 @@\n-uint HeapRegionManager::expand_any(uint num_regions, WorkerThreads* pretouch_workers) {\n+uint G1HeapRegionManager::expand_any(uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -337,1 +337,1 @@\n-    HeapRegionRange regions = _committed_map.next_committable_range(offset);\n+    G1HeapRegionRange regions = _committed_map.next_committable_range(offset);\n@@ -352,1 +352,1 @@\n-uint HeapRegionManager::expand_by(uint num_regions, WorkerThreads* pretouch_workers) {\n+uint G1HeapRegionManager::expand_by(uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -368,1 +368,1 @@\n-void HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+void G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -396,1 +396,1 @@\n-uint HeapRegionManager::expand_on_preferred_node(uint preferred_index) {\n+uint G1HeapRegionManager::expand_on_preferred_node(uint preferred_index) {\n@@ -423,1 +423,1 @@\n-bool HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {\n+bool G1HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {\n@@ -429,1 +429,1 @@\n-void HeapRegionManager::assert_contiguous_range(uint start, uint num_regions) {\n+void G1HeapRegionManager::assert_contiguous_range(uint start, uint num_regions) {\n@@ -442,1 +442,1 @@\n-uint HeapRegionManager::find_contiguous_in_range(uint start, uint end, uint num_regions) {\n+uint G1HeapRegionManager::find_contiguous_in_range(uint start, uint end, uint num_regions) {\n@@ -468,1 +468,1 @@\n-uint HeapRegionManager::find_contiguous_in_free_list(uint num_regions) {\n+uint G1HeapRegionManager::find_contiguous_in_free_list(uint num_regions) {\n@@ -470,1 +470,1 @@\n-  HeapRegionRange range(0,0);\n+  G1HeapRegionRange range(0,0);\n@@ -480,1 +480,1 @@\n-uint HeapRegionManager::find_contiguous_allow_expand(uint num_regions) {\n+uint G1HeapRegionManager::find_contiguous_allow_expand(uint num_regions) {\n@@ -489,1 +489,1 @@\n-G1HeapRegion* HeapRegionManager::next_region_in_heap(const G1HeapRegion* r) const {\n+G1HeapRegion* G1HeapRegionManager::next_region_in_heap(const G1HeapRegion* r) const {\n@@ -501,1 +501,1 @@\n-void HeapRegionManager::iterate(HeapRegionClosure* blk) const {\n+void G1HeapRegionManager::iterate(G1HeapRegionClosure* blk) const {\n@@ -517,1 +517,1 @@\n-void HeapRegionManager::iterate(HeapRegionIndexClosure* blk) const {\n+void G1HeapRegionManager::iterate(G1HeapRegionIndexClosure* blk) const {\n@@ -532,1 +532,1 @@\n-uint HeapRegionManager::find_highest_free(bool* expanded) {\n+uint G1HeapRegionManager::find_highest_free(bool* expanded) {\n@@ -554,1 +554,1 @@\n-bool HeapRegionManager::allocate_containing_regions(MemRegion range, size_t* commit_count, WorkerThreads* pretouch_workers) {\n+bool G1HeapRegionManager::allocate_containing_regions(MemRegion range, size_t* commit_count, WorkerThreads* pretouch_workers) {\n@@ -577,1 +577,1 @@\n-void HeapRegionManager::par_iterate(HeapRegionClosure* blk, HeapRegionClaimer* hrclaimer, const uint start_index) const {\n+void G1HeapRegionManager::par_iterate(G1HeapRegionClosure* blk, G1HeapRegionClaimer* hrclaimer, const uint start_index) const {\n@@ -606,1 +606,1 @@\n-uint HeapRegionManager::shrink_by(uint num_regions_to_remove) {\n+uint G1HeapRegionManager::shrink_by(uint num_regions_to_remove) {\n@@ -636,1 +636,1 @@\n-void HeapRegionManager::shrink_at(uint index, size_t num_regions) {\n+void G1HeapRegionManager::shrink_at(uint index, size_t num_regions) {\n@@ -648,1 +648,1 @@\n-uint HeapRegionManager::find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const {\n+uint G1HeapRegionManager::find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const {\n@@ -682,1 +682,1 @@\n-void HeapRegionManager::verify() {\n+void G1HeapRegionManager::verify() {\n@@ -727,1 +727,1 @@\n-void HeapRegionManager::verify_optional() {\n+void G1HeapRegionManager::verify_optional() {\n@@ -732,1 +732,1 @@\n-HeapRegionClaimer::HeapRegionClaimer(uint n_workers) :\n+G1HeapRegionClaimer::G1HeapRegionClaimer(uint n_workers) :\n@@ -739,1 +739,1 @@\n-HeapRegionClaimer::~HeapRegionClaimer() {\n+G1HeapRegionClaimer::~G1HeapRegionClaimer() {\n@@ -743,1 +743,1 @@\n-uint HeapRegionClaimer::offset_for_worker(uint worker_id) const {\n+uint G1HeapRegionClaimer::offset_for_worker(uint worker_id) const {\n@@ -749,1 +749,1 @@\n-bool HeapRegionClaimer::is_region_claimed(uint region_index) const {\n+bool G1HeapRegionClaimer::is_region_claimed(uint region_index) const {\n@@ -754,1 +754,1 @@\n-bool HeapRegionClaimer::claim_region(uint region_index) {\n+bool G1HeapRegionClaimer::claim_region(uint region_index) {\n@@ -761,4 +761,4 @@\n-  HeapRegionManager* _hrm;\n-  FreeRegionList*    _worker_freelists;\n-  uint               _worker_chunk_size;\n-  uint               _num_workers;\n+  G1HeapRegionManager* _hrm;\n+  G1FreeRegionList*    _worker_freelists;\n+  uint                 _worker_chunk_size;\n+  uint                 _num_workers;\n@@ -767,1 +767,1 @@\n-  G1RebuildFreeListTask(HeapRegionManager* hrm, uint num_workers) :\n+  G1RebuildFreeListTask(G1HeapRegionManager* hrm, uint num_workers) :\n@@ -770,1 +770,1 @@\n-      _worker_freelists(NEW_C_HEAP_ARRAY(FreeRegionList, num_workers, mtGC)),\n+      _worker_freelists(NEW_C_HEAP_ARRAY(G1FreeRegionList, num_workers, mtGC)),\n@@ -774,1 +774,1 @@\n-      ::new (&_worker_freelists[worker]) FreeRegionList(\"Appendable Worker Free List\");\n+      ::new (&_worker_freelists[worker]) G1FreeRegionList(\"Appendable Worker Free List\");\n@@ -780,1 +780,1 @@\n-      _worker_freelists[worker].~FreeRegionList();\n+      _worker_freelists[worker].~G1FreeRegionList();\n@@ -782,1 +782,1 @@\n-    FREE_C_HEAP_ARRAY(FreeRegionList, _worker_freelists);\n+    FREE_C_HEAP_ARRAY(G1FreeRegionList, _worker_freelists);\n@@ -785,1 +785,1 @@\n-  FreeRegionList* worker_freelist(uint worker) {\n+  G1FreeRegionList* worker_freelist(uint worker) {\n@@ -803,1 +803,1 @@\n-    FreeRegionList* free_list = worker_freelist(worker_id);\n+    G1FreeRegionList* free_list = worker_freelist(worker_id);\n@@ -818,1 +818,1 @@\n-void HeapRegionManager::rebuild_free_list(WorkerThreads* workers) {\n+void G1HeapRegionManager::rebuild_free_list(WorkerThreads* workers) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,3 @@\n-class HeapRegionClosure;\n-class HeapRegionClaimer;\n-class FreeRegionList;\n+class G1HeapRegionClaimer;\n+class G1HeapRegionClosure;\n+class G1FreeRegionList;\n@@ -52,1 +52,1 @@\n-\/\/ HeapRegions are kept in the _regions array in address order. A region's\n+\/\/ G1HeapRegions are kept in the _regions array in address order. A region's\n@@ -68,1 +68,1 @@\n-\/\/   number of regions+1 for which we have HeapRegions.\n+\/\/   number of regions+1 for which we have G1HeapRegions.\n@@ -73,1 +73,1 @@\n-class HeapRegionManager: public CHeapObj<mtGC> {\n+class G1HeapRegionManager: public CHeapObj<mtGC> {\n@@ -75,1 +75,1 @@\n-  friend class HeapRegionClaimer;\n+  friend class G1HeapRegionClaimer;\n@@ -93,1 +93,1 @@\n-  \/\/ Initialize the HeapRegions in the range and put them on the free list.\n+  \/\/ Initialize the G1HeapRegions in the range and put them on the free list.\n@@ -126,1 +126,1 @@\n-  FreeRegionList _free_list;\n+  G1FreeRegionList _free_list;\n@@ -160,1 +160,1 @@\n-  HeapRegionManager();\n+  G1HeapRegionManager();\n@@ -199,1 +199,1 @@\n-  void insert_list_into_free_list(FreeRegionList* list) {\n+  void insert_list_into_free_list(G1FreeRegionList* list) {\n@@ -204,1 +204,1 @@\n-  G1HeapRegion* allocate_free_region(HeapRegionType type, uint requested_node_index);\n+  G1HeapRegion* allocate_free_region(G1HeapRegionType type, uint requested_node_index);\n@@ -249,1 +249,1 @@\n-  \/\/ HeapRegions, or re-use existing ones. Returns the number of regions the\n+  \/\/ G1HeapRegions, or re-use existing ones. Returns the number of regions the\n@@ -271,2 +271,2 @@\n-  void iterate(HeapRegionClosure* blk) const;\n-  void iterate(HeapRegionIndexClosure* blk) const;\n+  void iterate(G1HeapRegionClosure* blk) const;\n+  void iterate(G1HeapRegionIndexClosure* blk) const;\n@@ -274,1 +274,1 @@\n-  void par_iterate(HeapRegionClosure* blk, HeapRegionClaimer* hrclaimer, const uint start_index) const;\n+  void par_iterate(G1HeapRegionClosure* blk, G1HeapRegionClaimer* hrclaimer, const uint start_index) const;\n@@ -297,1 +297,1 @@\n-\/\/ The HeapRegionClaimer is used during parallel iteration over heap regions,\n+\/\/ The G1HeapRegionClaimer is used during parallel iteration over heap regions,\n@@ -299,1 +299,1 @@\n-class HeapRegionClaimer : public StackObj {\n+class G1HeapRegionClaimer : public StackObj {\n@@ -308,2 +308,2 @@\n-  HeapRegionClaimer(uint n_workers);\n-  ~HeapRegionClaimer();\n+  G1HeapRegionClaimer(uint n_workers);\n+  ~G1HeapRegionClaimer();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-inline bool HeapRegionManager::is_available(uint region) const {\n+inline bool G1HeapRegionManager::is_available(uint region) const {\n@@ -38,1 +38,1 @@\n-inline G1HeapRegion* HeapRegionManager::addr_to_region(HeapWord* addr) const {\n+inline G1HeapRegion* G1HeapRegionManager::addr_to_region(HeapWord* addr) const {\n@@ -46,1 +46,1 @@\n-inline G1HeapRegion* HeapRegionManager::at(uint index) const {\n+inline G1HeapRegion* G1HeapRegionManager::at(uint index) const {\n@@ -54,1 +54,1 @@\n-inline G1HeapRegion* HeapRegionManager::at_or_null(uint index) const {\n+inline G1HeapRegion* G1HeapRegionManager::at_or_null(uint index) const {\n@@ -64,1 +64,1 @@\n-inline G1HeapRegion* HeapRegionManager::next_region_in_humongous(G1HeapRegion* hr) const {\n+inline G1HeapRegion* G1HeapRegionManager::next_region_in_humongous(G1HeapRegion* hr) const {\n@@ -76,1 +76,1 @@\n-inline void HeapRegionManager::insert_into_free_list(G1HeapRegion* hr) {\n+inline void G1HeapRegionManager::insert_into_free_list(G1HeapRegion* hr) {\n@@ -80,1 +80,1 @@\n-inline G1HeapRegion* HeapRegionManager::allocate_free_regions_starting_at(uint first, uint num_regions) {\n+inline G1HeapRegion* G1HeapRegionManager::allocate_free_regions_starting_at(uint first, uint num_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class FreeRegionList;\n+class G1FreeRegionList;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-HeapWord* HeapRegionRemSet::_heap_base_address = nullptr;\n+HeapWord* G1HeapRegionRemSet::_heap_base_address = nullptr;\n@@ -50,2 +50,2 @@\n-const char* HeapRegionRemSet::_state_strings[] =  {\"Untracked\", \"Updating\", \"Complete\"};\n-const char* HeapRegionRemSet::_short_state_strings[] =  {\"UNTRA\", \"UPDAT\", \"CMPLT\"};\n+const char* G1HeapRegionRemSet::_state_strings[] =  {\"Untracked\", \"Updating\", \"Complete\"};\n+const char* G1HeapRegionRemSet::_short_state_strings[] =  {\"UNTRA\", \"UPDAT\", \"CMPLT\"};\n@@ -53,1 +53,1 @@\n-void HeapRegionRemSet::initialize(MemRegion reserved) {\n+void G1HeapRegionRemSet::initialize(MemRegion reserved) {\n@@ -58,1 +58,1 @@\n-HeapRegionRemSet::HeapRegionRemSet(G1HeapRegion* hr,\n+G1HeapRegionRemSet::G1HeapRegionRemSet(G1HeapRegion* hr,\n@@ -66,1 +66,1 @@\n-void HeapRegionRemSet::clear_fcc() {\n+void G1HeapRegionRemSet::clear_fcc() {\n@@ -70,1 +70,1 @@\n-void HeapRegionRemSet::clear(bool only_cardset, bool keep_tracked) {\n+void G1HeapRegionRemSet::clear(bool only_cardset, bool keep_tracked) {\n@@ -84,1 +84,1 @@\n-void HeapRegionRemSet::reset_table_scanner() {\n+void G1HeapRegionRemSet::reset_table_scanner() {\n@@ -89,1 +89,1 @@\n-G1MonotonicArenaMemoryStats HeapRegionRemSet::card_set_memory_stats() const {\n+G1MonotonicArenaMemoryStats G1HeapRegionRemSet::card_set_memory_stats() const {\n@@ -93,2 +93,2 @@\n-void HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n-  out->print_cr(\"  Static structures = \" SIZE_FORMAT, HeapRegionRemSet::static_mem_size());\n+void G1HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n+  out->print_cr(\"  Static structures = \" SIZE_FORMAT, G1HeapRegionRemSet::static_mem_size());\n@@ -104,1 +104,1 @@\n-void HeapRegionRemSet::add_code_root(nmethod* nm) {\n+void G1HeapRegionRemSet::add_code_root(nmethod* nm) {\n@@ -109,1 +109,1 @@\n-void HeapRegionRemSet::remove_code_root(nmethod* nm) {\n+void G1HeapRegionRemSet::remove_code_root(nmethod* nm) {\n@@ -118,1 +118,1 @@\n-void HeapRegionRemSet::bulk_remove_code_roots() {\n+void G1HeapRegionRemSet::bulk_remove_code_roots() {\n@@ -122,1 +122,1 @@\n-void HeapRegionRemSet::code_roots_do(NMethodClosure* blk) const {\n+void G1HeapRegionRemSet::code_roots_do(NMethodClosure* blk) const {\n@@ -126,1 +126,1 @@\n-void HeapRegionRemSet::clean_code_roots(G1HeapRegion* hr) {\n+void G1HeapRegionRemSet::clean_code_roots(G1HeapRegion* hr) {\n@@ -130,1 +130,1 @@\n-size_t HeapRegionRemSet::code_roots_mem_size() {\n+size_t G1HeapRegionRemSet::code_roots_mem_size() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-class HeapRegionRemSet : public CHeapObj<mtGC> {\n+class G1HeapRegionRemSet : public CHeapObj<mtGC> {\n@@ -60,1 +60,1 @@\n-  HeapRegionRemSet(G1HeapRegion* hr, G1CardSetConfiguration* config);\n+  G1HeapRegionRemSet(G1HeapRegion* hr, G1CardSetConfiguration* config);\n@@ -129,1 +129,1 @@\n-           + (sizeof(HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n+           + (sizeof(G1HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-void HeapRegionRemSet::set_state_untracked() {\n+void G1HeapRegionRemSet::set_state_untracked() {\n@@ -46,1 +46,1 @@\n-void HeapRegionRemSet::set_state_updating() {\n+void G1HeapRegionRemSet::set_state_updating() {\n@@ -53,1 +53,1 @@\n-void HeapRegionRemSet::set_state_complete() {\n+void G1HeapRegionRemSet::set_state_complete() {\n@@ -110,1 +110,1 @@\n-inline void HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+inline void G1HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n@@ -119,1 +119,1 @@\n-uintptr_t HeapRegionRemSet::to_card(OopOrNarrowOopStar from) const {\n+uintptr_t G1HeapRegionRemSet::to_card(OopOrNarrowOopStar from) const {\n@@ -123,1 +123,1 @@\n-void HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n+void G1HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n@@ -139,1 +139,1 @@\n-bool HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n+bool G1HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n@@ -143,1 +143,1 @@\n-void HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n+void G1HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-uint FreeRegionList::_unrealistically_long_length = 0;\n+uint G1FreeRegionList::_unrealistically_long_length = 0;\n@@ -34,1 +34,1 @@\n-void HeapRegionSetBase::verify_region(G1HeapRegion* hr) {\n+void G1HeapRegionSetBase::verify_region(G1HeapRegion* hr) {\n@@ -44,1 +44,1 @@\n-void HeapRegionSetBase::verify() {\n+void G1HeapRegionSetBase::verify() {\n@@ -56,1 +56,1 @@\n-void HeapRegionSetBase::verify_start() {\n+void G1HeapRegionSetBase::verify_start() {\n@@ -62,1 +62,1 @@\n-  HeapRegionSetBase::verify();\n+  G1HeapRegionSetBase::verify();\n@@ -67,1 +67,1 @@\n-void HeapRegionSetBase::verify_end() {\n+void G1HeapRegionSetBase::verify_end() {\n@@ -75,1 +75,1 @@\n-void HeapRegionSetBase::print_on(outputStream* out, bool print_contents) {\n+void G1HeapRegionSetBase::print_on(outputStream* out, bool print_contents) {\n@@ -82,1 +82,1 @@\n-HeapRegionSetBase::HeapRegionSetBase(const char* name, HeapRegionSetChecker* checker)\n+G1HeapRegionSetBase::G1HeapRegionSetBase(const char* name, G1HeapRegionSetChecker* checker)\n@@ -87,1 +87,1 @@\n-void FreeRegionList::set_unrealistically_long_length(uint len) {\n+void G1FreeRegionList::set_unrealistically_long_length(uint len) {\n@@ -92,1 +92,1 @@\n-void FreeRegionList::abandon() {\n+void G1FreeRegionList::abandon() {\n@@ -98,1 +98,1 @@\n-void FreeRegionList::remove_all() {\n+void G1FreeRegionList::remove_all() {\n@@ -120,1 +120,1 @@\n-void FreeRegionList::add_list_common_start(FreeRegionList* from_list) {\n+void G1FreeRegionList::add_list_common_start(G1FreeRegionList* from_list) {\n@@ -135,1 +135,1 @@\n-  FreeRegionListIterator iter(from_list);\n+  G1FreeRegionListIterator iter(from_list);\n@@ -147,1 +147,1 @@\n-void FreeRegionList::add_list_common_end(FreeRegionList* from_list) {\n+void G1FreeRegionList::add_list_common_end(G1FreeRegionList* from_list) {\n@@ -155,1 +155,1 @@\n-void FreeRegionList::append_ordered(FreeRegionList* from_list) {\n+void G1FreeRegionList::append_ordered(G1FreeRegionList* from_list) {\n@@ -180,1 +180,1 @@\n-void FreeRegionList::add_ordered(FreeRegionList* from_list) {\n+void G1FreeRegionList::add_ordered(G1FreeRegionList* from_list) {\n@@ -230,1 +230,1 @@\n-void FreeRegionList::verify_region_to_remove(G1HeapRegion* curr, G1HeapRegion* next) {\n+void G1FreeRegionList::verify_region_to_remove(G1HeapRegion* curr, G1HeapRegion* next) {\n@@ -247,1 +247,1 @@\n-void FreeRegionList::remove_starting_at(G1HeapRegion* first, uint num_regions) {\n+void G1FreeRegionList::remove_starting_at(G1HeapRegion* first, uint num_regions) {\n@@ -307,2 +307,2 @@\n-void FreeRegionList::verify() {\n-  \/\/ See comment in HeapRegionSetBase::verify() about MT safety and\n+void G1FreeRegionList::verify() {\n+  \/\/ See comment in G1HeapRegionSetBase::verify() about MT safety and\n@@ -320,1 +320,1 @@\n-void FreeRegionList::clear() {\n+void G1FreeRegionList::clear() {\n@@ -331,1 +331,1 @@\n-void FreeRegionList::verify_list() {\n+void G1FreeRegionList::verify_list() {\n@@ -367,2 +367,2 @@\n-FreeRegionList::FreeRegionList(const char* name, HeapRegionSetChecker* checker):\n-  HeapRegionSetBase(name, checker),\n+G1FreeRegionList::G1FreeRegionList(const char* name, G1HeapRegionSetChecker* checker):\n+  G1HeapRegionSetBase(name, checker),\n@@ -374,1 +374,1 @@\n-FreeRegionList::~FreeRegionList() {\n+G1FreeRegionList::~G1FreeRegionList() {\n@@ -380,2 +380,2 @@\n-FreeRegionList::NodeInfo::NodeInfo() : _numa(G1NUMA::numa()), _length_of_node(nullptr),\n-                                       _num_nodes(_numa->num_active_nodes()) {\n+G1FreeRegionList::NodeInfo::NodeInfo() : _numa(G1NUMA::numa()), _length_of_node(nullptr),\n+                                         _num_nodes(_numa->num_active_nodes()) {\n@@ -387,1 +387,1 @@\n-FreeRegionList::NodeInfo::~NodeInfo() {\n+G1FreeRegionList::NodeInfo::~NodeInfo() {\n@@ -391,1 +391,1 @@\n-void FreeRegionList::NodeInfo::clear() {\n+void G1FreeRegionList::NodeInfo::clear() {\n@@ -397,1 +397,1 @@\n-void FreeRegionList::NodeInfo::add(NodeInfo* info) {\n+void G1FreeRegionList::NodeInfo::add(NodeInfo* info) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-\/\/ HeapRegionSets.\n-class HeapRegionSetChecker : public CHeapObj<mtGC> {\n+\/\/ G1HeapRegionSets.\n+class G1HeapRegionSetChecker : public CHeapObj<mtGC> {\n@@ -54,1 +54,1 @@\n-  \/\/ Verify MT safety for this HeapRegionSet.\n+  \/\/ Verify MT safety for this G1HeapRegionSet.\n@@ -56,1 +56,1 @@\n-  \/\/ Returns true if the given G1HeapRegion is of the correct type for this HeapRegionSet.\n+  \/\/ Returns true if the given G1HeapRegion is of the correct type for this G1HeapRegionSet.\n@@ -58,1 +58,1 @@\n-  \/\/ Return a description of the type of regions this HeapRegionSet contains.\n+  \/\/ Return a description of the type of regions this G1HeapRegionSet contains.\n@@ -67,1 +67,1 @@\n-class HeapRegionSetBase {\n+class G1HeapRegionSetBase {\n@@ -70,1 +70,1 @@\n-  HeapRegionSetChecker* _checker;\n+  G1HeapRegionSetChecker* _checker;\n@@ -90,1 +90,1 @@\n-  HeapRegionSetBase(const char* name, HeapRegionSetChecker* verifier);\n+  G1HeapRegionSetBase(const char* name, G1HeapRegionSetChecker* verifier);\n@@ -120,1 +120,1 @@\n-\/\/ the same interface (namely, the HeapRegionSetBase API).\n+\/\/ the same interface (namely, the G1HeapRegionSetBase API).\n@@ -122,1 +122,1 @@\n-class HeapRegionSet : public HeapRegionSetBase {\n+class G1HeapRegionSet : public G1HeapRegionSetBase {\n@@ -124,2 +124,2 @@\n-  HeapRegionSet(const char* name, HeapRegionSetChecker* checker):\n-    HeapRegionSetBase(name, checker) {\n+  G1HeapRegionSet(const char* name, G1HeapRegionSetChecker* checker):\n+    G1HeapRegionSetBase(name, checker) {\n@@ -138,1 +138,1 @@\n-class FreeRegionListIterator;\n+class G1FreeRegionListIterator;\n@@ -141,2 +141,2 @@\n-class FreeRegionList : public HeapRegionSetBase {\n-  friend class FreeRegionListIterator;\n+class G1FreeRegionList : public G1HeapRegionSetBase {\n+  friend class G1FreeRegionListIterator;\n@@ -184,2 +184,2 @@\n-  void add_list_common_start(FreeRegionList* from_list);\n-  void add_list_common_end(FreeRegionList* from_list);\n+  void add_list_common_start(G1FreeRegionList* from_list);\n+  void add_list_common_end(G1FreeRegionList* from_list);\n@@ -189,1 +189,1 @@\n-  \/\/ See the comment for HeapRegionSetBase::clear()\n+  \/\/ See the comment for G1HeapRegionSetBase::clear()\n@@ -193,2 +193,2 @@\n-  FreeRegionList(const char* name, HeapRegionSetChecker* checker = nullptr);\n-  ~FreeRegionList();\n+  G1FreeRegionList(const char* name, G1HeapRegionSetChecker* checker = nullptr);\n+  ~G1FreeRegionList();\n@@ -221,2 +221,2 @@\n-  void add_ordered(FreeRegionList* from_list);\n-  void append_ordered(FreeRegionList* from_list);\n+  void add_ordered(G1FreeRegionList* from_list);\n+  void append_ordered(G1FreeRegionList* from_list);\n@@ -238,1 +238,1 @@\n-  using HeapRegionSetBase::length;\n+  using G1HeapRegionSetBase::length;\n@@ -245,1 +245,1 @@\n-class FreeRegionListIterator : public StackObj {\n+class G1FreeRegionListIterator : public StackObj {\n@@ -247,1 +247,1 @@\n-  FreeRegionList* _list;\n+  G1FreeRegionList* _list;\n@@ -268,1 +268,1 @@\n-  FreeRegionListIterator(FreeRegionList* list)\n+  G1FreeRegionListIterator(G1FreeRegionList* list)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-inline void HeapRegionSetBase::add(G1HeapRegion* hr) {\n+inline void G1HeapRegionSetBase::add(G1HeapRegion* hr) {\n@@ -43,1 +43,1 @@\n-inline void HeapRegionSetBase::remove(G1HeapRegion* hr) {\n+inline void G1HeapRegionSetBase::remove(G1HeapRegion* hr) {\n@@ -54,1 +54,1 @@\n-inline void FreeRegionList::add_to_tail(G1HeapRegion* region_to_add) {\n+inline void G1FreeRegionList::add_to_tail(G1HeapRegion* region_to_add) {\n@@ -74,1 +74,1 @@\n-inline void FreeRegionList::add_ordered(G1HeapRegion* hr) {\n+inline void G1FreeRegionList::add_ordered(G1HeapRegion* hr) {\n@@ -123,1 +123,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_from_head_impl() {\n+inline G1HeapRegion* G1FreeRegionList::remove_from_head_impl() {\n@@ -135,1 +135,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_from_tail_impl() {\n+inline G1HeapRegion* G1FreeRegionList::remove_from_tail_impl() {\n@@ -148,1 +148,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_region(bool from_head) {\n+inline G1HeapRegion* G1FreeRegionList::remove_region(bool from_head) {\n@@ -177,1 +177,1 @@\n-inline G1HeapRegion* FreeRegionList::remove_region_with_node_index(bool from_head,\n+inline G1HeapRegion* G1FreeRegionList::remove_region_with_node_index(bool from_head,\n@@ -235,1 +235,1 @@\n-inline void FreeRegionList::NodeInfo::increase_length(uint node_index) {\n+inline void G1FreeRegionList::NodeInfo::increase_length(uint node_index) {\n@@ -241,1 +241,1 @@\n-inline void FreeRegionList::NodeInfo::decrease_length(uint node_index) {\n+inline void G1FreeRegionList::NodeInfo::decrease_length(uint node_index) {\n@@ -250,1 +250,1 @@\n-inline uint FreeRegionList::NodeInfo::length(uint node_index) const {\n+inline uint G1FreeRegionList::NodeInfo::length(uint node_index) const {\n@@ -254,1 +254,1 @@\n-inline void FreeRegionList::increase_length(uint node_index) {\n+inline void G1FreeRegionList::increase_length(uint node_index) {\n@@ -260,1 +260,1 @@\n-inline void FreeRegionList::decrease_length(uint node_index) {\n+inline void G1FreeRegionList::decrease_length(uint node_index) {\n@@ -266,1 +266,1 @@\n-inline uint FreeRegionList::length(uint node_index) const {\n+inline uint G1FreeRegionList::length(uint node_index) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-void HeapRegionTracer::send_region_type_change(uint index,\n+void G1HeapRegionTracer::send_region_type_change(uint index,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-class HeapRegionTracer : AllStatic {\n+class G1HeapRegionTracer : AllStatic {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionTracer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,4 @@\n-const HeapRegionType HeapRegionType::Eden      = HeapRegionType(EdenTag);\n-const HeapRegionType HeapRegionType::Survivor  = HeapRegionType(SurvTag);\n-const HeapRegionType HeapRegionType::Old       = HeapRegionType(OldTag);\n-const HeapRegionType HeapRegionType::Humongous = HeapRegionType(StartsHumongousTag);\n+const G1HeapRegionType G1HeapRegionType::Eden      = G1HeapRegionType(EdenTag);\n+const G1HeapRegionType G1HeapRegionType::Survivor  = G1HeapRegionType(SurvTag);\n+const G1HeapRegionType G1HeapRegionType::Old       = G1HeapRegionType(OldTag);\n+const G1HeapRegionType G1HeapRegionType::Humongous = G1HeapRegionType(StartsHumongousTag);\n@@ -34,1 +34,1 @@\n-bool HeapRegionType::is_valid(Tag tag) {\n+bool G1HeapRegionType::is_valid(Tag tag) {\n@@ -48,1 +48,1 @@\n-const char* HeapRegionType::get_str() const {\n+const char* G1HeapRegionType::get_str() const {\n@@ -63,1 +63,1 @@\n-const char* HeapRegionType::get_short_str() const {\n+const char* G1HeapRegionType::get_short_str() const {\n@@ -78,1 +78,1 @@\n-G1HeapRegionTraceType::Type HeapRegionType::get_trace_type() {\n+G1HeapRegionTraceType::Type G1HeapRegionType::get_trace_type() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionType.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-class HeapRegionType {\n+class G1HeapRegionType {\n@@ -104,1 +104,1 @@\n-  HeapRegionType(Tag t) : _tag(t) { hrt_assert_is_valid(_tag); }\n+  G1HeapRegionType(Tag t) : _tag(t) { hrt_assert_is_valid(_tag); }\n@@ -162,1 +162,1 @@\n-  HeapRegionType() : _tag(FreeTag) { hrt_assert_is_valid(_tag); }\n+  G1HeapRegionType() : _tag(FreeTag) { hrt_assert_is_valid(_tag); }\n@@ -164,4 +164,4 @@\n-  static const HeapRegionType Eden;\n-  static const HeapRegionType Survivor;\n-  static const HeapRegionType Old;\n-  static const HeapRegionType Humongous;\n+  static const G1HeapRegionType Eden;\n+  static const G1HeapRegionType Survivor;\n+  static const G1HeapRegionType Old;\n+  static const G1HeapRegionType Humongous;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionType.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-class G1HeapTransition::DetailedUsageClosure: public HeapRegionClosure {\n+class G1HeapTransition::DetailedUsageClosure: public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-      HeapRegionRemSet* hrrs = hr->rem_set();\n+      G1HeapRegionRemSet* hrrs = hr->rem_set();\n@@ -234,1 +234,1 @@\n-class VerifyRegionClosure: public HeapRegionClosure {\n+class VerifyRegionClosure: public G1HeapRegionClosure {\n@@ -290,4 +290,4 @@\n-  G1CollectedHeap*  _g1h;\n-  VerifyOption      _vo;\n-  bool              _failures;\n-  HeapRegionClaimer _hrclaimer;\n+  G1CollectedHeap*    _g1h;\n+  VerifyOption        _vo;\n+  bool                _failures;\n+  G1HeapRegionClaimer _hrclaimer;\n@@ -380,1 +380,1 @@\n-class VerifyRegionListsClosure : public HeapRegionClosure {\n+class VerifyRegionListsClosure : public G1HeapRegionClosure {\n@@ -382,3 +382,3 @@\n-  HeapRegionSet*   _old_set;\n-  HeapRegionSet*   _humongous_set;\n-  HeapRegionManager* _hrm;\n+  G1HeapRegionSet*     _old_set;\n+  G1HeapRegionSet*     _humongous_set;\n+  G1HeapRegionManager* _hrm;\n@@ -391,3 +391,3 @@\n-  VerifyRegionListsClosure(HeapRegionSet* old_set,\n-                           HeapRegionSet* humongous_set,\n-                           HeapRegionManager* hrm) :\n+  VerifyRegionListsClosure(G1HeapRegionSet* old_set,\n+                           G1HeapRegionSet* humongous_set,\n+                           G1HeapRegionManager* hrm) :\n@@ -415,1 +415,1 @@\n-  void verify_counts(HeapRegionSet* old_set, HeapRegionSet* humongous_set, HeapRegionManager* free_list) {\n+  void verify_counts(G1HeapRegionSet* old_set, G1HeapRegionSet* humongous_set, G1HeapRegionManager* free_list) {\n@@ -438,1 +438,1 @@\n-class G1VerifyRegionMarkingStateClosure : public HeapRegionClosure {\n+class G1VerifyRegionMarkingStateClosure : public G1HeapRegionClosure {\n@@ -538,1 +538,1 @@\n-  class G1VerifyBitmapClear : public HeapRegionClosure {\n+  class G1VerifyBitmapClear : public G1HeapRegionClosure {\n@@ -560,1 +560,1 @@\n-class G1VerifyCardTableCleanup: public HeapRegionClosure {\n+class G1VerifyCardTableCleanup: public G1HeapRegionClosure {\n@@ -606,1 +606,1 @@\n-class G1VerifyDirtyYoungListClosure : public HeapRegionClosure {\n+class G1VerifyDirtyYoungListClosure : public G1HeapRegionClosure {\n@@ -610,1 +610,1 @@\n-  G1VerifyDirtyYoungListClosure(G1HeapVerifier* verifier) : HeapRegionClosure(), _verifier(verifier) { }\n+  G1VerifyDirtyYoungListClosure(G1HeapVerifier* verifier) : G1HeapRegionClosure(), _verifier(verifier) { }\n@@ -622,1 +622,1 @@\n-class G1CheckRegionAttrTableClosure : public HeapRegionClosure {\n+class G1CheckRegionAttrTableClosure : public G1HeapRegionClosure {\n@@ -627,1 +627,1 @@\n-  G1CheckRegionAttrTableClosure() : HeapRegionClosure(), _failures(false) { }\n+  G1CheckRegionAttrTableClosure() : G1HeapRegionClosure(), _failures(false) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,1 @@\n-  \/\/ There would be some cases that 1 page may be consisted of multiple HeapRegions.\n+  \/\/ There would be some cases that 1 page may be consisted of multiple heap regions.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  \/\/ This assumes that HeapRegions are evenly spit, so we can decide preferred index\n+  \/\/ This assumes that heap regions are evenly spit, so we can decide preferred index\n@@ -130,1 +130,1 @@\n-class G1NodeIndexCheckClosure : public HeapRegionClosure {\n+class G1NodeIndexCheckClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-  HeapRegionRemSet* to_rem_set = _g1h->heap_region_containing(obj)->rem_set();\n+  G1HeapRegionRemSet* to_rem_set = _g1h->heap_region_containing(obj)->rem_set();\n@@ -269,1 +269,1 @@\n-  HeapRegionRemSet* rem_set = to->rem_set();\n+  G1HeapRegionRemSet* rem_set = to->rem_set();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-  void iterate_dirty_regions_from(HeapRegionClosure* cl, uint worker_id) {\n+  void iterate_dirty_regions_from(G1HeapRegionClosure* cl, uint worker_id) {\n@@ -484,1 +484,1 @@\n-class G1ScanHRForRegionClosure : public HeapRegionClosure {\n+class G1ScanHRForRegionClosure : public G1HeapRegionClosure {\n@@ -758,1 +758,1 @@\n-class G1ScanCollectionSetRegionClosure : public HeapRegionClosure {\n+class G1ScanCollectionSetRegionClosure : public G1HeapRegionClosure {\n@@ -975,1 +975,1 @@\n-  \/\/ table. This is in addition to being the HeapRegionClosure to iterate over\n+  \/\/ table. This is in addition to being the HG1eapRegionClosure to iterate over\n@@ -981,1 +981,1 @@\n-  class G1MergeCardSetClosure : public HeapRegionClosure {\n+  class G1MergeCardSetClosure : public G1HeapRegionClosure {\n@@ -1077,1 +1077,1 @@\n-      HeapRegionRemSet* rem_set = r->rem_set();\n+      G1HeapRegionRemSet* rem_set = r->rem_set();\n@@ -1101,1 +1101,1 @@\n-  class G1ClearBitmapClosure : public HeapRegionClosure {\n+  class G1ClearBitmapClosure : public G1HeapRegionClosure {\n@@ -1147,3 +1147,3 @@\n-  class G1CombinedClosure : public HeapRegionClosure {\n-    HeapRegionClosure* _closure1;\n-    HeapRegionClosure* _closure2;\n+  class G1CombinedClosure : public G1HeapRegionClosure {\n+    G1HeapRegionClosure* _closure1;\n+    G1HeapRegionClosure* _closure2;\n@@ -1151,1 +1151,1 @@\n-    G1CombinedClosure(HeapRegionClosure* cl1, HeapRegionClosure* cl2) :\n+    G1CombinedClosure(G1HeapRegionClosure* cl1, G1HeapRegionClosure* cl2) :\n@@ -1163,1 +1163,1 @@\n-  class G1FlushHumongousCandidateRemSets : public HeapRegionIndexClosure {\n+  class G1FlushHumongousCandidateRemSets : public G1HeapRegionIndexClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+class G1HeapRegionClaimer;\n@@ -52,1 +53,0 @@\n-class HeapRegionClaimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-class HRRSStatsIter: public HeapRegionClosure {\n+class HRRSStatsIter: public G1HeapRegionClosure {\n@@ -219,1 +219,1 @@\n-    HeapRegionRemSet* hrrs = r->rem_set();\n+    G1HeapRegionRemSet* hrrs = r->rem_set();\n@@ -221,1 +221,1 @@\n-    \/\/ HeapRegionRemSet::mem_size() includes the\n+    \/\/ G1HeapRegionRemSet::mem_size() includes the\n@@ -277,1 +277,1 @@\n-    HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n+    G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n@@ -284,1 +284,1 @@\n-    HeapRegionRemSet::print_static_mem_size(out);\n+    G1HeapRegionRemSet::print_static_mem_size(out);\n@@ -289,1 +289,1 @@\n-    HeapRegionRemSet* max_code_root_rem_set = max_code_root_mem_sz_region()->rem_set();\n+    G1HeapRegionRemSet* max_code_root_rem_set = max_code_root_mem_sz_region()->rem_set();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-class G1PrintCollectionSetClosure : public HeapRegionClosure {\n+class G1PrintCollectionSetClosure : public G1HeapRegionClosure {\n@@ -289,1 +289,1 @@\n-  class G1PrepareRegionsClosure : public HeapRegionClosure {\n+  class G1PrepareRegionsClosure : public G1HeapRegionClosure {\n@@ -421,1 +421,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class SelectAllocationFailureRegionClosure : public HeapRegionClosure {\n+class SelectAllocationFailureRegionClosure : public G1HeapRegionClosure {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -336,1 +336,1 @@\n-class G1FreeHumongousRegionClosure : public HeapRegionIndexClosure {\n+class G1FreeHumongousRegionClosure : public G1HeapRegionIndexClosure {\n@@ -540,1 +540,1 @@\n-  HeapRegionClaimer _claimer;\n+  G1HeapRegionClaimer _claimer;\n@@ -542,1 +542,1 @@\n-  class ProcessEvacuationFailedRegionsClosure : public HeapRegionClosure {\n+  class ProcessEvacuationFailedRegionsClosure : public G1HeapRegionClosure {\n@@ -709,1 +709,1 @@\n-class FreeCSetClosure : public HeapRegionClosure {\n+class FreeCSetClosure : public G1HeapRegionClosure {\n@@ -810,1 +810,1 @@\n-      HeapRegionClosure(),\n+      G1HeapRegionClosure(),\n@@ -856,6 +856,6 @@\n-  G1CollectedHeap*  _g1h;\n-  G1EvacInfo*       _evacuation_info;\n-  FreeCSetStats*    _worker_stats;\n-  HeapRegionClaimer _claimer;\n-  const size_t*     _surviving_young_words;\n-  uint              _active_workers;\n+  G1CollectedHeap*    _g1h;\n+  G1EvacInfo*         _evacuation_info;\n+  FreeCSetStats*      _worker_stats;\n+  G1HeapRegionClaimer _claimer;\n+  const size_t*       _surviving_young_words;\n+  uint                _active_workers;\n@@ -863,1 +863,1 @@\n-  volatile uint     _num_retained_regions;\n+  volatile uint       _num_retained_regions;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-  if (FLAG_IS_CMDLINE(G1HeapRegionSize) && (value < HeapRegionBounds::min_size())) {\n+  if (FLAG_IS_CMDLINE(G1HeapRegionSize) && (value < G1HeapRegionBounds::min_size())) {\n@@ -183,1 +183,1 @@\n-  return HeapRegionBounds::max_size();\n+  return G1HeapRegionBounds::max_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  nonstatic_field(G1HeapRegion, _type,           HeapRegionType)              \\\n+  nonstatic_field(G1HeapRegion, _type,           G1HeapRegionType)            \\\n@@ -46,1 +46,1 @@\n-  nonstatic_field(HeapRegionType, _tag,       HeapRegionType::Tag volatile)   \\\n+  nonstatic_field(G1HeapRegionType, _tag,   G1HeapRegionType::Tag volatile)   \\\n@@ -55,1 +55,1 @@\n-  nonstatic_field(HeapRegionManager, _regions,          G1HeapRegionTable)    \\\n+  nonstatic_field(G1HeapRegionManager, _regions,        G1HeapRegionTable)    \\\n@@ -58,1 +58,1 @@\n-  nonstatic_field(G1CollectedHeap, _hrm,                HeapRegionManager)    \\\n+  nonstatic_field(G1CollectedHeap, _hrm,                G1HeapRegionManager)  \\\n@@ -60,2 +60,2 @@\n-  nonstatic_field(G1CollectedHeap, _old_set,            HeapRegionSetBase)    \\\n-  nonstatic_field(G1CollectedHeap, _humongous_set,      HeapRegionSetBase)    \\\n+  nonstatic_field(G1CollectedHeap, _old_set,            G1HeapRegionSetBase)  \\\n+  nonstatic_field(G1CollectedHeap, _humongous_set,      G1HeapRegionSetBase)  \\\n@@ -70,1 +70,1 @@\n-  nonstatic_field(HeapRegionSetBase,   _length,         uint)                 \\\n+  nonstatic_field(G1HeapRegionSetBase,   _length,       uint)                 \\\n@@ -77,8 +77,8 @@\n-  declare_constant(HeapRegionType::FreeTag)                                   \\\n-  declare_constant(HeapRegionType::YoungMask)                                 \\\n-  declare_constant(HeapRegionType::EdenTag)                                   \\\n-  declare_constant(HeapRegionType::SurvTag)                                   \\\n-  declare_constant(HeapRegionType::HumongousMask)                             \\\n-  declare_constant(HeapRegionType::StartsHumongousTag)                        \\\n-  declare_constant(HeapRegionType::ContinuesHumongousTag)                     \\\n-  declare_constant(HeapRegionType::OldMask)                                   \\\n+  declare_constant(G1HeapRegionType::FreeTag)                                 \\\n+  declare_constant(G1HeapRegionType::YoungMask)                               \\\n+  declare_constant(G1HeapRegionType::EdenTag)                                 \\\n+  declare_constant(G1HeapRegionType::SurvTag)                                 \\\n+  declare_constant(G1HeapRegionType::HumongousMask)                           \\\n+  declare_constant(G1HeapRegionType::StartsHumongousTag)                      \\\n+  declare_constant(G1HeapRegionType::ContinuesHumongousTag)                   \\\n+  declare_constant(G1HeapRegionType::OldMask)                                 \\\n@@ -97,2 +97,2 @@\n-  declare_toplevel_type(HeapRegionManager)                                    \\\n-  declare_toplevel_type(HeapRegionSetBase)                                    \\\n+  declare_toplevel_type(G1HeapRegionManager)                                  \\\n+  declare_toplevel_type(G1HeapRegionSetBase)                                  \\\n@@ -101,1 +101,1 @@\n-  declare_toplevel_type(HeapRegionType)                                       \\\n+  declare_toplevel_type(G1HeapRegionType)                                     \\\n@@ -109,1 +109,1 @@\n-  declare_integer_type(HeapRegionType::Tag volatile)\n+  declare_integer_type(G1HeapRegionType::Tag volatile)\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  _heap_start = 0;\n+  _heap_start = nullptr;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -444,5 +444,1 @@\n-  \/\/ The do_full_collection() parameter clear_all_soft_refs\n-  \/\/ is interpreted here as maximum_compaction which will\n-  \/\/ cause SoftRefs to be cleared.\n-  bool maximum_compaction = clear_all_soft_refs;\n-  PSParallelCompact::invoke(maximum_compaction);\n+  PSParallelCompact::invoke(clear_all_soft_refs);\n@@ -664,1 +660,1 @@\n-  return 0;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  if (vspace != 0) {\n+  if (vspace != nullptr) {\n@@ -250,1 +250,1 @@\n-  return 0;\n+  return nullptr;\n@@ -259,1 +259,1 @@\n-  if (_region_vspace != 0) {\n+  if (_region_vspace != nullptr) {\n@@ -830,4 +830,10 @@\n-bool PSParallelCompact::reassess_maximum_compaction(bool maximum_compaction,\n-                                                    size_t total_live_words,\n-                                                    MutableSpace* const old_space,\n-                                                    HeapWord* full_region_prefix_end) {\n+bool PSParallelCompact::check_maximum_compaction(size_t total_live_words,\n+                                                 MutableSpace* const old_space,\n+                                                 HeapWord* full_region_prefix_end) {\n+\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+\n+  \/\/ Check System.GC\n+  bool is_max_on_system_gc = UseMaximumCompactionOnSystemGC\n+                          && GCCause::is_user_requested_gc(heap->gc_cause());\n+\n@@ -838,1 +844,1 @@\n-  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n+  const uint total_invocations = heap->total_full_collections();\n@@ -847,1 +853,1 @@\n-  if (maximum_compaction || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n+  if (is_max_on_system_gc || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n@@ -855,1 +861,1 @@\n-void PSParallelCompact::summary_phase(bool maximum_compaction)\n+void PSParallelCompact::summary_phase()\n@@ -878,4 +884,3 @@\n-    maximum_compaction = reassess_maximum_compaction(maximum_compaction,\n-                                                     total_live_words,\n-                                                     old_space,\n-                                                     full_region_prefix_end);\n+    bool maximum_compaction = check_maximum_compaction(total_live_words,\n+                                                       old_space,\n+                                                       full_region_prefix_end);\n@@ -962,1 +967,1 @@\n-bool PSParallelCompact::invoke(bool maximum_heap_compaction) {\n+bool PSParallelCompact::invoke(bool clear_all_soft_refs) {\n@@ -967,3 +972,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  assert(!heap->is_stw_gc_active(), \"not reentrant\");\n-\n@@ -972,2 +974,3 @@\n-  const bool clear_all_soft_refs =\n-    heap->soft_ref_policy()->should_clear_all_soft_refs();\n+  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n+  clear_all_soft_refs = clear_all_soft_refs\n+                     || heap->soft_ref_policy()->should_clear_all_soft_refs();\n@@ -975,2 +978,1 @@\n-  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||\n-                                             maximum_heap_compaction);\n+  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs);\n@@ -981,1 +983,1 @@\n-bool PSParallelCompact::invoke_no_policy(bool maximum_heap_compaction) {\n+bool PSParallelCompact::invoke_no_policy(bool clear_all_soft_refs) {\n@@ -1002,1 +1004,1 @@\n-  ClearedAllSoftRefs casr(maximum_heap_compaction,\n+  ClearedAllSoftRefs casr(clear_all_soft_refs,\n@@ -1037,1 +1039,1 @@\n-    ref_processor()->start_discovery(maximum_heap_compaction);\n+    ref_processor()->start_discovery(clear_all_soft_refs);\n@@ -1045,3 +1047,1 @@\n-    bool max_on_system_gc = UseMaximumCompactionOnSystemGC\n-      && GCCause::is_user_requested_gc(gc_cause);\n-    summary_phase(maximum_heap_compaction || max_on_system_gc);\n+    summary_phase();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -726,4 +726,3 @@\n-  static bool reassess_maximum_compaction(bool maximum_compaction,\n-                                          size_t total_live_words,\n-                                          MutableSpace* const old_space,\n-                                          HeapWord* full_region_prefix_end);\n+  static bool check_maximum_compaction(size_t total_live_words,\n+                                       MutableSpace* const old_space,\n+                                       HeapWord* full_region_prefix_end);\n@@ -742,1 +741,1 @@\n-  static void summary_phase(bool maximum_compaction);\n+  static void summary_phase();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -151,4 +151,0 @@\n-    \/\/ Ensure any loads from the forwardee follow all changes that precede\n-    \/\/ the release-cmpxchg that performed the forwarding, possibly in some\n-    \/\/ other thread.\n-    OrderAccess::acquire();\n@@ -256,4 +252,0 @@\n-  \/\/ Parallel GC claims with a release - so other threads might access this object\n-  \/\/ after claiming and they should see the \"completed\" object.\n-  ContinuationGCSupport::transform_stack_chunk(new_obj);\n-\n@@ -261,2 +253,5 @@\n-  \/\/ Make copy visible to threads reading the forwardee.\n-  oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_release);\n+  \/\/ Because the forwarding is done with memory_order_relaxed there is no\n+  \/\/ ordering with the above copy.  Clients that get the forwardee must not\n+  \/\/ examine its contents without other synchronization, since the contents\n+  \/\/ may not be up to date for them.\n+  oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_relaxed);\n@@ -275,0 +270,2 @@\n+    ContinuationGCSupport::transform_stack_chunk(new_obj);\n+\n@@ -298,3 +295,0 @@\n-    \/\/ Ensure loads from the forwardee follow all changes that preceded the\n-    \/\/ release-cmpxchg that performed the forwarding in another thread.\n-    OrderAccess::acquire();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -238,1 +238,0 @@\n-  PSAdaptiveSizePolicy* policy = heap->size_policy();\n@@ -253,2 +252,1 @@\n-    SoftRefPolicy* srp = heap->soft_ref_policy();\n-    const bool clear_all_softrefs = srp->should_clear_all_soft_refs();\n+    const bool clear_all_softrefs = heap->soft_ref_policy()->should_clear_all_soft_refs();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-    _should_allocate_from_space(false),\n@@ -537,5 +536,0 @@\n-size_t DefNewGeneration::contiguous_available() const {\n-  return eden()->free();\n-}\n-\n-\n@@ -581,27 +575,0 @@\n-\/\/ The last collection bailed out, we are running out of heap space,\n-\/\/ so we try to allocate the from-space, too.\n-HeapWord* DefNewGeneration::allocate_from_space(size_t size) {\n-  bool should_try_alloc = should_allocate_from_space() || GCLocker::is_active_and_needs_gc();\n-\n-  \/\/ If the Heap_lock is not locked by this thread, this will be called\n-  \/\/ again later with the Heap_lock held.\n-  bool do_alloc = should_try_alloc && (Heap_lock->owned_by_self() || (SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread()));\n-\n-  HeapWord* result = nullptr;\n-  if (do_alloc) {\n-    result = from()->allocate(size);\n-  }\n-\n-  log_trace(gc, alloc)(\"DefNewGeneration::allocate_from_space(\" SIZE_FORMAT \"):  will_fail: %s  heap_lock: %s  free: \" SIZE_FORMAT \"%s%s returns %s\",\n-                        size,\n-                        SerialHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n-                          \"true\" : \"false\",\n-                        Heap_lock->is_locked() ? \"locked\" : \"unlocked\",\n-                        from()->free(),\n-                        should_try_alloc ? \"\" : \"  should_allocate_from_space: NOT\",\n-                        do_alloc ? \"  Heap_lock is not owned by self\" : \"\",\n-                        result == nullptr ? \"null\" : \"object\");\n-\n-  return result;\n-}\n-\n@@ -710,2 +677,0 @@\n-\n-    assert(!heap->incremental_collection_failed(), \"Should be clear\");\n@@ -718,7 +683,0 @@\n-    \/\/ Add to-space to the list of space to compact\n-    \/\/ when a promotion failure has occurred.  In that\n-    \/\/ case there can be live objects in to-space\n-    \/\/ as a result of a partial evacuation of eden\n-    \/\/ and from-space.\n-    swap_spaces();   \/\/ For uniformity wrt ParNewGeneration.\n-    heap->set_incremental_collection_failed();\n@@ -807,1 +765,1 @@\n-    obj = _old_gen->promote(old, s);\n+    obj = _old_gen->allocate_for_promotion(old, s);\n@@ -813,2 +771,0 @@\n-    ContinuationGCSupport::transform_stack_chunk(obj);\n-\n@@ -816,4 +772,5 @@\n-  } else {\n-    \/\/ Prefetch beyond obj\n-    const intx interval = PrefetchCopyIntervalInBytes;\n-    Prefetch::write(obj, interval);\n+  }\n+\n+  \/\/ Prefetch beyond obj\n+  const intx interval = PrefetchCopyIntervalInBytes;\n+  Prefetch::write(obj, interval);\n@@ -821,2 +778,2 @@\n-    \/\/ Copy obj\n-    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), s);\n+  \/\/ Copy obj\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), s);\n@@ -824,1 +781,1 @@\n-    ContinuationGCSupport::transform_stack_chunk(obj);\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n@@ -826,0 +783,1 @@\n+  if (!new_obj_is_tenured) {\n@@ -874,11 +832,0 @@\n-bool DefNewGeneration::collection_attempt_is_safe() {\n-  if (!to()->is_empty()) {\n-    log_trace(gc)(\":: to is not empty ::\");\n-    return false;\n-  }\n-  if (_old_gen == nullptr) {\n-    _old_gen = SerialHeap::heap()->old_gen();\n-  }\n-  return _old_gen->promotion_attempt_is_safe(used());\n-}\n-\n@@ -886,2 +833,0 @@\n-  DEBUG_ONLY(static bool seen_incremental_collection_failed = false;)\n-\n@@ -889,39 +834,0 @@\n-  \/\/ Check if the heap is approaching full after a collection has\n-  \/\/ been done.  Generally the young generation is empty at\n-  \/\/ a minimum at the end of a collection.  If it is not, then\n-  \/\/ the heap is approaching full.\n-  SerialHeap* gch = SerialHeap::heap();\n-  if (full) {\n-    DEBUG_ONLY(seen_incremental_collection_failed = false;)\n-    if (!collection_attempt_is_safe() && !_eden_space->is_empty()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, not safe, set_failed, set_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->set_incremental_collection_failed(); \/\/ Slight lie: a full gc left us in that state\n-      set_should_allocate_from_space(); \/\/ we seem to be running out of space\n-    } else {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), full, safe, clear_failed, clear_alloc_from, clear_seen\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      gch->clear_incremental_collection_failed(); \/\/ We just did a full collection\n-      clear_should_allocate_from_space(); \/\/ if set\n-    }\n-  } else {\n-#ifdef ASSERT\n-    \/\/ It is possible that incremental_collection_failed() == true\n-    \/\/ here, because an attempted scavenge did not succeed. The policy\n-    \/\/ is normally expected to cause a full collection which should\n-    \/\/ clear that condition, so we should not be here twice in a row\n-    \/\/ with incremental_collection_failed() == true without having done\n-    \/\/ a full collection in between.\n-    if (!seen_incremental_collection_failed &&\n-        gch->incremental_collection_failed()) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, not_seen_failed, failed, set_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = true;\n-    } else if (seen_incremental_collection_failed) {\n-      log_trace(gc)(\"DefNewEpilogue: cause(%s), not full, seen_failed, will_clear_seen_failed\",\n-                            GCCause::to_string(gch->gc_cause()));\n-      seen_incremental_collection_failed = false;\n-    }\n-#endif \/\/ ASSERT\n-  }\n-\n@@ -930,1 +836,1 @@\n-  gch->counters()->update_counters();\n+  SerialHeap::heap()->counters()->update_counters();\n@@ -970,7 +876,0 @@\n-  if (result == nullptr) {\n-    \/\/ If the eden is full and the last collection bailed out, we are running\n-    \/\/ out of heap space, and we try to allocate the from-space, too.\n-    \/\/ allocate_from_space can't be inlined because that would introduce a\n-    \/\/ circular dependency at compile time.\n-    result = allocate_from_space(word_size);\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":11,"deletions":112,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-class ScanWeakRefClosure;\n@@ -122,12 +121,0 @@\n-  \/\/ Allocation support\n-  bool _should_allocate_from_space;\n-  bool should_allocate_from_space() const {\n-    return _should_allocate_from_space;\n-  }\n-  void clear_should_allocate_from_space() {\n-    _should_allocate_from_space = false;\n-  }\n-  void set_should_allocate_from_space() {\n-    _should_allocate_from_space = true;\n-  }\n-\n@@ -188,2 +175,0 @@\n-  size_t contiguous_available() const;\n-\n@@ -228,1 +213,0 @@\n-  HeapWord* allocate_from_space(size_t word_size);\n@@ -244,7 +228,0 @@\n-  \/\/ Returns true if the collection is likely to be safely\n-  \/\/ completed. Even if this method returns true, a collection\n-  \/\/ may not be guaranteed to succeed, and the system should be\n-  \/\/ able to safely unwind and recover from that failure, albeit\n-  \/\/ at some additional cost.\n-  bool collection_attempt_is_safe();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -99,4 +99,0 @@\n-  \/\/ The largest number of contiguous free bytes in the generation,\n-  \/\/ including expansion  (Assumes called at a safepoint.)\n-  virtual size_t contiguous_available() const = 0;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-    _incremental_collection_failed(false),\n@@ -290,2 +289,1 @@\n-         || GCLocker::is_active_and_needs_gc()\n-         || incremental_collection_failed();\n+         || GCLocker::is_active_and_needs_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-public:\n@@ -78,5 +77,0 @@\n-  enum GenerationType {\n-    YoungGen,\n-    OldGen\n-  };\n-\n@@ -94,5 +88,0 @@\n-  \/\/ Indicates that the most recent previous incremental collection failed.\n-  \/\/ The flag is cleared when an action is taken that might clear the\n-  \/\/ condition that caused that incremental collection to fail.\n-  bool _incremental_collection_failed;\n-\n@@ -132,1 +121,0 @@\n-  bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }\n@@ -258,23 +246,0 @@\n-  \/\/ Returns true if an incremental collection is likely to fail.\n-  \/\/ We optionally consult the young gen, if asked to do so;\n-  \/\/ otherwise we base our answer on whether the previous incremental\n-  \/\/ collection attempt failed with no corrective action as of yet.\n-  bool incremental_collection_will_fail(bool consult_young) {\n-    \/\/ The first disjunct remembers if an incremental collection failed, even\n-    \/\/ when we thought (second disjunct) that it would not.\n-    return incremental_collection_failed() ||\n-           (consult_young && !_young_gen->collection_attempt_is_safe());\n-  }\n-\n-  \/\/ If a generation bails out of an incremental collection,\n-  \/\/ it sets this flag.\n-  bool incremental_collection_failed() const {\n-    return _incremental_collection_failed;\n-  }\n-  void set_incremental_collection_failed() {\n-    _incremental_collection_failed = true;\n-  }\n-  void clear_incremental_collection_failed() {\n-    _incremental_collection_failed = false;\n-  }\n-\n@@ -292,1 +257,0 @@\n-private:\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-  size_t available = contiguous_available();\n+  size_t available = _the_space->free() + _virtual_space.uncommitted_size();\n@@ -390,1 +390,1 @@\n-oop TenuredGeneration::promote(oop obj, size_t obj_size) {\n+oop TenuredGeneration::allocate_for_promotion(oop obj, size_t obj_size) {\n@@ -404,3 +404,0 @@\n-    if (result == nullptr) {\n-      return nullptr;\n-    }\n@@ -409,4 +406,1 @@\n-  \/\/ Copy to new location.\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), result, obj_size);\n-  oop new_obj = cast_to_oop<HeapWord*>(result);\n-  return new_obj;\n+  return cast_to_oop<HeapWord*>(result);\n@@ -422,4 +416,0 @@\n-size_t TenuredGeneration::contiguous_available() const {\n-  return _the_space->free() + _virtual_space.uncommitted_size();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -127,2 +127,0 @@\n-  size_t contiguous_available() const;\n-\n@@ -166,2 +164,1 @@\n-  \/\/ in the old-gen, and copy \"obj\" into the newly allocated space, if\n-  \/\/ possible, returning the result (or null if the allocation failed).\n+  \/\/ in the old-gen, returning the result (or null if the allocation failed).\n@@ -171,1 +168,1 @@\n-  oop promote(oop obj, size_t obj_size);\n+  oop allocate_for_promotion(oop obj, size_t obj_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,0 +103,6 @@\n+  if (!is_armed(nm)) {\n+    \/\/ Some other thread got here first and healed the oops\n+    \/\/ and disarmed the nmethod. No need to continue.\n+    return true;\n+  }\n+\n@@ -175,5 +181,0 @@\n-  if (!bs_nm->is_armed(nm)) {\n-    return 0;\n-  }\n-\n-  assert(!nm->is_osr_method(), \"Should not reach here\");\n@@ -182,0 +183,1 @@\n+  assert(!nm->is_osr_method() || may_enter, \"OSR nmethods should always be entrant after migration\");\n@@ -191,1 +193,1 @@\n-  \/\/ Diagnostic option to force deoptimization 1 in 3 times. It is otherwise\n+  \/\/ Diagnostic option to force deoptimization 1 in 10 times. It is otherwise\n@@ -193,1 +195,1 @@\n-  if (DeoptimizeNMethodBarriersALot) {\n+  if (DeoptimizeNMethodBarriersALot && !nm->is_osr_method()) {\n@@ -195,1 +197,1 @@\n-    if (Atomic::add(&counter, 1u) % 3 == 0) {\n+    if (Atomic::add(&counter, 1u) % 10 == 0) {\n@@ -208,9 +210,0 @@\n-  \/\/ This check depends on the invariant that all nmethods that are deoptimized \/ made not entrant\n-  \/\/ are NOT disarmed.\n-  \/\/ This invariant is important because a method can be deoptimized after the method have been\n-  \/\/ resolved \/ looked up by OSR by another thread. By not deoptimizing them we guarantee that\n-  \/\/ a deoptimized method will always hit the barrier and come to the same conclusion - deoptimize\n-  if (!is_armed(nm)) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -43,1 +43,5 @@\n-\n+  if (is_full_gc) {\n+    \/\/ Explicit Full GC would do the clearing of soft-refs as well\n+    \/\/ So reset in the beginning\n+    soft_ref_policy->set_should_clear_all_soft_refs(false);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcOverheadChecker.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  OopMapCache::trigger_cleanup();\n+  OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+    mem_zap_start_padding(mem);\n@@ -403,0 +404,14 @@\n+void ObjArrayAllocator::mem_zap_start_padding(HeapWord* mem) const {\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t header_size_in_bytes = arrayOopDesc::header_size_in_bytes();\n+\n+  const address base = reinterpret_cast<address>(mem) + base_offset_in_bytes;\n+  const address header_end = reinterpret_cast<address>(mem) + header_size_in_bytes;\n+\n+  if (header_end < base) {\n+    const size_t padding_in_bytes = base - header_end;\n+    Copy::fill_to_bytes(header_end, padding_in_bytes, heapPaddingByteVal);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  void mem_zap_start_padding(HeapWord* mem) const PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n+  QuickSort::sort(data, size, compare_by_garbage);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +106,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -110,1 +110,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -180,1 +179,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -185,1 +183,0 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,4 +156,1 @@\n-  {\n-    ShenandoahHeapLocker locker(heap->lock());\n-    heap->free_set()->log_status();\n-  }\n+  heap->free_set()->log_status_under_lock();\n@@ -774,1 +772,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -781,1 +778,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -887,1 +883,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -894,1 +889,0 @@\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,4 +150,1 @@\n-      {\n-        ShenandoahHeapLocker locker(heap->lock());\n-        heap->free_set()->log_status();\n-      }\n+      heap->free_set()->log_status_under_lock();\n@@ -181,3 +178,1 @@\n-      {\n-        ShenandoahHeapLocker locker(heap->lock());\n-        heap->free_set()->log_status();\n+      heap->free_set()->log_status_under_lock();\n@@ -185,4 +180,4 @@\n-        \/\/ Notify Universe about new heap usage. This has implications for\n-        \/\/ global soft refs policy, and we better report it every time heap\n-        \/\/ usage goes down.\n-        heap->update_capacity_and_used_at_gc();\n+      \/\/ Notify Universe about new heap usage. This has implications for\n+      \/\/ global soft refs policy, and we better report it every time heap\n+      \/\/ usage goes down.\n+      heap->update_capacity_and_used_at_gc();\n@@ -190,3 +185,2 @@\n-        \/\/ Signal that we have completed a visit to all live objects.\n-        heap->record_whole_heap_examined_timestamp();\n-      }\n+      \/\/ Signal that we have completed a visit to all live objects.\n+      heap->record_whole_heap_examined_timestamp();\n@@ -327,1 +321,2 @@\n-    \/\/ Cycle is complete\n+    \/\/ Cycle is complete.  There were no failed allocation requests and no degeneration, so count this as good progress.\n+    heap->notify_gc_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-    heap->notify_gc_no_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1133,0 +1133,10 @@\n+void ShenandoahFreeSet::log_status_under_lock() {\n+  \/\/ Must not be heap locked, it acquires heap lock only when log is enabled\n+  shenandoah_assert_not_heaplocked();\n+  if (LogTarget(Info, gc, free)::is_enabled()\n+      DEBUG_ONLY(|| LogTarget(Debug, gc, free)::is_enabled())) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    log_status();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -321,0 +321,3 @@\n+  \/\/ log status, assuming lock has already been acquired by the caller.\n+  void log_status();\n+\n@@ -343,1 +346,2 @@\n-  void log_status();\n+  \/\/ Acquire heap lock and log status, assuming heap lock is not acquired by the caller.\n+  void log_status_under_lock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -948,18 +948,30 @@\n-    \/\/ Block until control thread reacted, then retry allocation.\n-    \/\/\n-    \/\/ It might happen that one of the threads requesting allocation would unblock\n-    \/\/ way later after GC happened, only to fail the second allocation, because\n-    \/\/ other threads have already depleted the free storage. In this case, a better\n-    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n-    \/\/ one full GC has completed).\n-    size_t original_count = shenandoah_policy()->full_gc_count();\n-    while (result == nullptr\n-        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req, true);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n-\n-    if (log_is_enabled(Debug, gc, alloc)) {\n-      ResourceMark rm;\n-      log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n-                           Thread::current()->name(), p2i(result), req.type_string(), req.size(), original_count, get_gc_no_progress_count());\n+    if (result == nullptr) {\n+      \/\/ Block until control thread reacted, then retry allocation.\n+      \/\/\n+      \/\/ It might happen that one of the threads requesting allocation would unblock\n+      \/\/ way later after GC happened, only to fail the second allocation, because\n+      \/\/ other threads have already depleted the free storage. In this case, a better\n+      \/\/ strategy is to try again, until at least one full GC has completed.\n+      \/\/\n+      \/\/ Stop retrying and return nullptr to cause OOMError exception if our allocation failed even after:\n+      \/\/   a) We experienced a GC that had good progress, or\n+      \/\/   b) We experienced at least one Full GC (whether or not it had good progress)\n+      \/\/\n+      \/\/ TODO: Consider GLOBAL GC rather than Full GC to remediate OOM condition: https:\/\/bugs.openjdk.org\/browse\/JDK-8335910\n+\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n+      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+        control_thread()->handle_alloc_failure(req, true);\n+        result = allocate_memory_under_lock(req, in_new_region);\n+      }\n+      if (result != nullptr) {\n+        \/\/ If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        notify_gc_progress();\n+      }\n+      if (log_is_enabled(Debug, gc, alloc)) {\n+        ResourceMark rm;\n+        log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT\n+                             \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n+                             Thread::current()->name(), p2i(result), req.type_string(), req.size(),\n+                             original_count, get_gc_no_progress_count());\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":30,"deletions":18,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -35,9 +35,0 @@\n-\/\/ These are inline variants of Thread::SpinAcquire with optional blocking in VM.\n-\n-class ShenandoahNoBlockOp : public StackObj {\n-public:\n-  ShenandoahNoBlockOp(JavaThread* java_thread) {\n-    assert(java_thread == nullptr, \"Should not pass anything\");\n-  }\n-};\n-\n@@ -47,1 +38,1 @@\n-    contended_lock_internal<ThreadBlockInVM>(JavaThread::cast(thread));\n+    contended_lock_internal<true>(JavaThread::cast(thread));\n@@ -49,1 +40,1 @@\n-    contended_lock_internal<ShenandoahNoBlockOp>(nullptr);\n+    contended_lock_internal<false>(nullptr);\n@@ -53,1 +44,1 @@\n-template<typename BlockOp>\n+template<bool ALLOW_BLOCK>\n@@ -55,2 +46,4 @@\n-  int ctr = 0;\n-  int yields = 0;\n+  assert(!ALLOW_BLOCK || java_thread != nullptr, \"Must have a Java thread when allowing block.\");\n+  \/\/ Spin this much, but only on multi-processor systems.\n+  int ctr = os::is_MP() ? 0xFF : 0;\n+  \/\/ Apply TTAS to avoid more expensive CAS calls if the lock is still held by other thread.\n@@ -59,4 +52,21 @@\n-    if ((++ctr & 0xFFF) == 0) {\n-      BlockOp block(java_thread);\n-      if (yields > 5) {\n-        os::naked_short_sleep(1);\n+    if (ctr > 0 && !SafepointSynchronize::is_synchronizing()) {\n+      \/\/ Lightly contended, spin a little if no safepoint is pending.\n+      SpinPause();\n+      ctr--;\n+    } else if (ALLOW_BLOCK) {\n+      ThreadBlockInVM block(java_thread);\n+      if (SafepointSynchronize::is_synchronizing()) {\n+        \/\/ If safepoint is pending, we want to block and allow safepoint to proceed.\n+        \/\/ Normally, TBIVM above would block us in its destructor.\n+        \/\/\n+        \/\/ But that blocking only happens when TBIVM knows the thread poll is armed.\n+        \/\/ There is a window between announcing a safepoint and arming the thread poll\n+        \/\/ during which trying to continuously enter TBIVM is counter-productive.\n+        \/\/ Under high contention, we may end up going in circles thousands of times.\n+        \/\/ To avoid it, we wait here until local poll is armed and then proceed\n+        \/\/ to TBVIM exit for blocking. We do not SpinPause, but yield to let\n+        \/\/ VM thread to arm the poll sooner.\n+        while (SafepointSynchronize::is_synchronizing() &&\n+               !SafepointMechanism::local_poll_armed(java_thread)) {\n+          os::naked_yield();\n+        }\n@@ -65,1 +75,0 @@\n-        yields++;\n@@ -68,1 +77,1 @@\n-      SpinPause();\n+      os::naked_yield();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  volatile Thread* _owner;\n+  Thread* volatile _owner;\n@@ -43,1 +43,1 @@\n-  template<typename BlockOp>\n+  template<bool ALLOW_BLOCK>\n@@ -45,1 +45,0 @@\n-\n@@ -52,2 +51,5 @@\n-    \/\/ Try to lock fast, or dive into contended lock handling.\n-    if (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+    if ((allow_block_for_safepoint && SafepointSynchronize::is_synchronizing()) ||\n+        (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked)) {\n+      \/\/ 1. Java thread, and there is a pending safepoint. Dive into contended locking\n+      \/\/    immediately without trying anything else, and block.\n+      \/\/ 2. Fast lock fails, dive into contended lock handling.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,1 +482,1 @@\n-  assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -491,1 +492,1 @@\n-  assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  OopMapCache::trigger_cleanup();\n+  OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+  if (!is_armed(nm)) {\n+    \/\/ Some other thread got here first and healed the oops\n+    \/\/ and disarmed the nmethod. No need to continue.\n+    return true;\n+  }\n+\n@@ -39,2 +45,2 @@\n-    \/\/ Some other thread got here first and healed the oops\n-    \/\/ and disarmed the nmethod.\n+    \/\/ Some other thread managed to complete while we were\n+    \/\/ waiting for lock. No need to continue.\n","filename":"src\/hotspot\/share\/gc\/x\/xBarrierSetNMethod.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-    OopMapCache::trigger_cleanup();\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/x\/xDriver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,2 @@\n+  static void load_barrier_on_oop_array(volatile zpointer* p, size_t length);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,0 +478,6 @@\n+inline void ZBarrier::load_barrier_on_oop_array(volatile zpointer* p, size_t length) {\n+  for (volatile const zpointer* const end = p + length; p < end; p++) {\n+    load_barrier_on_oop_field(p);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,7 @@\n+  if (!is_armed(nm)) {\n+    log_develop_trace(gc, nmethod)(\"nmethod: \" PTR_FORMAT \" visited by entry (disarmed before lock)\", p2i(nm));\n+    \/\/ Some other thread got here first and healed the oops\n+    \/\/ and disarmed the nmethod. No need to continue.\n+    return true;\n+  }\n+\n@@ -47,2 +54,2 @@\n-    \/\/ Some other thread got here first and healed the oops\n-    \/\/ and disarmed the nmethod.\n+    \/\/ Some other thread managed to complete while we were\n+    \/\/ waiting for lock. No need to continue.\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+JRT_LEAF(void, ZBarrierSetRuntime::load_barrier_on_oop_array(oop* p, size_t length))\n+  ZBarrier::load_barrier_on_oop_array((zpointer*)p, length);\n+JRT_END\n+\n@@ -129,0 +133,4 @@\n+address ZBarrierSetRuntime::load_barrier_on_oop_array_addr() {\n+  return reinterpret_cast<address>(load_barrier_on_oop_array);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  static void load_barrier_on_oop_array(oop* p, size_t length);\n@@ -57,0 +58,1 @@\n+  static address load_barrier_on_oop_array_addr();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-    OopMapCache::trigger_cleanup();\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,0 +143,2 @@\n+  mem_zap_start_padding(mem);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-    return 0;\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,0 +153,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsContainerized(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-  if (klass->is_being_initialized() && klass->is_init_thread(THREAD)) {\n+  if (klass->is_being_initialized() && klass->is_reentrant_initialization(THREAD)) {\n@@ -1022,1 +1022,0 @@\n-  ConstantPoolCache* cache = pool->cache();\n@@ -1047,0 +1046,7 @@\n+  update_invoke_cp_cache_entry(info, bytecode, resolved_method, pool, method_index);\n+}\n+\n+void InterpreterRuntime::update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                                      methodHandle& resolved_method,\n+                                                      constantPoolHandle& pool,\n+                                                      int method_index) {\n@@ -1051,0 +1057,1 @@\n+  ConstantPoolCache* cache = pool->cache();\n@@ -1102,0 +1109,27 @@\n+void InterpreterRuntime::cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                            constantPoolHandle& pool, TRAPS) {\n+  LinkInfo link_info(pool, method_index, bytecode, CHECK);\n+\n+  if (!link_info.resolved_klass()->is_instance_klass() || InstanceKlass::cast(link_info.resolved_klass())->is_linked()) {\n+    CallInfo call_info;\n+    switch (bytecode) {\n+      case Bytecodes::_invokevirtual:   LinkResolver::cds_resolve_virtual_call  (call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokeinterface: LinkResolver::cds_resolve_interface_call(call_info, link_info, CHECK); break;\n+      case Bytecodes::_invokespecial:   LinkResolver::cds_resolve_special_call  (call_info, link_info, CHECK); break;\n+\n+      default: fatal(\"Unimplemented: %s\", Bytecodes::name(bytecode));\n+    }\n+    methodHandle resolved_method(THREAD, call_info.resolved_method());\n+    guarantee(resolved_method->method_holder()->is_linked(), \"\");\n+    update_invoke_cp_cache_entry(call_info, bytecode, resolved_method, pool, method_index);\n+  } else {\n+    \/\/ FIXME: why a shared class is not linked yet?\n+    \/\/ Can't link it here since there are no guarantees it'll be prelinked on the next run.\n+    ResourceMark rm;\n+    InstanceKlass* resolved_iklass = InstanceKlass::cast(link_info.resolved_klass());\n+    log_info(cds, resolve)(\"Not resolved: class not linked: %s %s %s\",\n+                           resolved_iklass->is_shared() ? \"is_shared\" : \"\",\n+                           resolved_iklass->init_state_name(),\n+                           resolved_iklass->external_name());\n+  }\n+}\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  \/\/ Used by ClassListParser.\n+  \/\/ Used by ClassPrelinker\n@@ -109,0 +109,2 @@\n+  static void cds_resolve_invoke(Bytecodes::Code bytecode, int method_index,\n+                                 constantPoolHandle& pool, TRAPS);\n@@ -119,0 +121,3 @@\n+  static void update_invoke_cp_cache_entry(CallInfo& info, Bytecodes::Code bytecode,\n+                                           methodHandle& resolved_method,\n+                                           constantPoolHandle& pool, int method_index);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,1 +145,3 @@\n-  assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  if (selected_method.not_null()) {\n+    assert(resolved_method->signature() == selected_method->signature(), \"signatures must correspond\");\n+  }\n@@ -154,1 +156,3 @@\n-  CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  if (selected_method.not_null()) {\n+    CompilationPolicy::compile_if_required(selected_method, THREAD);\n+  }\n@@ -1156,0 +1160,4 @@\n+void LinkResolver::cds_resolve_special_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  resolve_special_call(result, Handle(), link_info, CHECK);\n+}\n+\n@@ -1339,1 +1347,11 @@\n-                                 check_null_and_abstract, CHECK);\n+                                 check_null_and_abstract,\n+                                 \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_virtual_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);\n+  runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),\n+                                 link_info.resolved_klass(),\n+                                 Handle(), nullptr,\n+                                 \/*check_null_and_abstract*\/ false,\n+                                 \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1391,0 +1409,1 @@\n+                                                  bool is_abstract_interpretation,\n@@ -1392,0 +1411,3 @@\n+  \/\/ is_abstract_interpretation is true IFF CDS is resolving method references without\n+  \/\/ running any actual bytecode. Therefore, we don't have an actual recv\/recv_klass, so\n+  \/\/ we cannot check the actual selected_method (which is not needed by CDS anyway).\n@@ -1412,1 +1434,3 @@\n-    selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    if (!is_abstract_interpretation) {\n+      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+    }\n@@ -1426,1 +1450,3 @@\n-      selected_method = resolved_method;\n+      if (!is_abstract_interpretation) {\n+        selected_method = resolved_method;\n+      }\n@@ -1428,1 +1454,3 @@\n-      selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      if (!is_abstract_interpretation) {\n+        selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));\n+      }\n@@ -1432,4 +1460,5 @@\n-  \/\/ check if method exists\n-  if (selected_method.is_null()) {\n-    throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n-  }\n+  if (!is_abstract_interpretation) {\n+    \/\/ check if method exists\n+    if (selected_method.is_null()) {\n+      throw_abstract_method_error(resolved_method, recv_klass, CHECK);\n+    }\n@@ -1437,5 +1466,5 @@\n-  \/\/ check if abstract\n-  if (check_null_and_abstract && selected_method->is_abstract()) {\n-    \/\/ Pass arguments for generating a verbose error message.\n-    throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n-  }\n+    \/\/ check if abstract\n+    if (check_null_and_abstract && selected_method->is_abstract()) {\n+      \/\/ Pass arguments for generating a verbose error message.\n+      throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);\n+    }\n@@ -1443,4 +1472,5 @@\n-  if (log_develop_is_enabled(Trace, vtables)) {\n-    trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n-                            recv_klass, resolved_klass, selected_method(),\n-                            false, vtable_index);\n+    if (log_develop_is_enabled(Trace, vtables)) {\n+      trace_method_resolution(\"invokevirtual selected method: receiver-class:\",\n+                              recv_klass, resolved_klass, selected_method(),\n+                              false, vtable_index);\n+    }\n@@ -1448,0 +1478,1 @@\n+\n@@ -1450,1 +1481,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (selected_method.not_null()) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n@@ -1460,1 +1493,10 @@\n-                                   recv, recv_klass, check_null_and_abstract, CHECK);\n+                                   recv, recv_klass, check_null_and_abstract,\n+                                   \/*is_abstract_interpretation*\/ false, CHECK);\n+}\n+\n+void LinkResolver::cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);\n+  runtime_resolve_interface_method(result, methodHandle(THREAD, resolved_method), link_info.resolved_klass(),\n+                                   Handle(), nullptr,\n+                                   \/*check_null_and_abstract*\/ false,\n+                                   \/*is_abstract_interpretation*\/ true, CHECK);\n@@ -1479,1 +1521,3 @@\n-                                                    bool check_null_and_abstract, TRAPS) {\n+                                                    bool check_null_and_abstract,\n+                                                    bool is_abstract_interpretation, TRAPS) {\n+  \/\/ is_abstract_interpretation -- see comments in runtime_resolve_virtual_method()\n@@ -1487,1 +1531,1 @@\n-  if (!recv_klass->is_subtype_of(resolved_klass)) {\n+  if (!is_abstract_interpretation && !recv_klass->is_subtype_of(resolved_klass)) {\n@@ -1496,1 +1540,5 @@\n-  methodHandle selected_method = resolved_method;\n+  methodHandle selected_method;\n+\n+  if (!is_abstract_interpretation) {\n+    selected_method = resolved_method;\n+  }\n@@ -1499,1 +1547,1 @@\n-  if (!resolved_method()->is_private()) {\n+  if (!is_abstract_interpretation && !resolved_method()->is_private()) {\n@@ -1545,1 +1593,1 @@\n-    assert(vtable_index == selected_method->vtable_index(), \"sanity check\");\n+    assert(is_abstract_interpretation || vtable_index == selected_method->vtable_index(), \"sanity check\");\n@@ -1562,1 +1610,3 @@\n-  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  if (!is_abstract_interpretation) {\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n+  }\n@@ -1831,1 +1881,1 @@\n-  \/\/ a lock to do the final serialization of updates\n+  \/\/ an ObjectLocker to do the final serialization of updates\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":78,"deletions":28,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -245,1 +245,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -251,1 +252,2 @@\n-                                                 bool check_null_and_abstract, TRAPS);\n+                                                 bool check_null_and_abstract,\n+                                                 bool is_abstract_interpretation, TRAPS);\n@@ -328,0 +330,4 @@\n+  static void cds_resolve_virtual_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_interface_call(CallInfo& result, const LinkInfo& link_info, TRAPS);\n+  static void cds_resolve_special_call  (CallInfo& result, const LinkInfo& link_info, TRAPS);\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,3 +69,0 @@\n-#ifdef ASSERT\n-    _resource_allocate_bit_mask = false;\n-#endif\n@@ -180,3 +177,7 @@\n-#ifdef ASSERT\n-  _resource_allocate_bit_mask = true;\n-#endif\n+}\n+\n+InterpreterOopMap::~InterpreterOopMap() {\n+  if (has_valid_mask() && mask_size() > small_mask_limit) {\n+    assert(_bit_mask[0] != 0, \"should have pointer to C heap\");\n+    FREE_C_HEAP_ARRAY(uintptr_t, _bit_mask[0]);\n+  }\n@@ -402,5 +403,5 @@\n-void InterpreterOopMap::resource_copy(OopMapCacheEntry* from) {\n-  assert(_resource_allocate_bit_mask,\n-    \"Should not resource allocate the _bit_mask\");\n-  assert(from->has_valid_mask(),\n-    \"Cannot copy entry with an invalid mask\");\n+void InterpreterOopMap::copy_from(const OopMapCacheEntry* src) {\n+  \/\/ The expectation is that this InterpreterOopMap is recently created\n+  \/\/ and empty. It is used to get a copy of a cached entry.\n+  assert(!has_valid_mask(), \"InterpreterOopMap object can only be filled once\");\n+  assert(src->has_valid_mask(), \"Cannot copy entry with an invalid mask\");\n@@ -408,5 +409,5 @@\n-  set_method(from->method());\n-  set_bci(from->bci());\n-  set_mask_size(from->mask_size());\n-  set_expression_stack_size(from->expression_stack_size());\n-  _num_oops = from->num_oops();\n+  set_method(src->method());\n+  set_bci(src->bci());\n+  set_mask_size(src->mask_size());\n+  set_expression_stack_size(src->expression_stack_size());\n+  _num_oops = src->num_oops();\n@@ -415,3 +416,2 @@\n-  if (from->mask_size() <= small_mask_limit) {\n-    memcpy((void *)_bit_mask, (void *)from->_bit_mask,\n-      mask_word_size() * BytesPerWord);\n+  if (src->mask_size() <= small_mask_limit) {\n+    memcpy(_bit_mask, src->_bit_mask, mask_word_size() * BytesPerWord);\n@@ -419,14 +419,2 @@\n-    \/\/ The expectation is that this InterpreterOopMap is a recently created\n-    \/\/ and empty. It is used to get a copy of a cached entry.\n-    \/\/ If the bit mask has a value, it should be in the\n-    \/\/ resource area.\n-    assert(_bit_mask[0] == 0 ||\n-      Thread::current()->resource_area()->contains((void*)_bit_mask[0]),\n-      \"The bit mask should have been allocated from a resource area\");\n-    \/\/ Allocate the bit_mask from a Resource area for performance.  Allocating\n-    \/\/ from the C heap as is done for OopMapCache has a significant\n-    \/\/ performance impact.\n-    _bit_mask[0] = (uintptr_t) NEW_RESOURCE_ARRAY(uintptr_t, mask_word_size());\n-    assert(_bit_mask[0] != 0, \"bit mask was not allocated\");\n-    memcpy((void*) _bit_mask[0], (void*) from->_bit_mask[0],\n-      mask_word_size() * BytesPerWord);\n+    _bit_mask[0] = (uintptr_t) NEW_C_HEAP_ARRAY(uintptr_t, mask_word_size(), mtClass);\n+    memcpy((void*) _bit_mask[0], (void*) src->_bit_mask[0], mask_word_size() * BytesPerWord);\n@@ -448,2 +436,1 @@\n-  _array  = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);\n-  for(int i = 0; i < _size; i++) _array[i] = nullptr;\n+  for(int i = 0; i < size; i++) _array[i] = nullptr;\n@@ -454,1 +441,0 @@\n-  assert(_array != nullptr, \"sanity check\");\n@@ -457,2 +443,0 @@\n-  \/\/ Deallocate array\n-  FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);\n@@ -462,1 +446,1 @@\n-  return Atomic::load_acquire(&(_array[i % _size]));\n+  return Atomic::load_acquire(&(_array[i % size]));\n@@ -466,1 +450,1 @@\n-  return Atomic::cmpxchg(&_array[i % _size], old, entry) == old;\n+  return Atomic::cmpxchg(&_array[i % size], old, entry) == old;\n@@ -470,1 +454,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -481,1 +465,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -516,1 +500,1 @@\n-    for (int i = 0; i < _probe_depth; i++) {\n+    for (int i = 0; i < probe_depth; i++) {\n@@ -519,1 +503,1 @@\n-        entry_for->resource_copy(entry);\n+        entry_for->copy_from(entry);\n@@ -533,1 +517,1 @@\n-  entry_for->resource_copy(tmp);\n+  entry_for->copy_from(tmp);\n@@ -545,1 +529,1 @@\n-  for (int i = 0; i < _probe_depth; i++) {\n+  for (int i = 0; i < probe_depth; i++) {\n@@ -595,3 +579,5 @@\n-void OopMapCache::trigger_cleanup() {\n-  if (has_cleanup_work()) {\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+void OopMapCache::try_trigger_cleanup() {\n+  \/\/ See we can take the lock for the notification without blocking.\n+  \/\/ This allows triggering the cleanup from GC paths, that can hold\n+  \/\/ the service lock for e.g. oop iteration in service thread.\n+  if (has_cleanup_work() && Service_lock->try_lock_without_rank_check()) {\n@@ -599,0 +585,1 @@\n+    Service_lock->unlock();\n@@ -631,1 +618,1 @@\n-    entry->resource_copy(tmp);\n+    entry->copy_from(tmp);\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":38,"deletions":51,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-\/\/ bit_mask can fit into two words it is stored in\n+\/\/ bit_mask can fit into four words it is stored in\n@@ -43,3 +43,4 @@\n-\/\/ For InterpreterOopMap the bit_mask is allocated in\n-\/\/ a resource area for better performance.  InterpreterOopMap\n-\/\/ should only be created and deleted during same garbage collection.\n+\/\/ For InterpreterOopMap the bit_mask is allocated in the C heap\n+\/\/ to avoid issues with allocations from the resource area that have\n+\/\/ to live accross the oop closure. InterpreterOopMap should only be\n+\/\/ created and deleted during the same garbage collection.\n@@ -86,1 +87,0 @@\n-  unsigned short _bci;            \/\/ the bci    for which the mask is valid\n@@ -89,0 +89,1 @@\n+  unsigned short _bci;            \/\/ the bci    for which the mask is valid\n@@ -91,0 +92,1 @@\n+  int            _num_oops;\n@@ -97,4 +99,0 @@\n-  int            _num_oops;\n-#ifdef ASSERT\n-  bool _resource_allocate_bit_mask;\n-#endif\n@@ -131,0 +129,1 @@\n+  ~InterpreterOopMap();\n@@ -132,5 +131,5 @@\n-  \/\/ Copy the OopMapCacheEntry in parameter \"from\" into this\n-  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"from\" points to\n-  \/\/ allocated space (i.e., the bit mask was to large to hold\n-  \/\/ in-line), allocate the space from a Resource area.\n-  void resource_copy(OopMapCacheEntry* from);\n+  \/\/ Copy the OopMapCacheEntry in parameter \"src\" into this\n+  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"src\" points to\n+  \/\/ allocated space (i.e., the bit mask was too large to hold\n+  \/\/ in-line), allocate the space from the C heap.\n+  void copy_from(const OopMapCacheEntry* src);\n@@ -155,3 +154,2 @@\n-  enum { _size        = 32,     \/\/ Use fixed size for now\n-         _probe_depth = 3       \/\/ probe depth in case of collisions\n-  };\n+  static constexpr int size = 32;        \/\/ Use fixed size for now\n+  static constexpr int probe_depth = 3;  \/\/ probe depth in case of collisions\n@@ -159,1 +157,1 @@\n-  OopMapCacheEntry* volatile * _array;\n+  OopMapCacheEntry* volatile _array[size];\n@@ -186,2 +184,2 @@\n-  \/\/ Request cleanup if work is needed\n-  static void trigger_cleanup();\n+  \/\/ Request cleanup if work is needed and notification is currently possible\n+  static void try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-  } else {\n-    ++last;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  template(jdk_jfr_internal_HiddenWait,                               \"jdk\/jfr\/internal\/HiddenWait\")                 \\\n+  template(jdk_jfr_internal_management_HiddenWait,                    \"jdk\/jfr\/internal\/management\/HiddenWait\")      \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1301,0 +1301,4 @@\n+  if (pd_relocate(pc, id)) {\n+    return;\n+  }\n+\n@@ -1336,6 +1340,0 @@\n-    case POLL_NEAR:\n-    case POLL_FAR:\n-    case POLL_RETURN_NEAR:\n-    case POLL_RETURN_FAR:\n-      pd_relocate_poll(pc, id, JVMCI_CHECK);\n-      break;\n@@ -1356,0 +1354,1 @@\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -179,0 +179,17 @@\n+\n+#ifdef X86\n+    Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_SHL,\n+    Z_BARRIER_RELOCATION_FORMAT_LOAD_BAD_AFTER_TEST,\n+    Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_AFTER_TEST,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_CMP,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_AFTER_TEST,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_OR,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_MOV,\n+#endif\n+#ifdef AARCH64\n+    Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_TB_X,\n+    Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_BEFORE_MOV,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_BEFORE_MOV,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_BEFORE_MOV,\n+#endif\n+\n@@ -315,1 +332,1 @@\n-  void pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS);\n+  bool pd_relocate(address pc, jint mark);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -900,1 +900,3 @@\n-      assert(cp->tag_at(index).is_unresolved_klass(), \"wrong tag\");\n+      if (!tag.is_unresolved_klass()) {\n+        JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Expected %d at index %d, got %d\", JVM_CONSTANT_UnresolvedClassInError, index, tag.value()));\n+      }\n@@ -1211,4 +1213,12 @@\n-  JVMCINMethodHandle nmethod_handle(THREAD);\n-  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n-  if (nm == nullptr || !nm->is_in_use()) {\n-    JVMCI_THROW_NULL(InvalidInstalledCodeException);\n+  methodHandle mh;\n+  {\n+    \/\/ Reduce the scope of JVMCINMethodHandle so that it isn't alive across the Java call.  Once the\n+    \/\/ nmethod has been validated and the method is fetched from the nmethod it's fine for the\n+    \/\/ nmethod to be reclaimed if necessary.\n+    JVMCINMethodHandle nmethod_handle(THREAD);\n+    nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n+    if (nm == nullptr || !nm->is_in_use()) {\n+      JVMCI_THROW_NULL(InvalidInstalledCodeException);\n+    }\n+    methodHandle nmh(THREAD, nm->method());\n+    mh = nmh;\n@@ -1216,1 +1226,0 @@\n-  methodHandle mh(THREAD, nm->method());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,4 @@\n+    static address ZPointerVectorLoadBadMask_address;\n+    static address ZPointerVectorStoreBadMask_address;\n+    static address ZPointerVectorStoreGoodMask_address;\n+\n@@ -103,0 +107,7 @@\n+#if INCLUDE_ZGC\n+    static int sizeof_ZStoreBarrierEntry;\n+#endif\n+\n+#ifdef X86\n+    static int L1_line_size;\n+#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n@@ -83,0 +85,4 @@\n+address CompilerToVM::Data::ZPointerVectorLoadBadMask_address;\n+address CompilerToVM::Data::ZPointerVectorStoreBadMask_address;\n+address CompilerToVM::Data::ZPointerVectorStoreGoodMask_address;\n+\n@@ -111,0 +117,4 @@\n+#ifdef X86\n+int CompilerToVM::Data::L1_line_size;\n+#endif\n+\n@@ -120,0 +130,3 @@\n+#if INCLUDE_ZGC\n+int CompilerToVM::Data::sizeof_ZStoreBarrierEntry = sizeof(ZStoreBarrierEntry);\n+#endif\n@@ -160,9 +173,17 @@\n-    thread_address_bad_mask_offset = in_bytes(XThreadLocalData::address_bad_mask_offset());\n-    ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded =                     XBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded =                XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded =             XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded =                XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded =           XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded =        XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_load_barrier_on_oop_array =                               XBarrierSetRuntime::load_barrier_on_oop_array_addr();\n-    ZBarrierSetRuntime_clone =                                                   XBarrierSetRuntime::clone_addr();\n+    if (ZGenerational) {\n+      ZPointerVectorLoadBadMask_address   = (address) &ZPointerVectorLoadBadMask;\n+      ZPointerVectorStoreBadMask_address  = (address) &ZPointerVectorStoreBadMask;\n+      ZPointerVectorStoreGoodMask_address = (address) &ZPointerVectorStoreGoodMask;\n+    } else {\n+      thread_address_bad_mask_offset = in_bytes(XThreadLocalData::address_bad_mask_offset());\n+      \/\/ Initialize the old names for compatibility.  The proper XBarrierSetRuntime names are\n+      \/\/ exported as addresses in vmStructs_jvmci.cpp as are the new ZBarrierSetRuntime names.\n+      ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded              = XBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded         = XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded      = XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded         = XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded    = XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded = XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_load_barrier_on_oop_array                        = XBarrierSetRuntime::load_barrier_on_oop_array_addr();\n+      ZBarrierSetRuntime_clone                                            = XBarrierSetRuntime::clone_addr();\n+    }\n@@ -226,0 +247,4 @@\n+#ifdef X86\n+  L1_line_size = VM_Version::L1_line_size();\n+#endif\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -877,1 +877,1 @@\n-      guarantee(*oop_ptr != nullptr, \"unexpected cleared handle\");\n+      guarantee(NativeAccess<>::oop_load(oop_ptr) != nullptr, \"unexpected cleared handle\");\n@@ -892,1 +892,1 @@\n-  return handle != nullptr && *handle != nullptr;\n+  return handle != nullptr && NativeAccess<>::oop_load(handle) != nullptr;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  return UseSerialGC || UseParallelGC || UseG1GC || (UseZGC && !ZGenerational);\n+  return UseSerialGC || UseParallelGC || UseG1GC || UseZGC || UseEpsilonGC;\n@@ -233,3 +233,1 @@\n-      log_warning(gc, jvmci)(\"Setting EnableJVMCI to false as selected GC does not support JVMCI: %s\", GCConfig::hs_err_name());\n-      FLAG_SET_DEFAULT(EnableJVMCI, false);\n-      FLAG_SET_DEFAULT(UseJVMCICompiler, false);\n+      fatal(\"JVMCI does not support the selected GC\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n@@ -49,0 +50,6 @@\n+#if INCLUDE_ZGC\n+#include \"gc\/x\/xBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n+#endif\n@@ -69,0 +76,1 @@\n+  AARCH64_ONLY(static_field(CompilerToVM::Data, BarrierSetAssembler_patching_epoch_addr, address))                                   \\\n@@ -79,0 +87,4 @@\n+  static_field(CompilerToVM::Data,             ZPointerVectorLoadBadMask_address, address)                                           \\\n+  static_field(CompilerToVM::Data,             ZPointerVectorStoreBadMask_address, address)                                          \\\n+  static_field(CompilerToVM::Data,             ZPointerVectorStoreGoodMask_address, address)                                         \\\n+                                                                                                                                     \\\n@@ -103,0 +115,2 @@\n+  X86_ONLY(static_field(CompilerToVM::Data,    L1_line_size,                           int))                                         \\\n+                                                                                                                                     \\\n@@ -112,0 +126,1 @@\n+  ZGC_ONLY(static_field(CompilerToVM::Data,    sizeof_ZStoreBarrierEntry,              int))                                         \\\n@@ -769,0 +784,1 @@\n+  declare_constant(vmIntrinsics::_linkToNative)                           \\\n@@ -790,1 +806,6 @@\n-#define VM_ADDRESSES(declare_address, declare_preprocessor_address, declare_function) \\\n+\/\/ Helper macro to support ZGC pattern where the function itself isn't exported\n+#define DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, name) \\\n+  declare_function_with_value(name, name##_addr())\n+\n+\n+#define VM_ADDRESSES(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -807,0 +828,20 @@\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_field_preloaded))                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded))              \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded))            \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded))         \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_array))                                \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::clone))                                                    \\\n+                                                                                                                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded))                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded))              \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_store_good))           \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_load_barrier_on_weak_oop_field_preloaded))    \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_load_barrier_on_phantom_oop_field_preloaded)) \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing))        \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_oop_field_with_healing))                  \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_oop_field_without_healing))               \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_array))                                \\\n+                                                                          \\\n@@ -857,0 +898,26 @@\n+#if INCLUDE_ZGC\n+\n+#define VM_INT_CONSTANTS_JVMCI_ZGC(declare_constant, declare_constant_with_value, declare_preprocessor_constant)                           \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_good_mask_offset\" , in_bytes(ZThreadLocalData::store_good_mask_offset()))           \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_bad_mask_offset\" , in_bytes(ZThreadLocalData::store_bad_mask_offset()))             \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_barrier_buffer_offset\" , in_bytes(ZThreadLocalData::store_barrier_buffer_offset())) \\\n+  declare_constant_with_value(\"ZStoreBarrierBuffer::current_offset\" , in_bytes(ZStoreBarrierBuffer::current_offset()))                     \\\n+  declare_constant_with_value(\"ZStoreBarrierBuffer::buffer_offset\" , in_bytes(ZStoreBarrierBuffer::buffer_offset()))                       \\\n+  declare_constant_with_value(\"ZStoreBarrierEntry::p_offset\" , in_bytes(ZStoreBarrierEntry::p_offset()))                                   \\\n+  declare_constant_with_value(\"ZStoreBarrierEntry::prev_offset\" , in_bytes(ZStoreBarrierEntry::prev_offset()))                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_SHL))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_BAD_AFTER_TEST))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_AFTER_TEST))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_CMP))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_AFTER_TEST))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_OR))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_MOV))                                            \\\n+  AARCH64_ONLY(declare_constant(ZPointerLoadShift))                                                                                        \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_TB_X))                                         \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_BEFORE_MOV))                                           \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_BEFORE_MOV))                                         \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_BEFORE_MOV))\n+\n+#endif \/\/ INCLUDE_ZGC\n+\n+\n@@ -859,1 +926,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function) \\\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -867,1 +934,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function) \\\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -918,1 +985,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function)\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value)\n@@ -925,0 +992,4 @@\n+#define GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY(name, value) \\\n+  { QUOTE(name), CAST_FROM_FN_PTR(void*, value) },\n+\n+\n@@ -975,0 +1046,5 @@\n+#if INCLUDE_ZGC\n+  VM_INT_CONSTANTS_JVMCI_ZGC(GENERATE_VM_INT_CONSTANT_ENTRY,\n+                              GENERATE_VM_INT_CONSTANT_WITH_VALUE_ENTRY,\n+                              GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+#endif\n@@ -1000,1 +1076,2 @@\n-               GENERATE_VM_FUNCTION_ENTRY)\n+               GENERATE_VM_FUNCTION_ENTRY,\n+               GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY)\n@@ -1003,1 +1080,2 @@\n-                  GENERATE_VM_FUNCTION_ENTRY)\n+                  GENERATE_VM_FUNCTION_ENTRY,\n+                  GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":84,"deletions":6,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-  QuickSort::sort(suggestions, nsuggestions, sc, false);\n+  QuickSort::sort(suggestions, nsuggestions, sc);\n","filename":"src\/hotspot\/share\/logging\/logSelection.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,1 +212,6 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) : _flags(flag), _tag(tag), _size_in_bytes(0)  {\n+Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) :\n+  _flags(flag), _tag(tag),\n+  _size_in_bytes(0),\n+  _first(nullptr), _chunk(nullptr),\n+  _hwm(nullptr), _max(nullptr)\n+{\n@@ -222,9 +227,0 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag) : _flags(flag), _tag(tag), _size_in_bytes(0) {\n-  _chunk = ChunkPool::allocate_chunk(Chunk::init_size, AllocFailStrategy::EXIT_OOM);\n-  _first = _chunk;\n-  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n-  _max = _chunk->top();\n-  MemTracker::record_new_arena(flag);\n-  set_size_in_bytes(Chunk::init_size);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+private:\n+  const MEMFLAGS _flags;        \/\/ Memory tracking flags\n+  const Tag _tag;\n+  size_t _size_in_bytes;        \/\/ Size of arena (used for native memory tracking)\n+\n@@ -102,3 +107,0 @@\n-  MEMFLAGS    _flags;           \/\/ Memory tracking flags\n-  const Tag _tag;\n-  uint32_t _init_size;\n@@ -109,0 +111,1 @@\n+\n@@ -111,1 +114,0 @@\n-  size_t _size_in_bytes;        \/\/ Size of arena (used for native memory tracking)\n@@ -127,2 +129,1 @@\n-  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other);\n-  Arena(MEMFLAGS memflag, Tag tag, size_t init_size);\n+  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other, size_t init_size = Chunk::init_size);\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,3 +120,0 @@\n-#ifdef ASSERT\n-  , _first_fence(nullptr)\n-#endif\n@@ -131,6 +128,0 @@\n-#ifdef ASSERT\n-  SOMETIMES(verify();)\n-  if (Settings::use_allocation_guard()) {\n-    verify_allocation_guards();\n-  }\n-#endif\n@@ -138,1 +129,0 @@\n-\n@@ -242,17 +232,0 @@\n-#ifdef ASSERT\n-  \/\/ Fence allocation\n-  if (p != nullptr && Settings::use_allocation_guard()) {\n-    STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n-    MetaWord* guard = allocate_inner(sizeof(Fence) \/ BytesPerWord);\n-    if (guard != nullptr) {\n-      \/\/ Ignore allocation errors for the fence to keep coding simple. If this\n-      \/\/ happens (e.g. because right at this time we hit the Metaspace GC threshold)\n-      \/\/ we miss adding this one fence. Not a big deal. Note that his would\n-      \/\/ be pretty rare. Chances are much higher the primary allocation above\n-      \/\/ would have already failed).\n-      Fence* f = new(guard) Fence(_first_fence);\n-      _first_fence = f;\n-    }\n-  }\n-#endif \/\/ ASSERT\n-\n@@ -430,12 +403,0 @@\n-void MetaspaceArena::Fence::verify() const {\n-  assert(_eye1 == EyeCatcher && _eye2 == EyeCatcher,\n-         \"Metaspace corruption: fence block at \" PTR_FORMAT \" broken.\", p2i(this));\n-}\n-\n-void MetaspaceArena::verify_allocation_guards() const {\n-  assert(Settings::use_allocation_guard(), \"Don't call with guards disabled.\");\n-  for (const Fence* f = _first_fence; f != nullptr; f = f->next()) {\n-    f->verify();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,22 +103,0 @@\n-#ifdef ASSERT\n-  \/\/ Allocation guards: When active, arena allocations are interleaved with\n-  \/\/  fence allocations. An overwritten fence indicates a buffer overrun in either\n-  \/\/  the preceding or the following user block. All fences are linked together;\n-  \/\/  validating the fences just means walking that linked list.\n-  \/\/ Note that for the Arena, fence blocks are just another form of user blocks.\n-  class Fence {\n-    static const uintx EyeCatcher =\n-      NOT_LP64(0x77698465) LP64_ONLY(0x7769846577698465ULL); \/\/ \"META\" resp \"METAMETA\"\n-    \/\/ Two eyecatchers to easily spot a corrupted _next pointer\n-    const uintx _eye1;\n-    const Fence* const _next;\n-    NOT_LP64(uintx _dummy;)\n-    const uintx _eye2;\n-  public:\n-    Fence(const Fence* next) : _eye1(EyeCatcher), _next(next), _eye2(EyeCatcher) {}\n-    const Fence* next() const { return _next; }\n-    void verify() const;\n-  };\n-  const Fence* _first_fence;\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.hpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-DEBUG_ONLY(bool Settings::_use_allocation_guard = false;)\n-\n@@ -49,3 +47,0 @@\n-  \/\/ Off for release builds, off by default - but switchable - for debug builds.\n-  DEBUG_ONLY(_use_allocation_guard = MetaspaceGuardAllocations;)\n-\n@@ -61,1 +56,0 @@\n-  st->print_cr(\" - use_allocation_guard: %d.\", (int)use_allocation_guard());\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSettings.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,0 @@\n-  \/\/ If true, metablock allocations are guarded and periodically checked.\n-  DEBUG_ONLY(static bool _use_allocation_guard;)\n-\n@@ -69,1 +66,0 @@\n-  static bool use_allocation_guard()                          { return DEBUG_ONLY(_use_allocation_guard) NOT_DEBUG(false); }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSettings.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,11 +33,0 @@\n-void ResourceArea::bias_to(MEMFLAGS new_flags) {\n-  if (new_flags != _flags) {\n-    size_t size = size_in_bytes();\n-    MemTracker::record_arena_size_change(-ssize_t(size), _flags);\n-    MemTracker::record_arena_free(_flags);\n-    MemTracker::record_new_arena(new_flags);\n-    MemTracker::record_arena_size_change(ssize_t(size), new_flags);\n-    _flags = new_flags;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/resourceArea.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,4 +63,0 @@\n-  \/\/ Bias this resource area to specific memory type\n-  \/\/ (by default, ResourceArea is tagged as mtThread, per-thread general purpose storage)\n-  void bias_to(MEMFLAGS flags);\n-\n@@ -84,1 +80,1 @@\n-      _size_in_bytes(area->_size_in_bytes)\n+      _size_in_bytes(area->size_in_bytes())\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-        AIX_ONLY(&& os::vm_page_size() != 64*K)) {\n+        AIX_ONLY(&& (os::Aix::supports_64K_mmap_pages() || os::vm_page_size() == 4*K))) {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#ifndef SHARE_NMT_ARRAYWITHFREELIST_HPP\n+#define SHARE_NMT_ARRAYWITHFREELIST_HPP\n+\n+#include \"utilities\/growableArray.hpp\"\n+#include <type_traits>\n+\n+\/\/ A flat array of elements E, backed by C-heap, growing on-demand. It allows for\n+\/\/ returning arbitrary elements and keeps them in a freelist. Elements can be uniquely\n+\/\/ identified via array index.\n+template<typename E, MEMFLAGS flag>\n+class ArrayWithFreeList {\n+\n+  \/\/ An E must be trivially copyable and destructible, but it may be constructed\n+  \/\/ however it likes.\n+  constexpr void static_assert_E_satisfies_type_requirements() const {\n+    static_assert(std::is_trivially_copyable<E>::value && std::is_trivially_destructible<E>::value, \"must be\");\n+  }\n+\n+public:\n+  using I = int32_t;\n+  static constexpr const I nil = -1;\n+\n+private:\n+  \/\/ A free list allocator element is either a link to the next free space\n+  \/\/ or an actual element.\n+  union BackingElement {\n+    I link;\n+    E e;\n+  };\n+\n+  GrowableArrayCHeap<BackingElement, flag> _backing_storage;\n+  I _free_start;\n+\n+  bool is_in_bounds(I i) {\n+    return i >= 0 && i < _backing_storage.length();\n+  }\n+\n+public:\n+  NONCOPYABLE(ArrayWithFreeList);\n+\n+  ArrayWithFreeList(int initial_capacity = 8)\n+    : _backing_storage(initial_capacity),\n+    _free_start(nil) {}\n+\n+  template<typename... Args>\n+  I allocate(Args... args) {\n+    static_assert_E_satisfies_type_requirements();\n+    BackingElement* be;\n+    I i;\n+    if (_free_start != nil) {\n+      \/\/ Must point to already existing index\n+      be = &_backing_storage.at(_free_start);\n+      i = _free_start;\n+      _free_start = be->link;\n+    } else {\n+      \/\/ There are no free elements, allocate a new one.\n+      i = _backing_storage.append(BackingElement());\n+      be = _backing_storage.adr_at(i);\n+    }\n+\n+    ::new (be) E{args...};\n+    return i;\n+  }\n+\n+  void deallocate(I i) {\n+    static_assert_E_satisfies_type_requirements();\n+    assert(i == nil || is_in_bounds(i), \"out of bounds free\");\n+    if (i == nil) return;\n+    BackingElement& be_freed = _backing_storage.at(i);\n+    be_freed.link = _free_start;\n+    _free_start = i;\n+  }\n+\n+  E& at(I i) {\n+    static_assert_E_satisfies_type_requirements();\n+    assert(i != nil, \"null pointer dereference\");\n+    assert(is_in_bounds(i), \"out of bounds dereference\");\n+    return _backing_storage.at(i).e;\n+  }\n+};\n+\n+#endif \/\/ SHARE_NMT_ARRAYWITHFREELIST_HPP\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"logging\/logAsyncWriter.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -163,7 +163,0 @@\n-\n-  void print_on(outputStream* st) const {\n-    for (size_t i = 0; i < _count; i ++) {\n-      st->print_cr(PTR_FORMAT \"-\" PTR_FORMAT \" %s\", p2i(_ranges[i].from), p2i(_ranges[i].to),\n-          NMTUtil::flag_to_enum_name(_flags[i]));\n-    }\n-  }\n@@ -201,1 +194,10 @@\n-  st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", (uintx)thread_id, name);\n+  \/\/ avoid commas and spaces in output to ease post-processing via awk\n+  char tmp[64];\n+  stringStream ss(tmp, sizeof(tmp));\n+  ss.print(\":\" UINTX_FORMAT \"-%s\", (uintx)thread_id, name);\n+  for (int i = 0; tmp[i] != '\\0'; i++) {\n+    if (!isalnum(tmp[i])) {\n+      tmp[i] = '-';\n+    }\n+  }\n+  st->print_raw(tmp);\n@@ -233,2 +235,6 @@\n-static void print_legend(outputStream* st) {\n-#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+MappingPrintSession::MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info) :\n+    _out(st), _nmt_info(nmt_info)\n+{}\n+\n+void MappingPrintSession::print_nmt_flag_legend() const {\n+#define DO(flag, shortname, text) _out->indent(); _out->print_cr(\"%10s: %s\", shortname, text);\n@@ -239,29 +245,2 @@\n-MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info) :\n-    _out(st), _human_readable(human_readable),\n-    _total_count(0), _total_vsize(0), _nmt_info(nmt_info)\n-{}\n-\n-void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n-\n-  _total_count++;\n-\n-  const void* const vma_from = info->from();\n-  const void* const vma_to = info->to();\n-\n-  \/\/ print from, to\n-  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(vma_from), p2i(vma_to));\n-  const size_t size = pointer_delta(vma_to, vma_from, 1);\n-  _total_vsize += size;\n-\n-  \/\/ print mapping size\n-  if (_human_readable) {\n-    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n-  } else {\n-    _out->print(\"%11zu\", size);\n-  }\n-\n-  assert(info->from() <= info->to(), \"Invalid VMA\");\n-  _out->fill_to(53);\n-  info->print_OS_specific_details(_out);\n-  _out->fill_to(70);\n-\n+bool MappingPrintSession::print_nmt_info_for_region(const void* vma_from, const void* vma_to) const {\n+  int num_printed = 0;\n@@ -276,0 +255,3 @@\n+          if (num_printed > 0) {\n+            _out->put(',');\n+          }\n@@ -280,1 +262,1 @@\n-          _out->print(\" \");\n+          num_printed++;\n@@ -285,21 +267,1 @@\n-\n-  \/\/ print file name, if available\n-  const char* f = info->filename();\n-  if (f != nullptr) {\n-    _out->print_raw(f);\n-  }\n-  _out->cr();\n-}\n-\n-void MemMapPrinter::print_header(outputStream* st) {\n-  st->print(\n-#ifdef _LP64\n-  \/\/   0x0000000000000000 - 0x0000000000000000\n-      \"from                 to                 \"\n-#else\n-  \/\/   0x00000000 - 0x00000000\n-      \"from         to         \"\n-#endif\n-  );\n-  \/\/ Print platform-specific columns\n-  pd_print_header(st);\n+  return num_printed > 0;\n@@ -308,2 +270,1 @@\n-void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n-  \/\/ First collect all NMT information\n+void MemMapPrinter::print_all_mappings(outputStream* st) {\n@@ -311,2 +272,0 @@\n-  nmt_info.fill_from_nmt();\n-  DEBUG_ONLY(nmt_info.print_on(st);)\n@@ -314,3 +273,6 @@\n-  if (!MemTracker::enabled()) {\n-    st->cr();\n-    st->print_cr(\" (NMT is disabled, will not annotate mappings).\");\n+  \/\/ Prepare NMT info cache. But only do so if we print individual mappings,\n+  \/\/ otherwise, we won't need it and can save that work.\n+  if (MemTracker::enabled()) {\n+    nmt_info.fill_from_nmt();\n+  } else {\n+    st->print_cr(\"NMT is disabled. VM info not available.\");\n@@ -318,11 +280,2 @@\n-  st->cr();\n-\n-  print_legend(st);\n-  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n-  st->cr();\n-\n-  pd_print_header(st);\n-  MappingPrintClosure closure(st, human_readable, nmt_info);\n-  pd_iterate_all_mappings(closure);\n-  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n-               closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+  MappingPrintSession session(st, nmt_info);\n+  pd_print_all_mappings(session);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":34,"deletions":81,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -38,14 +38,1 @@\n-class MappingPrintInformation {\n-  const void* const _from;\n-  const void* const _to;\n-public:\n-  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n-  const void* from() const { return _from; }\n-  const void* to() const { return _to; }\n-  \/\/ Will be called for each mapping before VM annotations are printed.\n-  virtual void print_OS_specific_details(outputStream* st) const {}\n-  \/\/ If mapping is backed by a file, the name of that file\n-  virtual const char* filename() const { return nullptr; }\n-};\n-\n-class MappingPrintClosure {\n+class MappingPrintSession {\n@@ -53,3 +40,0 @@\n-  const bool _human_readable;\n-  uintx _total_count;\n-  size_t _total_vsize;\n@@ -58,4 +42,4 @@\n-  MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info);\n-  void do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n-  uintx total_count() const { return _total_count; }\n-  size_t total_vsize() const { return _total_vsize; }\n+  MappingPrintSession(outputStream* st, const CachedNMTInformation& nmt_info);\n+  bool print_nmt_info_for_region(const void* from, const void* to) const;\n+  void print_nmt_flag_legend() const;\n+  outputStream* out() const { return _out; }\n@@ -65,3 +49,1 @@\n-  static void pd_print_header(outputStream* st);\n-  static void print_header(outputStream* st);\n-  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+  static void pd_print_all_mappings(const MappingPrintSession& session);\n@@ -69,2 +51,1 @@\n-  static void mark_page_malloced(const void* p, MEMFLAGS f);\n-  static void print_all_mappings(outputStream* st, bool human_readable);\n+  static void print_all_mappings(outputStream* st);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -377,1 +377,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -431,1 +431,1 @@\n-    INDENT_BY(4, stack->print_on(out);)\n+    INDENT_BY(4, _stackprinter.print_stack(stack);)\n@@ -872,1 +872,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n@@ -907,1 +907,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"utilities\/nativeCallStack.hpp\"\n@@ -152,1 +154,1 @@\n-\n+  NativeCallStackPrinter _stackprinter;\n@@ -156,1 +158,1 @@\n-     _baseline(baseline) { }\n+     _baseline(baseline), _stackprinter(output) { }\n@@ -232,0 +234,1 @@\n+  NativeCallStackPrinter _stackprinter;\n@@ -235,1 +238,2 @@\n-    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale) { }\n+    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale),\n+    _stackprinter(output) { }\n","filename":"src\/hotspot\/share\/nmt\/memReporter.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  friend class MemoryFileTrackerTest;\n+  friend class NMTMemoryFileTrackerTest;\n@@ -51,1 +51,1 @@\n-    friend class MemoryFileTrackerTest;\n+    friend class NMTMemoryFileTrackerTest;\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+NativeCallStackPrinter::NativeCallStackPrinter(outputStream* out) :\n+    _text_storage(mtNMT, Arena::Tag::tag_other, 128 * K), _out(out)\n+{}\n+\n+void NativeCallStackPrinter::print_stack(const NativeCallStack* stack) const {\n+  for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+    const address pc = stack->get_frame(i);\n+    if (pc == nullptr) {\n+      break;\n+    }\n+    bool created = false;\n+    const char** cached_frame_text = _cache.put_if_absent(pc, &created);\n+    if (created) {\n+      stringStream ss(4 * K);\n+      stack->print_frame(&ss, pc);\n+      const size_t len = ss.size();\n+      char* store = NEW_ARENA_ARRAY(&_text_storage, char, len + 1);\n+      memcpy(store, ss.base(), len + 1);\n+      (*cached_frame_text) = store;\n+    }\n+    _out->print_raw_cr(*cached_frame_text);\n+  }\n+}\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n+#define SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n+\n+#include \"memory\/arena.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class outputStream;\n+class NativeCallStack;\n+\n+\/\/ This is a text cache for NativeCallStack frames by PC. When printing tons of\n+\/\/ NativeCallStack instances (e.g. during NMT detail reports), printing through\n+\/\/ this printer speeds up frame description resolution by quite a bit.\n+class NativeCallStackPrinter {\n+  \/\/ Cache-related data are mutable to be able to use NativeCallStackPrinter as\n+  \/\/ inline member in classes with const printing methods.\n+  mutable Arena _text_storage;\n+  mutable ResourceHashtable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n+  outputStream* const _out;\n+public:\n+  NativeCallStackPrinter(outputStream* out);\n+  void print_stack(const NativeCallStack* stack) const;\n+};\n+\n+#endif \/\/ SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n+\n+NativeCallStackStorage::StackIndex NativeCallStackStorage::put(const NativeCallStack& value) {\n+  int bucket = value.calculate_hash() % _table_size;\n+  TableEntryIndex link = _table[bucket];\n+  while (link != TableEntryStorage::nil) {\n+    TableEntry& l = _entry_storage.at(link);\n+    if (value.equals(get(l.stack))) {\n+      return l.stack;\n+    }\n+    link = l.next;\n+  }\n+  int idx = _stacks.append(value);\n+  StackIndex si{idx};\n+  TableEntryIndex new_link = _entry_storage.allocate(_table[bucket], si);\n+  _table[bucket] = new_link;\n+  return si;\n+}\n+NativeCallStackStorage::NativeCallStackStorage(bool is_detailed_mode, int table_size)\n+  : _table_size(table_size),\n+    _table(nullptr),\n+    _stacks(),\n+    _is_detailed_mode(is_detailed_mode),\n+    _fake_stack() {\n+  if (_is_detailed_mode) {\n+    _table = NEW_C_HEAP_ARRAY(TableEntryIndex, _table_size, mtNMT);\n+    for (int i = 0; i < _table_size; i++) {\n+      _table[i] = TableEntryStorage::nil;\n+    }\n+  }\n+}\n+NativeCallStackStorage::~NativeCallStackStorage() {\n+  FREE_C_HEAP_ARRAY(LinkPtr, _table);\n+}\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -28,2 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/arena.hpp\"\n+#include \"nmt\/arrayWithFreeList.hpp\"\n@@ -43,1 +42,1 @@\n-class NativeCallStackStorage : public CHeapObj<mtNMT> {\n+class NativeCallStackStorage : public CHeapObjBase {\n@@ -47,4 +46,0 @@\n-\n-  private:\n-    static constexpr const int32_t _invalid = -1;\n-\n@@ -52,4 +47,0 @@\n-    StackIndex(int32_t stack_index)\n-      : _stack_index(stack_index) {\n-    }\n-\n@@ -57,0 +48,1 @@\n+    static constexpr const int32_t invalid = -1;\n@@ -62,5 +54,1 @@\n-      return _stack_index == _invalid;\n-    }\n-\n-    StackIndex()\n-      : _stack_index(_invalid) {\n+      return _stack_index == invalid;\n@@ -71,2 +59,8 @@\n-  struct Link : public ArenaObj {\n-    Link* next;\n+  struct TableEntry;\n+  using TableEntryStorage = ArrayWithFreeList<TableEntry, mtNMT>;\n+  using TableEntryIndex = typename TableEntryStorage::I;\n+\n+  TableEntryStorage _entry_storage;\n+\n+  struct TableEntry {\n+    TableEntryIndex next;\n@@ -74,4 +68,0 @@\n-    Link(Link* next, StackIndex v)\n-      : next(next),\n-        stack(v) {\n-    }\n@@ -79,14 +69,0 @@\n-  StackIndex put(const NativeCallStack& value) {\n-    int bucket = value.calculate_hash() % _table_size;\n-    Link* link = _table[bucket];\n-    while (link != nullptr) {\n-      if (value.equals(get(link->stack))) {\n-        return link->stack;\n-      }\n-      link = link->next;\n-    }\n-    int idx = _stacks.append(value);\n-    Link* new_link = new (&_arena) Link(_table[bucket], StackIndex(idx));\n-    _table[bucket] = new_link;\n-    return new_link->stack;\n-  }\n@@ -94,2 +70,2 @@\n-  \/\/ For storage of the Links\n-  Arena _arena;\n+  StackIndex put(const NativeCallStack& value);\n+\n@@ -99,2 +75,2 @@\n-  int _table_size;\n-  Link** _table;\n+  const int _table_size;\n+  TableEntryIndex* _table;\n@@ -110,1 +86,1 @@\n-      return StackIndex();\n+      return StackIndex{StackIndex::invalid};\n@@ -122,10 +98,3 @@\n-  NativeCallStackStorage(bool is_detailed_mode, int table_size = default_table_size)\n-  : _arena(mtNMT), _table_size(table_size), _table(nullptr), _stacks(),\n-    _is_detailed_mode(is_detailed_mode), _fake_stack() {\n-    if (_is_detailed_mode) {\n-      _table = NEW_ARENA_ARRAY(&_arena, Link*, _table_size);\n-      for (int i = 0; i < _table_size; i++) {\n-        _table[i] = nullptr;\n-      }\n-    }\n-  }\n+  NativeCallStackStorage(bool is_detailed_mode, int table_size = default_table_size);\n+\n+  ~NativeCallStackStorage();\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":20,"deletions":51,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -34,1 +33,1 @@\n-#include <stdint.h>\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -56,2 +55,2 @@\n-  friend class VMATreeTest;\n-  friend class TreapTest;\n+  friend class NMTVMATreeTest;\n+  friend class NMTTreapTest;\n@@ -87,0 +86,3 @@\n+\n+  \/\/ A random number\n+  static constexpr const uint64_t _initial_seed = 0xC8DD2114AE0543A3;\n@@ -91,6 +93,3 @@\n-    \/\/ Taken directly off of JFRPrng\n-    static const constexpr uint64_t PrngMult = 0x5DEECE66DLL;\n-    static const constexpr uint64_t PrngAdd = 0xB;\n-    static const constexpr uint64_t PrngModPower = 48;\n-    static const constexpr uint64_t PrngModMask = (static_cast<uint64_t>(1) << PrngModPower) - 1;\n-    _prng_seed = (PrngMult * _prng_seed + PrngAdd) & PrngModMask;\n+    uint64_t first_half = os::next_random(_prng_seed);\n+    uint64_t second_half = os::next_random(_prng_seed >> 32);\n+    _prng_seed = first_half | (second_half << 32);\n@@ -176,1 +175,1 @@\n-    \/\/ We take the ceiling of log_2(N + 1) * 2.5 as our maximum bound.\n+    \/\/ We take the ceiling of log_2(N + 1) * 3 as our maximum bound.\n@@ -178,1 +177,1 @@\n-    const int expected_maximum_depth = ceil((log(this->_node_count+1) \/ log(2)) * 2.5);\n+    const int expected_maximum_depth = ceil(log2i(this->_node_count+1) * 3);\n@@ -228,2 +227,1 @@\n-  Treap(uint64_t seed = static_cast<uint64_t>(os::random())\n-                        | (static_cast<uint64_t>(os::random()) << 32))\n+  Treap()\n@@ -232,1 +230,1 @@\n-    _prng_seed(seed),\n+    _prng_seed(_initial_seed),\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n@@ -682,0 +683,1 @@\n+  NativeCallStackPrinter      _stackprinter;\n@@ -684,1 +686,1 @@\n-    _p((address)p), _st(st) { }\n+    _p((address)p), _st(st), _stackprinter(st) { }\n@@ -691,1 +693,1 @@\n-        rgn->call_stack()->print_on(_st);\n+        _stackprinter.print_stack(rgn->call_stack());\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  friend class VMATreeTest;\n+  friend class NMTVMATreeTest;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -59,0 +60,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -177,1 +179,1 @@\n-             method->method_holder()->is_init_thread(JavaThread::current()),\n+             method->method_holder()->is_reentrant_initialization(JavaThread::current()),\n@@ -273,0 +275,1 @@\n+\n@@ -275,2 +278,0 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n-  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -278,0 +279,10 @@\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle resolved_references(current, constant_pool()->resolved_references());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n+\n+  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -315,1 +326,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n@@ -403,3 +413,1 @@\n-    for (int i = 0; i < _resolved_method_entries->length(); i++) {\n-      resolved_method_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_method_entries_if_non_deterministic();\n@@ -443,0 +451,90 @@\n+\n+void ConstantPoolCache::remove_resolved_method_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_method_entries->length(); i++) {\n+    ResolvedMethodEntry* rme = _resolved_method_entries->adr_at(i);\n+    int cp_index = rme->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rme->is_resolved(Bytecodes::_invokevirtual)   ||\n+                    rme->is_resolved(Bytecodes::_invokespecial)   ||\n+                    rme->is_resolved(Bytecodes::_invokeinterface);\n+\n+    \/\/ Just for safety -- this should not happen, but do not archive if we ever see this.\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n+                  rme->is_resolved(Bytecodes::_invokestatic));\n+\n+    if (resolved && can_archive_resolved_method(rme)) {\n+      rme->mark_and_relocate(src_cp);\n+      archived = true;\n+    } else {\n+      rme->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+        if (archived) {\n+          Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n+          log.print(\" => %s%s\",\n+                    resolved_klass->name()->as_C_string(),\n+                    (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n+        }\n+      }\n+      ArchiveBuilder::alloc_stats()->record_method_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+  InstanceKlass* pool_holder = constant_pool()->pool_holder();\n+  if (!(pool_holder->is_shared_boot_class() || pool_holder->is_shared_platform_class() ||\n+        pool_holder->is_shared_app_class())) {\n+    \/\/ Archiving resolved cp entries for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return false;\n+  }\n+\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    \/\/ InstanceKlass::methods() has been resorted. We need to\n+    \/\/ update the vtable_index in method_entry (not implemented)\n+    return false;\n+  }\n+\n+  if (!method_entry->is_resolved(Bytecodes::_invokevirtual)) {\n+    if (method_entry->method() == nullptr) {\n+      return false;\n+    }\n+    if (method_entry->method()->is_continuation_native_intrinsic()) {\n+      return false; \/\/ FIXME: corresponding stub is generated on demand during method resolution (see LinkResolver::resolve_static_call).\n+    }\n+  }\n+\n+  int cp_index = method_entry->constant_pool_index();\n+  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n+  assert(src_cp->tag_at(cp_index).is_method() || src_cp->tag_at(cp_index).is_interface_method(), \"sanity\");\n+\n+  if (!ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+    return false;\n+  }\n+\n+  if (method_entry->is_resolved(Bytecodes::_invokeinterface) ||\n+      method_entry->is_resolved(Bytecodes::_invokevirtual) ||\n+      method_entry->is_resolved(Bytecodes::_invokespecial)) {\n+    return true;\n+  } else {\n+    \/\/ invokestatic and invokehandle are not supported yet.\n+    return false;\n+  }\n+\n+}\n@@ -591,1 +689,8 @@\n-  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = THREAD;\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -614,1 +719,11 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n+\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = JavaThread::current();\n+  constantPoolHandle cp(current, constant_pool());\n+\n+  objArrayHandle resolved_references(current, cp->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -618,1 +733,1 @@\n-    return constant_pool()->resolved_reference_from_indy(index);\n+    return cp->resolved_reference_from_indy(index);\n@@ -626,3 +741,1 @@\n-    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-    constantPoolHandle cp(THREAD, constant_pool());\n-    ConstantPool::throw_resolution_error(cp, encoded_index, THREAD);\n+    ConstantPool::throw_resolution_error(cp, encoded_index, current);\n@@ -652,1 +765,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":126,"deletions":14,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,2 @@\n+  void remove_resolved_method_entries_if_non_deterministic();\n+  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsEnumKlass.hpp\"\n@@ -90,0 +91,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -547,3 +549,0 @@\n-static Monitor* create_init_monitor(const char* name) {\n-  return new Monitor(Mutex::safepoint, name);\n-}\n@@ -567,1 +566,0 @@\n-  _init_monitor(create_init_monitor(\"InstanceKlassInitMonitor_lock\")),\n@@ -819,0 +817,22 @@\n+oop InstanceKlass::init_lock() const {\n+  \/\/ return the init lock from the mirror\n+  oop lock = java_lang_Class::init_lock(java_mirror());\n+  \/\/ Prevent reordering with any access of initialization state\n+  OrderAccess::loadload();\n+  assert(lock != nullptr || !is_not_initialized(), \/\/ initialized or in_error state\n+         \"only fully initialized state can have a null lock\");\n+  return lock;\n+}\n+\n+\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n+\/\/ threads to get this lock will see a null lock and will not lock.\n+\/\/ That's okay because they all check for initialized state after getting\n+\/\/ the lock and return.\n+void InstanceKlass::fence_and_clear_init_lock() {\n+  \/\/ make sure previous stores are all done, notably the init_state.\n+  OrderAccess::storestore();\n+  java_lang_Class::clear_init_lock(java_mirror());\n+  assert(!is_not_initialized(), \"class must be initialized now\");\n+}\n+\n+\n@@ -846,43 +866,0 @@\n-void InstanceKlass::check_link_state_and_wait(JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n-\n-  \/\/ Another thread is linking this class, wait.\n-  while (is_being_linked() && !is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" waiting for linking of %s by thread \\\"%s\\\"\",\n-                             current->name(), external_name(), init_thread_name());\n-    }\n-    ml.wait();\n-  }\n-\n-  \/\/ This thread is recursively linking this class, continue\n-  if (is_being_linked() && is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" recursively linking %s\",\n-                             current->name(), external_name());\n-    }\n-    return;\n-  }\n-\n-  \/\/ If this class wasn't linked already, set state to being_linked\n-  if (!is_linked()) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" linking %s\",\n-                             current->name(), external_name());\n-    }\n-    set_init_state(being_linked);\n-    set_init_thread(current);\n-  } else {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" found %s already linked\",\n-                             current->name(), external_name());\n-      }\n-  }\n-}\n-\n@@ -1069,2 +1046,3 @@\n-    LockLinkState init_lock(this, jt);\n-\n+    HandleMark hm(THREAD);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1128,1 +1106,15 @@\n-      set_initialization_state_and_notify(linked, THREAD);\n+      if (Universe::is_fully_initialized()) {\n+        DeoptimizationScope deopt_scope;\n+        {\n+          \/\/ Now mark all code that assumes the class is not linked.\n+          \/\/ Set state under the Compile_lock also.\n+          MutexLocker ml(THREAD, Compile_lock);\n+\n+          set_init_state(linked);\n+          CodeCache::mark_dependents_on(&deopt_scope, this);\n+        }\n+        \/\/ Perform the deopt handshake outside Compile_lock.\n+        deopt_scope.deoptimize_marked();\n+      } else {\n+        set_init_state(linked);\n+      }\n@@ -1260,1 +1252,0 @@\n-  bool throw_error = false;\n@@ -1269,1 +1260,2 @@\n-    MonitorLocker ml(jt, _init_monitor);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1272,1 +1264,4 @@\n-    while (is_being_initialized() && !is_init_thread(jt)) {\n+    \/\/ If we were to use wait() instead of waitInterruptibly() then\n+    \/\/ we might end up throwing IE from link\/symbol resolution sites\n+    \/\/ that aren't expected to throw.  This would wreak havoc.  See 6320309.\n+    while (is_being_initialized() && !is_reentrant_initialization(jt)) {\n@@ -1278,1 +1273,0 @@\n-\n@@ -1281,1 +1275,1 @@\n-      ml.wait();\n+      ol.wait_uninterruptibly(jt);\n@@ -1286,1 +1280,1 @@\n-    if (is_being_initialized() && is_init_thread(jt)) {\n+    if (is_being_initialized() && is_reentrant_initialization(jt)) {\n@@ -1314,1 +1308,13 @@\n-      throw_error = true;\n+\n+      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n+      ResourceMark rm(THREAD);\n+      Handle cause(THREAD, get_initialization_error(THREAD));\n+\n+      stringStream ss;\n+      ss.print(\"Could not initialize class %s\", external_name());\n+      if (cause.is_null()) {\n+        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n+      } else {\n+        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                        ss.as_string(), cause);\n+      }\n@@ -1328,16 +1334,0 @@\n-  \/\/ Throw error outside lock\n-  if (throw_error) {\n-    DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n-    ResourceMark rm(THREAD);\n-    Handle cause(THREAD, get_initialization_error(THREAD));\n-\n-    stringStream ss;\n-    ss.print(\"Could not initialize class %s\", external_name());\n-    if (cause.is_null()) {\n-      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n-    } else {\n-      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n-                      ss.as_string(), cause);\n-    }\n-  }\n-\n@@ -1452,1 +1442,1 @@\n-    set_initialization_state_and_notify(fully_initialized, THREAD);\n+    set_initialization_state_and_notify(fully_initialized, CHECK);\n@@ -1485,17 +1475,8 @@\n-void InstanceKlass::set_initialization_state_and_notify(ClassState state, JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  if (state == linked && UseVtableBasedCHA && Universe::is_fully_initialized()) {\n-    DeoptimizationScope deopt_scope;\n-    {\n-      \/\/ Now mark all code that assumes the class is not linked.\n-      \/\/ Set state under the Compile_lock also.\n-      MutexLocker ml(current, Compile_lock);\n-\n-      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-      set_init_state(state);\n-\n-      CodeCache::mark_dependents_on(&deopt_scope, this);\n-    }\n-    \/\/ Perform the deopt handshake outside Compile_lock.\n-    deopt_scope.deoptimize_marked();\n+void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {\n+  Handle h_init_lock(THREAD, init_lock());\n+  if (h_init_lock() != nullptr) {\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+    set_init_state(state);\n+    fence_and_clear_init_lock();\n+    ol.notify_all(CHECK);\n@@ -1503,0 +1484,1 @@\n+    assert(h_init_lock() != nullptr, \"The initialization state should never be set twice\");\n@@ -1506,1 +1488,0 @@\n-  ml.notify_all();\n@@ -1514,8 +1495,0 @@\n-  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n-  \/\/ deopt is completed before anyone links this class.\n-  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n-  \/\/ held we make sure the deopt is completed before linking.\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->lock();\n-  }\n-\n@@ -1543,4 +1516,0 @@\n-\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->unlock();\n-  }\n@@ -1549,0 +1518,1 @@\n+\n@@ -1834,1 +1804,1 @@\n-    bool initialized = HeapShared::initialize_enum_klass(this, CHECK);\n+    bool initialized = CDSEnumKlass::initialize_enum_klass(this, CHECK);\n@@ -2829,1 +2799,0 @@\n-  _init_monitor = nullptr;\n@@ -2937,3 +2906,0 @@\n-\n-  \/\/ restore the monitor\n-  _init_monitor = create_init_monitor(\"InstanceKlassInitMonitorRestored_lock\");\n@@ -3035,3 +3001,0 @@\n-  \/\/ Destroy the init_monitor\n-  delete _init_monitor;\n-\n@@ -3731,1 +3694,1 @@\n-  \"allocated\", \"loaded\", \"being_linked\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n+  \"allocated\", \"loaded\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n@@ -3828,5 +3791,3 @@\n-  if (default_vtable_indices() != nullptr) {\n-    st->print(BULLET\"default vtable indices:   \"); print_array_on(st, default_vtable_indices());\n-  }\n-  st->print(BULLET\"local interfaces:  \"); print_array_on(st, local_interfaces());\n-  st->print(BULLET\"trans. interfaces: \"); print_array_on(st, transitive_interfaces());\n+  print_on_maybe_null(st, BULLET\"default vtable indices:   \", default_vtable_indices());\n+  st->print(BULLET\"local interfaces:  \"); local_interfaces()->print_value_on(st);      st->cr();\n+  st->print(BULLET\"trans. interfaces: \"); transitive_interfaces()->print_value_on(st); st->cr();\n@@ -3857,10 +3818,3 @@\n-  if (class_loader_data() != nullptr) {\n-    st->print(BULLET\"class loader data:  \");\n-    class_loader_data()->print_value_on(st);\n-    st->cr();\n-  }\n-  if (source_file_name() != nullptr) {\n-    st->print(BULLET\"source file:       \");\n-    source_file_name()->print_value_on(st);\n-    st->cr();\n-  }\n+\n+  print_on_maybe_null(st, BULLET\"class loader data:  \", class_loader_data());\n+  print_on_maybe_null(st, BULLET\"source file:       \", source_file_name());\n@@ -3872,4 +3826,4 @@\n-  st->print(BULLET\"class annotations:       \"); class_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"class type annotations:  \"); class_type_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"field annotations:       \"); fields_annotations()->print_value_on(st); st->cr();\n-  st->print(BULLET\"field type annotations:  \"); fields_type_annotations()->print_value_on(st); st->cr();\n+  print_on_maybe_null(st, BULLET\"class annotations:       \", class_annotations());\n+  print_on_maybe_null(st, BULLET\"class type annotations:  \", class_type_annotations());\n+  print_on_maybe_null(st, BULLET\"field annotations:       \", fields_annotations());\n+  print_on_maybe_null(st, BULLET\"field type annotations:  \", fields_type_annotations());\n@@ -3890,5 +3844,1 @@\n-  if (generic_signature() != nullptr) {\n-    st->print(BULLET\"generic signature: \");\n-    generic_signature()->print_value_on(st);\n-    st->cr();\n-  }\n+  print_on_maybe_null(st, BULLET\"generic signature: \", generic_signature());\n@@ -3897,3 +3847,1 @@\n-  if (record_components() != nullptr) {\n-    st->print(BULLET\"record components:     \"); record_components()->print_value_on(st);     st->cr();\n-  }\n+  print_on_maybe_null(st, BULLET\"record components:     \", record_components());\n@@ -4405,3 +4353,0 @@\n-  if (state > loaded) {\n-    assert_lock_strong(_init_monitor);\n-  }\n@@ -4411,2 +4356,1 @@\n-  bool link_failed = _init_state == being_linked && state == loaded;\n-  assert(good_state || state == allocated || link_failed, \"illegal state transition\");\n+  assert(good_state || state == allocated, \"illegal state transition\");\n@@ -4415,1 +4359,1 @@\n-  Atomic::store(&_init_state, state);\n+  _init_state = state;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":90,"deletions":146,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-    being_linked,                       \/\/ currently running verifier and rewriter\n@@ -251,0 +250,7 @@\n+  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n+  \/\/ _misc_flags.\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n+\n+  \/\/ Class states are defined as ClassState (see above).\n+  \/\/ Place the _init_state here to utilize the unused 2-byte after\n+  \/\/ _idnum_allocated_count.\n@@ -253,1 +259,1 @@\n-  u1              _reference_type;          \/\/ reference type\n+  u1              _reference_type;                \/\/ reference type\n@@ -258,1 +264,0 @@\n-  Monitor*             _init_monitor;       \/\/ mutual exclusion to _init_state and _init_thread.\n@@ -558,1 +563,0 @@\n-  \/\/ We can safely access the name as long as we hold the _init_monitor.\n@@ -560,1 +564,0 @@\n-    assert(_init_monitor->owned_by_self(), \"Must hold _init_monitor here\");\n@@ -566,9 +569,8 @@\n-  bool is_loaded() const                   { return init_state() >= loaded; }\n-  bool is_linked() const                   { return init_state() >= linked; }\n-  bool is_being_linked() const             { return init_state() == being_linked; }\n-  bool is_initialized() const              { return init_state() == fully_initialized; }\n-  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n-  bool is_being_initialized() const        { return init_state() == being_initialized; }\n-  bool is_in_error_state() const           { return init_state() == initialization_error; }\n-  bool is_init_thread(JavaThread *thread)  { return thread == init_thread(); }\n-  ClassState  init_state() const           { return Atomic::load(&_init_state); }\n+  bool is_loaded() const                   { return _init_state >= loaded; }\n+  bool is_linked() const                   { return _init_state >= linked; }\n+  bool is_initialized() const              { return _init_state == fully_initialized; }\n+  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n+  bool is_being_initialized() const        { return _init_state == being_initialized; }\n+  bool is_in_error_state() const           { return _init_state == initialization_error; }\n+  bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }\n+  ClassState  init_state() const           { return _init_state; }\n@@ -578,15 +580,0 @@\n-  class LockLinkState : public StackObj {\n-    InstanceKlass* _ik;\n-    JavaThread*    _current;\n-   public:\n-    LockLinkState(InstanceKlass* ik, JavaThread* current) : _ik(ik), _current(current) {\n-      ik->check_link_state_and_wait(current);\n-    }\n-    ~LockLinkState() {\n-      if (!_ik->is_linked()) {\n-        \/\/ Reset to loaded if linking failed.\n-        _ik->set_initialization_state_and_notify(loaded, _current);\n-      }\n-    }\n-  };\n-\n@@ -893,1 +880,1 @@\n-  void set_initialization_state_and_notify(ClassState state, JavaThread* current);\n+  void set_initialization_state_and_notify(ClassState state, TRAPS);\n@@ -905,0 +892,1 @@\n+ public:\n@@ -1139,1 +1127,1 @@\n- private:\n+private:\n@@ -1156,0 +1144,6 @@\n+  \/\/ Lock for (1) initialization; (2) access to the ConstantPool of this class.\n+  \/\/ Must be one per class and it has to be a VM internal object so java code\n+  \/\/ cannot lock it (like the mirror).\n+  \/\/ It has to be an object not a Mutex because it's held through java calls.\n+  oop init_lock() const;\n+\n@@ -1165,2 +1159,0 @@\n-\n-  Monitor* init_monitor() const { return _init_monitor; }\n@@ -1168,1 +1160,2 @@\n-  void check_link_state_and_wait(JavaThread* current);\n+  void fence_and_clear_init_lock();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -164,5 +164,0 @@\n-  \/\/ Bitmap and hash code used by hashed secondary supers.\n-  uintx    _bitmap;\n-  uint8_t  _hash_slot;\n-\n-  static uint8_t compute_hash_slot(Symbol* s);\n@@ -179,0 +174,4 @@\n+  \/\/ Bitmap and hash code used by hashed secondary supers.\n+  uintx    _bitmap;\n+  uint8_t  _hash_slot;\n+\n@@ -398,0 +397,1 @@\n+  static uint8_t compute_hash_slot(Symbol* s);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,0 +79,9 @@\n+template <typename M>\n+static void print_on_maybe_null(outputStream* st, const char* str, const M* m) {\n+  if (nullptr != m) {\n+    st->print_raw(str);\n+    m->print_value_on(st);\n+    st->cr();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/metadata.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1795,1 +1795,1 @@\n-      QuickSort::sort(methods->data(), length, func, \/*idempotent=*\/false);\n+      QuickSort::sort(methods->data(), length, func);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2181,1 +2181,0 @@\n-private:\n@@ -2315,1 +2314,0 @@\n-  int                _jvmci_ir_size;\n@@ -2317,0 +2315,1 @@\n+  int                _jvmci_ir_size;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,15 @@\n+  void copy_from(const ResolvedMethodEntry& other) {\n+    _method = other._method;\n+    _entry_specific = other._entry_specific;\n+    _cpool_index = other._cpool_index;\n+    _number_of_parameters = other._number_of_parameters;\n+    _tos_state = other._tos_state;\n+    _flags = other._flags;\n+    _bytecode1 = other._bytecode1;\n+    _bytecode2 = other._bytecode2;\n+#ifdef ASSERT\n+    _has_interface_klass = other._has_interface_klass;\n+    _has_table_index = other._has_table_index;\n+#endif\n+  }\n+\n@@ -102,0 +117,10 @@\n+    ResolvedMethodEntry(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+    }\n+\n+    ResolvedMethodEntry& operator=(const ResolvedMethodEntry& other) {\n+      copy_from(other);\n+      return *this;\n+    }\n+\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  AddNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  AddNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -168,1 +168,1 @@\n-  AddPNode( Node *base, Node *ptr, Node *off ) : Node(0,base,ptr,off) {\n+  AddPNode( Node *base, Node *ptr, Node *off ) : Node(nullptr,base,ptr,off) {\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,1 @@\n-      _idom(0),\n+      _idom(nullptr),\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2172,0 +2172,16 @@\n+\/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+bool AbstractLockNode::is_balanced() {\n+  Node* obj = obj_node();\n+  for (uint j = 0; j < obj->outcnt(); j++) {\n+    Node* n = obj->raw_out(j);\n+    if (n->is_AbstractLock() &&\n+        n->as_AbstractLock()->obj_node()->eqv_uncast(obj)) {\n+      BoxLockNode* n_box = n->as_AbstractLock()->box_node()->as_BoxLock();\n+      if (n_box->is_unbalanced()) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2279,0 +2295,2 @@\n+            tty->print(\"Obj: \");\n+            obj_node()->dump();\n@@ -2287,0 +2305,2 @@\n+              tty->print(\"Box %d: \", i);\n+              box_node()->dump();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1203,0 +1203,4 @@\n+  \/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+  \/\/ They can become unbalanced after coarsening optimization or on OSR entry.\n+  bool is_balanced();\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+enum class AssertionPredicateType;\n@@ -243,1 +244,1 @@\n-  virtual bool pinned() const { return in(0) != 0; }\n+  virtual bool pinned() const { return in(0) != nullptr; }\n@@ -331,0 +332,13 @@\n+ public:\n+  float _prob;                           \/\/ Probability of true path being taken.\n+  float _fcnt;                           \/\/ Frequency counter\n+\n+ private:\n+  NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+\n+  void init_node(Node* control, Node* bol) {\n+    init_class_id(Class_If);\n+    init_req(0, control);\n+    init_req(1, bol);\n+  }\n+\n@@ -335,1 +349,0 @@\n-private:\n@@ -426,8 +439,2 @@\n-  float _prob;                  \/\/ Probability of true path being taken.\n-  float _fcnt;                  \/\/ Frequency counter\n-  IfNode( Node *control, Node *b, float p, float fcnt )\n-    : MultiBranchNode(2), _prob(p), _fcnt(fcnt) {\n-    init_class_id(Class_If);\n-    init_req(0,control);\n-    init_req(1,b);\n-  }\n+  IfNode(Node* control, Node* bol, float p, float fcnt);\n+  NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n@@ -465,1 +472,1 @@\n-  int is_range_check(Node* &range, Node* &index, jint &offset);\n+  int is_range_check(Node*& range, Node*& index, jint& offset);\n@@ -468,2 +475,7 @@\n-  RangeCheckNode(Node* control, Node *b, float p, float fcnt)\n-    : IfNode(control, b, p, fcnt) {\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt) : IfNode(control, bol, p, fcnt) {\n+    init_class_id(Class_RangeCheck);\n+  }\n+\n+#ifndef PRODUCT\n+  RangeCheckNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+      : IfNode(control, bol, p, fcnt, assertion_predicate_type) {\n@@ -472,0 +484,1 @@\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    Constant() : _type(T_ILLEGAL), _is_array(false), _alignment(-1), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }\n+    Constant() : _type(T_ILLEGAL), _is_array(false), _alignment(-1), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = nullptr; }\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,1 +263,1 @@\n-  RoundDoubleModeNode(Node *in1, Node * rmode): Node(0, in1, rmode) {}\n+  RoundDoubleModeNode(Node *in1, Node * rmode): Node(nullptr, in1, rmode) {}\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  CountBitsNode(Node* in1) : Node(0, in1) {}\n+  CountBitsNode(Node* in1) : Node(nullptr, in1) {}\n","filename":"src\/hotspot\/share\/opto\/countbitsnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-  \/\/ (http:\/\/www.hackersdelight.org\/HDcode\/mulhs.c)\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -671,1 +671,6 @@\n-    Node* curr_cmp = curr_ctrl->in(0)->in(1)->in(1); \/\/ true\/false -> if -> bool -> cmp\n+    \/\/ can_reduce_check_users() verified graph: true\/false -> if -> bool -> cmp\n+    assert(curr_ctrl->in(0)->Opcode() == Op_If, \"unexpected node %s\", curr_ctrl->in(0)->Name());\n+    Node* bol = curr_ctrl->in(0)->in(1);\n+    assert(bol->is_Bool(), \"unexpected node %s\", bol->Name());\n+    Node* curr_cmp = bol->in(1);\n+    assert(curr_cmp->Opcode() == Op_CmpP || curr_cmp->Opcode() == Op_CmpN, \"unexpected node %s\", curr_cmp->Name());\n@@ -3585,2 +3590,1 @@\n-  BoxLockNode* box = alock->box_node()->as_BoxLock();\n-  if (!box->is_unbalanced() && not_global_escape(alock->obj_node())) {\n+  if (alock->is_balanced() && not_global_escape(alock->obj_node())) {\n@@ -3590,1 +3594,1 @@\n-      box->set_local();\n+      alock->box_node()->as_BoxLock()->set_local();\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  _append = append;\n@@ -148,1 +149,1 @@\n-    init_file_stream(file_name, use_multiple_files, append);\n+    init_file_stream(file_name, use_multiple_files);\n@@ -153,1 +154,1 @@\n-  if (!append) {\n+  if (!_append) {\n@@ -160,1 +161,3 @@\n-  tail(TOP_ELEMENT);\n+  if (!_append) {\n+    tail(TOP_ELEMENT);\n+  }\n@@ -863,1 +866,1 @@\n-void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files, bool append) {\n+void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files) {\n@@ -866,1 +869,1 @@\n-    assert(!append, \"append should only be used for debugging with a single file\");\n+    assert(!_append, \"append should only be used for debugging with a single file\");\n@@ -878,1 +881,1 @@\n-    _output = new (mtCompiler) fileStream(file_name, append ? \"a\" : \"w\");\n+    _output = new (mtCompiler) fileStream(file_name, _append ? \"a\" : \"w\");\n@@ -881,1 +884,1 @@\n-    assert(!append, \"append should only be used for debugging with a single file\");\n+    assert(!_append, \"append should only be used for debugging with a single file\");\n@@ -912,3 +915,10 @@\n-    end_method();\n-    _current_method = nullptr;\n-    begin_method();\n+    if (_append) {\n+      \/\/ Do not call `end_method` if we are appending, just update `_current_method`,\n+      \/\/ because `begin_method` is not called in the constructor in append mode.\n+      _current_method = current_method;\n+    } else {\n+      \/\/ End the old method and begin a new one.\n+      \/\/ Don't worry about `_current_method`, `end_method` will clear it.\n+      end_method();\n+      begin_method();\n+    }\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+  bool _append;\n@@ -121,1 +122,1 @@\n-  void init_file_stream(const char* file_name, bool use_multiple_files, bool append);\n+  void init_file_stream(const char* file_name, bool use_multiple_files);\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,18 @@\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt)\n+      NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+  init_node(control, bol);\n+}\n+\n+#ifndef PRODUCT\n+IfNode::IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type)\n+    : MultiBranchNode(2),\n+      _prob(p),\n+      _fcnt(fcnt),\n+      _assertion_predicate_type(assertion_predicate_type) {\n+  init_node(control, bol);\n+}\n+#endif \/\/ NOT_PRODUCT\n+\n@@ -1842,3 +1860,15 @@\n-\/\/------------------------------dump_spec--------------------------------------\n-void IfNode::dump_spec(outputStream *st) const {\n-  st->print(\"P=%f, C=%f\",_prob,_fcnt);\n+void IfNode::dump_spec(outputStream* st) const {\n+  switch (_assertion_predicate_type) {\n+    case AssertionPredicateType::Init_value:\n+      st->print(\"#Init Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::Last_value:\n+      st->print(\"#Last Value Assertion Predicate  \");\n+      break;\n+    case AssertionPredicateType::None:\n+      \/\/ No Assertion Predicate\n+      break;\n+    default:\n+      fatal(\"Unknown Assertion Predicate type\");\n+  }\n+  st->print(\"P=%f, C=%f\", _prob, _fcnt);\n@@ -1846,1 +1876,1 @@\n-#endif\n+#endif \/\/ NOT PRODUCT\n@@ -2201,0 +2231,3 @@\n+  if (_useless) {\n+    st->print(\"#useless \");\n+  }\n@@ -2202,1 +2235,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,1 +242,1 @@\n-  CopySignDNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+  CopySignDNode(Node* in1, Node* in2, Node* in3) : Node(nullptr, in1, in2, in3) {}\n@@ -252,1 +252,1 @@\n-  CopySignFNode(Node* in1, Node* in2) : Node(0, in1, in2) {}\n+  CopySignFNode(Node* in1, Node* in2) : Node(nullptr, in1, in2) {}\n@@ -261,1 +261,1 @@\n-  SignumDNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+  SignumDNode(Node* in1, Node* in2, Node* in3) : Node(nullptr, in1, in2, in3) {}\n@@ -271,1 +271,1 @@\n-  SignumFNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+  SignumFNode(Node* in1, Node* in2, Node* in3) : Node(nullptr, in1, in2, in3) {}\n@@ -309,1 +309,1 @@\n-  IsInfiniteFNode(Node* in1) : Node(0, in1) {}\n+  IsInfiniteFNode(Node* in1) : Node(nullptr, in1) {}\n@@ -318,1 +318,1 @@\n-  IsInfiniteDNode(Node* in1) : Node(0, in1) {}\n+  IsInfiniteDNode(Node* in1) : Node(nullptr, in1) {}\n@@ -327,1 +327,1 @@\n-  IsFiniteFNode(Node* in1) : Node(0, in1) {}\n+  IsFiniteFNode(Node* in1) : Node(nullptr, in1) {}\n@@ -336,1 +336,1 @@\n-  IsFiniteDNode(Node* in1) : Node(0, in1) {}\n+  IsFiniteDNode(Node* in1) : Node(nullptr, in1) {}\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -5856,0 +5856,32 @@\n+\/\/ Common checks for array sorting intrinsics arguments.\n+\/\/ Returns `true` if checks passed.\n+bool LibraryCallKit::check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt) {\n+  \/\/ check address of the class\n+  if (elementType == nullptr || elementType->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  if (elem_klass == nullptr) {\n+    return false;  \/\/ dead path\n+  }\n+  \/\/ java_mirror_type() returns non-null for compile-time Class constants only\n+  ciType* elem_type = elem_klass->java_mirror_type();\n+  if (elem_type == nullptr) {\n+    return false;\n+  }\n+  bt = elem_type->basic_type();\n+  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n+  if (!Matcher::supports_simd_sort(bt)) {\n+    return false;\n+  }\n+  \/\/ check address of the array\n+  if (obj == nullptr || obj->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM) {\n+    return false; \/\/ failed input validation\n+  }\n+  return true;\n+}\n+\n@@ -5858,0 +5890,5 @@\n+  address stubAddr = StubRoutines::select_array_partition_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 9, \"arrayPartition has 8 parameters (one long)\");\n@@ -5859,1 +5896,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5861,1 +5899,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5866,0 +5904,1 @@\n+  \/\/ PartitionOperation:  argument(8) is ignored\n@@ -5868,0 +5907,1 @@\n+  BasicType bt = T_ILLEGAL;\n@@ -5869,0 +5909,8 @@\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n+    return false;\n+  }\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -5874,18 +5922,0 @@\n-    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-    BasicType bt = elem_type->basic_type();\n-    \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-    if (!Matcher::supports_simd_sort(bt)) {\n-      return false;\n-    }\n-    address stubAddr = nullptr;\n-    stubAddr = StubRoutines::select_array_partition_function();\n-    \/\/ stub not loaded\n-    if (stubAddr == nullptr) {\n-      return false;\n-    }\n-    \/\/ get the address of the array\n-    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-      return false; \/\/ failed input validation\n-    }\n@@ -5924,0 +5954,5 @@\n+  address stubAddr = StubRoutines::select_arraysort_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 7, \"arraySort has 6 parameters (one long)\");\n@@ -5925,1 +5960,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5927,1 +5963,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5930,0 +5966,1 @@\n+  \/\/ SortOperation:       argument(6) is ignored\n@@ -5931,11 +5968,3 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType bt = elem_type->basic_type();\n-  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-  if (!Matcher::supports_simd_sort(bt)) {\n-    return false;\n-  }\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_arraysort_function();\n-  \/\/stub not loaded\n-  if (stubAddr == nullptr) {\n+  BasicType bt = T_ILLEGAL;\n+\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n@@ -5944,5 +5973,4 @@\n-\n-  \/\/ get address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n@@ -7971,2 +7999,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n@@ -8072,1 +8098,1 @@\n-    state = get_state_from_digest_object(digestBase_obj, T_BYTE);\n+    state = get_state_from_digest_object(digestBase_obj, T_LONG);\n@@ -8172,1 +8198,1 @@\n-      elem_type = T_BYTE;\n+      elem_type = T_LONG;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":68,"deletions":42,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+  bool check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -125,1 +125,3 @@\n-  virtual void dump_spec(outputStream *st) const { st->print(\"  Lock %d\",_slot); }\n+  virtual void dump_spec(outputStream *st) const {\n+    st->print(\"  Lock slot: %d, Kind: %s\", _slot, _kind_name[(int)_kind]);\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs) {\n+                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs\n+                                                        NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type)) {\n@@ -146,1 +147,2 @@\n-      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n+      new_iff = new IfNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n+                           NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -149,1 +151,2 @@\n-      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt);\n+      new_iff = new RangeCheckNode(entry, parse_predicate->in(1), parse_predicate->_prob, parse_predicate->_fcnt\n+                                   NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -1155,1 +1158,0 @@\n-  IfProjNode* new_predicate_proj = nullptr;\n@@ -1166,4 +1168,3 @@\n-    new_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr,\n-                                                     reason,\n-                                                     iff->Opcode());\n-    Node* ctrl = new_predicate_proj->in(0)->as_If()->in(0);\n+    IfProjNode* hoisted_check_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason,\n+                                                                           iff->Opcode());\n+    Node* ctrl = hoisted_check_predicate_proj->in(0)->as_If()->in(0);\n@@ -1180,1 +1181,1 @@\n-    IfNode* new_predicate_iff = new_predicate_proj->in(0)->as_If();\n+    IfNode* new_predicate_iff = hoisted_check_predicate_proj->in(0)->as_If();\n@@ -1184,1 +1185,6 @@\n-    C->print_method(PHASE_AFTER_LOOP_PREDICATION_IC, 4, new_predicate_proj->in(0));\n+    invar.map_ctrl(if_success_proj, hoisted_check_predicate_proj); \/\/ Mark hoisted check as invariant\n+\n+    \/\/ Eliminate the old If in the loop body.\n+    dominated_by(hoisted_check_predicate_proj, iff, negated);\n+\n+    C->print_method(PHASE_AFTER_LOOP_PREDICATION_IC, 4, hoisted_check_predicate_proj->in(0));\n@@ -1196,1 +1202,0 @@\n-    range_check_predicate = true;\n@@ -1200,0 +1205,1 @@\n+    IfTrueNode* hoisted_check_proj = if_success_proj->as_IfTrue();\n@@ -1268,2 +1274,10 @@\n-    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj, upper_bound_proj, scale,\n-                                                          offset, init, limit, stride, rng, overflow, reason);\n+    IfTrueNode* template_assertion_predicate_proj =\n+        add_template_assertion_predicate(iff, loop, hoisted_check_proj, parse_predicate_proj, upper_bound_proj, scale,\n+                                         offset, init, limit, stride, rng, overflow, reason);\n+\n+    \/\/ Eliminate the old range check in the loop body.\n+    \/\/ When a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n+    \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n+    \/\/ dependency: pin the data dependent nodes.\n+    eliminate_hoisted_range_check(hoisted_check_proj, template_assertion_predicate_proj);\n+    invar.map_ctrl(hoisted_check_proj, template_assertion_predicate_proj); \/\/ Mark hoisted check as invariant\n@@ -1271,1 +1285,1 @@\n-    C->print_method(PHASE_AFTER_LOOP_PREDICATION_RC, 4, new_predicate_proj->in(0));\n+    C->print_method(PHASE_AFTER_LOOP_PREDICATION_RC, 4, template_assertion_predicate_proj->in(0));\n@@ -1284,9 +1298,0 @@\n-  assert(new_predicate_proj != nullptr, \"sanity\");\n-  \/\/ Success - attach condition (new_predicate_bol) to predicate if\n-  invar.map_ctrl(if_success_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n-\n-  \/\/ Eliminate the old If in the loop body\n-  \/\/ If a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n-  \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n-  \/\/ dependency: pin the data dependent nodes.\n-  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con, range_check_predicate);\n@@ -1298,0 +1303,6 @@\n+void PhaseIdealLoop::eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj,\n+                                                   IfTrueNode* template_assertion_predicate_proj) {\n+  _igvn.replace_input_of(hoisted_check_proj->in(0), 1, _igvn.intcon(1));\n+  rewire_safe_outputs_to_dominator(hoisted_check_proj, template_assertion_predicate_proj, true);\n+}\n+\n@@ -1301,1 +1312,1 @@\n-IfProjNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+IfTrueNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n@@ -1315,1 +1326,2 @@\n-  IfProjNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  IfTrueNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n+                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n@@ -1340,1 +1352,2 @@\n-  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n+                                         false NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2772,4 +2772,3 @@\n-Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* ctrl,\n-                                                                      const int scale_con, Node* offset, Node* limit,\n-                                                                      jint stride_con, Node* value,\n-                                                                      const bool is_template) {\n+Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(\n+    IdealLoopTree* loop, Node* ctrl, const int scale_con, Node* offset, Node* limit, jint stride_con, Node* value,\n+    const bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n@@ -2996,2 +2995,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, opaque_init, true);\n+          loop_entry = add_range_check_elimination_assertion_predicate(\n+              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, opaque_init, true\n+              NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n@@ -3009,2 +3009,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, max_value, true);\n+          loop_entry = add_range_check_elimination_assertion_predicate(\n+              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, max_value, true\n+              NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-  LoopLimitNode( Compile* C, Node *init, Node *limit, Node *stride ) : Node(0,init,limit,stride) {\n+  LoopLimitNode( Compile* C, Node *init, Node *limit, Node *stride ) : Node(nullptr,init,limit,stride) {\n@@ -614,1 +614,1 @@\n-    : _parent(0), _next(0), _child(0),\n+    : _parent(nullptr), _next(nullptr), _child(nullptr),\n@@ -1347,3 +1347,4 @@\n-  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                          Deoptimization::DeoptReason reason, int opcode,\n-                                          bool rewire_uncommon_proj_phi_inputs = false);\n+  IfTrueNode* create_new_if_for_predicate(\n+      ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n+      bool rewire_uncommon_proj_phi_inputs = false\n+      NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n@@ -1385,1 +1386,1 @@\n-  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+  IfTrueNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n@@ -1389,3 +1390,4 @@\n-  Node* add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* predicate_proj, int scale_con,\n-                                                        Node* offset, Node* limit, int stride_con, Node* value,\n-                                                        bool is_template);\n+  void eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj, IfTrueNode* template_assertion_predicate_proj);\n+  Node* add_range_check_elimination_assertion_predicate(\n+      IdealLoopTree* loop, Node* predicate_proj, int scale_con, Node* offset, Node* limit, int stride_con, Node* value,\n+      bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n@@ -1545,0 +1547,1 @@\n+  void rewire_safe_outputs_to_dominator(Node* source, Node* dominator, bool pin_array_access_nodes);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -350,1 +350,3 @@\n-  if (iff->outcnt() != 2) return;\n+  if (iff->outcnt() != 2) {\n+    return;\n+  }\n@@ -357,1 +359,1 @@\n-  if (dp == nullptr)\n+  if (dp == nullptr) {\n@@ -359,0 +361,4 @@\n+  }\n+\n+  rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n+}\n@@ -360,1 +366,2 @@\n-  IdealLoopTree* old_loop = get_loop(dp);\n+void PhaseIdealLoop::rewire_safe_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n+  IdealLoopTree* old_loop = get_loop(source);\n@@ -362,2 +369,2 @@\n-  for (DUIterator_Fast imax, i = dp->fast_outs(imax); i < imax; i++) {\n-    Node* cd = dp->fast_out(i); \/\/ Control-dependent node\n+  for (DUIterator_Fast imax, i = source->fast_outs(imax); i < imax; i++) {\n+    Node* out = source->fast_out(i); \/\/ Control-dependent node\n@@ -365,3 +372,3 @@\n-    if (cd->depends_only_on_test() && _igvn.no_dependent_zero_check(cd)) {\n-      assert(cd->in(0) == dp, \"\");\n-      _igvn.replace_input_of(cd, 0, prevdom);\n+    if (out->depends_only_on_test() && _igvn.no_dependent_zero_check(out)) {\n+      assert(out->in(0) == source, \"must be control dependent on source\");\n+      _igvn.replace_input_of(out, 0, dominator);\n@@ -375,1 +382,1 @@\n-        Node* clone = cd->pin_array_access_node();\n+        Node* clone = out->pin_array_access_node();\n@@ -377,3 +384,3 @@\n-          clone = _igvn.register_new_node_with_optimizer(clone, cd);\n-          _igvn.replace_node(cd, clone);\n-          cd = clone;\n+          clone = _igvn.register_new_node_with_optimizer(clone, out);\n+          _igvn.replace_node(out, clone);\n+          out = clone;\n@@ -382,2 +389,2 @@\n-      set_early_ctrl(cd, false);\n-      IdealLoopTree* new_loop = get_loop(get_ctrl(cd));\n+      set_early_ctrl(out, false);\n+      IdealLoopTree* new_loop = get_loop(get_ctrl(out));\n@@ -386,1 +393,1 @@\n-          old_loop->_body.yank(cd);\n+          old_loop->_body.yank(out);\n@@ -389,1 +396,1 @@\n-          new_loop->_body.push(cd);\n+          new_loop->_body.push(out);\n@@ -809,3 +816,11 @@\n-  \/\/ Ignore cost if CMOVE can be moved outside the loop.\n-  if (used_inside_loop && cost >= ConditionalMoveLimit) {\n-    return nullptr;\n+  float infrequent_prob = PROB_UNLIKELY_MAG(3);\n+  \/\/ Ignore cost and blocks frequency if CMOVE can be moved outside the loop.\n+  if (used_inside_loop) {\n+    if (cost >= ConditionalMoveLimit) return nullptr; \/\/ Too much goo\n+\n+    \/\/ BlockLayoutByFrequency optimization moves infrequent branch\n+    \/\/ from hot path. No point in CMOV'ing in such case (110 is used\n+    \/\/ instead of 100 to take into account not exactness of float value).\n+    if (BlockLayoutByFrequency) {\n+      infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage\/110.0f);\n+    }\n@@ -815,1 +830,0 @@\n-  constexpr float infrequent_prob = PROB_UNLIKELY_MAG(2);\n@@ -818,1 +832,2 @@\n-  } else if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n+  } else if (iff->_prob < infrequent_prob ||\n+      iff->_prob > (1.0f - infrequent_prob))\n@@ -820,1 +835,0 @@\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1124,1 +1124,1 @@\n-  labelOper() : _label(0), _block_num(0) {}\n+  labelOper() : _label(nullptr), _block_num(0) {}\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2225,1 +2225,1 @@\n-  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+  if (!alock->is_balanced()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3037,0 +3037,3 @@\n+  if (_store->is_unsafe_access()) {\n+    return nullptr;\n+  }\n@@ -3070,0 +3073,1 @@\n+  assert(!_store->is_unsafe_access(), \"no unsafe accesses\");\n@@ -3074,1 +3078,2 @@\n-      other_store->adr_type()->isa_aryptr() == nullptr) {\n+      other_store->adr_type()->isa_aryptr() == nullptr ||\n+      other_store->is_unsafe_access()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1695,1 +1695,1 @@\n-  PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}\n+  PrefetchAllocationNode(Node *mem, Node *adr) : Node(nullptr,mem,adr) {}\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  BinaryNode( Node *n1, Node *n2 ) : Node(0,n1,n2) { }\n+  BinaryNode( Node *n1, Node *n2 ) : Node(nullptr,n1,n2) { }\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,1 @@\n-  MulHiLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  MulHiLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -181,1 +181,1 @@\n-  UMulHiLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  UMulHiLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -294,1 +294,1 @@\n-  RShiftINode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  RShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -307,1 +307,1 @@\n-  RShiftLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  RShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -319,1 +319,1 @@\n-  URShiftBNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  URShiftBNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -329,1 +329,1 @@\n-  URShiftSNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  URShiftSNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -339,1 +339,1 @@\n-  URShiftINode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  URShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -352,1 +352,1 @@\n-  URShiftLNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {}\n+  URShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -399,1 +399,1 @@\n-  MulAddS2INode(Node* in1, Node *in2, Node *in3, Node* in4) : Node(0, in1, in2, in3, in4) {}\n+  MulAddS2INode(Node* in1, Node *in2, Node *in3, Node* in4) : Node(nullptr, in1, in2, in3, in4) {}\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  ProfileBooleanNode(Node *n, uint false_cnt, uint true_cnt) : Node(0, n),\n+  ProfileBooleanNode(Node *n, uint false_cnt, uint true_cnt) : Node(nullptr, n),\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  Type_Array(Arena *a) : _a(a), _max(0), _types(0) {}\n+  Type_Array(Arena *a) : _a(a), _max(0), _types(nullptr) {}\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,0 +196,9 @@\n+#ifndef PRODUCT\n+\/\/ Assertion Predicates are either emitted to check the initial value of a range check in the first iteration or the last\n+\/\/ value of a range check in the last iteration of a loop.\n+enum class AssertionPredicateType {\n+  None, \/\/ Not an Assertion Predicate\n+  Init_value,\n+  Last_value\n+};\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  RootNode( ) : LoopNode(0,0) {\n+  RootNode( ) : LoopNode(nullptr, nullptr) {\n","filename":"src\/hotspot\/share\/opto\/rootnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1444,2 +1444,2 @@\n-  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n-  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n@@ -1464,1 +1464,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  SubNode( Node *in1, Node *in2 ) : Node(0,in1,in2) {\n+  SubNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -388,1 +388,1 @@\n-  AbsNode( Node *value ) : Node(0,value) {}\n+  AbsNode( Node *value ) : Node(nullptr,value) {}\n@@ -445,1 +445,1 @@\n-  CmpLTMaskNode( Node *p, Node *q ) : Node(0, p, q) {}\n+  CmpLTMaskNode( Node *p, Node *q ) : Node(nullptr, p, q) {}\n@@ -455,1 +455,1 @@\n-  NegNode(Node* in1) : Node(0, in1) {\n+  NegNode(Node* in1) : Node(nullptr, in1) {\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-#include \"libadt\/vectset.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -29,1 +26,0 @@\n-#include \"opto\/c2compiler.hpp\"\n@@ -32,5 +28,0 @@\n-#include \"opto\/matcher.hpp\"\n-#include \"opto\/memnode.hpp\"\n-#include \"opto\/opcodes.hpp\"\n-#include \"opto\/opaquenode.hpp\"\n-#include \"opto\/rootnode.hpp\"\n@@ -38,0 +29,1 @@\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n@@ -40,1 +32,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n@@ -710,1 +701,1 @@\n-  \/\/ and will still be vectorized by SuperWord::vector_opd.\n+  \/\/ and will still be vectorized by SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index.\n@@ -772,2 +763,3 @@\n-\/\/ Look for pattern n1 = (iv + c) and n2 = (iv + c + 1), which may lead to PopulateIndex vector node.\n-\/\/ We skip the pack creation of these nodes. They will be vectorized by SuperWord::vector_opd.\n+\/\/ Look for pattern n1 = (iv + c) and n2 = (iv + c + 1), which may lead to\n+\/\/ PopulateIndex vector node. We skip the pack creation of these nodes. They\n+\/\/ will be vectorized by SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index.\n@@ -1861,127 +1853,2 @@\n-\/\/ The PacksetGraph combines the dependency graph with the packset. In the PackSet\n-\/\/ graph, we have two kinds of nodes:\n-\/\/  (1) pack-node:   Represents all nodes of some pack p in a single node, which\n-\/\/                   shall later become a vector node.\n-\/\/  (2) scalar-node: Represents a node that is not in any pack.\n-\/\/ For any edge (n1, n2) in the dependency graph, we add an edge to the PacksetGraph for\n-\/\/ the PacksetGraph nodes corresponding to n1 and n2.\n-\/\/ We work from the dependency graph, because it gives us all the data-dependencies,\n-\/\/ as well as more refined memory-dependencies than the C2 graph. The dependency graph\n-\/\/ does not have cycles. But packing nodes can introduce cyclic dependencies. Example:\n-\/\/\n-\/\/                                                       +--------+\n-\/\/  A -> X                                               |        v\n-\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n-\/\/  Y -> B                                                 ^        |\n-\/\/                                                         +--------+\n-\/\/\n-class PacksetGraph {\n-private:\n-  \/\/ pid: packset graph node id.\n-  GrowableArray<int> _pid;                 \/\/ bb_idx(n) -> pid\n-  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via _packset.pack\n-  GrowableArray<GrowableArray<int>> _out;  \/\/ out-edges\n-  GrowableArray<int> _incnt;               \/\/ number of (implicit) in-edges\n-  int _max_pid = 0;\n-\n-  bool _schedule_success;\n-\n-  SuperWord* _slp;\n-public:\n-  PacksetGraph(SuperWord* slp)\n-  : _pid(8, 0, \/* default *\/ 0), _slp(slp) {\n-  }\n-  \/\/ Get pid, if there is a packset node that n belongs to. Else return 0.\n-  int get_pid_or_zero(const Node* n) const {\n-    if (!_slp->in_bb(n)) {\n-      return 0;\n-    }\n-    int idx = _slp->bb_idx(n);\n-    if (idx >= _pid.length()) {\n-      return 0;\n-    } else {\n-      return _pid.at(idx);\n-    }\n-  }\n-  int get_pid(const Node* n) {\n-    int poz = get_pid_or_zero(n);\n-    assert(poz != 0, \"pid should not be zero\");\n-    return poz;\n-  }\n-  void set_pid(Node* n, int pid) {\n-    assert(n != nullptr && pid > 0, \"sane inputs\");\n-    assert(_slp->in_bb(n), \"must be\");\n-    int idx = _slp->bb_idx(n);\n-    _pid.at_put_grow(idx, pid);\n-    _pid_to_node.at_put_grow(pid - 1, n, nullptr);\n-  }\n-  Node* get_node(int pid) {\n-    assert(pid > 0 && pid <= _pid_to_node.length(), \"pid must be mapped\");\n-    Node* n = _pid_to_node.at(pid - 1);\n-    assert(n != nullptr, \"sanity\");\n-    return n;\n-  }\n-  int new_pid() {\n-    _incnt.push(0);\n-    _out.push(GrowableArray<int>());\n-    return ++_max_pid;\n-  }\n-  int incnt(int pid) { return _incnt.at(pid - 1); }\n-  void incnt_set(int pid, int cnt) { return _incnt.at_put(pid - 1, cnt); }\n-  GrowableArray<int>& out(int pid) { return _out.at(pid - 1); }\n-  bool schedule_success() const { return _schedule_success; }\n-\n-  \/\/ Create nodes (from packs and scalar-nodes), and add edges, based on the dependency graph.\n-  void build() {\n-    const PackSet& packset = _slp->packset();\n-    const GrowableArray<Node*>& body = _slp->body();\n-    \/\/ Map nodes in packsets\n-    for (int i = 0; i < packset.length(); i++) {\n-      Node_List* p = packset.at(i);\n-      int pid = new_pid();\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        set_pid(n, pid);\n-        assert(packset.get_pack(n) == p, \"matching packset\");\n-      }\n-    }\n-\n-    int max_pid_packset = _max_pid;\n-\n-    \/\/ Map nodes not in packset\n-    for (int i = 0; i < body.length(); i++) {\n-      Node* n = body.at(i);\n-      if (n->is_Phi() || n->is_CFG()) {\n-        continue; \/\/ ignore control flow\n-      }\n-      int pid = get_pid_or_zero(n);\n-      if (pid == 0) {\n-        pid = new_pid();\n-        set_pid(n, pid);\n-        assert(packset.get_pack(n) == nullptr, \"no packset\");\n-      }\n-    }\n-\n-    \/\/ Map edges for packset nodes\n-    VectorSet set;\n-    for (int i = 0; i < packset.length(); i++) {\n-      Node_List* p = packset.at(i);\n-      set.clear();\n-      int pid = get_pid(p->at(0));\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        assert(pid == get_pid(n), \"all nodes in pack have same pid\");\n-        for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n-          Node* pred = preds.current();\n-          int pred_pid = get_pid_or_zero(pred);\n-          if (pred_pid == pid && _slp->is_marked_reduction(n)) {\n-            continue; \/\/ reduction -> self-cycle is not a cyclic dependency\n-          }\n-          \/\/ Only add edges once, and only for mapped nodes (in body)\n-          if (pred_pid > 0 && !set.test_set(pred_pid)) {\n-            incnt_set(pid, incnt(pid) + 1); \/\/ increment\n-            out(pred_pid).push(pid);\n-          }\n-        }\n-      }\n-    }\n+bool SuperWord::schedule_and_apply() const {\n+  if (_packset.is_empty()) { return false; }\n@@ -1989,82 +1856,1 @@\n-    \/\/ Map edges for nodes not in packset\n-    for (int i = 0; i < body.length(); i++) {\n-      Node* n = body.at(i);\n-      int pid = get_pid_or_zero(n); \/\/ zero for Phi or CFG\n-      if (pid <= max_pid_packset) {\n-        continue; \/\/ Only scalar-nodes\n-      }\n-      for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n-        Node* pred = preds.current();\n-        int pred_pid = get_pid_or_zero(pred);\n-        \/\/ Only add edges for mapped nodes (in body)\n-        if (pred_pid > 0) {\n-          incnt_set(pid, incnt(pid) + 1); \/\/ increment\n-          out(pred_pid).push(pid);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Schedule nodes of PacksetGraph to worklist, using topsort: schedule a node\n-  \/\/ that has zero incnt. If a PacksetGraph node corresponds to memops, then add\n-  \/\/ those to the memops_schedule. At the end, we return the memops_schedule, and\n-  \/\/ note if topsort was successful.\n-  Node_List schedule() {\n-    Node_List memops_schedule;\n-    GrowableArray<int> worklist;\n-    \/\/ Directly schedule all nodes without precedence\n-    for (int pid = 1; pid <= _max_pid; pid++) {\n-      if (incnt(pid) == 0) {\n-        worklist.push(pid);\n-      }\n-    }\n-    \/\/ Continue scheduling via topological sort\n-    for (int i = 0; i < worklist.length(); i++) {\n-      int pid = worklist.at(i);\n-\n-      \/\/ Add memops to memops_schedule\n-      Node* n = get_node(pid);\n-      Node_List* p = _slp->packset().get_pack(n);\n-      if (n->is_Mem()) {\n-        if (p == nullptr) {\n-          memops_schedule.push(n);\n-        } else {\n-          for (uint k = 0; k < p->size(); k++) {\n-            memops_schedule.push(p->at(k));\n-            assert(p->at(k)->is_Mem(), \"only schedule memops\");\n-          }\n-        }\n-      }\n-\n-      \/\/ Decrement incnt for all successors\n-      for (int j = 0; j < out(pid).length(); j++){\n-        int pid_use = out(pid).at(j);\n-        int incnt_use = incnt(pid_use) - 1;\n-        incnt_set(pid_use, incnt_use);\n-        \/\/ Did use lose its last input?\n-        if (incnt_use == 0) {\n-          worklist.push(pid_use);\n-        }\n-      }\n-    }\n-\n-    \/\/ Was every pid scheduled? If not, we found some cycles in the PacksetGraph.\n-    _schedule_success = (worklist.length() == _max_pid);\n-    return memops_schedule;\n-  }\n-\n-  \/\/ Print the PacksetGraph.\n-  \/\/ print_nodes = true: print all C2 nodes beloning to PacksetGrahp node.\n-  \/\/ print_zero_incnt = false: do not print nodes that have no in-edges (any more).\n-  void print(bool print_nodes, bool print_zero_incnt) {\n-    const GrowableArray<Node*> &body = _slp->body();\n-    tty->print_cr(\"PacksetGraph\");\n-    for (int pid = 1; pid <= _max_pid; pid++) {\n-      if (incnt(pid) == 0 && !print_zero_incnt) {\n-        continue;\n-      }\n-      tty->print(\"Node %d. incnt %d [\", pid, incnt(pid));\n-      for (int j = 0; j < out(pid).length(); j++) {\n-        tty->print(\"%d \", out(pid).at(j));\n-      }\n-      tty->print_cr(\"]\");\n+  \/\/ Make an empty transform.\n@@ -2072,9 +1858,4 @@\n-      if (print_nodes) {\n-        for (int i = 0; i < body.length(); i++) {\n-          Node* n = body.at(i);\n-          if (get_pid_or_zero(n) == pid) {\n-            tty->print(\"    \");\n-            n->dump();\n-          }\n-        }\n-      }\n+  VTransformTrace trace(_vloop.vtrace(),\n+                        is_trace_superword_rejections(),\n+                        is_trace_align_vector(),\n+                        is_trace_superword_info());\n@@ -2082,21 +1863,5 @@\n-    }\n-  }\n-};\n-\n-\/\/ We want to replace the packed scalars from the PackSet and replace them\n-\/\/ with vector operations. This requires scheduling and re-ordering the memory\n-\/\/ graph. We take these steps:\n-\/\/ (1) Build the PacksetGraph. It combines the dependency graph with the\n-\/\/     packset. The PacksetGraph gives us the dependencies that must be\n-\/\/     respected after scheduling.\n-\/\/ (2) Schedule the PacksetGraph to the memops_schedule, which represents\n-\/\/     a linear order of all memops in the body. The order respects the\n-\/\/     dependencies of the PacksetGraph.\n-\/\/ (3) If the PacksetGraph has cycles, we cannot schedule. Abort.\n-\/\/ (4) Apply the vectorization, including re-ordering the memops and replacing\n-\/\/     packed scalars with vector operations.\n-bool SuperWord::schedule_and_apply() {\n-  if (_packset.is_empty()) {\n-    return false;\n-  }\n-  ResourceMark rm;\n+  VTransform vtransform(_vloop_analyzer,\n+                        _mem_ref_for_main_loop_alignment,\n+                        _aw_for_main_loop_alignment\n+                        NOT_PRODUCT(COMMA trace)\n+                        );\n@@ -2104,3 +1869,5 @@\n-  \/\/ (1) Build the PacksetGraph.\n-  PacksetGraph graph(this);\n-  graph.build();\n+  \/\/ Build the transform from the packset.\n+  {\n+    ResourceMark rm;\n+    SuperWordVTransformBuilder builder(_packset, vtransform);\n+  }\n@@ -2108,2 +1875,4 @@\n-  \/\/ (2) Schedule the PacksetGraph.\n-  Node_List memops_schedule = graph.schedule();\n+  if (!vtransform.schedule()) { return false; }\n+  vtransform.apply();\n+  return true;\n+}\n@@ -2111,7 +1880,3 @@\n-  \/\/ (3) Check if the PacksetGraph schedule succeeded (had no cycles).\n-  \/\/ We now know that we only have independent packs, see verify_packs.\n-  \/\/ This is a necessary but not a sufficient condition for an acyclic\n-  \/\/ graph (DAG) after scheduling. Thus, we must check if the packs have\n-  \/\/ introduced a cycle. The SuperWord paper mentions the need for this\n-  \/\/ in \"3.7 Scheduling\".\n-  if (!graph.schedule_success()) {\n+\/\/ Apply the vectorization, i.e. we irreversibly edit the C2 graph. At this point, all\n+\/\/ correctness and profitability checks have passed, and the graph was successfully scheduled.\n+void VTransform::apply() {\n@@ -2119,8 +1884,4 @@\n-    if (is_trace_superword_rejections()) {\n-      tty->print_cr(\"SuperWord::schedule found cycle in PacksetGraph:\");\n-      graph.print(true, false);\n-      tty->print_cr(\"removing all packs from packset.\");\n-    }\n-#endif\n-    _packset.clear();\n-    return false;\n+  if (_trace._info || TraceLoopOpts) {\n+    tty->print_cr(\"\\nVTransform::apply:\");\n+    lpt()->dump_head();\n+    lpt()->head()->dump();\n@@ -2128,0 +1889,3 @@\n+  assert(cl()->is_main_loop(), \"auto vectorization only for main loops\");\n+  assert(_graph.is_scheduled(), \"must already be scheduled\");\n+#endif\n@@ -2129,5 +1893,0 @@\n-  \/\/ (4) Apply the vectorization, including re-ordering the memops.\n-  return apply(memops_schedule);\n-}\n-\n-bool SuperWord::apply(Node_List& memops_schedule) {\n@@ -2135,2 +1894,1 @@\n-  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n-  C->print_method(PHASE_AUTO_VECTORIZATION1_BEFORE_APPLY, 4, cl);\n+  C->print_method(PHASE_AUTO_VECTORIZATION1_BEFORE_APPLY, 4, cl());\n@@ -2138,2 +1896,2 @@\n-  apply_memops_reordering_with_schedule(memops_schedule);\n-  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl);\n+  _graph.apply_memops_reordering_with_schedule();\n+  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl());\n@@ -2142,1 +1900,1 @@\n-  C->print_method(PHASE_AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, 4, cl);\n+  C->print_method(PHASE_AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, 4, cl());\n@@ -2144,4 +1902,2 @@\n-  bool is_success = apply_vectorization();\n-  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_APPLY, 4, cl);\n-\n-  return is_success;\n+  apply_vectorization();\n+  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_APPLY, 4, cl());\n@@ -2150,3 +1906,5 @@\n-\/\/ Reorder the memory graph for all slices in parallel. We walk over the schedule once,\n-\/\/ and track the current memory state of each slice.\n-void SuperWord::apply_memops_reordering_with_schedule(Node_List& memops_schedule) {\n+\/\/ We prepare the memory graph for the replacement of scalar memops with vector memops.\n+\/\/ We reorder all slices in parallel, ensuring that the memops inside each slice are\n+\/\/ ordered according to the _schedule. This means that all packed memops are consecutive\n+\/\/ in the memory graph after the reordering.\n+void VTransformGraph::apply_memops_reordering_with_schedule() const {\n@@ -2154,3 +1912,3 @@\n-  if (is_trace_superword_info()) {\n-    tty->print_cr(\"\\nSuperWord::apply_memops_reordering_with_schedule:\");\n-    memops_schedule.dump();\n+  assert(is_scheduled(), \"must be already scheduled\");\n+  if (_trace._info) {\n+    print_memops_schedule();\n@@ -2160,0 +1918,1 @@\n+  ResourceMark rm;\n@@ -2161,1 +1920,1 @@\n-  \/\/ When iterating over the memops_schedule, we keep track of the current memory state,\n+  \/\/ When iterating over the schedule, we keep track of the current memory state,\n@@ -2182,1 +1941,1 @@\n-  \/\/ (2) Walk over memops_schedule, append memops to the current state\n+  \/\/ (2) Walk over schedule, append memops to the current state\n@@ -2184,2 +1943,1 @@\n-  for (uint i = 0; i < memops_schedule.size(); i++) {\n-    MemNode* n = memops_schedule.at(i)->as_Mem();\n+  for_each_memop_in_schedule([&] (MemNode* n) {\n@@ -2201,1 +1959,1 @@\n-  }\n+  });\n@@ -2206,1 +1964,1 @@\n-  Node_List uses_after_loop;\n+  GrowableArray<Node*> uses_after_loop;\n@@ -2228,1 +1986,1 @@\n-    for (uint k = 0; k < uses_after_loop.size(); k++) {\n+    for (int k = 0; k < uses_after_loop.length(); k++) {\n@@ -2240,60 +1998,7 @@\n-\/\/ Convert packs into vector node operations\n-\/\/ At this point, all correctness and profitability checks have passed.\n-\/\/ We start the irreversible process of editing the C2 graph. Should\n-\/\/ there be an unexpected situation (assert fails), then we can only\n-\/\/ bail out of the compilation, as the graph has already been partially\n-\/\/ modified. We bail out, and retry without SuperWord.\n-bool SuperWord::apply_vectorization() {\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n-  Compile* C = phase()->C;\n-  assert(!_packset.is_empty(), \"vectorization requires non-empty packset\");\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"SuperWord::apply_vectorization \");\n-    lpt()->dump_head();\n-  }\n-#endif\n-\n-  uint max_vlen_in_bytes = 0;\n-  uint max_vlen = 0;\n-\n-  for (int i = 0; i < body().length(); i++) {\n-    Node* n = body().at(i);\n-    Node_List* p = get_pack(n);\n-    if (p != nullptr && n == p->at(p->size()-1)) {\n-      \/\/ After apply_memops_reordering_with_schedule, we know that the memops have the same order in the pack\n-      \/\/ as in the memory slice. Hence, \"first\" is the first memop in the slice from the pack,\n-      \/\/ and \"n\" is the last node in the slice from the pack.\n-      Node* first = p->at(0);\n-      uint vlen = p->size();\n-      uint vlen_in_bytes = 0;\n-      Node* vn = nullptr;\n-      int   opc = n->Opcode();\n-      if (n->is_Load()) {\n-        Node* ctl = n->in(MemNode::Control);\n-        Node* mem = first->in(MemNode::Memory);\n-        \/\/ Set the memory dependency of the LoadVector as early as possible.\n-        \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n-        \/\/ does not have any memory dependency.\n-        while (mem->is_StoreVector()) {\n-          VPointer p_store(mem->as_Mem(), _vloop);\n-          if (p_store.overlap_possible_with_any_in(p)) {\n-            break;\n-          } else {\n-            mem = mem->in(MemNode::Memory);\n-          }\n-        }\n-        Node* adr = first->in(MemNode::Address);\n-        const TypePtr* atyp = n->adr_type();\n-        vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n-        vlen_in_bytes = vn->as_LoadVector()->memory_size();\n-      } else if (n->is_Store()) {\n-        \/\/ Promote value to be stored to vector\n-        Node* val = vector_opd(p, MemNode::ValueIn);\n-        if (val == nullptr) {\n-          assert(false, \"input to vector store was not created\");\n-          C->record_failure(C2Compiler::retry_no_superword());\n-          return false; \/\/ bailout\n-        }\n+void VTransformGraph::apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const {\n+  ResourceMark rm;\n+  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n+  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n+  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n+  int length = _vtnodes.length();\n+  GrowableArray<Node*> vtnode_idx_to_transformed_node(length, length, nullptr);\n@@ -2301,65 +2006,5 @@\n-        Node* ctl = n->in(MemNode::Control);\n-        Node* mem = first->in(MemNode::Memory);\n-        Node* adr = first->in(MemNode::Address);\n-        const TypePtr* atyp = n->adr_type();\n-        vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n-        vlen_in_bytes = vn->as_StoreVector()->memory_size();\n-      } else if (VectorNode::is_scalar_rotate(n)) {\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = first->in(2);\n-        \/\/ If rotation count is non-constant or greater than 8bit value create a vector.\n-        if (!in2->is_Con() || !Matcher::supports_vector_constant_rotates(in2->get_int())) {\n-          in2 =  vector_opd(p, 2);\n-        }\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_roundopD(n)) {\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = first->in(2);\n-        assert(in2->is_Con(), \"Constant rounding mode expected.\");\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_muladds2i(n)) {\n-        assert(n->req() == 5u, \"MulAddS2I should have 4 operands.\");\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = vector_opd(p, 2);\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (opc == Op_SignumF || opc == Op_SignumD) {\n-        assert(n->req() == 4, \"four inputs expected\");\n-        Node* in = vector_opd(p, 1);\n-        Node* zero = vector_opd(p, 2);\n-        Node* one = vector_opd(p, 3);\n-        vn = VectorNode::make(opc, in, zero, one, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (n->is_Cmp()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-        continue;\n-      } else if (n->is_Bool()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-        continue;\n-      } else if (n->is_CMove()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-\n-        BoolNode* bol = n->in(1)->as_Bool();\n-        assert(bol != nullptr, \"must have Bool above CMove\");\n-        Node_List* bool_pack = get_pack(bol);\n-        assert(bool_pack != nullptr, \"CMove must have matching Bool pack\");\n-\n-        CmpNode* cmp = bol->in(1)->as_Cmp();\n-        assert(cmp != nullptr, \"must have cmp above CMove\");\n-        Node_List* cmp_pack = get_pack(cmp);\n-        assert(cmp_pack != nullptr, \"Bool must have matching Cmp pack\");\n-\n-        Node* cmp_in1 = vector_opd(cmp_pack, 1);\n-        Node* cmp_in2 = vector_opd(cmp_pack, 2);\n-\n-        Node* blend_in1 = vector_opd(p, 2);\n-        Node* blend_in2 = vector_opd(p, 3);\n-\n-        VTransformBoolTest bool_test = _packset.get_bool_test(bool_pack);\n-        BoolTest::mask test_mask = bool_test._mask;\n-        if (bool_test._is_negated) {\n-           \/\/ We can cancel out the negation by swapping the blend inputs.\n-           swap(blend_in1, blend_in2);\n-        }\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+    VTransformApplyResult result = vtn->apply(_vloop_analyzer,\n+                                              vtnode_idx_to_transformed_node);\n+    NOT_PRODUCT( if (_trace._verbose) { result.trace(vtn); } )\n@@ -2367,90 +2012,5 @@\n-        \/\/ VectorMaskCmp\n-        ConINode* test_mask_node  = igvn().intcon((int)test_mask);\n-        BasicType bt = velt_basic_type(cmp);\n-        const TypeVect* vt = TypeVect::make(bt, vlen);\n-        VectorNode* mask = new VectorMaskCmpNode(test_mask, cmp_in1, cmp_in2, test_mask_node, vt);\n-        phase()->register_new_node_with_ctrl_of(mask, p->at(0));\n-        igvn()._worklist.push(mask);\n-\n-        \/\/ VectorBlend\n-        vn = new VectorBlendNode(blend_in1, blend_in2, mask);\n-      } else if (n->req() == 3) {\n-        \/\/ Promote operands to vector\n-        Node* in1 = nullptr;\n-        bool node_isa_reduction = is_marked_reduction(n);\n-        if (node_isa_reduction) {\n-          \/\/ the input to the first reduction operation is retained\n-          in1 = first->in(1);\n-        } else {\n-          in1 = vector_opd(p, 1);\n-          if (in1 == nullptr) {\n-            assert(false, \"input in1 to vector operand was not created\");\n-            C->record_failure(C2Compiler::retry_no_superword());\n-            return false; \/\/ bailout\n-          }\n-        }\n-        Node* in2 = vector_opd(p, 2);\n-        if (in2 == nullptr) {\n-          assert(false, \"input in2 to vector operand was not created\");\n-          C->record_failure(C2Compiler::retry_no_superword());\n-          return false; \/\/ bailout\n-        }\n-        if (in1->Opcode() == Op_Replicate && (node_isa_reduction == false) && (n->is_Add() || n->is_Mul())) {\n-          \/\/ Move invariant vector input into second position to avoid register spilling.\n-          Node* tmp = in1;\n-          in1 = in2;\n-          in2 = tmp;\n-        }\n-        if (node_isa_reduction) {\n-          const Type *arith_type = n->bottom_type();\n-          vn = ReductionNode::make(opc, nullptr, in1, in2, arith_type->basic_type());\n-          if (in2->is_Load()) {\n-            vlen_in_bytes = in2->as_LoadVector()->memory_size();\n-          } else {\n-            vlen_in_bytes = in2->as_Vector()->length_in_bytes();\n-          }\n-        } else {\n-          if (VectorNode::can_use_RShiftI_instead_of_URShiftI(n, velt_basic_type(n))) {\n-            opc = Op_RShiftI;\n-          }\n-          vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-          vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-        }\n-      } else if (VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        Node* in = vector_opd(p, 1);\n-        vn = VectorNode::make(opc, in, nullptr, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        Node* in = vector_opd(p, 1);\n-        Node* longval = VectorNode::make(opc, in, nullptr, vlen, T_LONG);\n-        phase()->register_new_node_with_ctrl_of(longval, first);\n-        \/\/ Requires extra vector long -> int conversion.\n-        vn = VectorCastNode::make(Op_VectorCastL2X, longval, T_INT, vlen);\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_convert_opcode(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        BasicType bt = velt_basic_type(n);\n-        Node* in = vector_opd(p, 1);\n-        int vopc = VectorCastNode::opcode(opc, in->bottom_type()->is_vect()->element_basic_type());\n-        vn = VectorCastNode::make(vopc, in, bt, vlen);\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (opc == Op_FmaD || opc == Op_FmaF) {\n-        \/\/ Promote operands to vector\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = vector_opd(p, 2);\n-        Node* in3 = vector_opd(p, 3);\n-        vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else {\n-        assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n-        C->record_failure(C2Compiler::retry_no_superword());\n-        return false; \/\/ bailout\n-      }\n-\n-      if (vn == nullptr) {\n-        assert(false, \"got null node instead of vector node\");\n-        C->record_failure(C2Compiler::retry_no_superword());\n-        return false; \/\/ bailout\n-      }\n+    vtnode_idx_to_transformed_node.at_put(vtn->_idx, result.node());\n+    max_vector_length = MAX2(max_vector_length, result.vector_length());\n+    max_vector_width  = MAX2(max_vector_width,  result.vector_width());\n+  }\n+}\n@@ -2458,9 +2018,7 @@\n-#ifdef ASSERT\n-      \/\/ Mark Load\/Store Vector for alignment verification\n-      if (VerifyAlignVector) {\n-        if (vn->Opcode() == Op_LoadVector) {\n-          vn->as_LoadVector()->set_must_verify_alignment();\n-        } else if (vn->Opcode() == Op_StoreVector) {\n-          vn->as_StoreVector()->set_must_verify_alignment();\n-        }\n-      }\n+\/\/ We call \"apply\" on every VTransformNode, which replaces the packed scalar nodes with vector nodes.\n+void VTransform::apply_vectorization() const {\n+  Compile* C = phase()->C;\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    tty->print_cr(\"\\nVTransform::apply_vectorization:\");\n+  }\n@@ -2469,6 +2027,3 @@\n-      phase()->register_new_node_with_ctrl_of(vn, first);\n-      for (uint j = 0; j < p->size(); j++) {\n-        Node* pm = p->at(j);\n-        igvn().replace_node(pm, vn);\n-      }\n-      igvn()._worklist.push(vn);\n+  uint max_vector_length = 0; \/\/ number of elements\n+  uint max_vector_width  = 0; \/\/ total width in bytes\n+  _graph.apply_vectorization_for_each_vtnode(max_vector_length, max_vector_width);\n@@ -2476,9 +2031,2 @@\n-      if (vlen > max_vlen) {\n-        max_vlen = vlen;\n-      }\n-      if (vlen_in_bytes > max_vlen_in_bytes) {\n-        max_vlen_in_bytes = vlen_in_bytes;\n-      }\n-      VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    }\n-  }\/\/for (int i = 0; i < body().length(); i++)\n+  assert(max_vector_length > 0 && max_vector_width > 0, \"must have vectorized\");\n+  cl()->mark_loop_vectorized();\n@@ -2486,5 +2034,2 @@\n-  if (max_vlen_in_bytes > C->max_vector_size()) {\n-    C->set_max_vector_size(max_vlen_in_bytes);\n-  }\n-  if (max_vlen_in_bytes > 0) {\n-    cl->mark_loop_vectorized();\n+  if (max_vector_width > C->max_vector_size()) {\n+    C->set_max_vector_size(max_vector_width);\n@@ -2494,3 +2039,3 @@\n-    if (cl->has_passed_slp()) {\n-      uint slp_max_unroll_factor = cl->slp_max_unroll();\n-      if (slp_max_unroll_factor == max_vlen) {\n+    if (cl()->has_passed_slp()) {\n+      uint slp_max_unroll_factor = cl()->slp_max_unroll();\n+      if (slp_max_unroll_factor == max_vector_length) {\n@@ -2499,1 +2044,1 @@\n-          tty->print_cr(\"vector loop(unroll=%d, len=%d)\\n\", max_vlen, max_vlen_in_bytes*BitsPerByte);\n+          tty->print_cr(\"vector loop(unroll=%d, len=%d)\\n\", max_vector_length, max_vector_width * BitsPerByte);\n@@ -2503,1 +2048,1 @@\n-        cl->set_notpassed_slp();\n+        cl()->set_notpassed_slp();\n@@ -2507,1 +2052,1 @@\n-          cl->mark_do_unroll_only();\n+          cl()->mark_do_unroll_only();\n@@ -2512,118 +2057,0 @@\n-\n-  return true;\n-}\n-\n-\/\/------------------------------vector_opd---------------------------\n-\/\/ Create a vector operand for the nodes in pack p for operand: in(opd_idx)\n-Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {\n-  Node* p0 = p->at(0);\n-  uint vlen = p->size();\n-  Node* opd = p0->in(opd_idx);\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  Node* same_input = _packset.same_inputs_at_index_or_null(p, opd_idx);\n-\n-  \/\/ Insert index population operation to create a vector of increasing\n-  \/\/ indices starting from the iv value. In some special unrolled loops\n-  \/\/ (see JDK-8286125), we need scalar replications of the iv value if\n-  \/\/ all inputs are the same iv, so we do a same inputs check here.\n-  if (opd == iv() && same_input == nullptr) {\n-    BasicType p0_bt = velt_basic_type(p0);\n-    BasicType iv_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n-    assert(VectorNode::is_populate_index_supported(iv_bt), \"Should support\");\n-    const TypeVect* vt = TypeVect::make(iv_bt, vlen);\n-    Node* vn = new PopulateIndexNode(iv(), igvn().intcon(1), vt);\n-    VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    phase()->register_new_node_with_ctrl_of(vn, opd);\n-    return vn;\n-  }\n-\n-  if (same_input != nullptr) {\n-    if (opd->is_Vector() || opd->is_LoadVector()) {\n-      if (opd_idx == 2 && VectorNode::is_shift(p0)) {\n-        assert(false, \"shift's count can't be vector\");\n-        return nullptr;\n-      }\n-      return opd; \/\/ input is matching vector\n-    }\n-    if ((opd_idx == 2) && VectorNode::is_shift(p0)) {\n-      Node* cnt = opd;\n-      \/\/ Vector instructions do not mask shift count, do it here.\n-      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n-      const TypeInt* t = opd->find_int_type();\n-      if (t != nullptr && t->is_con()) {\n-        juint shift = t->get_con();\n-        if (shift > mask) { \/\/ Unsigned cmp\n-          cnt = igvn().intcon(shift & mask);\n-          phase()->set_ctrl(cnt, phase()->C->root());\n-        }\n-      } else {\n-        if (t == nullptr || t->_lo < 0 || t->_hi > (int)mask) {\n-          cnt = igvn().intcon(mask);\n-          cnt = new AndINode(opd, cnt);\n-          phase()->register_new_node_with_ctrl_of(cnt, opd);\n-        }\n-        if (!opd->bottom_type()->isa_int()) {\n-          assert(false, \"int type only\");\n-          return nullptr;\n-        }\n-      }\n-      \/\/ Move shift count into vector register.\n-      cnt = VectorNode::shift_count(p0->Opcode(), cnt, vlen, velt_basic_type(p0));\n-      phase()->register_new_node_with_ctrl_of(cnt, opd);\n-      return cnt;\n-    }\n-    if (opd->is_StoreVector()) {\n-      assert(false, \"StoreVector is not expected here\");\n-      return nullptr;\n-    }\n-    \/\/ Convert scalar input to vector with the same number of elements as\n-    \/\/ p0's vector. Use p0's type because size of operand's container in\n-    \/\/ vector should match p0's size regardless operand's size.\n-    const Type* p0_t = nullptr;\n-    VectorNode* vn = nullptr;\n-    if (opd_idx == 2 && VectorNode::is_scalar_rotate(p0)) {\n-       Node* conv = opd;\n-       p0_t =  TypeInt::INT;\n-       if (p0->bottom_type()->isa_long()) {\n-         p0_t = TypeLong::LONG;\n-         conv = new ConvI2LNode(opd);\n-         phase()->register_new_node_with_ctrl_of(conv, opd);\n-       }\n-       vn = VectorNode::scalar2vector(conv, vlen, p0_t);\n-    } else {\n-       p0_t =  velt_type(p0);\n-       vn = VectorNode::scalar2vector(opd, vlen, p0_t);\n-    }\n-\n-    phase()->register_new_node_with_ctrl_of(vn, opd);\n-    VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    return vn;\n-  }\n-\n-  \/\/ Insert pack operation\n-  BasicType bt = velt_basic_type(p0);\n-  PackNode* pk = PackNode::make(opd, vlen, bt);\n-  DEBUG_ONLY( const BasicType opd_bt = opd->bottom_type()->basic_type(); )\n-\n-  for (uint i = 1; i < vlen; i++) {\n-    Node* pi = p->at(i);\n-    Node* in = pi->in(opd_idx);\n-    if (get_pack(in) != nullptr) {\n-      assert(false, \"Should already have been unpacked\");\n-      return nullptr;\n-    }\n-    assert(opd_bt == in->bottom_type()->basic_type(), \"all same type\");\n-    pk->add_opd(in);\n-    if (VectorNode::is_muladds2i(pi)) {\n-      Node* in2 = pi->in(opd_idx + 2);\n-      if (get_pack(in2) != nullptr) {\n-        assert(false, \"Should already have been unpacked\");\n-        return nullptr;\n-      }\n-      assert(opd_bt == in2->bottom_type()->basic_type(), \"all same type\");\n-      pk->add_opd(in2);\n-    }\n-  }\n-  phase()->register_new_node_with_ctrl_of(pk, opd);\n-  VectorNode::trace_new_vector(pk, \"SuperWord\");\n-  return pk;\n@@ -2800,12 +2227,1 @@\n-  if (u_pk->size() != d_pk->size()) {\n-    return false;\n-  }\n-\n-  for (uint i = 0; i < u_pk->size(); i++) {\n-    Node* ui = u_pk->at(i);\n-    Node* di = d_pk->at(i);\n-    if (ui->in(u_idx) != di) {\n-      return false;\n-    }\n-  }\n-  return true;\n+  return _packset.pack_input_at_index_or_null(u_pk, u_idx) != nullptr;\n@@ -3173,0 +2589,6 @@\n+    \/\/ Float to half float conversion may be succeeded by a conversion from\n+    \/\/ half float to float, in such a case back propagation of narrow type (SHORT)\n+    \/\/ may not be possible.\n+    if (n->Opcode() == Op_ConvF2HF) {\n+      return TypeInt::SHORT;\n+    }\n@@ -3185,1 +2607,1 @@\n-LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {\n+LoadNode::ControlDependency VTransformLoadVectorNode::control_dependency() const {\n@@ -3187,2 +2609,2 @@\n-  for (uint i = 0; i < p->size(); i++) {\n-    Node* n = p->at(i);\n+  for (int i = 0; i < nodes().length(); i++) {\n+    Node* n = nodes().at(i);\n@@ -3205,2 +2627,2 @@\n-\/\/ determined by SuperWord::filter_packs_for_alignment().\n-void SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n+\/\/ determined (e.g. by SuperWord::filter_packs_for_alignment()).\n+void VTransform::determine_mem_ref_and_aw_for_main_loop_alignment() {\n@@ -3214,4 +2636,0 @@\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    MemNode* first = pack->at(0)->isa_Mem();\n-    if (first == nullptr) { continue; }\n@@ -3219,1 +2637,8 @@\n-    int vw = first->memory_size() * pack->size();\n+  const GrowableArray<VTransformNode*>& vtnodes = _graph.vtnodes();\n+  for (int i = 0; i < vtnodes.length(); i++) {\n+    VTransformVectorNode* vtn = vtnodes.at(i)->isa_Vector();\n+    if (vtn == nullptr) { continue; }\n+    MemNode* p0 = vtn->nodes().at(0)->isa_Mem();\n+    if (p0 == nullptr) { continue; }\n+\n+    int vw = p0->memory_size() * vtn->nodes().length();\n@@ -3222,1 +2647,1 @@\n-      mem_ref = first;\n+      mem_ref = p0;\n@@ -3232,1 +2657,1 @@\n-    if (is_trace_align_vector()) {      \\\n+    if (_trace._align_vector) {         \\\n@@ -3243,1 +2668,1 @@\n-void SuperWord::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n+void VTransform::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n@@ -3400,2 +2825,2 @@\n-  if (is_trace_align_vector()) {\n-    tty->print_cr(\"\\nadjust_pre_loop_limit_to_align_main_loop_vectors:\");\n+  if (_trace._align_vector) {\n+    tty->print_cr(\"\\nVTransform::adjust_pre_loop_limit_to_align_main_loop_vectors:\");\n@@ -3427,1 +2852,1 @@\n-    if (is_trace_align_vector()) {\n+    if (_trace._align_vector) {\n@@ -3443,1 +2868,1 @@\n-  if (is_trace_align_vector()) {\n+  if (_trace._align_vector) {\n@@ -3598,1 +3023,1 @@\n-  tty->print_cr(\"\\nBlock\");\n+  tty->print_cr(\"\\nVLoopBody::print\");\n@@ -3601,1 +3026,1 @@\n-    tty->print(\"%d \", i);\n+    tty->print(\"%4d \", i);\n@@ -3618,0 +3043,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":124,"deletions":698,"binary":false,"changes":822,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/vtransform.hpp\"\n@@ -370,0 +371,4 @@\n+  Node_List* pack_input_at_index_or_null(const Node_List* pack, const int index) const {\n+    return strided_pack_input_at_index_or_null(pack, index, 1, 0);\n+  }\n+\n@@ -602,7 +607,0 @@\n-  bool schedule_and_apply();\n-  bool apply(Node_List& memops_schedule);\n-  void apply_memops_reordering_with_schedule(Node_List& memops_schedule);\n-  bool apply_vectorization();\n-  \/\/ Create a vector operand for the nodes in pack p for operand: in(opd_idx)\n-  Node* vector_opd(Node_List* p, int opd_idx);\n-\n@@ -633,5 +631,1 @@\n-  static LoadNode::ControlDependency control_dependency(Node_List* p);\n-\n-  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n-  void determine_mem_ref_and_aw_for_main_loop_alignment();\n-  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n+  bool schedule_and_apply() const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+\n+void SuperWordVTransformBuilder::build() {\n+  assert(!_packset.is_empty(), \"must have non-empty packset\");\n+  assert(!_vtransform.has_graph(), \"start with empty vtransform\");\n+\n+  \/\/ Create vtnodes for all nodes in the loop.\n+  build_vector_vtnodes_for_packed_nodes();\n+  build_scalar_vtnodes_for_non_packed_nodes();\n+\n+  \/\/ Connect all vtnodes with their inputs. Possibly create vtnodes for input\n+  \/\/ nodes that are outside the loop.\n+  VectorSet vtn_dependencies; \/\/ Shared, but cleared for every vtnode.\n+  build_inputs_for_vector_vtnodes(vtn_dependencies);\n+  build_inputs_for_scalar_vtnodes(vtn_dependencies);\n+}\n+\n+void SuperWordVTransformBuilder::build_vector_vtnodes_for_packed_nodes() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    VTransformVectorNode* vtn = make_vector_vtnode_for_pack(pack);\n+    for (uint k = 0; k < pack->size(); k++) {\n+      map_node_to_vtnode(pack->at(k), vtn);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_scalar_vtnodes_for_non_packed_nodes() {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    if (_packset.get_pack(n) != nullptr) { continue; }\n+    VTransformScalarNode* vtn = new (_vtransform.arena()) VTransformScalarNode(_vtransform, n);\n+    map_node_to_vtnode(n, vtn);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    Node* p0 = pack->at(0);\n+\n+    VTransformVectorNode* vtn = get_vtnode(p0)->isa_Vector();\n+    assert(vtn != nullptr, \"all packs must have vector vtnodes\");\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (p0->is_Load()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+    } else if (p0->is_Store()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_vector(pack, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (vtn->isa_ReductionVector() != nullptr) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, 1); \/\/ scalar init\n+      set_req_with_vector(pack, vtn, vtn_dependencies, 2); \/\/ vector\n+    } else {\n+      assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n+      if (VectorNode::is_scalar_rotate(p0) &&\n+          p0->in(2)->is_Con() &&\n+          Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rotation\n+      } else if (VectorNode::is_roundopD(p0)) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rounding mode\n+      } else if (p0->is_CMove()) {\n+        \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n+        if (vtn_mask_cmp->test()._is_negated) {\n+          vtn->swap_req(2, 3); \/\/ swap if test was negated.\n+        }\n+      } else {\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+      }\n+    }\n+\n+    for (uint k = 0; k < pack->size(); k++) {\n+      add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n+    if (vtn == nullptr) { continue; }\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (n->is_Load()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+    } else if (n->is_Store()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (n->is_CountedLoop()) {\n+      continue; \/\/ Is \"root\", has no dependency.\n+    } else if (n->is_Phi()) {\n+      \/\/ CountedLoop Phi's: ignore backedge (and entry value).\n+      assert(n->in(0) == _vloop.cl(), \"only Phi's from the CountedLoop allowed\");\n+      set_req_with_scalar(n, vtn, vtn_dependencies, 0);\n+      continue;\n+    } else {\n+      set_all_req_with_scalars(n, vtn, vtn_dependencies);\n+    }\n+\n+    add_dependencies_of_node_to_vtnode(n, vtn, vtn_dependencies);\n+  }\n+}\n+\n+\/\/ Create a vtnode for each pack. No in\/out edges set yet.\n+VTransformVectorNode* SuperWordVTransformBuilder::make_vector_vtnode_for_pack(const Node_List* pack) const {\n+  uint pack_size = pack->size();\n+  Node* p0 = pack->at(0);\n+  int opc = p0->Opcode();\n+  VTransformVectorNode* vtn = nullptr;\n+\n+  if (p0->is_Load()) {\n+    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, pack_size);\n+  } else if (p0->is_Store()) {\n+    vtn = new (_vtransform.arena()) VTransformStoreVectorNode(_vtransform, pack_size);\n+  } else if (p0->is_Bool()) {\n+    VTransformBoolTest kind = _packset.get_bool_test(pack);\n+    vtn = new (_vtransform.arena()) VTransformBoolVectorNode(_vtransform, pack_size, kind);\n+  } else if (_vloop_analyzer.reductions().is_marked_reduction(p0)) {\n+    vtn = new (_vtransform.arena()) VTransformReductionVectorNode(_vtransform, pack_size);\n+  } else if (VectorNode::is_muladds2i(p0)) {\n+    \/\/ A special kind of binary element-wise vector op: the inputs are \"ints\" a and b,\n+    \/\/ but reinterpreted as two \"shorts\" [a0, a1] and [b0, b1]:\n+    \/\/   v = MulAddS2I(a, b) = a0 * b0 + a1 + b1\n+    assert(p0->req() == 5, \"MulAddS2I should have 4 operands\");\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, pack_size);\n+  } else {\n+    assert(p0->req() == 3 ||\n+           p0->is_CMove() ||\n+           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc) ||\n+           VectorNode::is_convert_opcode(opc) ||\n+           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc) ||\n+           opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"pack type must be in this list\");\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), pack_size);\n+  }\n+  vtn->set_nodes(pack);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index) {\n+  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n+  vtn->set_req(index, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+\/\/ Either get the existing vtnode vector input (when input is a pack), or else make a\n+\/\/ new vector vtnode for the input (e.g. for Replicate or PopulateIndex).\n+VTransformNode* SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index) {\n+  Node* p0 = pack->at(0);\n+\n+  Node_List* pack_in = _packset.pack_input_at_index_or_null(pack, index);\n+  if (pack_in != nullptr) {\n+    \/\/ Input is a matching pack -> vtnode already exists.\n+    assert(index != 2 || !VectorNode::is_shift(p0), \"shift's count cannot be vector\");\n+    return get_vtnode(pack_in->at(0));\n+  }\n+\n+  if (VectorNode::is_muladds2i(p0)) {\n+    assert(_packset.is_muladds2i_pack_with_pack_inputs(pack), \"inputs must all be packs\");\n+    \/\/ All inputs are strided (stride = 2), either with offset 0 or 1.\n+    Node_List* pack_in0 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 0);\n+    if (pack_in0 != nullptr) {\n+      return get_vtnode(pack_in0->at(0));\n+    }\n+    Node_List* pack_in1 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 1);\n+    if (pack_in1 != nullptr) {\n+      return get_vtnode(pack_in1->at(0));\n+    }\n+  }\n+\n+  Node* same_input = _packset.same_inputs_at_index_or_null(pack, index);\n+  if (same_input == nullptr && p0->in(index) == _vloop.iv()) {\n+    \/\/ PopulateIndex: [iv+0, iv+1, iv+2, ...]\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    BasicType p0_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+    \/\/ If we have subword type, take that type directly. If p0 is some ConvI2L\/F\/D,\n+    \/\/ then the p0_bt can also be L\/F\/D but we need to produce ints for the input of\n+    \/\/ the ConvI2L\/F\/D.\n+    BasicType element_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n+    VTransformNode* populate_index = new (_vtransform.arena()) VTransformPopulateIndexNode(_vtransform, pack->size(), element_bt);\n+    populate_index->set_req(1, iv_vtn);\n+    return populate_index;\n+  }\n+\n+  if (same_input != nullptr) {\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    if (index == 2 && VectorNode::is_shift(p0)) {\n+      \/\/ Scalar shift count for vector shift operation: vec2 = shiftV(vec1, scalar_count)\n+      \/\/ Scalar shift operations masks the shift count, but the vector shift does not, so\n+      \/\/ create a special ShiftCount node.\n+      BasicType element_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n+      VTransformNode* shift_count = new (_vtransform.arena()) VTransformShiftCountNode(_vtransform, pack->size(), element_bt, mask, p0->Opcode());\n+      shift_count->set_req(1, same_input_vtn);\n+      return shift_count;\n+    } else {\n+      \/\/ Replicate the scalar same_input to every vector element.\n+      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+        \/\/ Scalar rotate has int rotation value, but the scalar rotate expects longs.\n+        assert(same_input->bottom_type()->isa_int(), \"scalar rotate expects int rotation\");\n+        VTransformNode* conv = new (_vtransform.arena()) VTransformConvI2LNode(_vtransform);\n+        conv->set_req(1, same_input_vtn);\n+        same_input_vtn = conv;\n+      }\n+      VTransformNode* replicate = new (_vtransform.arena()) VTransformReplicateNode(_vtransform, pack->size(), element_type);\n+      replicate->set_req(1, same_input_vtn);\n+      return replicate;\n+    }\n+  }\n+\n+  \/\/ The input is neither a pack not a same_input node. SuperWord::profitable does not allow\n+  \/\/ any other case. In the future, we could insert a PackNode.\n+#ifdef ASSERT\n+  tty->print_cr(\"\\nSuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index: index=%d\", index);\n+  pack->dump();\n+  assert(false, \"Pack input was neither a pack nor a same_input node\");\n+#endif\n+  ShouldNotReachHere();\n+}\n+\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+  VTransformNode* vtn = get_vtnode_or_null(n);\n+  if (vtn != nullptr) { return vtn; }\n+\n+  assert(!_vloop.in_bb(n), \"only nodes outside the loop can be input nodes to the loop\");\n+  vtn = new (_vtransform.arena()) VTransformInputScalarNode(_vtransform, n);\n+  map_node_to_vtnode(n, vtn);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, int j) {\n+  VTransformNode* req = get_or_make_vtnode_vector_input_at_index(pack, j);\n+  vtn->set_req(j, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  assert(vtn->req() == n->req(), \"scalars must have same number of reqs\");\n+  for (uint j = 0; j < n->req(); j++) {\n+    Node* def = n->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_scalar(n, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  Node* p0 = pack->at(0);\n+  assert(vtn->req() <= p0->req(), \"must have at at most as many reqs\");\n+  \/\/ Vectors have no ctrl, so ignore it.\n+  for (uint j = 1; j < vtn->req(); j++) {\n+    Node* def = p0->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_vector(pack, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::add_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  for (VLoopDependencyGraph::PredsIterator preds(_vloop_analyzer.dependency_graph(), n); !preds.done(); preds.next()) {\n+    Node* pred = preds.current();\n+    if (!_vloop.in_bb(pred)) { continue; }\n+\n+    \/\/ Only add memory dependencies to memory nodes. All others are taken care of with the req.\n+    if (n->is_Mem() && !pred->is_Mem()) { continue; }\n+\n+    VTransformNode* dependency = get_vtnode(pred);\n+\n+    \/\/ Reduction self-cycle?\n+    if (vtn == dependency && _vloop_analyzer.reductions().is_marked_reduction(n)) { continue; }\n+\n+    if (vtn_dependencies.test_set(dependency->_idx)) { continue; }\n+    vtn->add_dependency(dependency); \/\/ Add every dependency only once per vtn.\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/superword.hpp\"\n+\n+#ifndef SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+#define SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+\n+\/\/ Facility class that builds a VTransform from a SuperWord PackSet.\n+class SuperWordVTransformBuilder : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+  const PackSet& _packset;\n+  VTransform& _vtransform;\n+\n+  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n+\n+public:\n+  SuperWordVTransformBuilder(const PackSet& packset,\n+                             VTransform& vtransform) :\n+      _vloop_analyzer(vtransform.vloop_analyzer()),\n+      _vloop(_vloop_analyzer.vloop()),\n+      _packset(packset),\n+      _vtransform(vtransform)\n+  {\n+    assert(!_vtransform.has_graph(), \"constructor is passed an empty vtransform\");\n+    build();\n+    assert(_vtransform.has_graph(), \"vtransform must contain some vtnodes now\");\n+  }\n+\n+private:\n+  void build();\n+  void build_vector_vtnodes_for_packed_nodes();\n+  void build_scalar_vtnodes_for_non_packed_nodes();\n+  void build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies);\n+  void build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies);\n+\n+  \/\/ Helper methods for building VTransform.\n+  VTransformNode* get_vtnode_or_null(Node* n) const {\n+    VTransformNode** ptr = _idx_to_vtnode.get(n->_idx);\n+    return (ptr == nullptr) ? nullptr : *ptr;\n+  }\n+\n+  VTransformNode* get_vtnode(Node* n) const {\n+    VTransformNode* vtn = get_vtnode_or_null(n);\n+    assert(vtn != nullptr, \"expect non-null vtnode\");\n+    return vtn;\n+  }\n+\n+  void map_node_to_vtnode(Node* n, VTransformNode* vtn) {\n+    assert(vtn != nullptr, \"only set non-null vtnodes\");\n+    _idx_to_vtnode.put_when_absent(n->_idx, vtn);\n+  }\n+\n+  VTransformVectorNode* make_vector_vtnode_for_pack(const Node_List* pack) const;\n+  VTransformNode* get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index);\n+  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n+  void set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void add_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+};\n+\n+#endif \/\/ SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+  flags(VTRANSFORM,           \"Trace VTransform Graph\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"opto\/matcher.hpp\"\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"opto\/node.hpp\"\n+#include \"opto\/matcher.hpp\"\n@@ -766,3 +766,3 @@\n-  bool overlap_possible_with_any_in(const Node_List* p) const {\n-    for (uint k = 0; k < p->size(); k++) {\n-      MemNode* mem = p->at(k)->as_Mem();\n+  bool overlap_possible_with_any_in(const GrowableArray<Node*>& nodes) const {\n+    for (int i = 0; i < nodes.length(); i++) {\n+      MemNode* mem = nodes.at(i)->as_Mem();\n@@ -1326,8 +1326,0 @@\n-struct VTransformBoolTest {\n-  const BoolTest::mask _mask;\n-  const bool _is_negated;\n-\n-  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n-    _mask(mask), _is_negated(is_negated) {}\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+#include \"opto\/convertnode.hpp\"\n+\n+void VTransformGraph::add_vtnode(VTransformNode* vtnode) {\n+  assert(vtnode->_idx == _vtnodes.length(), \"position must match idx\");\n+  _vtnodes.push(vtnode);\n+}\n+\n+\/\/ Compute a linearization of the graph. We do this with a reverse-post-order of a DFS.\n+\/\/ This only works if the graph is a directed acyclic graph (DAG). The C2 graph, and\n+\/\/ the VLoopDependencyGraph are both DAGs, but after introduction of vectors\/packs, the\n+\/\/ graph has additional constraints which can introduce cycles. Example:\n+\/\/\n+\/\/                                                       +--------+\n+\/\/  A -> X                                               |        v\n+\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n+\/\/  Y -> B                                                 ^        |\n+\/\/                                                         +--------+\n+\/\/\n+\/\/ We return \"true\" IFF we find no cycle, i.e. if the linearization succeeds.\n+bool VTransformGraph::schedule() {\n+  assert(!is_scheduled(), \"not yet scheduled\");\n+\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    print_vtnodes();\n+  }\n+#endif\n+\n+  ResourceMark rm;\n+  GrowableArray<VTransformNode*> stack;\n+  VectorSet pre_visited;\n+  VectorSet post_visited;\n+\n+  collect_nodes_without_req_or_dependency(stack);\n+\n+  \/\/ We create a reverse-post-visit order. This gives us a linearization, if there are\n+  \/\/ no cycles. Then, we simply reverse the order, and we have a schedule.\n+  int rpo_idx = _vtnodes.length() - 1;\n+  while (!stack.is_empty()) {\n+    VTransformNode* vtn = stack.top();\n+    if (!pre_visited.test_set(vtn->_idx)) {\n+      \/\/ Forward arc in graph (pre-visit).\n+    } else if (!post_visited.test(vtn->_idx)) {\n+      \/\/ Forward arc in graph. Check if all uses were already visited:\n+      \/\/   Yes -> post-visit.\n+      \/\/   No  -> we are mid-visit.\n+      bool all_uses_already_visited = true;\n+\n+      for (int i = 0; i < vtn->outs(); i++) {\n+        VTransformNode* use = vtn->out(i);\n+        if (post_visited.test(use->_idx)) { continue; }\n+        if (pre_visited.test(use->_idx)) {\n+          \/\/ Cycle detected!\n+          \/\/ The nodes that are pre_visited but not yet post_visited form a path from\n+          \/\/ the \"root\" to the current vtn. Now, we are looking at an edge (vtn, use),\n+          \/\/ and discover that use is also pre_visited but not post_visited. Thus, use\n+          \/\/ lies on that path from \"root\" to vtn, and the edge (vtn, use) closes a\n+          \/\/ cycle.\n+          NOT_PRODUCT(if (_trace._rejections) { trace_schedule_cycle(stack, pre_visited, post_visited); } )\n+          return false;\n+        }\n+        stack.push(use);\n+        all_uses_already_visited = false;\n+      }\n+\n+      if (all_uses_already_visited) {\n+        stack.pop();\n+        post_visited.set(vtn->_idx);           \/\/ post-visit\n+        _schedule.at_put_grow(rpo_idx--, vtn); \/\/ assign rpo_idx\n+      }\n+    } else {\n+      stack.pop(); \/\/ Already post-visited. Ignore secondary edge.\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    print_schedule();\n+  }\n+#endif\n+\n+  assert(rpo_idx == -1, \"used up all rpo_idx, rpo_idx=%d\", rpo_idx);\n+  return true;\n+}\n+\n+\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n+void VTransformGraph::collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    VTransformNode* vtn = _vtnodes.at(i);\n+    if (!vtn->has_req_or_dependency()) {\n+      stack.push(vtn);\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                                           const VectorSet& pre_visited,\n+                                           const VectorSet& post_visited) const {\n+  tty->print_cr(\"\\nVTransform::schedule found a cycle on path (P), vectorization attempt fails.\");\n+  for (int j = 0; j < stack.length(); j++) {\n+    VTransformNode* n = stack.at(j);\n+    bool on_path = pre_visited.test(n->_idx) && !post_visited.test(n->_idx);\n+    tty->print(\"  %s \", on_path ? \"P\" : \"_\");\n+    n->print();\n+  }\n+}\n+\n+void VTransformApplyResult::trace(VTransformNode* vtnode) const {\n+  tty->print(\"  apply: \");\n+  vtnode->print();\n+  tty->print(\"    ->   \");\n+  if (_node == nullptr) {\n+    tty->print_cr(\"nullptr\");\n+  } else {\n+    _node->dump();\n+  }\n+}\n+#endif\n+\n+Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n+  assert(n != nullptr, \"must find input IR node\");\n+  return n;\n+}\n+\n+VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                  const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                     const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  VectorNode* vn = VectorNode::scalar2vector(val, _vlen, _element_type);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                   const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* n = new ConvI2LNode(val);\n+  register_new_node_from_vectorization(vloop_analyzer, n, val);\n+  return VTransformApplyResult::make_scalar(n);\n+}\n+\n+VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(shift_count_in->bottom_type()->isa_int(), \"int type only for shift count\");\n+  \/\/ The shift_count_in would be automatically truncated to the lowest _mask\n+  \/\/ bits in a scalar shift operation. But vector shift does not truncate, so\n+  \/\/ we must apply the mask now.\n+  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n+  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n+  \/\/ Now that masked value is \"boadcast\" (some platforms only set the lowest element).\n+  VectorNode* vn = VectorNode::shift_count(_shift_opcode, shift_count_masked, _vlen, _element_bt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+\n+VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                         const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(val->is_Phi(), \"expected to be iv\");\n+  assert(VectorNode::is_populate_index_supported(_element_bt), \"should support\");\n+  const TypeVect* vt = TypeVect::make(_element_bt, _vlen);\n+  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                             const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  if (first->is_Cmp()) {\n+    \/\/ Cmp + Bool -> VectorMaskCmp\n+    \/\/ Handled by Bool \/ VTransformBoolVectorNode, so we do not generate any nodes here.\n+    return VTransformApplyResult::make_empty();\n+  }\n+\n+  assert(2 <= req() && req() <= 4, \"Must have 1-3 inputs\");\n+  VectorNode* vn = nullptr;\n+  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n+  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n+\n+  if (first->is_CMove()) {\n+    assert(req() == 4, \"three inputs expected: mask, blend1, blend2\");\n+    vn = new VectorBlendNode(\/* blend1 *\/ in2, \/* blend2 *\/ in3, \/* mask *\/ in1);\n+  } else if (VectorNode::is_convert_opcode(opc)) {\n+    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n+    int vopc = VectorCastNode::opcode(opc, in1->bottom_type()->is_vect()->element_basic_type());\n+    vn = VectorCastNode::make(vopc, in1, bt, vlen);\n+  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(first, bt)) {\n+    opc = Op_RShiftI;\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt);\n+  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n+    \/\/ The scalar operation was a long -> int operation.\n+    \/\/ However, the vector operation is long -> long.\n+    VectorNode* long_vn = VectorNode::make(opc, in1, nullptr, vlen, T_LONG);\n+    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n+    \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n+    vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n+  } else if (req() == 3 ||\n+             VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n+    assert(!VectorNode::is_roundopD(first) || in2->is_Con(), \"rounding mode must be constant\");\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt); \/\/ unary and binary\n+  } else {\n+    assert(req() == 4, \"three inputs expected\");\n+    assert(opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"element wise operation must be from this list\");\n+    vn = VectorNode::make(opc, in1, in2, in3, vlen, bt); \/\/ ternary\n+  }\n+\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  BoolNode* first = nodes().at(0)->as_Bool();\n+  uint  vlen = nodes().length();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Cmp + Bool -> VectorMaskCmp\n+  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n+  assert(vtn_cmp != nullptr && vtn_cmp->nodes().at(0)->is_Cmp(),\n+         \"bool vtn expects cmp vtn as input\");\n+\n+  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n+  BoolTest::mask mask = test()._mask;\n+\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n+  VectorNode* vn = new VectorMaskCmpNode(mask, cmp_in1, cmp_in2, mask_node, vt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                           const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = first->bottom_type()->basic_type();\n+\n+  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n+\n+  ReductionNode* vn = ReductionNode::make(opc, nullptr, init, vec, bt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  LoadNode* first = nodes().at(0)->as_Load();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Set the memory dependency of the LoadVector as early as possible.\n+  \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n+  \/\/ does not have any memory dependency.\n+  while (mem->is_StoreVector()) {\n+    VPointer p_store(mem->as_Mem(), vloop_analyzer.vloop());\n+    if (p_store.overlap_possible_with_any_in(nodes())) {\n+      break;\n+    } else {\n+      mem = mem->in(MemNode::Memory);\n+    }\n+  }\n+\n+  LoadVectorNode* vn = LoadVectorNode::make(opc, ctrl, mem, adr, adr_type, vlen, bt,\n+                                            control_dependency());\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n+                                                       const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  StoreNode* first = nodes().at(0)->as_Store();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+\n+  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n+  StoreVectorNode* vn = StoreVectorNode::make(opc, ctrl, mem, adr, adr_type, value, vlen);\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* first = nodes().at(0);\n+\n+  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n+\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    phase->igvn().replace_node(n, vn);\n+  }\n+}\n+\n+void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  phase->register_new_node_with_ctrl_of(vn, old_node);\n+  phase->igvn()._worklist.push(vn);\n+  VectorNode::trace_new_vector(vn, \"AutoVectorization\");\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::print_vtnodes() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_vtnodes:\");\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    _vtnodes.at(i)->print();\n+  }\n+}\n+\n+void VTransformGraph::print_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_schedule:\");\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    tty->print(\" %3d: \", i);\n+    VTransformNode* vtn = _schedule.at(i);\n+    if (vtn == nullptr) {\n+      tty->print_cr(\"nullptr\");\n+    } else {\n+      vtn->print();\n+    }\n+  }\n+}\n+\n+void VTransformGraph::print_memops_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_memops_schedule:\");\n+  int i = 0;\n+  for_each_memop_in_schedule([&] (MemNode* mem) {\n+    tty->print(\" %3d: \", i++);\n+    mem->dump();\n+  });\n+}\n+\n+void VTransformNode::print() const {\n+  tty->print(\"%3d %s (\", _idx, name());\n+  for (uint i = 0; i < _req; i++) {\n+    print_node_idx(_in.at(i));\n+  }\n+  if ((uint)_in.length() > _req) {\n+    tty->print(\" |\");\n+    for (int i = _req; i < _in.length(); i++) {\n+      print_node_idx(_in.at(i));\n+    }\n+  }\n+  tty->print(\") [\");\n+  for (int i = 0; i < _out.length(); i++) {\n+    print_node_idx(_out.at(i));\n+  }\n+  tty->print(\"] \");\n+  print_spec();\n+  tty->cr();\n+}\n+\n+void VTransformNode::print_node_idx(const VTransformNode* vtn) {\n+  if (vtn == nullptr) {\n+    tty->print(\" _\");\n+  } else {\n+    tty->print(\" %d\", vtn->_idx);\n+  }\n+}\n+\n+void VTransformScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformReplicateNode::print_spec() const {\n+  tty->print(\"vlen=%d element_type=\", _vlen);\n+  _element_type->dump();\n+}\n+\n+void VTransformShiftCountNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s mask=%d shift_opcode=%s\",\n+             _vlen, type2name(_element_bt), _mask,\n+             NodeClassNames[_shift_opcode]);\n+}\n+\n+void VTransformPopulateIndexNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s\", _vlen, type2name(_element_bt));\n+}\n+\n+void VTransformVectorNode::print_spec() const {\n+  tty->print(\"%d-pack[\", _nodes.length());\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    if (i > 0) {\n+      tty->print(\", \");\n+    }\n+    tty->print(\"%d %s\", n->_idx, n->Name());\n+  }\n+  tty->print(\"]\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_OPTO_VTRANSFORM_HPP\n+#define SHARE_OPTO_VTRANSFORM_HPP\n+\n+#include \"opto\/node.hpp\"\n+#include \"opto\/vectorization.hpp\"\n+\n+\/\/ VTransform:\n+\/\/ - Models the transformation of the scalar loop to vectorized loop:\n+\/\/   It is a \"C2 subgraph\" -> \"C2 subgraph\" mapping.\n+\/\/ - The VTransform contains a graph (VTransformGraph), which consists of\n+\/\/   many vtnodes (VTransformNode).\n+\/\/ - Each vtnode models a part of the transformation, and is supposed\n+\/\/   to represent the output C2 nodes after the vectorization as closely\n+\/\/   as possible.\n+\/\/\n+\/\/ This is the life-cycle of a VTransform:\n+\/\/ - Construction:\n+\/\/   - From SuperWord, with the SuperWordVTransformBuilder.\n+\/\/\n+\/\/ - Future Plans: optimize, if-conversion, etc.\n+\/\/\n+\/\/ - Schedule:\n+\/\/   - Compute linearization of the VTransformGraph, into an order that respects\n+\/\/     all edges in the graph (bailout if cycle detected).\n+\/\/\n+\/\/ - Apply:\n+\/\/   - Changes to the C2 IR are only made once the \"apply\" method is called.\n+\/\/   - Each vtnode generates its corresponding scalar and vector C2 nodes,\n+\/\/     possibly replacing old scalar C2 nodes.\n+\/\/\n+\/\/ Future Plans with VTransform:\n+\/\/ - Cost model: estimate if vectorization is profitable.\n+\/\/ - Optimizations: moving unordered reductions out of the loop, whih decreases cost.\n+\/\/ - Pack\/Unpack\/Shuffle: introduce additional nodes not present in the scalar loop.\n+\/\/                        This is difficult to do with the SuperWord packset approach.\n+\/\/ - If-conversion: convert predicated nodes into CFG.\n+\n+typedef int VTransformNodeIDX;\n+class VTransformNode;\n+class VTransformScalarNode;\n+class VTransformInputScalarNode;\n+class VTransformVectorNode;\n+class VTransformElementWiseVectorNode;\n+class VTransformBoolVectorNode;\n+class VTransformReductionVectorNode;\n+\n+\/\/ Result from VTransformNode::apply\n+class VTransformApplyResult {\n+private:\n+  Node* const _node;\n+  const uint _vector_length; \/\/ number of elements\n+  const uint _vector_width;  \/\/ total width in bytes\n+\n+  VTransformApplyResult(Node* n, uint vector_length, uint vector_width) :\n+    _node(n),\n+    _vector_length(vector_length),\n+    _vector_width(vector_width) {}\n+\n+public:\n+  static VTransformApplyResult make_scalar(Node* n) {\n+    return VTransformApplyResult(n, 0, 0);\n+  }\n+\n+  static VTransformApplyResult make_vector(Node* n, uint vector_length, uint vector_width) {\n+    assert(vector_length > 0 && vector_width > 0, \"must have nonzero size\");\n+    return VTransformApplyResult(n, vector_length, vector_width);\n+  }\n+\n+  static VTransformApplyResult make_empty() {\n+    return VTransformApplyResult(nullptr, 0, 0);\n+  }\n+\n+  Node* node() const { return _node; }\n+  uint vector_length() const { return _vector_length; }\n+  uint vector_width() const { return _vector_width; }\n+  NOT_PRODUCT( void trace(VTransformNode* vtnode) const; )\n+};\n+\n+#ifndef PRODUCT\n+\/\/ Convenience class for tracing flags.\n+class VTransformTrace {\n+public:\n+  const bool _verbose;\n+  const bool _rejections;\n+  const bool _align_vector;\n+  const bool _info;\n+\n+  VTransformTrace(const VTrace& vtrace,\n+                  const bool is_trace_rejections,\n+                  const bool is_trace_align_vector,\n+                  const bool is_trace_info) :\n+    _verbose     (vtrace.is_trace(TraceAutoVectorizationTag::ALL)),\n+    _rejections  (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n+    _align_vector(_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n+    _info        (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n+\n+  static bool is_trace_vtransform(const VTrace& vtrace) {\n+    return vtrace.is_trace(TraceAutoVectorizationTag::VTRANSFORM);\n+  }\n+};\n+#endif\n+\n+\/\/ VTransformGraph: component of VTransform\n+\/\/ See description at top of this file.\n+class VTransformGraph : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  NOT_PRODUCT(const VTransformTrace _trace;)\n+\n+  VTransformNodeIDX _next_idx;\n+  GrowableArray<VTransformNode*> _vtnodes;\n+\n+  \/\/ Schedule (linearization) of the graph. We use this to reorder the memory graph\n+  \/\/ before inserting vector operations.\n+  GrowableArray<VTransformNode*> _schedule;\n+\n+public:\n+  VTransformGraph(const VLoopAnalyzer& vloop_analyzer,\n+                  Arena& arena\n+                  NOT_PRODUCT( COMMA const VTransformTrace trace)) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    NOT_PRODUCT(_trace(trace) COMMA)\n+    _next_idx(0),\n+    _vtnodes(&arena, _vloop.estimated_body_length(), 0, nullptr),\n+    _schedule(&arena, _vloop.estimated_body_length(), 0, nullptr) {}\n+\n+  VTransformNodeIDX new_idx() { return _next_idx++; }\n+  void add_vtnode(VTransformNode* vtnode);\n+  DEBUG_ONLY( bool is_empty() const { return _vtnodes.is_empty(); } )\n+  DEBUG_ONLY( bool is_scheduled() const { return _schedule.is_nonempty(); } )\n+  const GrowableArray<VTransformNode*>& vtnodes() const { return _vtnodes; }\n+\n+  bool schedule();\n+  void apply_memops_reordering_with_schedule() const;\n+  void apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const;\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  bool in_bb(const Node* n)   const { return _vloop.in_bb(n); }\n+\n+  void collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+\n+  template<typename Callback>\n+  void for_each_memop_in_schedule(Callback callback) const;\n+\n+#ifndef PRODUCT\n+  void print_vtnodes() const;\n+  void print_schedule() const;\n+  void print_memops_schedule() const;\n+  void trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                            const VectorSet& pre_visited,\n+                            const VectorSet& post_visited) const;\n+#endif\n+};\n+\n+\/\/ VTransform: models the transformation of the scalar loop to vectorized loop.\n+\/\/ It is a \"C2 subgraph\" to \"C2 subgraph\" mapping.\n+\/\/ See description at top of this file.\n+class VTransform : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  NOT_PRODUCT(const VTransformTrace _trace;)\n+\n+  \/\/ Everything in the vtransform is allocated from this arena, including all vtnodes.\n+  Arena _arena;\n+\n+  VTransformGraph _graph;\n+\n+  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ by adjusting the pre-loop limit.\n+  MemNode const* _mem_ref_for_main_loop_alignment;\n+  int _aw_for_main_loop_alignment;\n+\n+public:\n+  VTransform(const VLoopAnalyzer& vloop_analyzer,\n+             MemNode const* mem_ref_for_main_loop_alignment,\n+             int aw_for_main_loop_alignment\n+             NOT_PRODUCT( COMMA const VTransformTrace trace)\n+             ) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    NOT_PRODUCT(_trace(trace) COMMA)\n+    _arena(mtCompiler),\n+    _graph(_vloop_analyzer, _arena NOT_PRODUCT(COMMA _trace)),\n+    _mem_ref_for_main_loop_alignment(mem_ref_for_main_loop_alignment),\n+    _aw_for_main_loop_alignment(aw_for_main_loop_alignment) {}\n+\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+  Arena* arena() { return &_arena; }\n+  DEBUG_ONLY( bool has_graph() const { return !_graph.is_empty(); } )\n+  VTransformGraph& graph() { return _graph; }\n+\n+  bool schedule() { return _graph.schedule(); }\n+  void apply();\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  IdealLoopTree* lpt()        const { return _vloop.lpt(); }\n+  CountedLoopNode* cl()       const { return _vloop.cl(); }\n+  int iv_stride()             const { return cl()->stride_con(); }\n+\n+  \/\/ VLoopVPointers accessors\n+  const VPointer& vpointer(const MemNode* mem) const {\n+    return _vloop_analyzer.vpointers().vpointer(mem);\n+  }\n+\n+  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n+  void determine_mem_ref_and_aw_for_main_loop_alignment();\n+  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n+\n+  void apply_vectorization() const;\n+};\n+\n+\/\/ The vtnodes (VTransformNode) resemble the C2 IR Nodes, and model a part of the\n+\/\/ VTransform. Many such vtnodes make up the VTransformGraph. The vtnodes represent\n+\/\/ the resulting scalar and vector nodes as closely as possible.\n+\/\/ See description at top of this file.\n+class VTransformNode : public ArenaObj {\n+public:\n+  const VTransformNodeIDX _idx;\n+\n+private:\n+  \/\/ _in is split into required inputs (_req), and additional dependencies.\n+  const uint _req;\n+  GrowableArray<VTransformNode*> _in;\n+  GrowableArray<VTransformNode*> _out;\n+\n+public:\n+  VTransformNode(VTransform& vtransform, const uint req) :\n+    _idx(vtransform.graph().new_idx()),\n+    _req(req),\n+    _in(vtransform.arena(),  req, req, nullptr),\n+    _out(vtransform.arena(), 4, 0, nullptr)\n+  {\n+    vtransform.graph().add_vtnode(this);\n+  }\n+\n+  void set_req(uint i, VTransformNode* n) {\n+    assert(i < _req, \"must be a req\");\n+    assert(_in.at(i) == nullptr && n != nullptr, \"only set once\");\n+    _in.at_put(i, n);\n+    n->add_out(this);\n+  }\n+\n+  void swap_req(uint i, uint j) {\n+    assert(i < _req, \"must be a req\");\n+    assert(j < _req, \"must be a req\");\n+    VTransformNode* tmp = _in.at(i);\n+    _in.at_put(i, _in.at(j));\n+    _in.at_put(j, tmp);\n+  }\n+\n+  void add_dependency(VTransformNode* n) {\n+    assert(n != nullptr, \"no need to add nullptr\");\n+    _in.push(n);\n+    n->add_out(this);\n+  }\n+\n+  void add_out(VTransformNode* n) {\n+    _out.push(n);\n+  }\n+\n+  uint req() const { return _req; }\n+  VTransformNode* in(int i) const { return _in.at(i); }\n+  int outs() const { return _out.length(); }\n+  VTransformNode* out(int i) const { return _out.at(i); }\n+\n+  bool has_req_or_dependency() const {\n+    for (int i = 0; i < _in.length(); i++) {\n+      if (_in.at(i) != nullptr) { return true; }\n+    }\n+    return false;\n+  }\n+\n+  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n+  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformVectorNode* isa_Vector() { return nullptr; }\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() { return nullptr; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() { return nullptr; }\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() { return nullptr; }\n+\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n+\n+  Node* find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const;\n+\n+  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n+\n+  NOT_PRODUCT(virtual const char* name() const = 0;)\n+  NOT_PRODUCT(void print() const;)\n+  NOT_PRODUCT(virtual void print_spec() const {};)\n+  NOT_PRODUCT(static void print_node_idx(const VTransformNode* vtn);)\n+};\n+\n+\/\/ Identity transform for scalar nodes.\n+class VTransformScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n) {}\n+  Node* node() const { return _node; }\n+  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Wrapper node for nodes outside the loop that are inputs to nodes in the loop.\n+\/\/ Since we want the loop-internal nodes to be able to reference all inputs as vtnodes,\n+\/\/ we must wrap the inputs that are outside the loop into special vtnodes, too.\n+class VTransformInputScalarNode : public VTransformScalarNode {\n+public:\n+  VTransformInputScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformScalarNode(vtransform, n) {}\n+  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n+  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+};\n+\n+\/\/ Transform produces a ReplicateNode, replicating the input to all vector lanes.\n+class VTransformReplicateNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const Type* _element_type;\n+public:\n+  VTransformReplicateNode(VTransform& vtransform, int vlen, const Type* element_type) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_type(element_type) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Replicate\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a scalar ConvI2LNode that was not previously in the C2 graph.\n+class VTransformConvI2LNode : public VTransformNode {\n+public:\n+  VTransformConvI2LNode(VTransform& vtransform) : VTransformNode(vtransform, 2) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ConvI2L\"; };)\n+};\n+\n+\/\/ Transform introduces a shift-count node that truncates the shift count for a vector shift.\n+class VTransformShiftCountNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+  juint _mask;\n+  int _shift_opcode;\n+public:\n+  VTransformShiftCountNode(VTransform& vtransform, int vlen, BasicType element_bt, juint mask, int shift_opcode) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_bt(element_bt), _mask(mask), _shift_opcode(shift_opcode) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ShiftCount\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a PopulateIndex node: [phi, phi+1, phi+2, phi+3, ...].\n+class VTransformPopulateIndexNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+public:\n+  VTransformPopulateIndexNode(VTransform& vtransform, int vlen, const BasicType element_bt) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_bt(element_bt) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"PopulateIndex\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Base class for all vector vtnodes.\n+class VTransformVectorNode : public VTransformNode {\n+private:\n+  GrowableArray<Node*> _nodes;\n+public:\n+  VTransformVectorNode(VTransform& vtransform, const uint req, const uint number_of_nodes) :\n+    VTransformNode(vtransform, req), _nodes(vtransform.arena(), number_of_nodes, number_of_nodes, nullptr) {}\n+\n+  void set_nodes(const Node_List* pack) {\n+    for (uint k = 0; k < pack->size(); k++) {\n+      _nodes.at_put(k, pack->at(k));\n+    }\n+  }\n+\n+  const GrowableArray<Node*>& nodes() const { return _nodes; }\n+  virtual VTransformVectorNode* isa_Vector() override { return this; }\n+  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Catch all for all element-wise vector operations.\n+class VTransformElementWiseVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformElementWiseVectorNode(VTransform& vtransform, uint req, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, req, number_of_nodes) {}\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ElementWiseVector\"; };)\n+};\n+\n+struct VTransformBoolTest {\n+  const BoolTest::mask _mask;\n+  const bool _is_negated;\n+\n+  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n+    _mask(mask), _is_negated(is_negated) {}\n+};\n+\n+class VTransformBoolVectorNode : public VTransformElementWiseVectorNode {\n+private:\n+  const VTransformBoolTest _test;\n+public:\n+  VTransformBoolVectorNode(VTransform& vtransform, uint number_of_nodes, VTransformBoolTest test) :\n+    VTransformElementWiseVectorNode(vtransform, 2, number_of_nodes), _test(test) {}\n+  VTransformBoolTest test() const { return _test; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"BoolVector\"; };)\n+};\n+\n+class VTransformReductionVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, scalar init, vector]\n+  VTransformReductionVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ReductionVector\"; };)\n+};\n+\n+class VTransformLoadVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, mem, adr]\n+  VTransformLoadVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  LoadNode::ControlDependency control_dependency() const;\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoadVector\"; };)\n+};\n+\n+class VTransformStoreVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 4 -> [ctrl, mem, adr, val]\n+  VTransformStoreVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 4, number_of_nodes) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"StoreVector\"; };)\n+};\n+\n+\/\/ Invoke callback on all memops, in the order of the schedule.\n+template<typename Callback>\n+void VTransformGraph::for_each_memop_in_schedule(Callback callback) const {\n+  assert(_schedule.length() == _vtnodes.length(), \"schedule was computed\");\n+\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+\n+    \/\/ We can ignore input nodes, they are outside the loop.\n+    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+\n+    VTransformScalarNode* scalar = vtn->isa_Scalar();\n+    if (scalar != nullptr && scalar->node()->is_Mem()) {\n+      callback(scalar->node()->as_Mem());\n+    }\n+\n+    VTransformVectorNode* vector = vtn->isa_Vector();\n+    if (vector != nullptr && vector->nodes().at(0)->is_Mem()) {\n+      for (int j = 0; j < vector->nodes().length(); j++) {\n+        callback(vector->nodes().at(j)->as_Mem());\n+      }\n+    }\n+  }\n+}\n+\n+#endif \/\/ SHARE_OPTO_VTRANSFORM_HPP\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 Red Hat, Inc.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 Red Hat, Inc.\n@@ -3872,1 +3872,1 @@\n-  JavaThread* thread = new JavaThread(true);\n+  JavaThread* thread = JavaThread::create_attaching_thread();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,0 +117,3 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#endif\n@@ -523,0 +526,9 @@\n+JVM_LEAF(jboolean, JVM_IsContainerized(void))\n+#ifdef LINUX\n+  if (OSContainer::is_containerized()) {\n+    return JNI_TRUE;\n+  }\n+#endif\n+  return JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2342,1 +2342,1 @@\n-  ClassLoaderDataGraph::modules_do(&do_module);\n+  ClassLoaderDataGraph::modules_do_keepalive(&do_module);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    ClassLoaderDataGraph::loaded_classes_do(&closure);\n+    ClassLoaderDataGraph::loaded_classes_do_keepalive(&closure);\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-class OldRegionsLivenessClosure: public HeapRegionClosure {\n+class OldRegionsLivenessClosure: public G1HeapRegionClosure {\n@@ -1121,0 +1121,4 @@\n+size_t WhiteBox::get_in_use_monitor_count() {\n+  return ObjectSynchronizer::_in_use_list.count();\n+}\n+\n@@ -1856,0 +1860,4 @@\n+WB_ENTRY(jlong, WB_getInUseMonitorCount(JNIEnv* env, jobject wb))\n+  return (jlong) WhiteBox::get_in_use_monitor_count();\n+WB_END\n+\n@@ -2935,0 +2943,1 @@\n+  {CC\"getInUseMonitorCount\", CC\"()J\", (void*)&WB_getInUseMonitorCount  },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  static size_t get_in_use_monitor_count();\n","filename":"src\/hotspot\/share\/prims\/whitebox.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  { \"UseEmptySlotsInSupers\",        JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"LockingMode\",                  JDK_Version::jdk(24), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n@@ -517,0 +517,1 @@\n+  { \"UseEmptySlotsInSupers\",        JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -525,0 +526,1 @@\n+  { \"UseVtableBasedCHA\",               JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -977,1 +977,0 @@\n-  ResourceMark rm(thread);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -992,3 +992,0 @@\n-  product(bool, UseVtableBasedCHA, true,  DIAGNOSTIC,                       \\\n-          \"Use vtable information during CHA\")                              \\\n-                                                                            \\\n@@ -1435,3 +1432,0 @@\n-  develop(bool, MetaspaceGuardAllocations, false,                           \\\n-          \"Metapace allocations are guarded.\")                              \\\n-                                                                            \\\n@@ -1989,4 +1983,0 @@\n-  product(bool, UseEmptySlotsInSupers, true,                                \\\n-          \"(Deprecated) Allow allocating fields in empty slots of \"         \\\n-          \"super-classes\")                                                  \\\n-                                                                            \\\n@@ -2002,3 +1992,3 @@\n-          \"Select locking mode: \"                                           \\\n-          \"0: monitors only (LM_MONITOR), \"                                 \\\n-          \"1: monitors & legacy stack-locking (LM_LEGACY), \"                \\\n+          \"(Deprecated) Select locking mode: \"                              \\\n+          \"0: (Deprecated) monitors only (LM_MONITOR), \"                    \\\n+          \"1: (Deprecated) monitors & legacy stack-locking (LM_LEGACY), \"   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,1 +192,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n+  HandleArea(MEMFLAGS flags, HandleArea* prev) : Arena(flags, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+void ExternalsRecorder_init(); \/\/ After mutex_init() and before CodeCache_init\n@@ -110,0 +111,1 @@\n+  ExternalsRecorder_init(); \/\/ After mutex_init() and before CodeCache_init\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-    MemMapPrinter::print_all_mappings(tty, false);\n+    MemMapPrinter::print_all_mappings(tty);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,1 +413,2 @@\n-JavaThread::JavaThread() :\n+JavaThread::JavaThread(MEMFLAGS flags) :\n+  Thread(flags),\n@@ -415,1 +416,0 @@\n-\n@@ -529,4 +529,4 @@\n-JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n-  if (is_attaching_via_jni) {\n-    _jni_attach_state = _attaching_via_jni;\n-  }\n+JavaThread* JavaThread::create_attaching_thread() {\n+  JavaThread* jt = new JavaThread();\n+  jt->_jni_attach_state = _attaching_via_jni;\n+  return jt;\n@@ -535,1 +535,0 @@\n-\n@@ -638,2 +637,1 @@\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n-  _jni_attach_state = _not_attaching_via_jni;\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MEMFLAGS flags) : JavaThread(flags) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,3 +482,2 @@\n-  JavaThread();                            \/\/ delegating constructor\n-  JavaThread(bool is_attaching_via_jni);   \/\/ for main thread and JNI attached threads\n-  JavaThread(ThreadFunction entry_point, size_t stack_size = 0);\n+  JavaThread(MEMFLAGS flags = mtThread);   \/\/ delegating constructor\n+  JavaThread(ThreadFunction entry_point, size_t stack_size = 0, MEMFLAGS flags = mtThread);\n@@ -487,0 +486,3 @@\n+  \/\/ Factory method to create a new JavaThread whose attach state is \"is attaching\"\n+  static JavaThread* create_attaching_thread();\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,0 +126,2 @@\n+Mutex*   ExternalsRecorder_lock       = nullptr;\n+\n@@ -331,0 +333,3 @@\n+  \/\/ tty_lock is held when printing nmethod and its relocations which use this lock.\n+  MUTEX_DEFL(ExternalsRecorder_lock         , PaddedMutex  , tty_lock);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -145,0 +145,2 @@\n+extern Mutex*   ExternalsRecorder_lock;          \/\/ used to guard access to the external addresses table\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1445,1 +1445,1 @@\n-  JFR_ONLY(return vmSymbols::jdk_jfr_internal_HiddenWait() == monitor_klass->name();)\n+  JFR_ONLY(return vmSymbols::jdk_jfr_internal_management_HiddenWait() == monitor_klass->name();)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,4 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#endif\n+\n@@ -275,7 +279,0 @@\n-#if !defined(LINUX) && !defined(_WINDOWS)\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  committed_start = start;\n-  committed_size = size;\n-  return true;\n-}\n-#endif\n@@ -944,3 +941,4 @@\n-ATTRIBUTE_NO_ASAN static bool read_safely_from(intptr_t* p, intptr_t* result) {\n-  const intptr_t errval = 0x1717;\n-  intptr_t i = SafeFetchN(p, errval);\n+ATTRIBUTE_NO_ASAN static bool read_safely_from(const uintptr_t* p, uintptr_t* result) {\n+  DEBUG_ONLY(*result = 0xAAAA;)\n+  const uintptr_t errval = 0x1717;\n+  uintptr_t i = (uintptr_t)SafeFetchN((intptr_t*)p, errval);\n@@ -948,1 +946,1 @@\n-    i = SafeFetchN(p, ~errval);\n+    i = (uintptr_t)SafeFetchN((intptr_t*)p, ~errval);\n@@ -953,1 +951,1 @@\n-  (*result) = i;\n+  (*result) = (uintptr_t)i;\n@@ -957,1 +955,15 @@\n-static void print_hex_location(outputStream* st, address p, int unitsize) {\n+\/\/ Helper for os::print_hex_dump\n+static void print_ascii_form(stringStream& ascii_form, uint64_t value, int unitsize) {\n+  union {\n+    uint64_t v;\n+    uint8_t c[sizeof(v)];\n+  } u = { value };\n+  for (int i = 0; i < unitsize; i++) {\n+    const int idx = LITTLE_ENDIAN_ONLY(i) BIG_ENDIAN_ONLY(sizeof(u.v) - unitsize + i);\n+    const uint8_t c = u.c[idx];\n+    ascii_form.put(isprint(c) && isascii(c) ? c : '.');\n+  }\n+}\n+\n+\/\/ Helper for os::print_hex_dump\n+static void print_hex_location(outputStream* st, const_address p, int unitsize, stringStream& ascii_form) {\n@@ -959,1 +971,1 @@\n-  address pa = align_down(p, sizeof(intptr_t));\n+  const uintptr_t* pa = (const uintptr_t*) align_down(p, sizeof(intptr_t));\n@@ -963,3 +975,3 @@\n-    intptr_t i1, i2;\n-    if (read_safely_from((intptr_t*)pa, &i1) &&\n-        read_safely_from((intptr_t*)pa + 1, &i2)) {\n+    uintptr_t i1 = 0, i2 = 0;\n+    if (read_safely_from(pa, &i1) &&\n+        read_safely_from(pa + 1, &i2)) {\n@@ -970,0 +982,1 @@\n+      print_ascii_form(ascii_form, value, unitsize);\n@@ -976,2 +989,2 @@\n-  intptr_t i = 0;\n-  if (read_safely_from((intptr_t*)pa, &i)) {\n+  uintptr_t i = 0;\n+  if (read_safely_from(pa, &i)) {\n@@ -982,1 +995,1 @@\n-    const int offset = (int)(p - (address)pa);\n+    const int offset = (int)(p - (const_address)pa);\n@@ -987,1 +1000,1 @@\n-    intptr_t value = bitfield(i, bitoffset, bitfieldsize);\n+    uintptr_t value = bitfield(i, bitoffset, bitfieldsize);\n@@ -994,0 +1007,1 @@\n+    print_ascii_form(ascii_form, value, unitsize);\n@@ -1004,2 +1018,3 @@\n-void os::print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                        int bytes_per_line, address logical_start) {\n+void os::print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize,\n+                        bool print_ascii, int bytes_per_line, const_address logical_start) {\n+  constexpr int max_bytes_per_line = 64;\n@@ -1007,0 +1022,2 @@\n+  assert(bytes_per_line > 0 && bytes_per_line <= max_bytes_per_line &&\n+         is_power_of_2(bytes_per_line), \"invalid bytes_per_line\");\n@@ -1013,1 +1030,4 @@\n-  int cols_per_line = bytes_per_line \/ unitsize;\n+  const int cols_per_line = bytes_per_line \/ unitsize;\n+\n+  const_address p = start;\n+  const_address logical_p = logical_start;\n@@ -1015,2 +1035,1 @@\n-  address p = start;\n-  address logical_p = logical_start;\n+  stringStream ascii_form;\n@@ -1019,1 +1038,0 @@\n-  st->print(PTR_FORMAT \":   \", p2i(logical_p));\n@@ -1021,1 +1039,4 @@\n-    print_hex_location(st, p, unitsize);\n+    if (cols == 0) {\n+      st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+    }\n+    print_hex_location(st, p, unitsize, ascii_form);\n@@ -1025,2 +1046,5 @@\n-    if (cols >= cols_per_line && p < end) {\n-       cols = 0;\n+    if (cols >= cols_per_line) {\n+       if (print_ascii && !ascii_form.is_empty()) {\n+         st->print(\"   %s\", ascii_form.base());\n+       }\n+       ascii_form.reset();\n@@ -1028,1 +1052,1 @@\n-       st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+       cols = 0;\n@@ -1033,1 +1057,11 @@\n-  st->cr();\n+\n+  if (cols > 0) { \/\/ did not print a full line\n+    if (print_ascii) {\n+      \/\/ indent last ascii part to match that of full lines\n+      const int size_of_printed_unit = unitsize * 2;\n+      const int space_left = (cols_per_line - cols) * (size_of_printed_unit + 1);\n+      st->sp(space_left);\n+      st->print(\"  %s\", ascii_form.base());\n+    }\n+    st->cr();\n+  }\n@@ -1051,1 +1085,1 @@\n-  print_hex_dump(st, pc - 256, pc + 256, unitsize);\n+  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false);\n@@ -1927,2 +1961,1 @@\n-    AIX_ONLY(os::vm_page_size() == 4*K ? 4*K : 256*M)\n-    NOT_AIX(os::vm_allocation_granularity());\n+    AIX_ONLY((!os::Aix::supports_64K_mmap_pages() && os::vm_page_size() == 64*K) ? 256*M : ) os::vm_allocation_granularity();\n@@ -2067,0 +2100,13 @@\n+julong os::used_memory() {\n+#ifdef LINUX\n+  if (OSContainer::is_containerized()) {\n+    jlong mem_usage = OSContainer::memory_usage_in_bytes();\n+    if (mem_usage > 0) {\n+      return mem_usage;\n+    }\n+  }\n+#endif\n+  return os::physical_memory() - os::available_memory();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":81,"deletions":35,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -339,0 +339,1 @@\n+  static julong used_memory();\n@@ -858,4 +859,4 @@\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                             int bytes_per_line, address logical_start);\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize) {\n-    print_hex_dump(st, start, end, unitsize, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii,\n+                             int bytes_per_line, const_address logical_start);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true) {\n+    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1383,1 +1383,1 @@\n-           callee_method->method_holder()->is_init_thread(current),\n+           callee_method->method_holder()->is_reentrant_initialization(current),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -860,0 +860,10 @@\n+void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {\n+  if (millis < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n+  }\n+  ObjectSynchronizer::inflate(THREAD,\n+                              obj(),\n+                              inflate_cause_wait)->wait(millis, false, THREAD);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  friend class WhiteBox;\n@@ -122,0 +123,5 @@\n+  \/\/ Special internal-use-only method for use by JVM infrastructure\n+  \/\/ that needs to wait() on a java-level object but that can't risk\n+  \/\/ throwing unexpected InterruptedExecutionExceptions.\n+  static void waitUninterruptibly(Handle obj, jlong Millis, TRAPS);\n+\n@@ -228,0 +234,1 @@\n+  void wait_uninterruptibly(TRAPS)  { ObjectSynchronizer::waitUninterruptibly(_obj, 0, CHECK); } \/\/ wait forever\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-Thread::Thread() {\n+Thread::Thread(MEMFLAGS flags) {\n@@ -81,1 +81,1 @@\n-  set_resource_area(new (mtThread)ResourceArea());\n+  set_resource_area(new (flags) ResourceArea(flags));\n@@ -83,1 +83,1 @@\n-  set_handle_area(new (mtThread) HandleArea(nullptr));\n+  set_handle_area(new (flags) HandleArea(flags, nullptr));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-  Thread();\n+  Thread(MEMFLAGS flag = mtThread);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -822,1 +822,1 @@\n-    MetaspaceShared::preload_and_dump();\n+    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,2 +208,3 @@\n-    else if (thread()->osthread()->get_state() == CONDVAR_WAIT) {\n-      \/\/ We are waiting on the native class initialization monitor.\n+    else if (thread()->osthread()->get_state() == OBJECT_WAIT) {\n+      \/\/ We are waiting on an Object monitor but Object.wait() isn't the\n+      \/\/ top-frame, so we should be waiting on a Class initialization monitor.\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -2171,1 +2172,0 @@\n-  declare_constant(InstanceKlass::being_linked)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#ifdef UNDEFINED_BEHAVIOR_SANITIZER\n@@ -38,0 +39,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/sanitizers\/ub.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,7 @@\n-    bufferedStream st;\n+    \/\/ jcmd output can get lengthy. As long as we miss jcmd continuous streaming output\n+    \/\/ and instead just send the output in bulk, make sure large command output does not\n+    \/\/ cause asserts. We still retain a max cap, but dimensioned in a way that makes it\n+    \/\/ highly unlikely we should ever hit it under normal conditions.\n+    constexpr size_t initial_size = 1 * M;\n+    constexpr size_t max_size = 3 * G;\n+    bufferedStream st(initial_size, max_size);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1019,1 +1019,1 @@\n-  VM_PrintClasses vmop(output(), _verbose.is_set());\n+  VM_PrintClasses vmop(output(), _verbose.value());\n@@ -1207,5 +1207,1 @@\n-SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) :\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n-}\n+SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -1214,1 +1210,1 @@\n-  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+  MemMapPrinter::print_all_mappings(output());\n@@ -1220,2 +1216,1 @@\n-    DCmdWithParser(output, heap),\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  DCmdWithParser(output, heap),\n@@ -1223,1 +1218,0 @@\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n@@ -1241,1 +1235,1 @@\n-    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+    MemMapPrinter::print_all_mappings(&fs);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1011,2 +1011,1 @@\n-class SystemMapDCmd : public DCmdWithParser {\n-  DCmdArgument<bool> _human_readable;\n+class SystemMapDCmd : public DCmd {\n@@ -1014,1 +1013,0 @@\n-  static int num_arguments() { return 1; }\n@@ -1020,1 +1018,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium; can be high for very large java heaps.\"; }\n@@ -1030,1 +1028,0 @@\n-  DCmdArgument<bool> _human_readable;\n@@ -1033,1 +1030,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 1; }\n@@ -1039,1 +1036,1 @@\n-  static const char* impact() { return \"Low\"; }\n+  static const char* impact() { return \"Medium; can be high for very large java heaps.\"; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -403,0 +403,2 @@\n+      \/\/ Allow for \"<cmd> -h|-help|--help\" to enable the help diagnostic command.\n+      \/\/ Ignores any additional arguments.\n@@ -404,0 +406,6 @@\n+      stringStream updated_line;\n+      if (reorder_help_cmd(line, updated_line)) {\n+        CmdLine updated_cmd(updated_line.base(), updated_line.size(), false);\n+        line = updated_cmd;\n+      }\n+\n@@ -414,0 +422,19 @@\n+bool DCmd::reorder_help_cmd(CmdLine line, stringStream &updated_line) {\n+  stringStream args;\n+  args.print(\"%s\", line.args_addr());\n+  char* rest = args.as_string();\n+  char* token = strtok_r(rest, \" \", &rest);\n+  while (token != NULL) {\n+    if (strcmp(token, \"-h\") == 0 || strcmp(token, \"--help\") == 0 ||\n+        strcmp(token, \"-help\") == 0) {\n+      updated_line.print(\"%s\", \"help \");\n+      updated_line.write(line.cmd_addr(), line.cmd_len());\n+      updated_line.write(\"\\0\", 1);\n+      return true;\n+    }\n+    token = strtok_r(rest, \" \", &rest);\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,0 +315,3 @@\n+  \/\/ Helper method to substitute help options \"<cmd> -h|-help|--help\"\n+  \/\/ for \"help <cmd>\".\n+  static bool reorder_help_cmd(CmdLine line, stringStream& updated_line);\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1229,0 +1229,8 @@\n+  \/\/ Also provide a pointer to the init_lock if present, so there aren't unreferenced int[0]\n+  \/\/ arrays.\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    field_count++;\n+    size += sizeof(address);\n+  }\n+\n@@ -1268,0 +1276,8 @@\n+\n+  \/\/ Add init lock to the end if the class is not yet initialized\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    writer->write_symbolID(vmSymbols::init_lock_name());         \/\/ name\n+    writer->write_u1(sig2tag(vmSymbols::int_array_signature())); \/\/ type\n+    writer->write_objectID(init_lock);\n+  }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-  _invisible_epoch = 0;\n+  _invisible_epoch = nullptr;\n@@ -348,1 +348,1 @@\n-  _invisible_epoch = 0;\n+  _invisible_epoch = nullptr;\n@@ -355,1 +355,1 @@\n-  _invisible_epoch = 0;\n+  _invisible_epoch = nullptr;\n@@ -1019,1 +1019,1 @@\n-      _invisible_epoch(0)\n+      _invisible_epoch(nullptr)\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+typedef const u_char* const_address;\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,3 +75,2 @@\n-void NativeCallStack::print_on(outputStream* out) const {\n-  DEBUG_ONLY(assert_not_fake();)\n-  address pc;\n+\n+void NativeCallStack::print_frame(outputStream* out, address pc) const {\n@@ -80,26 +79,15 @@\n-  if (is_empty()) {\n-    out->print(\"[BOOTSTRAP]\");\n-  } else {\n-    for (int frame = 0; frame < NMT_TrackingStackDepth; frame ++) {\n-      pc = get_frame(frame);\n-      if (pc == nullptr) break;\n-      out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n-      \/\/ Print function and library; shorten library name to just its last component\n-      \/\/ for brevity, and omit it completely for libjvm.so\n-      bool function_printed = false;\n-      if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n-        out->print(\"%s+0x%x\", buf, offset);\n-        function_printed = true;\n-      }\n-      if ((!function_printed || !os::address_is_in_vm(pc)) &&\n-          os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n-        const char* libname = strrchr(buf, os::file_separator()[0]);\n-        if (libname != nullptr) {\n-          libname++;\n-        } else {\n-          libname = buf;\n-        }\n-        out->print(\" in %s\", libname);\n-        if (!function_printed) {\n-          out->print(\"+0x%x\", offset);\n-        }\n+  int     line;\n+  const bool pc_in_VM = os::address_is_in_vm(pc);\n+  out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n+  \/\/ Print function and library; shorten library name to just its last component\n+  \/\/ for brevity, and omit it completely for libjvm.so\n+  bool function_printed = false;\n+  if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n+    out->print(\"%s+0x%x\", buf, offset);\n+    function_printed = true;\n+    if (Decoder::get_source_info(pc, buf, sizeof(buf), &line, false)) {\n+      \/\/ For intra-vm functions, we omit the full path\n+      const char* s = buf;\n+      if (pc_in_VM) {\n+        s = strrchr(s, os::file_separator()[0]);\n+        s = (s != nullptr) ? s + 1 : buf;\n@@ -107,6 +95,14 @@\n-\n-      \/\/ Note: we deliberately omit printing source information here. NativeCallStack::print_on()\n-      \/\/ can be called thousands of times as part of NMT detail reporting, and source printing\n-      \/\/ can slow down reporting by a factor of 5 or more depending on platform (see JDK-8296931).\n-\n-      out->cr();\n+      out->print(\"   (%s:%d)\", s, line);\n+    }\n+  }\n+  if ((!function_printed || !pc_in_VM) &&\n+      os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n+    const char* libname = strrchr(buf, os::file_separator()[0]);\n+    if (libname != nullptr) {\n+      libname++;\n+    } else {\n+      libname = buf;\n+    }\n+    out->print(\" in %s\", libname);\n+    if (!function_printed) {\n+      out->print(\"+0x%x\", offset);\n@@ -116,0 +112,8 @@\n+\n+void NativeCallStack::print_on(outputStream* out) const {\n+  DEBUG_ONLY(assert_not_fake();)\n+  for (int i = 0; i < NMT_TrackingStackDepth && _stack[i] != nullptr; i++) {\n+    print_frame(out, _stack[i]);\n+  }\n+  out->cr();\n+}\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":40,"deletions":36,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -126,0 +127,1 @@\n+  void print_frame(outputStream* out, address pc) const;\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-void outputStream::fill_to(int col) {\n-  int need_fill = col - position();\n+int outputStream::fill_to(int col) {\n+  const int need_fill = MAX2(col - position(), 0);\n@@ -197,0 +197,1 @@\n+  return need_fill;\n@@ -1040,1 +1041,1 @@\n-      assert(false, \"Exceeded max buffer size for this string.\");\n+      assert(false, \"Exceeded max buffer size for this string (\\\"%.200s...\\\").\", buffer);\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-   void fill_to(int col);\n+   int fill_to(int col);\n@@ -270,0 +270,1 @@\n+  bool is_empty() const { return _buffer[0] == '\\0'; }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"runtime\/globals.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -36,4 +36,2 @@\n-  static void swap(T* array, size_t x, size_t y) {\n-    T tmp = array[x];\n-    array[x] = array[y];\n-    array[y] = tmp;\n+  static void swap_elements(T* array, size_t x, size_t y) {\n+    swap(array[x], array[y]);\n@@ -43,3 +41,1 @@\n-  \/\/ We swap in these three values at the right place in the array. This\n-  \/\/ means that this method not only returns the index of the pivot\n-  \/\/ element. It also alters the array so that:\n+  \/\/ We swap these three values as needed so that\n@@ -47,1 +43,3 @@\n-  \/\/ A side effect of this is that arrays of length <= 3 are sorted.\n+  \/\/ As a result, the first and last elements are placed in the proper\n+  \/\/ partition, and arrays of length <= 3 are sorted.\n+  \/\/ The middle index is returned, designating that element as the pivot.\n@@ -56,1 +54,1 @@\n-      swap(array, 0, middle_index);\n+      swap_elements(array, 0, middle_index);\n@@ -59,1 +57,1 @@\n-      swap(array, 0, last_index);\n+      swap_elements(array, 0, last_index);\n@@ -62,1 +60,1 @@\n-      swap(array, middle_index, last_index);\n+      swap_elements(array, middle_index, last_index);\n@@ -65,1 +63,1 @@\n-    \/\/ of the fist, last and middle values. Use this as pivot.\n+    \/\/ of the first, last and middle values. Use this as pivot.\n@@ -69,1 +67,1 @@\n-  template<bool idempotent, class T, class C>\n+  template<class T, class C>\n@@ -77,1 +75,1 @@\n-        assert(left_index < length, \"reached end of partition\");\n+        assert(left_index < (length - 1), \"reached end of partition\");\n@@ -82,1 +80,0 @@\n-\n@@ -84,3 +81,1 @@\n-        if (!idempotent || comparator(array[left_index], array[right_index]) != 0) {\n-          swap(array, left_index, right_index);\n-        }\n+        swap_elements(array, left_index, right_index);\n@@ -91,3 +86,0 @@\n-\n-    ShouldNotReachHere();\n-    return 0;\n@@ -96,2 +88,3 @@\n-  template<bool idempotent, class T, class C>\n-  static void inner_sort(T* array, size_t length, C comparator) {\n+ public:\n+  template<class T, class C>\n+  static void sort(T* array, size_t length, C comparator) {\n@@ -106,1 +99,1 @@\n-    size_t split = partition<idempotent>(array, pivot, length, comparator);\n+    size_t split = partition(array, pivot, length, comparator);\n@@ -108,18 +101,2 @@\n-    inner_sort<idempotent>(array, first_part_length, comparator);\n-    inner_sort<idempotent>(&array[first_part_length], length - first_part_length, comparator);\n-  }\n-\n- public:\n-  \/\/ The idempotent parameter prevents the sort from\n-  \/\/ reordering a previous valid sort by not swapping\n-  \/\/ fields that compare as equal. This requires extra\n-  \/\/ calls to the comparator, so the performance\n-  \/\/ impact depends on the comparator.\n-  template<class T, class C>\n-  static void sort(T* array, size_t length, C comparator, bool idempotent) {\n-    \/\/ Switch \"idempotent\" from function parameter to template parameter\n-    if (idempotent) {\n-      inner_sort<true>(array, length, comparator);\n-    } else {\n-      inner_sort<false>(array, length, comparator);\n-    }\n+    sort(array, first_part_length, comparator);\n+    sort(&array[first_part_length], length - first_part_length, comparator);\n@@ -129,1 +106,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/quickSort.hpp","additions":21,"deletions":45,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+    @Override\n+    public boolean isContainerized() {\n+        return isContainerized0();\n+    }\n+\n@@ -197,0 +202,1 @@\n+    private static native boolean isContainerized0();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\n+    default boolean isContainerized() {\n+        return false; \/\/ This default impl is never used\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isContainerized0(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsContainerized();\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.SecureRandom;\n-import java.security.InvalidParameterException;\n@@ -31,1 +29,2 @@\n-import java.security.InvalidKeyException;\n+import java.security.InvalidParameterException;\n+import java.security.SecureRandom;\n@@ -37,0 +36,1 @@\n+\n@@ -40,1 +40,1 @@\n- * This class generates a AES key.\n+ * This class generates an AES key.\n@@ -108,1 +108,1 @@\n-        SecretKeySpec aesKey = null;\n+        SecretKeySpec aesKey;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,5 @@\n-import java.util.Arrays;\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import javax.crypto.IllegalBlockSizeException;\n+\n@@ -69,1 +69,1 @@\n-    };\n+    }\n@@ -77,1 +77,1 @@\n-    };\n+    }\n@@ -115,1 +115,1 @@\n-    };\n+    }\n@@ -118,1 +118,1 @@\n-    \/\/ no support for multi-part encryption\n+    \/\/ no support for multipart encryption\n@@ -121,2 +121,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n@@ -124,1 +124,1 @@\n-    \/\/ no support for multi-part decryption\n+    \/\/ no support for multipart decryption\n@@ -127,2 +127,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrap.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n@@ -30,4 +32,2 @@\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.IllegalBlockSizeException;\n+\n@@ -52,1 +52,1 @@\n-    \/\/ set the first semiblock of dest with iv and inLen\n+    \/\/ set the first semi-block of dest with iv and inLen\n@@ -63,1 +63,1 @@\n-    \/\/ validate the recovered internal ivAndLen semiblock against iv and\n+    \/\/ validate the recovered internal ivAndLen semi-block against iv and\n@@ -106,1 +106,1 @@\n-    };\n+    }\n@@ -114,1 +114,1 @@\n-    };\n+    }\n@@ -154,1 +154,1 @@\n-    };\n+    }\n@@ -156,1 +156,1 @@\n-    \/\/ no support for multi-part encryption\n+    \/\/ no support for multipart encryption\n@@ -159,2 +159,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n@@ -162,1 +162,1 @@\n-    \/\/ no support for multi-part decryption\n+    \/\/ no support for multipart decryption\n@@ -165,2 +165,2 @@\n-        throw new UnsupportedOperationException(\"multi-part not supported\");\n-    };\n+        throw new UnsupportedOperationException(\"multipart not supported\");\n+    }\n@@ -202,1 +202,1 @@\n-            \/\/ overwrite the first semiblock with iv and input length\n+            \/\/ overwrite the first semi-block with iv and input length\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-        if (mode.equalsIgnoreCase(\"ECB\") == false) {\n+        if (!mode.equalsIgnoreCase(\"ECB\")) {\n@@ -126,1 +126,1 @@\n-        if (padding.equalsIgnoreCase(\"NoPadding\") == false) {\n+        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n@@ -204,1 +204,1 @@\n-        if (\"RAW\".equals(key.getFormat()) == false) {\n+        if (!\"RAW\".equals(key.getFormat())) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ARCFOURCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,1 @@\n-        if (mode.equalsIgnoreCase(\"None\") == false) {\n+        if (!mode.equalsIgnoreCase(\"None\")) {\n@@ -177,1 +177,1 @@\n-        if (padding.equalsIgnoreCase(\"NoPadding\") == false) {\n+        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n@@ -329,1 +329,1 @@\n-        byte[] newNonce = null;\n+        byte[] newNonce;\n@@ -363,1 +363,1 @@\n-     * format.  This cipher does supports initialization with\n+     * format.  This cipher supports initialization with\n@@ -621,1 +621,1 @@\n-        if (\"RAW\".equals(key.getFormat()) == false) {\n+        if (!\"RAW\".equals(key.getFormat())) {\n@@ -678,1 +678,1 @@\n-        int bytesUpdated = 0;\n+        int bytesUpdated;\n@@ -694,1 +694,1 @@\n-     * @return the length in bytes of the data written into the {@code out}\n+     * @return the length in bytes of the data written into the {@code output}\n@@ -697,1 +697,1 @@\n-     * @throws ShortBufferException if the buffer {@code out} does not have\n+     * @throws ShortBufferException if the buffer {@code output} does not have\n@@ -766,1 +766,1 @@\n-        int bytesUpdated = 0;\n+        int bytesUpdated;\n@@ -788,0 +788,3 @@\n+     * @throws ShortBufferException if the buffer {@code output} does not have\n+     *      enough space to hold the resulting data.\n+     *\n@@ -950,4 +953,0 @@\n-     * @throws IllegalArgumentException if the key or nonce are not in\n-     *      their proper lengths (32 bytes for the key, 12 bytes for the\n-     *      nonce).\n-     * @throws InvalidKeyException if the key does not support an encoded form.\n@@ -955,1 +954,1 @@\n-    private void setInitialState() throws InvalidKeyException {\n+    private void setInitialState() {\n@@ -1260,1 +1259,1 @@\n-     * @throws ShortBufferException if there is insufficient room to\n+     * @throws ProviderException if there is insufficient room to\n@@ -1264,1 +1263,1 @@\n-            byte[] out, int outOff) throws ShortBufferException {\n+            byte[] out, int outOff) {\n@@ -1303,1 +1302,1 @@\n-     * @note it is the caller's responsibility to provide an array large\n+     * @implNote it is the caller's responsibility to provide an array large\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,3 +209,2 @@\n-        StringBuilder sb = new StringBuilder(LINE_SEP + \"nonce:\" +\n-                LINE_SEP + \"[\" + encoder.encodeBuffer(nonce) + \"]\");\n-        return sb.toString();\n+        return LINE_SEP + \"nonce:\" +\n+                LINE_SEP + \"[\" + encoder.encodeBuffer(nonce) + \"]\";\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Poly1305Parameters.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-     * (This check is omitted here, to avoid double checking.)\n+     * (This check is omitted here, to avoid double-checking.)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherBlockChaining.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    private int unitBytes = 0;\n+    private int unitBytes;\n@@ -94,1 +94,1 @@\n-    private int diffBlocksize = 0;\n+    private int diffBlocksize;\n@@ -99,1 +99,1 @@\n-    private Padding padding = null;\n+    private Padding padding;\n@@ -104,1 +104,1 @@\n-    private FeedbackCipher cipher = null;\n+    private FeedbackCipher cipher;\n@@ -139,1 +139,1 @@\n-         * In decryption mode, it also hold the possible padding block.\n+         * In decryption mode, it also holds the possible padding block.\n@@ -337,1 +337,1 @@\n-        AlgorithmParameters params = null;\n+        AlgorithmParameters params;\n@@ -548,1 +548,1 @@\n-        byte[] output = null;\n+        byte[] output;\n@@ -933,2 +933,1 @@\n-        throws ShortBufferException, BadPaddingException,\n-        IllegalBlockSizeException {\n+        throws BadPaddingException, IllegalBlockSizeException {\n@@ -970,1 +969,1 @@\n-        throws IllegalBlockSizeException, ShortBufferException {\n+        throws IllegalBlockSizeException {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import javax.crypto.ShortBufferException;\n@@ -156,1 +155,1 @@\n-     * (This check is omitted here, to avoid double checking.)\n+     * (This check is omitted here, to avoid double-checking.)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherTextStealing.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-        PublicKey key = null;\n+        PublicKey key;\n@@ -91,1 +91,1 @@\n-        PrivateKey key = null;\n+        PrivateKey key;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ConstructKeys.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    private static final int s0p[] = {\n+    private static final int[] s0p = {\n@@ -59,1 +59,1 @@\n-    private static final int s1p[] = {\n+    private static final int[] s1p = {\n@@ -75,1 +75,1 @@\n-    private static final int s2p[] = {\n+    private static final int[] s2p = {\n@@ -91,1 +91,1 @@\n-    private static final int s3p[] = {\n+    private static final int[] s3p = {\n@@ -107,1 +107,1 @@\n-    private static final int s4p[] = {\n+    private static final int[] s4p = {\n@@ -123,1 +123,1 @@\n-    private static final int s5p[] = {\n+    private static final int[] s5p = {\n@@ -139,1 +139,1 @@\n-    private static final int s6p[] = {\n+    private static final int[] s6p = {\n@@ -155,1 +155,1 @@\n-    private static final int s7p[] = {\n+    private static final int[] s7p = {\n@@ -171,1 +171,1 @@\n-    private static final int permRight0[] = {\n+    private static final int[] permRight0 = {\n@@ -178,1 +178,1 @@\n-    private static final int permLeft1[] = {\n+    private static final int[] permLeft1 = {\n@@ -185,1 +185,1 @@\n-    private static final int permRight2[] = {\n+    private static final int[] permRight2 = {\n@@ -192,1 +192,1 @@\n-    private static final int permLeft3[] = {\n+    private static final int[] permLeft3 = {\n@@ -199,1 +199,1 @@\n-    private static final int permRight4[] = {\n+    private static final int[] permRight4 = {\n@@ -206,1 +206,1 @@\n-    private static final int permLeft5[] = {\n+    private static final int[] permLeft5 = {\n@@ -213,1 +213,1 @@\n-    private static final int permRight6[] = {\n+    private static final int[] permRight6 = {\n@@ -220,1 +220,1 @@\n-    private static final int permLeft7[] = {\n+    private static final int[] permLeft7 = {\n@@ -227,1 +227,1 @@\n-    private static final int permRight8[] = {\n+    private static final int[] permRight8 = {\n@@ -234,1 +234,1 @@\n-    private static final int permLeft9[] = {\n+    private static final int[] permLeft9 = {\n@@ -241,1 +241,1 @@\n-    private static final int permRightA[] = {\n+    private static final int[] permRightA = {\n@@ -248,1 +248,1 @@\n-    private static final int permLeftB[] = {\n+    private static final int[] permLeftB = {\n@@ -255,1 +255,1 @@\n-    private static final int permRightC[] = {\n+    private static final int[] permRightC = {\n@@ -262,1 +262,1 @@\n-    private static final int permLeftD[] = {\n+    private static final int[] permLeftD = {\n@@ -269,1 +269,1 @@\n-    private static final int permRightE[] = {\n+    private static final int[] permRightE = {\n@@ -276,1 +276,1 @@\n-    private static final int permLeftF[] = {\n+    private static final int[] permLeftF = {\n@@ -286,1 +286,1 @@\n-    private static final int initPermLeft0[] = {\n+    private static final int[] initPermLeft0 = {\n@@ -293,1 +293,1 @@\n-    private static final int initPermRight0[] = {\n+    private static final int[] initPermRight0 = {\n@@ -300,1 +300,1 @@\n-    private static final int initPermLeft1[] = {\n+    private static final int[] initPermLeft1 = {\n@@ -307,1 +307,1 @@\n-    private static final int initPermRight1[] = {\n+    private static final int[] initPermRight1 = {\n@@ -314,1 +314,1 @@\n-    private static final int initPermLeft2[] = {\n+    private static final int[] initPermLeft2 = {\n@@ -321,1 +321,1 @@\n-    private static final int initPermRight2[] = {\n+    private static final int[] initPermRight2 = {\n@@ -328,1 +328,1 @@\n-    private static final int initPermLeft3[] = {\n+    private static final int[] initPermLeft3 = {\n@@ -335,1 +335,1 @@\n-    private static final int initPermRight3[] = {\n+    private static final int[] initPermRight3 = {\n@@ -342,1 +342,1 @@\n-    private static final int initPermLeft4[] = {\n+    private static final int[] initPermLeft4 = {\n@@ -349,1 +349,1 @@\n-    private static final int initPermRight4[] = {\n+    private static final int[] initPermRight4 = {\n@@ -356,1 +356,1 @@\n-    private static final int initPermLeft5[] = {\n+    private static final int[] initPermLeft5 = {\n@@ -363,1 +363,1 @@\n-    private static final int initPermRight5[] = {\n+    private static final int[] initPermRight5 = {\n@@ -370,1 +370,1 @@\n-    private static final int initPermLeft6[] = {\n+    private static final int[] initPermLeft6 = {\n@@ -377,1 +377,1 @@\n-    private static final int initPermRight6[] = {\n+    private static final int[] initPermRight6 = {\n@@ -384,1 +384,1 @@\n-    private static final int initPermLeft7[] = {\n+    private static final int[] initPermLeft7 = {\n@@ -391,1 +391,1 @@\n-    private static final int initPermRight7[] = {\n+    private static final int[] initPermRight7 = {\n@@ -398,1 +398,1 @@\n-    private static final int initPermLeft8[] = {\n+    private static final int[] initPermLeft8 = {\n@@ -405,1 +405,1 @@\n-    private static final int initPermRight8[] = {\n+    private static final int[] initPermRight8 = {\n@@ -412,1 +412,1 @@\n-    private static final int initPermLeft9[] = {\n+    private static final int[] initPermLeft9 = {\n@@ -419,1 +419,1 @@\n-    private static final int initPermRight9[] = {\n+    private static final int[] initPermRight9 = {\n@@ -426,1 +426,1 @@\n-    private static final int initPermLeftA[] = {\n+    private static final int[] initPermLeftA = {\n@@ -433,1 +433,1 @@\n-    private static final int initPermRightA[] = {\n+    private static final int[] initPermRightA = {\n@@ -440,1 +440,1 @@\n-    private static final int initPermLeftB[] = {\n+    private static final int[] initPermLeftB = {\n@@ -447,1 +447,1 @@\n-    private static final int initPermRightB[] = {\n+    private static final int[] initPermRightB = {\n@@ -454,1 +454,1 @@\n-    private static final int initPermLeftC[] = {\n+    private static final int[] initPermLeftC = {\n@@ -461,1 +461,1 @@\n-    private static final int initPermRightC[] = {\n+    private static final int[] initPermRightC = {\n@@ -468,1 +468,1 @@\n-    private static final int initPermLeftD[] = {\n+    private static final int[] initPermLeftD = {\n@@ -475,1 +475,1 @@\n-    private static final int initPermRightD[] = {\n+    private static final int[] initPermRightD = {\n@@ -482,1 +482,1 @@\n-    private static final int initPermLeftE[] = {\n+    private static final int[] initPermLeftE = {\n@@ -489,1 +489,1 @@\n-    private static final int initPermRightE[] = {\n+    private static final int[] initPermRightE = {\n@@ -496,1 +496,1 @@\n-    private static final int initPermLeftF[] = {\n+    private static final int[] initPermLeftF = {\n@@ -503,1 +503,1 @@\n-    private static final int initPermRightF[] = {\n+    private static final int[] initPermRightF = {\n@@ -589,1 +589,1 @@\n-        byte key[];\n+        byte[] key;\n@@ -641,1 +641,1 @@\n-                             byte out[], int offset) {\n+                             byte[] out, int offset) {\n@@ -690,1 +690,1 @@\n-    private static int initialPermutationLeft(byte block[], int offset) {\n+    private static int initialPermutationLeft(byte[] block, int offset) {\n@@ -712,1 +712,1 @@\n-    private static int initialPermutationRight(byte block[], int offset) {\n+    private static int initialPermutationRight(byte[] block, int offset) {\n@@ -734,1 +734,1 @@\n-    void expandKey(byte key[]) {\n+    void expandKey(byte[] key) {\n@@ -736,1 +736,1 @@\n-        byte ek[] = new byte[128];\n+        byte[] ek = new byte[128];\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESCrypt.java","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-            if ((key instanceof SecretKey)\n+            if ((key != null)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-            if ((key instanceof SecretKey)\n+            if ((key != null)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-        DESedeKey desEdeKey = null;\n+        DESedeKey desEdeKey;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKeyGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-        int result = 0;\n+        int result;\n@@ -146,1 +146,1 @@\n-        return (result < 0? 0:result);\n+        return (Math.max(result, 0));\n@@ -213,1 +213,1 @@\n-        byte[] currIv = null;\n+        byte[] currIv;\n@@ -383,1 +383,1 @@\n-     * parameters or when it has not be set, e.g. initialized with\n+     * parameters or when it has not been set, e.g. initialized with\n@@ -559,1 +559,0 @@\n-            int offset = keyValLen;\n@@ -561,1 +560,1 @@\n-                if (buffer2[offset + i] != cks[i]) {\n+                if (buffer2[keyValLen + i] != cks[i]) {\n@@ -591,1 +590,1 @@\n-        MessageDigest md = null;\n+        MessageDigest md;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeWrapCipher.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,0 @@\n-import sun.security.jca.JCAUtil;\n-import sun.security.ssl.HKDF;\n-import sun.security.util.*;\n-\n-import javax.crypto.*;\n-import javax.crypto.spec.SecretKeySpec;\n@@ -36,1 +30,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -38,1 +31,4 @@\n-import java.security.interfaces.*;\n+import java.security.interfaces.ECKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.interfaces.XECKey;\n+import java.security.interfaces.XECPublicKey;\n@@ -42,0 +38,6 @@\n+import javax.crypto.*;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import sun.security.jca.JCAUtil;\n+import sun.security.ssl.HKDF;\n+import sun.security.util.*;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.util.*;\n-import java.lang.*;\n@@ -31,8 +29,1 @@\n-import java.security.AccessController;\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import java.security.Key;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.SecureRandom;\n-import java.security.PrivilegedAction;\n-import java.security.ProviderException;\n+import java.security.*;\n@@ -40,1 +31,1 @@\n-import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n@@ -42,1 +33,0 @@\n-import javax.crypto.ShortBufferException;\n@@ -44,1 +34,3 @@\n-import javax.crypto.spec.*;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.DHParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -183,1 +175,1 @@\n-     * @param lastPhase flag which indicates whether or not this is the last\n+     * @param lastPhase flag which indicates if this is the last\n@@ -230,1 +222,1 @@\n-        if (lastPhase == false) {\n+        if (!lastPhase) {\n@@ -296,1 +288,1 @@\n-        if (generateSecret == false) {\n+        if (!generateSecret) {\n@@ -416,3 +408,1 @@\n-            SecretKeySpec skey = new SecretKeySpec(secret, 0, keysize,\n-                                                   \"Blowfish\");\n-            return skey;\n+            return new SecretKeySpec(secret, 0, keysize, \"Blowfish\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyAgreement.java","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.security.spec.InvalidParameterSpecException;\n@@ -33,1 +32,0 @@\n-import javax.crypto.spec.DHGenParameterSpec;\n@@ -36,0 +34,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyPairGenerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n-import sun.security.util.ArrayUtil;\n-import java.util.Objects;\n+\n@@ -33,0 +32,1 @@\n+import sun.security.util.ArrayUtil;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ElectronicCodeBook.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-         throws IllegalBlockSizeException, ShortBufferException {\n+         throws IllegalBlockSizeException {\n@@ -202,1 +202,1 @@\n-         throws IllegalBlockSizeException, ShortBufferException {\n+         throws IllegalBlockSizeException {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/FeedbackCipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,1 @@\n-        long blocksLeft = (1L << 32) - ctr32;\n-        return blocksLeft;\n+        return (1L << 32) - ctr32;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,0 @@\n-            int processed = inLen;\n@@ -195,1 +194,1 @@\n-            return processed;\n+            return inLen;\n@@ -276,1 +275,1 @@\n-     * throw exceptions or allocate arrays as it will breaking intrinsics\n+     * throw exceptions or allocate arrays as it will break intrinsics.\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,15 +28,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.Unsafe;\n-import sun.nio.ch.DirectBuffer;\n-import sun.security.jca.JCAUtil;\n-import sun.security.util.ArrayUtil;\n-\n-import javax.crypto.AEADBadTagException;\n-import javax.crypto.BadPaddingException;\n-import javax.crypto.Cipher;\n-import javax.crypto.CipherSpi;\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.NoSuchPaddingException;\n-import javax.crypto.ShortBufferException;\n-import javax.crypto.spec.GCMParameterSpec;\n@@ -47,8 +32,1 @@\n-import java.security.AlgorithmParameters;\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import java.security.Key;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.ProviderException;\n-import java.security.SecureRandom;\n+import java.security.*;\n@@ -58,0 +36,2 @@\n+import javax.crypto.*;\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -59,0 +39,3 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n@@ -60,0 +43,3 @@\n+import sun.nio.ch.DirectBuffer;\n+import sun.security.jca.JCAUtil;\n+import sun.security.util.ArrayUtil;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":10,"deletions":24,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.util.Arrays;\n-\n@@ -31,1 +29,3 @@\n-\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n@@ -34,4 +34,0 @@\n-import java.security.*;\n-import java.security.spec.*;\n-\n-import sun.security.x509.AlgorithmId;\n@@ -90,2 +86,1 @@\n-                    } catch (NoSuchAlgorithmException nsae) {\n-                        continue;\n+                    } catch (NoSuchAlgorithmException ignored) {\n@@ -172,1 +167,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -190,2 +185,2 @@\n-    protected void engineUpdate(byte input[], int offset, int len) {\n-        if (first == true) {\n+    protected void engineUpdate(byte[] input, int offset, int len) {\n+        if (first) {\n@@ -208,1 +203,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -224,1 +219,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -253,1 +248,1 @@\n-        if (first == false) {\n+        if (!first) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacCore.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,1 @@\n-import java.nio.ByteBuffer;\n-\n-import javax.crypto.MacSpi;\n-import javax.crypto.SecretKey;\n-import java.security.*;\n-import java.security.spec.*;\n+import java.security.NoSuchAlgorithmException;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacMD5.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.SecureRandom;\n-import java.security.InvalidParameterException;\n@@ -31,0 +29,1 @@\n+import java.security.SecureRandom;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacMD5KeyGenerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,1 @@\n-import java.nio.ByteBuffer;\n-\n-import javax.crypto.MacSpi;\n-import javax.crypto.SecretKey;\n-import java.security.*;\n-import java.security.spec.*;\n+import java.security.NoSuchAlgorithmException;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacSHA1.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.SecureRandom;\n-import java.security.InvalidParameterException;\n@@ -31,0 +29,1 @@\n+import java.security.SecureRandom;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacSHA1KeyGenerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,2 +122,1 @@\n-        int paddingOctet = blockSize - (len % blockSize);\n-        return paddingOctet;\n+        return blockSize - (len % blockSize);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ISO10126Padding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    };\n+    }\n@@ -96,1 +96,1 @@\n-    };\n+    }\n@@ -122,1 +122,1 @@\n-        Key key = null;\n+        Key key;\n@@ -655,1 +655,1 @@\n-                byte digest[] = md.digest();\n+                byte[] digest = md.digest();\n@@ -694,2 +694,2 @@\n-            ByteArrayInputStream bais = null;\n-            byte[] encoded = null;\n+            ByteArrayInputStream bais;\n+            byte[] encoded;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/JceKeyStore.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n@@ -61,1 +57,1 @@\n-        \/\/ overwrite the first block of in with the icv semiblock\n+        \/\/ overwrite the first block of in with the icv semi-block\n@@ -96,1 +92,1 @@\n-     * @param ivOut buffer for holding the recovered ICV semiblock\n+     * @param ivOut buffer for holding the recovered ICV semi-block\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWUtil.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-            } catch (NumberFormatException e) {}\n+            } catch (NumberFormatException ignored) {}\n@@ -372,1 +372,1 @@\n-            SealedObjectForKeyProtector soForKeyProtector = null;\n+            SealedObjectForKeyProtector soForKeyProtector;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,1 +288,1 @@\n-            \/\/ then add the first semiblock and padLen to result\n+            \/\/ then add the first semi-block and padLen to result\n@@ -342,1 +342,1 @@\n-            implInit(opmode, key, (byte[])null, random);\n+            implInit(opmode, key, null, random);\n@@ -397,1 +397,1 @@\n-                AlgorithmParameterSpec spec =\n+                IvParameterSpec spec =\n@@ -399,1 +399,1 @@\n-                iv = ((IvParameterSpec)spec).getIV();\n+                iv = spec.getIV();\n@@ -465,1 +465,1 @@\n-            \/\/ the first semiblock is for iv, store data after it\n+            \/\/ the first semi-block is for iv, store data after it\n@@ -598,2 +598,2 @@\n-    \/\/ 'inBuf' = semiblock | plain text | extra bytes if padding is used\n-    \/\/ 'inLen' = semiblock length + plain text length\n+    \/\/ 'inBuf' = semi-block | plain text | extra bytes if padding is used\n+    \/\/ 'inLen' = semi-block length + plain text length\n@@ -649,1 +649,1 @@\n-        AlgorithmParameters params = null;\n+        AlgorithmParameters params;\n@@ -714,1 +714,1 @@\n-        \/\/ reserve the first semiblock and do not write data\n+        \/\/ reserve the first semi-block and do not write data\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -228,6 +228,4 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"MD: \" + mdName + \"\\n\");\n-        sb.append(\"MGF: MGF1\" + mgfSpec.getDigestAlgorithm() + \"\\n\");\n-        sb.append(\"PSource: PSpecified \" +\n-            (p.length==0? \"\":Debug.toHexString(new BigInteger(p))) + \"\\n\");\n-        return sb.toString();\n+        return \"MD: \" + mdName + \"\\n\" +\n+                \"MGF: MGF1\" + mgfSpec.getDigestAlgorithm() + \"\\n\" +\n+                \"PSource: PSpecified \" +\n+                (p.length == 0 ? \"\" : Debug.toHexString(new BigInteger(p))) + \"\\n\";\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-     * number of bytes for each stream unit, defaults to the blocksize\n+     * number of bytes for each stream unit, defaults to the block size\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OutputFeedback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,1 @@\n-        if ((key instanceof SecretKey)\n+        if ((key != null)\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,1 @@\n-        AlgorithmParameters params = null;\n+        AlgorithmParameters params;\n@@ -306,1 +306,1 @@\n-            byte[] toBeHashed = null;\n+            byte[] toBeHashed;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES1Core.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,2 @@\n-        String kdfAlgo = null;\n-        String cipherAlgo = null;\n+        String kdfAlgo;\n+        String cipherAlgo;\n@@ -213,3 +213,0 @@\n-        String kdfAlgo = null;\n-        String cipherAlgo = null;\n-\n@@ -234,1 +231,1 @@\n-        kdfAlgo = parseKDF(kdf);\n+        String kdfAlgo = parseKDF(kdf);\n@@ -240,1 +237,1 @@\n-        cipherAlgo = parseES(pBES2_params.data.getDerValue());\n+        String cipherAlgo = parseES(pBES2_params.data.getDerValue());\n@@ -242,2 +239,1 @@\n-        this.pbes2AlgorithmName = new StringBuilder().append(\"PBEWith\")\n-            .append(kdfAlgo).append(\"And\").append(cipherAlgo).toString();\n+        this.pbes2AlgorithmName = \"PBEWith\" + kdfAlgo + \"And\" + cipherAlgo;\n@@ -308,1 +304,1 @@\n-        String cipherAlgo = null;\n+        String cipherAlgo;\n@@ -402,1 +398,1 @@\n-     * The algorithn name pattern is: \"PBEWith<prf>And<encryption>\"\n+     * The algorithm name pattern is: \"PBEWith<prf>And<encryption>\"\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import java.io.*;\n-import java.lang.ref.Reference;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamException;\n@@ -31,0 +33,1 @@\n+import java.lang.ref.Reference;\n@@ -33,4 +36,0 @@\n-import java.util.Arrays;\n-import java.util.Locale;\n-import java.security.MessageDigest;\n-import java.security.KeyRep;\n@@ -38,0 +37,2 @@\n+import java.security.KeyRep;\n+import java.security.MessageDigest;\n@@ -40,0 +41,2 @@\n+import java.util.Arrays;\n+import java.util.Locale;\n@@ -44,2 +47,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -48,0 +49,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        PBKDF2Core kdf = null;\n+        PBKDF2Core kdf;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBMAC1Core.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,2 +123,1 @@\n-        int paddingOctet = blockSize - (len % blockSize);\n-        return paddingOctet;\n+        return blockSize - (len % blockSize);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS5Padding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.security.Key;\n@@ -31,0 +30,1 @@\n+import java.security.Key;\n@@ -35,3 +35,0 @@\n-import sun.security.util.math.*;\n-import sun.security.util.math.intpoly.*;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -39,0 +36,5 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import sun.security.util.math.IntegerFieldModuloP;\n+import sun.security.util.math.IntegerModuloP;\n+import sun.security.util.math.MutableIntegerModuloP;\n+import sun.security.util.math.intpoly.IntegerPolynomial1305;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-        if (algorithm.equals(\"RC2\") == false) {\n+        if (!algorithm.equals(\"RC2\")) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RC2Crypt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -129,1 +130,1 @@\n-        if (mode.equalsIgnoreCase(\"ECB\") == false) {\n+        if (!mode.equalsIgnoreCase(\"ECB\")) {\n@@ -471,1 +472,1 @@\n-        byte[] encoded = null;\n+        byte[] encoded;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-\n-import javax.crypto.MacSpi;\n-import javax.crypto.SecretKey;\n@@ -34,0 +31,2 @@\n+import javax.crypto.MacSpi;\n+import javax.crypto.SecretKey;\n@@ -112,1 +111,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -131,2 +130,2 @@\n-    void update(byte input[], int offset, int len) {\n-        if (first == true) {\n+    void update(byte[] input, int offset, int len) {\n+        if (first) {\n@@ -144,1 +143,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -161,1 +160,1 @@\n-        if (first == true) {\n+        if (first) {\n@@ -192,1 +191,1 @@\n-        if (first == false) {\n+        if (!first) {\n@@ -214,1 +213,1 @@\n-        protected void engineUpdate(byte input[], int offset, int len) {\n+        protected void engineUpdate(byte[] input, int offset, int len) {\n@@ -247,1 +246,1 @@\n-        protected void engineUpdate(byte input[], int offset, int len) {\n+        protected void engineUpdate(byte[] input, int offset, int len) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SslMacCore.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        if (params instanceof TlsKeyMaterialParameterSpec == false) {\n+        if (!(params instanceof TlsKeyMaterialParameterSpec)) {\n@@ -69,1 +69,1 @@\n-        if (\"RAW\".equals(spec.getMasterSecret().getFormat()) == false) {\n+        if (!\"RAW\".equals(spec.getMasterSecret().getFormat())) {\n@@ -108,2 +108,0 @@\n-        SecretKey clientCipherKey = null;\n-        SecretKey serverCipherKey = null;\n@@ -197,0 +195,2 @@\n+        SecretKey clientCipherKey;\n+        SecretKey serverCipherKey;\n@@ -198,1 +198,1 @@\n-            if (isExportable == false) {\n+            if (!isExportable) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsKeyMaterialGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-        if (params instanceof TlsPrfParameterSpec == false) {\n+        if (!(params instanceof TlsPrfParameterSpec)) {\n@@ -140,1 +140,1 @@\n-        if ((key != null) && (\"RAW\".equals(key.getFormat()) == false)) {\n+        if ((key != null) && (!\"RAW\".equals(key.getFormat()))) {\n@@ -381,1 +381,1 @@\n-     * we could use.  Therefore for TLS 1.2, we are updating JSSE to request\n+     * we could use.  Therefore, for TLS 1.2, we are updating JSSE to request\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsPrfGenerator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -374,0 +374,3 @@\n+    \/**\n+     * @since 11\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -888,5 +888,3 @@\n-        try {\n-            FloatToDecimal.appendTo(f, this);\n-        } catch (IOException e) {\n-            throw new AssertionError(e);\n-        }\n+        ensureCapacityInternal(count + FloatToDecimal.MAX_CHARS);\n+        FloatToDecimal toDecimal = isLatin1() ? FloatToDecimal.LATIN1 : FloatToDecimal.UTF16;\n+        count = toDecimal.putDecimal(value, count, f);\n@@ -894,1 +892,0 @@\n-\n@@ -910,5 +907,3 @@\n-        try {\n-            DoubleToDecimal.appendTo(d, this);\n-        } catch (IOException e) {\n-            throw new AssertionError(e);\n-        }\n+        ensureCapacityInternal(count + DoubleToDecimal.MAX_CHARS);\n+        DoubleToDecimal toDecimal = isLatin1() ? DoubleToDecimal.LATIN1 : DoubleToDecimal.UTF16;\n+        count = toDecimal.putDecimal(value, count, d);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n@@ -60,1 +58,0 @@\n-import java.lang.classfile.attribute.ModuleAttribute;\n@@ -63,1 +60,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -1591,1 +1587,1 @@\n-        byte[] bytes = cc.transform(cc.parse(in.readAllBytes()), (clb, cle) -> {\n+        byte[] bytes = cc.transformClass(cc.parse(in.readAllBytes()), (clb, cle) -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -244,0 +244,4 @@\n+     *\n+     * Satisfying this method's contract implies a non-{@code null}\n+     * result must be returned.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.classfile.attribute.UnknownAttribute;\n@@ -438,1 +437,1 @@\n-     *                     b -> b.transform(model, transform));\n+     *                     clb -> clb.transform(model, transform));\n@@ -445,2 +444,2 @@\n-    default byte[] transform(ClassModel model, ClassTransform transform) {\n-        return transform(model, model.thisClass(), transform);\n+    default byte[] transformClass(ClassModel model, ClassTransform transform) {\n+        return transformClass(model, model.thisClass(), transform);\n@@ -461,2 +460,2 @@\n-    default byte[] transform(ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n-        return transform(model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n+    default byte[] transformClass(ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n+        return transformClass(model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n@@ -476,1 +475,1 @@\n-     *                     b -> b.transform(model, transform));\n+     *                     clb -> clb.transform(model, transform));\n@@ -484,1 +483,1 @@\n-    byte[] transform(ClassModel model, ClassEntry newClassName, ClassTransform transform);\n+    byte[] transformClass(ClassModel model, ClassEntry newClassName, ClassTransform transform);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * {@link ClassFile#transform(ClassModel, ClassTransform)}, and the elements of the class,\n+ * {@link ClassFile#transformClass(ClassModel, ClassTransform)}, and the elements of the class,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileTransform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,4 +30,0 @@\n-import java.lang.classfile.constantpool.MethodHandleEntry;\n-import java.lang.classfile.constantpool.ModuleEntry;\n-import java.lang.classfile.constantpool.NameAndTypeEntry;\n-import java.lang.classfile.constantpool.PackageEntry;\n@@ -133,71 +129,0 @@\n-    \/**\n-     * {@return the UTF8 entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a UTF8 entry\n-     *\/\n-    Utf8Entry readUtf8Entry(int offset);\n-\n-    \/**\n-     * {@return the UTF8 entry whose index is given at the specified\n-     * offset within the classfile, or null if the index at the specified\n-     * offset is zero}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or the index does not correspond to\n-     *         a UTF8 entry\n-     *\/\n-    Utf8Entry readUtf8EntryOrNull(int offset);\n-\n-    \/**\n-     * {@return the module entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a module entry\n-     *\/\n-    ModuleEntry readModuleEntry(int offset);\n-\n-    \/**\n-     * {@return the package entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a package entry\n-     *\/\n-    PackageEntry readPackageEntry(int offset);\n-\n-    \/**\n-     * {@return the class entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a class entry\n-     *\/\n-    ClassEntry readClassEntry(int offset);\n-\n-    \/**\n-     * {@return the name-and-type entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a name-and-type entry\n-     *\/\n-    NameAndTypeEntry readNameAndTypeEntry(int offset);\n-\n-    \/**\n-     * {@return the method handle entry whose index is given at the specified\n-     * offset within the classfile}\n-     * @param offset the offset of the index within the classfile\n-     * @throws ConstantPoolException if the index is out of range of the\n-     *         constant pool size, or zero, or the index does not correspond to\n-     *         a method handle entry\n-     *\/\n-    MethodHandleEntry readMethodHandleEntry(int offset);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassReader.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -44,1 +44,5 @@\n-    \/** {@return the instantiation of the superclass in this signature} *\/\n+    \/**\n+     * {@return the instantiation of the superclass in this signature}\n+     *\n+     * @since 23\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-import jdk.internal.classfile.impl.TransformingCodeBuilder;\n+\n@@ -100,0 +100,21 @@\n+ * <h2>Instruction Factories<\/h2>\n+ * {@code CodeBuilder} provides convenience methods to create instructions (See\n+ * JVMS {@jvms 6.5} Instructions) by their mnemonic, taking necessary operands.\n+ * <ul>\n+ * <li>Instructions that encode their operands in their opcode, such as {@code\n+ * aload_<n>}, share their factories with their generic version like {@link\n+ * #aload aload}. Note that some constant instructions, such as {@link #iconst_1\n+ * iconst_1}, do not have generic versions, and thus have their own factories.\n+ * <li>Instructions that accept wide operands, such as {@code ldc2_w} or {@code\n+ * wide}, share their factories with their regular version like {@link #ldc}. Note\n+ * that {@link #goto_w goto_w} has its own factory to avoid {@linkplain\n+ * ClassFile.ShortJumpsOption short jumps}.\n+ * <li>The {@code goto}, {@code instanceof}, {@code new}, and {@code return}\n+ * instructions' factories are named {@link #goto_ goto_}, {@link #instanceOf\n+ * instanceOf}, {@link #new_ new_}, and {@link #return_() return_} respectively,\n+ * due to clashes with keywords in the Java programming language.\n+ * <li>Factories are not provided for instructions {@code jsr}, {@code jsr_w},\n+ * {@code ret}, and {@code wide ret}, which cannot appear in class files with\n+ * major version {@value ClassFile#JAVA_7_VERSION} or higher. (JVMS {@jvms 4.9.1})\n+ * <\/ul>\n+ *\n@@ -133,1 +154,1 @@\n-     * @throws IllegalStateException if this is not a static method\n+     * @throws IllegalStateException if this is a static method\n@@ -174,1 +195,1 @@\n-        handler.accept(new TransformingCodeBuilder(this, resolved.consumer()));\n+        handler.accept(new ChainedCodeBuilder(this, resolved.consumer()));\n@@ -702,1 +723,1 @@\n-        return with(ExceptionCatch.of(handler, start, end, Optional.of(catchType)));\n+        return with(ExceptionCatch.of(handler, start, end, Optional.ofNullable(catchType)));\n@@ -840,0 +861,4 @@\n+     *\n+     * <p>This may also generate {@code aload_<N>} and\n+     * {@code wide aload} instructions.\n+     *\n@@ -884,0 +909,4 @@\n+     *\n+     * <p>This may also generate {@code astore_<N>} and\n+     * {@code wide astore} instructions.\n+     *\n@@ -1049,0 +1078,4 @@\n+     *\n+     * <p>This may also generate {@code dload_<N>} and\n+     * {@code wide dload} instructions.\n+     *\n@@ -1090,0 +1123,4 @@\n+     *\n+     * <p>This may also generate {@code dstore_<N>} and\n+     * {@code wide dstore} instructions.\n+     *\n@@ -1253,0 +1290,4 @@\n+     *\n+     * <p>This may also generate {@code fload_<N>} and\n+     * {@code wide fload} instructions.\n+     *\n@@ -1294,0 +1335,4 @@\n+     *\n+     * <p>This may also generate {@code fstore_<N>} and\n+     * {@code wide fstore} instructions.\n+     *\n@@ -1353,0 +1398,9 @@\n+     *\n+     * <p>This may also generate {@code goto_w} instructions if the {@link\n+     * ClassFile.ShortJumpsOption#FIX_SHORT_JUMPS FIX_SHORT_JUMPS} option\n+     * is set.\n+     *\n+     * @apiNote The instruction's name is {@code goto}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n@@ -1590,1 +1644,1 @@\n-    default CodeBuilder if_nonnull(Label target) {\n+    default CodeBuilder ifnonnull(Label target) {\n@@ -1599,1 +1653,1 @@\n-    default CodeBuilder if_null(Label target) {\n+    default CodeBuilder ifnull(Label target) {\n@@ -1669,0 +1723,4 @@\n+     *\n+     * <p>This may also generate {@code iload_<N>} and\n+     * {@code wide iload} instructions.\n+     *\n@@ -1694,0 +1752,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code instanceof}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with camel case instead.\n+     *\n@@ -1704,0 +1767,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code instanceof}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with camel case instead.\n+     *\n@@ -1913,0 +1981,4 @@\n+     *\n+     * <p>This may also generate {@code istore_<N>} and\n+     * {@code wide istore} instructions.\n+     *\n@@ -2036,0 +2108,6 @@\n+     *\n+     * <p>This may also generate {@code ldc_w} and {@code ldc2_w} instructions.\n+     *\n+     * @apiNote {@link #loadConstant(ConstantDesc) loadConstant} generates more optimal instructions\n+     * and should be used for general constants if an {@code ldc} instruction is not strictly required.\n+     *\n@@ -2045,0 +2123,3 @@\n+     *\n+     * <p>This may also generate {@code ldc_w} and {@code ldc2_w} instructions.\n+     *\n@@ -2065,0 +2146,4 @@\n+     *\n+     * <p>This may also generate {@code lload_<N>} and\n+     * {@code wide lload} instructions.\n+     *\n@@ -2130,0 +2215,4 @@\n+     *\n+     * <p>This may also generate {@code lstore_<N>} and\n+     * {@code wide lstore} instructions.\n+     *\n@@ -2200,0 +2289,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code new}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n@@ -2209,0 +2303,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code new}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n@@ -2286,0 +2385,5 @@\n+     *\n+     * @apiNote The instruction's name is {@code return}, which coincides with a\n+     * reserved keyword of the Java programming language, thus this method is\n+     * named with an extra {@code _} suffix instead.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":111,"deletions":7,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,1 @@\n-     * {@return the position of the {@code Label} in the {@code codeArray}\n-     * or -1 if the {@code Label} does not point to the {@code codeArray}}\n+     * {@return the position of the {@code label} in the {@link #codeArray codeArray}}\n@@ -64,0 +63,1 @@\n+     * @throws IllegalArgumentException if the {@code label} is not from this attribute\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CodeAttribute.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-        return  mb.build();\n+        return mb.build();\n@@ -169,1 +169,1 @@\n-        return  mb.build();\n+        return mb.build();\n@@ -322,6 +322,0 @@\n-\n-        \/**\n-         * Builds module attribute.\n-         * @return the module attribute\n-         *\/\n-        ModuleAttribute build();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-        return context.transform(clm, map(clm.thisClass().asSymbol()), this);\n+        return context.transformClass(clm, map(clm.thisClass().asSymbol()), this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassRemapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,8 +77,0 @@\n-\n-    \/**\n-     * Access method to internal re-labeling function.\n-     * @param label source label\n-     * @param codeBuilder builder to create new labels\n-     * @return target label\n-     *\/\n-    Label relabel(Label label, CodeBuilder codeBuilder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeRelabeler.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-        byte[] newBytes = ClassFile.of().transform(\n+        byte[] newBytes = ClassFile.of().transformClass(\n@@ -148,1 +148,1 @@\n-        byte[] newBytes = ClassFile.of().transform(\n+        byte[] newBytes = ClassFile.of().transformClass(\n@@ -163,1 +163,1 @@\n-        return ClassFile.of().transform(target,\n+        return ClassFile.of().transformClass(target,\n@@ -194,1 +194,1 @@\n-                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                    .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,8 +95,0 @@\n-    \/**\n-     * Writes associated bootstrap method entries to the specified writer\n-     *\n-     * @param buf the writer\n-     * @return false when no bootstrap method entry has been written\n-     *\/\n-    boolean writeBootstrapMethods(BufWriter buf);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-        byte[] newBytes = cc.transform(cc.parse(bytes), ct);\n+        byte[] newBytes = cc.transformClass(cc.parse(bytes), ct);\n@@ -349,1 +349,1 @@\n-        byte[] newBytes = ClassFile.of().transform(classModel,\n+        byte[] newBytes = ClassFile.of().transformClass(classModel,\n@@ -363,1 +363,1 @@\n-        return ClassFile.of().transform(target,\n+        return ClassFile.of().transformClass(target,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -377,0 +377,3 @@\n+    \/**\n+     * @since 21\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,0 +210,3 @@\n+    \/**\n+     * @since 21\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -225,0 +225,2 @@\n+     *\n+     * @since 21\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n- *     MemoryLayout.paddingLayout(32),\n+ *     MemoryLayout.paddingLayout(4),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n- *     ... POINT_ARR_X.get(segment, 0L, (long)i) ...\n+ *     ... POINT_ARR_X.get(points, 0L, (long)i) ...\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -621,0 +621,2 @@\n+     *\n+     * @since 23\n@@ -634,0 +636,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -653,0 +658,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -680,0 +688,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -706,0 +717,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -722,0 +736,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -760,0 +777,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n@@ -808,0 +828,3 @@\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -42,0 +43,1 @@\n+import java.util.function.Consumer;\n@@ -69,0 +71,2 @@\n+    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n+    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -616,56 +620,61 @@\n-            return ClassFile.of().build(classDesc, clb -> {\n-                clb.withFlags(ACC_FINAL | ACC_SUPER)\n-                   .withSuperclass(superClassDesc)\n-                   .with(SourceFileAttribute.of(classDesc.displayName()))\n-\n-                \/\/ emit static types and BMH_SPECIES fields\n-                   .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n-\n-                \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n-                class Var {\n-                    final int index;\n-                    final String name;\n-                    final Class<?> type;\n-                    final ClassDesc desc;\n-                    final BasicType basicType;\n-                    final int slotIndex;\n-                    Var(int index, int slotIndex) {\n-                        this.index = index;\n-                        this.slotIndex = slotIndex;\n-                        name = null; type = null; desc = null;\n-                        basicType = BasicType.V_TYPE;\n-                    }\n-                    Var(String name, Class<?> type, Var prev) {\n-                        int slotIndex = prev.nextSlotIndex();\n-                        int index = prev.nextIndex();\n-                        if (name == null)  name = \"x\";\n-                        if (name.endsWith(\"#\"))\n-                            name = name.substring(0, name.length()-1) + index;\n-                        assert(!type.equals(void.class));\n-                        this.index = index;\n-                        this.name = name;\n-                        this.type = type;\n-                        this.desc = classDesc(type);\n-                        this.basicType = BasicType.basicType(type);\n-                        this.slotIndex = slotIndex;\n-                    }\n-                    Var lastOf(List<Var> vars) {\n-                        int n = vars.size();\n-                        return (n == 0 ? this : vars.get(n-1));\n-                    }\n-                    <X> List<Var> fromTypes(List<X> types) {\n-                        Var prev = this;\n-                        ArrayList<Var> result = new ArrayList<>(types.size());\n-                        int i = 0;\n-                        for (X x : types) {\n-                            String vn = name;\n-                            Class<?> vt;\n-                            if (x instanceof Class<?> cl) {\n-                                vt = cl;\n-                                \/\/ make the names friendlier if debugging\n-                                assert((vn = vn + \"_\" + (i++)) != null);\n-                            } else {\n-                                @SuppressWarnings(\"unchecked\")\n-                                Var v = (Var) x;\n-                                vn = v.name;\n-                                vt = v.type;\n+            return ClassFile.of().build(classDesc, new Consumer<ClassBuilder>() {\n+                @Override\n+                public void accept(ClassBuilder clb) {\n+                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                       .withSuperclass(superClassDesc)\n+                       .with(SourceFileAttribute.of(classDesc.displayName()))\n+\n+                    \/\/ emit static types and BMH_SPECIES fields\n+                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+\n+                    \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n+                    class Var {\n+                        final int index;\n+                        final String name;\n+                        final Class<?> type;\n+                        final ClassDesc desc;\n+                        final BasicType basicType;\n+                        final int slotIndex;\n+                        Var(int index, int slotIndex) {\n+                            this.index = index;\n+                            this.slotIndex = slotIndex;\n+                            name = null; type = null; desc = null;\n+                            basicType = BasicType.V_TYPE;\n+                        }\n+                        Var(String name, Class<?> type, Var prev) {\n+                            int slotIndex = prev.nextSlotIndex();\n+                            int index = prev.nextIndex();\n+                            if (name == null)  name = \"x\";\n+                            if (name.endsWith(\"#\"))\n+                                name = name.substring(0, name.length()-1) + index;\n+                            assert(!type.equals(void.class));\n+                            this.index = index;\n+                            this.name = name;\n+                            this.type = type;\n+                            this.desc = classDesc(type);\n+                            this.basicType = BasicType.basicType(type);\n+                            this.slotIndex = slotIndex;\n+                        }\n+                        Var lastOf(List<Var> vars) {\n+                            int n = vars.size();\n+                            return (n == 0 ? this : vars.get(n-1));\n+                        }\n+                        <X> List<Var> fromTypes(List<X> types) {\n+                            Var prev = this;\n+                            ArrayList<Var> result = new ArrayList<>(types.size());\n+                            int i = 0;\n+                            for (X x : types) {\n+                                String vn = name;\n+                                Class<?> vt;\n+                                if (x instanceof Class<?> cl) {\n+                                    vt = cl;\n+                                    \/\/ make the names friendlier if debugging\n+                                    assert((vn = vn + \"_\" + (i++)) != null);\n+                                } else {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Var v = (Var) x;\n+                                    vn = v.name;\n+                                    vt = v.type;\n+                                }\n+                                prev = new Var(vn, vt, prev);\n+                                result.add(prev);\n@@ -673,2 +682,1 @@\n-                            prev = new Var(vn, vt, prev);\n-                            result.add(prev);\n+                            return result;\n@@ -676,37 +684,0 @@\n-                        return result;\n-                    }\n-\n-                    int slotSize() { return basicType.basicTypeSlots(); }\n-                    int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n-                    int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n-                    boolean isInHeap() { return slotIndex < 0; }\n-                    void emitLoadInstruction(CodeBuilder cob) {\n-                        cob.loadLocal(basicType.btKind, slotIndex);\n-                    }\n-                }\n-\n-                final Var NO_THIS = new Var(0, 0),\n-                        AFTER_THIS = new Var(0, 1),\n-                        IN_HEAP = new Var(0, -1);\n-\n-                \/\/ figure out the field types\n-                final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n-                final List<Var> fields = new ArrayList<>(fieldTypes.size());\n-                {\n-                    Var nextF = IN_HEAP;\n-                    for (Class<?> ft : fieldTypes) {\n-                        String fn = chooseFieldName(ft, nextF.nextIndex());\n-                        nextF = new Var(fn, ft, nextF);\n-                        fields.add(nextF);\n-                    }\n-                }\n-\n-                \/\/ emit bound argument fields\n-                for (Var field : fields) {\n-                    clb.withField(field.name, field.desc, ACC_FINAL);\n-                }\n-\n-                \/\/ emit implementation of speciesData()\n-                clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                        cob -> cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                                  .areturn());\n@@ -714,11 +685,7 @@\n-                \/\/ figure out the constructor arguments\n-                MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n-                MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n-\n-                \/\/ emit constructor\n-                clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE, cob -> {\n-                    cob.aload(0); \/\/ this\n-\n-                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n-                    for (Var ca : ctorArgs) {\n-                        ca.emitLoadInstruction(cob);\n+                        int slotSize() { return basicType.basicTypeSlots(); }\n+                        int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n+                        int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n+                        boolean isInHeap() { return slotIndex < 0; }\n+                        void emitLoadInstruction(CodeBuilder cob) {\n+                            cob.loadLocal(basicType.btKind, slotIndex);\n+                        }\n@@ -727,11 +694,14 @@\n-                    \/\/ super(ca...)\n-                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n-\n-                    \/\/ store down fields\n-                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n-                    for (Var f : fields) {\n-                        \/\/ this.argL1 = argL1\n-                        cob.aload(0);  \/\/ this\n-                        lastFV = new Var(f.name, f.type, lastFV);\n-                        lastFV.emitLoadInstruction(cob);\n-                        cob.putfield(classDesc, f.name, f.desc);\n+                    final Var NO_THIS = new Var(0, 0),\n+                            AFTER_THIS = new Var(0, 1),\n+                            IN_HEAP = new Var(0, -1);\n+\n+                    \/\/ figure out the field types\n+                    final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n+                    final List<Var> fields = new ArrayList<>(fieldTypes.size());\n+                    {\n+                        Var nextF = IN_HEAP;\n+                        for (Class<?> ft : fieldTypes) {\n+                            String fn = chooseFieldName(ft, nextF.nextIndex());\n+                            nextF = new Var(fn, ft, nextF);\n+                            fields.add(nextF);\n+                        }\n@@ -740,12 +710,3 @@\n-                    cob.return_();\n-                });\n-\n-                \/\/ emit make()  ...factory method wrapping constructor\n-                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n-                clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC, cob -> {\n-                    \/\/ make instance\n-                    cob.new_(classDesc)\n-                       .dup();\n-                    \/\/ load factory method arguments:  ctarg... and arg...\n-                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n-                        v.emitLoadInstruction(cob);\n+                    \/\/ emit bound argument fields\n+                    for (Var field : fields) {\n+                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n@@ -754,40 +715,7 @@\n-                    \/\/ finally, invoke the constructor and return\n-                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n-                       .areturn();\n-                });\n-\n-                \/\/ For each transform, emit the customized override of the transform method.\n-                \/\/ This method mixes together some incoming arguments (from the transform's\n-                \/\/ static type signature) with the field types themselves, and passes\n-                \/\/ the resulting mish-mosh of values to a method handle produced by\n-                \/\/ the species itself.  (Typically this method handle is the factory\n-                \/\/ method of this species or a related one.)\n-                for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n-                    final int whichtm = i;\n-                    final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n-                    final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n-                    final int        TMODS = TRANSFORM_MODS.get(whichtm);\n-                    clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, mb -> {\n-                        mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n-                          .withCode(cob -> {\n-                            \/\/ return a call to the corresponding \"transform helper\", something like this:\n-                            \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n-                            cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                               .loadConstant(whichtm)\n-                               .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n-\n-                            List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n-                            List<Var> tfields = new ArrayList<>(fields);\n-                            \/\/ mix them up and load them for the transform helper:\n-                            List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n-                            ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n-                            for (int hi = 0; hi < helperTypes.length; hi++) {\n-                                Var ha = helperArgs.get(hi);\n-                                helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n-                                if (ha.isInHeap()) {\n-                                    assert(tfields.contains(ha));\n-                                    cob.aload(0);\n-                                    cob.getfield(classDesc, ha.name, ha.desc);\n-                                } else {\n-                                    assert(targs.contains(ha));\n-                                    ha.emitLoadInstruction(cob);\n+                    \/\/ emit implementation of speciesData()\n+                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                            .areturn();\n@@ -795,10 +723,108 @@\n-                            }\n-\n-                            \/\/ jump into the helper (which is probably a factory method)\n-                            final Class<?> rtype = TTYPE.returnType();\n-                            if (!rtype.isPrimitive()) {\n-                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n-                                   .checkcast(classDesc(rtype))\n-                                   .areturn();\n-                            } else {\n-                                throw newInternalError(\"NYI: transform of type \"+rtype);\n+                            }));\n+\n+                    \/\/ figure out the constructor arguments\n+                    MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n+                    MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n+\n+                    \/\/ emit constructor\n+                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.aload(0); \/\/ this\n+\n+                                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n+                                    for (Var ca : ctorArgs) {\n+                                        ca.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ super(ca...)\n+                                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n+\n+                                    \/\/ store down fields\n+                                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n+                                    for (Var f : fields) {\n+                                        \/\/ this.argL1 = argL1\n+                                        cob.aload(0);  \/\/ this\n+                                        lastFV = new Var(f.name, f.type, lastFV);\n+                                        lastFV.emitLoadInstruction(cob);\n+                                        cob.putfield(classDesc, f.name, f.desc);\n+                                    }\n+\n+                                    cob.return_();\n+                                }\n+                            }));\n+\n+                    \/\/ emit make()  ...factory method wrapping constructor\n+                    MethodType ftryType = thisCtorType.changeReturnType(topClass());\n+                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    \/\/ make instance\n+                                    cob.new_(classDesc)\n+                                            .dup();\n+                                    \/\/ load factory method arguments:  ctarg... and arg...\n+                                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n+                                        v.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ finally, invoke the constructor and return\n+                                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n+                                            .areturn();\n+                                }\n+                            }));\n+\n+                    \/\/ For each transform, emit the customized override of the transform method.\n+                    \/\/ This method mixes together some incoming arguments (from the transform's\n+                    \/\/ static type signature) with the field types themselves, and passes\n+                    \/\/ the resulting mish-mosh of values to a method handle produced by\n+                    \/\/ the species itself.  (Typically this method handle is the factory\n+                    \/\/ method of this species or a related one.)\n+                    for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n+                        final int whichtm = i;\n+                        final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n+                        final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n+                        final int        TMODS = TRANSFORM_MODS.get(whichtm);\n+                        clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, new Consumer<MethodBuilder>() {\n+                            @Override\n+                            public void accept(MethodBuilder mb) {\n+                                mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n+                                  .withCode(new Consumer<CodeBuilder>() {\n+                                    @Override\n+                                    public void accept(CodeBuilder cob) {\n+                                        \/\/ return a call to the corresponding \"transform helper\", something like this:\n+                                        \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n+                                        cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                                .loadConstant(whichtm)\n+                                                .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n+\n+                                        List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n+                                        List<Var> tfields = new ArrayList<>(fields);\n+                                        \/\/ mix them up and load them for the transform helper:\n+                                        List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n+                                        ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n+                                        for (int hi = 0; hi < helperTypes.length; hi++) {\n+                                            Var ha = helperArgs.get(hi);\n+                                            helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n+                                            if (ha.isInHeap()) {\n+                                                assert(tfields.contains(ha));\n+                                                cob.aload(0);\n+                                                cob.getfield(classDesc, ha.name, ha.desc);\n+                                            } else {\n+                                                assert(targs.contains(ha));\n+                                                ha.emitLoadInstruction(cob);\n+                                            }\n+                                        }\n+\n+                                        \/\/ jump into the helper (which is probably a factory method)\n+                                        final Class<?> rtype = TTYPE.returnType();\n+                                        if (!rtype.isPrimitive()) {\n+                                            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n+                                                    .checkcast(classDesc(rtype))\n+                                                    .areturn();\n+                                        } else {\n+                                            throw newInternalError(\"NYI: transform of type \"+rtype);\n+                                        }\n+                                    }\n+                                });\n@@ -807,1 +833,1 @@\n-                    });\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":206,"deletions":180,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -72,8 +72,8 @@\n-        if (type == int.class)     return TypeKind.IntType;\n-        if (type == long.class)    return TypeKind.LongType;\n-        if (type == boolean.class) return TypeKind.BooleanType;\n-        if (type == short.class)   return TypeKind.ShortType;\n-        if (type == byte.class)    return TypeKind.ByteType;\n-        if (type == char.class)    return TypeKind.CharType;\n-        if (type == float.class)   return TypeKind.FloatType;\n-        if (type == double.class)  return TypeKind.DoubleType;\n+        if (type == Integer.class)   return TypeKind.IntType;\n+        if (type == Long.class)      return TypeKind.LongType;\n+        if (type == Boolean.class)   return TypeKind.BooleanType;\n+        if (type == Short.class)     return TypeKind.ShortType;\n+        if (type == Byte.class)      return TypeKind.ByteType;\n+        if (type == Character.class) return TypeKind.CharType;\n+        if (type == Float.class)     return TypeKind.FloatType;\n+        if (type == Double.class)    return TypeKind.DoubleType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -529,2 +529,0 @@\n-     *\n-     * @since 11\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -517,2 +517,1 @@\n-        List<ProxyMethod> sigmethods = proxyMethods.computeIfAbsent(sig,\n-                _ -> new ArrayList<>(3));\n+        List<ProxyMethod> sigmethods = proxyMethodsFor(sig);\n@@ -540,0 +539,4 @@\n+    private List<ProxyMethod> proxyMethodsFor(String sig) {\n+        return proxyMethods.computeIfAbsent(sig, _ -> new ArrayList<>(3));\n+    }\n+\n@@ -546,4 +549,1 @@\n-        String sig = pm.shortSignature;\n-        List<ProxyMethod> sigmethods = proxyMethods.computeIfAbsent(sig,\n-                _ -> new ArrayList<>(3));\n-        sigmethods.add(pm);\n+        proxyMethodsFor(pm.shortSignature).add(pm);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-        private Object[] resolvedEnum;\n+        private final Object[] resolvedEnum;\n@@ -425,1 +425,1 @@\n-            cb.if_nonnull(nonNullLabel);\n+            cb.ifnonnull(nonNullLabel);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-     *        domain parameters. See the ParameterSpec Names section in the\n+     *        domain parameters. See the ECGenParameterSpec section in the\n@@ -50,1 +50,1 @@\n-     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#parameterspec-names\">\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#ecgenparameterspec\">\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/ECGenParameterSpec.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,4 +33,4 @@\n- * parameter set name. For example, NamedParameterSpec.X25519 represents the\n- * parameter set identified by the string \"X25519\". These strings are defined\n- * in the <a href=\n- * \"{@docRoot}\/..\/specs\/security\/standard-names.html#parameterspec-names\">\n+ * parameter set name. For example, {@code NamedParameterSpec.X25519}\n+ * represents the parameter set identified by the string \"X25519\". These\n+ * strings are defined in the <a href=\n+ * \"{@docRoot}\/..\/specs\/security\/standard-names.html#namedparameterspec\">\n@@ -80,1 +80,1 @@\n-     *        ParameterSpec Names section in the\n+     *        NamedParameterSpec section in the\n@@ -82,1 +82,1 @@\n-     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#parameterspec-names\">\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#namedparameterspec\">\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/NamedParameterSpec.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,2 +121,13 @@\n-     * @param mdName       the algorithm name of the hash function\n-     * @param mgfName      the algorithm name of the mask generation function\n+     * @param mdName       the algorithm name of the hash function. See the\n+     *         PSSParameterSpec section of the\n+     *         <a href=\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#pssparameterspec\">\n+     *         Java Security Standard Algorithm Names Specification<\/a>\n+     *         for information about standard names for the hash function.\n+     * @param mgfName      the algorithm name of the mask generation function.\n+     *         See the PSSParameterSpec section of the\n+     *         <a href=\n+     *        \"{@docRoot}\/..\/specs\/security\/standard-names.html#pssparameterspec\">\n+     *         Java Security Standard Algorithm Names Specification<\/a>\n+     *         for information about standard names for the mask generation\n+     *         function.\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PSSParameterSpec.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -589,0 +589,3 @@\n+    \/**\n+     * @since 23\n+     *\/\n@@ -595,0 +598,3 @@\n+    \/**\n+     * @since 23\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1727,1 +1727,1 @@\n-                digitList, false, false, status);\n+                digitList, false, false, status).fullPos();\n@@ -1735,20 +1735,0 @@\n-\n-        \/\/ If parse integer only is true and the parsing is broken at\n-        \/\/ decimal point, then pass\/ignore all digits and move pointer\n-        \/\/ at the start of suffix, to process the suffix part\n-        if (isParseIntegerOnly() && position < text.length()\n-                && text.charAt(position) == symbols.getDecimalSeparator()) {\n-            position++; \/\/ Pass decimal character\n-            for (; position < text.length(); ++position) {\n-                char ch = text.charAt(position);\n-                int digit = ch - symbols.getZeroDigit();\n-                if (digit < 0 || digit > 9) {\n-                    digit = Character.digit(ch, 10);\n-                    \/\/ Parse all digit characters\n-                    if (!(digit >= 0 && digit <= 9)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n@@ -2375,0 +2355,2 @@\n+     * @implSpec This implementation does not set the {@code ParsePosition} index\n+     * to the position of the decimal symbol, but rather the end of the string.\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2153,4 +2153,1 @@\n-     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n-     *   separator is found\n-     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n-     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and the grouping\n@@ -2382,1 +2379,2 @@\n-        position = subparseNumber(text, position, digits, true, isExponent, status);\n+        NumericPosition pos = subparseNumber(text, position, digits, true, isExponent, status);\n+        position = pos.fullPos;\n@@ -2425,3 +2423,9 @@\n-            \/\/ No failures, thus increment the index by the suffix\n-            parsePosition.index = position +\n-                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n+            \/\/ When parsing integer only, index should be int pos\n+            \/\/ If intPos is 0, the entire value was integer\n+            if (isParseIntegerOnly() && pos.intPos > 0) {\n+                parsePosition.index = pos.intPos;\n+            } else {\n+                \/\/ increment the index by the suffix\n+                parsePosition.index = position +\n+                        (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n+            }\n@@ -2440,0 +2444,13 @@\n+    \/**\n+     * NumericPosition is a helper record class that stores two indices of interest.\n+     * {@code fullPos} is either the first unparseable character or -1 in case\n+     * of no valid number parsed. {@code intPos} reflects the position of\n+     * a parsed decimal symbol, if one exists. When parsing with {@code isParseIntegerOnly()},\n+     * {@code fullPos} is used to match the suffix, and reset the {@code ParsePosition}\n+     * index to {@code intPos}.\n+     *\n+     * @param fullPos an index that reflects the full traversal of the numerical String\n+     * @param intPos an index that reflects the position of a parsed decimal symbol.\n+     *\/\n+    record NumericPosition(int fullPos, int intPos) {}\n+\n@@ -2452,2 +2469,2 @@\n-     * @return returns the position of the first unparseable character or\n-     *         -1 in case of no valid number parsed\n+     * @return returns a {@code NumericPosition} that stores both a full\n+     *         traversal index, and an int only index.\n@@ -2455,3 +2472,3 @@\n-    int subparseNumber(String text, int position,\n-                       DigitList digits, boolean checkExponent,\n-                       boolean isExponent, boolean[] status) {\n+    NumericPosition subparseNumber(String text, int position,\n+                                   DigitList digits, boolean checkExponent,\n+                                   boolean isExponent, boolean[] status) {\n@@ -2460,0 +2477,1 @@\n+        int intIndex = 0;\n@@ -2519,1 +2537,1 @@\n-                    return position;\n+                    return new NumericPosition(position, intIndex);\n@@ -2541,1 +2559,3 @@\n-                        digits.append((char)(digit + '0'));\n+                        if (!sawDecimal || !isParseIntegerOnly()) {\n+                            digits.append((char)(digit + '0'));\n+                        }\n@@ -2546,1 +2566,3 @@\n-                    digits.append((char)(digit + '0'));\n+                    if (!sawDecimal || !isParseIntegerOnly()) {\n+                        digits.append((char) (digit + '0'));\n+                    }\n@@ -2553,1 +2575,2 @@\n-                        return groupingViolationIndex(position, prevSeparatorIndex);\n+                        return new NumericPosition(\n+                                groupingViolationIndex(position, prevSeparatorIndex), intIndex);\n@@ -2557,1 +2580,1 @@\n-                    if (isParseIntegerOnly() || sawDecimal) {\n+                    if (sawDecimal) {\n@@ -2560,0 +2583,1 @@\n+                    intIndex = position;\n@@ -2566,1 +2590,1 @@\n-                            return startPos;\n+                            return new NumericPosition(startPos, intIndex);\n@@ -2571,1 +2595,2 @@\n-                            return groupingViolationIndex(position, prevSeparatorIndex);\n+                            return new NumericPosition(\n+                                    groupingViolationIndex(position, prevSeparatorIndex), intIndex);\n@@ -2624,1 +2649,2 @@\n-                    return groupingViolationIndex(position - 1, prevSeparatorIndex);\n+                    return new NumericPosition(\n+                            groupingViolationIndex(position - 1, prevSeparatorIndex), intIndex);\n@@ -2639,2 +2665,3 @@\n-            \/\/ Adjust for exponent, if any\n-            if (exponent != 0) {\n+            \/\/ If parsing integer only, adjust exponent if it occurs\n+            \/\/ in integer portion, otherwise ignore it\n+            if (!sawDecimal || !isParseIntegerOnly()) {\n@@ -2649,1 +2676,1 @@\n-                return -1;\n+                return new NumericPosition(-1, intIndex);\n@@ -2652,1 +2679,1 @@\n-        return position;\n+        return new NumericPosition(position, intIndex);\n@@ -2920,1 +2947,2 @@\n-     * \"123\" is parsed into 1.23.\n+     * \"123\" is parsed into 1.23. If {@code isParseIntegerOnly()} returns {@code true},\n+     * \"123\" is parsed into 1.\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":54,"deletions":26,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -471,1 +471,3 @@\n-     * Returns true if this format will parse numbers as integers only.\n+     * Returns {@code true} if this format will parse numbers as integers only.\n+     * The {@code ParsePosition} index will be set to the position of the decimal\n+     * symbol. The exact format accepted by the parse operation is locale dependent.\n@@ -473,4 +475,1 @@\n-     * string \"1234.\" would be parsed as the integer value 1234 and parsing\n-     * would stop at the \".\" character.  Of course, the exact format accepted\n-     * by the parse operation is locale dependent and determined by sub-classes\n-     * of NumberFormat.\n+     * string \"123.45\" would be parsed as the integer value 123.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4252,2 +4252,2 @@\n-            for (int i = 0; i < nzeros; i++) {\n-                sb.append('0');\n+            if (nzeros > 0) {\n+                sb.repeat('0', nzeros);\n@@ -4970,3 +4970,3 @@\n-                     LINE_SEPARATOR,\n-                     PERCENT_SIGN -> true;\n-                default -> false;\n+                     LINE_SEPARATOR -> true;\n+                \/\/ Don't put PERCENT_SIGN inside switch, as that will make the method size exceed 325 and cannot be inlined.\n+                default -> c == PERCENT_SIGN;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2181,0 +2181,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -2196,0 +2199,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -2443,0 +2449,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2448,0 +2457,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2453,0 +2465,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2458,0 +2473,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2463,0 +2481,3 @@\n+    \/**\n+     * @since 12\n+     *\/\n@@ -2588,0 +2609,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -330,0 +330,2 @@\n+     *\n+     * @since 21\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayQueue.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -890,0 +890,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -899,0 +902,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -913,0 +919,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -208,0 +208,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -224,0 +227,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n@@ -239,0 +245,3 @@\n+    \/**\n+     * @since 19\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/FutureTask.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    int extraAttributes = -1; \/\/ e.g. POSIX permissions, sym links.\n+    int externalFileAttributes = -1; \/\/ File type, setuid, setgid, sticky, POSIX permissions\n@@ -137,1 +137,1 @@\n-        extraAttributes = e.extraAttributes;\n+        externalFileAttributes = e.externalFileAttributes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -700,1 +700,1 @@\n-            e.extraAttributes = CENATX_PERMS(cen, pos) & 0xFFFF;\n+            e.externalFileAttributes = CENATX_PERMS(cen, pos) & 0xFFFF;\n@@ -1168,2 +1168,2 @@\n-                public int getExtraAttributes(ZipEntry ze) {\n-                    return ze.extraAttributes;\n+                public int getExternalFileAttributes(ZipEntry ze) {\n+                    return ze.externalFileAttributes;\n@@ -1172,2 +1172,2 @@\n-                public void setExtraAttributes(ZipEntry ze, int extraAttrs) {\n-                    ze.extraAttributes = extraAttrs;\n+                public void setExternalFileAttributes(ZipEntry ze, int externalFileAttributes) {\n+                    ze.externalFileAttributes = externalFileAttributes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-        return (e.extraAttributes < 0) ? version :\n+        return (e.externalFileAttributes < 0) ? version :\n@@ -640,1 +640,1 @@\n-        writeInt(e.extraAttributes > 0 ? e.extraAttributes << 16 : 0);\n+        writeInt(e.externalFileAttributes > 0 ? e.externalFileAttributes << 16 : 0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,2 @@\n-    public void setExtraAttributes(ZipEntry ze, int extraAttrs);\n-    public int getExtraAttributes(ZipEntry ze);\n+    public void setExternalFileAttributes(ZipEntry ze, int externalFileAttributes);\n+    public int getExternalFileAttributes(ZipEntry ze);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilZipFileAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-                classEntry = code.classReader.readClassEntry(pos + 1);\n+                classEntry = code.classReader.readEntry(pos + 1, ClassEntry.class);\n@@ -579,1 +579,1 @@\n-            return code.classReader.readClassEntry(pos + 1);\n+            return code.classReader.readEntry(pos + 1, ClassEntry.class);\n@@ -610,1 +610,1 @@\n-            return code.classReader.readClassEntry(pos + 1);\n+            return code.classReader.readEntry(pos + 1, ClassEntry.class);\n@@ -639,1 +639,1 @@\n-                typeEntry = code.classReader.readClassEntry(pos + 1);\n+                typeEntry = code.classReader.readEntry(pos + 1, ClassEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,3 +69,4 @@\n-            case AEV_STRING -> new AnnotationImpl.OfStringImpl(classReader.readUtf8Entry(p));\n-            case AEV_ENUM -> new AnnotationImpl.OfEnumImpl(classReader.readUtf8Entry(p), classReader.readUtf8Entry(p + 2));\n-            case AEV_CLASS -> new AnnotationImpl.OfClassImpl(classReader.readUtf8Entry(p));\n+            case AEV_STRING -> new AnnotationImpl.OfStringImpl(classReader.readEntry(p, Utf8Entry.class));\n+            case AEV_ENUM -> new AnnotationImpl.OfEnumImpl(classReader.readEntry(p, Utf8Entry.class),\n+                    classReader.readEntry(p + 2, Utf8Entry.class));\n+            case AEV_CLASS -> new AnnotationImpl.OfClassImpl(classReader.readEntry(p, Utf8Entry.class));\n@@ -130,1 +131,1 @@\n-        Utf8Entry annotationClass = classReader.entryByIndex(classReader.readU2(p), Utf8Entry.class);\n+        Utf8Entry annotationClass = classReader.readEntry(p, Utf8Entry.class);\n@@ -153,1 +154,1 @@\n-            Utf8Entry elementName = classReader.readUtf8Entry(p);\n+            Utf8Entry elementName = classReader.readEntry(p, Utf8Entry.class);\n@@ -242,1 +243,1 @@\n-        Utf8Entry type = classReader.readUtf8Entry(p);\n+        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-        terminalMaxLocals = topLocal(terminal);\n-        terminal.with((LabelTarget) startLabel);\n+        terminalMaxLocals = terminal.curTopLocal();\n+        parent.with((LabelTarget) startLabel);\n@@ -59,2 +59,2 @@\n-        terminal.with((LabelTarget) endLabel);\n-        if (terminalMaxLocals != topLocal(terminal)) {\n+        parent.with((LabelTarget) endLabel);\n+        if (terminalMaxLocals != terminal.curTopLocal()) {\n@@ -76,4 +76,2 @@\n-            case ChainedCodeBuilder b -> topLocal(b.terminal);\n-            case DirectCodeBuilder b -> b.curTopLocal();\n-            case BufferedCodeBuilder b -> b.curTopLocal();\n-            case TransformingCodeBuilder b -> topLocal(b.delegate);\n+            case ChainedCodeBuilder b -> b.terminal.curTopLocal();\n+            case TerminalCodeBuilder b -> b.curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            Utf8Entry name = reader.readUtf8Entry(p);\n+            Utf8Entry name = reader.readEntry(p, Utf8Entry.class);\n@@ -350,1 +350,1 @@\n-                    Utf8Entry name = classReader.readUtf8EntryOrNull(p);\n+                    Utf8Entry name = classReader.readEntryOrNull(p, Utf8Entry.class);\n@@ -370,1 +370,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -381,1 +381,1 @@\n-                    ModuleEntry module = classReader.readModuleEntry(p);\n+                    ModuleEntry module = classReader.readEntry(p, ModuleEntry.class);\n@@ -433,1 +433,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -445,1 +445,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -457,1 +457,1 @@\n-            return classReader.readClassEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ClassEntry.class);\n@@ -469,1 +469,1 @@\n-            return classReader.readClassEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ClassEntry.class);\n@@ -501,1 +501,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -513,1 +513,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -525,1 +525,1 @@\n-            return classReader.readUtf8Entry(payloadStart);\n+            return classReader.readEntry(payloadStart, Utf8Entry.class);\n@@ -572,1 +572,1 @@\n-            return classReader.readModuleEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ModuleEntry.class);\n@@ -582,1 +582,1 @@\n-            return Optional.ofNullable(classReader.readUtf8EntryOrNull(payloadStart + 4));\n+            return Optional.ofNullable(classReader.readEntryOrNull(payloadStart + 4, Utf8Entry.class));\n@@ -633,1 +633,1 @@\n-                    elements[i] = ModuleRequireInfo.of(classReader.readModuleEntry(p),\n+                    elements[i] = ModuleRequireInfo.of(classReader.readEntry(p, ModuleEntry.class),\n@@ -645,1 +645,1 @@\n-                    PackageEntry pe = classReader.readPackageEntry(p);\n+                    PackageEntry pe = classReader.readEntry(p, PackageEntry.class);\n@@ -660,1 +660,1 @@\n-                    PackageEntry po = classReader.readPackageEntry(p);\n+                    PackageEntry po = classReader.readEntry(p, PackageEntry.class);\n@@ -678,1 +678,1 @@\n-                    ClassEntry c = classReader.readClassEntry(p);\n+                    ClassEntry c = classReader.readEntry(p, ClassEntry.class);\n@@ -746,2 +746,1 @@\n-                    final AbstractPoolEntry.MethodHandleEntryImpl handle\n-                            = (AbstractPoolEntry.MethodHandleEntryImpl) classReader.readMethodHandleEntry(p);\n+                    final var handle = classReader.readEntry(p, AbstractPoolEntry.MethodHandleEntryImpl.class);\n@@ -774,1 +773,1 @@\n-                    ClassEntry innerClass = classReader.readClassEntry(p);\n+                    ClassEntry innerClass = classReader.readEntry(p, ClassEntry.class);\n@@ -795,1 +794,1 @@\n-            return classReader.readClassEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ClassEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        return reader.readUtf8Entry(startPos);\n+        return reader.readEntry(startPos, Utf8Entry.class);\n@@ -54,1 +54,1 @@\n-        return reader.readUtf8Entry(startPos + 2);\n+        return reader.readEntry(startPos + 2, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundRecordComponentInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    private final ClassBuilder downstream;\n@@ -42,1 +41,0 @@\n-        this.downstream = downstream;\n@@ -63,1 +61,1 @@\n-        return downstream.with(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n@@ -67,0 +65,1 @@\n+        return this;\n@@ -75,1 +74,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n@@ -81,1 +81,1 @@\n-        return downstream.with(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n@@ -85,0 +85,1 @@\n+        return this;\n@@ -92,1 +93,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-    final MethodBuilder downstream;\n@@ -45,1 +44,0 @@\n-        this.downstream = downstream;\n@@ -61,1 +59,1 @@\n-        return downstream.with(terminal.bufferedCodeBuilder(null)\n+        consumer.accept(terminal.bufferedCodeBuilder(null)\n@@ -64,0 +62,1 @@\n+        return this;\n@@ -70,1 +69,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    public byte[] transform(ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n+    public byte[] transformClass(ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-                arr[i] = reader.readClassEntry(pos);\n+                arr[i] = reader.readEntry(pos, ClassEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-            thisClass = readClassEntry(thisClassPos);\n+            thisClass = readEntry(thisClassPos, ClassEntry.class);\n@@ -398,10 +398,10 @@\n-                case TAG_CLASS -> new AbstractPoolEntry.ClassEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_STRING -> new AbstractPoolEntry.StringEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_FIELDREF -> new AbstractPoolEntry.FieldRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n-                                                                             (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_METHODREF -> new AbstractPoolEntry.MethodRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n-                                                                               (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_INTERFACEMETHODREF -> new AbstractPoolEntry.InterfaceMethodRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n-                                                                                                 (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_NAMEANDTYPE -> new AbstractPoolEntry.NameAndTypeEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q),\n-                                                                                   (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q + 2));\n+                case TAG_CLASS -> new AbstractPoolEntry.ClassEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_STRING -> new AbstractPoolEntry.StringEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_FIELDREF -> new AbstractPoolEntry.FieldRefEntryImpl(this, index, readEntry(q, AbstractPoolEntry.ClassEntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_METHODREF -> new AbstractPoolEntry.MethodRefEntryImpl(this, index, readEntry(q, AbstractPoolEntry.ClassEntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_INTERFACEMETHODREF -> new AbstractPoolEntry.InterfaceMethodRefEntryImpl(this, index, readEntry(q, AbstractPoolEntry.ClassEntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_NAMEANDTYPE -> new AbstractPoolEntry.NameAndTypeEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class),\n+                        readEntry(q + 2, AbstractPoolEntry.Utf8EntryImpl.class));\n@@ -410,5 +410,5 @@\n-                case TAG_METHODTYPE -> new AbstractPoolEntry.MethodTypeEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_CONSTANTDYNAMIC -> new AbstractPoolEntry.ConstantDynamicEntryImpl(this, index, readU2(q), (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_INVOKEDYNAMIC -> new AbstractPoolEntry.InvokeDynamicEntryImpl(this, index, readU2(q), (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n-                case TAG_MODULE -> new AbstractPoolEntry.ModuleEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n-                case TAG_PACKAGE -> new AbstractPoolEntry.PackageEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n+                case TAG_METHODTYPE -> new AbstractPoolEntry.MethodTypeEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_CONSTANTDYNAMIC -> new AbstractPoolEntry.ConstantDynamicEntryImpl(this, index, readU2(q), readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_INVOKEDYNAMIC -> new AbstractPoolEntry.InvokeDynamicEntryImpl(this, index, readU2(q), readEntry(q + 2, AbstractPoolEntry.NameAndTypeEntryImpl.class));\n+                case TAG_MODULE -> new AbstractPoolEntry.ModuleEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n+                case TAG_PACKAGE -> new AbstractPoolEntry.PackageEntryImpl(this, index, readEntry(q, AbstractPoolEntry.Utf8EntryImpl.class));\n@@ -431,1 +431,1 @@\n-                throw new IllegalArgumentException(\"attribute \" + readUtf8Entry(p - 6).stringValue() + \" too big to handle\");\n+                throw new IllegalArgumentException(\"attribute \" + readEntry(p - 6, Utf8Entry.class).stringValue() + \" too big to handle\");\n@@ -468,35 +468,0 @@\n-    @Override\n-    public Utf8Entry readUtf8Entry(int pos) {\n-        return readEntry(pos, Utf8Entry.class);\n-    }\n-\n-    @Override\n-    public Utf8Entry readUtf8EntryOrNull(int pos) {\n-        return readEntryOrNull(pos, Utf8Entry.class);\n-    }\n-\n-    @Override\n-    public ModuleEntry readModuleEntry(int pos) {\n-        return readEntry(pos, ModuleEntry.class);\n-    }\n-\n-    @Override\n-    public PackageEntry readPackageEntry(int pos) {\n-        return readEntry(pos, PackageEntry.class);\n-    }\n-\n-    @Override\n-    public ClassEntry readClassEntry(int pos) {\n-        return readEntry(pos, ClassEntry.class);\n-    }\n-\n-    @Override\n-    public NameAndTypeEntry readNameAndTypeEntry(int pos) {\n-        return readEntry(pos, NameAndTypeEntry.class);\n-    }\n-\n-    @Override\n-    public MethodHandleEntry readMethodHandleEntry(int pos) {\n-        return readEntry(pos, MethodHandleEntry.class);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeRelabelerImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        return reader.readUtf8Entry(startPos + 2);\n+        return reader.readEntry(startPos + 2, Utf8Entry.class);\n@@ -69,1 +69,1 @@\n-        return reader.readUtf8Entry(startPos + 4);\n+        return reader.readEntry(startPos + 4, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-        permits BufferedCodeBuilder, CodeImpl, DirectCodeBuilder {\n+        permits TerminalCodeBuilder, CodeImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        public LabelImpl(LabelContext labelContext, int bci) {\n+    public LabelImpl(LabelContext labelContext, int bci) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-        return reader.readUtf8Entry(startPos + 2);\n+        return reader.readEntry(startPos + 2, Utf8Entry.class);\n@@ -72,1 +72,1 @@\n-        return reader.readUtf8Entry(startPos + 4);\n+        return reader.readEntry(startPos + 4, Utf8Entry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1049,1 +1049,1 @@\n-            checkLocal(methodDesc.parameterCount() + (isStatic ? 0 : -1));\n+            checkLocal(methodDesc.parameterCount() + (isStatic ? -1 : 0));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,5 +193,0 @@\n-    @Override\n-    public boolean writeBootstrapMethods(BufWriter buf) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n-public sealed interface TerminalCodeBuilder extends CodeBuilder\n-        permits DirectCodeBuilder, BufferedCodeBuilder, TransformingCodeBuilder {\n-\n+public sealed interface TerminalCodeBuilder extends CodeBuilder, LabelContext\n+        permits DirectCodeBuilder, BufferedCodeBuilder {\n+    int curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeModel;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.TypeKind;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-\n-public final class TransformingCodeBuilder implements TerminalCodeBuilder {\n-\n-    final CodeBuilder delegate;\n-    final Consumer<CodeElement> consumer;\n-\n-    public TransformingCodeBuilder(CodeBuilder delegate, Consumer<CodeElement> consumer) {\n-        this.delegate = delegate;\n-        this.consumer = consumer;\n-    }\n-\n-    @Override\n-    public CodeBuilder with(CodeElement e) {\n-        consumer.accept(e);\n-        return this;\n-    }\n-\n-    @Override\n-    public Optional<CodeModel> original() {\n-        return delegate.original();\n-    }\n-\n-    @Override\n-    public Label newLabel() {\n-        return delegate.newLabel();\n-    }\n-\n-    @Override\n-    public Label startLabel() {\n-        return delegate.startLabel();\n-    }\n-\n-    @Override\n-    public Label endLabel() {\n-        return delegate.endLabel();\n-    }\n-\n-    @Override\n-    public int receiverSlot() {\n-        return delegate.receiverSlot();\n-    }\n-\n-    @Override\n-    public int parameterSlot(int paramNo) {\n-        return delegate.parameterSlot(paramNo);\n-    }\n-\n-    @Override\n-    public int allocateLocal(TypeKind typeKind) {\n-        return delegate.allocateLocal(typeKind);\n-    }\n-\n-    @Override\n-    public ConstantPoolBuilder constantPool() {\n-        return delegate.constantPool();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformingCodeBuilder.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -162,1 +162,1 @@\n-                (MemorySessionImpl)scope, action);\n+                (MemorySessionImpl)scope, readOnly, action);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,5 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n+    public static MemorySegment makeNativeSegmentUnchecked(long min,\n+                                                           long byteSize,\n+                                                           MemorySessionImpl sessionImpl,\n+                                                           boolean readOnly,\n+                                                           Runnable action) {\n@@ -67,1 +71,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+        return new NativeMemorySegmentImpl(min, byteSize, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -35,0 +36,2 @@\n+import sun.nio.cs.ISO_8859_1;\n+\n@@ -38,1 +41,13 @@\n-public final class DoubleToDecimal {\n+public final class DoubleToDecimal extends ToDecimal {\n+    \/**\n+     * Use LATIN1 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final DoubleToDecimal LATIN1 = new DoubleToDecimal(true);\n+\n+    \/**\n+     * Use UTF16 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final DoubleToDecimal UTF16  = new DoubleToDecimal(false);\n+\n@@ -94,10 +109,0 @@\n-    \/* Used for left-to-tight digit extraction *\/\n-    private static final int MASK_28 = (1 << 28) - 1;\n-\n-    private static final int NON_SPECIAL    = 0;\n-    private static final int PLUS_ZERO      = 1;\n-    private static final int MINUS_ZERO     = 2;\n-    private static final int PLUS_INF       = 3;\n-    private static final int MINUS_INF      = 4;\n-    private static final int NAN            = 5;\n-\n@@ -113,7 +118,2 @@\n-    private final byte[] bytes;\n-\n-    \/* Index into bytes of rightmost valid character *\/\n-    private int index;\n-\n-    private DoubleToDecimal(boolean noChars) {\n-        bytes = noChars ? null : new byte[MAX_CHARS];\n+    private DoubleToDecimal(boolean latin1) {\n+        super(latin1);\n@@ -131,1 +131,8 @@\n-        return new DoubleToDecimal(false).toDecimalString(v);\n+        byte[] str = new byte[MAX_CHARS];\n+        int pair = LATIN1.toDecimal(str, 0, v, null);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            int size = pair & 0xFF;\n+            return new String(str, 0, size, ISO_8859_1.INSTANCE);\n+        }\n+        return special(type);\n@@ -152,1 +159,2 @@\n-        new DoubleToDecimal(true).toDecimal(v, fd);\n+        byte[] str = new byte[MAX_CHARS];\n+        LATIN1.toDecimal(str, 0, v, fd);\n@@ -156,1 +164,1 @@\n-     * Appends the rendering of the {@code v} to {@code app}.\n+     * Appends the rendering of the {@code v} to {@code str}.\n@@ -160,1 +168,0 @@\n-     * {@link Appendable#append(CharSequence) appended} to {@code app}.\n@@ -162,2 +169,3 @@\n-     * @param v the {@code double} whose rendering is appended.\n-     * @param app the {@link Appendable} to append to.\n+     * @param str the String byte array to append to\n+     * @param index the index into str\n+     * @param v the {@code double} whose rendering is into str.\n@@ -166,4 +174,2 @@\n-    public static Appendable appendTo(double v, Appendable app)\n-            throws IOException {\n-        return new DoubleToDecimal(false).appendDecimalTo(v, app);\n-    }\n+    public int putDecimal(byte[] str, int index, double v) {\n+        assert 0 <= index && index <= length(str) - MAX_CHARS : \"Trusted caller missed bounds check\";\n@@ -171,34 +177,4 @@\n-    private String toDecimalString(double v) {\n-        return switch (toDecimal(v, null)) {\n-            case NON_SPECIAL -> charsToString();\n-            case PLUS_ZERO -> \"0.0\";\n-            case MINUS_ZERO -> \"-0.0\";\n-            case PLUS_INF -> \"Infinity\";\n-            case MINUS_INF -> \"-Infinity\";\n-            default -> \"NaN\";\n-        };\n-    }\n-\n-    private Appendable appendDecimalTo(double v, Appendable app)\n-            throws IOException {\n-        switch (toDecimal(v, null)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n+        int pair = toDecimal(str, index, v, null);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            return index + (pair & 0xFF);\n@@ -206,0 +182,1 @@\n+        return putSpecial(str, index, type);\n@@ -209,1 +186,1 @@\n-     * Returns\n+     * Returns size in the lower byte, type in the high byte, where type is\n@@ -215,0 +192,1 @@\n+     *     otherwise NON_SPECIAL\n@@ -216,1 +194,1 @@\n-    private int toDecimal(double v, FormattedFPDecimal fd) {\n+    private int toDecimal(byte[] str, int index, double v, FormattedFPDecimal fd) {\n@@ -230,1 +208,1 @@\n-            index = -1;\n+            int start = index;\n@@ -233,1 +211,1 @@\n-                 * fd != null implies bytes == null and bits >= 0\n+                 * fd != null implies str == null and bits >= 0\n@@ -236,1 +214,1 @@\n-                append('-');\n+                index = putChar(str, index, '-');\n@@ -246,1 +224,1 @@\n-                        return toChars(f, 0, fd);\n+                        return toChars(str, index, f, 0, fd) - start;\n@@ -249,1 +227,1 @@\n-                return toDecimal(-mq, c, 0, fd);\n+                return toDecimal(str, index, -mq, c, 0, fd) - start;\n@@ -253,3 +231,3 @@\n-                return t < C_TINY\n-                       ? toDecimal(Q_MIN, 10 * t, -1, fd)\n-                       : toDecimal(Q_MIN, t, 0, fd);\n+                return (t < C_TINY\n+                        ? toDecimal(str, index, Q_MIN, 10 * t, -1, fd)\n+                        : toDecimal(str, index, Q_MIN, t, 0, fd)) - start;\n@@ -265,1 +243,1 @@\n-    private int toDecimal(int q, long c, int dk, FormattedFPDecimal fd) {\n+    private int toDecimal(byte[] str, int index, int q, long c, int dk, FormattedFPDecimal fd) {\n@@ -330,1 +308,1 @@\n-                return toChars(upin ? sp10 : tp10, k, fd);\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n@@ -345,1 +323,1 @@\n-            return toChars(uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd);\n@@ -352,1 +330,1 @@\n-        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n@@ -371,1 +349,1 @@\n-    private int toChars(long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n@@ -384,1 +362,1 @@\n-            return NON_SPECIAL;\n+            return index;\n@@ -416,1 +394,1 @@\n-            return toChars1(h, m, l, e);\n+            return toChars1(str, index, h, m, l, e);\n@@ -419,1 +397,1 @@\n-            return toChars2(h, m, l, e);\n+            return toChars2(str, index, h, m, l, e);\n@@ -421,1 +399,1 @@\n-        return toChars3(h, m, l, e);\n+        return toChars3(str, index, h, m, l, e);\n@@ -424,1 +402,1 @@\n-    private int toChars1(int h, int m, int l, int e) {\n+    private int toChars1(byte[] str, int index, int h, int m, int l, int e) {\n@@ -430,1 +408,1 @@\n-        appendDigit(h);\n+        index = putDigit(str, index, h);\n@@ -436,1 +414,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -439,1 +417,1 @@\n-        append('.');\n+        index = putChar(str, index, '.');\n@@ -442,1 +420,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -445,2 +423,1 @@\n-        lowDigits(l);\n-        return NON_SPECIAL;\n+        return lowDigits(str, index, l);\n@@ -449,1 +426,1 @@\n-    private int toChars2(int h, int m, int l, int e) {\n+    private int toChars2(byte[] str, int index, int h, int m, int l, int e) {\n@@ -451,2 +428,2 @@\n-        appendDigit(0);\n-        append('.');\n+        index = putDigit(str, index, 0);\n+        index = putChar(str, index, '.');\n@@ -454,1 +431,1 @@\n-            appendDigit(0);\n+            index = putDigit(str, index, 0);\n@@ -456,4 +433,3 @@\n-        appendDigit(h);\n-        append8Digits(m);\n-        lowDigits(l);\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = put8Digits(str, index, m);\n+        return lowDigits(str, index, l);\n@@ -462,1 +438,1 @@\n-    private int toChars3(int h, int m, int l, int e) {\n+    private int toChars3(byte[] str, int index, int h, int m, int l, int e) {\n@@ -464,6 +440,5 @@\n-        appendDigit(h);\n-        append('.');\n-        append8Digits(m);\n-        lowDigits(l);\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = putChar(str, index, '.');\n+        index = put8Digits(str, index, m);\n+        index = lowDigits(str, index, l);\n+        return exponent(str, index, e - 1);\n@@ -472,1 +447,1 @@\n-    private void lowDigits(int l) {\n+    private int lowDigits(byte[] str, int index, int l) {\n@@ -474,1 +449,1 @@\n-            append8Digits(l);\n+            index = put8Digits(str, index, l);\n@@ -476,1 +451,1 @@\n-        removeTrailingZeroes();\n+        return removeTrailingZeroes(str, index);\n@@ -479,39 +454,2 @@\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n-        int y = y(m);\n-        for (int i = 0; i < 8; ++i) {\n-            int t = 10 * y;\n-            appendDigit(t >>> 28);\n-            y = t & MASK_28;\n-        }\n-    }\n-\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n-        }\n-    }\n-\n-    private int y(int a) {\n-        \/*\n-         * Algorithm 1 in [3] needs computation of\n-         *     floor((a + 1) 2^n \/ b^k) - 1\n-         * with a < 10^8, b = 10, k = 8, n = 28.\n-         * Noting that\n-         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n-         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n-         *\/\n-        return (int) (multiplyHigh(\n-                (long) (a + 1) << 28,\n-                193_428_131_138_340_668L) >>> 20) - 1;\n-    }\n-\n-    private void exponent(int e) {\n-        append('E');\n+    private int exponent(byte[] str, int index, int e) {\n+        index = putChar(str, index, 'E');\n@@ -519,1 +457,1 @@\n-            append('-');\n+            index = putChar(str, index, '-');\n@@ -523,2 +461,1 @@\n-            appendDigit(e);\n-            return;\n+            return putDigit(str, index, e);\n@@ -533,1 +470,1 @@\n-            appendDigit(d);\n+            index = putDigit(str, index, d);\n@@ -541,6 +478,2 @@\n-        appendDigit(d);\n-        appendDigit(e - 10 * d);\n-    }\n-\n-    private void append(int c) {\n-        bytes[++index] = (byte) c;\n+        index = putDigit(str, index, d);\n+        return putDigit(str, index, e - 10 * d);\n@@ -548,11 +481,0 @@\n-\n-    private void appendDigit(int d) {\n-        bytes[++index] = (byte) ('0' + d);\n-    }\n-\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n-    private String charsToString() {\n-        return new String(bytes, 0, 0, index + 1);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":89,"deletions":167,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -35,0 +36,2 @@\n+import sun.nio.cs.ISO_8859_1;\n+\n@@ -38,1 +41,13 @@\n-public final class FloatToDecimal {\n+public final class FloatToDecimal extends ToDecimal {\n+    \/**\n+     * Use LATIN1 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final FloatToDecimal LATIN1 = new FloatToDecimal(true);\n+\n+    \/**\n+     * Use UTF16 encoding to process the in-out byte[] str\n+     *\n+     *\/\n+    public static final FloatToDecimal UTF16  = new FloatToDecimal(false);\n+\n@@ -94,10 +109,0 @@\n-    \/* Used for left-to-tight digit extraction *\/\n-    private static final int MASK_28 = (1 << 28) - 1;\n-\n-    private static final int NON_SPECIAL    = 0;\n-    private static final int PLUS_ZERO      = 1;\n-    private static final int MINUS_ZERO     = 2;\n-    private static final int PLUS_INF       = 3;\n-    private static final int MINUS_INF      = 4;\n-    private static final int NAN            = 5;\n-\n@@ -113,6 +118,2 @@\n-    private final byte[] bytes = new byte[MAX_CHARS];\n-\n-    \/* Index into bytes of rightmost valid character *\/\n-    private int index;\n-\n-    private FloatToDecimal() {\n+    private FloatToDecimal(boolean latin1) {\n+        super(latin1);\n@@ -130,1 +131,8 @@\n-        return new FloatToDecimal().toDecimalString(v);\n+        byte[] str = new byte[MAX_CHARS];\n+        int pair = LATIN1.toDecimal(str, 0, v);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            int size = pair & 0xFF;\n+            return new String(str, 0, size, ISO_8859_1.INSTANCE);\n+        }\n+        return special(type);\n@@ -134,1 +142,1 @@\n-     * Appends the rendering of the {@code v} to {@code app}.\n+     * Appends the rendering of the {@code v} to {@code str}.\n@@ -137,2 +145,1 @@\n-     * {@link #toString(float) rendered} and the resulting string were then\n-     * {@link Appendable#append(CharSequence) appended} to {@code app}.\n+     * {@link #toString(double) rendered} and the resulting string were then\n@@ -140,2 +147,3 @@\n-     * @param v the {@code float} whose rendering is appended.\n-     * @param app the {@link Appendable} to append to.\n+     * @param str the String byte array to append to\n+     * @param index the index into str\n+     * @param v the {@code float} whose rendering is into str.\n@@ -144,4 +152,2 @@\n-    public static Appendable appendTo(float v, Appendable app)\n-            throws IOException {\n-        return new FloatToDecimal().appendDecimalTo(v, app);\n-    }\n+    public int putDecimal(byte[] str, int index, float v) {\n+        assert 0 <= index && index <= length(str) - MAX_CHARS : \"Trusted caller missed bounds check\";\n@@ -149,34 +155,4 @@\n-    private String toDecimalString(float v) {\n-        return switch (toDecimal(v)) {\n-            case NON_SPECIAL -> charsToString();\n-            case PLUS_ZERO -> \"0.0\";\n-            case MINUS_ZERO -> \"-0.0\";\n-            case PLUS_INF -> \"Infinity\";\n-            case MINUS_INF -> \"-Infinity\";\n-            default -> \"NaN\";\n-        };\n-    }\n-\n-    private Appendable appendDecimalTo(float v, Appendable app)\n-            throws IOException {\n-        switch (toDecimal(v)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n+        int pair = toDecimal(str, index, v);\n+        int type = pair & 0xFF00;\n+        if (type == NON_SPECIAL) {\n+            return index + (pair & 0xFF);\n@@ -184,0 +160,1 @@\n+        return putSpecial(str, index, type);\n@@ -188,0 +165,2 @@\n+     *     Combine type and size, the first byte is size, the second byte is type\n+     *\n@@ -194,1 +173,1 @@\n-    private int toDecimal(float v) {\n+    private int toDecimal(byte[] str, int index, float v) {\n@@ -208,1 +187,1 @@\n-            index = -1;\n+            int start = index;\n@@ -210,1 +189,1 @@\n-                append('-');\n+                index = putChar(str, index, '-');\n@@ -220,1 +199,1 @@\n-                        return toChars(f, 0);\n+                        return toChars(str, index, f, 0) - start;\n@@ -223,1 +202,1 @@\n-                return toDecimal(-mq, c, 0);\n+                return toDecimal(str, index, -mq, c, 0) - start;\n@@ -227,3 +206,3 @@\n-                return t < C_TINY\n-                       ? toDecimal(Q_MIN, 10 * t, -1)\n-                       : toDecimal(Q_MIN, t, 0);\n+                return (t < C_TINY\n+                        ? toDecimal(str, index, Q_MIN, 10 * t, -1)\n+                        : toDecimal(str, index, Q_MIN, t, 0)) - start;\n@@ -239,1 +218,1 @@\n-    private int toDecimal(int q, int c, int dk) {\n+    private int toDecimal(byte[] str, int index, int q, int c, int dk) {\n@@ -303,1 +282,1 @@\n-                return toChars(upin ? sp10 : tp10, k);\n+                return toChars(str, index, upin ? sp10 : tp10, k);\n@@ -318,1 +297,1 @@\n-            return toChars(uin ? s : t, k + dk);\n+            return toChars(str, index, uin ? s : t, k + dk);\n@@ -325,1 +304,1 @@\n-        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n@@ -341,1 +320,1 @@\n-    private int toChars(int f, int e) {\n+    private int toChars(byte[] str, int index, int f, int e) {\n@@ -376,1 +355,1 @@\n-            return toChars1(h, l, e);\n+            return toChars1(str, index, h, l, e);\n@@ -379,1 +358,1 @@\n-            return toChars2(h, l, e);\n+            return toChars2(str, index, h, l, e);\n@@ -381,1 +360,1 @@\n-        return toChars3(h, l, e);\n+        return toChars3(str, index, h, l, e);\n@@ -384,1 +363,1 @@\n-    private int toChars1(int h, int l, int e) {\n+    private int toChars1(byte[] str, int index, int h, int l, int e) {\n@@ -390,1 +369,1 @@\n-        appendDigit(h);\n+        index = putDigit(str, index, h);\n@@ -396,1 +375,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -399,1 +378,1 @@\n-        append('.');\n+        index = putChar(str, index, '.');\n@@ -402,1 +381,1 @@\n-            appendDigit(t >>> 28);\n+            index = putDigit(str, index, t >>> 28);\n@@ -405,2 +384,1 @@\n-        removeTrailingZeroes();\n-        return NON_SPECIAL;\n+        return removeTrailingZeroes(str, index);\n@@ -409,1 +387,1 @@\n-    private int toChars2(int h, int l, int e) {\n+    private int toChars2(byte[] str, int index, int h, int l, int e) {\n@@ -411,2 +389,2 @@\n-        appendDigit(0);\n-        append('.');\n+        index = putDigit(str, index, 0);\n+        index = putChar(str, index, '.');\n@@ -414,1 +392,1 @@\n-          appendDigit(0);\n+            index = putDigit(str, index, 0);\n@@ -416,4 +394,3 @@\n-        appendDigit(h);\n-        append8Digits(l);\n-        removeTrailingZeroes();\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = put8Digits(str, index, l);\n+        return removeTrailingZeroes(str, index);\n@@ -422,1 +399,1 @@\n-    private int toChars3(int h, int l, int e) {\n+    private int toChars3(byte[] str, int index, int h, int l, int e) {\n@@ -424,6 +401,5 @@\n-        appendDigit(h);\n-        append('.');\n-        append8Digits(l);\n-        removeTrailingZeroes();\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n+        index = putDigit(str, index, h);\n+        index = putChar(str, index, '.');\n+        index = put8Digits(str, index, l);\n+        index = removeTrailingZeroes(str, index);\n+        return exponent(str, index, e - 1);\n@@ -432,39 +408,2 @@\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n-        int y = y(m);\n-        for (int i = 0; i < 8; ++i) {\n-            int t = 10 * y;\n-            appendDigit(t >>> 28);\n-            y = t & MASK_28;\n-        }\n-    }\n-\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n-        }\n-    }\n-\n-    private int y(int a) {\n-        \/*\n-         * Algorithm 1 in [3] needs computation of\n-         *     floor((a + 1) 2^n \/ b^k) - 1\n-         * with a < 10^8, b = 10, k = 8, n = 28.\n-         * Noting that\n-         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n-         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n-         *\/\n-        return (int) (multiplyHigh(\n-                (long) (a + 1) << 28,\n-                193_428_131_138_340_668L) >>> 20) - 1;\n-    }\n-\n-    private void exponent(int e) {\n-        append('E');\n+    private int exponent(byte[] str, int index, int e) {\n+        index = putChar(str, index, 'E');\n@@ -472,1 +411,1 @@\n-            append('-');\n+            index = putChar(str, index, '-');\n@@ -476,2 +415,1 @@\n-            appendDigit(e);\n-            return;\n+            return putDigit(str, index, e);\n@@ -484,6 +422,2 @@\n-        appendDigit(d);\n-        appendDigit(e - 10 * d);\n-    }\n-\n-    private void append(int c) {\n-        bytes[++index] = (byte) c;\n+        index = putDigit(str, index, d);\n+        return putDigit(str, index, e - 10 * d);\n@@ -491,11 +425,0 @@\n-\n-    private void appendDigit(int d) {\n-        bytes[++index] = (byte) ('0' + d);\n-    }\n-\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n-    private String charsToString() {\n-        return new String(bytes, 0, 0, index + 1);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":82,"deletions":159,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import static java.lang.Math.multiplyHigh;\n+\n+abstract sealed class ToDecimal permits DoubleToDecimal, FloatToDecimal {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/* Used for left-to-tight digit extraction *\/\n+    static final int MASK_28 = (1 << 28) - 1;\n+\n+    static final int NON_SPECIAL = 0 << 8;\n+    static final int PLUS_ZERO   = 1 << 8;\n+    static final int MINUS_ZERO  = 2 << 8;\n+    static final int PLUS_INF    = 3 << 8;\n+    static final int MINUS_INF   = 4 << 8;\n+    static final int NAN         = 5 << 8;\n+\n+    \/**\n+     * The identifier of the encoding used to encode the bytes. If latin1 is true, the encoding is LATIN1, false is UTF16\n+     *\n+     *\/\n+    private final boolean latin1;\n+\n+    ToDecimal(boolean latin1) {\n+        this.latin1 = latin1;\n+    }\n+\n+    final int putChar(byte[] str, int index, int c) {\n+        if (latin1) {\n+            str[index] = (byte) c;\n+        } else {\n+            JLA.putCharUTF16(str, index, (char) c);\n+        }\n+        return index + 1;\n+    }\n+\n+    final int putDigit(byte[] str, int index, int d) {\n+        return putChar(str, index, (byte) ('0' + d));\n+    }\n+\n+    final int put8Digits(byte[] str, int index, int m) {\n+        \/*\n+         * Left-to-right digits extraction:\n+         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n+         *\/\n+        if (latin1) {\n+            put8DigitsLatin1(str, index, m);\n+        } else {\n+            put8DigitsUTF16 (str, index, m);\n+        }\n+        return index + 8;\n+    }\n+\n+    private static void put8DigitsLatin1(byte[] str, int index, int m) {\n+        int y = y(m);\n+        for (int i = 0; i < 8; ++i) {\n+            int t = 10 * y;\n+            str[index + i] = (byte) ('0' + (t >>> 28));\n+            y = t & MASK_28;\n+        }\n+    }\n+\n+    private static void put8DigitsUTF16(byte[] str, int index, int m) {\n+        int y = y(m);\n+        for (int i = 0; i < 8; ++i) {\n+            int t = 10 * y;\n+            JLA.putCharUTF16(str, index + i, '0' + (t >>> 28));\n+            y = t & MASK_28;\n+        }\n+    }\n+\n+    static int y(int a) {\n+        \/*\n+         * Algorithm 1 in [3] needs computation of\n+         *     floor((a + 1) 2^n \/ b^k) - 1\n+         * with a < 10^8, b = 10, k = 8, n = 28.\n+         * Noting that\n+         *     (a + 1) 2^n <= 10^8 2^28 < 10^17\n+         * For n = 17, m = 8 the table in section 10 of [1] leads to:\n+         *\/\n+        return (int) (multiplyHigh(\n+                (long) (a + 1) << 28,\n+                193_428_131_138_340_668L) >>> 20) - 1;\n+    }\n+\n+    final int removeTrailingZeroes(byte[] str, int index) {\n+        if (latin1) {\n+            while (str[index - 1] == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (str[index - 1] == '.') {\n+                ++index;\n+            }\n+        } else {\n+            while (JLA.getUTF16Char(str, index - 1) == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (JLA.getUTF16Char(str, index - 1) == '.') {\n+                ++index;\n+            }\n+        }\n+        return index;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    final int putSpecial(byte[] str, int index, int type) {\n+        String s = special(type);\n+        int length = s.length();\n+        if (latin1) {\n+            s.getBytes(0, length, str, index);\n+        } else {\n+            for (int i = 0; i < length; ++i) {\n+                putChar(str, index + i, s.charAt(i));\n+            }\n+        }\n+        return index + length;\n+    }\n+\n+    final int length(byte[] str) {\n+        return str.length >> (latin1 ? 0 : 1);\n+    }\n+\n+    static String special(int type) {\n+        return switch (type) {\n+            case PLUS_ZERO  -> \"0.0\";\n+            case MINUS_ZERO -> \"-0.0\";\n+            case PLUS_INF   -> \"Infinity\";\n+            case MINUS_INF  -> \"-Infinity\";\n+            default         -> \"NaN\";\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/ToDecimal.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -156,1 +156,1 @@\n-        return cc.transform(cm, ClassTransform.endHandler(clb -> {\n+        return cc.transformClass(cm, ClassTransform.endHandler(clb -> {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoExtender.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,17 @@\n+    \/**\n+     * Determines whether or not the underlying system\n+     * has useful metrics (a.k.a. is containerized).\n+     *\n+     * @implNote\n+     * Note that Metrics on some systems aren't useful.\n+     * For example on a regular Linux system with cgroups\n+     * present, with no limits enforced and not running in\n+     * a container, Metric aren't useful. This can be used\n+     * in order to determine if the system is containerized.\n+     *\n+     * @return true when the JVM runs in containerized mode.\n+     *         false otherwise.\n+     *\n+     *\/\n+    public boolean isContainerized();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -373,0 +373,4 @@\n+        if (!c.isContainerized()) {\n+            ostream.println(INDENT + \"System not containerized.\");\n+            return;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,3 @@\n+            if (expected > count) {\n+                throw new IOException(\"Premature EOF\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MeteredStream.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1948,0 +1948,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,6 @@\n-        implRegister(fdVal);\n+        try {\n+            implRegister(fdVal);\n+        } catch (Throwable t) {\n+            map.remove(fdVal);\n+            throw t;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -657,0 +657,3 @@\n+        \/\/ wait for any accept operation to complete before trying to close\n+        acceptLock.lock();\n+        acceptLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1219,0 +1219,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    private final int blockSize;\n+    protected final int blockSize;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DigestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n@@ -33,2 +36,0 @@\n-import static sun.security.provider.ByteArrayAccess.b2lLittle;\n-import static sun.security.provider.ByteArrayAccess.l2bLittle;\n@@ -51,1 +52,1 @@\n-    private static final int DM = 5; \/\/ dimension of lanes\n+    private static final int DM = 5; \/\/ dimension of state matrix\n@@ -68,2 +69,5 @@\n-    private byte[] state = new byte[WIDTH];\n-    private long[] lanes = new long[DM*DM];\n+    private long[] state = new long[DM*DM];\n+\n+    static final VarHandle asLittleEndian\n+            = MethodHandles.byteArrayViewVarHandle(long[].class,\n+            ByteOrder.LITTLE_ENDIAN).withInvokeExactBehavior();\n@@ -94,4 +98,6 @@\n-       for (int i = 0; i < buffer.length; i++) {\n-           state[i] ^= b[ofs++];\n-       }\n-       keccak();\n+        for (int i = 0; i < blockSize \/ 8; i++) {\n+            state[i] ^= (long) asLittleEndian.get(b, ofs);\n+            ofs += 8;\n+        }\n+\n+        keccak();\n@@ -105,0 +111,1 @@\n+        byte[] byteState = new byte[8];\n@@ -106,1 +113,1 @@\n-            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % buffer.length));\n+            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % blockSize));\n@@ -111,1 +118,1 @@\n-        int availableBytes = buffer.length;\n+        int availableBytes = blockSize; \/\/ i.e. buffer.length\n@@ -114,1 +121,4 @@\n-            System.arraycopy(state, 0, out, ofs, availableBytes);\n+            for (int i = 0; i < availableBytes \/ 8 ; i++) {\n+                asLittleEndian.set(out, ofs, state[i]);\n+                ofs += 8;\n+            }\n@@ -116,1 +126,0 @@\n-            ofs += availableBytes;\n@@ -119,1 +128,13 @@\n-        System.arraycopy(state, 0, out, ofs, numBytes);\n+        int numLongs = (numBytes + 7) \/ 8;\n+\n+        for (int i = 0; i < numLongs - 1; i++) {\n+            asLittleEndian.set(out, ofs, state[i]);\n+            ofs += 8;\n+        }\n+        if (numBytes == numLongs * 8) {\n+            asLittleEndian.set(out, ofs, state[numLongs - 1]);\n+        } else {\n+            asLittleEndian.set(byteState, 0, state[numLongs - 1]);\n+            System.arraycopy(byteState, 0,\n+                    out, ofs, numBytes - (numLongs - 1) * 8);\n+        }\n@@ -126,2 +147,1 @@\n-        Arrays.fill(state, (byte)0);\n-        Arrays.fill(lanes, 0L);\n+        Arrays.fill(state, 0L);\n@@ -147,24 +167,0 @@\n-    \/**\n-     * Utility function for transforming the specified byte array 's'\n-     * into array of lanes 'm' as defined in section 3.1.2.\n-     *\/\n-    private static void bytes2Lanes(byte[] s, long[] m) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            b2lLittle(s, sOfs, m, DM*y, 40);\n-        }\n-    }\n-\n-    \/**\n-     * Utility function for transforming the specified array of\n-     * lanes 'm' into a byte array 's' as defined in section 3.1.3.\n-     *\/\n-    private static void lanes2Bytes(long[] m, byte[] s) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            l2bLittle(m, DM*y, s, sOfs, 40);\n-        }\n-    }\n-\n@@ -176,3 +172,0 @@\n-        \/\/ convert the 200-byte state into 25 lanes\n-        bytes2Lanes(state, lanes);\n-\n@@ -182,5 +175,5 @@\n-        a0 = lanes[0]; a1 = lanes[1]; a2 = lanes[2]; a3 = lanes[3]; a4 = lanes[4];\n-        a5 = lanes[5]; a6 = lanes[6]; a7 = lanes[7]; a8 = lanes[8]; a9 = lanes[9];\n-        a10 = lanes[10]; a11 = lanes[11]; a12 = lanes[12]; a13 = lanes[13]; a14 = lanes[14];\n-        a15 = lanes[15]; a16 = lanes[16]; a17 = lanes[17]; a18 = lanes[18]; a19 = lanes[19];\n-        a20 = lanes[20]; a21 = lanes[21]; a22 = lanes[22]; a23 = lanes[23]; a24 = lanes[24];\n+        a0 = state[0]; a1 = state[1]; a2 = state[2]; a3 = state[3]; a4 = state[4];\n+        a5 = state[5]; a6 = state[6]; a7 = state[7]; a8 = state[8]; a9 = state[9];\n+        a10 = state[10]; a11 = state[11]; a12 = state[12]; a13 = state[13]; a14 = state[14];\n+        a15 = state[15]; a16 = state[16]; a17 = state[17]; a18 = state[18]; a19 = state[19];\n+        a20 = state[20]; a21 = state[21]; a22 = state[22]; a23 = state[23]; a24 = state[24];\n@@ -290,8 +283,5 @@\n-        lanes[0] = a0; lanes[1] = a1; lanes[2] = a2; lanes[3] = a3; lanes[4] = a4;\n-        lanes[5] = a5; lanes[6] = a6; lanes[7] = a7; lanes[8] = a8; lanes[9] = a9;\n-        lanes[10] = a10; lanes[11] = a11; lanes[12] = a12; lanes[13] = a13; lanes[14] = a14;\n-        lanes[15] = a15; lanes[16] = a16; lanes[17] = a17; lanes[18] = a18; lanes[19] = a19;\n-        lanes[20] = a20; lanes[21] = a21; lanes[22] = a22; lanes[23] = a23; lanes[24] = a24;\n-\n-        \/\/ convert the resulting 25 lanes back into 200-byte state\n-        lanes2Bytes(lanes, state);\n+        state[0] = a0; state[1] = a1; state[2] = a2; state[3] = a3; state[4] = a4;\n+        state[5] = a5; state[6] = a6; state[7] = a7; state[8] = a8; state[9] = a9;\n+        state[10] = a10; state[11] = a11; state[12] = a12; state[13] = a13; state[14] = a14;\n+        state[15] = a15; state[16] = a16; state[17] = a17; state[18] = a18; state[19] = a19;\n+        state[20] = a20; state[21] = a21; state[22] = a22; state[23] = a23; state[24] = a24;\n@@ -303,1 +293,0 @@\n-        copy.lanes = new long[DM*DM];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":47,"deletions":58,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,2 +171,2 @@\n-                int remains = (limit - offset) + (count - position);\n-                int fragLen = Math.min(fragLimit, remains);\n+                int remains = (limit - offset);\n+                int fragLen = Math.min(fragLimit - count + position, remains);\n@@ -176,1 +176,1 @@\n-                if (remains < fragLimit) {\n+                if (remains < fragLen) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketOutputRecord.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    protected int multByInt(long[] a, long b) {\n+    protected void multByInt(long[] a, long b) {\n@@ -98,1 +98,0 @@\n-        return 0;\n@@ -107,1 +106,1 @@\n-    protected abstract int mult(long[] a, long[] b, long[] r);\n+    protected abstract void mult(long[] a, long[] b, long[] r);\n@@ -115,1 +114,1 @@\n-    protected abstract int square(long[] a, long[] r);\n+    protected abstract void square(long[] a, long[] r);\n@@ -625,2 +624,2 @@\n-            int numAdds = mult(limbs, b.limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            mult(limbs, b.limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -638,2 +637,2 @@\n-            int numAdds = IntegerPolynomial.this.square(limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            IntegerPolynomial.this.square(limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -754,1 +753,2 @@\n-            numAdds = mult(limbs, b.limbs, limbs);\n+            mult(limbs, b.limbs, limbs);\n+            numAdds = 0;\n@@ -767,1 +767,2 @@\n-            numAdds += multByInt(limbs, value);\n+            multByInt(limbs, value);\n+            numAdds = 0;\n@@ -827,1 +828,2 @@\n-            numAdds = IntegerPolynomial.this.square(limbs, limbs);\n+            IntegerPolynomial.this.square(limbs, limbs);\n+            numAdds = 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -76,1 +76,0 @@\n-        return 0;\n@@ -103,1 +102,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -126,1 +125,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -139,1 +139,0 @@\n-        return 0;\n@@ -192,1 +191,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -203,1 +202,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialModBinP.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -106,2 +107,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -117,18 +118,0 @@\n-    \/*\n-     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n-     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n-     * montgomery conversion followed by a montgomery multiplication, just use\n-     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n-     * Section 4 )\n-     *\n-     * Will return an unreduced value\n-     *\/\n-    @Override\n-    protected int multByInt(long[] a, long b) {\n-        assert (b < (1 << BITS_PER_LIMB));\n-        for (int i = 0; i < a.length; i++) {\n-            a[i] *= b;\n-        }\n-        return (int) (b - 1);\n-    }\n-\n@@ -166,2 +149,2 @@\n-    protected int square(long[] a, long[] r) {\n-        return mult(a, a, r);\n+    protected void square(long[] a, long[] r) {\n+        mult(a, a, r);\n@@ -170,0 +153,1 @@\n+\n@@ -177,0 +161,7 @@\n+    @Override\n+    protected void mult(long[] a, long[] b, long[] r) {\n+        multImpl(a, b, r);\n+        reducePositive(r);\n+    }\n+\n+    @ForceInline\n@@ -178,1 +169,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    private void multImpl(long[] a, long[] b, long[] r) {\n@@ -411,30 +402,10 @@\n-        c6 += d2 + dd1 + (c5 >>> BITS_PER_LIMB);\n-        c7 += d3 + dd2 + (c6 >>> BITS_PER_LIMB);\n-        c8 += d4 + dd3 + (c7 >>> BITS_PER_LIMB);\n-        c9 = dd4 + (c8 >>> BITS_PER_LIMB);\n-\n-        c5 &= LIMB_MASK;\n-        c6 &= LIMB_MASK;\n-        c7 &= LIMB_MASK;\n-        c8 &= LIMB_MASK;\n-\n-        \/\/ At this point, the result could overflow by one modulus.\n-        c0 = c5 - modulus[0];\n-        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB);\n-        c0 &= LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n-        c1 &= LIMB_MASK;\n-        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB);\n-        c2 &= LIMB_MASK;\n-        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB);\n-        c3 &= LIMB_MASK;\n-\n-        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n-\n-        r[0] = ((c5 & mask) | (c0 & ~mask));\n-        r[1] = ((c6 & mask) | (c1 & ~mask));\n-        r[2] = ((c7 & mask) | (c2 & ~mask));\n-        r[3] = ((c8 & mask) | (c3 & ~mask));\n-        r[4] = ((c9 & mask) | (c4 & ~mask));\n-\n-        return 0;\n+        c6 += d2 + dd1;\n+        c7 += d3 + dd2;\n+        c8 += d4 + dd3;\n+        c9 = dd4;\n+\n+        r[0] = c5;\n+        r[1] = c6;\n+        r[2] = c7;\n+        r[3] = c8;\n+        r[4] = c9;\n@@ -519,2 +490,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -559,0 +530,23 @@\n+\n+    \/\/ Used when limbs a could overflow by one modulus.\n+    @ForceInline\n+    protected void reducePositive(long[] a) {\n+        long aa0 = a[0];\n+        long aa1 = a[1] + (aa0>>BITS_PER_LIMB);\n+        long aa2 = a[2] + (aa1>>BITS_PER_LIMB);\n+        long aa3 = a[3] + (aa2>>BITS_PER_LIMB);\n+        long aa4 = a[4] + (aa3>>BITS_PER_LIMB);\n+\n+        long c0 = a[0] - modulus[0];\n+        long c1 = a[1] - modulus[1] + (c0 >> BITS_PER_LIMB);\n+        long c2 = a[2] - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        long c3 = a[3] - modulus[3] + (c2 >> BITS_PER_LIMB);\n+        long c4 = a[4] - modulus[4] + (c3 >> BITS_PER_LIMB);\n+        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        a[0] = ((aa0 & mask) | (c0 & ~mask)) & LIMB_MASK;\n+        a[1] = ((aa1 & mask) | (c1 & ~mask)) & LIMB_MASK;\n+        a[2] = ((aa2 & mask) | (c2 & ~mask)) & LIMB_MASK;\n+        a[3] = ((aa3 & mask) | (c3 & ~mask)) & LIMB_MASK;\n+        a[4] = ((aa4 & mask) | (c4 & ~mask));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":49,"deletions":55,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,0 +290,1 @@\n+ZWG=ZWG\n@@ -515,0 +516,1 @@\n+zwg=Zimbabwe Gold\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/CurrencyNames.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-dataVersion=176\n+dataVersion=177\n@@ -59,2 +59,2 @@\n-    XPT962-XSU994-XTS963-XUA965-XXX999-YER886-YUM891-ZAR710-ZMK894-ZMW967-ZWD716-ZWL932-\\\n-    ZWN942-ZWR935\n+    XPT962-XSU994-XTS963-XUA965-XXX999-YER886-YUM891-ZAR710-ZMK894-ZMW967-ZWD716-ZWG924-\\\n+    ZWL932-ZWN942-ZWR935\n@@ -585,1 +585,1 @@\n-ZW=ZWL\n+ZW=ZWG\n","filename":"src\/java.base\/share\/data\/currency\/CurrencyData.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-File-Date: 2024-05-16\n+File-Date: 2024-06-14\n@@ -48012,0 +48012,1 @@\n+Deprecated: 2024-06-08\n@@ -48013,0 +48014,1 @@\n+Comments: Preferred tag is cls\n@@ -48388,0 +48390,1 @@\n+Deprecated: 2024-06-08\n@@ -48391,0 +48394,1 @@\n+Comments: Preferred tag is vsn\n","filename":"src\/java.base\/share\/data\/lsrdata\/language-subtag-registry.txt","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1713,1 +1713,1 @@\n-\\f[V]-XX:StartFlightRecording=\\f[R]\\f[I]parameter\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R]\n+\\f[V]-XX:StartFlightRecording:\\f[R]\\f[I]parameter\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R]\n@@ -1717,0 +1717,2 @@\n+\\f[V]-XX:StartFlightRecording:help\\f[R] prints available options and\n+example command lines.\n@@ -1763,0 +1765,2 @@\n+The filename may also be a directory in which case, the filename is\n+generated from the PID and the current date in the specified directory.\n@@ -1843,0 +1847,3 @@\n+.PP\n+To only see warnings and errors from JFR during startup set\n+-Xlog:jfr+startup=warning.\n","filename":"src\/java.base\/share\/man\/java.1","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -204,0 +204,3 @@\n+        \/\/ wait for any write operation to complete before trying to close\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+        \/\/ wait for any read operation to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+import sun.lwawt.LWKeyboardFocusManagerPeer;\n@@ -1059,0 +1060,5 @@\n+\n+        Window currFocus = LWKeyboardFocusManagerPeer.getInstance().getCurrentFocusedWindow();\n+        if (!blocked && (target == currFocus)) {\n+            requestWindowFocus();\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformWindow.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,3 @@\n+        \/**\n+         * @since 10\n+         *\/\n@@ -1181,0 +1184,3 @@\n+        \/**\n+         * @since 10\n+         *\/\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,2 @@\n+ *\n+ * @since 1.1\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,0 +186,2 @@\n+     *\n+     * @since 11\n@@ -208,0 +210,2 @@\n+     *\n+     * @since 11\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultComboBoxModel.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -533,0 +533,2 @@\n+     *\n+     * @since 11\n@@ -555,0 +557,2 @@\n+     *\n+     * @since 11\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultListModel.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1464,0 +1464,2 @@\n+         *\n+         * @since 16\n@@ -1564,0 +1566,2 @@\n+         *\n+         * @since 17\n@@ -1575,0 +1579,2 @@\n+         *\n+         * @since 17\n@@ -1593,0 +1599,2 @@\n+         *\n+         * @since 17\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSlider.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import javax.swing.plaf.basic.BasicSplitPaneUI;\n@@ -364,0 +365,11 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @param enabled {@inheritDoc}\n+     *\/\n+    @Override\n+    public void setEnabled(boolean enabled) {\n+        super.setEnabled(enabled);\n+        if (this.getUI() instanceof BasicSplitPaneUI) {\n+            ((BasicSplitPaneUI)(this.getUI())).getDivider().setEnabled(enabled);\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSplitPane.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+ *\n+ * @since 1.2\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+     *\n+     * @since 16\n+     * @deprecated This constructor was exposed erroneously and will be removed in a future release.\n+     *             Use {@link #BasicSliderUI(JSlider)} instead.\n@@ -154,0 +158,1 @@\n+    @Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSliderUI.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,0 +363,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @param enabled {@inheritDoc}\n+     *\/\n+    @Override\n+    public void setEnabled(boolean enabled) {\n+        if (splitPane.isOneTouchExpandable() &&\n+                rightButton != null &&\n+                leftButton != null) {\n+\n+            rightButton.setEnabled(enabled);\n+            leftButton.setEnabled(enabled);\n+        }\n+    }\n@@ -475,0 +489,1 @@\n+        b.setEnabled(splitPane.isEnabled());\n@@ -532,0 +547,1 @@\n+        b.setEnabled(splitPane.isEnabled());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -651,0 +651,2 @@\n+     *\n+     * @since 20\n@@ -660,0 +662,2 @@\n+     *\n+     * @since 20\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultEditorKit.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1320,7 +1320,0 @@\n-        \/\/ TAB\/SHIFT-TAB should transfer focus and ENTER should select an item.\n-        \/\/ We don't want them to navigate within the table\n-        ActionMap am = SwingUtilities.getUIActionMap(detailsTable);\n-        am.remove(\"selectNextRowCell\");\n-        am.remove(\"selectPreviousRowCell\");\n-        am.remove(\"selectNextColumnCell\");\n-        am.remove(\"selectPreviousColumnCell\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/FilePane.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -525,0 +525,1 @@\n+    jboolean doIt = JNI_FALSE;\n@@ -580,1 +581,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -608,1 +609,1 @@\n-        return JNI_FALSE;\n+        return doIt;\n@@ -622,1 +623,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -664,1 +665,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -673,1 +674,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -687,1 +688,1 @@\n-                        return JNI_FALSE;\n+                        return doIt;\n@@ -693,0 +694,1 @@\n+        doIt = JNI_TRUE;\n@@ -711,1 +713,1 @@\n-    return JNI_TRUE;\n+    return doIt;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Extends the {@code javax.naming} package to provide functionality\n+ * for accessing directory services.\n+ *\n+ * <p>\n+ * This package defines the directory operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * This package allows applications to retrieve and update attributes\n+ * associated with objects stored in a directory, and to search for\n+ * objects using specified attributes.\n+ *\n+ * <h2>The Directory Context<\/h2>\n+ *\n+ * The {@code DirContext}\n+ * interface represents a <em>directory context<\/em>.\n+ * It defines methods for examining and updating attributes associated with a\n+ * <em>directory object<\/em>, or <em>directory entry<\/em> as it is sometimes\n+ * called.\n+ * <p>\n+ * You use {@code getAttributes()} to retrieve the attributes\n+ * associated with a directory object (for which you supply the name).\n+ * Attributes are modified using {@code modifyAttributes()}.\n+ * You can add, replace, or remove attributes and\/or attribute values\n+ * using this operation.\n+ * <p>\n+ * {@code DirContext} also behaves as a naming context\n+ * by extending the {@code Context} interface in the {@code javax.naming} package.\n+ * This means that any directory object can also provide\n+ * a naming context.\n+ * For example, the directory object for a person might contain\n+ * the attributes of that person, and at the same time provide\n+ * a context for naming objects relative to that person\n+ * such as his printers and home directory.\n+ *\n+ * <h3>Searches<\/h3>\n+ * {@code DirContext} contains methods for\n+ * performing content-based searching of the directory.\n+ * In the simplest and most common form of usage, the application\n+ * specifies a set of attributes--possibly with specific\n+ * values--to match, and submits this attribute set, to the\n+ * {@code search()} method.\n+ * There are other overloaded forms of {@code search()}\n+ * that support more sophisticated <em>search filters<\/em>.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.directory;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/package-info.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Extends the <code>javax.naming<\/code> package to provide functionality\n-for accessing directory services.\n-\n-<p>\n-This package defines the directory operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-This package allows applications to retrieve and update attributes\n-associated with objects stored in a directory, and to search for\n-objects using specified attributes.\n-\n-<h2>The Directory Context<\/h2>\n-\n-The <code>DirContext<\/code>\n-interface represents a <em>directory context<\/em>.\n-It defines methods for examining and updating attributes associated with a\n-<em>directory object<\/em>, or <em>directory entry<\/em> as it is sometimes\n-called.\n-<p>\n-You use\t<code>getAttributes()<\/code> to retrieve the attributes\n-associated with a directory object (for which you supply the name).\n-Attributes are modified using <code>modifyAttributes()<\/code>.\n-You can add, replace, or remove attributes and\/or attribute values\n-using this operation.\n-<p>\n-<code>DirContext<\/code> also behaves as a naming context\n-by extending the <code>Context<\/code> interface in the <code>javax.naming<\/code> package.\n-This means that any directory object can also provide\n-a naming context. \n-For example, the directory object for a person might contain\n-the attributes of that person, and at the same time provide\n-a context for naming objects relative to that person\n-such as his printers and home directory.\n-\n-<h3>Searches<\/h3>\n-<code>DirContext<\/code> contains methods for\n-performing content-based searching of the directory.\n-In the simplest and most common form of usage, the application\n-specifies a set of attributes--possibly with specific\n-values--to match, and submits this attribute set, to the\n-<code>search()<\/code> method.\n-There are other overloaded forms of <code>search()<\/code>\n-that support more sophisticated <em>search filters<\/em>.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/package.html","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides support for event notification when accessing naming and\n+ * directory services.\n+ *\n+ * <p>\n+ * This package defines the event notification operations of the Java Naming\n+ * and Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <h2>Naming Events<\/h2>\n+ * <p>\n+ * This package defines a {@code NamingEvent} class to represent an event\n+ * that is generated by a naming\/directory service.\n+ * It also defines subinterfaces of {@code Context} and {@code DirContext},\n+ * called {@code EventContext} and {@code EventDirContext},\n+ * through which applications can register their interest in events\n+ * fired by the context.\n+ * <p>\n+ * {@code NamingEvent} represents an event that occurs in a\n+ * naming or directory service. There are two categories of naming events:\n+ * <ul>\n+ * <li>Those that affect the namespace (add\/remove\/rename an object)\n+ * <li>Those that affect the objects' contents.\n+ * <\/ul>\n+ * Each category of events is handled by a corresponding listener:\n+ * {@code NamespaceChangeListener}, {@code ObjectChangeListener}.\n+ * <p>\n+ * An application, for example, can register its interest in changes to\n+ * objects in a context as follows:\n+ * {@snippet :\n+ * EventContext src =\n+ *     (EventContext)(new InitialContext()).lookup(\"o=wiz,c=us\");\n+ * src.addNamingListener(\"ou=users\", EventContext.ONELEVEL_SCOPE,\n+ *     new ChangeHandler());\n+ * ...\n+ * class ChangeHandler implements ObjectChangeListener {\n+ *     public void objectChanged(NamingEvent evt) {\n+ *         System.out.println(evt.getNewBinding());\n+ *     }\n+ *     public void namingExceptionThrown(NamingExceptionEvent evt) {\n+ *         System.out.println(evt.getException());\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <a id=THREADING><\/a>\n+ * <h3>Threading Issues<\/h3>\n+ *\n+ * When an event is dispatched to a listener, the listener method (such\n+ * as {@code objectChanged()}) may be executed in a thread other than the\n+ * one in which the call to {@code addNamingListener()} was executed.\n+ * The choice of which thread to use is made by the service provider.\n+ * When an event is dispatched to multiple listeners, the service provider\n+ * may choose (and is generally encouraged) to execute the listener methods\n+ * concurrently in separate threads.\n+ * <p>\n+ * When a listener instance invokes {@code NamingEvent.getEventContext()},\n+ * it must take into account the possibility that other threads will be\n+ * working with that context concurrently. Likewise, when a listener is\n+ * registered via {@code addNamingListener()}, the registering thread\n+ * must take into account the likely possibility that the service provider\n+ * will later invoke the listeners in newly-created threads. As {@code Context}\n+ * instances are not guaranteed to be thread-safe in general, all context\n+ * operations must be synchronized as needed.\n+ *\n+ * <h3>Exception Handling<\/h3>\n+ *\n+ * When a listener registers for events with a context, the context might\n+ * need to do some internal processing in order to collect information\n+ * required to generate the events. The context, for example, might need\n+ * to make a request to the server to register interest in changes\n+ * on the server that will eventually be translated into events.\n+ * If an exception occurs that prevents information about the events from\n+ * being collected, the listener will never be notified of the events.\n+ * When such an exception occurs, a {@code NamingExceptionEvent} is\n+ * fired to notify the listener. The listener's\n+ * {@code namingExceptionThrown()} method is invoked, as shown in the\n+ * sample code above,\n+ * and the listener is automatically deregistered.\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.event;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/event\/package-info.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -1,125 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides support for event notification when accessing naming and\n-directory services.\n-\n-<p>\n-This package defines the event notification operations of the Java Naming\n-and Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<h2>Naming Events<\/h2>\n-<p>\n-This package defines a <code>NamingEvent<\/code> class to represent an event\n-that is generated by a naming\/directory service.\n-It also defines subinterfaces of <code>Context<\/code> and <code>DirContext<\/code>,\n-called <code>EventContext<\/code> and <code>EventDirContext<\/code>,\n-through which applications can register their interest in events\n-fired by the context.\n-<p>\n-<code>NamingEvent<\/code> represents an event that occurs in a \n-naming or directory service. There are two categories of naming events:\n-<ul>\n-<li>Those that affect the namespace (add\/remove\/rename an object)\n-<li>Those that affect the objects' contents.\n-<\/ul>\n-Each category of events is handled by a corresponding listener:\n-<code>NamespaceChangeListener<\/code>, <code>ObjectChangeListener<\/code>.\n-<p>\n-An application, for example, can register its interest in changes to\n-objects in a context as follows:\n-<blockquote>\n-<pre>\n-EventContext src = \n-    (EventContext)(new InitialContext()).lookup(\"o=wiz,c=us\");\n-src.addNamingListener(\"ou=users\", EventContext.ONELEVEL_SCOPE,\n-    new ChangeHandler());\n-...\n-class ChangeHandler implements ObjectChangeListener {\n-    public void objectChanged(NamingEvent evt) {\n-        System.out.println(evt.getNewBinding());\n-    }\n-    public void namingExceptionThrown(NamingExceptionEvent evt) {\n-        System.out.println(evt.getException());\n-    }\n-}\n-<\/pre>\n-<\/blockquote>\n-\n-<a id=THREADING><\/a>\n-<h3>Threading Issues<\/h3>\n-\n-When an event is dispatched to a listener, the listener method (such\n-as <code>objectChanged()<\/code>) may be executed in a thread other than the\n-one in which the call to <code>addNamingListener()<\/code> was executed.\n-The choice of which thread to use is made by the service provider.\n-When an event is dispatched to multiple listeners, the service provider\n-may choose (and is generally encouraged) to execute the listener methods\n-concurrently in separate threads.\n-<p>\n-When a listener instance invokes <code>NamingEvent.getEventContext()<\/code>,\n-it must take into account the possibility that other threads will be\n-working with that context concurrently.  Likewise, when a listener is\n-registered via <code>addNamingListener()<\/code>, the registering thread\n-must take into account the likely possibility that the service provider\n-will later invoke the listeners in newly-created threads.  As <code>Context<\/code>\n-instances are not guaranteed to be thread-safe in general, all context\n-operations must be synchronized as needed.\n-\n-<h3>Exception Handling<\/h3>\n-\n-When a listener registers for events with a context, the context might\n-need to do some internal processing in order to collect information\n-required to generate the events.  The context, for example, might need\n-to make a request to the server to register interest in changes\n-on the server that will eventually be translated into events.\n-If an exception occurs that prevents information about the events from\n-being collected, the listener will never be notified of the events.\n-When such an exception occurs, a <code>NamingExceptionEvent<\/code> is\n-fired to notify the listener. The listener's\n-<code>namingExceptionThrown()<\/code> method is invoked, as shown in the\n-sample code above,\n-and the listener is automatically deregistered.\n-\n-<h2>Package Specification<\/h2>\n-\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/event\/package.html","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides support for LDAPv3 extended operations and controls.\n+ *\n+ * <p>\n+ * This package extends the directory operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * This package is for applications and service providers that deal with\n+ * LDAPv3 extended operations and controls, as defined by\n+ * <a href=http:\/\/www.ietf.org\/rfc\/rfc2251.txt>RFC 2251<\/a>.\n+ * The core interface in this package is {@code LdapContext}, which defines\n+ * methods on a context for performing extended operations and handling\n+ * controls.\n+ *\n+ * <h2>Extended Operations<\/h2>\n+ * <p>\n+ * This package defines the interface {@code ExtendedRequest}\n+ * to represent the argument to an extended operation,\n+ * and the interface {@code ExtendedResponse} to represent the result\n+ * of the extended operation.\n+ * An extended response is always paired with an extended request\n+ * but not necessarily vice versa. That is, you can have an extended request\n+ * that has no corresponding extended response.\n+ * <p>\n+ * An application typically does not deal directly with these interfaces.\n+ * Instead, it deals with classes that <em>implement<\/em> these\n+ * interfaces.\n+ * The application gets these classes either as part of a\n+ * repertoire of extended operations standardized through the IETF, or\n+ * from directory vendors for vendor-specific extended operations.\n+ * The request classes should have constructors that accept\n+ * arguments in a type-safe and user-friendly manner, while the\n+ * response classes should have access methods for getting the data\n+ * of the response in a type-safe and user-friendly manner.\n+ * Internally, the request\/response classes deal with encoding and decoding\n+ * BER values.\n+ * <p>\n+ * For example, suppose an LDAP server supports a \"get time\" extended operation.\n+ * It would supply classes such as\n+ * {@code GetTimeRequest} and {@code GetTimeResponse},\n+ * so that applications can use this feature.\n+ * An application would use these classes as follows:\n+ * {@snippet :\n+ * GetTimeResponse resp =\n+ *     (GetTimeResponse) ectx.extendedOperation(new GetTimeRequest());\n+ * long time = resp.getTime();\n+ * }\n+ * <p>\n+ * The {@code GetTimeRequest} and {@code GetTimeResponse} classes might\n+ * be defined as follows:\n+ * {@snippet :\n+ * public class GetTimeRequest implements ExtendedRequest {\n+ *     \/\/ User-friendly constructor\n+ *     public GetTimeRequest() {\n+ *     };\n+ *\n+ *     \/\/ Methods used by service providers\n+ *     public String getID() {\n+ *         return GETTIME_REQ_OID;\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return null;  \/\/ no value needed for get time request\n+ *     }\n+ *     public ExtendedResponse createExtendedResponse(\n+ *         String id, byte[] berValue, int offset, int length) throws NamingException {\n+ *         return new GetTimeResponse(id, berValue, offset, length);\n+ *     }\n+ * }\n+ * public class GetTimeResponse implements ExtendedResponse {\n+ *     long time;\n+ *     \/\/ called by GetTimeRequest.createExtendedResponse()\n+ *     public GetTimeResponse(String id, byte[] berValue, int offset, int length)\n+ *         throws NamingException {\n+ *         \/\/ check validity of id\n+ *         long time =  ... \/\/ decode berValue to get time\n+ *     }\n+ *\n+ *     \/\/ Type-safe and User-friendly methods\n+ *     public java.util.Date getDate() { return new java.util.Date(time); }\n+ *     public long getTime() { return time; }\n+ *\n+ *     \/\/ Low level methods\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ berValue saved;\n+ *     }\n+ *     public String getID() {\n+ *         return GETTIME_RESP_OID;\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <h2>Controls<\/h2>\n+ *\n+ * This package defines the interface {@code Control} to represent an LDAPv3\n+ * control. It can be a control that is sent to an LDAP server\n+ * (<em>request control<\/em>) or a control returned by an LDAP server\n+ * (<em>response control<\/em>). Unlike extended requests and responses,\n+ * there is not necessarily any pairing between request controls and\n+ * response controls. You can send request controls and expect no\n+ * response controls back, or receive response controls without sending\n+ * any request controls.\n+ * <p>\n+ * An application typically does not deal directly with this interface.\n+ * Instead, it deals with classes that <em>implement<\/em> this interface.\n+ * The application gets control classes either as part of a repertoire of\n+ * controls standardized through the IETF, or from directory vendors for\n+ * vendor-specific controls. The request control classes should have\n+ * constructors that accept arguments in a type-safe and user-friendly\n+ * manner, while the response control classes should have access methods\n+ * for getting the data of the response in a type-safe and user-friendly\n+ * manner. Internally, the request\/response control classes deal with\n+ * encoding and decoding BER values.\n+ * <p>\n+ * For example, suppose an LDAP server supports a \"signed results\"\n+ * request control, which when sent with a request, asks the\n+ * server to digitally sign the results of an operation.\n+ * It would supply a class {@code SignedResultsControl} so that applications\n+ * can use this feature.\n+ * An application would use this class as follows:\n+ * {@snippet :\n+ * Control[] reqCtls = new Control[] {new SignedResultsControl(Control.CRITICAL)};\n+ * ectx.setRequestControls(reqCtls);\n+ * NamingEnumeration enum = ectx.search(...);\n+ * }\n+ * The {@code SignedResultsControl} class might be defined as follows:\n+ * {@snippet :\n+ * public class SignedResultsControl implements Control {\n+ *     \/\/ User-friendly constructor\n+ *     public SignedResultsControl(boolean criticality) {\n+ *  \/\/ assemble the components of the request control\n+ *     };\n+ *\n+ *     \/\/ Methods used by service providers\n+ *     public String getID() {\n+ *         return \/\/ control's object identifier\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ ASN.1 BER encoded control value\n+ *     }\n+ *     ...\n+ * }\n+ * }\n+ * <p>\n+ * When a service provider receives response controls, it uses\n+ * the {@code ControlFactory} class to produce specific classes\n+ * that implement the {@code Control} interface.\n+ * <p>\n+ * An LDAP server can send back response controls with an LDAP operation\n+ * and also with enumeration results, such as those returned\n+ * by a list or search operation.\n+ * The {@code LdapContext} provides a method ({@code getResponseControls()})\n+ * for getting the response controls sent with an LDAP operation,\n+ * while the {@code HasControls} interface is used to retrieve\n+ * response controls associated with enumeration results.\n+ * <p>\n+ * For example, suppose an LDAP server sends back a \"change ID\" control in response\n+ * to a successful modification. It would supply a class {@code ChangeIDControl}\n+ * so that the application can use this feature.\n+ * An application would perform an update, and then try to get the change ID.\n+ * {@snippet :\n+ * \/\/ Perform update\n+ * Context ctx = ectx.createSubsubcontext(\"cn=newobj\");\n+ *\n+ * \/\/ Get response controls\n+ * Control[] respCtls = ectx.getResponseControls();\n+ * if (respCtls != null) {\n+ *     \/\/ Find the one we want\n+ *     for (int i = 0; i < respCtls.length; i++) {\n+ *         if(respCtls[i] instanceof ChangeIDControl) {\n+ *      ChangeIDControl cctl = (ChangeIDControl)respCtls[i];\n+ *      System.out.println(cctl.getChangeID());\n+ *         }\n+ *     }\n+ * }\n+ * }\n+ * The vendor might supply the following {@code ChangeIDControl} and\n+ * {@code VendorXControlFactory} classes. The {@code VendorXControlFactory}\n+ * will be used by the service provider when the provider receives response\n+ * controls from the LDAP server.\n+ * {@snippet :\n+ * public class ChangeIDControl implements Control {\n+ *     long id;\n+ *\n+ *     \/\/ Constructor used by ControlFactory\n+ *     public ChangeIDControl(String OID, byte[] berVal) throws NamingException {\n+ *         \/\/ check validity of OID\n+ *         id = \/\/ extract change ID from berVal\n+ *     };\n+ *\n+ *     \/\/ Type-safe and User-friendly method\n+ *     public long getChangeID() {\n+ *         return id;\n+ *     }\n+ *\n+ *     \/\/ Low-level methods\n+ *     public String getID() {\n+ *         return CHANGEID_OID;\n+ *     }\n+ *     public byte[] getEncodedValue() {\n+ *         return \/\/ original berVal\n+ *     }\n+ *     ...\n+ * }\n+ * public class VendorXControlFactory extends ControlFactory {\n+ *     public VendorXControlFactory () {\n+ *     }\n+ *\n+ *     public Control getControlInstance(Control orig) throws NamingException {\n+ *         if (isOneOfMyControls(orig.getID())) {\n+ *      ...\n+ *\n+ *      \/\/ determine which of ours it is and call its constructor\n+ *      return (new ChangeIDControl(orig.getID(), orig.getEncodedValue()));\n+ *  }\n+ *         return null;  \/\/ not one of ours\n+ *     }\n+ * }\n+ * }\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.ldap;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/package-info.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -1,266 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n- \n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides support for LDAPv3 extended operations and controls.\n-\n-<p>\n-This package extends the directory operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-This package is for applications and service providers that deal with\n-LDAPv3 extended operations and controls, as defined by\n-<a href=http:\/\/www.ietf.org\/rfc\/rfc2251.txt>RFC 2251<\/a>.\n-The core interface in this package is <code>LdapContext<\/code>, which defines\n-methods on a context for performing extended operations and handling\n-controls.\n-\n-<h2>Extended Operations<\/h2>\n-<p>\n-This package defines the interface <code>ExtendedRequest<\/code>\n-to represent the argument to an extended operation,\n-and the interface <code>ExtendedResponse<\/code> to represent the result\n-of the extended operation.\n-An extended response is always paired with an extended request\n-but not necessarily vice versa. That is, you can have an extended request\n-that has no corresponding extended response.\n-<p>\n-An application typically does not deal directly with these interfaces.\n-Instead, it deals with classes that <em>implement<\/em> these\n-interfaces.  \n-The application gets these classes either as part of a\n-repertoire of extended operations standardized through the IETF, or\n-from directory vendors for vendor-specific extended operations.\n-The request classes should have constructors that accept\n-arguments in a type-safe and user-friendly manner, while the\n-response classes should have access methods for getting the data\n-of the response in a type-safe and user-friendly manner.\n-Internally, the request\/response classes deal with encoding and decoding\n-BER values.\n-<p>\n-For example, suppose an LDAP server supports a \"get time\" extended operation.\n-It would supply classes such as\n-<code>GetTimeRequest<\/code> and <code>GetTimeResponse<\/code>,\n-so that applications can use this feature.\n-An application would use these classes as follows:\n-<blockquote><pre>\n-GetTimeResponse resp =\n-    (GetTimeResponse) ectx.extendedOperation(new GetTimeRequest());\n-long time = resp.getTime();\n-<\/pre><\/blockquote>\n-<p>\n-The <code>GetTimeRequest<\/code> and <code>GetTimeResponse<\/code> classes might\n-be defined as follows:\n-<blockquote><pre>\n-public class GetTimeRequest implements ExtendedRequest {\n-    \/\/ User-friendly constructor \n-    public GetTimeRequest() {\n-    };\n-\n-    \/\/ Methods used by service providers\n-    public String getID() {\n-        return GETTIME_REQ_OID;\n-    }\n-    public byte[] getEncodedValue() {\n-        return null;  \/\/ no value needed for get time request\n-    }\n-    public ExtendedResponse createExtendedResponse(\n-        String id, byte[] berValue, int offset, int length) throws NamingException {\n-        return new GetTimeResponse(id, berValue, offset, length);\n-    }\n-}\n-public class GetTimeResponse() implements ExtendedResponse {\n-    long time;\n-    \/\/ called by GetTimeRequest.createExtendedResponse()\n-    public GetTimeResponse(String id, byte[] berValue, int offset, int length)\n-        throws NamingException {\n-        \/\/ check validity of id\n-        long time =  ... \/\/ decode berValue to get time\n-    }\n-\n-    \/\/ Type-safe and User-friendly methods\n-    public java.util.Date getDate() { return new java.util.Date(time); }\n-    public long getTime() { return time; }\n-\n-    \/\/ Low level methods\n-    public byte[] getEncodedValue() {\n-        return \/\/ berValue saved;\n-    }\n-    public String getID() {\n-        return GETTIME_RESP_OID;\n-    }\n-}\n-<\/pre><\/blockquote>\n-\n-<h2>Controls<\/h2>\n-\n-This package defines the interface <code>Control<\/code> to represent an LDAPv3\n-control. It can be a control that is sent to an LDAP server\n-(<em>request control<\/em>) or a control returned by an LDAP server\n-(<em>response control<\/em>).  Unlike extended requests and responses,\n-there is not necessarily any pairing between request controls and\n-response controls.  You can send request controls and expect no\n-response controls back, or receive response controls without sending\n-any request controls.\n-<p>\n-An application typically does not deal directly with this interface.\n-Instead, it deals with classes that <em>implement<\/em> this interface.\n-The application gets control classes either as part of a repertoire of\n-controls standardized through the IETF, or from directory vendors for\n-vendor-specific controls.  The request control classes should have\n-constructors that accept arguments in a type-safe and user-friendly\n-manner, while the response control classes should have access methods\n-for getting the data of the response in a type-safe and user-friendly\n-manner.  Internally, the request\/response control classes deal with\n-encoding and decoding BER values.\n-<p>\n-For example, suppose an LDAP server supports a \"signed results\"\n-request control, which when sent with a request, asks the\n-server to digitally sign the results of an operation.\n-It would supply a class <code>SignedResultsControl<\/code>  so that applications\n-can use this feature.\n-An application  would use this class as follows:\n-<blockquote>\n-<pre>\n-Control[] reqCtls = new Control[] {new SignedResultsControl(Control.CRITICAL)};\n-ectx.setRequestControls(reqCtls);\n-NamingEnumeration enum = ectx.search(...);\n-<\/pre>\n-<\/blockquote>\n-The <code>SignedResultsControl<\/code> class might be defined as follows:\n-<blockquote><pre>\n-public class SignedResultsControl implements Control {\n-    \/\/ User-friendly constructor \n-    public SignedResultsControl(boolean criticality) {\n-\t\/\/ assemble the components of the request control\n-    };\n-\n-    \/\/ Methods used by service providers\n-    public String getID() {\n-        return \/\/ control's object identifier\n-    }\n-    public byte[] getEncodedValue() {\n-        return \/\/ ASN.1 BER encoded control value\n-    }\n-    ...\n-}\n-<\/pre><\/blockquote>\n-<p>\n-When a service provider receives response controls, it uses\n-the <code>ControlFactory<\/code> class to produce specific classes\n-that implement the <code>Control<\/code> interface.\n-<p>\n-An LDAP server can send back response controls with an LDAP operation\n-and also with enumeration results, such as those returned\n-by a list or search operation.\n-The <code>LdapContext<\/code> provides a method (<code>getResponseControls()<\/code>)\n-for getting the response controls sent with an LDAP operation,\n-while the <code>HasControls<\/code> interface is used to retrieve\n-response controls associated with enumeration results.\n-<p>\n-For example, suppose an LDAP server sends back a \"change ID\" control in response\n-to a successful modification. It would supply a class <code>ChangeIDControl<\/code>\n-so that the application can use this feature.\n-An application would perform an update, and then try to get the change ID.\n-<blockquote><pre>\n-\/\/ Perform update\n-Context ctx = ectx.createSubsubcontext(\"cn=newobj\");\n-\n-\/\/ Get response controls\n-Control[] respCtls = ectx.getResponseControls();\n-if (respCtls != null) {\n-    \/\/ Find the one we want\n-    for (int i = 0; i &lt; respCtls; i++) {\n-        if(respCtls[i] instanceof ChangeIDControl) {\n-\t    ChangeIDControl cctl = (ChangeIDControl)respCtls[i];\n-\t    System.out.println(cctl.getChangeID());\n-        }\n-    }\n-}\n-<\/pre><\/blockquote>\n-The vendor might supply the following <code>ChangeIDControl<\/code> and\n-<code>VendorXControlFactory<\/code> classes. The <code>VendorXControlFactory<\/code>\n-will be used by the service provider when the provider receives response\n-controls from the LDAP server.\n-<blockquote><pre>\n-public class ChangeIDControl implements Control {\n-    long id;\n-\n-    \/\/ Constructor used by ControlFactory\n-    public ChangeIDControl(String OID, byte[] berVal) throws NamingException {\n-        \/\/ check validity of OID\n-        id = \/\/ extract change ID from berVal\n-    };\n-\n-    \/\/ Type-safe and User-friendly method\n-    public long getChangeID() {\n-        return id;\n-    }\n-\n-    \/\/ Low-level methods\n-    public String getID() {\n-        return CHANGEID_OID;\n-    }\n-    public byte[] getEncodedValue() {\n-        return \/\/ original berVal\n-    }\n-    ...\n-}\n-public class VendorXControlFactory extends ControlFactory {\n-    public VendorXControlFactory () {\n-    }\n-\n-    public Control getControlInstance(Control orig) throws NamingException {\n-        if (isOneOfMyControls(orig.getID())) {\n-\t    ...\n-\n-\t    \/\/ determine which of ours it is and call its constructor\n-\t    return (new ChangeIDControl(orig.getID(), orig.getEncodedValue()));\n-\t}\n-        return null;  \/\/ not one of ours\n-    }\n-}\n-<\/pre><\/blockquote>\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/package.html","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *\n+ * Provides the Service Provider Interface for DNS lookups when\n+ * performing LDAP operations.\n+ *\n+ * @since 12\n+ *\/\n+package javax.naming.ldap.spi;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/spi\/package-info.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides the classes and interfaces for accessing naming services.\n+ *\n+ * <p>\n+ * This package defines the naming operations of the Java Naming and\n+ * Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ *\n+ * <h2>Context<\/h2>\n+ * <p>\n+ * This package defines the notion of a <em>context<\/em>, represented\n+ * by the {@code Context} interface.\n+ * A context consists of a set of name-to-object <em>bindings<\/em>.\n+ * {@code Context} is the core interface for looking up, binding, unbinding,\n+ * and renaming objects, and for creating and destroying subcontexts.\n+ * <p>\n+ * {@code lookup()} is the most commonly used operation.\n+ * You supply {@code lookup()}\n+ * the name of the object you want\n+ * to look up, and it returns the object bound to that name.\n+ * For example, the following code fragment looks up\n+ * a printer and sends a document to the printer object\n+ * to be printed:\n+ *\n+ * {@snippet :\n+ * Printer printer = (Printer)ctx.lookup(\"treekiller\");\n+ * printer.print(report);\n+ * }\n+ *\n+ * <h2>Names<\/h2>\n+ * <p>\n+ * Every naming method in the {@code Context}\n+ * interface has two\n+ * overloads: one that accepts a\n+ * {@code Name} argument and one that accepts a string name.\n+ * {@code Name} is an interface that represents a generic\n+ * name--an ordered sequence of zero of more components.\n+ * For these methods, {@code Name} can be used to represent a\n+ * <em>composite name<\/em> ({@code CompositeName})\n+ * so that you can name an object using a name which spans multiple namespaces.\n+ * <p>\n+ * The overloads that accept {@code Name}\n+ * are useful for applications that need to manipulate names: composing\n+ * them, comparing components, and so on.\n+ * The overloads that accept string names are likely to be more useful\n+ * for simple applications, such as those that simply read in a name\n+ * and look up the corresponding object.\n+ *\n+ * <h2>Bindings<\/h2>\n+ *\n+ * The {@code Binding} class represents a name-to-object binding.\n+ * It is a tuple containing the name of the bound object,\n+ * the name of the object's class, and the object itself.\n+ * <p>\n+ * The {@code Binding} class is actually a subclass of\n+ * {@code NameClassPair}, which consists\n+ * simply of the object's name and the object's class name.\n+ * The {@code NameClassPair} is useful when you only want\n+ * information about the object's class and do not want to\n+ * pay the extra cost of getting the object.\n+ *\n+ * <h2>References<\/h2>\n+ * Objects are stored in naming and directory services in different ways.\n+ * If an object store supports storing Java objects,\n+ * it might support storing an object in its serialized form.\n+ * However, some naming and directory services do not support the\n+ * storing of Java objects. Furthermore, for some\n+ * objects in the directory, Java programs are but one group of applications\n+ * that access them. In this case, a serialized Java object might\n+ * not be the most appropriate representation.\n+ * JNDI defines a <em>reference<\/em>, represented by the {@code Reference}\n+ * class, which contains information on how to construct a copy of the object.\n+ * JNDI will attempt to turn references looked up from the directory\n+ * into the Java objects they represent, so that\n+ * JNDI clients have the illusion that what\n+ * is stored in the directory are Java objects.\n+ *\n+ *\n+ * <h2>The Initial Context<\/h2>\n+ *\n+ * In JNDI, all naming and directory operations are performed relative\n+ * to a context. There are no absolute roots.\n+ * Therefore JNDI defines an <em>initial context<\/em>,\n+ * {@code InitialContext},\n+ * which provides a starting point for naming and directory operations.\n+ * Once you have an initial context, you can use it to\n+ * look up other contexts and objects.\n+ *\n+ * <h2>Exceptions<\/h2>\n+ *\n+ * JNDI defines a class hierarchy for exceptions that can be thrown in\n+ * the course of performing naming and directory operations. The root of\n+ * this class hierarchy is {@code NamingException}.\n+ * Programs interested in dealing with a particular exception\n+ * can catch the corresponding subclass of the exception.\n+ * Otherwise, programs should catch {@code NamingException}.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI API Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/package-info.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -1,143 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides the classes and interfaces for accessing naming services.\n-\n-<p>\n-This package defines the naming operations of the Java Naming and\n-Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-\n-<h2>Context<\/h2>\n-<p>\n-This package defines the notion of a <em>context<\/em>, represented\n-by the <code>Context<\/code> interface.\n-A context consists of a set of name-to-object <em>bindings<\/em>.\n-<code>Context<\/code> is the core interface for looking up, binding, unbinding,\n-and renaming objects, and for creating and destroying subcontexts.\n-<p>\n-<code>lookup()<\/code> is the most commonly used operation.\n-You supply <code>lookup()<\/code>\n-the name of the object you want\n-to look up, and it returns the object bound to that name.\n-For example, the following code fragment looks up \n-a printer and sends a document to the printer object\n-to be printed:\n-\n-<blockquote>\n-<pre>\n-Printer printer = (Printer)ctx.lookup(\"treekiller\");\n-printer.print(report);\n-<\/pre>\n-<\/blockquote>\n-\n-<h2>Names<\/h2>\n-<p>\n-Every naming method in the <code>Context<\/code>\n-interface has two\n-overloads: one that accepts a \n-<code>Name<\/code> argument and one that accepts a string name.\n-<code>Name<\/code> is an interface that represents a generic \n-name--an ordered sequence of zero of more components.\n-For these methods, <code>Name<\/code> can be used to represent a\n-<em>composite name<\/em> (<code>CompositeName<\/code>)\n-so that you can name an object using a name which spans multiple namespaces.\n-<p>\n-The overloads that accept <code>Name<\/code>\n-are useful for applications that need to manipulate names: composing\n-them, comparing components, and so on.\n-The overloads that accept string names are likely to be more useful\n-for simple applications, such as those that simply read in a name\n-and look up the corresponding object.\n-\n-<h2>Bindings<\/h2>\n-\n-The <code>Binding<\/code> class represents a name-to-object binding.\n-It is a tuple containing the name of the bound object,\n-the name of the object's class, and the object itself.\n-<p>\n-The <code>Binding<\/code> class is actually a subclass of\n-<code>NameClassPair<\/code>, which consists\n-simply of the object's name and the object's class name.\n-The <code>NameClassPair<\/code> is useful when you only want\n-information about the object's class and do not want to\n-pay the extra cost of getting the object.\n-\n-<h2>References<\/h2>\n-Objects are stored in naming and directory services in different ways.\n-If an object store supports storing Java objects, \n-it might support storing an object in its serialized form.\n-However, some naming and directory services do not support the\n-storing of Java objects. Furthermore, for some\n-objects in the directory, Java programs are but one group of applications \n-that access them. In this case, a serialized Java object might\n-not be the most appropriate representation.\n-JNDI defines a <em>reference<\/em>, represented by the <code>Reference<\/code>\n-class, which contains information on how to construct a copy of the object.\n-JNDI will attempt to turn references looked up from the directory\n-into the Java objects they represent, so that\n-JNDI clients have the illusion that what\n-is stored in the directory are Java objects. \n-\n-\n-<h2>The Initial Context<\/h2>\n-\n-In JNDI, all naming and directory operations are performed relative\n-to a context. There are no absolute roots.\n-Therefore JNDI defines an <em>initial context<\/em>, \n-<code>InitialContext<\/code>,\n-which provides a starting point for naming and directory operations.\n-Once you have an initial context, you can use it to\n-look up other contexts and objects.\n-\n-<h2>Exceptions<\/h2>\n-\n-JNDI defines a class hierarchy for exceptions that can be thrown in\n-the course of performing naming and directory operations.  The root of\n-this class hierarchy is <code>NamingException<\/code>.\n-Programs interested in dealing with a particular exception\n-can catch the corresponding subclass of the exception.\n-Otherwise, programs should catch <code>NamingException<\/code>.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI API Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/package.html","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides the means for dynamically plugging in support for accessing\n+ * naming and directory services through the {@code javax.naming}\n+ * and related packages.\n+ *\n+ * <p>\n+ * This package defines the service provider interface (SPI) of the Java Naming\n+ * and Directory Interface (JNDI). &nbsp;\n+ * JNDI provides naming and directory functionality to applications\n+ * written in the Java programming language. It is designed to be\n+ * independent of any specific naming or directory service\n+ * implementation. Thus a variety of services--new, emerging, and\n+ * already deployed ones--can be accessed in a common way.\n+ *\n+ * <p>\n+ * The JNDI SPI provides the means for creating JNDI service providers,\n+ * through which JNDI applications access different naming and\n+ * directory services.\n+ *\n+ *\n+ * <h2>Plug-in Architecture<\/h2>\n+ *\n+ * The service provider package allows different implementations to be plugged in\n+ * dynamically.\n+ * These different implementations include those for the\n+ * <em>initial context<\/em>,\n+ * and implementations for contexts that can be reached\n+ * from the initial context.\n+ *\n+ * <h2>Java Object Support<\/h2>\n+ *\n+ * The service provider package provides support\n+ * for implementors of the\n+ * {@code javax.naming.Context.lookup()}\n+ * method and related methods to return Java objects that are natural\n+ * and intuitive for the Java programmer.\n+ * For example, when looking up a printer name from the directory,\n+ * it is natural for you to expect to get\n+ * back a printer object on which to operate.\n+ *\n+ *\n+ * <h2>Multiple Naming Systems (Federation)<\/h2>\n+ *\n+ * JNDI operations allow applications to supply names that span multiple\n+ * naming systems. So in the process of completing\n+ * an operation, one service provider might need to interact\n+ * with another service provider, for example, to pass on\n+ * the operation to be continued in the next naming system.\n+ * The service provider package provides support for\n+ * different providers to cooperate to complete JNDI operations.\n+ *\n+ *\n+ * <h2>Package Specification<\/h2>\n+ *\n+ * The JNDI SPI Specification and related documents can be found in the\n+ * {@extLink jndi_overview JNDI documentation}.\n+ *\n+ * @since 1.3\n+ *\/\n+package javax.naming.spi;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/package-info.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2 Final\/\/EN\">\n-<html>\n-<head>\n-<!--\n-Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-\n-Provides the means for dynamically plugging in support for accessing\n-naming and directory services through the <code>javax.naming<\/code>\n-and related packages.\n-\n-<p>\n-This package defines the service provider interface (SPI) of the Java Naming\n-and Directory Interface (JNDI). &nbsp;\n-JNDI provides naming and directory functionality to applications\n-written in the Java programming language.  It is designed to be\n-independent of any specific naming or directory service\n-implementation.  Thus a variety of services--new, emerging, and\n-already deployed ones--can be accessed in a common way.\n-\n-<p>\n-The JNDI SPI provides the means for creating JNDI service providers,\n-through which JNDI applications access different naming and\n-directory services.\n-\n-\n-<h2>Plug-in Architecture<\/h2>\n-\n-The service provider package allows different implementations to be plugged in\n-dynamically.\n-These different implementations include those for the\n-<em>initial context<\/em>,\n-and implementations for contexts that can be reached \n-from the initial context.\n-\n-<h2>Java Object Support<\/h2>\n-\n-The service provider package provides support\n-for implementors of the\n-<code>javax.naming.Context.lookup()<\/code>\n-method and related methods to return Java objects that are natural\n-and intuitive for the Java programmer.\n-For example, when looking up a printer name from the directory,\n-it is natural for you to expect to get\n-back a printer object on which to operate.\n-\n-\n-<h2>Multiple Naming Systems (Federation)<\/h2>\n-\n-JNDI operations allow applications to supply names that span multiple\n-naming systems.  So in the process of completing\n-an operation, one service provider might need to interact\n-with another service provider, for example, to pass on\n-the operation to be continued in the next naming system.\n-The service provider package provides support for\n-different providers to cooperate to complete JNDI operations.\n-\n-\n-<h2>Package Specification<\/h2>\n-\n-The JNDI SPI Specification and related documents can be found in the\n-{@extLink jndi_overview JNDI documentation}.\n-\n-@since 1.3\n-\n-<\/body>\n-<\/html>\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/package.html","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -4678,3 +4678,0 @@\n-            if (pt.isErroneous()) {\n-                return types.createErrorType(site);\n-            }\n@@ -4789,0 +4786,4 @@\n+            if (pt.isErroneous()) {\n+                owntype = types.createErrorType(owntype);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-        UNLAMBDA(8),\n-        LOWER(9),\n+        LOWER(8),\n+        UNLAMBDA(9),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import com.sun.tools.javac.code.Symbol.TypeSymbol;\n@@ -48,1 +47,0 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -51,1 +49,0 @@\n-import com.sun.tools.javac.comp.Lower.BasicFreeVarCollector;\n@@ -53,1 +50,0 @@\n-import com.sun.tools.javac.jvm.*;\n@@ -56,1 +52,0 @@\n-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -75,1 +70,0 @@\n-import javax.lang.model.type.TypeKind;\n@@ -129,3 +123,0 @@\n-    \/** lambda proxy is a dynamic nestmate *\/\n-    private final boolean nestmateLambdas;\n-\n@@ -178,1 +169,0 @@\n-        nestmateLambdas = Target.instance(context).runtimeUseNestAccess();\n@@ -287,0 +277,1 @@\n+        cdef = analyzer.analyzeAndPreprocessClass((JCClassDecl) cdef);\n@@ -300,4 +291,0 @@\n-        if (tree.sym.owner.kind == PCK) {\n-            \/\/analyze class\n-            tree = analyzer.analyzeAndPreprocessClass(tree);\n-        }\n@@ -421,3 +408,1 @@\n-        if (localContext.methodReferenceReceiver != null) {\n-            syntheticInits.append(localContext.methodReferenceReceiver);\n-        } else if (!sym.isStatic()) {\n+        if (!sym.isStatic()) {\n@@ -436,5 +421,0 @@\n-        \/\/ add captured outer this instances (used only when `this' capture itself is illegal)\n-        for (Symbol fv : localContext.getSymbolMap(CAPTURED_OUTER_THIS).keySet()) {\n-            JCExpression captured_local = make.QualThis(fv.type);\n-            syntheticInits.append(captured_local);\n-        }\n@@ -556,48 +536,0 @@\n-    \/**\n-     * Translate qualified `this' references within a lambda to the mapped identifier\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitSelect(JCFieldAccess tree) {\n-        if (context == null || !analyzer.lambdaFieldAccessFilter(tree)) {\n-            super.visitSelect(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                JCTree ltree = lambdaContext.translate(tree);\n-                if (ltree != null) {\n-                    result = ltree;\n-                } else {\n-                    super.visitSelect(tree);\n-                }\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Translate instance creation expressions with implicit enclosing instances\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitNewClass(JCNewClass tree) {\n-        if (context == null || !analyzer.lambdaNewClassFilter(context, tree)) {\n-            super.visitNewClass(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                tree = lambdaContext.translate(tree);\n-                super.visitNewClass(tree);\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n@@ -728,1 +660,1 @@\n-        return deser;\n+        return lower.translateMethod(attrEnv, deser, make);\n@@ -860,30 +792,0 @@\n-    \/**\n-     * Set varargsElement field on a given tree (must be either a new class tree\n-     * or a method call tree)\n-     *\/\n-    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n-        if (varargsElement != null) {\n-            switch (tree.getTag()) {\n-                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n-                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n-                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n-                default: throw new AssertionError();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Convert method\/constructor arguments by inserting appropriate cast\n-     * as required by type-erasure - this is needed when bridging a lambda\/method\n-     * reference, as the bridged signature might require downcast to be compatible\n-     * with the generated signature.\n-     *\/\n-    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n-       Assert.check(meth.kind == MTH);\n-       List<Type> formals = types.erasure(meth.type).getParameterTypes();\n-       if (varargsElement != null) {\n-           Assert.check((meth.flags() & VARARGS) != 0);\n-       }\n-       return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n-    }\n-\n@@ -892,207 +794,0 @@\n-    \/**\n-     * Converts a method reference which cannot be used directly into a lambda\n-     *\/\n-    private class MemberReferenceToLambda {\n-\n-        private final JCMemberReference tree;\n-        private final ReferenceTranslationContext localContext;\n-        private final Symbol owner;\n-        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n-        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-\n-        private JCExpression receiverExpression = null;\n-\n-        MemberReferenceToLambda(JCMemberReference tree, ReferenceTranslationContext localContext, Symbol owner) {\n-            this.tree = tree;\n-            this.localContext = localContext;\n-            this.owner = owner;\n-        }\n-\n-        JCLambda lambda() {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                \/\/body generation - this can be either a method call or a\n-                \/\/new instance creation expression, depending on the member reference kind\n-                VarSymbol rcvr = addParametersReturnReceiver();\n-                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n-                        ? expressionInvoke(rcvr)\n-                        : expressionNew();\n-\n-                JCLambda slam = make.Lambda(params.toList(), expr);\n-                slam.target = tree.target;\n-                slam.type = tree.type;\n-                slam.pos = tree.pos;\n-                return slam;\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-\n-        \/**\n-         * Generate the parameter list for the converted member reference.\n-         *\n-         * @return The receiver variable symbol, if any\n-         *\/\n-        VarSymbol addParametersReturnReceiver() {\n-            Type samDesc = localContext.bridgedRefSig();\n-            List<Type> samPTypes = samDesc.getParameterTypes();\n-            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n-\n-            \/\/ Determine the receiver, if any\n-            VarSymbol rcvr;\n-            switch (tree.kind) {\n-                case BOUND:\n-                    \/\/ The receiver is explicit in the method reference\n-                    rcvr = addParameter(\"rec$\", tree.getQualifierExpression().type, false);\n-                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n-                    break;\n-                case UNBOUND:\n-                    \/\/ The receiver is the first parameter, extract it and\n-                    \/\/ adjust the SAM and unerased type lists accordingly\n-                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n-                    samPTypes = samPTypes.tail;\n-                    descPTypes = descPTypes.tail;\n-                    break;\n-                default:\n-                    rcvr = null;\n-                    break;\n-            }\n-            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n-            int implSize = implPTypes.size();\n-            int samSize = samPTypes.size();\n-            \/\/ Last parameter to copy from referenced method, exclude final var args\n-            int last = localContext.needsVarArgsConversion() ? implSize - 1 : implSize;\n-\n-            \/\/ Failsafe -- assure match-up\n-            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n-\n-            \/\/ Use parameter types of the implementation method unless the unerased\n-            \/\/ SAM parameter type is an intersection type, in that case use the\n-            \/\/ erased SAM parameter type so that the supertype relationship\n-            \/\/ the implementation method parameters is not obscured.\n-            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n-            \/\/ are used as pointers to the current parameter type information\n-            \/\/ and are thus not usable afterwards.\n-            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n-                \/\/ By default use the implementation method parameter type\n-                Type parmType = implPTypes.head;\n-                if (checkForIntersection) {\n-                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n-                        parmType = samPTypes.head;\n-                    }\n-                    \/\/ If the unerased parameter type is a type variable whose\n-                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n-                    \/\/ use the SAM parameter type\n-                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n-                        TypeVar tv = (TypeVar) descPTypes.head;\n-                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-                            parmType = samPTypes.head;\n-                        }\n-                    }\n-                }\n-                addParameter(\"x$\" + i, parmType, true);\n-\n-                \/\/ Advance to the next parameter\n-                implPTypes = implPTypes.tail;\n-                samPTypes = samPTypes.tail;\n-                descPTypes = descPTypes.tail;\n-            }\n-            \/\/ Flatten out the var args\n-            for (int i = last; i < samSize; ++i) {\n-                addParameter(\"xva$\" + i, tree.varargsElement, true);\n-            }\n-\n-            return rcvr;\n-        }\n-\n-        JCExpression getReceiverExpression() {\n-            return receiverExpression;\n-        }\n-\n-        private JCExpression makeReceiver(VarSymbol rcvr) {\n-            if (rcvr == null) return null;\n-            JCExpression rcvrExpr = make.Ident(rcvr);\n-            boolean protAccess =\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner);\n-            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n-                                                                : tree.expr.type;\n-            if (rcvrType == syms.arrayClass.type) {\n-                \/\/ Map the receiver type to the actually type, not just \"array\"\n-                rcvrType = tree.getQualifierExpression().type;\n-            }\n-            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n-                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n-            }\n-            return rcvrExpr;\n-        }\n-\n-        \/**\n-         * determine the receiver of the method call - the receiver can\n-         * be a type qualifier, the synthetic receiver parameter or 'super'.\n-         *\/\n-        private JCExpression expressionInvoke(VarSymbol rcvr) {\n-            JCExpression qualifier =\n-                    (rcvr != null) ?\n-                        makeReceiver(rcvr) :\n-                        tree.getQualifierExpression();\n-\n-            \/\/create the qualifier expression\n-            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n-            select.sym = tree.sym;\n-            select.type = tree.sym.erasure(types);\n-\n-            \/\/create the method call expression\n-            JCExpression apply = make.Apply(List.nil(), select,\n-                    convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n-                    setType(tree.sym.erasure(types).getReturnType());\n-\n-            apply = transTypes.coerce(attrEnv, apply,\n-                    types.erasure(localContext.tree.referentType.getReturnType()));\n-\n-            setVarargsIfNeeded(apply, tree.varargsElement);\n-            return apply;\n-        }\n-\n-        \/**\n-         * Lambda body to use for a 'new'.\n-         *\/\n-        private JCExpression expressionNew() {\n-            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n-                \/\/create the array creation expression\n-                JCNewArray newArr = make.NewArray(\n-                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n-                        List.of(make.Ident(params.first())),\n-                        null);\n-                newArr.type = tree.getQualifierExpression().type;\n-                return newArr;\n-            } else {\n-                \/\/create the instance creation expression\n-                \/\/note that method reference syntax does not allow an explicit\n-                \/\/enclosing class (so the enclosing class is null)\n-                \/\/ but this may need to be patched up later with the proxy for the outer this\n-                JCNewClass newClass = make.NewClass(null,\n-                        List.nil(),\n-                        make.Type(tree.getQualifierExpression().type),\n-                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n-                        null);\n-                newClass.constructor = tree.sym;\n-                newClass.constructorType = tree.sym.erasure(types);\n-                newClass.type = tree.getQualifierExpression().type;\n-                setVarargsIfNeeded(newClass, tree.varargsElement);\n-                return newClass;\n-            }\n-        }\n-\n-        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n-            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n-            vsym.pos = tree.pos;\n-            params.append(make.VarDef(vsym, null));\n-            if (genArg) {\n-                args.append(make.Ident(vsym));\n-            }\n-            return vsym;\n-        }\n-    }\n-\n@@ -1241,5 +936,0 @@\n-        \/**\n-         * List of types undergoing construction, i.e., in an early construction context.\n-         *\/\n-        private List<ClassSymbol> typesUnderConstruction;\n-\n@@ -1276,1 +966,0 @@\n-            typesUnderConstruction = List.nil();\n@@ -1281,19 +970,0 @@\n-        @Override\n-        public void visitApply(JCMethodInvocation tree) {\n-            super.visitApply(tree);\n-            if (TreeInfo.isConstructorCall(tree)) {\n-                Assert.check(typesUnderConstruction.head == currentClass());\n-                typesUnderConstruction = typesUnderConstruction.tail;   \/\/ end of early construction context\n-            }\n-        }\n-            \/\/ where\n-            private ClassSymbol currentClass() {\n-                for (Frame frame : frameStack) {\n-                    if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                        JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                        return cdef.sym;\n-                    }\n-                }\n-                return null;\n-            }\n-\n@@ -1332,15 +1002,0 @@\n-                    if (tree.sym.hasOuterInstance()) {\n-                        \/\/if a class is defined within a lambda, the lambda must capture\n-                        \/\/its enclosing instance (if any)\n-                        TranslationContext<?> localContext = context();\n-                        final TypeSymbol outerInstanceSymbol = tree.sym.type.getEnclosingType().tsym;\n-                        while (localContext != null && !localContext.owner.isStatic()) {\n-                            if (localContext.tree.hasTag(LAMBDA)) {\n-                                JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                                if (block == null) break;\n-                                ((LambdaTranslationContext)localContext)\n-                                        .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                            }\n-                            localContext = localContext.prev;\n-                        }\n-                    }\n@@ -1401,10 +1056,1 @@\n-            analyzeLambda(tree, \"lambda.stat\");\n-        }\n-\n-        private void analyzeLambda(JCLambda tree, JCExpression methodReferenceReceiver) {\n-            \/\/ Translation of the receiver expression must occur first\n-            JCExpression rcvr = translate(methodReferenceReceiver);\n-            LambdaTranslationContext context = analyzeLambda(tree, \"mref.stat.1\");\n-            if (rcvr != null) {\n-                context.methodReferenceReceiver = rcvr;\n-            }\n+            analyzeLambda(tree, tree.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\");\n@@ -1437,1 +1083,0 @@\n-            List<ClassSymbol> prevTypesUnderConstruction = typesUnderConstruction;\n@@ -1440,2 +1085,0 @@\n-                if (TreeInfo.isConstructor(tree))       \/\/ start early construction context (Object() notwithstanding)\n-                    typesUnderConstruction = typesUnderConstruction.prepend(currentClass());\n@@ -1444,25 +1087,0 @@\n-            } finally {\n-                frameStack = prevStack;\n-                typesUnderConstruction = prevTypesUnderConstruction;\n-            }\n-        }\n-\n-        @Override\n-        public void visitNewClass(JCNewClass tree) {\n-            TypeSymbol def = tree.type.tsym;\n-            boolean inReferencedClass = currentlyInClass(def);\n-            boolean isLocal = def.isDirectlyOrIndirectlyLocal();\n-            if ((inReferencedClass && isLocal || lambdaNewClassFilter(context(), tree))) {\n-                TranslationContext<?> localContext = context();\n-                final TypeSymbol outerInstanceSymbol = tree.type.getEnclosingType().tsym;\n-                while (localContext != null  && !localContext.owner.isStatic()) {\n-                    if (localContext.tree.hasTag(LAMBDA)) {\n-                        if (outerInstanceSymbol != null) {\n-                            JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                            if (block == null) break;\n-                        }\n-                        ((LambdaTranslationContext)localContext)\n-                                .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                    }\n-                    localContext = localContext.prev;\n-                }\n@@ -1470,44 +1088,2 @@\n-            super.visitNewClass(tree);\n-            if (context() != null && !inReferencedClass && isLocal) {\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context();\n-                captureLocalClassDefs(def, lambdaContext);\n-            }\n-        }\n-        \/\/where\n-            void captureLocalClassDefs(Symbol csym, final LambdaTranslationContext lambdaContext) {\n-                JCClassDecl localCDef = localClassDefs.get(csym);\n-                if (localCDef != null && lambdaContext.freeVarProcessedLocalClasses.add(csym)) {\n-                    BasicFreeVarCollector fvc = lower.new BasicFreeVarCollector() {\n-                        @Override\n-                        void addFreeVars(ClassSymbol c) {\n-                            captureLocalClassDefs(c, lambdaContext);\n-                        }\n-                        @Override\n-                        void visitSymbol(Symbol sym) {\n-                            if (sym.kind == VAR &&\n-                                    sym.owner.kind == MTH &&\n-                                    ((VarSymbol)sym).getConstValue() == null) {\n-                                TranslationContext<?> localContext = context();\n-                                while (localContext != null) {\n-                                    if (localContext.tree.getTag() == LAMBDA) {\n-                                        JCTree block = capturedDecl(localContext.depth, sym);\n-                                        if (block == null) break;\n-                                        ((LambdaTranslationContext)localContext).addSymbol(sym, CAPTURED_VAR);\n-                                    }\n-                                    localContext = localContext.prev;\n-                                }\n-                            }\n-                        }\n-                    };\n-                    fvc.scan(localCDef);\n-                }\n-        }\n-        \/\/where\n-        boolean currentlyInClass(Symbol csym) {\n-            for (Frame frame : frameStack) {\n-                if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                    JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                    if (cdef.sym == csym) {\n-                        return true;\n-                    }\n-                }\n+            finally {\n+                frameStack = prevStack;\n@@ -1515,1 +1091,0 @@\n-            return false;\n@@ -1534,9 +1109,3 @@\n-            if (rcontext.needsConversionToLambda()) {\n-                 \/\/ Convert to a lambda, and process as such\n-                MemberReferenceToLambda conv = new MemberReferenceToLambda(tree, rcontext, owner());\n-                analyzeLambda(conv.lambda(), conv.getReceiverExpression());\n-            } else {\n-                super.visitReference(tree);\n-                if (dumpLambdaToMethodStats) {\n-                    log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n-                }\n+            super.visitReference(tree);\n+            if (dumpLambdaToMethodStats) {\n+                log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n@@ -1776,36 +1345,0 @@\n-        \/**\n-         *  This is used to filter out those select nodes that need to be adjusted\n-         *  when translating away lambda expressions - at the moment, this is the\n-         *  set of nodes that select `this' (qualified this)\n-         *\/\n-        private boolean lambdaFieldAccessFilter(JCFieldAccess fAccess) {\n-            return (context instanceof LambdaTranslationContext lambdaContext)\n-                    && !fAccess.sym.isStatic()\n-                    && fAccess.name == names._this\n-                    && (fAccess.sym.owner.kind == TYP)\n-                    && !lambdaContext.translatedSymbols.get(CAPTURED_OUTER_THIS).isEmpty();\n-        }\n-\n-        \/**\n-         * This is used to filter out those new class expressions that need to\n-         * be qualified with an enclosing tree\n-         *\/\n-        private boolean lambdaNewClassFilter(TranslationContext<?> context, JCNewClass tree) {\n-            if (context != null\n-                    && tree.encl == null\n-                    && tree.def == null\n-                    && !tree.type.getEnclosingType().hasTag(NONE)) {\n-                Type encl = tree.type.getEnclosingType();\n-                Type current = context.owner.enclClass().type;\n-                while (!current.hasTag(NONE)) {\n-                    if (current.tsym.isSubClass(encl.tsym, types)) {\n-                        return true;\n-                    }\n-                    current = current.getEnclosingType();\n-                }\n-                return false;\n-            } else {\n-                return false;\n-            }\n-        }\n-\n@@ -1921,12 +1454,0 @@\n-            \/**\n-             * to prevent recursion, track local classes processed\n-             *\/\n-            final Set<Symbol> freeVarProcessedLocalClasses;\n-\n-            \/**\n-             * For method references converted to lambdas.  The method\n-             * reference receiver expression. Must be treated like a captured\n-             * variable.\n-             *\/\n-            JCExpression methodReferenceReceiver;\n-\n@@ -1963,7 +1484,4 @@\n-                translatedSymbols.put(PARAM, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap<Symbol, Symbol>());\n-\n-                freeVarProcessedLocalClasses = new HashSet<>();\n+                translatedSymbols.put(PARAM, new LinkedHashMap<>());\n+                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<>());\n+                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<>());\n+                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<>());\n@@ -2069,10 +1587,0 @@\n-                    case CAPTURED_OUTER_THIS:\n-                        Name name = names.fromString(sym.flatName().toString().replace('.', '$') + names.dollarThis);\n-                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original captured symbol\n-                                return sym;\n-                            }\n-                        };\n-                        break;\n@@ -2117,8 +1625,0 @@\n-                if (skind == CAPTURED_THIS && sym != null && sym.kind == TYP && !typesUnderConstruction.isEmpty()) {\n-                    ClassSymbol currentClass = currentClass();\n-                    if (currentClass != null && typesUnderConstruction.contains(currentClass)) {\n-                        \/\/ reference must be to enclosing outer instance, mutate capture kind.\n-                        Assert.check(sym != currentClass); \/\/ should have been caught right in Attr\n-                        skind = CAPTURED_OUTER_THIS;\n-                    }\n-                }\n@@ -2148,14 +1648,0 @@\n-                        case CAPTURED_OUTER_THIS:\n-                            Optional<Symbol> proxy = m.keySet().stream()\n-                                    .filter(out -> lambdaIdent.sym.isMemberOf(out.type.tsym, types))\n-                                    .reduce((a, b) -> a.isEnclosedBy((ClassSymbol)b) ? a : b);\n-                            if (proxy.isPresent()) {\n-                                \/\/ Transform outer instance variable references anchoring them to the captured synthetic.\n-                                Symbol tSym = m.get(proxy.get());\n-                                JCExpression t = make.Ident(tSym).setType(lambdaIdent.sym.owner.type);\n-                                t = make.Select(t, lambdaIdent.name);\n-                                t.setType(lambdaIdent.type);\n-                                TreeInfo.setSymbol(t, lambdaIdent.sym);\n-                                return t;\n-                            }\n-                            break;\n@@ -2167,29 +1653,0 @@\n-            \/* Translate away qualified this expressions, anchoring them to synthetic parameters that\n-               capture the qualified this handle. `fieldAccess' is guaranteed to one such.\n-            *\/\n-            public JCTree translate(JCFieldAccess fieldAccess) {\n-                Assert.check(fieldAccess.name == names._this);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                if (m.containsKey(fieldAccess.sym.owner)) {\n-                    Symbol tSym = m.get(fieldAccess.sym.owner);\n-                    JCExpression t = make.Ident(tSym).setType(fieldAccess.sym.owner.type);\n-                    return t;\n-                }\n-                return null;\n-            }\n-\n-            \/* Translate away naked new instance creation expressions with implicit enclosing instances,\n-               anchoring them to synthetic parameters that stand proxy for the qualified outer this handle.\n-            *\/\n-            public JCNewClass translate(JCNewClass newClass) {\n-                Assert.check(newClass.clazz.type.tsym.hasOuterInstance() && newClass.encl == null);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                final Type enclosingType = newClass.clazz.type.getEnclosingType();\n-                if (m.containsKey(enclosingType.tsym)) {\n-                      Symbol tSym = m.get(enclosingType.tsym);\n-                      JCExpression encl = make.Ident(tSym).setType(enclosingType);\n-                      newClass.encl = encl;\n-                }\n-                return newClass;\n-            }\n-\n@@ -2233,4 +1690,0 @@\n-                for (Symbol thisSym : getSymbolMap(CAPTURED_OUTER_THIS).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n-                }\n@@ -2262,4 +1715,1 @@\n-         * This class retains all the useful information about a method reference;\n-         * the contents of this class are filled by the LambdaAnalyzer visitor,\n-         * and the used by the main translation routines in order to adjust method\n-         * references (i.e. in case a bridge is needed)\n+         * Simple subclass modelling the translation context of a method reference.\n@@ -2269,2 +1719,0 @@\n-            final boolean isSuper;\n-\n@@ -2273,85 +1721,0 @@\n-                this.isSuper = tree.hasKind(ReferenceKind.SUPER);\n-            }\n-\n-            boolean needsVarArgsConversion() {\n-                return tree.varargsElement != null;\n-            }\n-\n-            \/**\n-             * @return Is this an array operation like clone()\n-             *\/\n-            boolean isArrayOp() {\n-                return tree.sym.owner == syms.arrayClass;\n-            }\n-\n-            boolean receiverAccessible() {\n-                \/\/hack needed to workaround 292 bug (7087658)\n-                \/\/when 292 issue is fixed we should remove this and change the backend\n-                \/\/code to always generate a method handle to an accessible method\n-                return tree.ownerAccessible;\n-            }\n-\n-            \/**\n-             * This method should be called only when target release <= 14\n-             * where LambdaMetaFactory does not spin nestmate classes.\n-             *\n-             * This method should be removed when --release 14 is not supported.\n-             *\/\n-            boolean isPrivateInOtherClass() {\n-                assert !nestmateLambdas;\n-                return  (tree.sym.flags() & PRIVATE) != 0 &&\n-                        !types.isSameType(\n-                              types.erasure(tree.sym.enclClass().asType()),\n-                              types.erasure(owner.enclClass().asType()));\n-            }\n-\n-            \/**\n-             * Erasure destroys the implementation parameter subtype\n-             * relationship for intersection types.\n-             * Have similar problems for union types too.\n-             *\/\n-            boolean interfaceParameterIsIntersectionOrUnionType() {\n-                List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n-                for (; tl.nonEmpty(); tl = tl.tail) {\n-                    Type pt = tl.head;\n-                    if (isIntersectionOrUnionType(pt))\n-                        return true;\n-                }\n-                return false;\n-            }\n-\n-            boolean isIntersectionOrUnionType(Type t) {\n-                switch (t.getKind()) {\n-                    case INTERSECTION:\n-                    case UNION:\n-                        return true;\n-                    case TYPEVAR:\n-                        TypeVar tv = (TypeVar) t;\n-                        return isIntersectionOrUnionType(tv.getUpperBound());\n-                }\n-                return false;\n-            }\n-\n-            \/**\n-             * Does this reference need to be converted to a lambda\n-             * (i.e. var args need to be expanded or \"super\" is used)\n-             *\/\n-            final boolean needsConversionToLambda() {\n-                return interfaceParameterIsIntersectionOrUnionType() ||\n-                        isSuper ||\n-                        needsVarArgsConversion() ||\n-                        isArrayOp() ||\n-                        (!nestmateLambdas && isPrivateInOtherClass()) ||\n-                        isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner) ||\n-                        !receiverAccessible() ||\n-                        (tree.getMode() == ReferenceMode.NEW &&\n-                          tree.kind != ReferenceKind.ARRAY_CTOR &&\n-                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n-            }\n-\n-            Type generatedRefSig() {\n-                return types.erasure(tree.sym.type);\n-            }\n-\n-            Type bridgedRefSig() {\n-                return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n@@ -2371,2 +1734,1 @@\n-        CAPTURED_THIS,  \/\/ class symbols to translated synthetic parameters (for captured member access)\n-        CAPTURED_OUTER_THIS; \/\/ used when `this' capture is illegal, but outer this capture is legit (JDK-8129740)\n+        CAPTURED_THIS;  \/\/ class symbols to translated synthetic parameters (for captured member access)\n@@ -2378,1 +1740,0 @@\n-                case CAPTURED_OUTER_THIS:\n@@ -2420,6 +1781,0 @@\n-    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n-                                                                          Symbol currentClass) {\n-        return ((targetReference.flags() & PROTECTED) != 0 &&\n-                targetReference.packge() != currentClass.packge());\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":15,"deletions":660,"binary":false,"changes":675,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -38,0 +40,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -39,0 +42,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n@@ -65,0 +69,3 @@\n+\n+import javax.lang.model.type.TypeKind;\n+\n@@ -107,0 +114,1 @@\n+    private int variableIndex = 0;\n@@ -176,0 +184,5 @@\n+    \/**\n+     * The current expected return type.\n+     *\/\n+    Type currentRestype;\n+\n@@ -192,6 +205,0 @@\n-    \/** A map from local variable symbols to their translation (as per LambdaToMethod).\n-     * This is required when a capturing local class is created from a lambda (in which\n-     * case the captured symbols should be replaced with the translated lambda symbols).\n-     *\/\n-    Map<Symbol, Symbol> lambdaTranslationMap = null;\n-\n@@ -1244,8 +1251,4 @@\n-            if (lambdaTranslationMap != null && lambdaTranslationMap.get(sym) != null) {\n-                return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));\n-            } else {\n-                \/\/ Otherwise replace the variable by its proxy.\n-                sym = proxies.get(sym);\n-                Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n-                tree = make.at(tree.pos).Ident(sym);\n-            }\n+            \/\/ Otherwise replace the variable by its proxy.\n+            sym = proxies.get(sym);\n+            Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n+            tree = make.at(tree.pos).Ident(sym);\n@@ -1336,8 +1339,0 @@\n-            } else if (sym.owner.kind == MTH && lambdaTranslationMap != null) {\n-                \/\/sym is a local variable - check the lambda translation map to\n-                \/\/see if sym has been translated to something else in the current\n-                \/\/scope (by LambdaToMethod)\n-                Symbol translatedSym = lambdaTranslationMap.get(sym.baseSymbol());\n-                if (translatedSym != null) {\n-                    tree = make.at(tree.pos).Ident(translatedSym);\n-                }\n@@ -2790,0 +2785,1 @@\n+        Type prevRestype = currentRestype;\n@@ -2792,0 +2788,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -2793,0 +2790,1 @@\n+            currentRestype = types.erasure(tree.type.getReturnType());\n@@ -2795,0 +2793,1 @@\n+            variableIndex = 0;\n@@ -2797,0 +2796,1 @@\n+            currentRestype = prevRestype;\n@@ -2799,0 +2799,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -2877,10 +2878,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap =\n-                    lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = (tree.sym.flags() & SYNTHETIC) != 0 &&\n-                        tree.sym.name.startsWith(names.lambda) ?\n-                        makeTranslationMap(tree) : null;\n-                super.visitMethodDef(tree);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            super.visitMethodDef(tree);\n@@ -2918,11 +2910,0 @@\n-    \/\/where\n-        private Map<Symbol, Symbol> makeTranslationMap(JCMethodDecl tree) {\n-            Map<Symbol, Symbol> translationMap = new HashMap<>();\n-            for (JCVariableDecl vd : tree.params) {\n-                Symbol p = vd.sym;\n-                if (p != p.baseSymbol()) {\n-                    translationMap.put(p.baseSymbol(), p);\n-                }\n-            }\n-            return translationMap;\n-        }\n@@ -2990,1 +2971,1 @@\n-                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -3160,7 +3141,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap = lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = null;\n-                translate(tree.def);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            translate(tree.def);\n@@ -3386,0 +3361,3 @@\n+        if (tree.args.stream().anyMatch(c -> c == null)) {\n+            throw new AssertionError(\"Whooops before: \" + tree);\n+        }\n@@ -3873,0 +3851,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -3882,3 +3861,7 @@\n-        if (tree.init != null) tree.init = translate(tree.init, tree.type);\n-        result = tree;\n-        currentMethodSym = oldMethodSym;\n+        try {\n+            if (tree.init != null) tree.init = translate(tree.init, tree.type);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3896,2 +3879,8 @@\n-        super.visitBlock(tree);\n-        currentMethodSym = oldMethodSym;\n+        int prevVariableIndex = variableIndex;\n+        try {\n+            variableIndex = 0;\n+            super.visitBlock(tree);\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3924,2 +3913,1 @@\n-                                  types.erasure(currentMethodDef\n-                                                .restype.type));\n+                                  currentRestype);\n@@ -3929,0 +3917,345 @@\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        Type prevRestype = currentRestype;\n+        try {\n+            currentRestype = types.erasure(tree.getDescriptorType(types)).getReturnType();\n+            tree.body = tree.getBodyKind() == BodyKind.EXPRESSION ?\n+                    translate((JCExpression) tree.body, currentRestype) :\n+                    translate(tree.body);\n+        } finally {\n+            currentRestype = prevRestype;\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+    \/\/ where\n+        boolean needsVarArgsConversion(JCMemberReference tree) {\n+            return tree.varargsElement != null;\n+        }\n+\n+        \/**\n+         * @return Is this an array operation like clone()\n+         *\/\n+        boolean isArrayOp(JCMemberReference tree) {\n+            return tree.sym.owner == syms.arrayClass;\n+        }\n+\n+        boolean receiverAccessible(JCMemberReference tree) {\n+            \/\/hack needed to workaround 292 bug (7087658)\n+            \/\/when 292 issue is fixed we should remove this and change the backend\n+            \/\/code to always generate a method handle to an accessible method\n+            return tree.ownerAccessible;\n+        }\n+\n+        \/**\n+         * Erasure destroys the implementation parameter subtype\n+         * relationship for intersection types.\n+         * Have similar problems for union types too.\n+         *\/\n+        boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+            List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+            for (; tl.nonEmpty(); tl = tl.tail) {\n+                Type pt = tl.head;\n+                if (isIntersectionOrUnionType(pt))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        boolean isIntersectionOrUnionType(Type t) {\n+            switch (t.getKind()) {\n+                case INTERSECTION:\n+                case UNION:\n+                    return true;\n+                case TYPEVAR:\n+                    TypeVar tv = (TypeVar) t;\n+                    return isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            return false;\n+        }\n+\n+        private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                              Symbol currentClass) {\n+            return ((targetReference.flags() & PROTECTED) != 0 &&\n+                    targetReference.packge() != currentClass.packge());\n+        }\n+\n+        \/**\n+         * This method should be called only when target release <= 14\n+         * where LambdaMetaFactory does not spin nestmate classes.\n+         *\n+         * This method should be removed when --release 14 is not supported.\n+         *\/\n+        boolean isPrivateInOtherClass(JCMemberReference tree) {\n+            assert !target.runtimeUseNestAccess();\n+            return  (tree.sym.flags() & PRIVATE) != 0 &&\n+                    !types.isSameType(\n+                            types.erasure(tree.sym.enclClass().asType()),\n+                            types.erasure(currentClass.asType()));\n+        }\n+\n+        \/**\n+         * Does this reference need to be converted to a lambda\n+         * (i.e. var args need to be expanded or \"super\" is used)\n+         *\/\n+        boolean needsConversionToLambda(JCMemberReference tree) {\n+            return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                    tree.hasKind(ReferenceKind.SUPER) ||\n+                    needsVarArgsConversion(tree) ||\n+                    isArrayOp(tree) ||\n+                    (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass) ||\n+                    !receiverAccessible(tree) ||\n+                    (tree.getMode() == ReferenceMode.NEW &&\n+                            tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                            (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+        }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, currentClass);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, translate(receiverExpression)), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            Type samDesc = types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n+            List<Type> samPTypes = samDesc.getParameterTypes();\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n+                    samPTypes = samPTypes.tail;\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = samPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            \/\/ Failsafe -- assure match-up\n+            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n+\n+            \/\/ Use parameter types of the implementation method unless the unerased\n+            \/\/ SAM parameter type is an intersection type, in that case use the\n+            \/\/ erased SAM parameter type so that the supertype relationship\n+            \/\/ the implementation method parameters is not obscured.\n+            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n+            \/\/ are used as pointers to the current parameter type information\n+            \/\/ and are thus not usable afterwards.\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = implPTypes.head;\n+                if (checkForIntersection) {\n+                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n+                        parmType = samPTypes.head;\n+                    }\n+                    \/\/ If the unerased parameter type is a type variable whose\n+                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n+                    \/\/ use the SAM parameter type\n+                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n+                        TypeVar tv = (TypeVar) descPTypes.head;\n+                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n+                            parmType = samPTypes.head;\n+                        }\n+                    }\n+                }\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                samPTypes = samPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        private JCExpression makeReceiver(VarSymbol rcvr) {\n+            if (rcvr == null) return null;\n+            JCExpression rcvrExpr = make.Ident(rcvr);\n+            boolean protAccess =\n+                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass);\n+            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n+                    : tree.expr.type;\n+            if (rcvrType == syms.arrayClass.type) {\n+                \/\/ Map the receiver type to the actually type, not just \"array\"\n+                rcvrType = tree.getQualifierExpression().type;\n+            }\n+            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n+                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n+            }\n+            return rcvrExpr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            makeReceiver(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.sym.erasure(types);\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n+                    setType(tree.sym.erasure(types).getReturnType());\n+\n+            apply = transTypes.coerce(attrEnv, apply,\n+                    types.erasure(tree.referentType.getReturnType()));\n+\n+            setVarargsIfNeeded(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                setVarargsIfNeeded(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n+    \/**\n+     * Convert method\/constructor arguments by inserting appropriate cast\n+     * as required by type-erasure - this is needed when bridging a lambda\/method\n+     * reference, as the bridged signature might require downcast to be compatible\n+     * with the generated signature.\n+     *\/\n+    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n+        Assert.check(meth.kind == MTH);\n+        List<Type> formals = types.erasure(meth.type).getParameterTypes();\n+        if (varargsElement != null) {\n+            Assert.check((meth.flags() & VARARGS) != 0);\n+        }\n+        return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n+    }\n+\n+    \/**\n+     * Set varargsElement field on a given tree (must be either a new class tree\n+     * or a method call tree)\n+     *\/\n+    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n+        if (varargsElement != null) {\n+            switch (tree.getTag()) {\n+                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n+                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n+                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n+                default: throw new AssertionError();\n+            }\n+        }\n+    }\n+\n@@ -4046,1 +4379,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4203,1 +4536,1 @@\n-                                               names.fromString(\"s\" + tree.pos + target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4209,1 +4542,1 @@\n-                                                 names.fromString(\"tmp\" + tree.pos + target.syntheticNameChar()),\n+                                                 names.fromString(\"tmp\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4351,1 +4684,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4409,1 +4742,1 @@\n-        if (tree.name == names._class) {\n+        if (tree.name == names._class && tree.selected.type.isPrimitiveOrVoid()) {\n@@ -4485,0 +4818,1 @@\n+            currentRestype = null;\n@@ -4514,0 +4848,1 @@\n+            currentRestype = null;\n@@ -4533,0 +4868,19 @@\n+\n+    \/\/ needed for the lambda deserialization method, which is expressed as a big switch on strings\n+    public JCMethodDecl translateMethod(Env<AttrContext> env, JCMethodDecl methodDecl, TreeMaker make) {\n+        try {\n+            this.attrEnv = env;\n+            this.make = make;\n+            this.currentClass = methodDecl.sym.enclClass();\n+            proxies = new HashMap<>();\n+            return translate(methodDecl);\n+        } finally {\n+            this.attrEnv = null;\n+            this.make = null;\n+            this.currentClass = null;\n+            \/\/ the two fields below are set when visiting the method\n+            this.currentMethodSym = null;\n+            this.currentMethodDef = null;\n+            this.proxies = null;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":417,"deletions":63,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -2434,1 +2434,8 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n+        try {\n+            return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n+        } catch (ClassFinder.BadClassFile err) {\n+            return new BadClassFileError(err);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return typeNotFound;\n+        }\n@@ -2506,1 +2513,8 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name));\n+        try {\n+            return checkNonExistentType(checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name));\n+        } catch (ClassFinder.BadClassFile err) {\n+            return new BadClassFileError(err);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return typeNotFound;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1621,8 +1621,0 @@\n-            if (scanner.hasLambdas) {\n-                if (shouldStop(CompileState.UNLAMBDA))\n-                    return;\n-\n-                env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);\n-                compileStates.put(env, CompileState.UNLAMBDA);\n-            }\n-\n@@ -1650,0 +1642,10 @@\n+            if (scanner.hasLambdas) {\n+                if (shouldStop(CompileState.UNLAMBDA))\n+                    return;\n+\n+                for (JCTree def : cdefs) {\n+                    LambdaToMethod.instance(context).translateTopLevelClass(env, def, localMake);\n+                }\n+                compileStates.put(env, CompileState.UNLAMBDA);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2935,1 +2935,1 @@\n-                    case NULL: case IDENTIFIER: case TRUE: case FALSE:\n+                    case NULL: case IDENTIFIER: case UNDERSCORE: case TRUE: case FALSE:\n@@ -3456,1 +3456,9 @@\n-                case RPAREN: parenDepth--; break;\n+                case RPAREN:\n+                    parenDepth--;\n+                    if (parenDepth == 0 &&\n+                        typeDepth == 0 &&\n+                        peekToken(lookahead, TokenKind.IDENTIFIER) &&\n+                        S.token(lookahead + 1).name() == names.when) {\n+                        return PatternResult.PATTERN;\n+                    }\n+                    break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,8 @@\n-    public PlatformDescription getPlatform(String platformName, String options) {\n+    public PlatformDescription getPlatform(String platformName, String options) throws PlatformNotSupported {\n+        if (!SUPPORTED_JAVA_PLATFORM_VERSIONS.contains(platformName)) {\n+            throw new PlatformNotSupported();\n+        }\n+        return getPlatformTrusted(platformName);\n+    }\n+\n+    public PlatformDescription getPlatformTrusted(String platformName) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2016,0 +2016,1 @@\n+        public boolean wasMethodReference;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,0 +347,1 @@\n+            result = tree;\n@@ -352,0 +353,1 @@\n+            result = tree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,0 +187,3 @@\n+        else if (arg instanceof JCDiagnostic.AnnotatedType type) {\n+            preprocessType(type.type());\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+class name javax\/swing\/plaf\/basic\/BasicSliderUI\n+-method name <init> descriptor ()V\n+method name <init> descriptor ()V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"23\")\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.desktop-N.sym.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,0 +167,5 @@\n+    \/\/ CTS mode variant used by the token, as described in Addendum to NIST\n+    \/\/ Special Publication 800-38A, \"Recommendation for Block Cipher Modes\n+    \/\/ of Operation: Three Variants of Ciphertext Stealing for CBC Mode\".\n+    private Token.CTSVariant ctsVariant = null;\n+\n@@ -324,0 +329,4 @@\n+    Token.CTSVariant getCTSVariant() {\n+        return ctsVariant;\n+    }\n+\n@@ -475,0 +484,2 @@\n+            case \"cipherTextStealingVariant\"->\n+                ctsVariant = parseEnumEntry(Token.CTSVariant.class, st.sval);\n@@ -630,0 +641,11 @@\n+    private <E extends Enum<E>> E parseEnumEntry(Class<E> enumClass,\n+            String keyword) throws IOException {\n+        String value = parseStringEntry(keyword);\n+        try {\n+            return Enum.valueOf(enumClass, value);\n+        } catch (IllegalArgumentException ignored) {\n+            throw excToken(keyword + \" must be one of \" +\n+                    Arrays.toString(enumClass.getEnumConstants()) + \", read:\");\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * This class is designed to support ECB, CBC, CTR with NoPadding\n+ * This class is designed to support ECB, CBC, CTR, CTS with NoPadding\n@@ -63,11 +63,3 @@\n-    \/\/ mode constant for ECB mode\n-    private static final int MODE_ECB = 3;\n-    \/\/ mode constant for CBC mode\n-    private static final int MODE_CBC = 4;\n-    \/\/ mode constant for CTR mode\n-    private static final int MODE_CTR = 5;\n-\n-    \/\/ padding constant for NoPadding\n-    private static final int PAD_NONE = 5;\n-    \/\/ padding constant for PKCS5Padding\n-    private static final int PAD_PKCS5 = 6;\n+    \/\/ mode and padding constants\n+    private enum Mode {ECB \/* or stream ciphers *\/, CBC, CTR, CTS}\n+    private enum Pad {NONE, PKCS5}\n@@ -149,2 +141,2 @@\n-    \/\/ mode, one of MODE_* above (MODE_ECB for stream ciphers)\n-    private int blockMode;\n+    \/\/ mode, Mode.ECB for stream ciphers\n+    private final Mode blockMode;\n@@ -155,2 +147,2 @@\n-    \/\/ padding type, on of PAD_* above (PAD_NONE for stream ciphers)\n-    private int paddingType;\n+    \/\/ padding type, Pad.NONE for stream ciphers\n+    private Pad paddingType;\n@@ -166,1 +158,1 @@\n-    \/\/ original IV, if in MODE_CBC or MODE_CTR\n+    \/\/ original IV, if in Mode.CBC, Mode.CTR or Mode.CTS\n@@ -211,2 +203,1 @@\n-        this.blockMode =\n-            (algoParts.length > 1 ? parseMode(algoParts[1]) : MODE_ECB);\n+        blockMode = algoParts.length > 1 ? parseMode(algoParts[1]) : Mode.ECB;\n@@ -230,1 +221,1 @@\n-    private int parseMode(String mode) throws NoSuchAlgorithmException {\n+    private Mode parseMode(String mode) throws NoSuchAlgorithmException {\n@@ -232,12 +223,11 @@\n-        return switch (mode) {\n-            case \"ECB\" -> MODE_ECB;\n-            case \"CBC\" -> {\n-                if (blockSize == 0) {\n-                    throw new NoSuchAlgorithmException\n-                            (\"CBC mode not supported with stream ciphers\");\n-                }\n-                yield MODE_CBC;\n-            }\n-            case \"CTR\" -> MODE_CTR;\n-            default -> throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-        };\n+        Mode result;\n+        try {\n+            result = Mode.valueOf(mode);\n+        } catch (IllegalArgumentException ignored) {\n+            throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+        }\n+        if (blockSize == 0 && result != Mode.ECB) {\n+            throw new NoSuchAlgorithmException(\n+                    result + \" mode not supported with stream ciphers\");\n+        }\n+        return result;\n@@ -253,1 +243,10 @@\n-            paddingType = PAD_NONE;\n+            paddingType = Pad.NONE;\n+            if (blockMode == Mode.CTS) {\n+                \/\/ Buffer at least two blocks (where the last one may be\n+                \/\/ partial). When using NSS, buffer one more block to avoid\n+                \/\/ NSS Bug 1823875: \"AES CTS decryption does not update\n+                \/\/ its own context's IV on full blocks input\"\n+                \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1823875#c2\n+                int bufferedBlocks = P11Util.isNSS(token) ? 3 : 2;\n+                padBuffer = new byte[bufferedBlocks * blockSize];\n+            }\n@@ -255,3 +254,3 @@\n-            if (this.blockMode == MODE_CTR) {\n-                throw new NoSuchPaddingException\n-                    (\"PKCS#5 padding not supported with CTR mode\");\n+            if (blockMode == Mode.CTR || blockMode == Mode.CTS) {\n+                throw new NoSuchPaddingException(\"PKCS#5 padding not \" +\n+                        \"supported with \" + blockMode + \" mode\");\n@@ -259,1 +258,1 @@\n-            paddingType = PAD_PKCS5;\n+            paddingType = Pad.PKCS5;\n@@ -374,1 +373,1 @@\n-        if (blockMode == MODE_ECB) { \/\/ ECB or stream cipher\n+        if (blockMode == Mode.ECB) { \/\/ ECB or stream cipher\n@@ -384,1 +383,1 @@\n-        } else { \/\/ MODE_CBC or MODE_CTR\n+        } else { \/\/ Mode.CBC, Mode.CTR or Mode.CTS\n@@ -387,5 +386,3 @@\n-                    String exMsg =\n-                        (blockMode == MODE_CBC ?\n-                         \"IV must be specified for decryption in CBC mode\" :\n-                         \"IV must be specified for decryption in CTR mode\");\n-                    throw new InvalidAlgorithmParameterException(exMsg);\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"IV must be specified for decryption in \" +\n+                            blockMode + \" mode\");\n@@ -436,0 +433,3 @@\n+            if (padBuffer != null) {\n+                Arrays.fill(padBuffer, (byte) 0);\n+            }\n@@ -490,1 +490,1 @@\n-            CK_MECHANISM mechParams = (blockMode == MODE_CTR ?\n+            CK_MECHANISM mechParams = (blockMode == Mode.CTR ?\n@@ -515,1 +515,3 @@\n-        if (blockSize != 0 && blockMode != MODE_CTR) {\n+        if (blockMode == Mode.CTS) {\n+            result -= getCTSMustBeBuffered(result);\n+        } else if (blockSize != 0 && blockMode != Mode.CTR) {\n@@ -529,1 +531,1 @@\n-        if (blockSize != 0 && encrypt && paddingType != PAD_NONE) {\n+        if (blockSize != 0 && encrypt && paddingType != Pad.NONE) {\n@@ -607,1 +609,50 @@\n-            if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+            if (blockMode == Mode.CTS) {\n+                \/\/ decide how to split the total data (totalInLen) between\n+                \/\/ the token (dataForP11Update) and padBuffer\n+                \/\/ (newPadBufferLen)\n+                int totalInLen = padBufferLen + inLen;\n+                newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                int dataForP11Update = totalInLen - newPadBufferLen;\n+                if (dataForP11Update > 0 && padBufferLen > 0) {\n+                    \/\/ there is data for the token and part of it is in\n+                    \/\/ padBuffer\n+                    int flushFromPadBuffer;\n+                    int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                    if (dataForP11Update >= padBufferLen + fillLen) {\n+                        \/\/ flush the whole padBuffer\n+                        if (fillLen > 0) {\n+                            \/\/ complete the last padBuffer block from the\n+                            \/\/ input\n+                            bufferInputBytes(in, inOfs, fillLen);\n+                            inOfs += fillLen;\n+                            inLen -= fillLen;\n+                        }\n+                        flushFromPadBuffer = padBufferLen;\n+                    } else {\n+                        \/\/ There is not enough input data available to\n+                        \/\/ complete the padBuffer to a multiple of block\n+                        \/\/ size. Flush part of the padBuffer (up to a\n+                        \/\/ multiple of blockSize) now. Shift the remaining\n+                        \/\/ padBuffer data and buffer more up to completing\n+                        \/\/ newPadBufferLen later.\n+                        flushFromPadBuffer = dataForP11Update;\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    } else {\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    }\n+                    padBufferLen -= flushFromPadBuffer;\n+                    if (padBufferLen > 0) {\n+                        \/\/ shift remaining data to the padBuffer start\n+                        System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                padBuffer, 0, padBufferLen);\n+                    }\n+                }\n+                newPadBufferLen -= padBufferLen;\n+                inLen -= newPadBufferLen;\n+            } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -652,1 +703,2 @@\n-            if (paddingObj != null && newPadBufferLen > 0) {\n+            if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                    newPadBufferLen > 0) {\n@@ -718,1 +770,50 @@\n-                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                if (blockMode == Mode.CTS) {\n+                    \/\/ decide how to split the total data (totalInLen) between\n+                    \/\/ the token (dataForP11Update) and padBuffer\n+                    \/\/ (newPadBufferLen)\n+                    int totalInLen = padBufferLen + inLen;\n+                    newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                    int dataForP11Update = totalInLen - newPadBufferLen;\n+                    if (dataForP11Update > 0 && padBufferLen > 0) {\n+                        \/\/ there is data for the token and part of it is in\n+                        \/\/ padBuffer\n+                        int flushFromPadBuffer;\n+                        int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                        if (dataForP11Update >= padBufferLen + fillLen) {\n+                            \/\/ flush the whole padBuffer\n+                            if (fillLen > 0) {\n+                                \/\/ complete the last padBuffer block from the\n+                                \/\/ input\n+                                bufferInputBytes(inBuffer, fillLen);\n+                                inOfs += fillLen;\n+                                inLen -= fillLen;\n+                            }\n+                            flushFromPadBuffer = padBufferLen;\n+                        } else {\n+                            \/\/ There is not enough input data available to\n+                            \/\/ complete the padBuffer to a multiple of block\n+                            \/\/ size. Flush part of the padBuffer (up to a\n+                            \/\/ multiple of blockSize) now. Shift the remaining\n+                            \/\/ padBuffer data and buffer more up to completing\n+                            \/\/ newPadBufferLen later.\n+                            flushFromPadBuffer = dataForP11Update;\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        } else {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        }\n+                        padBufferLen -= flushFromPadBuffer;\n+                        if (padBufferLen > 0) {\n+                            \/\/ shift remaining data to the padBuffer start\n+                            System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                    padBuffer, 0, padBufferLen);\n+                        }\n+                    }\n+                    newPadBufferLen -= padBufferLen;\n+                    inLen -= newPadBufferLen;\n+                } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -771,1 +872,2 @@\n-                if (paddingObj != null && newPadBufferLen > 0) {\n+                if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                        newPadBufferLen > 0) {\n@@ -833,0 +935,4 @@\n+                } else if (blockMode == Mode.CTS) {\n+                    k = token.p11.C_EncryptUpdate(session.id(),\n+                            0, padBuffer, 0, padBufferLen,\n+                            0, out, outOfs, outLen);\n@@ -842,0 +948,3 @@\n+                if (blockMode == Mode.CTS) {\n+                    convertCTSVariant(null, out, outOfs + k);\n+                }\n@@ -866,0 +975,8 @@\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(null, padBuffer, padBufferLen);\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                0, out, outOfs, outLen);\n+                        outOfs += k;\n+                        outLen -= k;\n+                    }\n@@ -867,1 +984,1 @@\n-                    k = token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n+                    k += token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n@@ -931,0 +1048,4 @@\n+                    } else if (blockMode == Mode.CTS) {\n+                       k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                outAddr, outArray, outOfs, outLen);\n@@ -940,0 +1061,3 @@\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(outBuffer, outArray, outOfs + k);\n+                    }\n@@ -945,1 +1069,0 @@\n-\n@@ -967,0 +1090,8 @@\n+                        if (blockMode == Mode.CTS) {\n+                            convertCTSVariant(null, padBuffer, padBufferLen);\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, padBufferLen,\n+                                    outAddr, outArray, outOfs, outLen);\n+                            outOfs += k;\n+                            outLen -= k;\n+                        }\n@@ -968,1 +1099,1 @@\n-                        k = token.p11.C_DecryptFinal(session.id(),\n+                        k += token.p11.C_DecryptFinal(session.id(),\n@@ -991,0 +1122,77 @@\n+    private int getBytesToCompleteBlock(int availableBytes) {\n+        int partBlock = availableBytes & (blockSize - 1);\n+        return partBlock == 0 ? 0 : blockSize - partBlock;\n+    }\n+\n+    private int getCTSMustBeBuffered(int availableBytes) {\n+        return Math.min(availableBytes,\n+                padBuffer.length - getBytesToCompleteBlock(availableBytes));\n+    }\n+\n+    \/**\n+     * The ciphertext ordering for the three variants can be depicted as\n+     * follows, where 'p' is the penultimate block (which may be partial\n+     * or full), and 'f' the full final block:\n+     *\n+     *                    'p' is a partial block   'p' is a full block\n+     *                   ------------------------ ---------------------\n+     *   CS1 (NIST)     |     .... pp ffff       |    .... pppp ffff\n+     *   CS2 (Schneier) |     .... ffff pp       |    .... pppp ffff\n+     *   CS3 (Kerberos) |     .... ffff pp       |    .... ffff pppp\n+     *\n+     * After encryption, we get the ciphertext from the token formatted as\n+     * specified in the SunPKCS11 'cipherTextStealingVariant' configuration\n+     * property. Conversely, before decryption, the ciphertext has to be passed\n+     * to the token according to the previous formatting. This method converts\n+     * the ciphertext between the format used by the token and the one used by\n+     * SunJCE's \"AES\/CTS\/NoPadding\" implementation (CS3 as described by RFC\n+     * 2040, section 8).\n+     *\/\n+    private void convertCTSVariant(ByteBuffer ciphertextBuf,\n+            byte[] ciphertextArr, int ciphertextEnd) {\n+        if (padBufferLen == blockSize) {\n+            \/\/ No reordering needed for a single block\n+            return;\n+        }\n+        assert token.ctsVariant != null : \"CTS algorithms should not be \" +\n+                \"registered if the CTS variant of the token is unknown\";\n+        if (token.ctsVariant == Token.CTSVariant.CS3) {\n+            \/\/ Already CS3\n+            return;\n+        }\n+        int pad = padBufferLen % blockSize;\n+        if (token.ctsVariant == Token.CTSVariant.CS2 && pad != 0) {\n+            \/\/ CS2 and 'p' is a partial block, equal to CS3\n+            return;\n+        }\n+        if (ciphertextArr != null) {\n+            ciphertextBuf = ByteBuffer.wrap(ciphertextArr);\n+        }\n+        if (ciphertextBuf != null) {\n+            \/\/ No assumptions should be made about the current ciphertextBuf\n+            \/\/ position. Additionally, if ciphertextBuf was not created here,\n+            \/\/ the position should not be altered. To ensure this, use offsets\n+            \/\/ to read and write bytes from the last two blocks (i.e. absolute\n+            \/\/ ByteBuffer operations). Other blocks should not be modified.\n+            pad = pad == 0 ? blockSize : pad;\n+            if (encrypt) {\n+                \/\/ .... pp[pp] ffff -> .... ffff pp[pp]\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, pad, blockSize);\n+            } else {\n+                \/\/ .... ffff pp[pp] -> .... pp[pp] ffff\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, blockSize, pad);\n+            }\n+        }\n+    }\n+\n+    private static void swapLastTwoBlocks(ByteBuffer ciphertextBuf,\n+            int ciphertextEnd, int prevBlockLen, int lastBlockLen) {\n+        \/\/ .... prevBlock lastBlock -> .... lastBlock prevBlock\n+        int prevBlockStart = ciphertextEnd - prevBlockLen - lastBlockLen;\n+        byte[] prevBlockBackup = new byte[prevBlockLen];\n+        ciphertextBuf.get(prevBlockStart, prevBlockBackup);\n+        ciphertextBuf.put(prevBlockStart, ciphertextBuf,\n+                ciphertextEnd - lastBlockLen, lastBlockLen);\n+        ciphertextBuf.put(ciphertextEnd - prevBlockLen, prevBlockBackup);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":263,"deletions":55,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -863,0 +863,9 @@\n+        d(CIP, \"AES\/CTS\/NoPadding\",             P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_128\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_192\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_256\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+\n@@ -1293,1 +1302,7 @@\n-\n+            if (longMech == CKM_AES_CTS && token.ctsVariant == null) {\n+                if (showInfo) {\n+                    System.out.println(\"DISABLED due to an unspecified \" +\n+                            \"cipherTextStealingVariant in configuration\");\n+                }\n+                continue;\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+    public enum CTSVariant {CS1, CS2, CS3}\n@@ -68,0 +69,2 @@\n+    final transient CTSVariant ctsVariant;\n+\n@@ -149,0 +152,1 @@\n+        ctsVariant = getCTSVariant();\n@@ -415,0 +419,13 @@\n+    private CTSVariant getCTSVariant() {\n+        CTSVariant ctsVariant = config.getCTSVariant();\n+        if (ctsVariant != null) {\n+            return ctsVariant;\n+        }\n+        \/\/ 'cipherTextStealingVariant' needs an explicit value for the\n+        \/\/ CKM_AES_CTS mechanism to be enabled. In the case of NSS we know\n+        \/\/ that this value is 'CS1', so we can set it for the user. See:\n+        \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=373108#c7\n+        \/\/ https:\/\/github.com\/nss-dev\/nss\/blob\/NSS_3_99_RTM\/lib\/freebl\/cts.c#L65\n+        return P11Util.isNSS(this) ? CTSVariant.CS1 : null;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-import sun.jvm.hotspot.gc.g1.HeapRegionClosure;\n-import sun.jvm.hotspot.gc.g1.PrintRegionClosure;\n+import sun.jvm.hotspot.gc.g1.G1HeapRegionClosure;\n+import sun.jvm.hotspot.gc.g1.G1PrintRegionClosure;\n@@ -50,1 +50,1 @@\n-    \/\/ HeapRegionManager _hrm;\n+    \/\/ G1HeapRegionManager _hrm;\n@@ -58,1 +58,1 @@\n-    \/\/ HeapRegionSet _old_set;\n+    \/\/ G1HeapRegionSet _old_set;\n@@ -60,1 +60,1 @@\n-    \/\/ HeapRegionSet _humongous_set;\n+    \/\/ G1HeapRegionSet _humongous_set;\n@@ -93,1 +93,1 @@\n-    public HeapRegionManager hrm() {\n+    public G1HeapRegionManager hrm() {\n@@ -95,1 +95,1 @@\n-        return VMObjectFactory.newObject(HeapRegionManager.class, hrmAddr);\n+        return VMObjectFactory.newObject(G1HeapRegionManager.class, hrmAddr);\n@@ -103,1 +103,1 @@\n-    public HeapRegionSetBase oldSet() {\n+    public G1HeapRegionSetBase oldSet() {\n@@ -105,1 +105,1 @@\n-        return VMObjectFactory.newObject(HeapRegionSetBase.class, oldSetAddr);\n+        return VMObjectFactory.newObject(G1HeapRegionSetBase.class, oldSetAddr);\n@@ -108,1 +108,1 @@\n-    public HeapRegionSetBase humongousSet() {\n+    public G1HeapRegionSetBase humongousSet() {\n@@ -110,1 +110,1 @@\n-        return VMObjectFactory.newObject(HeapRegionSetBase.class, humongousSetAddr);\n+        return VMObjectFactory.newObject(G1HeapRegionSetBase.class, humongousSetAddr);\n@@ -117,1 +117,1 @@\n-    public void heapRegionIterate(HeapRegionClosure hrcl) {\n+    public void heapRegionIterate(G1HeapRegionClosure hrcl) {\n@@ -162,1 +162,1 @@\n-        PrintRegionClosure prc = new PrintRegionClosure(tty);\n+        G1PrintRegionClosure prc = new G1PrintRegionClosure(tty);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1CollectedHeap.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private HeapRegionType type;\n+    private G1HeapRegionType type;\n@@ -91,1 +91,1 @@\n-        type = VMObjectFactory.newObject(HeapRegionType.class, typeAddr);\n+        type = VMObjectFactory.newObject(G1HeapRegionType.class, typeAddr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.g1;\n+\n+public interface G1HeapRegionClosure {\n+    public void doHeapRegion(G1HeapRegion hr);\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionClosure.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/ Mirror class for HeapRegionManager.\n+\/\/ Mirror class for G1HeapRegionManager.\n@@ -42,1 +42,1 @@\n-public class HeapRegionManager extends VMObject {\n+public class G1HeapRegionManager extends VMObject {\n@@ -55,1 +55,1 @@\n-        Type type = db.lookupType(\"HeapRegionManager\");\n+        Type type = db.lookupType(\"G1HeapRegionManager\");\n@@ -77,1 +77,1 @@\n-    public HeapRegionManager(Address addr) {\n+    public G1HeapRegionManager(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionManager.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionManager.java","status":"renamed"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/ Mirror class for HeapRegionSetBase. Represents a group of regions.\n+\/\/ Mirror class for G1HeapRegionSetBase. Represents a group of regions.\n@@ -42,1 +42,1 @@\n-public class HeapRegionSetBase extends VMObject {\n+public class G1HeapRegionSetBase extends VMObject {\n@@ -56,1 +56,1 @@\n-        Type type = db.lookupType(\"HeapRegionSetBase\");\n+        Type type = db.lookupType(\"G1HeapRegionSetBase\");\n@@ -65,1 +65,1 @@\n-    public HeapRegionSetBase(Address addr) {\n+    public G1HeapRegionSetBase(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionSetBase.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionSetBase.java","status":"renamed"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.g1;\n+\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+\/\/ Mirror class for G1HeapRegionType. Currently we don't actually include\n+\/\/ any of its fields but only iterate over it.\n+\n+public class G1HeapRegionType extends VMObject {\n+\n+    private static int freeTag;\n+    private static int youngMask;\n+    private static int edenTag;\n+    private static int survTag;\n+    private static int humongousMask;\n+    private static int startsHumongousTag;\n+    private static int continuesHumongousTag;\n+    private static int oldMask;\n+    private static CIntegerField tagField;\n+    private int tag;\n+\n+    static {\n+        VM.registerVMInitializedObserver(new Observer() {\n+                public void update(Observable o, Object data) {\n+                    initialize(VM.getVM().getTypeDataBase());\n+                }\n+        });\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"G1HeapRegionType\");\n+\n+        tagField = type.getCIntegerField(\"_tag\");\n+\n+        freeTag = db.lookupIntConstant(\"G1HeapRegionType::FreeTag\");\n+        youngMask = db.lookupIntConstant(\"G1HeapRegionType::YoungMask\");\n+        edenTag = db.lookupIntConstant(\"G1HeapRegionType::EdenTag\");\n+        survTag = db.lookupIntConstant(\"G1HeapRegionType::SurvTag\");\n+        startsHumongousTag = db.lookupIntConstant(\"G1HeapRegionType::StartsHumongousTag\");\n+        continuesHumongousTag = db.lookupIntConstant(\"G1HeapRegionType::ContinuesHumongousTag\");\n+        humongousMask = db.lookupIntConstant(\"G1HeapRegionType::HumongousMask\");\n+        oldMask = db.lookupIntConstant(\"G1HeapRegionType::OldMask\");\n+    }\n+\n+    public boolean isFree() {\n+        return tagField.getValue(addr) == freeTag;\n+    }\n+\n+    public boolean isEden() {\n+        return tagField.getValue(addr) == edenTag;\n+    }\n+\n+    public boolean isSurvivor() {\n+        return tagField.getValue(addr) == survTag;\n+    }\n+\n+    public boolean isYoung() {\n+        return (tagField.getValue(addr) & youngMask) != 0;\n+    }\n+\n+    public boolean isHumongous() {\n+        return (tagField.getValue(addr) & humongousMask) != 0;\n+    }\n+\n+    public boolean isStartsHumongous() {\n+        return tagField.getValue(addr) == startsHumongousTag;\n+    }\n+\n+    public boolean isContinuesHumongous() {\n+        return tagField.getValue(addr) == continuesHumongousTag;\n+    }\n+\n+    public boolean isOld() {\n+        return (tagField.getValue(addr) & oldMask) != 0;\n+    }\n+\n+    public G1HeapRegionType(Address addr) {\n+        super(addr);\n+    }\n+\n+    public String typeAnnotation() {\n+        if (isFree()) {\n+            return \"Free\";\n+        }\n+        if (isEden()) {\n+            return \"Eden\";\n+        }\n+        if (isSurvivor()) {\n+            return \"Survivor\";\n+        }\n+        if (isStartsHumongous()) {\n+            return \"StartsHumongous\";\n+        }\n+        if (isContinuesHumongous()) {\n+            return \"ContinuesHumongous\";\n+        }\n+        if (isOld()) {\n+            return \"Old\";\n+        }\n+        return \"Unknown Region Type\";\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionType.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-public class PrintRegionClosure implements HeapRegionClosure {\n+public class G1PrintRegionClosure implements G1HeapRegionClosure {\n@@ -33,1 +33,1 @@\n-    public PrintRegionClosure(PrintStream tty) {\n+    public G1PrintRegionClosure(PrintStream tty) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1PrintRegionClosure.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/PrintRegionClosure.java","status":"renamed"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.g1;\n-\n-public interface HeapRegionClosure {\n-    public void doHeapRegion(G1HeapRegion hr);\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionClosure.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.g1;\n-\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-import sun.jvm.hotspot.debugger.Address;\n-import sun.jvm.hotspot.runtime.VM;\n-import sun.jvm.hotspot.runtime.VMObject;\n-import sun.jvm.hotspot.types.CIntegerField;\n-import sun.jvm.hotspot.types.Type;\n-import sun.jvm.hotspot.types.TypeDataBase;\n-\n-\/\/ Mirror class for HeapRegionType. Currently we don't actually include\n-\/\/ any of its fields but only iterate over it.\n-\n-public class HeapRegionType extends VMObject {\n-\n-    private static int freeTag;\n-    private static int youngMask;\n-    private static int edenTag;\n-    private static int survTag;\n-    private static int humongousMask;\n-    private static int startsHumongousTag;\n-    private static int continuesHumongousTag;\n-    private static int oldMask;\n-    private static CIntegerField tagField;\n-    private int tag;\n-\n-    static {\n-        VM.registerVMInitializedObserver(new Observer() {\n-                public void update(Observable o, Object data) {\n-                    initialize(VM.getVM().getTypeDataBase());\n-                }\n-        });\n-    }\n-\n-    private static synchronized void initialize(TypeDataBase db) {\n-        Type type = db.lookupType(\"HeapRegionType\");\n-\n-        tagField = type.getCIntegerField(\"_tag\");\n-\n-        freeTag = db.lookupIntConstant(\"HeapRegionType::FreeTag\");\n-        youngMask = db.lookupIntConstant(\"HeapRegionType::YoungMask\");\n-        edenTag = db.lookupIntConstant(\"HeapRegionType::EdenTag\");\n-        survTag = db.lookupIntConstant(\"HeapRegionType::SurvTag\");\n-        startsHumongousTag = db.lookupIntConstant(\"HeapRegionType::StartsHumongousTag\");\n-        continuesHumongousTag = db.lookupIntConstant(\"HeapRegionType::ContinuesHumongousTag\");\n-        humongousMask = db.lookupIntConstant(\"HeapRegionType::HumongousMask\");\n-        oldMask = db.lookupIntConstant(\"HeapRegionType::OldMask\");\n-    }\n-\n-    public boolean isFree() {\n-        return tagField.getValue(addr) == freeTag;\n-    }\n-\n-    public boolean isEden() {\n-        return tagField.getValue(addr) == edenTag;\n-    }\n-\n-    public boolean isSurvivor() {\n-        return tagField.getValue(addr) == survTag;\n-    }\n-\n-    public boolean isYoung() {\n-        return (tagField.getValue(addr) & youngMask) != 0;\n-    }\n-\n-    public boolean isHumongous() {\n-        return (tagField.getValue(addr) & humongousMask) != 0;\n-    }\n-\n-    public boolean isStartsHumongous() {\n-        return tagField.getValue(addr) == startsHumongousTag;\n-    }\n-\n-    public boolean isContinuesHumongous() {\n-        return tagField.getValue(addr) == continuesHumongousTag;\n-    }\n-\n-    public boolean isOld() {\n-        return (tagField.getValue(addr) & oldMask) != 0;\n-    }\n-\n-    public HeapRegionType(Address addr) {\n-        super(addr);\n-    }\n-\n-    public String typeAnnotation() {\n-        if (isFree()) {\n-            return \"Free\";\n-        }\n-        if (isEden()) {\n-            return \"Eden\";\n-        }\n-        if (isSurvivor()) {\n-            return \"Survivor\";\n-        }\n-        if (isStartsHumongous()) {\n-            return \"StartsHumongous\";\n-        }\n-        if (isContinuesHumongous()) {\n-            return \"ContinuesHumongous\";\n-        }\n-        if (isOld()) {\n-            return \"Old\";\n-        }\n-        return \"Unknown Region Type\";\n-    }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionType.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -60,1 +60,0 @@\n-  private static int CLASS_STATE_BEING_LINKED;\n@@ -104,1 +103,0 @@\n-    CLASS_STATE_BEING_LINKED = db.lookupIntConstant(\"InstanceKlass::being_linked\").intValue();\n@@ -161,1 +159,0 @@\n-     public static final ClassState BEING_LINKED = new ClassState(\"beingLinked\");\n@@ -185,2 +182,0 @@\n-     } else if (state == CLASS_STATE_BEING_LINKED) {\n-        return ClassState.BEING_LINKED;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-      if (getMethod().getName().asString().equals(\"wait\") &&\n+      if (getMethod().getName().asString().equals(\"wait0\") &&\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaVFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,2 +255,2 @@\n-      HeapRegionSetBase oldSet = g1h.oldSet();\n-      HeapRegionSetBase humongousSet = g1h.humongousSet();\n+      G1HeapRegionSetBase oldSet = g1h.oldSet();\n+      G1HeapRegionSetBase humongousSet = g1h.humongousSet();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        String path = System.getenv(\"PATH\");\n+        String path = \"\/usr\/bin\" + File.pathSeparator + \"\/bin\";\/\/was: System.getenv(\"PATH\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.jdeps;\n@@ -40,1 +41,2 @@\n-        jdk.jpackage;\n+        jdk.jpackage,\n+        jdk.jdeps;\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,0 +69,18 @@\n+    public static final Register r16 = new Register(16, 16, \"r16\", CPU);\n+    public static final Register r17 = new Register(17, 17, \"r17\", CPU);\n+    public static final Register r18 = new Register(18, 18, \"r18\", CPU);\n+    public static final Register r19 = new Register(19, 19, \"r19\", CPU);\n+    public static final Register r20 = new Register(20, 20, \"r20\", CPU);\n+    public static final Register r21 = new Register(21, 21, \"r21\", CPU);\n+    public static final Register r22 = new Register(22, 22, \"r22\", CPU);\n+    public static final Register r23 = new Register(23, 23, \"r23\", CPU);\n+    public static final Register r24 = new Register(24, 24, \"r24\", CPU);\n+    public static final Register r25 = new Register(25, 25, \"r25\", CPU);\n+    public static final Register r26 = new Register(26, 26, \"r26\", CPU);\n+    public static final Register r27 = new Register(27, 27, \"r27\", CPU);\n+    public static final Register r28 = new Register(28, 28, \"r28\", CPU);\n+    public static final Register r29 = new Register(29, 29, \"r29\", CPU);\n+    public static final Register r30 = new Register(30, 30, \"r30\", CPU);\n+    public static final Register r31 = new Register(31, 31, \"r31\", CPU);\n+\n+    \/\/ The set of common CPU registers available on all x64 platforms.\n@@ -77,35 +95,35 @@\n-    public static final Register xmm0 = new Register(16, 0, \"xmm0\", XMM);\n-    public static final Register xmm1 = new Register(17, 1, \"xmm1\", XMM);\n-    public static final Register xmm2 = new Register(18, 2, \"xmm2\", XMM);\n-    public static final Register xmm3 = new Register(19, 3, \"xmm3\", XMM);\n-    public static final Register xmm4 = new Register(20, 4, \"xmm4\", XMM);\n-    public static final Register xmm5 = new Register(21, 5, \"xmm5\", XMM);\n-    public static final Register xmm6 = new Register(22, 6, \"xmm6\", XMM);\n-    public static final Register xmm7 = new Register(23, 7, \"xmm7\", XMM);\n-\n-    public static final Register xmm8  = new Register(24,  8, \"xmm8\",  XMM);\n-    public static final Register xmm9  = new Register(25,  9, \"xmm9\",  XMM);\n-    public static final Register xmm10 = new Register(26, 10, \"xmm10\", XMM);\n-    public static final Register xmm11 = new Register(27, 11, \"xmm11\", XMM);\n-    public static final Register xmm12 = new Register(28, 12, \"xmm12\", XMM);\n-    public static final Register xmm13 = new Register(29, 13, \"xmm13\", XMM);\n-    public static final Register xmm14 = new Register(30, 14, \"xmm14\", XMM);\n-    public static final Register xmm15 = new Register(31, 15, \"xmm15\", XMM);\n-\n-    public static final Register xmm16 = new Register(32, 16, \"xmm16\", XMM);\n-    public static final Register xmm17 = new Register(33, 17, \"xmm17\", XMM);\n-    public static final Register xmm18 = new Register(34, 18, \"xmm18\", XMM);\n-    public static final Register xmm19 = new Register(35, 19, \"xmm19\", XMM);\n-    public static final Register xmm20 = new Register(36, 20, \"xmm20\", XMM);\n-    public static final Register xmm21 = new Register(37, 21, \"xmm21\", XMM);\n-    public static final Register xmm22 = new Register(38, 22, \"xmm22\", XMM);\n-    public static final Register xmm23 = new Register(39, 23, \"xmm23\", XMM);\n-\n-    public static final Register xmm24 = new Register(40, 24, \"xmm24\", XMM);\n-    public static final Register xmm25 = new Register(41, 25, \"xmm25\", XMM);\n-    public static final Register xmm26 = new Register(42, 26, \"xmm26\", XMM);\n-    public static final Register xmm27 = new Register(43, 27, \"xmm27\", XMM);\n-    public static final Register xmm28 = new Register(44, 28, \"xmm28\", XMM);\n-    public static final Register xmm29 = new Register(45, 29, \"xmm29\", XMM);\n-    public static final Register xmm30 = new Register(46, 30, \"xmm30\", XMM);\n-    public static final Register xmm31 = new Register(47, 31, \"xmm31\", XMM);\n+    public static final Register xmm0 = new Register(32, 0, \"xmm0\", XMM);\n+    public static final Register xmm1 = new Register(33, 1, \"xmm1\", XMM);\n+    public static final Register xmm2 = new Register(34, 2, \"xmm2\", XMM);\n+    public static final Register xmm3 = new Register(35, 3, \"xmm3\", XMM);\n+    public static final Register xmm4 = new Register(36, 4, \"xmm4\", XMM);\n+    public static final Register xmm5 = new Register(37, 5, \"xmm5\", XMM);\n+    public static final Register xmm6 = new Register(38, 6, \"xmm6\", XMM);\n+    public static final Register xmm7 = new Register(39, 7, \"xmm7\", XMM);\n+\n+    public static final Register xmm8  = new Register(40,  8, \"xmm8\",  XMM);\n+    public static final Register xmm9  = new Register(41,  9, \"xmm9\",  XMM);\n+    public static final Register xmm10 = new Register(42, 10, \"xmm10\", XMM);\n+    public static final Register xmm11 = new Register(43, 11, \"xmm11\", XMM);\n+    public static final Register xmm12 = new Register(44, 12, \"xmm12\", XMM);\n+    public static final Register xmm13 = new Register(45, 13, \"xmm13\", XMM);\n+    public static final Register xmm14 = new Register(46, 14, \"xmm14\", XMM);\n+    public static final Register xmm15 = new Register(47, 15, \"xmm15\", XMM);\n+\n+    public static final Register xmm16 = new Register(48, 16, \"xmm16\", XMM);\n+    public static final Register xmm17 = new Register(49, 17, \"xmm17\", XMM);\n+    public static final Register xmm18 = new Register(50, 18, \"xmm18\", XMM);\n+    public static final Register xmm19 = new Register(51, 19, \"xmm19\", XMM);\n+    public static final Register xmm20 = new Register(52, 20, \"xmm20\", XMM);\n+    public static final Register xmm21 = new Register(53, 21, \"xmm21\", XMM);\n+    public static final Register xmm22 = new Register(54, 22, \"xmm22\", XMM);\n+    public static final Register xmm23 = new Register(55, 23, \"xmm23\", XMM);\n+\n+    public static final Register xmm24 = new Register(56, 24, \"xmm24\", XMM);\n+    public static final Register xmm25 = new Register(57, 25, \"xmm25\", XMM);\n+    public static final Register xmm26 = new Register(58, 26, \"xmm26\", XMM);\n+    public static final Register xmm27 = new Register(59, 27, \"xmm27\", XMM);\n+    public static final Register xmm28 = new Register(60, 28, \"xmm28\", XMM);\n+    public static final Register xmm29 = new Register(61, 29, \"xmm29\", XMM);\n+    public static final Register xmm30 = new Register(62, 30, \"xmm30\", XMM);\n+    public static final Register xmm31 = new Register(63, 31, \"xmm31\", XMM);\n@@ -127,8 +145,8 @@\n-    public static final Register k0 = new Register(48, 0, \"k0\", MASK);\n-    public static final Register k1 = new Register(49, 1, \"k1\", MASK);\n-    public static final Register k2 = new Register(50, 2, \"k2\", MASK);\n-    public static final Register k3 = new Register(51, 3, \"k3\", MASK);\n-    public static final Register k4 = new Register(52, 4, \"k4\", MASK);\n-    public static final Register k5 = new Register(53, 5, \"k5\", MASK);\n-    public static final Register k6 = new Register(54, 6, \"k6\", MASK);\n-    public static final Register k7 = new Register(55, 7, \"k7\", MASK);\n+    public static final Register k0 = new Register(64, 0, \"k0\", MASK);\n+    public static final Register k1 = new Register(65, 1, \"k1\", MASK);\n+    public static final Register k2 = new Register(66, 2, \"k2\", MASK);\n+    public static final Register k3 = new Register(67, 3, \"k3\", MASK);\n+    public static final Register k4 = new Register(68, 4, \"k4\", MASK);\n+    public static final Register k5 = new Register(69, 5, \"k5\", MASK);\n+    public static final Register k6 = new Register(70, 6, \"k6\", MASK);\n+    public static final Register k7 = new Register(71, 7, \"k7\", MASK);\n@@ -156,1 +174,1 @@\n-    public static final Register rip = new Register(56, -1, \"rip\", SPECIAL);\n+    public static final Register rip = new Register(72, -1, \"rip\", SPECIAL);\n@@ -161,0 +179,2 @@\n+        r16,  r17,  r18,   r19,   r20,   r21,   r22,   r23,\n+        r24,  r25,  r26,   r27,   r28,   r29,   r30,   r31,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":64,"deletions":44,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -84,0 +85,7 @@\n+        \/\/ registers is expected to mention all registers in order of their encoding.\n+        for (int i = 0; i < registers.size(); ++i) {\n+            if (registers.get(i).number != i) {\n+                Register reg = registers.get(i);\n+                throw new JVMCIError(\"%s: %d != %d\", reg, reg.number, i);\n+            }\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/Architecture.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,3 +111,0 @@\n-    \/\/ This field is being kept around for compatibility with libgraal\n-    @SuppressWarnings(\"unused\") private long oopSizeOffset;\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJDKReflection.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -149,0 +149,2 @@\n+        } else if (intrinsicId == config.vmIntrinsicLinkToNative) {\n+            return IntrinsicMethod.LINK_TO_NATIVE;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodHandleAccessProvider.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+    final int vmIntrinsicLinkToNative = getConstant(\"vmIntrinsics::_linkToNative\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,3 @@\n-        LINK_TO_INTERFACE\n+        LINK_TO_INTERFACE,\n+        \/** The method {@code MethodHandle.linkToNative}. *\/\n+        LINK_TO_NATIVE\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/MethodHandleAccessProvider.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import sun.security.tools.PathList;\n@@ -42,1 +41,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -45,2 +43,0 @@\n-import java.net.URL;\n-import java.net.URLClassLoader;\n@@ -495,1 +491,1 @@\n-    private boolean extraAttrsDetected;\n+    private boolean externalFileAttributesDetected;\n@@ -939,3 +935,3 @@\n-        int extraAttrs = JUZFA.getExtraAttributes(ze);\n-        if (!extraAttrsDetected && extraAttrs != -1) {\n-            extraAttrsDetected = true;\n+        int externalFileAttributes = JUZFA.getExternalFileAttributes(ze);\n+        if (!externalFileAttributesDetected && externalFileAttributes != -1) {\n+            externalFileAttributesDetected = true;\n@@ -944,1 +940,1 @@\n-        JUZFA.setExtraAttributes(ze2, extraAttrs);\n+        JUZFA.setExternalFileAttributes(ze2, externalFileAttributes);\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-    private static boolean extraAttrsDetected;\n+    private static boolean externalFileAttributesDetected;\n@@ -826,2 +826,2 @@\n-                    if (!extraAttrsDetected && JUZFA.getExtraAttributes(je) != -1) {\n-                        extraAttrsDetected = true;\n+                    if (!externalFileAttributesDetected && JUZFA.getExternalFileAttributes(je) != -1) {\n+                        externalFileAttributesDetected = true;\n@@ -1314,2 +1314,2 @@\n-        if (extraAttrsDetected) {\n-            warnings.add(rb.getString(\"extra.attributes.detected\"));\n+        if (externalFileAttributesDetected) {\n+            warnings.add(rb.getString(\"external.file.attributes.detected\"));\n@@ -1949,1 +1949,1 @@\n-                    (t, o) -> extraAttrsDetected = true);\n+                    (t, o) -> externalFileAttributesDetected = true);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"POSIX file permission and\/or symlink attributes detected. These attributes are ignored when signing and are not protected by the signature.\"},\n+        {\"external.file.attributes.detected\", \"POSIX file permission and\/or symlink attributes detected. These attributes are ignored when signing and are not protected by the signature.\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"POSIX-Dateiberechtigung und\/oder Symlink-Attribute erkannt. Diese Attribute werden bei der Signatur ignoriert und sind nicht durch die Signatur gesch\\u00FCtzt.\"},\n+        {\"external.file.attributes.detected\", \"POSIX-Dateiberechtigung und\/oder Symlink-Attribute erkannt. Diese Attribute werden bei der Signatur ignoriert und sind nicht durch die Signatur gesch\\u00FCtzt.\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_de.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"POSIX\\u30D5\\u30A1\\u30A4\\u30EB\\u6A29\\u9650\\u307E\\u305F\\u306Fsymlink(\\u3042\\u308B\\u3044\\u306F\\u305D\\u306E\\u4E21\\u65B9)\\u306E\\u5C5E\\u6027\\u304C\\u691C\\u51FA\\u3055\\u308C\\u307E\\u3057\\u305F\\u3002\\u7F72\\u540D\\u4E2D\\u306F\\u3053\\u308C\\u3089\\u306E\\u5C5E\\u6027\\u306F\\u7121\\u8996\\u3055\\u308C\\u3001\\u7F72\\u540D\\u306B\\u3088\\u3063\\u3066\\u4FDD\\u8B77\\u3055\\u308C\\u307E\\u305B\\u3093\\u3002\"},\n+        {\"external.file.attributes.detected\", \"POSIX\\u30D5\\u30A1\\u30A4\\u30EB\\u6A29\\u9650\\u307E\\u305F\\u306Fsymlink(\\u3042\\u308B\\u3044\\u306F\\u305D\\u306E\\u4E21\\u65B9)\\u306E\\u5C5E\\u6027\\u304C\\u691C\\u51FA\\u3055\\u308C\\u307E\\u3057\\u305F\\u3002\\u7F72\\u540D\\u4E2D\\u306F\\u3053\\u308C\\u3089\\u306E\\u5C5E\\u6027\\u306F\\u7121\\u8996\\u3055\\u308C\\u3001\\u7F72\\u540D\\u306B\\u3088\\u3063\\u3066\\u4FDD\\u8B77\\u3055\\u308C\\u307E\\u305B\\u3093\\u3002\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_ja.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-        {\"extra.attributes.detected\", \"\\u68C0\\u6D4B\\u5230 POSIX \\u6587\\u4EF6\\u6743\\u9650\\u548C\/\\u6216 symlink \\u5C5E\\u6027\\u3002\\u8FD9\\u4E9B\\u5C5E\\u6027\\u5728\\u8FDB\\u884C\\u7B7E\\u540D\\u65F6\\u4F1A\\u88AB\\u5FFD\\u7565\\uFF0C\\u4E0D\\u53D7\\u8BE5\\u7B7E\\u540D\\u7684\\u4FDD\\u62A4\\u3002\"},\n+        {\"external.file.attributes.detected\", \"\\u68C0\\u6D4B\\u5230 POSIX \\u6587\\u4EF6\\u6743\\u9650\\u548C\/\\u6216 symlink \\u5C5E\\u6027\\u3002\\u8FD9\\u4E9B\\u5C5E\\u6027\\u5728\\u8FDB\\u884C\\u7B7E\\u540D\\u65F6\\u4F1A\\u88AB\\u5FFD\\u7565\\uFF0C\\u4E0D\\u53D7\\u8BE5\\u7B7E\\u540D\\u7684\\u4FDD\\u62A4\\u3002\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_zh_CN.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-    flex: 2.6 1 0;\n+    flex: 3 1 0;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -693,1 +693,3 @@\n-            if (!name.toString().startsWith(\"on\")) {\n+            \/\/ custom \"data-*\" attributes are also accepted\n+            var attrName = name.toString();\n+            if (!attrName.startsWith(\"on\") && !attrName.startsWith(\"data-\")) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -437,0 +437,1 @@\n+        ACCESSKEY(true),\n@@ -440,15 +441,17 @@\n-        ARIA_ACTIVEDESCENDANT,\n-        ARIA_CONTROLS,\n-        ARIA_DESCRIBEDBY,\n-        ARIA_EXPANDED,\n-        ARIA_LABEL,\n-        ARIA_LABELLEDBY,\n-        ARIA_LEVEL,\n-        ARIA_MULTISELECTABLE,\n-        ARIA_OWNS,\n-        ARIA_POSINSET,\n-        ARIA_SETSIZE,\n-        ARIA_READONLY,\n-        ARIA_REQUIRED,\n-        ARIA_SELECTED,\n-        ARIA_SORT,\n+        ARIA_ACTIVEDESCENDANT(true),\n+        ARIA_CONTROLS(true),\n+        ARIA_DESCRIBEDBY(true),\n+        ARIA_EXPANDED(true),\n+        ARIA_LABEL(true),\n+        ARIA_LABELLEDBY(true),\n+        ARIA_LEVEL(true),\n+        ARIA_MULTISELECTABLE(true),\n+        ARIA_OWNS(true),\n+        ARIA_POSINSET(true),\n+        ARIA_READONLY(true),\n+        ARIA_REQUIRED(true),\n+        ARIA_SELECTED(true),\n+        ARIA_SETSIZE(true),\n+        ARIA_SORT(true),\n+        AUTOCAPITALIZE(true),\n+        AUTOFOCUS(true),\n@@ -459,1 +462,0 @@\n-        CELLSPACING,\n@@ -461,0 +463,1 @@\n+        CELLSPACING,\n@@ -465,0 +468,1 @@\n+        CLASS(true),\n@@ -466,1 +470,0 @@\n-        CLASS,\n@@ -470,0 +473,1 @@\n+        CONTENTEDITABLE(true),\n@@ -473,0 +477,3 @@\n+        DIR(true),\n+        DRAGGABLE(true),\n+        ENTERKEYHINT(true),\n@@ -478,0 +485,1 @@\n+        HIDDEN(true),\n@@ -480,1 +488,10 @@\n-        ID,\n+        ID(true),\n+        INERT(true),\n+        INPUTMODE(true),\n+        IS(true),\n+        ITEMID(true),\n+        ITEMPROP(true),\n+        ITEMREF(true),\n+        ITEMSCOPE(true),\n+        ITEMTYPE(true),\n+        LANG(true),\n@@ -486,0 +503,1 @@\n+        NONCE(true),\n@@ -488,0 +506,1 @@\n+        POPOVER(true),\n@@ -500,0 +519,1 @@\n+        SPELLCHECK(true),\n@@ -502,1 +522,1 @@\n-        STYLE,\n+        STYLE(true),\n@@ -504,0 +524,1 @@\n+        TABINDEX(true),\n@@ -506,0 +527,2 @@\n+        TITLE(true),\n+        TRANSLATE(true),\n@@ -512,1 +535,2 @@\n-        WIDTH;\n+        WIDTH,\n+        WRITINGSUGGESTIONS(true);\n@@ -515,0 +539,1 @@\n+        private final boolean isGlobal;\n@@ -517,0 +542,4 @@\n+            this(false);\n+        }\n+\n+        Attr(boolean flag) {\n@@ -518,0 +547,5 @@\n+            isGlobal = flag;\n+        }\n+\n+        public boolean isGlobal() {\n+            return isGlobal;\n@@ -635,2 +669,7 @@\n-        AttrKind k = attrs.get(getAttr(attrName)); \/\/ null-safe\n-        return (k == null) ? AttrKind.INVALID : k;\n+        Attr attr = getAttr(attrName);\n+        if (attr == null) {\n+            return AttrKind.INVALID;\n+        }\n+        return attr.isGlobal() ?\n+                AttrKind.OK :\n+                attrs.getOrDefault(attr, AttrKind.INVALID);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/HtmlTag.java","additions":62,"deletions":23,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-\\f[V]path-to-gc-root\\f[R]: (Optional) Flag for saving the path to\n+\\f[V]path-to-gc-roots\\f[R]: (Optional) Flag for saving the path to\n@@ -609,1 +609,1 @@\n-\\f[V]path-to-gc-root\\f[R]: (Optional) Flag for saving the path to\n+\\f[V]path-to-gc-roots\\f[R]: (Optional) Flag for saving the path to\n@@ -684,0 +684,49 @@\n+\\f[V]JFR.view\\f[R] [\\f[I]options\\f[R]]\n+Display event data in predefined views.\n+.RS\n+.PP\n+Impact: Medium\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The \\f[I]options\\f[R] must be specified using either \\f[I]key\\f[R] or\n+\\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+If no parameters are entered, then a list of available views are\n+displayed.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]cell-height\\f[R]: (Optional) Maximum number of rows in a table\n+cell.\n+(INT, default value depends on the view)\n+.IP \\[bu] 2\n+\\f[V]maxage\\f[R]: (Optional) Length of time for the view to span.\n+(INT followed by \\[aq]s\\[aq] for seconds \\[aq]m\\[aq] for minutes or\n+\\[aq]h\\[aq] for hours, default value is 10m)\n+.IP \\[bu] 2\n+\\f[V]maxsize\\f[R]: (Optional) Maximum size for the view to span in bytes\n+if one of the following suffixes is not used: \\[aq]m\\[aq] or \\[aq]M\\[aq]\n+for megabytes OR \\[aq]g\\[aq] or \\[aq]G\\[aq] for gigabytes.\n+(STRING, default value is 32MB)\n+.IP \\[bu] 2\n+\\f[V]truncate\\f[R]: (Optional) Maximum number of rows in a table cell.\n+(INT, default value depends on the view)\n+.IP \\[bu] 2\n+\\f[V]verbose\\f[R]: (Optional) Displays the query that makes up the view.\n+(BOOLEAN, default value is false)\n+.IP \\[bu] 2\n+\\f[V]width\\f[R]: (Optional) The width of the view in characters.\n+(INT, default value depends on the view)\n+.PP\n+\\f[I]arguments\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]view\\f[R]: Name of the view or event type to display.\n+Use \\f[V]help JFR.view\\f[R] to see a list of available views.\n+(STRING, no default value)\n+.PP\n+The view parameter can be an event type name.\n+Use \\f[V]JFR.view types\\f[R] to see a list.\n+To display all views, use \\f[V]JFR.view all-views\\f[R].\n+To display all events, use \\f[V]JFR.view all-events\\f[R].\n+.RE\n+.TP\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-                        for (var flag : info.flags()) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,6 @@\n+import java.lang.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.Set;\n@@ -41,0 +47,20 @@\n+    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n+\n+    static {\n+        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n+        for (var loc : AccessFlag.Location.values()) {\n+            map.put(loc, 0);\n+        }\n+\n+        for (var flag : AccessFlag.values()) {\n+            for (var loc : flag.locations()) {\n+                map.compute(loc, (_, v) -> v | flag.mask());\n+            }\n+        }\n+\n+        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n+        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n+\n+        LOCATION_MASKS = map;\n+    }\n+\n@@ -49,0 +75,14 @@\n+    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags) {\n+        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location());\n+    }\n+\n+    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location) {\n+        try {\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        } catch (IllegalArgumentException ex) {\n+            mask &= LOCATION_MASKS.get(location);\n+            report(\"Access Flags: \" + ex.getMessage());\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        }\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n@@ -451,1 +451,1 @@\n-                    flags.flags().stream().map(fl -> \"ACC_\" + fl.toString()).toList(),\n+                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.toString()).toList(),\n@@ -483,1 +483,1 @@\n-        for (var f : AccessFlags.ofMethod(flags).flags())\n+        for (var f : flagsReportUnknown(m.flags()))\n@@ -566,1 +566,1 @@\n-            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+            for (var f : flagsReportUnknown(m.flags())) {\n@@ -799,3 +799,3 @@\n-    private static Set<String> getClassModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n+    private Set<String> getClassModifiers(int mask) {\n+        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask)));\n@@ -814,8 +814,0 @@\n-    private static Set<String> getMethodModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofMethod(mask).flags());\n-    }\n-\n-    private static Set<String> getFieldModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofField(mask).flags());\n-    }\n-\n@@ -829,2 +821,2 @@\n-    private static Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+    private Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n@@ -833,2 +825,2 @@\n-    private static Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+    private Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n@@ -837,2 +829,2 @@\n-    private static Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+    private Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n@@ -855,36 +847,0 @@\n-    public static enum AccessFlag {\n-        ACC_PUBLIC      (ClassFile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n-        ACC_PRIVATE     (ClassFile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n-        ACC_PROTECTED   (ClassFile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n-        ACC_STATIC      (ClassFile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n-        ACC_FINAL       (ClassFile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n-        ACC_SUPER       (ClassFile.ACC_SUPER,        null,           true,  false, false, false),\n-        ACC_SYNCHRONIZED(ClassFile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n-        ACC_VOLATILE    (ClassFile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n-        ACC_BRIDGE      (ClassFile.ACC_BRIDGE,       null,           false, false, false, true ),\n-        ACC_TRANSIENT   (ClassFile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n-        ACC_VARARGS     (ClassFile.ACC_VARARGS,      null,           false, false, false, true ),\n-        ACC_NATIVE      (ClassFile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n-        ACC_INTERFACE   (ClassFile.ACC_INTERFACE,    null,           true,   true, false, false),\n-        ACC_ABSTRACT    (ClassFile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n-        ACC_STRICT      (ClassFile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n-        ACC_SYNTHETIC   (ClassFile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n-        ACC_ANNOTATION  (ClassFile.ACC_ANNOTATION,   null,           true,   true, false, false),\n-        ACC_ENUM        (ClassFile.ACC_ENUM,         null,           true,   true, true,  false),\n-        ACC_MODULE      (ClassFile.ACC_MODULE,       null,           true,  false, false, false);\n-\n-        public final int flag;\n-        public final String modifier;\n-        public final boolean isClass, isInnerClass, isField, isMethod;\n-\n-        AccessFlag(int flag, String modifier, boolean isClass,\n-                boolean isInnerClass, boolean isField, boolean isMethod) {\n-            this.flag = flag;\n-            this.modifier = modifier;\n-            this.isClass = isClass;\n-            this.isInnerClass = isInnerClass;\n-            this.isField = isField;\n-            this.isMethod = isMethod;\n-        }\n-    }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -870,1 +870,1 @@\n-                if (className.indexOf('.') > 0) {\n+                if (className.indexOf('.') > 0 || className.indexOf('\/') > 0) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -417,1 +417,1 @@\n-            JavaFileManager fm = pp.getPlatform(release, \"\").getFileManager();\n+            JavaFileManager fm = pp.getPlatformTrusted(release).getFileManager();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.JarFile;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipFile;\n+\n+sealed interface ClassFileSource {\n+    String moduleName();\n+    Path path();\n+\n+    Stream<byte[]> classFiles(Runtime.Version version) throws IOException;\n+\n+    record Module(ModuleReference reference) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return reference.descriptor().name();\n+        }\n+\n+        @Override\n+        public Path path() {\n+            URI location = reference.location().orElseThrow();\n+            return Path.of(location);\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            ModuleReader reader = reference().open();\n+            return reader.list()\n+                .filter(resourceName -> resourceName.endsWith(\".class\"))\n+                .map(resourceName -> {\n+                    try (InputStream stream = reader.open(resourceName).orElseThrow()) {\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).onClose(() -> {\n+                    try {\n+                        reader.close();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+\n+    record ClassPathJar(Path path) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return \"ALL-UNNAMED\";\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            JarFile jf = new JarFile(path().toFile(), false, ZipFile.OPEN_READ, version);\n+            return jf.versionedStream()\n+                .filter(je -> je.getName().endsWith(\".class\"))\n+                .map(je -> {\n+                    try (InputStream stream = jf.getInputStream(je)){\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).onClose(() -> {\n+                    try {\n+                        jf.close();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+\n+    record ClassPathDirectory(Path path) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return \"ALL-UNNAMED\";\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            return Files.walk(path)\n+                .filter(file -> Files.isRegularFile(file) && file.toString().endsWith(\".class\"))\n+                .map(file -> {\n+                    try (InputStream stream = Files.newInputStream(file)){\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassFileSource.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.javac.platform.PlatformDescription;\n+import com.sun.tools.javac.platform.PlatformProvider;\n+\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardLocation;\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Stream;\n+\n+abstract class ClassResolver implements AutoCloseable {\n+\n+    static ClassResolver forClassFileSources(List<ClassFileSource> sources, Runtime.Version version) throws IOException {\n+        Map<ClassDesc, Info> classMap = new HashMap<>();\n+        for (ClassFileSource source : sources) {\n+            try (Stream<byte[]> classFiles = source.classFiles(version)) {\n+                classFiles.forEach(bytes -> {\n+                    ClassModel model = ClassFile.of().parse(bytes);\n+                    ClassDesc desc = model.thisClass().asSymbol();\n+                    classMap.put(desc, new Info(source, model));\n+                });\n+            }\n+        }\n+        return new SimpleClassResolver(classMap);\n+    }\n+\n+    static ClassResolver forSystemModules(Runtime.Version version) {\n+        String platformName = String.valueOf(version.feature());\n+        PlatformProvider platformProvider = ServiceLoader.load(PlatformProvider.class).findFirst().orElseThrow();\n+        PlatformDescription platform;\n+        try {\n+            platform = platformProvider.getPlatform(platformName, null);\n+        } catch (PlatformProvider.PlatformNotSupported e) {\n+            throw new JNativeScanFatalError(\"Release: \" + platformName + \" not supported\", e);\n+        }\n+        JavaFileManager fm = platform.getFileManager();\n+        return new SystemModuleClassResolver(fm);\n+    }\n+\n+    record Info(ClassFileSource source, ClassModel model) {}\n+\n+    public abstract void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action);\n+    public abstract Optional<ClassResolver.Info> lookup(ClassDesc desc);\n+\n+    @Override\n+    public abstract void close() throws IOException;\n+\n+    private static class SimpleClassResolver extends ClassResolver {\n+\n+        private final Map<ClassDesc, ClassResolver.Info> classMap;\n+\n+        public SimpleClassResolver(Map<ClassDesc, Info> classMap) {\n+            this.classMap = classMap;\n+        }\n+\n+        public void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action) {\n+            classMap.forEach(action);\n+        }\n+\n+        public Optional<ClassResolver.Info> lookup(ClassDesc desc) {\n+            return Optional.ofNullable(classMap.get(desc));\n+        }\n+\n+        @Override\n+        public void close() {}\n+    }\n+\n+    private static class SystemModuleClassResolver extends ClassResolver {\n+\n+        private final JavaFileManager platformFileManager;\n+        private final Map<String, String> packageToSystemModule;\n+        private final Map<ClassDesc, Info> cache = new HashMap<>();\n+\n+        public SystemModuleClassResolver(JavaFileManager platformFileManager) {\n+            this.platformFileManager = platformFileManager;\n+            this.packageToSystemModule = packageToSystemModule(platformFileManager);\n+        }\n+\n+        private static Map<String, String> packageToSystemModule(JavaFileManager platformFileManager) {\n+            try {\n+                Set<JavaFileManager.Location> locations = platformFileManager.listLocationsForModules(\n+                        StandardLocation.SYSTEM_MODULES).iterator().next();\n+\n+                Map<String, String> result = new HashMap<>();\n+                for (JavaFileManager.Location loc : locations) {\n+                    JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, \"module-info\", JavaFileObject.Kind.CLASS);\n+                    ModuleDescriptor descriptor = ModuleDescriptor.read(jfo.openInputStream());\n+                    for (ModuleDescriptor.Exports export : descriptor.exports()) {\n+                        if (!export.isQualified()) {\n+                            result.put(export.source(), descriptor.name());\n+                        }\n+                    }\n+                }\n+                return result;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void forEach(BiConsumer<ClassDesc, Info> action) {\n+            throw new UnsupportedOperationException(\"NYI\");\n+        }\n+\n+        @Override\n+        public Optional<Info> lookup(ClassDesc desc) {\n+            return Optional.ofNullable(cache.computeIfAbsent(desc, _ -> {\n+                String qualName = JNativeScanTask.qualName(desc);\n+                String moduleName = packageToSystemModule.get(desc.packageName());\n+                if (moduleName != null) {\n+                    try {\n+                        JavaFileManager.Location loc = platformFileManager.getLocationForModule(StandardLocation.SYSTEM_MODULES, moduleName);\n+                        JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, qualName, JavaFileObject.Kind.CLASS);\n+                        if (jfo == null) {\n+                            throw new JNativeScanFatalError(\"System class can not be found: \" + qualName);\n+                        }\n+                        ClassModel model = ClassFile.of().parse(jfo.openInputStream().readAllBytes());\n+                        return new Info(null, model);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                return null;\n+            }));\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            platformFileManager.close();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassResolver.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.Serial;\n+\n+\/\/ Exception used in case of fatal error that is reasonably expected and handled.\n+public class JNativeScanFatalError extends RuntimeException {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    public JNativeScanFatalError(String message) {\n+        super(message);\n+    }\n+\n+    public JNativeScanFatalError(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public JNativeScanFatalError(Throwable cause) {\n+        super(cause);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanFatalError.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ResolvedModule;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+class JNativeScanTask {\n+\n+    private final PrintWriter out;\n+    private final List<Path> classPaths;\n+    private final List<Path> modulePaths;\n+    private final List<String> cmdRootModules;\n+    private final Runtime.Version version;\n+    private final Action action;\n+\n+    public JNativeScanTask(PrintWriter out, List<Path> classPaths, List<Path> modulePaths,\n+                           List<String> cmdRootModules, Runtime.Version version, Action action) {\n+        this.out = out;\n+        this.classPaths = classPaths;\n+        this.modulePaths = modulePaths;\n+        this.version = version;\n+        this.action = action;\n+        this.cmdRootModules = cmdRootModules;\n+    }\n+\n+    public void run() throws JNativeScanFatalError {\n+        List<ClassFileSource> toScan = new ArrayList<>(findAllClassPathJars());\n+\n+        ModuleFinder moduleFinder = ModuleFinder.of(modulePaths.toArray(Path[]::new));\n+        List<String> rootModules = cmdRootModules;\n+        if (rootModules.contains(\"ALL-MODULE-PATH\")) {\n+            rootModules = allModuleNames(moduleFinder);\n+        }\n+        Configuration config = systemConfiguration().resolveAndBind(ModuleFinder.of(), moduleFinder, rootModules);\n+        for (ResolvedModule m : config.modules()) {\n+            toScan.add(new ClassFileSource.Module(m.reference()));\n+        }\n+\n+        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods;\n+        try(ClassResolver classesToScan = ClassResolver.forClassFileSources(toScan, version);\n+            ClassResolver systemClassResolver = ClassResolver.forSystemModules(version)) {\n+            NativeMethodFinder finder = NativeMethodFinder.create(classesToScan, systemClassResolver);\n+            allRestrictedMethods = finder.findAll();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        switch (action) {\n+            case PRINT -> printNativeAccess(allRestrictedMethods);\n+            case DUMP_ALL -> dumpAll(allRestrictedMethods);\n+        }\n+    }\n+\n+    private List<ClassFileSource> findAllClassPathJars() throws JNativeScanFatalError {\n+        List<ClassFileSource> result = new ArrayList<>();\n+        for (Path path : classPaths) {\n+            if (isJarFile(path)) {\n+                Deque<Path> jarsToScan  = new ArrayDeque<>();\n+                jarsToScan.offer(path);\n+\n+                \/\/ recursively look for all class path jars, starting at the root jars\n+                \/\/ in this.classPaths, and recursively following all Class-Path manifest\n+                \/\/ attributes\n+                while (!jarsToScan.isEmpty()) {\n+                    Path jar = jarsToScan.poll();\n+                    String[] classPathAttribute = classPathAttribute(jar);\n+                    Path parentDir = jar.getParent();\n+                    for (String classPathEntry : classPathAttribute) {\n+                        Path otherJar = parentDir != null\n+                                ? parentDir.resolve(classPathEntry)\n+                                : Path.of(classPathEntry);\n+                        if (Files.exists(otherJar)) {\n+                            \/\/ Class-Path attribute specifies that jars that\n+                            \/\/ are not found are simply ignored. Do the same here\n+                            jarsToScan.offer(otherJar);\n+                        }\n+                    }\n+                    result.add(new ClassFileSource.ClassPathJar(jar));\n+                }\n+            } else if (Files.isDirectory(path)) {\n+                result.add(new ClassFileSource.ClassPathDirectory(path));\n+            } else {\n+                throw new JNativeScanFatalError(\n+                    \"Path does not appear to be a jar file, or directory containing classes: \" + path);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private String[] classPathAttribute(Path jar) {\n+        try (JarFile jf = new JarFile(jar.toFile(), false, ZipFile.OPEN_READ, version)) {\n+           Manifest manifest = jf.getManifest();\n+           if (manifest != null) {\n+               String attrib = manifest.getMainAttributes().getValue(\"Class-Path\");\n+               if (attrib != null) {\n+                   return attrib.split(\"\\\\s+\");\n+               }\n+           }\n+           return new String[0];\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private Configuration systemConfiguration() {\n+        ModuleFinder systemFinder = ModuleFinder.ofSystem();\n+        Configuration system = Configuration.resolve(systemFinder, List.of(Configuration.empty()), ModuleFinder.of(),\n+                allModuleNames(systemFinder)); \/\/ resolve all of them\n+        return system;\n+    }\n+\n+    private List<String> allModuleNames(ModuleFinder finder) {\n+        return finder.findAll().stream().map(mr -> mr.descriptor().name()).toList();\n+    }\n+\n+    private void printNativeAccess(SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+        String nativeAccess = allRestrictedMethods.keySet().stream()\n+                .map(ClassFileSource::moduleName)\n+                .distinct()\n+                .collect(Collectors.joining(\",\"));\n+        out.println(nativeAccess);\n+    }\n+\n+    private void dumpAll(SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+        if (allRestrictedMethods.isEmpty()) {\n+            out.println(\"  <no restricted methods>\");\n+        } else {\n+            allRestrictedMethods.forEach((module, perClass) -> {\n+                out.println(module.path() + \" (\" + module.moduleName() + \"):\");\n+                perClass.forEach((classDesc, restrictedUses) -> {\n+                    out.println(\"  \" + qualName(classDesc) + \":\");\n+                    restrictedUses.forEach(use -> {\n+                        switch (use) {\n+                            case RestrictedUse.NativeMethodDecl(MethodRef nmd) ->\n+                                out.println(\"    \" + nmd + \" is a native method declaration\");\n+                            case RestrictedUse.RestrictedMethodRefs(MethodRef referent, Set<MethodRef> referees) -> {\n+                                out.println(\"    \" + referent + \" references restricted methods:\");\n+                                referees.forEach(referee -> out.println(\"      \" + referee));\n+                            }\n+                        }\n+                    });\n+                });\n+            });\n+        }\n+    }\n+\n+    private static boolean isJarFile(Path path) throws JNativeScanFatalError {\n+        return Files.exists(path) && Files.isRegularFile(path) && path.toString().endsWith(\".jar\");\n+    }\n+\n+    public enum Action {\n+        DUMP_ALL,\n+        PRINT\n+    }\n+\n+    public static String qualName(ClassDesc desc) {\n+        String packagePrefix = desc.packageName().isEmpty() ? \"\" : desc.packageName() + \".\";\n+        return packagePrefix + desc.displayName();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanTask.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import jdk.internal.joptsimple.*;\n+import jdk.internal.opt.CommandLine;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.spi.ToolProvider;\n+\n+public class Main {\n+\n+    private static boolean DEBUG = Boolean.getBoolean(\"com.sun.tools.jnativescan.DEBUG\");\n+\n+    private static final int SUCCESS_CODE = 0;\n+    private static final int FATAL_ERROR_CODE = 1;\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    private Main(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    private void printError(String message) {\n+        err.println(\"ERROR: \" + message);\n+    }\n+\n+    private void printUsage()  {\n+        out.print(\"\"\"\n+            Use 'jnativescan --help' for help\n+            \"\"\");\n+    }\n+\n+    private void printVersion() {\n+        out.println(System.getProperty(\"java.version\"));\n+    }\n+\n+    public int run(String[] args) {\n+        if (args.length < 1) {\n+            printUsage();\n+            return FATAL_ERROR_CODE;\n+        }\n+\n+        try {\n+            String[] expandedArgs = expandArgFiles(args);\n+            parseOptionsAndRun(expandedArgs);\n+        } catch (JNativeScanFatalError fatalError) {\n+            printError(fatalError.getMessage());\n+            for (Throwable cause = fatalError.getCause();\n+                     cause instanceof JNativeScanFatalError jNativeScanFatalError;\n+                     cause = jNativeScanFatalError.getCause()) {\n+                err.println(\"CAUSED BY: \" + jNativeScanFatalError.getMessage());\n+            }\n+            if (DEBUG) {\n+                fatalError.printStackTrace(err);\n+            }\n+            return FATAL_ERROR_CODE;\n+        } catch (Throwable e) {\n+            printError(\"Unexpected exception encountered\");\n+            e.printStackTrace(err);\n+            return FATAL_ERROR_CODE;\n+        }\n+\n+        return SUCCESS_CODE;\n+    }\n+\n+    private void parseOptionsAndRun(String[] expandedArgs) throws JNativeScanFatalError {\n+        OptionParser parser = new OptionParser(false);\n+        OptionSpec<Void> helpOpt = parser.acceptsAll(List.of(\"?\", \"h\", \"help\"), \"help\").forHelp();\n+        OptionSpec<Void> versionOpt = parser.accepts(\"version\", \"Print version information and exit\");\n+        OptionSpec<Path> classPathOpt = parser.accepts(\n+                \"class-path\",\n+                \"The class path as used at runtime\")\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(File.pathSeparatorChar)\n+                .withValuesConvertedBy(PARSE_PATH);\n+        OptionSpec<Path> modulePathOpt = parser.accepts(\n+                \"module-path\",\n+                \"The module path as used at runtime\")\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(File.pathSeparatorChar)\n+                .withValuesConvertedBy(PARSE_PATH);\n+        OptionSpec<Runtime.Version> releaseOpt = parser.accepts(\n+                \"release\",\n+                \"The runtime version that will run the application\")\n+                .withRequiredArg()\n+                .withValuesConvertedBy(PARSE_VERSION);\n+        OptionSpec<String> addModulesOpt = parser.accepts(\n+                \"add-modules\",\n+                \"List of root modules to scan\")\n+                .requiredIf(modulePathOpt)\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(',');\n+        OptionSpec<Void> printNativeAccessOpt = parser.accepts(\n+                \"print-native-access\",\n+                \"print a comma separated list of modules that may perform native access operations.\" +\n+                        \" ALL-UNNAMED is used to indicate unnamed modules.\");\n+\n+        OptionSet optionSet;\n+        try {\n+            optionSet = parser.parse(expandedArgs);\n+        } catch (OptionException oe) {\n+            throw new JNativeScanFatalError(\"Parsing options failed: \" + oe.getMessage(), oe);\n+        }\n+\n+        if (optionSet.nonOptionArguments().size() != 0) {\n+            throw new JNativeScanFatalError(\"jnativescan does not accept positional arguments\");\n+        }\n+\n+        if (optionSet.has(helpOpt)) {\n+            out.println(\"\"\"\n+                The jnativescan tool can be used to find methods that may access native functionality when\n+                run. This includes restricted method calls and 'native' method declarations.\n+                \"\"\");\n+            try {\n+                parser.printHelpOn(out);\n+                return;\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        if (optionSet.has(versionOpt)) {\n+            printVersion();\n+            return;\n+        }\n+\n+        List<Path> classPathJars = optionSet.valuesOf(classPathOpt);\n+        List<Path> modulePaths = optionSet.valuesOf(modulePathOpt);\n+        List<String> rootModules = optionSet.valuesOf(addModulesOpt);\n+        Runtime.Version version = Optional.ofNullable(optionSet.valueOf(releaseOpt)).orElse(Runtime.version());\n+\n+        JNativeScanTask.Action action = JNativeScanTask.Action.DUMP_ALL;\n+        if (optionSet.has(printNativeAccessOpt)) {\n+            action = JNativeScanTask.Action.PRINT;\n+        }\n+\n+        new JNativeScanTask(out, classPathJars, modulePaths, rootModules, version, action).run();\n+    }\n+\n+    private static String[] expandArgFiles(String[] args) throws JNativeScanFatalError {\n+        try {\n+            return CommandLine.parse(args);\n+        } catch (IOException e) { \/\/ file not found\n+            throw new JNativeScanFatalError(e.getMessage(), e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.exit(new Main.Provider().run(System.out, System.err, args));\n+    }\n+\n+    public static class Provider implements ToolProvider {\n+\n+        @Override\n+        public String name() {\n+            return \"jnativescan\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            return new Main(out, err).run(args);\n+        }\n+    }\n+\n+    \/\/ where\n+    private static final ValueConverter<Path> PARSE_PATH = new ValueConverter<>() {\n+        @Override\n+        public Path convert(String value) {\n+            return Path.of(value);\n+        }\n+\n+        @Override\n+        public Class<? extends Path> valueType() {\n+            return Path.class;\n+        }\n+\n+        @Override\n+        public String valuePattern() {\n+            return \"Path\";\n+        }\n+    };\n+\n+    private static final ValueConverter<Runtime.Version> PARSE_VERSION = new ValueConverter<>() {\n+        @Override\n+        public Runtime.Version convert(String value) {\n+            try {\n+                return Runtime.Version.parse(value);\n+            } catch (IllegalArgumentException e) {\n+                throw new JNativeScanFatalError(\"Invalid release: \" + value + \": \" + e.getMessage());\n+            }\n+        }\n+\n+        @Override\n+        public Class<? extends Runtime.Version> valueType() {\n+            return Runtime.Version.class;\n+        }\n+\n+        @Override\n+        public String valuePattern() {\n+            return \"Version\";\n+        }\n+    };\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/Main.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+record MethodRef(ClassDesc owner, String name, MethodTypeDesc type) {\n+    public static MethodRef ofModel(MethodModel model) {\n+        return new MethodRef(model.parent().orElseThrow().thisClass().asSymbol(),\n+                model.methodName().stringValue(), model.methodTypeSymbol());\n+    }\n+\n+    public static MethodRef ofInvokeInstruction(InvokeInstruction instruction) {\n+        return new MethodRef(instruction.owner().asSymbol(),\n+                instruction.name().stringValue(), instruction.typeSymbol());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return JNativeScanTask.qualName(owner) + \"::\" + name + type.displayDescriptor();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/MethodRef.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.jnativescan.RestrictedUse.NativeMethodDecl;\n+import com.sun.tools.jnativescan.RestrictedUse.RestrictedMethodRefs;\n+\n+import java.io.IOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.*;\n+\n+class NativeMethodFinder {\n+\n+    \/\/ ct.sym uses this fake name for the restricted annotation instead\n+    \/\/ see make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java\n+    private static final String RESTRICTED_NAME = \"Ljdk\/internal\/javac\/Restricted+Annotation;\";\n+\n+    private final Map<MethodRef, Boolean> cache = new HashMap<>();\n+    private final ClassResolver classesToScan;\n+    private final ClassResolver systemClassResolver;\n+\n+    private NativeMethodFinder(ClassResolver classesToScan, ClassResolver systemClassResolver) {\n+        this.classesToScan = classesToScan;\n+        this.systemClassResolver = systemClassResolver;\n+    }\n+\n+    public static NativeMethodFinder create(ClassResolver classesToScan, ClassResolver systemClassResolver) throws JNativeScanFatalError, IOException {\n+        return new NativeMethodFinder(classesToScan, systemClassResolver);\n+    }\n+\n+    public SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n+        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> restrictedMethods\n+                = new TreeMap<>(Comparator.comparing(ClassFileSource::path));\n+        classesToScan.forEach((_, info) -> {\n+            ClassModel classModel = info.model();\n+            List<RestrictedUse> perClass = new ArrayList<>();\n+            classModel.methods().forEach(methodModel -> {\n+                if (methodModel.flags().has(AccessFlag.NATIVE)) {\n+                    perClass.add(new NativeMethodDecl(MethodRef.ofModel(methodModel)));\n+                } else {\n+                    SortedSet<MethodRef> perMethod = new TreeSet<>(Comparator.comparing(MethodRef::toString));\n+                    methodModel.code().ifPresent(code -> {\n+                         try {\n+                             code.forEach(e -> {\n+                                 switch (e) {\n+                                     case InvokeInstruction invoke -> {\n+                                         MethodRef ref = MethodRef.ofInvokeInstruction(invoke);\n+                                         if (isRestrictedMethod(ref)) {\n+                                             perMethod.add(ref);\n+                                         }\n+                                     }\n+                                     default -> {\n+                                     }\n+                                 }\n+                             });\n+                         } catch (JNativeScanFatalError e) {\n+                             throw new JNativeScanFatalError(\"Error while processing method: \" +\n+                                     MethodRef.ofModel(methodModel), e);\n+                         }\n+                    });\n+                    if (!perMethod.isEmpty()) {\n+                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel), perMethod));\n+                    }\n+                }\n+            });\n+            if (!perClass.isEmpty()) {\n+                restrictedMethods.computeIfAbsent(info.source(),\n+                                _ -> new TreeMap<>(Comparator.comparing(JNativeScanTask::qualName)))\n+                        .put(classModel.thisClass().asSymbol(), perClass);\n+            }\n+        });\n+        return restrictedMethods;\n+    }\n+\n+    private boolean isRestrictedMethod(MethodRef ref) throws JNativeScanFatalError {\n+        return cache.computeIfAbsent(ref, methodRef -> {\n+            if (methodRef.owner().isArray()) {\n+                \/\/ no restricted methods in arrays atm, and we can't look them up since they have no class file\n+                return false;\n+            }\n+            Optional<ClassResolver.Info> info = systemClassResolver.lookup(methodRef.owner());\n+            if (!info.isPresent()) {\n+                return false;\n+            }\n+            ClassModel classModel = info.get().model();\n+            Optional<MethodModel> methodModel = findMethod(classModel, methodRef.name(), methodRef.type());\n+            if (!methodModel.isPresent()) {\n+                \/\/ If we are here, the method was referenced through a subclass of the class containing the actual\n+                \/\/ method declaration. We could implement a method resolver (that needs to be version aware\n+                \/\/ as well) to find the method model of the declaration, but it's not really worth it.\n+                \/\/ None of the restricted methods (atm) are exposed through more than 1 public type, so it's not\n+                \/\/ possible for user code to reference them through a subclass.\n+                return false;\n+            }\n+\n+            return hasRestrictedAnnotation(methodModel.get());\n+        });\n+    }\n+\n+    private static boolean hasRestrictedAnnotation(MethodModel method) {\n+        return method.findAttribute(Attributes.runtimeVisibleAnnotations())\n+                .map(rva -> rva.annotations().stream().anyMatch(ann ->\n+                        ann.className().stringValue().equals(RESTRICTED_NAME)))\n+                .orElse(false);\n+    }\n+\n+    private static Optional<MethodModel> findMethod(ClassModel classModel, String name, MethodTypeDesc type) {\n+        return classModel.methods().stream()\n+                .filter(m -> m.methodName().stringValue().equals(name)\n+                        && m.methodType().stringValue().equals(type.descriptorString()))\n+                .findFirst();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/NativeMethodFinder.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.util.SortedSet;\n+\n+sealed interface RestrictedUse {\n+    record RestrictedMethodRefs(MethodRef referent, SortedSet<MethodRef> referees) implements RestrictedUse {}\n+    record NativeMethodDecl(MethodRef decl) implements RestrictedUse {}\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/RestrictedUse.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,3 @@\n- * <em>{@index javap javap tool}<\/em>, and\n- * <em>{@index jdeprscan jdeprscan tool}<\/em> tools.\n+ * <em>{@index javap javap tool}<\/em>,\n+ * <em>{@index jdeprscan jdeprscan tool}<\/em>, and\n+ * <em>{@index jnativescan jnativescan tool}<\/em> tools.\n@@ -36,1 +37,1 @@\n- * <em>javap<\/em> and <em>jdeps<\/em> tools via the\n+ * <em>javap<\/em>, <em>jdeps<\/em>, and <em>jnativescan<\/em> tools via the\n@@ -52,0 +53,1 @@\n+ * @toolGuide jnativescan\n@@ -54,2 +56,3 @@\n- *     Use {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"javap\")}\n- *     or {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jdeps\")}\n+ *     Use {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"javap\")},\n+ *     {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jdeps\")},\n+ *     or {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jnativescan\")}\n@@ -57,1 +60,1 @@\n- *     of command-line access to the {@code javap} or {@code jdeps} tool.\n+ *     of command-line access to the {@code javap}, {@code jdeps}, {@code jnativescan} tool.\n@@ -66,0 +69,3 @@\n+    requires jdk.internal.opt;\n+\n+    uses com.sun.tools.javac.platform.PlatformProvider;\n@@ -71,1 +77,2 @@\n-        com.sun.tools.jdeps.Main.JDepsToolProvider;\n+        com.sun.tools.jdeps.Main.JDepsToolProvider,\n+        com.sun.tools.jnativescan.Main.Provider;\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+.\\\" Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+.\\\"\n+.\\\" This code is free software; you can redistribute it and\/or modify it\n+.\\\" under the terms of the GNU General Public License version 2 only, as\n+.\\\" published by the Free Software Foundation.\n+.\\\"\n+.\\\" This code is distributed in the hope that it will be useful, but WITHOUT\n+.\\\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+.\\\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+.\\\" version 2 for more details (a copy is included in the LICENSE file that\n+.\\\" accompanied this code).\n+.\\\"\n+.\\\" You should have received a copy of the GNU General Public License version\n+.\\\" 2 along with this work; if not, write to the Free Software Foundation,\n+.\\\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+.\\\"\n+.\\\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+.\\\" or visit www.oracle.com if you need additional information or have any\n+.\\\" questions.\n+.\\\"\n+.\\\" Automatically generated by Pandoc 2.19.2\n+.\\\"\n+.\\\" Define V font for inline verbatim, using C font in formats\n+.\\\" that render this, and otherwise B font.\n+.ie \"\\f[CB]x\\f[R]\"x\" \\{\\\n+. ftr V B\n+. ftr VI BI\n+. ftr VB B\n+. ftr VBI BI\n+.\\}\n+.el \\{\\\n+. ftr V CR\n+. ftr VI CI\n+. ftr VB CB\n+. ftr VBI CBI\n+.\\}\n+.TH \"JNATIVESCAN\" \"1\" \"2025\" \"JDK 24-ea\" \"JDK Commands\"\n+.hy\n+.SH NAME\n+.PP\n+jnativescan - static analysis tool that scans one or more jar files for\n+uses of native functionalities, such as restricted method calls or\n+\\f[V]native\\f[R] method declarations.\n+.SH SYNOPSIS\n+.PP\n+\\f[V]jnativescan\\f[R] [\\f[I]options\\f[R]]\n+.TP\n+\\f[I]options\\f[R]\n+See \\f[B]Options for the jnativescan Command\\f[R]\n+.SH DESCRIPTION\n+.PP\n+The \\f[V]jnative\\f[R] tool is a static analysis tool provided by the JDK\n+that scans a JAR file for uses of native functionalities, such as\n+restricted method calls or \\f[V]native\\f[R] method declarations.\n+.PP\n+\\f[V]jnativescan\\f[R] accepts a runtime class path and module path\n+configuration, as well as a set of root modules, and a target release.\n+It scans the jars on the class and module paths, and reports uses of\n+native functionalities either in a tree like structure, which also\n+identifies that calling classes and methods, or as a list of module\n+names when the \\f[V]--print-native-access\\f[R] flag is specified.\n+.SH OPTIONS FOR THE JNATIVESCAN COMMAND\n+.PP\n+The following options are available:\n+.TP\n+\\f[V]--class-path\\f[R] \\f[I]path\\f[R]\n+Used to specify a list of paths pointing to jar files to be scanned.\n+.PP\n+All jar files specified through this list will be scanned.\n+If a jar file contains a \\f[V]Class-Path\\f[R] attribute in its manifest,\n+jar files listed there will be scanned as well.\n+Jar files listed in the \\f[V]Class-Path\\f[R] manifest attribute that can\n+not be found are ignored.\n+All the jar files found are treated as if they belonged to the unnamed\n+module.\n+.TP\n+\\f[V]--module-path\\f[R] \\f[I]path\\f[R]\n+Used to specify a list of paths pointing to jar files or directories\n+containing jar files, that the tool can use to find modules that need to\n+be scanned.\n+The list of jar files that will be scanned depends on the\n+\\f[V]--add-modules\\f[R] option.\n+.RS\n+.PP\n+For both the \\f[V]--class-path\\f[R] and \\f[V]--module-path\\f[R] options,\n+\\f[I]path\\f[R] should be a search path that consists of one or more jar\n+files, separated by the system-specific path separator.\n+For example:\n+.IP \\[bu] 2\n+\\f[B]Linux and macOS:\\f[R]\n+.RS 2\n+.RS\n+.PP\n+\\f[V]--class-path \/some\/foo.jar:\/another\/different\/bar.jar\\f[R]\n+.RE\n+.RE\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+On Windows, use a semicolon (\\f[V];\\f[R]) as the separator instead of a\n+colon (\\f[V]:\\f[R]).\n+.IP \\[bu] 2\n+\\f[B]Windows:\\f[R]\n+.RS 2\n+.RS\n+.PP\n+\\f[V]--class-path C:\\[rs]some\\[rs]foo.jar;C:\\[rs]another\\[rs]different\\[rs]bar.jar\\f[R]\n+.RE\n+.RE\n+.RE\n+.TP\n+\\f[V]--add-modules\\f[R] \\f[I]module[,module...]\\f[R]\n+Used to specify a comma-separated list of module names that indicate the\n+root modules to scan.\n+All the root modules will be scanned, as well as any modules that they\n+depend on.\n+This includes dependencies on service implementations specified through\n+the \\f[V]uses\\f[R] directive in a module\\[aq]s \\f[V]module-info\\f[R]\n+file.\n+All modules found on the module path that provide an implementation of\n+such a service will be scanned as well.\n+.TP\n+\\f[V]--release\\f[R] \\f[I]version\\f[R]\n+Used to specify the Java SE release that specifies the set of restricted\n+methods to scan for.\n+For multi-release jar files, this option also indicates the version of\n+class file that should be loaded from the jar.\n+This option should be set to the version of the runtime under which the\n+application is eventually intended to be run.\n+If this flag is omitted, the version of \\f[V]jnativescan\\f[R] is used as\n+release version, which is the same as the version of the JDK that the\n+tool belongs to.\n+.TP\n+\\f[V]--print-native-access\\f[R]\n+Print a comma-separated list of module names that use native\n+functionalities, instead of the default tree structure.\n+.TP\n+\\f[V]--help\\f[R] or \\f[V]-h\\f[R]\n+Prints out a full help message.\n+.TP\n+\\f[V]--version\\f[R]\n+Prints out the abbreviated version string of the tool.\n+.SH EXAMPLE OF \\f[V]jnativescan\\f[R] USE\n+.PP\n+\\f[V]jnativescan\\f[R] accepts a runtime configuration in the form of a\n+class path, module path, set of root modules, and a target release\n+version.\n+For the class path, the tool will scan all jar files, including those\n+found recursively through the \\f[V]Class-Path\\f[R] manifest attribute.\n+For the module path, the tool scans all root modules specified through\n+\\f[V]--add-modules\\f[R], and any (transitive) dependence of the root\n+modules, including any modules that contain service implementations that\n+are used by a scanned module.\n+.PP\n+By default, the tool prints out which jars, classes, and methods use\n+native functionalities, in a tree-like structure.\n+The following is an example output:\n+.IP\n+.nf\n+\\f[CB]\n+$ jnativescan --class-path app.jar\n+app.jar (ALL-UNNAMED):\n+  foo.Main:\n+    foo.Main::main(String[])void references restricted methods:\n+      java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\n+    foo.Main::nativeMethod()void is a native method declaration\n+\\f[R]\n+.fi\n+.PP\n+\\f[V]app.jar (ALL-UNNAMED)\\f[R] is the path to the jar file, with the\n+module name in parentheses behind it.\n+Since in this case the jar file appears on the class path,\n+\\f[V]ALL-UNNAMED\\f[R] is printed to indicate the unnamed module.\n+The second line of the output, \\f[V]foo.Main\\f[R], indicates that\n+methods using native functionalities were found in the\n+\\f[V]foo.Main\\f[R] class.\n+The next line:\n+.IP\n+.nf\n+\\f[CB]\n+    foo.Main::main(String[])void references restricted methods:\n+\\f[R]\n+.fi\n+.PP\n+Indicates that the \\f[V]main(String[])\\f[R] method in the\n+\\f[V]foo.Main\\f[R] class references a restricted method, which is listed\n+on the following line as:\n+.IP\n+.nf\n+\\f[CB]\n+      java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\n+\\f[R]\n+.fi\n+.PP\n+Lastly, the text:\n+.IP\n+.nf\n+\\f[CB]\n+    foo.Main::nativeMethod()void is a native method declaration\n+\\f[R]\n+.fi\n+.PP\n+Indicates that the \\f[V]foo.Main\\f[R] class contains a declaration of a\n+\\f[V]native\\f[R] method named \\f[V]nativeMethod\\f[R].\n+.PP\n+If we add \\f[V]--print-native-access\\f[R] to the example command line,\n+we instead get a list of the names of modules that contain accesses to\n+native functionalities:\n+.IP\n+.nf\n+\\f[CB]\n+$ jnativescan --class-path app.jar --print-native-access\n+ALL-UNNAMED\n+\\f[R]\n+.fi\n+.PP\n+In this case the output consists of just \\f[V]ALL-UNNAMED\\f[R], which\n+indicates a jar file on the class path, that is, in the unnamed module,\n+contains an access to native functionalities.\n","filename":"src\/jdk.jdeps\/share\/man\/jnativescan.1","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        return getTyped(\"modifiers\", Integer.class, -1);\n+        return getTyped(\"modifiers\", Integer.class, INTEGER_MINUS_ONE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        return getTyped(\"bytecodeIndex\", Integer.class, Integer.valueOf(-1));\n+        return getTyped(\"bytecodeIndex\", Integer.class, INTEGER_MINUS_ONE);\n@@ -78,1 +78,1 @@\n-        return getTyped(\"lineNumber\", Integer.class, Integer.valueOf(-1));\n+        return getTyped(\"lineNumber\", Integer.class, INTEGER_MINUS_ONE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedFrame.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-        return getTyped(\"modifiers\", Integer.class, Integer.valueOf(0));\n+        return getTyped(\"modifiers\", Integer.class, INTEGER_ZERO);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,3 @@\n+    static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n+    static final Integer INTEGER_ZERO = Integer.valueOf(0);\n+    static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        Long l = getTyped(\"osThreadId\", Long.class, -1L);\n+        Long l = getTyped(\"osThreadId\", Long.class, LONG_MINUS_ONE);\n@@ -95,1 +95,1 @@\n-        Long l = getTyped(\"javaThreadId\", Long.class, -1L);\n+        Long l = getTyped(\"javaThreadId\", Long.class, LONG_MINUS_ONE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedThread.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-public abstract class AbstractBufferStatisticsEvent extends AbstractPeriodicEvent {\n+abstract class AbstractBufferStatisticsEvent extends AbstractPeriodicEvent {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/AbstractBufferStatisticsEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.jfr.StackTrace;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ActiveRecordingEvent.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.jfr.StackTrace;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ActiveSettingEvent.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.jfr.StackTrace;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ExceptionStatisticsEvent.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.jfr.internal.JVM;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-                    catchAllHandler.if_null(rethrow);\n+                    catchAllHandler.ifnull(rethrow);\n@@ -489,1 +489,1 @@\n-                codeBuilder.if_null(fail);\n+                codeBuilder.ifnull(fail);\n@@ -528,1 +528,1 @@\n-                    codeBuilder.if_null(fail);\n+                    codeBuilder.ifnull(fail);\n@@ -741,1 +741,1 @@\n-                codeBuilder.if_null(nullLabel);\n+                codeBuilder.ifnull(nullLabel);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal;\n-\n-\/**\n- * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n- * from being generated when Object.wait() is called on an object of this type.\n- *\/\n-public final class HiddenWait {\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/HiddenWait.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -106,1 +107,0 @@\n-        \/\/ JVM::getChunkStartNanos() may return a bumped timestamp, +1 ns or +2 ns.\n@@ -122,1 +122,2 @@\n-            Utils.takeNap(1);\n+            HiddenWait hiddenWait = new HiddenWait();\n+            hiddenWait.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-import jdk.jfr.StackTrace;\n-import jdk.jfr.Threshold;\n@@ -52,0 +50,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -62,0 +61,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -346,1 +346,1 @@\n-            Utils.takeNap(1);\n+            threadSleeper.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/OldObjectSample.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.time.Period;\n-import java.time.Duration;\n@@ -35,1 +33,0 @@\n-import java.util.Optional;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -35,1 +34,0 @@\n-import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -47,0 +48,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -198,1 +200,3 @@\n-            takeNap();\n+            if (!threadSleeper.takeNap(10)) {\n+                throw new IOException(\"Read operation interrupted\");\n+            }\n@@ -203,8 +207,0 @@\n-    private void takeNap() throws IOException {\n-        try {\n-            Thread.sleep(10);\n-        } catch (InterruptedException ie) {\n-            throw new IOException(\"Read operation interrupted\", ie);\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -70,0 +72,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -456,1 +459,1 @@\n-        Utils.takeNap(1);\n+        threadSleeper.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RecordingInput.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.jfr.internal.management.HiddenWait;;\n@@ -51,1 +52,1 @@\n-    private static final Object WAIT_OBJECT = new Object();\n+    private static final HiddenWait WAIT_OBJECT = new HiddenWait();\n@@ -62,1 +63,1 @@\n-    private final Object waitObject;\n+    private final HiddenWait waitObject;\n@@ -70,1 +71,1 @@\n-        this.waitObject = repository == null ? WAIT_OBJECT : new Object();\n+        this.waitObject = repository == null ? WAIT_OBJECT : new HiddenWait();\n@@ -111,1 +112,1 @@\n-                nap();\n+                waitObject.takeNap(1000);\n@@ -160,10 +161,0 @@\n-    private void nap() {\n-        try {\n-            synchronized (waitObject) {\n-                waitObject.wait(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            \/\/ ignore\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Map;\n+import java.util.HashMap;\n@@ -59,0 +61,1 @@\n+    private final Map<String, Long> waste = new HashMap<>();\n@@ -181,0 +184,10 @@\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {\n+            \/\/ Log largest waste first\n+            waste.entrySet().stream()\n+                 .sorted((a, b) -> b.getValue().compareTo(a.getValue()))\n+                 .forEach(entry -> {\n+                     String msg = \"Total chunk waste by \" + entry.getKey() + \": \" + entry.getValue() + \" bytes.\";\n+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);\n+                 });\n+        }\n+        waste.clear();\n@@ -219,0 +232,14 @@\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {\n+            for (CheckpointPool pool : event.getPools()) {\n+                for (PoolEntry pe : pool.getEntries()) {\n+                    if (!pe.isTouched()) {\n+                        String name = pe.getType().getName();\n+                        long amount = pe.getEndPosition() - pe.getStartPosition();\n+                        waste.merge(pe.getType().getName(), amount, Long::sum);\n+                        String msg = \"Unreferenced constant ID \" + pe.getId() +\n+                                     \" of type \"+ name + \" using \" + amount + \" bytes.\";\n+                        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, msg);\n+                    }\n+                }\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/ChunkWriter.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.ArrayList;\n@@ -40,2 +39,0 @@\n-import jdk.jfr.internal.query.QueryPrinter;\n-import jdk.jfr.internal.query.ViewPrinter;\n@@ -44,2 +41,0 @@\n-import jdk.jfr.internal.util.UserSyntaxException;\n-import jdk.jfr.internal.util.Output;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/QueryRecording.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,1 +296,1 @@\n-        if (e instanceof JFCModelException m) {\n+        if (e instanceof JFCModelException) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/JFC.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        if (getParent() instanceof XmlEvent event) {\n+        if (getParent() instanceof XmlEvent) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/model\/XmlSetting.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+\/**\n+ * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n+ * from being generated when Object.wait() is called on an object of this type.\n+ *\/\n+public final class HiddenWait {\n+\n+    public synchronized boolean takeNap(long timeoutMillis) {\n+        try {\n+            this.wait(timeoutMillis);\n+            return true;\n+        } catch (InterruptedException e) {\n+            \/\/ Ok, ignore\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/HiddenWait.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n-\n+    private final HiddenWait lock = new HiddenWait();\n@@ -48,6 +48,8 @@\n-    public synchronized void check() {\n-        while (activated) {\n-            try {\n-                this.wait();\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n+    public void check() {\n+        synchronized (lock) {\n+            while (activated) {\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n@@ -58,2 +60,4 @@\n-    public synchronized void setStreamEnd(long timestamp) {\n-        end = timestamp;\n+    public void setStreamEnd(long timestamp) {\n+        synchronized(lock) {\n+            end = timestamp;\n+        }\n@@ -62,2 +66,4 @@\n-    public synchronized long getStreamEnd() {\n-        return end;\n+    public long getStreamEnd() {\n+        synchronized(lock) {\n+            return end;\n+        }\n@@ -66,3 +72,5 @@\n-    public synchronized void activate() {\n-        activated = true;\n-        used = true;\n+    public void activate() {\n+        synchronized (lock) {\n+            activated = true;\n+            used = true;\n+        }\n@@ -73,2 +81,4 @@\n-        activated = false;\n-        this.notifyAll();\n+        synchronized (lock) {\n+            activated = false;\n+            lock.notifyAll();\n+        }\n@@ -80,2 +90,4 @@\n-    public synchronized boolean used() {\n-        return used;\n+    public boolean used() {\n+        synchronized (lock) {\n+            return used;\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":30,"deletions":18,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-        return Arrays.asList(values).toString();\n+        return Arrays.toString(values);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Row.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n@@ -30,1 +28,0 @@\n-import java.util.List;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/TableSorter.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-public class LevelSetting extends JDKSettingControl {\n+public final class LevelSetting extends JDKSettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/LevelSetting.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,3 +226,3 @@\n-                FileOutputStream fos = new FileOutputStream(splittedFile);\n-                fos.write(bytes);\n-                fos.close();\n+                try (var fos = new FileOutputStream(splittedFile)) {\n+                    fos.write(bytes);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Disassemble.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.ArrayList;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.jfr.internal.util.Columnizer;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/View.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import jdk.jfr.internal.HiddenWait;\n@@ -58,0 +57,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -63,1 +63,1 @@\n-    private static final Object flushObject = new Object();\n+    private static final HiddenWait flushObject = new HiddenWait();\n@@ -354,11 +354,0 @@\n-    public static void takeNap(long millis) {\n-        HiddenWait hiddenWait = new HiddenWait();\n-        try {\n-            synchronized(hiddenWait) {\n-                hiddenWait.wait(millis);\n-            }\n-        } catch (InterruptedException e) {\n-            \/\/ ok\n-        }\n-    }\n-\n@@ -372,7 +361,1 @@\n-        synchronized (flushObject) {\n-            try {\n-                flushObject.wait(timeOut);\n-            } catch (InterruptedException e) {\n-                \/\/ OK\n-            }\n-        }\n+        flushObject.takeNap(timeOut);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-public class ValueParser {\n+public final class ValueParser {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                        byte[] content = ClassFile.of().transform(clm, ClassTransform\n+                        byte[] content = ClassFile.of().transformClass(clm, ClassTransform\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        return ClassFile.of().transform(newClassReader(path, classFile),\n+        return ClassFile.of().transformClass(newClassReader(path, classFile),\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/VersionPropsPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-                     boolean interactive) throws Exception {\n+                     boolean interactive, Size size) throws Exception {\n@@ -146,1 +146,0 @@\n-                Size size = null;\n@@ -158,1 +157,6 @@\n-            terminal = TerminalBuilder.builder().inputStreamWrapper(in -> {\n+            \/\/on platforms which are known to be fully supported by\n+            \/\/the FFMTerminalProvider, do not permit the ExecTerminalProvider:\n+            boolean allowExecTerminal = !OSUtils.IS_WINDOWS &&\n+                                        !OSUtils.IS_LINUX &&\n+                                        !OSUtils.IS_OSX;\n+            terminal = TerminalBuilder.builder().exec(allowExecTerminal).inputStreamWrapper(in -> {\n@@ -1315,0 +1319,1 @@\n+        protected static final int DEFAULT_WIDTH = 80;\n@@ -1323,1 +1328,1 @@\n-                 size != null ? size : new Size(80, DEFAULT_HEIGHT),\n+                 size != null ? size : new Size(DEFAULT_WIDTH, DEFAULT_HEIGHT),\n@@ -1325,1 +1330,1 @@\n-                              : interactive ? new Size(80, DEFAULT_HEIGHT)\n+                              : interactive ? new Size(DEFAULT_WIDTH, DEFAULT_HEIGHT)\n@@ -1369,1 +1374,1 @@\n-            return new Size(80, h);\n+            return new Size(DEFAULT_WIDTH, h);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+import jdk.internal.org.jline.terminal.Size;\n@@ -169,0 +170,1 @@\n+    final Size windowSize;\n@@ -184,0 +186,1 @@\n+     * @param windowSize window size hint, or null\n@@ -189,1 +192,1 @@\n-            boolean interactiveTerminal) {\n+            boolean interactiveTerminal, Size windowSize) {\n@@ -206,0 +209,1 @@\n+        this.windowSize = windowSize;\n@@ -1001,1 +1005,1 @@\n-            try (IOContext in = new ConsoleIOContext(this, cmdin, console, interactiveTerminal)) {\n+            try (IOContext in = new ConsoleIOContext(this, cmdin, console, interactiveTerminal, windowSize)) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.org.jline.terminal.Size;\n@@ -56,0 +57,1 @@\n+    private Size windowSize = null;\n@@ -218,0 +220,10 @@\n+    @Override\n+    public JavaShellToolBuilder windowSize(int columns, int rows) {\n+        if (columns <= 0)\n+            throw new IllegalArgumentException(\"columns = \" + columns);\n+        if (rows <= 0)\n+            throw new IllegalArgumentException(\"rows = \" + rows);\n+        this.windowSize = new Size(columns, rows);\n+        return this;\n+    }\n+\n@@ -231,1 +243,1 @@\n-                userOut, userErr, prefs, vars, locale, interactiveTerminal);\n+                userOut, userErr, prefs, vars, locale, interactiveTerminal, windowSize);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellToolBuilder.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-         * @since 14\n@@ -254,0 +253,1 @@\n+         * @since 17\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Snippet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,2 @@\n+     *\n+     * @since 10\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysis.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        return cc.transform(cc.parse(classFile),\n+        return cc.transformClass(cc.parse(classFile),\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,0 +212,18 @@\n+    \/**\n+     * Provide a hint of the display window's dimensions when using an interactive terminal.\n+     *\n+     * <p>\n+     * When the input stream for this Java Shell is {@code System.in}, this setting is ignored.\n+     *\n+     * @implSpec Implementations may choose to ignore this method. The default implementation\n+     * of this method returns {@code this}.\n+     *\n+     * @param columns number of displayed columns\n+     * @param rows number of displayed rows\n+     * @return the {@code JavaShellToolBuilder} instance\n+     * @since 24\n+     *\/\n+    default JavaShellToolBuilder windowSize(int columns, int rows) {\n+        return this;\n+    }\n+\n@@ -235,0 +253,2 @@\n+     *\n+     * @since 10\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/JavaShellToolBuilder.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/jdk.jsobject\/share\/classes\/netscape\/javascript\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+@Deprecated(since=\"24\", forRemoval=true)\n","filename":"src\/jdk.jstatd\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,2 @@\n+        System.err.println(\"WARNING: jstatd is deprecated and will be removed in a future release.\");\n+\n","filename":"src\/jdk.jstatd\/share\/classes\/sun\/tools\/jstatd\/Jstatd.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,3 @@\n-\\f[B]Note:\\f[R] This command is experimental and unsupported.\n+\\f[B]WARNING:\\f[R] This command is experimental, unsupported, and\n+deprecated.\n+It will be removed in a future release.\n","filename":"src\/jdk.jstatd\/share\/man\/jstatd.1","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -39,0 +40,1 @@\n+    private final HiddenWait threadSleeper = new HiddenWait();\n@@ -67,1 +69,1 @@\n-                    takeNap();\n+                    threadSleeper.takeNap(1000);\n@@ -76,8 +78,0 @@\n-\n-    private void takeNap() {\n-        try {\n-            Thread.sleep(1000);\n-        } catch (InterruptedException ie) {\n-            \/\/ ignore\n-        }\n-    }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DownLoadThread.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.jfr.internal.management.HiddenWait;\n@@ -37,0 +38,1 @@\n+    private final HiddenWait lock = new HiddenWait();\n@@ -45,9 +47,11 @@\n-    public synchronized void add(DiskChunk dc) {\n-        if (isComplete()) {\n-            return;\n-        }\n-        dc.acquire();\n-        chunks.addFirst(dc);\n-        long endMillis = dc.endTimeNanos \/ 1_000_000;\n-        if (endMillis >= stopTimeMillis) {\n-            setComplete();\n+    public void add(DiskChunk dc) {\n+        synchronized (lock) {\n+            if (isComplete()) {\n+                return;\n+            }\n+            dc.acquire();\n+            chunks.addFirst(dc);\n+            long endMillis = dc.endTimeNanos \/ 1_000_000;\n+            if (endMillis >= stopTimeMillis) {\n+                setComplete();\n+            }\n@@ -57,2 +61,4 @@\n-    public synchronized boolean isComplete() {\n-        return complete;\n+    public boolean isComplete() {\n+        synchronized (lock) {\n+            return complete;\n+        }\n@@ -61,3 +67,5 @@\n-    public synchronized void setComplete() {\n-        complete = true;\n-        this.notifyAll();\n+    public void setComplete() {\n+        synchronized (lock) {\n+            complete = true;\n+            lock.notifyAll();\n+        }\n@@ -66,3 +74,7 @@\n-    public synchronized void close() {\n-        for (DiskChunk dc : chunks) {\n-            dc.release();\n+    public void close() {\n+        synchronized (lock) {\n+            for (DiskChunk dc : chunks) {\n+                dc.release();\n+            }\n+            chunks.clear();\n+            complete = true;\n@@ -70,2 +82,0 @@\n-        chunks.clear();\n-        complete = true;\n@@ -76,1 +86,1 @@\n-            synchronized (this) {\n+            synchronized (lock) {\n@@ -83,1 +93,1 @@\n-                this.wait();\n+                lock.wait();\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FileDump.java","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -648,3 +648,3 @@\n-                e.posixPerms = -1;\n-            } else if (e.posixPerms == -1) {\n-                e.posixPerms = ZipUtils.permsToFlags(perms);\n+                e.externalFileAttributes = -1;\n+            } else if (e.externalFileAttributes == -1) {\n+                e.externalFileAttributes = ZipUtils.permsToFlags(perms);\n@@ -652,2 +652,2 @@\n-                e.posixPerms = ZipUtils.permsToFlags(perms) |\n-                        (e.posixPerms & 0xFE00); \/\/ Preserve unrelated bits\n+                e.externalFileAttributes = ZipUtils.permsToFlags(perms) |\n+                        (e.externalFileAttributes & 0xFE00); \/\/ Preserve unrelated bits\n@@ -2890,1 +2890,1 @@\n-        int    posixPerms = -1; \/\/ posix permissions\n+        int    externalFileAttributes = -1; \/\/ file type, setuid, setgid, sticky, posix permissions\n@@ -2926,1 +2926,1 @@\n-                    posixPerms = ZipUtils.permsToFlags((Set<PosixFilePermission>)attr.value());\n+                    externalFileAttributes = ZipUtils.permsToFlags((Set<PosixFilePermission>)attr.value());\n@@ -2961,1 +2961,1 @@\n-            this.posixPerms = e.posixPerms;\n+            this.externalFileAttributes = e.externalFileAttributes;\n@@ -2991,1 +2991,1 @@\n-            return (posixPerms < 0) ? version :\n+            return (externalFileAttributes < 0) ? version :\n@@ -3018,1 +3018,1 @@\n-                posixPerms = (CENATX_PERMS(cen, pos) & 0xFFFF); \/\/ 16 bits for file type, setuid, setgid, sticky + perms\n+                externalFileAttributes = (CENATX_PERMS(cen, pos) & 0xFFFF); \/\/ 16 bits for file type, setuid, setgid, sticky + perms\n@@ -3108,1 +3108,1 @@\n-            writeInt(os, posixPerms > 0 ? posixPerms << 16 : 0); \/\/ external file\n+            writeInt(os, externalFileAttributes > 0 ? externalFileAttributes << 16 : 0); \/\/ external file\n@@ -3531,1 +3531,1 @@\n-            if (posixPerms != -1) {\n+            if (externalFileAttributes != -1) {\n@@ -3534,1 +3534,1 @@\n-                    if ((posixPerms & ZipUtils.permToFlag(perm)) != 0) {\n+                    if ((externalFileAttributes & ZipUtils.permToFlag(perm)) != 0) {\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-TEST_OTHER_VM(FreeRegionList, length) {\n+TEST_OTHER_VM(G1FreeRegionList, length) {\n@@ -42,1 +42,1 @@\n-  FreeRegionList l(\"test\");\n+  G1FreeRegionList l(\"test\");\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,2 +239,2 @@\n-  uint const min = (uint)log2i(HeapRegionBounds::min_size());\n-  uint const max = (uint)log2i(HeapRegionBounds::max_size());\n+  uint const min = (uint)log2i(G1HeapRegionBounds::min_size());\n+  uint const max = (uint)log2i(G1HeapRegionBounds::max_size());\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    HeapRegionRange current = map->next_active_range(current_offset);\n+    G1HeapRegionRange current = map->next_active_range(current_offset);\n@@ -82,1 +82,1 @@\n-    HeapRegionRange current = map->next_inactive_range(current_offset);\n+    G1HeapRegionRange current = map->next_inactive_range(current_offset);\n@@ -97,1 +97,1 @@\n-    HeapRegionRange current = map->next_committable_range(current_offset);\n+    G1HeapRegionRange current = map->next_committable_range(current_offset);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1RegionMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-      QuickSort::sort(to_release, nrelease, PointerCompare(), false);\n+      QuickSort::sort(to_release, nrelease, PointerCompare());\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/metaspace\/metaspaceArena.hpp\"\n-#include \"memory\/metaspace\/metaspaceSettings.hpp\"\n-#include \"memory\/metaspace\/testHelpers.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-\/\/#define LOG_PLEASE\n-#include \"metaspaceGtestCommon.hpp\"\n-#include \"metaspaceGtestContexts.hpp\"\n-\n-#ifdef ASSERT\n-\n-using metaspace::MetaspaceArena;\n-using metaspace::MetaspaceTestArena;\n-using metaspace::Settings;\n-\n-\/\/ Test that overwriting memory triggers an assert if allocation guards are enabled.\n-\/\/  Note: We use TEST_VM_ASSERT_MSG. However, an assert is only triggered if allocation\n-\/\/  guards are enabled; if guards are disabled for the gtests, this test would fail.\n-\/\/  So for that case, we trigger a fake assert.\n-TEST_VM_ASSERT_MSG(metaspace, test_overwriter, \".*Metaspace corruption.*\") {\n-\n-  if (Settings::use_allocation_guard()) {\n-    MetaspaceGtestContext context;\n-    MetaspaceTestArena* arena = context.create_arena(Metaspace::StandardMetaspaceType);\n-    \/\/ We allocate two blocks. We then write over the end of the first block, which\n-    \/\/  should corrupt the fence between the two blocks.\n-    \/\/ Note: there is of course no guarantee that blocks allocated sequentially are neighbors;\n-    \/\/  but in this case (clean standard-sized test arena and very small allocations) it can\n-    \/\/  be safely assumed).\n-    MetaWord* p1 = arena->allocate(8);\n-    MetaWord* p2 = arena->allocate(2);\n-    p1[8] = (MetaWord)0x9345; \/\/ Overwriter\n-    \/\/ Now we delete the arena (as happens during class unloading); this will check all\n-    \/\/ block canaries and should trigger an assert (see MetaspaceArena::verify_allocation_guards()).\n-    delete arena;\n-  } else {\n-    assert(false, \"Metaspace corruption - please ignore this, fake message to satisfy tests\");\n-  }\n-\n-}\n-\n-#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/metaspace\/test_allocationGuard.cpp","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -294,5 +294,0 @@\n-\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n@@ -340,5 +335,0 @@\n-\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n@@ -375,5 +365,0 @@\n-\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n@@ -402,3 +387,0 @@\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n@@ -508,4 +490,0 @@\n-  if (Settings::use_allocation_guard()) {\n-    return;\n-  }\n-\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-    \/\/ - if +MetaspaceGuardAllocations, guard costs\n@@ -116,2 +115,1 @@\n-    const size_t max_word_overhead_per_alloc =\n-        4 + (metaspace::Settings::use_allocation_guard() ? 4 : 0);\n+    constexpr size_t max_word_overhead_per_alloc = 4;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"nmt\/arrayWithFreeList.hpp\"\n+\n+using A = ArrayWithFreeList<int, mtTest>;\n+\n+class ArrayWithFreeListTest  : public testing::Test {\n+};\n+\n+\/\/ A linked list which sets the allocator itself\n+template<typename E>\n+struct LL {\n+  struct Node;\n+  using NodeAllocator = ArrayWithFreeList<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+  };\n+\n+  NodePtr start;\n+  LL()\n+  : start{NodeAllocator::nil} {\n+  }\n+\n+  void push(E e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n+    }\n+    alloc.at(new_element).next = current;\n+    current = new_element;\n+  };\n+\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.deallocate(start);\n+    start = next_start;\n+    return e;\n+  }\n+};\n+\n+\/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n+\/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n+\/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n+\/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n+template<typename E, template<typename, MEMFLAGS> class Allocator>\n+struct LL2 {\n+  struct Node;\n+  using NodeAllocator = Allocator<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+  };\n+\n+  NodePtr start;\n+  LL2()\n+    : start(NodeAllocator::nil) {\n+  }\n+\n+  void push(E e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n+    }\n+    alloc.at(new_element).next = current;\n+    current = new_element;\n+  };\n+\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.deallocate(start);\n+    start = next_start;\n+    return e;\n+  }\n+};\n+\n+template<typename List>\n+void test_with_list(List& list) {\n+  list.push(1);\n+  list.push(2);\n+  EXPECT_EQ(2, list.pop());\n+  EXPECT_EQ(1, list.pop());\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, TestLinkedLists) {\n+  {\n+    LL<int> list;\n+    test_with_list(list);\n+  }\n+  {\n+    LL2<int, ArrayWithFreeList> list;\n+    test_with_list(list);\n+  }\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, FreeingShouldReuseMemory) {\n+  A alloc;\n+  A::I i = alloc.allocate(1);\n+  int* x = &alloc.at(i);\n+  alloc.deallocate(i);\n+  i = alloc.allocate(1);\n+  int* y = &alloc.at(i);\n+  EXPECT_EQ(x, y);\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, FreeingInTheMiddleWorks) {\n+  A alloc;\n+  A::I i0 = alloc.allocate(0);\n+  A::I i1 = alloc.allocate(0);\n+  A::I i2 = alloc.allocate(0);\n+  int* p1 = &alloc.at(i1);\n+  alloc.deallocate(i1);\n+  A::I i3 = alloc.allocate(0);\n+  EXPECT_EQ(p1, &alloc.at(i3));\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_arrayWithFreeList.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-class MemoryFileTrackerTest : public testing::Test {\n+class NMTMemoryFileTrackerTest : public testing::Test {\n@@ -51,1 +51,1 @@\n-TEST_VM_F(MemoryFileTrackerTest, Basics) {\n+TEST_VM_F(NMTMemoryFileTrackerTest, Basics) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_memoryfiletracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class NativeCallStackStorageTest : public testing::Test {};\n+class NMTNativeCallStackStorageTest : public testing::Test {};\n@@ -34,1 +34,1 @@\n-TEST_VM_F(NativeCallStackStorageTest, DoNotStoreStackIfNotDetailed) {\n+TEST_VM_F(NMTNativeCallStackStorageTest, DoNotStoreStackIfNotDetailed) {\n@@ -43,1 +43,1 @@\n-TEST_VM_F(NativeCallStackStorageTest, CollisionsReceiveDifferentIndexes) {\n+TEST_VM_F(NMTNativeCallStackStorageTest, CollisionsReceiveDifferentIndexes) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_nativecallstackstorage.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-class TreapTest : public testing::Test {\n+class NMTTreapTest : public testing::Test {\n@@ -150,1 +150,1 @@\n-TEST_VM_F(TreapTest, InsertingDuplicatesResultsInOneValue) {\n+TEST_VM_F(NMTTreapTest, InsertingDuplicatesResultsInOneValue) {\n@@ -154,1 +154,1 @@\n-TEST_VM_F(TreapTest, TreapOughtNotLeak) {\n+TEST_VM_F(NMTTreapTest, TreapOughtNotLeak) {\n@@ -158,1 +158,1 @@\n-TEST_VM_F(TreapTest, TestVisitors) {\n+TEST_VM_F(NMTTreapTest, TestVisitors) {\n@@ -262,1 +262,1 @@\n-TEST_VM_F(TreapTest, TestFind) {\n+TEST_VM_F(NMTTreapTest, TestFind) {\n@@ -266,1 +266,1 @@\n-TEST_VM_F(TreapTest, TestClosestLeq) {\n+TEST_VM_F(NMTTreapTest, TestClosestLeq) {\n@@ -292,1 +292,1 @@\n-TEST_VM_F(TreapTest, VerifyItThroughStressTest) {\n+TEST_VM_F(NMTTreapTest, VerifyItThroughStressTest) {\n@@ -303,1 +303,3 @@\n-      verify_it(treap);\n+      if (i % 100 == 0) {\n+        verify_it(treap);\n+      }\n@@ -312,1 +314,3 @@\n-      verify_it(treap);\n+      if (i % 100 == 0) {\n+        verify_it(treap);\n+      }\n@@ -318,2 +322,2 @@\n-    constexpr const int five_million = 5000000;\n-    for (int i = 0; i < five_million; i++) {\n+    constexpr const int one_hundred_thousand = 100000;\n+    for (int i = 0; i < one_hundred_thousand; i++) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-class VMATreeTest : public testing::Test {\n+class NMTVMATreeTest : public testing::Test {\n@@ -44,1 +44,1 @@\n-  VMATreeTest() : ncs(true) {\n+  NMTVMATreeTest() : ncs(true) {\n@@ -175,1 +175,1 @@\n-TEST_VM_F(VMATreeTest, OverlappingReservationsResultInTwoNodes) {\n+TEST_VM_F(NMTVMATreeTest, OverlappingReservationsResultInTwoNodes) {\n@@ -185,1 +185,1 @@\n-TEST_VM_F(VMATreeTest, LowLevel) {\n+TEST_VM_F(NMTVMATreeTest, LowLevel) {\n@@ -271,1 +271,1 @@\n-TEST_VM_F(VMATreeTest, SummaryAccounting) {\n+TEST_VM_F(NMTVMATreeTest, SummaryAccounting) {\n@@ -419,1 +419,1 @@\n-TEST_VM_F(VMATreeTest, TestConsistencyWithSimpleTracker) {\n+TEST_VM_F(NMTVMATreeTest, TestConsistencyWithSimpleTracker) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+  bool is_read_only() override {\n+    return true; \/\/ doesn't matter\n+  }\n@@ -439,1 +442,2 @@\n-                                                       (char*)testCases[i]->mount_path);\n+                                                       (char*)testCases[i]->mount_path,\n+                                                       true \/* read-only mount *\/);\n@@ -463,1 +467,2 @@\n-                                                       (char*)testCases[i]->cgroup_path);\n+                                                       (char*)testCases[i]->cgroup_path,\n+                                                       true \/* read-only mount *\/);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -199,0 +199,36 @@\n+\n+  static void test_committed_in_range(size_t num_pages, size_t pages_to_touch) {\n+    bool result;\n+    size_t committed_size;\n+    address committed_start;\n+    size_t index;\n+\n+    const size_t page_sz = os::vm_page_size();\n+    const size_t size = num_pages * page_sz;\n+\n+    char* base = os::reserve_memory(size, !ExecMem, mtTest);\n+    ASSERT_NE(base, (char*)nullptr);\n+\n+    result = os::commit_memory(base, size, !ExecMem);\n+    ASSERT_TRUE(result);\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_FALSE(result);\n+\n+    \/\/ Touch pages\n+    for (index = 0; index < pages_to_touch; index ++) {\n+      base[index * page_sz] = 'a';\n+    }\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_TRUE(result);\n+    ASSERT_EQ(pages_to_touch * page_sz, committed_size);\n+    ASSERT_EQ(committed_start, (address)base);\n+\n+    os::uncommit_memory(base, size, false);\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_FALSE(result);\n+\n+    os::release_memory(base, size);\n+  }\n@@ -217,0 +253,7 @@\n+\n+#if !defined(_WINDOWS) && !defined(_AIX)\n+TEST_VM(CommittedVirtualMemory, test_committed_in_range){\n+  CommittedVirtualMemoryTest::test_committed_in_range(1024, 1024);\n+  CommittedVirtualMemoryTest::test_committed_in_range(2, 1);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -170,2 +170,6 @@\n-static void do_test_print_hex_dump(address addr, size_t len, int unitsize, const char* expected) {\n-  char buf[256];\n+#ifndef AIX\n+\/\/ Test relies on the ability to protect memory allocated with os::reserve_memory. AIX may not be able\n+\/\/ to do that (mprotect won't work on System V shm).\n+static void do_test_print_hex_dump(const_address from, const_address to, int unitsize, int bytes_per_line,\n+                                   const_address logical_start, const char* expected) {\n+  char buf[2048];\n@@ -174,4 +178,2 @@\n-  os::print_hex_dump(&ss, addr, addr + len, unitsize);\n-  \/\/ tty->print_cr(\"expected: %s\", expected);\n-  \/\/ tty->print_cr(\"result: %s\", buf);\n-  EXPECT_THAT(buf, HasSubstr(expected));\n+  os::print_hex_dump(&ss, from, to, unitsize, \/* print_ascii=*\/true, bytes_per_line, logical_start);\n+  EXPECT_STREQ(buf, expected);\n@@ -181,6 +183,5 @@\n-  const char* pattern [4] = {\n-#ifdef VM_LITTLE_ENDIAN\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0100 0302 0504 0706 0908 0b0a 0d0c 0f0e\",\n-    \"03020100 07060504 0b0a0908 0f0e0d0c\",\n-    \"0706050403020100 0f0e0d0c0b0a0908\"\n+\n+#ifdef _LP64\n+#define ADDRESS1 \"0x0000aaaaaaaaaa00\"\n+#define ADDRESS2 \"0x0000aaaaaaaaaa20\"\n+#define ADDRESS3 \"0x0000aaaaaaaaaa40\"\n@@ -188,4 +189,3 @@\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0001 0203 0405 0607 0809 0a0b 0c0d 0e0f\",\n-    \"00010203 04050607 08090a0b 0c0d0e0f\",\n-    \"0001020304050607 08090a0b0c0d0e0f\"\n+#define ADDRESS1 \"0xaaaaaa00\"\n+#define ADDRESS2 \"0xaaaaaa20\"\n+#define ADDRESS3 \"0xaaaaaa40\"\n@@ -193,1 +193,0 @@\n-  };\n@@ -195,6 +194,6 @@\n-  const char* pattern_not_readable [4] = {\n-    \"?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\",\n-    \"???? ???? ???? ???? ???? ???? ???? ????\",\n-    \"???????? ???????? ???????? ????????\",\n-    \"???????????????? ????????????????\"\n-  };\n+#define ASCII_1  \"....#.jdk\/internal\/loader\/Native\"\n+#define ASCII_2  \"Libraries.......\"\n+\n+#define PAT_1 ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n@@ -202,4 +201,12 @@\n-  \/\/ On AIX, zero page is readable.\n-  address unreadable =\n-#ifdef AIX\n-    (address) 0xFFFFFFFFFFFF0000ULL;\n+#ifdef VM_LITTLE_ENDIAN\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff dce0 0023 646a 2f6b 6e69 6574 6e72 6c61 6c2f 616f 6564 2f72 614e 6974 6576   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   694c 7262 7261 6569 0073 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   dce0ffff 646a0023 6e692f6b 6e726574 6c2f6c61 6564616f 614e2f72 65766974   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   7262694c 65697261 00000073 00000000                                       \" ASCII_2 \"\\n\"\n+\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   646a0023dce0ffff 6e7265746e692f6b 6564616f6c2f6c61 65766974614e2f72   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   656972617262694c 0000000000000073                                     \" ASCII_2 \"\\n\"\n@@ -207,3 +214,3 @@\n-    (address) 0\n-#endif\n-    ;\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff e0dc 2300 6a64 6b2f 696e 7465 726e 616c 2f6c 6f61 6465 722f 4e61 7469 7665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69 6272 6172 6965 7300 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n@@ -211,14 +218,7 @@\n-  ResourceMark rm;\n-  char buf[64];\n-  stringStream ss(buf, sizeof(buf));\n-  outputStream* out = &ss;\n-\/\/  outputStream* out = tty; \/\/ enable for printout\n-\n-  \/\/ Test dumping unreadable memory\n-  \/\/ Exclude test for Windows for now, since it needs SEH handling to work which cannot be\n-  \/\/ guaranteed when we call directly into VM code. (see JDK-8220220)\n-#ifndef _WIN32\n-  do_test_print_hex_dump(unreadable, 100, 1, pattern_not_readable[0]);\n-  do_test_print_hex_dump(unreadable, 100, 2, pattern_not_readable[1]);\n-  do_test_print_hex_dump(unreadable, 100, 4, pattern_not_readable[2]);\n-  do_test_print_hex_dump(unreadable, 100, 8, pattern_not_readable[3]);\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc 23006a64 6b2f696e 7465726e 616c2f6c 6f616465 722f4e61 74697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c696272 61726965 73000000 00000000                                       \" ASCII_2 \"\\n\"\n+\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc23006a64 6b2f696e7465726e 616c2f6c6f616465 722f4e6174697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69627261726965 7300000000000000                                     \" ASCII_2 \"\\n\"\n@@ -227,5 +227,13 @@\n-  \/\/ Test dumping readable memory\n-  address arr = (address)os::malloc(100, mtInternal);\n-  for (u1 c = 0; c < 100; c++) {\n-    arr[c] = c;\n-  }\n+  constexpr uint8_t bytes[] = {\n+    0xff, 0xff, 0xe0, 0xdc, 0x23, 0x00, 0x6a, 0x64, 0x6b, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+    0x61, 0x6c, 0x2f, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x2f, 0x4e, 0x61, 0x74, 0x69, 0x76, 0x65,\n+    0x4c, 0x69, 0x62, 0x72, 0x61, 0x72, 0x69, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+  };\n+\n+  \/\/ two pages, first one protected.\n+  const size_t ps = os::vm_page_size();\n+  char* two_pages = os::reserve_memory(ps * 2, false, mtTest);\n+  os::commit_memory(two_pages, ps * 2, false);\n+  os::protect_memory(two_pages, ps, os::MEM_PROT_NONE, true);\n+\n+  memcpy(two_pages + ps, bytes, sizeof(bytes));\n@@ -233,5 +241,4 @@\n-  \/\/ properly aligned\n-  do_test_print_hex_dump(arr, 100, 1, pattern[0]);\n-  do_test_print_hex_dump(arr, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr, 100, 8, pattern[3]);\n+  \/\/ print\n+  const const_address from = (const_address) two_pages + ps - 32;\n+  const const_address to = (const_address) from + 32 + sizeof(bytes);\n+  const const_address logical_start = (const_address) LP64_ONLY(0xAAAAAAAAAA00ULL) NOT_LP64(0xAAAAAA00ULL);\n@@ -239,4 +246,4 @@\n-  \/\/ Not properly aligned. Should automatically down-align by unitsize\n-  do_test_print_hex_dump(arr + 1, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr + 1, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr + 1, 100, 8, pattern[3]);\n+  do_test_print_hex_dump(from, to, 1, 32, logical_start, PAT_1);\n+  do_test_print_hex_dump(from, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from, to, 8, 32, logical_start, PAT_8);\n@@ -244,1 +251,6 @@\n-  os::free(arr);\n+  \/\/ unaligned printing, should align to next lower unitsize\n+  do_test_print_hex_dump(from + 1, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from + 1, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from + 1, to, 8, 32, logical_start, PAT_8);\n+\n+  os::release_memory(two_pages, ps * 2);\n@@ -246,0 +258,1 @@\n+#endif \/\/ not AIX\n@@ -957,12 +970,0 @@\n-#ifdef AIX\n-\/\/ On Aix, we should fail attach attempts not aligned to segment boundaries (256m)\n-TEST_VM(os, aix_reserve_at_non_shmlba_aligned_address) {\n-  if (Use64KPages) {\n-    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n-    ASSERT_EQ(p, nullptr); \/\/ should have failed\n-  }\n-}\n-#endif \/\/ AIX\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":72,"deletions":71,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef AIX\n+\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ On Aix, when using shmget() in os::attempt_reserve_memory_at() we should fail with attach\n+\/\/ attempts not aligned to shmget() segment boundaries (256m)\n+\/\/ But shmget() is only used in cases we want to have 64K pages and mmap() does not provide it.\n+TEST_VM(os_aix, aix_reserve_at_non_shmlba_aligned_address) {\n+  if (os::vm_page_size() != 4*K && !os::Aix::supports_64K_mmap_pages()) {\n+    \/\/ With this condition true shmget() is used inside\n+    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n+    ASSERT_EQ(p, nullptr); \/\/ should have failed\n+  }\n+}\n+\n+#endif \/\/ AIX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_aix.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -51,2 +51,2 @@\n-static bool sort_and_compare(int* arrayToSort, int* expectedResult, size_t length, C comparator, bool idempotent = false) {\n-  QuickSort::sort(arrayToSort, length, comparator, idempotent);\n+static bool sort_and_compare(int* arrayToSort, int* expectedResult, size_t length, C comparator) {\n+  QuickSort::sort(arrayToSort, length, comparator);\n@@ -56,12 +56,0 @@\n-static int test_even_odd_comparator(int a, int b) {\n-  bool a_is_odd = ((a % 2) == 1);\n-  bool b_is_odd = ((b % 2) == 1);\n-  if (a_is_odd == b_is_odd) {\n-    return 0;\n-  }\n-  if (a_is_odd) {\n-    return -1;\n-  }\n-  return 1;\n-}\n-\n@@ -129,44 +117,0 @@\n-  {\n-    int test_array[] = {2,8,1,4};\n-    int expected_array[] = {1,4,2,8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 4, test_even_odd_comparator));\n-  }\n-}\n-\n-TEST(QuickSort, idempotent) {\n-  {\n-    \/\/ An array of lenght 3 is only sorted by find_pivot. Make sure that it is idempotent.\n-    int test_array[] = {1, 4, 8};\n-    int expected_array[] = {1, 4, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 3, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {1, 7, 9, 4, 8, 2};\n-    int expected_array[] = {1, 7, 9, 4, 8, 2};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {1, 9, 7, 4, 2, 8};\n-    int expected_array[] = {1, 9, 7, 4, 2, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {7, 9, 1, 2, 8, 4};\n-    int expected_array[] = {7, 9, 1, 2, 8, 4};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {7, 1, 9, 2, 4, 8};\n-    int expected_array[] = {7, 1, 9, 2, 4, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {9, 1, 7, 4, 8, 2};\n-    int expected_array[] = {9, 1, 7, 4, 8, 2};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n-  {\n-    int test_array[] = {9, 7, 1, 4, 2, 8};\n-    int expected_array[] = {9, 7, 1, 4, 2, 8};\n-    EXPECT_TRUE(sort_and_compare(test_array, expected_array, 6, test_even_odd_comparator, true));\n-  }\n@@ -189,12 +133,0 @@\n-\n-    \/\/ Make sure sorting is idempotent.\n-    \/\/ Both test_array and expected_array are sorted by the test_comparator.\n-    \/\/ Now sort them once with the test_even_odd_comparator. Then sort the\n-    \/\/ test_array one more time with test_even_odd_comparator and verify that\n-    \/\/ it is idempotent.\n-    QuickSort::sort(expected_array, length, test_even_odd_comparator, true);\n-    QuickSort::sort(test_array, length, test_even_odd_comparator, true);\n-    EXPECT_TRUE(compare_arrays(test_array, expected_array, length));\n-    QuickSort::sort(test_array, length, test_even_odd_comparator, true);\n-    EXPECT_TRUE(compare_arrays(test_array, expected_array, length));\n-\n","filename":"test\/hotspot\/gtest\/utilities\/test_quicksort.cpp","additions":2,"deletions":70,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -89,0 +89,5 @@\n+###\n+# Fails on Windows because of additional memory allocation.\n+\n+gc\/g1\/TestMixedGCLiveThreshold.java#25percent 8334759 windows-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -119,3 +119,0 @@\n-vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java 8298991 linux-x64\n-\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-\n-vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java 8298991 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+compiler\/vectorization\/TestFloat16VectorConvChain.java 8335860 generic-all\n+\n@@ -73,0 +75,1 @@\n+\n@@ -113,1 +116,0 @@\n-runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8334545 generic-all\n@@ -117,1 +119,0 @@\n-containers\/cgroup\/PlainRead.java 8333967,8261242 linux-all\n@@ -140,7 +141,7 @@\n-serviceability\/sa\/ClhsdbCDSCore.java 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbPmap.java#core 8267433 macosx-x64\n-serviceability\/sa\/ClhsdbPstack.java#core 8267433 macosx-x64\n-serviceability\/sa\/TestJmapCore.java 8267433 macosx-x64\n-serviceability\/sa\/TestJmapCoreMetaspace.java 8267433 macosx-x64\n+serviceability\/sa\/ClhsdbCDSCore.java              8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core    8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbPmap.java#core            8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbPstack.java#core          8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/TestJmapCore.java               8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/TestJmapCoreMetaspace.java      8267433,8318754 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-#  Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/generate.bash","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.incubator.vector module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.incubator.vector\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.incubator.vector\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_incubator_vector.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.internal.md module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.internal.md\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.internal.md\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_internal_md.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.jpackage module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.jpackage\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.jpackage\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_jpackage.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary run CTW for all classes from jdk.nio.mapmode module\n+ *\n+ * @library \/test\/lib \/ \/testlibrary\/ctw\/src\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.reflect\n+ * @modules jdk.nio.mapmode\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver\/timeout=7200 sun.hotspot.tools.ctw.CtwRunner modules:jdk.nio.mapmode\n+ *\/\n","filename":"test\/hotspot\/jtreg\/applications\/ctw\/modules\/jdk_nio_mapmode.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -29,2 +29,2 @@\n- * @requires vm.debug == true & vm.compiler1.enabled\n- * @run main\/othervm -XX:TraceLinearScanLevel=4 compiler.c1.TestTraceLinearScanLevel\n+ * @requires vm.debug == true & vm.compiler1.enabled & vm.compMode != \"Xcomp\"\n+ * @run main\/othervm -Xbatch -XX:TraceLinearScanLevel=4 compiler.c1.TestTraceLinearScanLevel\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestTraceLinearScanLevel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -614,2 +614,3 @@\n-    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    \/\/ Disabled by JDK-8335390, to be enabled again by JDK-8335392.\n+    \/\/ @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+    \/\/     applyIf = {\"UseUnalignedAccesses\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335390\n+ * @summary Test merge stores for some Unsafe store address patterns.\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires vm.bits == 64\n+ * @requires os.maxMemory > 8G\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresUnsafeArrayPointer::test*\n+ *                   -Xbatch\n+ *                   -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ * @run main\/othervm -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ *\/\n+\n+package compiler.c2;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestMergeStoresUnsafeArrayPointer {\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ We allocate a big int array of length:\n+    static final int SIZE = (1 << 30) + 100;\n+\n+    \/\/ This gives us a memory region of 4x as many bytes:\n+    static final long BYTE_SIZE = 4L * SIZE; \/\/ = 1L << 32 + 400L\n+\n+    \/\/ We set an \"anchor\" in the middle of this memory region, in bytes:\n+    static final long ANCHOR = BYTE_SIZE \/ 2;\n+\n+    static int four = 4;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Allocate big array of SIZE = \" + SIZE);\n+        int[] big = new int[SIZE];\n+\n+        \/\/ Each test is executed a few times, so that we can see the difference between\n+        \/\/ interpreter and compiler.\n+        int errors = 0;\n+\n+        long val = 0;\n+        System.out.println(\"test1\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test1(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test1 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        val = 0;\n+        System.out.println(\"test2\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test2(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test2 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(\"ERRORS: \" + errors);\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    \/\/ Only clear and sum over relevant parts of array to make the test fast.\n+    static void testClear(int[] a) {\n+        for (int j = 0               ; j <              100; j++) { a[j] = j; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { a[j] = j; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { a[j] = j; }\n+    }\n+\n+    static long testSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0               ; j <              100; j++) { sum += a[j]; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { sum += a[j]; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { sum += a[j]; }\n+        return sum;\n+    }\n+\n+    \/\/ Reference: expected to merge.\n+    static void test1(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putInt(a, base + 0, 0x42424242);\n+        UNSAFE.putInt(a, base + 4, 0x66666666);\n+    }\n+\n+    \/\/ Test: if MergeStores is applied this can lead to wrong results\n+    static void test2(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + ANCHOR;\n+        UNSAFE.putInt(a, base + 0                 + (long)(four + Integer.MAX_VALUE), 0x42424242);\n+        UNSAFE.putInt(a, base + Integer.MAX_VALUE + (long)(four + 4                ), 0x66666666);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresUnsafeArrayPointer.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -184,2 +184,2 @@\n-        \/\/ Fill from 1 to 50\n-        for (int i = 0; i < 50; i++) {\n+        \/\/ Fill from 1 to 125\n+        for (int i = 0; i < 125; i++) {\n@@ -190,3 +190,3 @@\n-        \/\/ Fill from -1 to -50\n-        for (int i = 50; i < 100; i++) {\n-            a[i] = -(i - 49);\n+        \/\/ Fill from -1 to -125\n+        for (int i = 125; i < 250; i++) {\n+            a[i] = -(i - 124);\n@@ -196,1 +196,1 @@\n-        for (int i = 100; i < 512; i++) {\n+        for (int i = 250; i < 512; i++) {\n@@ -209,2 +209,2 @@\n-        \/\/ Fill from 1 to 50\n-        for (int i = 0; i < 50; i++) {\n+        \/\/ Fill from 1 to 125\n+        for (int i = 0; i < 125; i++) {\n@@ -215,3 +215,3 @@\n-        \/\/ Fill from -1 to -50\n-        for (int i = 50; i < 100; i++) {\n-            a[i] = -(i - 49);\n+        \/\/ Fill from -1 to -125\n+        for (int i = 125; i < 250; i++) {\n+            a[i] = -(i - 124);\n@@ -221,1 +221,1 @@\n-        for (int i = 100; i < 512; i++) {\n+        for (int i = 250; i < 512; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires !vm.graal.enabled & vm.opt.final.UseVtableBasedCHA == true\n+ * @requires !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gcbarriers;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.DontInline;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/**\n+ * @test\n+ * @bug 8231569\n+ * @summary Test that Shenandoah barriers are expanded correctly\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Shenandoah\n+ * @run main compiler.gcbarriers.TestShenandoahBarrierExpansion\n+ *\/\n+public class TestShenandoahBarrierExpansion {\n+    public static void main(String[] args) {\n+        TestFramework test = new TestFramework(TestShenandoahBarrierExpansion.class);\n+        test.addFlags(\"-XX:+UseShenandoahGC\");\n+        test.start();\n+    }\n+\n+    private static Object staticField;\n+    @Test\n+    @IR(failOn = IRNode.IF, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"2\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    public Object testLoadFieldObject() {\n+        return staticField;\n+    }\n+\n+    private static A staticField2 = new A();\n+    @Test\n+    @IR(counts = { IRNode.IF, \"1\" }, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"3\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    private static int testLoadObjectFieldWithNullCheck() {\n+        return staticField2.intField;\n+    }\n+\n+    private static A staticField3 = new A();\n+    @Test\n+    @IR(counts = { IRNode.IF, \"2\" }, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"6\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    private static int testLoadTwoObjectFieldsWithNullCheck() {\n+        return staticField2.intField + staticField3.intField;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = { IRNode.IF, \"3\" }, phase = CompilePhase.BARRIER_EXPANSION)\n+    private static void testLoadTwoFieldObjectAndEscape() {\n+        final A field2 = staticField2;\n+        final A field3 = staticField3;\n+        notInlined(field2, field3);\n+    }\n+\n+    @DontInline\n+    private static void notInlined(A field2, A field3) {\n+        \/\/ noop\n+    }\n+\n+    private static class A {\n+        public int intField;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestShenandoahBarrierExpansion.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334421\n+ * @summary C2 incorrectly marks not-escaped locks for elimination after\n+ *          coarsened locks were eliminated and created unbalanced regions.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-TieredCompilation TestCoarsenedAndNotEscapedLocksElimination\n+ * @run main TestCoarsenedAndNotEscapedLocksElimination\n+ *\/\n+\n+import java.util.Vector;\n+\n+class TestVector extends Vector<Object> {\n+\n+    TestVector() {\n+        super();\n+    }\n+\n+    TestVector(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    TestVector(int initialCapacity, int capacityIncrement) {\n+        super(initialCapacity, capacityIncrement);\n+    }\n+\n+    Object[] getElementData () {\n+        return elementData; \/\/ access protected field\n+    }\n+}\n+\n+public class TestCoarsenedAndNotEscapedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        TestCoarsenedAndNotEscapedLocksElimination tc = new TestCoarsenedAndNotEscapedLocksElimination();\n+        String result = null;\n+        for (int i = 0; i < 12000; ++i) {\n+            result = tc.test();\n+            if (result != null) break;\n+        }\n+        System.out.println(result == null? \"passed\" : result);\n+    }\n+\n+    int [][] vector_types = {\n+       {-1, -1},\n+       {0, -1},\n+       {1, -1},\n+       {2, -1},\n+       {1025, -1},\n+       {0, -2},\n+       {1, -2},\n+       {2, -2},\n+       {1025, -2},\n+       {0, 0},\n+       {1, 0},\n+       {2, 0},\n+       {1025, 0},\n+       {0, 1},\n+       {1, 1},\n+       {2, 1},\n+       {1025, 1},\n+       {0, 1025 },\n+       {1, 1025 },\n+       {2, 1025 },\n+       {1025, 1025 }\n+    };\n+\n+    Object [] elems = {\n+        null,\n+        new Object(),\n+        new Vector(),\n+        new Object[0]\n+    };\n+\n+    int cntr = 0, mode = 0;\n+\n+    void reset() {\n+        cntr = 0;\n+        mode = 0;\n+    }\n+\n+    TestVector nextVector() {\n+        if (cntr == vector_types.length) {\n+            return null;\n+        } else {\n+            TestVector vect;\n+            if (vector_types[cntr][0] < 0) {\n+                vect = new TestVector();\n+            } else if (vector_types[cntr][1] == -2) {\n+                vect = new TestVector(vector_types[cntr][0]);\n+            } else {\n+                vect = new TestVector(vector_types[cntr][0], vector_types[cntr][1]);\n+            }\n+            if (mode == 1) {\n+                vect.addElement(null);\n+                vect.addElement(new Object());\n+                vect.addElement(new Vector());\n+                vect.addElement(new Object[0]);\n+            } else if (mode == 2) {\n+                int cap = vect.capacity();\n+                vect.addElement(null);\n+                for (int i = 0; i < cap; i++) {\n+                    vect.addElement(new Object());\n+                }\n+            }\n+            if (++mode == 3) {\n+                mode = 0;\n+                cntr++;\n+            }\n+            return vect;\n+        }\n+    }\n+\n+    public String test() {\n+        reset();\n+        TestVector vect = (TestVector)nextVector();\n+        while (vect != null) {\n+            Object [] backup_array = new Object[vect.size()];\n+            System.arraycopy(vect.getElementData(),0,backup_array,0,vect.size());\n+\n+            int old_size = vect.size();\n+            vect.setSize(vect.size());\n+            if (vect.size() != old_size) {\n+                return \"Vector: \"+vect+\" size changed after setSize(size())\";\n+            }\n+            for (int i = 0; i < vect.size(); i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size())\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()*2);\n+            if (vect.size() != old_size*2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()*2)\";\n+            }\n+            for (int i = 0; i < old_size; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()*2)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_size*2; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(size()*2)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            int old_cap = vect.capacity();\n+            vect.setSize(vect.capacity()+1);\n+            if (vect.size() != old_cap+1) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(capacity()+1)\";\n+            }\n+            for (int i = 0; i < old_size && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(capacity()+1)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_cap + 1; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(capacity()+1)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()\/2);\n+            if (vect.size() != old_size\/2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()\/2)\";\n+            }\n+            for (int i = 0; i < old_size\/2 && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()\/2)\";\n+                }\n+            }\n+\n+            vect = nextVector();\n+        }\n+        return null;\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestCoarsenedAndNotEscapedLocksElimination.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -362,0 +362,1 @@\n+        applyIf = {\"AlignVector\", \"false\"}, \/\/ a[i] and a[i+1] cannot both be aligned.\n@@ -379,0 +380,1 @@\n+        applyIf = {\"AlignVector\", \"false\"}, \/\/ a[i] and a[i+1] cannot both be aligned.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-           root.array[i]= new Object[45];\n+           root.array[i]= new Object[4500];\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/DeoptReallocFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test Float16 vector conversion chain.\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorization.TestFloat16VectorConvChain\n+*\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+\n+public class TestFloat16VectorConvChain {\n+\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n+    public static void test(short [] res, short [] src1, short [] src2) {\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = (short)Float.float16ToFloat(Float.floatToFloat16(Float.float16ToFloat(src1[i]) + Float.float16ToFloat(src2[i])));\n+        }\n+    }\n+\n+    @Run(test = {\"test\"})\n+    @Warmup(1000)\n+    public static void micro() {\n+        short [] res = new short[1024];\n+        short [] src1 = new short[1024];\n+        short [] src2 = new short[1024];\n+        Arrays.fill(src1, (short)Float.floatToFloat16(1.0f));\n+        Arrays.fill(src2, (short)Float.floatToFloat16(2.0f));\n+        for (int i = 0; i < 1000; i++) {\n+            test(res, src1, src2);\n+        }\n+    }\n+\n+    public static void main(String [] args) {\n+        TestFramework.run(TestFloat16VectorConvChain.class);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test PlainRead\n- * @key cgroups\n- * @requires os.family == \"linux\"\n- * @requires vm.flagless\n- * @library \/testlibrary \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PlainRead\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class PlainRead {\n-\n-    static public void match(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static public void noMatch(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldNotMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static final String good_value = \"(\\\\d+|-1|-2|Unlimited)\";\n-    static final String bad_value = \"(failed)\";\n-\n-    static final String[] variables = {\"Memory Limit is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n-\n-    static public void isContainer(OutputAnalyzer oa) {\n-        for (String v: variables) {\n-            match(oa, v, good_value);\n-        }\n-        for (String v: variables) {\n-            noMatch(oa, v, bad_value);\n-        }\n-    }\n-\n-    static public void isNotContainer(OutputAnalyzer oa) {\n-       oa.shouldMatch(\"^.*Can't open \/proc\/self\/mountinfo.*$\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:os+container=trace\", \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        if (wb.isContainerized()) {\n-            System.out.println(\"Inside a cgroup, testing...\");\n-            isContainer(output);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/PlainRead.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261242\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestContainerized\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestContainerized {\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        if (wb.isContainerized()) {\n+            throw new RuntimeException(\"Test failed! Expected not containerized on plain Linux.\");\n+        }\n+        System.out.println(\"Plain linux, no limits. Passed!\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/TestContainerized.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMinInitialErgonomics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.opt.UseLargePages == null | !vm.opt.UseLargePages\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCErgo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- *  are not tested explicitly in the standard gtests.\n- *\n+ *  are not tested explicitly in the standard gtest. Hence, there is no \"default-ndebug\"\n+ *  since that would be equivalent to the normal gtest for release builds.\n@@ -43,11 +43,1 @@\n-\/* @test id=balanced-with-guards\n- * @summary Run metaspace-related gtests with allocation guards enabled\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.xml\n- * @requires vm.debug\n- * @requires vm.flagless\n- * @run main\/native GTestWrapper --gtest_filter=metaspace* -XX:VerifyMetaspaceInterval=1 -XX:+MetaspaceGuardAllocations\n- *\/\n-\n-\/* @test id=balanced-no-ccs\n+\/* @test id=no-ccs\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceGtests.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8309034\n+ * @bug 8309034 8334545\n@@ -30,3 +30,0 @@\n- * @requires os.simpleArch == \"x64\"\n- * @comment The reproducer only fails in the desired way on x64.\n- * @requires vm.flagless\n@@ -34,2 +31,4 @@\n- *\n- * @run main\/othervm -Xss160K -Xint TestStackOverflowDuringInit\n+ * @requires vm.flagless\n+ * @comment Run with the smallest stack possible to limit the execution time.\n+ *          This is the smallest stack that is supported by all platforms.\n+ * @run main\/othervm -Xss384K -Xint TestStackOverflowDuringInit\n@@ -54,0 +53,22 @@\n+    \/\/ Later changes to the JDK meant that LongCache was initialized before\n+    \/\/ the test even started under jtreg so we define local versions.\n+\n+    static class LongCache {\n+        \/\/ Must have a static initializer\n+        static {\n+            System.out.println(\"LongCache is initializing\");\n+        }\n+        static java.lang.Long valueOf(long l) {\n+            return Long.valueOf(l);\n+        }\n+    }\n+\n+    static class MyLong {\n+        static java.lang.Long valueOf(long l) {\n+            if (l > -128 && l < 127) {\n+                return LongCache.valueOf(l);\n+            } else {\n+                return Long.valueOf(l);\n+            }\n+        }\n+    }\n@@ -57,2 +78,2 @@\n-            \/\/ This will initialize Long but not touch LongCache.\n-            Long.valueOf(1024L);\n+            \/\/ This will initialize MyLong but not touch LongCache.\n+            MyLong.valueOf(1024L);\n@@ -66,1 +87,1 @@\n-            Long.valueOf(0);\n+            MyLong.valueOf(0);\n@@ -71,1 +92,1 @@\n-        String expected = \"java.lang.NoClassDefFoundError: Could not initialize class java.lang.Long$LongCache\";\n+        String expected = \"java.lang.NoClassDefFoundError: Could not initialize class TestStackOverflowDuringInit$LongCache\";\n@@ -74,0 +95,6 @@\n+        \/\/ Pre-load, but not initialize, LongCache, else we will\n+        \/\/ hit SOE during class loading.\n+        System.out.println(\"Pre-loading ...\");\n+        Class<?> c = Class.forName(\"TestStackOverflowDuringInit$LongCache\",\n+                                   false,\n+                                   TestStackOverflowDuringInit.class.getClassLoader());\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+            {\"LockingMode\", \"1\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8239014\n- * @summary -XX:-UseEmptySlotsInSupers sometime fails to reproduce the layout of the old code\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.bits == \"64\" & vm.opt.final.UseCompressedOops == true & vm.gc != \"Z\"\n- * @run main\/othervm -XX:+UseCompressedClassPointers -XX:-UseEmptySlotsInSupers OldLayoutCheck\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.bits == \"32\"\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -XX:-UseEmptySlotsInSupers OldLayoutCheck\n- *\/\n-\n-import java.lang.reflect.Field;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import jdk.internal.misc.Unsafe;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Platform;\n-\n-public class OldLayoutCheck {\n-\n-    static class LIClass {\n-        public long l;\n-        public int i;\n-    }\n-\n-    \/\/ 32-bit VMs: @0:  8 byte header,  @8: long field, @16:  int field\n-    \/\/ 64-bit VMs: @0: 12 byte header, @12:  int field, @16: long field\n-    static final long INT_OFFSET  = Platform.is64bit() ? 12L : 16L;\n-    static final long LONG_OFFSET = Platform.is64bit() ? 16L :  8L;\n-\n-    static public void main(String[] args) {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-        Class c = LIClass.class;\n-        Field[] fields = c.getFields();\n-        for (int i = 0; i < fields.length; i++) {\n-            long offset = unsafe.objectFieldOffset(fields[i]);\n-            if (fields[i].getType() == int.class) {\n-                Asserts.assertEquals(offset, INT_OFFSET, \"Misplaced int field\");\n-            } else if (fields[i].getType() == long.class) {\n-                Asserts.assertEquals(offset, LONG_OFFSET, \"Misplaced long field\");\n-            } else {\n-                Asserts.fail(\"Unexpected field type\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/OldLayoutCheck.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=special\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokespecial\/Checker.java invokespecial\/ClassGenerator.java invokespecial\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests special\n- *\/\n-\n-\/*\n- * @test id=virtual\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokevirtual\/Checker.java invokevirtual\/ClassGenerator.java invokevirtual\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests virtual\n- *\/\n-\n-\/*\n- * @test id=interface\n- * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n- * @requires vm.flagless\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile invokeinterface\/Checker.java invokeinterface\/ClassGenerator.java invokeinterface\/Generator.java\n- *\n- * @run driver\/timeout=1800 invocationOldCHATests interface\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-public class invocationOldCHATests {\n-\n-    public static void runTest(String whichTests, String classFileVersion) throws Throwable {\n-        System.out.println(\"\\nOld CHA invocation tests, Tests: \" + whichTests +\n-                           \", class file version: \" + classFileVersion);\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xmx128M\",\n-            \"-Xcomp\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseVtableBasedCHA\",\n-            \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n-            whichTests, \"--classfile_version=\" + classFileVersion);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        try {\n-            output.shouldContain(\"EXECUTION STATUS: PASSED\");\n-            output.shouldHaveExitValue(0);\n-        } catch (Throwable e) {\n-            System.out.println(\n-                \"\\nNote that an entry such as 'B.m\/C.m' in the failure chart means that\" +\n-                \" the test case failed because method B.m was invoked but the test \" +\n-                \"expected method C.m to be invoked. Similarly, a result such as 'AME\/C.m'\" +\n-                \" means that an AbstractMethodError exception was thrown but the test\" +\n-                \" case expected method C.m to be invoked.\");\n-            System.out.println(\n-                \"\\nAlso note that passing --dump to invoke*.Generator will\" +\n-                \" dump the generated classes (for debugging purposes).\\n\");\n-\n-            throw e;\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        if (args.length < 1) {\n-            throw new IllegalArgumentException(\"Should provide the test name\");\n-        }\n-        String testName = args[0];\n-\n-        \/\/ Get current major class file version and test with it.\n-        byte klassbuf[] = InMemoryJavaCompiler.compile(\"blah\", \"public class blah { }\");\n-        int major_version = klassbuf[6] << 8 | klassbuf[7];\n-\n-        switch (testName) {\n-            case \"special\":\n-                runTest(\"invokespecial.Generator\", String.valueOf(major_version));\n-                break;\n-            case \"virtual\":\n-                runTest(\"invokevirtual.Generator\", String.valueOf(major_version));\n-                break;\n-            case \"interface\":\n-                runTest(\"invokeinterface.Generator\", String.valueOf(major_version));\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unknown test name: \" + testName);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationOldCHATests.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,11 +39,0 @@\n-\/*\n- * @test id=test-64bit-ccs-guarded\n- * @summary Test the VM.metaspace command\n- * @requires vm.bits == \"64\"\n- * @requires vm.debug == true\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -Dwith-compressed-class-space -XX:MaxMetaspaceSize=201M -Xmx100M -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockDiagnosticVMOptions -XX:+MetaspaceGuardAllocations PrintMetaspaceDcmd\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/PrintMetaspaceDcmd.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-        \/\/ - overhead per allocation (padding for alignment, possibly allocation guards)\n+        \/\/ - overhead per allocation (padding for alignment)\n@@ -203,6 +203,0 @@\n-        if (Settings.settings().usesAllocationGuards) {\n-            \/\/ Guards need space.\n-            expectedMaxUsage += (numAllocated * 2);\n-            \/\/ Also, they disable the fbl, so deallocated still counts as used.\n-            expectedMaxUsage += deallocatedWords;\n-        }\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestContext.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-    public boolean usesAllocationGuards = WhiteBox.getWhiteBox().getBooleanVMFlag(\"MetaspaceGuardAllocations\");\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/Settings.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n+ * @modules java.base\/jdk.internal.misc java.management\n@@ -34,1 +33,0 @@\n- *\n@@ -36,1 +34,0 @@\n- *\n@@ -38,2 +35,0 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI  -XX:VerifyMetaspaceInterval=10  -XX:+MetaspaceGuardAllocations        TestMetaspaceAllocation\n- *\n@@ -46,2 +41,1 @@\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n+ * @modules java.base\/jdk.internal.misc java.management\n@@ -50,1 +44,0 @@\n- *\n@@ -52,2 +45,1 @@\n- *\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI                                        TestMetaspaceAllocation\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestMetaspaceAllocation\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/TestMetaspaceAllocation.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @test id=debug-default-strict\n+ * @test id=debug-default-long-manual\n@@ -77,18 +77,0 @@\n-\/*\n- * @test id=debug-guard\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @key randomness\n- * @requires (vm.debug == true)\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm\/timeout=400\n- *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:VerifyMetaspaceInterval=10\n- *      -XX:+MetaspaceGuardAllocations\n- *      TestMetaspaceAllocationMT1 3\n- *\/\n-\n@@ -133,1 +115,0 @@\n-            System.out.println(\"#### guards: \" + Settings.settings().usesAllocationGuards);\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT1.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @test id=debug-default-strict\n+ * @test id=debug-default-long-manual\n@@ -77,18 +77,0 @@\n-\/*\n- * @test id=debug-guard\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @key randomness\n- * @requires (vm.debug == true)\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm\/timeout=400\n- *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:VerifyMetaspaceInterval=10\n- *      -XX:+MetaspaceGuardAllocations\n- *      TestMetaspaceAllocationMT2 3\n- *\/\n-\n@@ -132,1 +114,0 @@\n-            System.out.println(\"#### guards: \" + Settings.settings().usesAllocationGuards);\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT2.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,2 @@\n+    private static final boolean expectSourceInformation = Platform.isLinux() || Platform.isWindows();\n+\n@@ -124,2 +126,3 @@\n-            if (Platform.isWindows() || Platform.isARM()) {\n-                return; \/\/ we are done\n+            if (!Platform.isWindows() && !Platform.isARM()) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -127,2 +130,0 @@\n-            output.reportDiagnosticSummary();\n-            throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -133,9 +134,11 @@\n-        if (okToHaveAllocateHeap) {\n-            System.out.print(stackTraceAllocateHeap);\n-            if (stackTraceMatches(stackTraceAllocateHeap, output)) {\n-                return;\n-            }\n-        } else {\n-            System.out.print(stackTraceDefault);\n-            if (stackTraceMatches(stackTraceDefault, output)) {\n-                return;\n+        String toMatch = okToHaveAllocateHeap ? stackTraceAllocateHeap : stackTraceDefault;\n+        if (!stackTraceMatches(toMatch, output)) {\n+            output.reportDiagnosticSummary();\n+            throw new RuntimeException(\"Expected stack trace missing from output\");\n+        }\n+\n+        System.out.println(\"Looking for source information:\");\n+        if (expectSourceInformation) {\n+            if (!stackTraceMatches(\".*moduleEntry.cpp.*\", output)) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected source information missing from output\");\n@@ -144,3 +147,0 @@\n-        \/\/ Failed to match so dump all the output\n-        output.reportDiagnosticSummary();\n-        throw new RuntimeException(\"Expected stack trace missing from output\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import static jdk.test.lib.Platform.isLinux;\n+import static jdk.test.lib.Platform.isWindows;\n+\n@@ -36,1 +39,1 @@\n- * @test\n+ * @test id=preTouch\n@@ -42,1 +45,11 @@\n- * @run driver TestAlwaysPreTouchStacks\n+ * @run driver TestAlwaysPreTouchStacks preTouch\n+ *\/\n+\n+\/*\n+ * @test id=noPreTouch\n+ * @summary Test that only touched committed memory is reported as thread stack usage.\n+ * @requires os.family != \"aix\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver TestAlwaysPreTouchStacks noPreTouch\n@@ -93,0 +106,8 @@\n+            boolean preTouch;\n+            if (args.length == 1 && args[0].equals(\"noPreTouch\")){\n+                preTouch = false;\n+            } else if (args.length == 1 && args[0].equals(\"preTouch\")){\n+                preTouch = true;\n+            } else {\n+                throw new RuntimeException(\"Invalid test input. Must be 'preTouch' or 'noPreTouch'.\");\n+            }\n@@ -97,1 +118,0 @@\n-                    \"-XX:+AlwaysPreTouchStacks\",\n@@ -99,0 +119,3 @@\n+            if (preTouch){\n+                vmArgs.add(\"-XX:+AlwaysPreTouchStacks\");\n+            }\n@@ -113,2 +136,2 @@\n-            \/\/ We want to see, in the final NMT printout, a committed thread stack size very close to reserved\n-            \/\/ stack size. Like this:\n+            \/\/ If using -XX:+AlwaysPreTouchStacks, we want to see, in the final NMT printout,\n+            \/\/ a committed thread stack size very close to reserved stack size. Like this:\n@@ -138,1 +161,1 @@\n-                    if ((double)committed < ((double)reserved * 0.75)) {\n+                    if (preTouch && (double)committed < ((double)reserved * 0.75)) {\n@@ -140,0 +163,2 @@\n+                    } else if (!preTouch && (double)committed > ((double)reserved * 0.50)){\n+                        throw new RuntimeException(\"Expected a lower ratio between stack committed and reserved.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-    \/\/ final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n-    final static String IN_CONVAR_WAIT = \"waiting on condition\";\n+    final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n@@ -143,1 +142,1 @@\n-                    if (!line.contains(IN_CONVAR_WAIT)) {\n+                    if (!line.contains(IN_OBJECT_WAIT)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpClassInitMonitor.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires vm.cds\n+ * @requires vm.cds & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8306580\n+ * @summary Test the writing error when archive file cannot be created\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver StaticWritingError\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class StaticWritingError {\n+    public static void main(String[] args) throws Exception {\n+        String directoryName = \"nosuchdir\";\n+        String archiveName = \"staticWritingError.jsa\";\n+\n+        \/\/ Perform static dump and attempt to write archive in unwritable directory\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-Xlog:cds\")\n+            .setArchiveName(directoryName + File.separator + archiveName);\n+        OutputAnalyzer out = CDSTestUtils.createArchive(opts);\n+        out.shouldHaveExitValue(1);\n+        out.shouldContain(\"Unable to create shared archive file\");\n+        out.shouldContain(\"Encountered error while dumping\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/StaticWritingError.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-                              .shouldContain(\"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+                              .shouldContain(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/ExceptionDuringDumpAtObjectsInitPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+          \/\/ Class References ---\n+\n@@ -73,0 +75,2 @@\n+          \/\/ Field References ---\n+\n@@ -83,1 +87,0 @@\n-\n@@ -88,0 +91,35 @@\n+          \/\/ Method References ---\n+\n+            \/\/ Should resolve references to own constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp ResolvedConstantsApp.<init>:\")\n+            \/\/ Should resolve references to super constructor\n+            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp java\/lang\/Object.<init>:\")\n+\n+            \/\/ Should resolve interface methods in VM classes\n+            .shouldMatch(\"cds,resolve.*archived interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\")\n+\n+            \/\/ Should resolve references to own non-static method (private or public)\n+            .shouldMatch(\"archived method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\")\n+            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\")\n+\n+            \/\/ Should not resolve references to static method\n+            .shouldNotMatch(\" archived method CP entry.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\")\n+\n+            \/\/ Should resolve references to method in super type\n+            .shouldMatch(\" archived method CP entry.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\")\n+\n+            \/\/ App class cannot resolve references to methods in boot classes:\n+            \/\/    When the app class loader tries to resolve a class X that's normally loaded by\n+            \/\/    the boot loader, it's possible for the app class loader to get a different copy of\n+            \/\/    X (by using MethodHandles.Lookup.defineClass(), etc). Therefore, let's be on\n+            \/\/    the side of safety and revert all such references.\n+            \/\/\n+            \/\/    This will be addressed in JDK-8315737.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\")\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsBar java\/lang\/Class.getName:\")\n+\n+            \/\/ Should not resolve methods in unrelated classes.\n+            .shouldMatch(\"reverted method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\")\n+\n+          \/\/ End ---\n@@ -95,1 +133,5 @@\n-        Object a = new ResolvedConstantsApp();\n+        ResolvedConstantsApp app = new ResolvedConstantsApp();\n+        ResolvedConstantsApp.staticCall();\n+        app.privateInstanceCall();\n+        app.publicInstanceCall();\n+        Object a = app;\n@@ -104,0 +146,4 @@\n+    private static void staticCall() {}\n+    private void privateInstanceCall() {}\n+    public void publicInstanceCall() {}\n+\n@@ -127,0 +173,2 @@\n+\n+        ((ResolvedConstantsFoo)this).doBar(this);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -24,7 +24,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.io.IOException;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n@@ -35,1 +28,6 @@\n- * @run driver TestRecursiveMonitorChurn\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xmx100M -XX:AsyncDeflationInterval=0 -XX:GuaranteedAsyncDeflationInterval=0\n+ *                   -Xlog:monitorinflation=trace\n+ *                   TestRecursiveMonitorChurn\n@@ -37,0 +35,4 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n@@ -49,20 +51,3 @@\n-    public static volatile Monitor monitor;\n-    public static void main(String[] args) throws IOException {\n-        if (args.length == 1 && args[0].equals(\"test\")) {\n-            \/\/ The actual test, in a forked JVM.\n-            for (int i = 0; i < 100000; i++) {\n-                monitor = new Monitor();\n-                monitor.doSomething();\n-            }\n-            System.out.println(\"i + j = \" + (Monitor.i + Monitor.j));\n-        } else {\n-            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                    \"-Xmx100M\", \"-XX:AsyncDeflationInterval=0\", \"-XX:GuaranteedAsyncDeflationInterval=0\",\n-                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\",\n-                    \"TestRecursiveMonitorChurn\",\n-                    \"test\");\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.reportDiagnosticSummary();\n-\n-            output.shouldHaveExitValue(0);\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final int LM_MONITOR = 0;\n+    static final int COUNT = 100000;\n@@ -70,8 +55,14 @@\n-            \/\/ We want to see, in the final NMT printout, a committed object monitor size that is reasonably low.\n-            \/\/ Like this:\n-            \/\/ -           Object Monitors (reserved=208, committed=208)\n-            \/\/                             (malloc=208 #1) (at peak)\n-            \/\/\n-            \/\/ Without recursive locking support, this would look more like this:\n-            \/\/ -           Object Monitors (reserved=20800624, committed=20800624)\n-            \/\/                             (malloc=20800624 #100003) (at peak)\n+    public static volatile Monitor monitor;\n+    public static void main(String[] args) {\n+        if (WB.getIntVMFlag(\"LockingMode\") == LM_MONITOR) {\n+            throw new SkippedException(\"LM_MONITOR always inflates. Invalid test.\");\n+        }\n+        final long pre_monitor_count = WB.getInUseMonitorCount();\n+        System.out.println(\" Precount = \" + pre_monitor_count);\n+        for (int i = 0; i < COUNT; i++) {\n+            monitor = new Monitor();\n+            monitor.doSomething();\n+        }\n+        System.out.println(\"i + j = \" + (Monitor.i + Monitor.j));\n+        final long post_monitor_count = WB.getInUseMonitorCount();\n+        System.out.println(\"Postcount = \" + post_monitor_count);\n@@ -79,12 +70,5 @@\n-            Pattern pat = Pattern.compile(\"- *Object Monitors.*reserved=(\\\\d+), committed=(\\\\d+).*\");\n-            for (String line : output.asLines()) {\n-                Matcher m = pat.matcher(line);\n-                if (m.matches()) {\n-                    long reserved = Long.parseLong(m.group(1));\n-                    long committed = Long.parseLong(m.group(2));\n-                    System.out.println(\">>>>> \" + line + \": \" + reserved + \" - \" + committed);\n-                    if (committed > 1000) {\n-                        throw new RuntimeException(\"Allocated too many monitors\");\n-                    }\n-                    return;\n-                }\n+        if (pre_monitor_count != post_monitor_count) {\n+            final long monitor_count_change = post_monitor_count - pre_monitor_count;\n+            System.out.println(\"Unexpected change in monitor count: \" + monitor_count_change);\n+            if (monitor_count_change < 0) {\n+                throw new RuntimeException(\"Unexpected Deflation\");\n@@ -92,1 +76,1 @@\n-            throw new RuntimeException(\"Did not find expected NMT output\");\n+            throw new RuntimeException(\"Unexpected Inflation\");\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":33,"deletions":49,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -54,0 +55,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -66,0 +68,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -78,0 +81,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -90,0 +94,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -264,6 +269,0 @@\n-        \/\/ For similar reasons, we skip the test on ppc platforms, since there the smaps\n-        \/\/  format may follow a different logic.\n-        if (Platform.isPPC()) {\n-            throw new SkippedException(\"PPC - skipping this test.\");\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -31,1 +31,0 @@\n-import java.util.ArrayList;\n@@ -44,1 +43,1 @@\n- * @run testng SystemDumpMapTest\n+ * @run testng\/othervm -XX:+UsePerfData SystemDumpMapTest\n@@ -46,1 +45,1 @@\n-public class SystemDumpMapTest {\n+public class SystemDumpMapTest extends SystemMapTestBase {\n@@ -67,1 +66,3 @@\n-            patterns.add(Pattern.compile(regexBase + \".*jvm.*\"));\n+            for (String s: shouldMatchUnconditionally) {\n+                patterns.add(Pattern.compile(s));\n+            }\n@@ -69,4 +70,3 @@\n-                patterns.add(Pattern.compile(regexBase + \".*JAVAHEAP.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*META.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*CODE.*\"));\n-                patterns.add(Pattern.compile(regexBase + \".*STACK.*main.*\"));\n+                for (String s: shouldMatchIfNMTIsEnabled) {\n+                    patterns.add(Pattern.compile(s));\n+                }\n@@ -74,0 +74,1 @@\n+\n@@ -77,0 +78,1 @@\n+                    System.out.println(\"   \" + line);\n@@ -79,0 +81,1 @@\n+                            System.out.println(\">>> matches \" + pat);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -30,7 +30,0 @@\n-import java.io.*;\n-import java.util.ArrayDeque;\n-import java.util.Collections;\n-import java.util.Deque;\n-import java.util.HashSet;\n-import java.util.regex.Pattern;\n-\n@@ -46,1 +39,1 @@\n- * @run testng SystemMapTest\n+ * @run testng\/othervm -XX:+UsePerfData SystemMapTest\n@@ -48,1 +41,1 @@\n-public class SystemMapTest {\n+public class SystemMapTest extends SystemMapTestBase {\n@@ -51,1 +44,0 @@\n-        output.reportDiagnosticSummary();\n@@ -53,3 +45,3 @@\n-\n-        String regexBase = \".*0x\\\\p{XDigit}+ - 0x\\\\p{XDigit}+ +\\\\d+\";\n-        output.shouldMatch(regexBase + \".*jvm.*\");\n+        for (String s: shouldMatchUnconditionally) {\n+            output.shouldMatch(s);\n+        }\n@@ -57,4 +49,3 @@\n-            output.shouldMatch(regexBase + \".*JAVAHEAP.*\");\n-            output.shouldMatch(regexBase + \".*META.*\");\n-            output.shouldMatch(regexBase + \".*CODE.*\");\n-            output.shouldMatch(regexBase + \".*STACK.*main.*\");\n+            for (String s: shouldMatchIfNMTIsEnabled) {\n+                output.shouldMatch(s);\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class SystemMapTestBase {\n+\n+    \/\/ e.g.\n+    \/\/ 0x00000007ff800000-0x00000007ff91a000      1155072 rw-p      1155072            0 4K   com              JAVAHEAP                              \/shared\/projects\/openjdk\/jdk-jdk\/output-fastdebug\/images\/jdk\/lib\/server\/classes.jsa\n+    private static final String range = \"0x\\\\p{XDigit}+-0x\\\\p{XDigit}+\";\n+    private static final String space = \" +\";\n+    private static final String someSize = \"\\\\d+\";\n+    private static final String pagesize = \"(4K|8K|16K|64K|2M|16M|64M)\";\n+    private static final String prot = \"[rwsxp-]+\";\n+\n+    private static final String regexBase = range + space +\n+            someSize + space +\n+            prot + space +\n+            someSize + space +\n+            someSize + space +\n+            pagesize + space;\n+\n+    private static final String regexBase_committed = regexBase + \"com.*\";\n+    private static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n+\n+    \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n+    private static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n+    protected static final String shouldMatchUnconditionally[] = {\n+        \/\/ java launcher\n+        regexBase_committed + \"\/bin\/java\",\n+        \/\/ libjvm\n+        regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n+        \/\/ vdso library, should be part of all user space apps on all architectures OpenJDK supports.\n+        regexBase_committed + \"\\\\[vdso\\\\]\",\n+        \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+        regexBase_shared_and_committed + \"hsperfdata_.*\"\n+    };\n+\n+    protected static final String shouldMatchIfNMTIsEnabled[] = {\n+        regexBase_java_heap + \"JAVAHEAP.*\",\n+        \/\/ metaspace\n+        regexBase_committed + \"META.*\",\n+        \/\/ parts of metaspace should be uncommitted\n+        regexBase + \"-\" + space + \"META.*\",\n+        \/\/ code cache\n+        regexBase_committed + \"CODE.*\",\n+        \/\/ Main thread stack\n+        regexBase_committed + \"STACK.*main.*\"\n+    };\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-    fflush(0);\n+    fflush(NULL);\n@@ -278,1 +278,1 @@\n-    fflush(0);\n+    fflush(NULL);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/AddModuleUsesAndProvides\/libAddModuleUsesAndProvidesTest.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GenerateEvents\/libGenerateEvents1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n@@ -135,1 +135,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GenerateEvents\/libGenerateEvents2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -75,1 +75,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetClassFields\/FilteredFields\/libFilteredFieldsTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -518,1 +518,3 @@\n-  memcpy(new_objects, storage->live_objects, current_count * sizeof(*new_objects));\n+  if (storage->live_objects != nullptr) {\n+    memcpy(new_objects, storage->live_objects, current_count * sizeof(*new_objects));\n+  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/libHeapMonitorTest.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/libMissedStackMapFrames.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n@@ -234,1 +234,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop02\/libframepop02.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/get_stack_trace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n@@ -172,1 +172,1 @@\n-      fflush(0);\n+      fflush(nullptr);\n@@ -213,1 +213,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume1\/libSuspendResume1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+    private static Object lockObj = new Object();\n@@ -39,0 +40,10 @@\n+    public static void waitMethod() {\n+        synchronized (lockObj) {\n+            try {\n+                lockObj.wait(300000);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n@@ -44,0 +55,1 @@\n+        Thread objectWait = new Thread(() -> waitMethod());\n@@ -49,0 +61,1 @@\n+        objectWait.start();\n@@ -56,1 +69,2 @@\n-               (primitiveLock.getState() != Thread.State.TIMED_WAITING)) {\n+               (primitiveLock.getState() != Thread.State.TIMED_WAITING) ||\n+               (objectWait.getState() != Thread.State.TIMED_WAITING)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithLock.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @bug 8185796 8335743\n@@ -60,1 +61,2 @@\n-                \"^\\\\s+- locked <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Class for int\\\\)$\"));\n+                \"^\\\\s+- locked <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Class for int\\\\)$\",\n+                \"^\\\\s+- waiting on <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)$\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestClhsdbJstackLock.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @bug 8185796 8335743\n@@ -67,0 +68,1 @@\n+            out.shouldMatch(\"^\\\\s+- waiting on <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)$\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLock.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,0 @@\n-import nsk.share.test.*;\n@@ -77,3 +76,0 @@\n-import vm.share.monitoring.MemoryPoolFinder;\n-\n-import java.io.*;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LoadUnloadGC\/LoadUnloadGC.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package vm.share.monitoring;\n+package gc.gctests.LoadUnloadGC;\n@@ -27,1 +27,1 @@\n-public enum MemoryPoolFinder {\n+enum MemoryPoolFinder {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LoadUnloadGC\/MemoryPoolFinder.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/monitoring\/MemoryPoolFinder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        if (mid == 0) {\n+        if (mid == nullptr) {\n@@ -59,1 +59,1 @@\n-        if (mid2 == 0) {\n+        if (mid2 == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC01\/libnativeGC01.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        if (fid == 0) {\n+        if (fid == nullptr) {\n@@ -56,1 +56,1 @@\n-        if (mid == 0) {\n+        if (mid == nullptr) {\n@@ -69,1 +69,1 @@\n-        if (mid2 == 0) {\n+        if (mid2 == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC02\/libnativeGC02.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-                if (mid == 0) {\n+                if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC03\/libnativeGC03.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-        jclass matrixClass, stackClass, pairClass = 0;\n-        jmethodID stack_pop_mid, stack_empty_mid, matrix_repopulate_mid, pair_geti_mid = 0, pair_getj_mid = 0;\n+        jclass matrixClass, stackClass, pairClass = nullptr;\n+        jmethodID stack_pop_mid, stack_empty_mid, matrix_repopulate_mid, pair_geti_mid = nullptr, pair_getj_mid = nullptr;\n@@ -43,1 +43,1 @@\n-        if (stack_pop_mid == 0) {\n+        if (stack_pop_mid == nullptr) {\n@@ -48,1 +48,1 @@\n-        if (stack_empty_mid == 0) {\n+        if (stack_empty_mid == nullptr) {\n@@ -54,1 +54,1 @@\n-        if (matrix_repopulate_mid == 0) {\n+        if (matrix_repopulate_mid == nullptr) {\n@@ -65,1 +65,1 @@\n-                if (pairClass == 0) {\n+                if (pairClass == nullptr) {\n@@ -68,1 +68,1 @@\n-                        if (pair_geti_mid == 0) {\n+                        if (pair_geti_mid == nullptr) {\n@@ -73,1 +73,1 @@\n-                        if (pair_getj_mid == 0) {\n+                        if (pair_getj_mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC05\/libnativeGC05.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import vm.share.VMRuntimeEnvUtils;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/gc\/HighWaterMarkTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.gc;\n+package metaspace.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/share\/HeapOOMEException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/HeapOOMEException.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.gc;\n+package metaspace.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/share\/TriggerUnloadingByFillingMetaspace.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingByFillingMetaspace.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.gc;\n+package metaspace.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/share\/TriggerUnloadingHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingHelper.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.gc;\n+package metaspace.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/share\/TriggerUnloadingWithWhiteBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingWithWhiteBox.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,2 @@\n-import vm.share.InMemoryJavaCompiler;\n+import metaspace.share.TriggerUnloadingHelper;\n+import metaspace.share.TriggerUnloadingWithWhiteBox;\n@@ -62,2 +63,1 @@\n-import vm.share.gc.TriggerUnloadingHelper;\n-import vm.share.gc.TriggerUnloadingWithWhiteBox;\n+import vm.share.InMemoryJavaCompiler;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/staticReferences\/StaticReferences.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jdk.test.whitebox.WhiteBox;\n+import metaspace.share.TriggerUnloadingHelper;\n@@ -36,2 +38,0 @@\n-import jdk.test.whitebox.WhiteBox;\n-import vm.share.gc.TriggerUnloadingHelper;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/PerformChecksHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,5 +27,4 @@\n-import vm.share.gc.HeapOOMEException;\n-import vm.share.gc.TriggerUnloadingByFillingMetaspace;\n-import vm.share.gc.TriggerUnloadingHelper;\n-import vm.share.gc.TriggerUnloadingWithWhiteBox;\n-\n+import metaspace.share.HeapOOMEException;\n+import metaspace.share.TriggerUnloadingByFillingMetaspace;\n+import metaspace.share.TriggerUnloadingHelper;\n+import metaspace.share.TriggerUnloadingWithWhiteBox;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/StressHierarchyBaseClass.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -101,1 +101,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -135,1 +135,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007\/getclfld007.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,0 @@\n-import vm.share.VMRuntimeEnvUtils;\n-import nsk.share.Consts;\n@@ -71,7 +69,0 @@\n-\n-        if (!VMRuntimeEnvUtils.isJITEnabled()) {\n-            System.out.println(\"WARNING: test isn't valid if JIT compilation is disabled\");\n-            System.out.println(\"Exiting with 'PASSED' status\");\n-            System.exit(Consts.JCK_STATUS_BASE + Consts.TEST_PASSED);\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS203\/hs203t004\/hs203t004.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -147,1 +147,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -182,1 +182,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -197,1 +197,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -212,1 +212,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -237,1 +237,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -246,1 +246,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -256,1 +256,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -265,1 +265,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -273,1 +273,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -280,1 +280,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -321,1 +321,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -397,1 +397,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -456,1 +456,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -491,1 +491,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -517,1 +517,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -545,1 +545,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -570,1 +570,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -650,1 +650,1 @@\n-            fflush(0);\n+            fflush(nullptr);\n@@ -677,1 +677,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -697,1 +697,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -714,1 +714,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -728,1 +728,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -735,1 +735,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -748,1 +748,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -758,1 +758,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -770,1 +770,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -777,1 +777,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -782,1 +782,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref001\/followref001.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -173,1 +173,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -180,1 +180,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -194,1 +194,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -202,1 +202,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -215,1 +215,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -229,1 +229,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -238,1 +238,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -247,1 +247,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -256,1 +256,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -265,1 +265,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -272,1 +272,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -283,1 +283,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -298,1 +298,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -351,1 +351,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -386,1 +386,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -407,1 +407,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -459,1 +459,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -534,1 +534,1 @@\n-            fflush(0);\n+            fflush(nullptr);\n@@ -559,1 +559,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -577,1 +577,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -593,1 +593,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -605,1 +605,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -611,1 +611,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -621,1 +621,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -632,1 +632,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -646,1 +646,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -663,1 +663,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -679,1 +679,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -687,1 +687,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -695,1 +695,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref002\/followref002.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -176,1 +176,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -183,1 +183,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -197,1 +197,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -205,1 +205,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -219,1 +219,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -235,1 +235,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -244,1 +244,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -253,1 +253,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -262,1 +262,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -271,1 +271,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -278,1 +278,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -289,1 +289,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -301,1 +301,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -350,1 +350,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -385,1 +385,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -406,1 +406,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -649,1 +649,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -668,1 +668,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -751,1 +751,1 @@\n-                 fflush(0);\n+                 fflush(nullptr);\n@@ -821,1 +821,1 @@\n-            fflush(0);\n+            fflush(nullptr);\n@@ -843,1 +843,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -856,1 +856,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -868,1 +868,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -905,1 +905,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -911,1 +911,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -920,1 +920,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -936,1 +936,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -949,1 +949,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -971,1 +971,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -988,1 +988,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -997,1 +997,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -1006,1 +1006,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -1050,1 +1050,1 @@\n-                fflush(0);\n+                fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref003\/followref003.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -114,1 +114,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -135,1 +135,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -171,1 +171,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -178,1 +178,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -195,1 +195,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref004\/followref004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref005\/followref005.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref006\/followref006.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return errCode\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return errCode\n@@ -62,1 +62,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -73,1 +73,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -123,1 +123,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -179,1 +179,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -271,1 +271,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretbase\/earlyretbase.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -178,1 +178,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -223,1 +223,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -259,1 +259,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -292,1 +292,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -364,1 +364,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -434,1 +434,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -443,1 +443,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -454,1 +454,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretfp\/earlyretfp.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -187,1 +187,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -232,1 +232,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -273,1 +273,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -298,1 +298,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -455,1 +455,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -466,1 +466,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretint\/earlyretint.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -171,1 +171,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -216,1 +216,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -254,1 +254,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -279,1 +279,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -415,1 +415,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -426,1 +426,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretlong\/earlyretlong.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -171,1 +171,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -216,1 +216,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -254,1 +254,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -277,1 +277,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -413,1 +413,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -422,1 +422,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretobj\/earlyretobj.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -170,1 +170,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -215,1 +215,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -252,1 +252,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -276,1 +276,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -412,1 +412,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretstr\/earlyretstr.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -158,1 +158,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -195,1 +195,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -226,1 +226,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -342,1 +342,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -352,1 +352,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretvoid\/earlyretvoid.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n@@ -228,1 +228,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -294,1 +294,1 @@\n-        fflush(0);\n+        fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetAllStackTraces\/getallstktr001\/getallstktr001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#define RETURN_FAILED errCode = STATUS_FAILED; fflush(0); return\n+#define RETURN_FAILED errCode = STATUS_FAILED; fflush(nullptr); return\n@@ -66,1 +66,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n@@ -86,1 +86,1 @@\n-    fflush(0);\n+    fflush(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetConstantPool\/getcpool001\/getcpool001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/rawmonitor\/rawmonitor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * Interface defining methods to control mirror of debuggee (i.e. debugged VM).\n+ * Class defining methods to control mirror of debuggee (i.e. debugged VM).\n@@ -35,1 +35,1 @@\n-public interface Debuggee {\n+public class Debuggee extends LocalProcess {\n@@ -42,40 +42,0 @@\n-    \/**\n-     * Launch debuggee.\n-     *\n-     * @throws IOException\n-     *\/\n-    public void launch (String[] args) throws IOException;\n-\n-    \/** Return exit status. *\/\n-    public int getStatus ();\n-\n-    \/** Check whether the process has been terminated. *\/\n-    public boolean terminated();\n-\n-    \/** Kill the debuggee VM. *\/\n-    public void killDebuggee ();\n-\n-    \/** Wait until the debuggee VM shutdown or crash. *\/\n-    public int waitForDebuggee () throws InterruptedException;\n-\n-    \/** Get a pipe to write to the debuggee's stdin stream. *\/\n-    public OutputStream getInPipe ();\n-\n-    \/** Get a pipe to read the debuggee's stdout stream. *\/\n-    public InputStream getOutPipe ();\n-\n-    \/** Get a pipe to read the debuggee's stderr stream. *\/\n-    public InputStream getErrPipe ();\n-\n-    \/** Redirect stdout stream to <code>Log<\/code> *\/\n-    public void redirectStdout(Log log, String prefix);\n-\n-    \/** Redirect stderr stream to <code>Log<\/code> *\/\n-    public void redirectStderr(Log log, String prefix);\n-}\n-\n-\/**\n- * Mirror of locally launched debuggee.\n- *\/\n-final class LocalLaunchedDebuggee extends LocalProcess implements Debuggee {\n-\n@@ -93,1 +53,1 @@\n-    LocalLaunchedDebuggee (Launcher launcher) {\n+    Debuggee(Launcher launcher) {\n@@ -238,67 +198,0 @@\n-\/**\n- * Mirror of remotely launched debuggee.\n- *\/\n-final class RemoteLaunchedDebuggee implements Debuggee {\n-\n-    \/** Launcher that creates this debuggee. *\/\n-    private Launcher launcher = null;\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    RemoteLaunchedDebuggee (Launcher launcher) {\n-        super();\n-        this.launcher = launcher;\n-    }\n-\n-    \/**\n-     * Launch debugee on remote host via <code>Launcher<\/code> object.\n-     *\/\n-    public void launch(String[] args) throws IOException {\n-        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n-        launcher.display(\"Starting remote java process:\\n\" + cmdLine);\n-        launcher.launchRemoteProcess(args);\n-    }\n-\n-    \/** Return exit status of the debuggee VM. *\/\n-    public int getStatus () {\n-        return launcher.getRemoteProcessStatus();\n-    }\n-\n-    \/** Check whether the debuggee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return launcher.isRemoteProcessTerminated();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debuggee VM. *\/\n-    public void killDebuggee () {\n-        launcher.killRemoteProcess();\n-    }\n-\n-    \/** Wait until the debuggee VM shutdown or crash. *\/\n-    public int waitForDebuggee () {\n-        return launcher.waitForRemoteProcess();\n-    }\n-\n-    \/** Get a pipe to write to the debuggee's stdin stream. *\/\n-    public OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debuggee's stdout stream. *\/\n-    public InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debuggee's stderr stream. *\/\n-    public InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Debuggee.java","additions":4,"deletions":111,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,43 +106,10 @@\n-        if (argumentHandler.isLaunchedLocally()) {\n-\n-            if (argumentHandler.isDefaultConnector()) {\n-\n-                localDefaultLaunch(jdbCmdArgs, classToExecute);\n-\n-            } else if (argumentHandler.isRawLaunchingConnector()) {\n-\n-                localRawLaunch(jdbCmdArgs, classToExecute);\n-\n-            } else if (argumentHandler.isLaunchingConnector()) {\n-\n-                localLaunch(jdbCmdArgs, classToExecute);\n-\n-            } else if (argumentHandler.isAttachingConnector()) {\n-\n-                localLaunchAndAttach(jdbCmdArgs, classToExecute);\n-\n-            } else if (argumentHandler.isListeningConnector()) {\n-\n-                localLaunchAndListen(jdbCmdArgs, classToExecute);\n-\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for local launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n-        } else if (argumentHandler.isLaunchedRemotely()) {\n-\n-            connectToBindServer(classToExecute);\n-\n-            if (argumentHandler.isAttachingConnector()) {\n-\n-                remoteLaunchAndAttach(jdbCmdArgs, classToExecute);\n-\n-            } else if (argumentHandler.isListeningConnector()) {\n-\n-                remoteLaunchAndListen(jdbCmdArgs, classToExecute);\n-\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for remote launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n+        if (argumentHandler.isDefaultConnector()) {\n+            localDefaultLaunch(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isRawLaunchingConnector()) {\n+            localRawLaunch(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isLaunchingConnector()) {\n+            localLaunch(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isAttachingConnector()) {\n+            localLaunchAndAttach(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isListeningConnector()) {\n+            localLaunchAndListen(jdbCmdArgs, classToExecute);\n@@ -150,1 +117,2 @@\n-            throw new Failure(\"Unexpected launching mode: \" + argumentHandler.getLaunchMode());\n+            throw new TestBug(\"Unexpected connector type for local launch mode\"\n+                              + argumentHandler.getConnectorType());\n@@ -152,0 +120,1 @@\n+\n@@ -201,5 +170,1 @@\n-                    if (argumentHandler.isLaunchedLocally()) {\n-                        connectorAddress = argumentHandler.getTransportPort();\n-                    } else {\n-                        connectorAddress = argumentHandler.getDebugeeHost() + \":\" + argumentHandler.getTransportPort();\n-                    }\n+                    connectorAddress = argumentHandler.getTransportPort();\n@@ -250,2 +215,0 @@\n-                    if (argumentHandler.isLaunchedRemotely())\n-                        connect.append(\",hostname=\" + argumentHandler.getDebugeeHost().trim());\n@@ -327,1 +290,1 @@\n-        debuggee = new LocalLaunchedDebuggee(this);\n+        debuggee = new Debuggee(this);\n@@ -349,1 +312,1 @@\n-        debuggee = new LocalLaunchedDebuggee(this);\n+        debuggee = new Debuggee(this);\n@@ -356,45 +319,0 @@\n-    \/**\n-     * Run test in remote mode using attaching connector.\n-     *\/\n-    private void remoteLaunchAndAttach\n-       (String[] jdbCmdArgs, String classToExecute) throws IOException {\n-\n-        debuggee = new RemoteLaunchedDebuggee(this);\n-        String address = makeTransportAddress();\n-        String[] javaCmdArgs = makeCommandLineArgs(classToExecute, address);\n-        try {\n-            debuggee.launch(javaCmdArgs);\n-        } catch (IOException e) {\n-            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n-                            + e);\n-        };\n-\n-        display(\"Start jdb attaching to remote debuggee\");\n-        jdb = Jdb.startAttachingJdb (this, jdbCmdArgs, JDB_STARTED);\n-\/\/        jdb.waitForPrompt(0, false);\n-    }\n-\n-    \/**\n-     * Run test in remote mode using listening connector.\n-     *\/\n-    private void remoteLaunchAndListen\n-       (String[] jdbCmdArgs, String classToExecute) throws IOException {\n-\n-        jdb = new Jdb(this);\n-        display(\"Starting jdb listening to remote debuggee\");\n-        jdb.launch(jdbCmdArgs);\n-        String address = jdb.waitForListeningJdb();\n-        display(\"Listening address found: \" + address);\n-\n-        debuggee = new RemoteLaunchedDebuggee(this);\n-        String[] javaCmdArgs = makeCommandLineArgs(classToExecute);\n-        try {\n-            debuggee.launch(javaCmdArgs);\n-        } catch (IOException e) {\n-            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n-                            + e);\n-        };\n-\n-        jdb.waitForMessage(0, JDB_STARTED);\n-\/\/        jdb.waitForPrompt(0, false);\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":17,"deletions":99,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -460,12 +460,0 @@\n-        if (! isLaunchedLocally() && ! isDefaultDebugeeSuspendMode()) {\n-            throw new BadOption(\"inconsistent options: \"\n-                                + \"-debugee.launch=\" + getLaunchMode()\n-                                + \" and -debugee.suspend=\" + getDebugeeSuspendMode());\n-        }\n-\n-        if (! isLaunchedLocally() && isLaunchingConnector()) {\n-            throw new BadOption(\"inconsistent options: \"\n-                                + \"-debugee.launch=\" + getLaunchMode()\n-                                + \" and -connector=\" + getConnectorType());\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/ArgumentHandler.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -130,2 +130,1 @@\n-        LocalLaunchedDebugee debugee = new LocalLaunchedDebugee(process, this);\n-        return debugee;\n+        return new Debugee(process, this);\n@@ -192,41 +191,10 @@\n-        if (argumentHandler.isLaunchedLocally()) {\n-\n-            if (argumentHandler.isDefaultConnector()) {\n-                debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isRawLaunchingConnector()) {\n-                debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isLaunchingConnector()) {\n-                debugee = localLaunchDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isAttachingConnector()) {\n-                debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isListeningConnector()) {\n-                debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for local debugee launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n-        } else if (argumentHandler.isLaunchedRemotely()) {\n-\n-            connectToBindServer(classToExecute);\n-\n-            if (argumentHandler.isAttachingConnector()) {\n-                debugee = remoteLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isListeningConnector()) {\n-                debugee = remoteLaunchAndListenDebugee(vmm, classToExecute, classPath);\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for remote debugee launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n-        } else if (argumentHandler.isLaunchedManually()) {\n-\n-            if (argumentHandler.isAttachingConnector()) {\n-                debugee = manualLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isListeningConnector()) {\n-                debugee = manualLaunchAndListenDebugee(vmm, classToExecute, classPath);\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for manual debugee launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n+        if (argumentHandler.isDefaultConnector()) {\n+            debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isRawLaunchingConnector()) {\n+            debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isLaunchingConnector()) {\n+            debugee = localLaunchDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isAttachingConnector()) {\n+            debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isListeningConnector()) {\n+            debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);\n@@ -234,1 +202,2 @@\n-            throw new Failure(\"Unexpected debugee launching mode: \" + argumentHandler.getLaunchMode());\n+            throw new TestBug(\"Unexpected connector type for local debugee launch mode\"\n+                              + argumentHandler.getConnectorType());\n@@ -237,0 +206,1 @@\n+\n@@ -489,188 +459,0 @@\n-    \/**\n-     * Launch debugee VM remotely via <code>BindServer<\/code> and connect to it using\n-     * <code>AttachingConnector<\/code>.\n-     *\/\n-    private Debugee remoteLaunchAndAttachDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        AttachingConnector connector =\n-            (AttachingConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.attachingConnectors());\n-\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupAttachingConnector(connector, classToExecute, classPath);\n-\n-        String address = makeTransportAddress();\n-        String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);\n-        String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-\n-        display(\"Starting remote java process:\\n\\t\" + javaCmdLine);\n-        Debugee debugee = startRemoteDebugee(cmdLineArgs);\n-\n-        display(\"Attaching to debugee\");\n-        VirtualMachine vm;\n-        IOException ioe = null;\n-        for (int i = 0; i < CONNECT_TRIES; i++) {\n-            try {\n-                vm = connector.attach(arguments);\n-                display(\"Debugee attached\");\n-                debugee.setupVM(vm);\n-                return debugee;\n-            } catch (IOException e) {\n-                display(\"Attempt #\" + i + \" to connect to debugee VM failed:\\n\\t\" + e);\n-                ioe = e;\n-                if (debugee.terminated()) {\n-                    throw new Failure(\"Unable to connect to debuggee VM: VM process is terminated\");\n-                }\n-                try {\n-                    Thread.currentThread().sleep(CONNECT_TRY_DELAY);\n-                } catch (InterruptedException ie) {\n-                    ie.printStackTrace(log.getOutStream());\n-                    throw new Failure(\"Thread interrupted while pausing connection attempts:\\n\\t\"\n-                                    + ie);\n-                }\n-            } catch (IllegalConnectorArgumentsException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new TestBug(\"Wrong connector arguments used to attach to debuggee VM:\\n\\t\" + e);\n-            }\n-        }\n-        throw new Failure(\"Unable to connect to debugee VM after \" + CONNECT_TRIES\n-                        + \" tries:\\n\\t\" + ioe);\n-    }\n-\n-    \/**\n-     * Launch debugee VM remotely via <code>BindServer<\/code> and connect to it using\n-     * <code>ListeningConnector<\/code>.\n-     *\/\n-    private Debugee remoteLaunchAndListenDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        ListeningConnector connector =\n-            (ListeningConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.listeningConnectors());\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupListeningConnector(connector, classToExecute, classPath);\n-\n-        String address = null;\n-        try {\n-            display(\"Listening for connection from debugee\");\n-            address = connector.startListening(arguments);\n-        } catch (IllegalConnectorArgumentsException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new TestBug(\"Wrong connector arguments used to listen debuggee VM:\\n\\t\" + e);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while starting listening debugee VM:\\n\\t\" + e);\n-        };\n-\n-        String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);\n-        String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-\n-        display(\"Starting remote java process:\\n\\t\" + javaCmdLine);\n-        Debugee debugee = startRemoteDebugee(cmdLineArgs);\n-\n-        display(\"Waiting for connection from debugee\");\n-        VirtualMachine vm;\n-        IOException ioe = null;\n-        for (int i = 0; i < CONNECT_TRIES; i++) {\n-            try {\n-                vm = connector.accept(arguments);\n-                connector.stopListening(arguments);\n-                display(\"Debugee attached\");\n-                debugee.setupVM(vm);\n-                return debugee;\n-            } catch (IOException e) {\n-                display(\"Attempt #\" + i + \" to listen debugee VM failed:\\n\\t\" + e);\n-                ioe = e;\n-                if (debugee.terminated()) {\n-                    throw new Failure(\"Unable to connect to debuggee VM: VM process is terminated\");\n-                }\n-                try {\n-                    Thread.currentThread().sleep(CONNECT_TRY_DELAY);\n-                } catch (InterruptedException ie) {\n-                    ie.printStackTrace(log.getOutStream());\n-                    throw new Failure(\"Thread interrupted while pausing connection attempts:\\n\\t\"\n-                                    + ie);\n-                }\n-            } catch (IllegalConnectorArgumentsException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new TestBug(\"Wrong connector arguments used to listen debuggee VM:\\n\\t\" + e);\n-            }\n-        }\n-        throw new Failure(\"Unable to connect to debugee VM after \" + CONNECT_TRIES\n-                        + \" tries:\\n\\t\" + ioe);\n-    }\n-\n-    \/\/ -------------------------------------------------- \/\/\n-\n-    \/**\n-     * Prompt to manually launch debugee VM and connect to it using\n-     * <code>AttachingConnector<\/code>.\n-     *\/\n-    private Debugee manualLaunchAndAttachDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        AttachingConnector connector =\n-            (AttachingConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.attachingConnectors());\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupAttachingConnector(connector, classToExecute, classPath);\n-\n-        String address = makeTransportAddress();\n-        String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-\n-        display(\"Starting manual java process:\\n\\t\" + javaCmdLine);\n-        ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);\n-\n-        VirtualMachine vm;\n-        try {\n-            display(\"Attaching to debugee\");\n-            vm = connector.attach(arguments);\n-        } catch (IllegalConnectorArgumentsException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new TestBug(\"Wrong connector arguments used to attach to debuggee VM:\\n\\t\" + e);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while attaching to debugee VM:\\n\\t\" + e);\n-        };\n-        display(\"Debugee attached\");\n-\n-        debugee.setupVM(vm);\n-        return debugee;\n-    }\n-\n-    \/**\n-     * Prompt to manually launch debugee VM and connect to it using\n-     * <code>ListeningConnector<\/code>.\n-     *\/\n-    private Debugee manualLaunchAndListenDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        ListeningConnector connector =\n-            (ListeningConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.listeningConnectors());\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupListeningConnector(connector, classToExecute, classPath);\n-\n-        VirtualMachine vm;\n-        try {\n-            display(\"Listening for connection from debugee\");\n-            String address = connector.startListening(arguments);\n-            String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-            display(\"Starting manual java process:\\n\\t\" + javaCmdLine);\n-            ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);\n-            display(\"Waiting for connection from debugee\");\n-            vm = connector.accept(arguments);\n-            display(\"Debugee attached\");\n-            connector.stopListening(arguments);\n-            debugee.setupVM(vm);\n-            return debugee;\n-        } catch (IllegalConnectorArgumentsException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new TestBug(\"Wrong connector arguments used to listen debuggee VM:\\n\\t\" + e);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while listening to debugee VM:\\n\\t\" + e);\n-        }\n-    }\n-\n@@ -923,27 +705,0 @@\n-    \/**\n-     * Launch remote debuggee process with specified command line arguments\n-     * and make initial <code>Debugee<\/code> mirror.\n-     *\/\n-    protected RemoteLaunchedDebugee startRemoteDebugee(String[] cmdArgs) {\n-        try {\n-            launchRemoteProcess(cmdArgs);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while launching remote debuggee VM process:\\n\\t\"\n-                            + e);\n-        }\n-\n-        RemoteLaunchedDebugee debugee = new RemoteLaunchedDebugee(this);\n-        return debugee;\n-    }\n-\n-    \/**\n-     * Launch manual debuggee process with specified command line arguments\n-     * and make initial <code>Debugee<\/code> mirror.\n-     *\/\n-    protected ManualLaunchedDebugee startManualDebugee(String cmd) {\n-        ManualLaunchedDebugee debugee = new ManualLaunchedDebugee(this);\n-        debugee.launchDebugee(cmd);\n-        return debugee;\n-    }\n-\n@@ -998,284 +753,1 @@\n-}\n-\n-\n-\/**\n- * Mirror of locally launched debugee.\n- *\/\n-final class LocalLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the locally started VM process. *\/\n-    public LocalLaunchedDebugee (Process process, Binder binder) {\n-        super(binder);\n-        this.process = process;\n-        checkTermination = true;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return process.exitValue();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        if (process == null)\n-            return true;\n-\n-        try {\n-            int value = process.exitValue();\n-            return true;\n-        } catch (IllegalThreadStateException e) {\n-            return false;\n-        }\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            log.display(\"Killing debugee VM process\");\n-            process.destroy();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () throws InterruptedException {\n-        int code = process.waitFor();\n-        return code;\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return process.getOutputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return process.getInputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return process.getErrorStream();\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of remotely launched debugee.\n- *\/\n-final class RemoteLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the remotely started VM process. *\/\n-    public RemoteLaunchedDebugee (Binder binder) {\n-        super(binder);\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return binder.getRemoteProcessStatus();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return binder.isRemoteProcessTerminated();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            binder.killRemoteProcess();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        return binder.waitForRemoteProcess();\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of manually launched debugee.\n- *\/\n-final class ManualLaunchedDebugee extends Debugee {\n-    \/** Enwrap the manually started VM process. *\/\n-    public ManualLaunchedDebugee (Binder binder) {\n-        super(binder);\n-        makeInputReader();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    private int exitCode = 0;\n-    private boolean finished = false;\n-    private static BufferedReader bin = null;\n-\n-    public void launchDebugee(String commandLine) {\n-        makeInputReader();\n-\n-        putMessage(\"Launch target VM using such command line:\\n\"\n-                    + commandLine);\n-        String answer = askQuestion(\"Has the VM successfully started? (yes\/no)\", \"yes\");\n-        for ( ; ; ) {\n-            if (answer.equals(\"yes\"))\n-                break;\n-            if (answer.equals(\"no\"))\n-                throw new Failure (\"Unable to manually launch debugee VM\");\n-            answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-        }\n-    }\n-\n-    private static void makeInputReader() {\n-        if (bin == null) {\n-            bin = new BufferedReader(new InputStreamReader(System.in));\n-        }\n-    }\n-\n-    private static void destroyInputReader() {\n-        if (bin != null) {\n-            try {\n-                bin.close();\n-            } catch (IOException e) {\n-\/\/                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Caught exception while closing input stream:\\n\\t\" + e);\n-            }\n-            bin = null;\n-        }\n-    }\n-\n-    private static void putMessage(String msg) {\n-        System.out.println(\"\\n>>> \" + msg);\n-    }\n-\n-    private static String askQuestion(String question, String defaultAnswer) {\n-        try {\n-            System.out.print(\"\\n>>> \" + question);\n-            System.out.print(\" [\" + defaultAnswer + \"] \");\n-            System.out.flush();\n-            String answer = bin.readLine();\n-            if (answer.equals(\"\"))\n-                return defaultAnswer;\n-            return answer;\n-        } catch (IOException e) {\n-\/\/            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while reading answer:\\n\\t\" + e);\n-        }\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        if (! finished) {\n-            throw new Failure(\"Unable to get status of debugee VM: process still alive\");\n-        }\n-        return exitCode;\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return finished;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            putMessage(\"Kill launched VM\");\n-            String answer = askQuestion(\"Has the VM successfully terminated? (yes\/no)\", \"yes\");\n-            for ( ; ; ) {\n-                if (answer.equals(\"yes\")) {\n-                    finished = true;\n-                    break;\n-                }\n-                if (answer.equals(\"no\"))\n-                    throw new Failure (\"Unable to manually kill debugee VM\");\n-                answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-            }\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        putMessage(\"Wait for launched VM to exit.\");\n-        String answer = askQuestion(\"What is VM exit code?\", \"95\");\n-        for ( ; ; ) {\n-            try {\n-                exitCode = Integer.parseInt(answer);\n-                break;\n-            } catch (NumberFormatException e) {\n-                answer = askQuestion(\"Wrong answer. Please type integer value\", \"95\");\n-            }\n-        }\n-        finished = true;\n-        return exitCode;\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-\n-    public void close() {\n-        destroyInputReader();\n-        super.close();\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Binder.java","additions":15,"deletions":543,"binary":false,"changes":558,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-abstract public class Debugee extends DebugeeProcess {\n+public class Debugee extends DebugeeProcess {\n@@ -68,0 +68,7 @@\n+        this.argumentHandler = (ArgumentHandler)binder.getArgumentHandler();\n+    }\n+\n+    protected Debugee (Process process, Binder binder) {\n+        super(binder);\n+        this.process = process;\n+        this.binder = binder;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Debugee.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,7 +101,2 @@\n-        if (argumentHandler.isLaunchedRemotely()) {\n-            connectToBindServer(classToExecute);\n-            debugee = launchDebugee(classToExecute);\n-        } else {\n-            debugee = launchDebugee(classToExecute);\n-            debugee.redirectOutput(log);\n-        }\n+        debugee = launchDebugee(classToExecute);\n+        debugee.redirectOutput(log);\n@@ -120,33 +115,7 @@\n-\n-            if (argumentHandler.isLaunchedLocally()) {\n-                LocalLaunchedDebugee debugee = new LocalLaunchedDebugee(this);\n-                String address = debugee.prepareTransport(argumentHandler);\n-                if (address == null)\n-                    address = makeTransportAddress();\n-                String[] argsArray = makeCommandLineArgs(classToExecute, address);\n-                debugee.launch(argsArray);\n-                return debugee;\n-            }\n-\n-            if (argumentHandler.isLaunchedRemotely()) {\n-                RemoteLaunchedDebugee debugee = new RemoteLaunchedDebugee(this);\n-                String address = debugee.prepareTransport(argumentHandler);\n-                if (address == null)\n-                    address = makeTransportAddress();\n-                String[] argsArray = makeCommandLineArgs(classToExecute, address);\n-                debugee.launch(argsArray);\n-                return debugee;\n-            }\n-\n-            if (argumentHandler.isLaunchedManually()) {\n-                ManualLaunchedDebugee debugee = new ManualLaunchedDebugee(this);\n-                String address = debugee.prepareTransport(argumentHandler);\n-                if (address == null)\n-                    address = makeTransportAddress();\n-                String cmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-                debugee.launch(cmdLine);\n-                return debugee;\n-            }\n-\n-            throw new TestBug(\"Unexpected launching mode: \"\n-                            + argumentHandler.getLaunchMode());\n+            Debugee debugee = new Debugee(this);\n+            String address = debugee.prepareTransport(argumentHandler);\n+            if (address == null)\n+                address = makeTransportAddress();\n+            String[] argsArray = makeCommandLineArgs(classToExecute, address);\n+            debugee.launch(argsArray);\n+            return debugee;\n@@ -158,293 +127,1 @@\n-\n-}\n-\n-\/**\n- * Mirror of locally launched debugee.\n- *\/\n-final class LocalLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    public LocalLaunchedDebugee (Binder binder) {\n-        super(binder);\n-        checkTermination = true;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    public void launch(String[] args) throws IOException {\n-        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n-        display(\"Starting java process:\\n\" + cmdLine);\n-        process = binder.launchProcess(args);\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return process.exitValue();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        if (process == null)\n-            return true;\n-\n-        try {\n-            int value = process.exitValue();\n-            return true;\n-        } catch (IllegalThreadStateException e) {\n-            return false;\n-        }\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            log.display(\"Killing debugee VM process\");\n-            process.destroy();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () throws InterruptedException {\n-        return process.waitFor();\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return process.getOutputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return process.getInputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return process.getErrorStream();\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of remotely launched debugee.\n- *\/\n-final class RemoteLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    public RemoteLaunchedDebugee (Binder binder) {\n-        super(binder);\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    public void launch(String[] args) throws IOException {\n-        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n-        display(\"Starting remote java process:\\n\" + cmdLine);\n-        binder.launchRemoteProcess(args);\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return binder.getRemoteProcessStatus();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return binder.isRemoteProcessTerminated();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            log.display(\"Killing debugee VM process\");\n-            binder.killRemoteProcess();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        return binder.waitForRemoteProcess();\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of manually launched debugee.\n- *\/\n-final class ManualLaunchedDebugee extends Debugee {\n-\n-    private int exitCode = 0;\n-    private boolean finished = false;\n-    private static BufferedReader bin = new BufferedReader(new InputStreamReader(System.in));\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    public ManualLaunchedDebugee (Binder binder) {\n-        super(binder);\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    public void launch(String commandLine) throws IOException {\n-        putMessage(\"Launch target VM using such command line:\\n\"\n-                    + commandLine);\n-        String answer = askQuestion(\"Has the VM successfully started? (yes\/no)\", \"yes\");\n-        for ( ; ; ) {\n-            if (answer.equals(\"yes\"))\n-                break;\n-            if (answer.equals(\"no\"))\n-                throw new Failure (\"Unable to manually launch debugee VM\");\n-            answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-        }\n-    }\n-\n-    private void putMessage(String msg) {\n-        System.out.println(\"\\n>>> \" + msg);\n-    }\n-\n-    private String askQuestion(String question, String defaultAnswer) {\n-        try {\n-            System.out.print(\"\\n>>> \" + question);\n-            System.out.print(\" [\" + defaultAnswer + \"] \");\n-            System.out.flush();\n-            String answer = bin.readLine();\n-            if (answer.equals(\"\"))\n-                return defaultAnswer;\n-            return answer;\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while reading answer:\\n\\t\" + e);\n-        }\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        if (! terminated()) {\n-            throw new Failure(\"Unable to get status of debugee VM: process still alive\");\n-        }\n-        return exitCode;\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        if(! finished) {\n-            String answer = askQuestion(\"Has the VM exited?\", \"no\");\n-            for ( ; ; ) {\n-                if (answer.equals(\"no\"))\n-                    return false;\n-                if (answer.equals(\"yes\")) {\n-                    finished = true;\n-                    waitForDebugee();\n-                    break;\n-                }\n-                answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-            }\n-        }\n-        return finished;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            putMessage(\"Kill launched VM\");\n-            String answer = askQuestion(\"Has the VM successfully terminated? (yes\/no)\", \"yes\");\n-            for ( ; ; ) {\n-                if (answer.equals(\"yes\")) {\n-                    finished = true;\n-                    break;\n-                }\n-                if (answer.equals(\"no\"))\n-                    throw new Failure (\"Unable to manually kill debugee VM\");\n-                answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-            }\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        putMessage(\"Wait for launched VM to exit.\");\n-        String answer = askQuestion(\"What is VM exit code?\", \"95\");\n-        for ( ; ; ) {\n-            try {\n-                exitCode = Integer.parseInt(answer);\n-                break;\n-            } catch (NumberFormatException e) {\n-                answer = askQuestion(\"Wrong answer. Please type integer value\", \"95\");\n-            }\n-        }\n-        finished = true;\n-        return exitCode;\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-\n-    public void close() {\n-        try {\n-            bin.close();\n-        } catch (IOException e) {\n-            log.display(\"WARNING: Caught IOException while closing InputStream\");\n-        }\n-        bin = null;\n-        super.close();\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdwp\/Binder.java","additions":10,"deletions":333,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-abstract public class Debugee extends DebugeeProcess {\n+public class Debugee extends DebugeeProcess {\n@@ -66,0 +66,6 @@\n+    public void launch(String[] args) throws IOException {\n+        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n+        display(\"Starting java process:\\n\" + cmdLine);\n+        process = binder.launchProcess(args);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdwp\/Debugee.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n- * <li> <code>-debugee.launch=[local|remote|manual]<\/code> -\n- *   launch and bind to debugee VM locally, remotely (via BindSever) or manually\n@@ -278,5 +276,2 @@\n-        if (isLaunchedLocally()) {\n-            String mode = getDebugeeSuspendMode();\n-            return mode.equals(\"no\");\n-        }\n-        return true;\n+        String mode = getDebugeeSuspendMode();\n+        return mode.equals(\"no\");\n@@ -340,48 +335,0 @@\n-    \/**\n-     * Return debugee VM launching mode, specified by\n-     * <code>-launch.mode<\/code> command line option, or\n-     * \"<i>local<\/i>\" string by default.\n-     *\n-     * Possible values for this option are:\n-     * <ul>\n-     * <li> \"<code>local<\/code>\"\n-     * <li> \"<code>remote<\/code>\"\n-     * <li> \"<code>manual<\/code>\"\n-     * <\/ul>\n-     *\n-     * @see #isLaunchedLocally()\n-     * @see #isLaunchedRemotely()\n-     * @see #isLaunchedManually()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getLaunchMode() {\n-        return options.getProperty(\"debugee.launch\", \"local\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if debugee should be launched locally.\n-     *\n-     * @see #getLaunchMode()\n-     *\/\n-    public boolean isLaunchedLocally() {\n-        return getLaunchMode().equals(\"local\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if debugee should be launched remotely via\n-     * BindServer.\n-     *\n-     * @see #getLaunchMode()\n-     *\/\n-    public boolean isLaunchedRemotely() {\n-        return getLaunchMode().equals(\"remote\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if debugee should be launched manually by user.\n-     *\n-     * @see #getLaunchMode()\n-     *\/\n-    public boolean isLaunchedManually() {\n-        return getLaunchMode().equals(\"manual\");\n-    }\n@@ -713,3 +660,1 @@\n-        if (option.equals(\"test.host\")\n-            || option.equals(\"debugee.host\")\n-            || option.equals(\"debugee.vmkind\")\n+        if (option.equals(\"debugee.vmkind\")\n@@ -751,8 +696,4 @@\n-        if (option.equals(\"debugee.launch\")) {\n-            if ((!value.equals(\"local\"))\n-                && (!value.equals(\"remote\"))\n-                && (!value.equals(\"manual\"))) {\n-                throw new BadOption(option + \": must be one of: \"\n-                                           + \"local, remote, manual \" + value);\n-            }\n-            return true;\n+        if (option.equals(\"debugee.launch\")\n+                || option.equals(\"debugee.host\")\n+                || option.equals(\"test.host\")) {\n+            throw new RuntimeException(\"option \" + option + \" is not supported.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeArgumentHandler.java","additions":7,"deletions":66,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -38,9 +38,0 @@\n- * The present version of <code>Binder<\/code> allows\n- * to launch debuggee VM either on local machine (<i>local<\/i> launch mode),\n- * or on remote host using <code>BindServer<\/code> utility\n- * (<i>remote<\/i> launch mode). Also there is an ability to launch\n- * debuggee VM manually as a separate process on local or remote machine\n- * (<i>manual<\/i> launch mode), which is usefull for debugging.\n- * All these launching modes are specified by command line option\n- * <code>-debugee.launch<\/code> recognized by <code>DebugeeArgumentHandler<\/code>.\n- * <p>\n@@ -108,2 +99,0 @@\n-\n-    private BindServerListener bindServerListener = null;\n@@ -389,147 +378,0 @@\n-    \/**\n-     * Make connection to remote BindServer and start BindServerListener thread.\n-     *\n-     * @throws IOException if I\/O error occured while connecting\n-     *\/\n-    public void connectToBindServer(String taskID) {\n-        if (bindServerListener != null) {\n-            throw new Failure(\"Connection to BindServer already exists\");\n-        }\n-        try {\n-            bindServerListener = new BindServerListener(this);\n-            bindServerListener.setDaemon(true);\n-            bindServerListener.connect(taskID);\n-            bindServerListener.start();\n-        } catch (IOException e) {\n-            e.printStackTrace(getOutStream());\n-            throw new Failure(\"Caught exception while connecting to BindServer:\\n\\t\" + e);\n-        }\n-    }\n-\n-    \/**\n-     * Split string into list of substrings using specified separator.\n-     *\/\n-    private static String[] splitString(String givenString, String separator) {\n-        Vector<String> tmpList = new Vector<String>();\n-        StringTokenizer tokenizer = new StringTokenizer(givenString, separator);\n-        while(tokenizer.hasMoreTokens()) {\n-            tmpList.add(tokenizer.nextToken());\n-        }\n-        String[] list = new String[tmpList.size()];\n-        for (int i = 0; i < tmpList.size(); i++) {\n-            list[i] = tmpList.elementAt(i);\n-        }\n-        return list;\n-    }\n-\n-    \/**\n-     * Send command to remote <code>BindServer<\/code> and receive reply.\n-     *\n-     * @throws IOException if I\/O error occured while launching process\n-     *\/\n-    public synchronized Object sendRemoteCommand(Object command) {\n-        try {\n-            bindServerListener.sendCommand(command);\n-            Object reply = bindServerListener.getReply();\n-            return reply;\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Unexpected exception while sending command to BindServer:\\n\\t\"\n-                            + e);\n-        }\n-    }\n-\n-    \/**\n-     * Launch remote process using request to <code>BindServer<\/code>.\n-     *\n-     * @throws IOException if I\/O error occured\n-     *\/\n-    public void launchRemoteProcess(String[] args) throws IOException {\n-        String pathSeparator = System.getProperty(\"path.separator\");\n-        BindServer.LaunchDebugee command =\n-            new BindServer.LaunchDebugee(args,\n-                    System.getProperty(\"file.separator\"),\n-                    System.getProperty(\"user.dir\"),\n-                    splitString(System.getProperty(\"java.library.path\"), pathSeparator),\n-                    splitString(System.getProperty(\"java.class.path\"), pathSeparator),\n-                    splitString(System.getProperty(\"java.library.path\"), pathSeparator));\n-\n-        Object reply = sendRemoteCommand(command);\n-        if (reply instanceof BindServer.OK) {\n-            \/\/ do nothing\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n-\n-    \/**\n-     * Return exit status of the remotely launched process\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public int getRemoteProcessStatus () {\n-        Object reply = sendRemoteCommand(new BindServer.DebugeeExitCode());\n-        if (reply instanceof BindServer.OK) {\n-            BindServer.OK castedReply = (BindServer.OK)reply;\n-            return (int)castedReply.info;\n-        } else if (reply instanceof BindServer.CaughtException) {\n-            BindServer.CaughtException castedReply = (BindServer.CaughtException)reply;\n-            throw new IllegalThreadStateException(castedReply.reason);\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n-\n-    \/**\n-     * Check whether the remotely launched process has been terminated\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public boolean isRemoteProcessTerminated () {\n-        try {\n-            int value = getRemoteProcessStatus();\n-            return true;\n-        } catch (IllegalThreadStateException e) {\n-            return false;\n-        }\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/**\n-     * Kill the remotely launched process\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public void killRemoteProcess () {\n-        Object reply = sendRemoteCommand(new BindServer.KillDebugee());\n-        if (reply instanceof BindServer.OK) {\n-            return;\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n-\n-    \/**\n-     * Wait until the remotely launched process exits or crashes\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public int waitForRemoteProcess () {\n-\n-        Object reply = sendRemoteCommand(new BindServer.WaitForDebugee(0));\n-        if (reply instanceof BindServer.OK) {\n-            BindServer.OK castedReply = (BindServer.OK)reply;\n-            return (int)castedReply.info;\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n@@ -541,3 +383,0 @@\n-        if (bindServerListener != null) {\n-            bindServerListener.close();\n-        }\n@@ -547,194 +386,0 @@\n-    \/**\n-     * Separate thread for listening connection from <code>BindServer<\/code>.\n-     *\/\n-    private class BindServerListener extends Thread {\n-        private SocketConnection connection = null;\n-        private Log.Logger logger = null;\n-\n-        \/** List of received responses from <code>BindServer<\/code>. *\/\n-        private LinkedList<BindServer.Response> replies = new LinkedList<BindServer.Response>();\n-\n-        \/**\n-         * Make thread.\n-         *\/\n-        public BindServerListener(Log.Logger logger) {\n-            this.logger = logger;\n-        }\n-\n-        \/**\n-         * Establish connection to <code>BindServer<\/code>.\n-         *\/\n-        public void connect(String taskID) throws IOException {\n-            String host = argumentHandler.getDebugeeHost();\n-            int port = argumentHandler.getBindPortNumber();\n-            display(\"Connecting to BindServer: \" + host + \":\" + port);\n-            connection = new SocketConnection(logger, \"BindServer\");\n-\/\/            connection.setPingTimeout(DebugeeBinder.PING_TIMEOUT);\n-            connection.attach(host, port);\n-            handshake(taskID);\n-        }\n-\n-        \/**\n-         * Receive OK(version) from BindServer and check received version number.\n-         *\/\n-        private void handshake(String taskID) {\n-            \/\/ receive OK(version)\n-            trace(TRACE_LEVEL_ACTIONS, \"Waiting for initial OK(version) from BindServer\");\n-            Object reply = connection.readObject();\n-            trace(TRACE_LEVEL_ACTIONS, \"Got initial OK(version) from BindServer: \" + reply);\n-            if (reply instanceof BindServer.RequestFailed) {\n-                BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-                trace(TRACE_LEVEL_ACTIONS, \"Reply is RequestFailed: throw Failure\");\n-                throw new Failure(\"BindServer error: \" + castedReply.reason);\n-            } else if (reply instanceof BindServer.OK) {\n-                BindServer.OK castedReply = (BindServer.OK)reply;\n-                trace(TRACE_LEVEL_ACTIONS, \"Reply is OK: check BindServer version\");\n-                if (castedReply.info != BindServer.VERSION) {\n-                    throw new Failure(\"Wrong version of BindServer: \" + castedReply.info\n-                                    + \" (expected: \" + BindServer.VERSION + \")\");\n-                }\n-                display(\"Connected to BindServer: version \" + castedReply.info);\n-            } else {\n-                trace(TRACE_LEVEL_ACTIONS, \"Reply is unknown: throw Failure\");\n-                throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-            }\n-\n-            \/\/ send TaskID(id)\n-            try {\n-                trace(TRACE_LEVEL_ACTIONS, \"Sending TaskID(id) to BindServer\");\n-                sendCommand(new BindServer.TaskID(taskID));\n-                trace(TRACE_LEVEL_ACTIONS, \"Sent TaskID(id) to BindServer\");\n-            } catch (IOException e) {\n-                throw new Failure(\"Caught IOException while sending TaskID(id) to BindServer:\\n\\t\"\n-                                + e);\n-            }\n-        }\n-\n-        \/**\n-         * Check if thread is connected to <code>BindServer<\/code>.\n-         *\/\n-        public boolean isConnected() {\n-            return (connection != null && connection.isConnected());\n-        }\n-\n-        \/**\n-         * Send a command to <\/code>BindServer<\/code>.\n-         *\/\n-        public synchronized void sendCommand(Object command) throws IOException {\n-            connection.writeObject(command);\n-        }\n-\n-        \/**\n-         * Receive response from <code>BindServer<\/code>.\n-         *\/\n-        public Object getReply() {\n-            synchronized (replies) {\n-                while (replies.isEmpty()) {\n-                    if (!isConnected()) {\n-                        throw new Failure(\"No reply from BindServer: connection lost\");\n-                    }\n-                    try {\n-                        replies.wait(TRY_DELAY);\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace(getOutStream());\n-                        throw new Failure(\"Thread interrupted while waiting for reply from BindServer:\\n\\t\"\n-                                        + e);\n-                    }\n-                }\n-                Object reply = replies.removeFirst();\n-                if (reply == null) {\n-                    throw new Failure(\"No reply from BindServer: connection lost\");\n-                }\n-                return reply;\n-            }\n-        }\n-\n-        \/**\n-         * Add response object to the list of received responses.\n-         *\/\n-        private void addReply(BindServer.Response reply) {\n-            synchronized (replies) {\n-                replies.add(reply);\n-                replies.notifyAll();\n-            }\n-        }\n-\n-        \/**\n-         * Read packets from <code>BindServer<code> connection and\n-         * notify waiting thread if response or IOPipe message received.\n-         * Received lines of redirected streams are put into log.\n-         *\/\n-        public void run() {\n-            trace(TRACE_LEVEL_THREADS, \"BindServerListener thread started\");\n-            try {\n-                for (;;) {\n-                    Object reply = connection.readObject();\n-                    if (reply == null) {\n-                        break;\n-                    } else if (reply instanceof BindServer.Disconnect) {\n-                        reply = null;\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is Disconnect: close connection\");\n-                        break;\n-                    } else if (reply instanceof BindServer.RedirectedStream) {\n-                        BindServer.RedirectedStream castedReply = (BindServer.RedirectedStream)reply;\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is RedirectedStream: put message into log\");\n-                        log.println(castedReply.line);\n-                    } else if (reply instanceof BindServer.Response) {\n-                        BindServer.Response castedReply = (BindServer.Response)reply;\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is reply: notify all threads waiting for reply\");\n-                        addReply(castedReply);\n-                    } else {\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is unknown: throw Failure\");\n-                        throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-                    }\n-                }\n-            } catch (Exception e) {\n-                e.printStackTrace(getOutStream());\n-                complain(\"Caught exception while reading packets from BindServer:\\n\\t\" + e);\n-            } finally {\n-                closeConnection();\n-                addReply(null);\n-                trace(TRACE_LEVEL_THREADS, \"BindServerListener thread finished\");\n-            }\n-        }\n-\n-        \/**\n-         * Send Disconnect command to <\/code>BindServer<\/code>.\n-         *\/\n-        public void disconnect() {\n-            if (connection == null) return;\n-            try {\n-                sendCommand(new BindServer.Disconnect());\n-            } catch (IOException e) {\n-                display(\"Caught IOException while requesting disconnection with BindServer\");\n-            }\n-        }\n-\n-        \/**\n-         * Close socket connection.\n-         *\/\n-        public void closeConnection() {\n-            if (connection != null) {\n-                connection.close();\n-            }\n-        }\n-\n-        \/**\n-         * Wait for thread finished in the specified timeout or interrupt it.\n-         *\/\n-        public void waitForThread(long millis) {\n-            DebugeeBinder.waitForThread(this, millis, logger);\n-        }\n-\n-        \/**\n-         * Close this thread by waiting for it finishes or interrupt it\n-         * and close socket connection.\n-         *\/\n-        public void close() {\n-            disconnect();\n-            waitForThread(DebugeeBinder.THREAD_TIMEOUT);\n-            closeConnection();\n-        }\n-\n-    } \/\/ BindServerListener\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeBinder.java","additions":0,"deletions":355,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-    \/** Need or not to check debuggee process termination at exit. *\/\n-    protected boolean checkTermination = false;\n+    \/** Need or not to check debuggee process termination. *\/\n+    private boolean checkTermination = true;\n@@ -167,1 +167,3 @@\n-    abstract protected int waitForDebugee () throws InterruptedException;\n+    protected int waitForDebugee() throws InterruptedException {\n+        return process.waitFor();\n+    }\n@@ -170,1 +172,6 @@\n-    abstract protected void killDebugee ();\n+    protected void killDebugee() {\n+        if (!terminated()) {\n+            log.display(\"Killing debugee VM process\");\n+            process.destroy();\n+        }\n+    }\n@@ -173,1 +180,11 @@\n-    abstract public boolean terminated ();\n+     public boolean terminated() {\n+        if (process == null)\n+            return true;\n+\n+        try {\n+            int value = process.exitValue();\n+            return true;\n+        } catch (IllegalThreadStateException e) {\n+            return false;\n+        }\n+    }\n@@ -176,1 +193,3 @@\n-    abstract public int getStatus ();\n+    public int getStatus() {\n+        return process.exitValue();\n+    }\n@@ -179,1 +198,3 @@\n-    abstract protected OutputStream getInPipe ();\n+    protected OutputStream getInPipe() {\n+        return process.getOutputStream();\n+    }\n@@ -182,1 +203,3 @@\n-    abstract protected InputStream getOutPipe ();\n+    protected InputStream getOutPipe() {\n+        return process.getInputStream();\n+    }\n@@ -185,2 +208,3 @@\n-    abstract protected InputStream getErrPipe ();\n-\n+    protected InputStream getErrPipe() {\n+        return process.getErrorStream();\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import vm.share.process.ProcessExecutor;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/complog\/share\/LogCompilationTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.process;\n+package vm.compiler.complog.share;\n@@ -28,1 +28,0 @@\n-import vm.share.ProcessUtils;\n@@ -30,3 +29,0 @@\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.BufferedReader;\n@@ -35,2 +31,0 @@\n-import java.io.PipedInputStream;\n-import java.io.PipedOutputStream;\n@@ -39,1 +33,0 @@\n-import java.lang.reflect.Field;\n@@ -141,2 +134,2 @@\n-    public int getPid() {\n-        return ProcessUtils.getPid(process);\n+    public long getPid() {\n+        return process.pid();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/complog\/share\/ProcessExecutor.java","additions":3,"deletions":10,"binary":false,"changes":13,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/ProcessExecutor.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.process;\n+package vm.compiler.complog.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/complog\/share\/StreamListener.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/StreamListener.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.process;\n+package vm.compiler.complog.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/complog\/share\/StreamLogger.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/StreamLogger.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share.process;\n+package vm.compiler.complog.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/complog\/share\/StreamReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/StreamReader.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-import vm.share.FileUtils;\n+import vm.mlvm.share.FileUtils;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/func\/findByName\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandles.Lookup;\n+\n@@ -30,2 +29,2 @@\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -35,0 +34,3 @@\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n@@ -36,3 +38,0 @@\n-import vm.share.options.Option;\n-import vm.share.options.OptionSupport;\n-import vm.share.options.IgnoreUnknownArgumentsHandler;\n@@ -42,2 +41,4 @@\n-import vm.share.FileUtils;\n-import vm.share.UnsafeAccess;\n+import vm.mlvm.share.FileUtils;\n+import vm.share.options.Option;\n+import vm.share.options.OptionSupport;\n+import vm.share.options.IgnoreUnknownArgumentsHandler;\n@@ -167,1 +168,1 @@\n-                        UnsafeAccess.unsafe.ensureClassInitialized(c);\n+                        MethodHandles.lookup().ensureInitialized(c);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/share\/StressClassLoadingTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-import vm.share.FileUtils;\n+import vm.mlvm.share.FileUtils;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/byteMutation\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-import vm.share.FileUtils;\n+import vm.mlvm.share.FileUtils;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-import vm.share.FileUtils;\n+import vm.mlvm.share.FileUtils;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/metaspace\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-import vm.share.FileUtils;\n+import vm.mlvm.share.FileUtils;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/parallelLoad\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n@@ -58,1 +55,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -70,0 +66,1 @@\n+import vm.mlvm.share.FileUtils;\n@@ -71,1 +68,0 @@\n-import vm.share.FileUtils;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/stress\/gc\/lotsOfCallSites\/Test.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import vm.share.FileUtils;\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/CustomClassLoaders.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-package vm.share;\n+package vm.mlvm.share;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/FileUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/FileUtils.java","status":"renamed"},{"patch":"@@ -26,0 +26,3 @@\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n@@ -29,0 +32,2 @@\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+\n@@ -31,1 +36,0 @@\n-import vm.share.ProcessUtils;\n@@ -264,0 +268,13 @@\n+    private static void dumpHeapWithHotspotDiagnosticMXBean(String fileName) throws IOException {\n+        System.err.println(\"Dumping heap to \" + fileName);\n+\n+        File f = new File(fileName);\n+        if (f.exists())\n+            f.delete();\n+\n+        HotSpotDiagnosticMXBean b = ManagementFactory.getPlatformMXBeans(\n+                com.sun.management.HotSpotDiagnosticMXBean.class).get(0);\n+        b.dumpHeap(fileName, false);\n+    }\n+\n+\n@@ -267,1 +284,1 @@\n-                ProcessUtils.dumpHeapWithHotspotDiagnosticMXBean(HEAP_DUMP_FILENAME);\n+                dumpHeapWithHotspotDiagnosticMXBean(HEAP_DUMP_FILENAME);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/MlvmTestExecutor.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share;\n-\n-import java.io.*;\n-import java.util.LinkedList;\n-\n-\/**\n- * Utility class intended to read file line by line and skip comments.\n- *\/\n-public class CommentedFileReader {\n-\n-    \/**\n-     * Type of comments that should be removed from file.\n-     *\/\n-    public static enum CommentStyle {\n-        \/**\n-         * Comments started with <i>#<\/i>.\n-         *\/\n-        BASH,\n-        \/**\n-         * Comments started with <i>\/\/<\/i>.\n-         *\/\n-        JAVA\n-    }\n-\n-    \/**\n-     * Get lines from specified file and filter out comments.\n-     * Only comments in BASH style will be filtered out.\n-     *\n-     * @param path to file that should be readed\n-     * @return filtered lines from file\n-     *\/\n-    public static String[] readFile(String path) throws IOException {\n-        return readFile(new File(path), CommentStyle.BASH);\n-    }\n-\n-    \/**\n-     * Get lines from specified file and filter out comments.\n-     * Only comments in BASH style will be filtered out.\n-     *\n-     * @param file that should be readed\n-     * @return filtered lines from file\n-     *\/\n-    public static String[] readFile(File file) throws IOException {\n-        return readFile(file, CommentStyle.BASH);\n-    }\n-\n-    \/**\n-     * Get lines from specified file without comments.\n-     *\n-     * @param path to file that should be readed\n-     * @param commentStyle describes what strings will be treated as comments\n-     * @return filtered lines from file\n-     *\/\n-    public static String[] readFile(String path, CommentStyle commentStyle) throws IOException {\n-        return readFile(new File(path), commentStyle);\n-    }\n-\n-    \/**\n-     * Get lines from specified file without comments.\n-     *\n-     * @param file that should be readed\n-     * @param commentStyle describes what strings will be treated as comments\n-     * @return filtered lines from file\n-     *\/\n-    public static String[] readFile(File file, CommentStyle commentStyle) throws IOException {\n-        LinkedList<String> entries = new LinkedList<String>();\n-        BufferedReader reader = new BufferedReader(new FileReader(file));\n-        String commentBeginning;\n-\n-        switch (commentStyle) {\n-        case BASH:\n-            commentBeginning = \"#\";\n-            break;\n-        case JAVA:\n-            commentBeginning = \"\/\/\";\n-            break;\n-        default:\n-            throw new IllegalArgumentException(\"Unknown comment style\");\n-        }\n-\n-        while (true) {\n-            String entry = reader.readLine();\n-            if (entry == null) {\n-                break;\n-            }\n-\n-            entry = entry.replaceAll(commentBeginning + \".*\", \"\").trim();\n-\n-            if (entry.length() > 0) {\n-                entries.add(entry);\n-            }\n-        }\n-\n-        return entries.toArray(new String[entries.size()]);\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/CommentedFileReader.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"native_thread.hpp\"\n@@ -27,3 +26,0 @@\n-#include <process.h>\n-#include <vdmdbg.h>\n-#include <dbghelp.h>\n@@ -38,34 +34,0 @@\n-\/*\n- * Class:     vm_share_ProcessUtils\n- * Method:    sendSignal\n- * Signature: ()Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_vm_share_ProcessUtils_sendSignal\n-(JNIEnv *env, jclass klass, jint signalNum) {\n-#ifdef _WIN32\n-\/* TODO TODO TODO\n-        int dw;\n-        LPVOID lpMsgBuf;\n-        if (!GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, 0)) {\n-                dw = GetLastError();\n-                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n-                                nullptr,\n-                                dw,\n-                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-                                (LPTSTR) &lpMsgBuf,\n-                                0,\n-                                nullptr\n-                             );\n-                printf(\"%s\\n\", (LPTSTR)lpMsgBuf);\n-                LocalFree(lpMsgBuf);\n-                return JNI_FALSE;\n-        }\n-        *\/\n-        return JNI_TRUE;\n-#else \/* _WIN32 *\/\n-        if (kill(getpid(), signalNum) < 0)\n-                return JNI_FALSE;\n-        return JNI_TRUE;\n-#endif \/* _WIN32 *\/\n-}\n-\n@@ -104,163 +66,0 @@\n-#ifdef _WIN32\n-static BOOL  (WINAPI *_MiniDumpWriteDump)  (HANDLE, DWORD, HANDLE, MINIDUMP_TYPE, PMINIDUMP_EXCEPTION_INFORMATION,\n-                                            PMINIDUMP_USER_STREAM_INFORMATION, PMINIDUMP_CALLBACK_INFORMATION);\n-void reportLastError(const char *msg) {\n-        long errcode = GetLastError();\n-        if (errcode != 0) {\n-                DWORD len = 0;\n-                char *buf;\n-                size_t n = (size_t)FormatMessage(\n-                                FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER,\n-                                nullptr,\n-                                errcode,\n-                                0,\n-                                (LPSTR) &buf,\n-                                (DWORD)len,\n-                                nullptr);\n-                if (n > 3) {\n-                        \/* Drop final '.', CR, LF *\/\n-                        if (buf[n - 1] == '\\n') n--;\n-                        if (buf[n - 1] == '\\r') n--;\n-                        if (buf[n - 1] == '.') n--;\n-                        buf[n] = '\\0';\n-                }\n-                printf(\"%s: %s\\n\", msg, buf);\n-                LocalFree(buf);\n-        }\n-}\n-\n-#endif \/* _WIN32 *\/\n-\n-jboolean doDumpCore() {\n-#ifdef _WIN32\n-        char path[MAX_PATH];\n-        DWORD size;\n-        DWORD pathLen = (DWORD) sizeof(path);\n-        HINSTANCE dbghelp;\n-        MINIDUMP_EXCEPTION_INFORMATION* pmei;\n-\n-        HANDLE hProcess = GetCurrentProcess();\n-        DWORD processId = GetCurrentProcessId();\n-        HANDLE dumpFile;\n-        MINIDUMP_TYPE dumpType;\n-        static const char* cwd;\n-        static const char* name = \"DBGHELP.DLL\";\n-\n-        printf(\"# TEST: creating Windows minidump...\\n\");\n-        size = GetSystemDirectory(path, pathLen);\n-        if (size > 0) {\n-                strcat(path, \"\\\\\");\n-                strcat(path, name);\n-                dbghelp = LoadLibrary(path);\n-                if (dbghelp == nullptr)\n-                        reportLastError(\"Load DBGHELP.DLL from system directory\");\n-        } else {\n-                printf(\"GetSystemDirectory returned 0\\n\");\n-        }\n-\n-        \/\/ try Windows directory\n-        if (dbghelp == nullptr) {\n-                size = GetWindowsDirectory(path, pathLen);\n-                if (size > 6) {\n-                        strcat(path, \"\\\\\");\n-                        strcat(path, name);\n-                        dbghelp = LoadLibrary(path);\n-                        if (dbghelp == nullptr) {\n-                                reportLastError(\"Load DBGHELP.DLL from Windows directory\");\n-                        }\n-                }\n-        }\n-        if (dbghelp == nullptr) {\n-                printf(\"Failed to load DBGHELP.DLL\\n\");\n-                return JNI_FALSE;\n-        }\n-\n-        _MiniDumpWriteDump =\n-                        (BOOL(WINAPI *)(HANDLE, DWORD, HANDLE, MINIDUMP_TYPE, PMINIDUMP_EXCEPTION_INFORMATION,\n-                                        PMINIDUMP_USER_STREAM_INFORMATION, PMINIDUMP_CALLBACK_INFORMATION))\n-                                        GetProcAddress(dbghelp, \"MiniDumpWriteDump\");\n-\n-        if (_MiniDumpWriteDump == nullptr) {\n-                printf(\"Failed to find MiniDumpWriteDump() in module dbghelp.dll\");\n-                return JNI_FALSE;\n-        }\n-        dumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory | MiniDumpWithHandleData);\n-\n-        \/\/ Older versions of dbghelp.h doesn't contain all the dumptypes we want, dbghelp.h with\n-        \/\/ API_VERSION_NUMBER 11 or higher contains the ones we want though\n-#if API_VERSION_NUMBER >= 11\n-        dumpType = (MINIDUMP_TYPE)(dumpType | MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo |\n-                        MiniDumpWithUnloadedModules);\n-#endif\n-\n-        dumpFile = CreateFile(\"core.mdmp\", GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);\n-\n-        if (dumpFile == INVALID_HANDLE_VALUE) {\n-                reportLastError(\"Failed to create file for dumping\");\n-                return JNI_FALSE;\n-        }\n-        pmei = nullptr;\n-\n-\n-        \/\/ Older versions of dbghelp.dll (the one shipped with Win2003 for example) may not support all\n-        \/\/ the dump types we really want. If first call fails, lets fall back to just use MiniDumpWithFullMemory then.\n-        if (_MiniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, nullptr, nullptr) == FALSE &&\n-                        _MiniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, nullptr, nullptr) == FALSE) {\n-                reportLastError(\"Call to MiniDumpWriteDump() failed\");\n-                return JNI_FALSE;\n-        }\n-\n-        CloseHandle(dumpFile);\n-        printf(\"# TEST: minidump created\\n\");\n-        \/\/ Emulate Unix behaviour - exit process.\n-        ExitProcess(137);\n-\n-        return JNI_TRUE;\n-#else \/* _WIN32 *\/\n-        if (kill(getpid(), SIGSEGV) < 0)\n-                return JNI_FALSE;\n-        return JNI_TRUE;\n-#endif \/* _WIN32 *\/\n-\n-}\n-\n-\/*\n- * Class:     vm_share_ProcessUtils\n- * Method:    dumpCore\n- * Signature: ()Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_vm_share_ProcessUtils_dumpCore\n-  (JNIEnv *env, jclass klass)\n-{\n-        return doDumpCore();\n-}\n-\n-\/*\n- * Class:     vm_share_ProcessUtils\n- * Method:    getPid\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_vm_share_ProcessUtils_getPid\n-  (JNIEnv *env, jclass klass) {\n-#ifdef _WIN32\n-        return _getpid();\n-#else \/* _WIN32 *\/\n-        return getpid();\n-#endif \/* _WIN32 *\/\n-}\n-\n-\n-\/*\n- * Class:     vm_share_ProcessUtils\n- * Method:    getPid\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_vm_share_ProcessUtils_getWindowsPid\n-  (JNIEnv *env, jclass klass, jlong handle) {\n-#ifdef _WIN32\n-        return GetProcessId((HANDLE) handle);\n-#else \/* _WIN32 *\/\n-        return -1;\n-#endif \/* _WIN32 *\/\n-}\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/ProcessUtils.cpp","additions":0,"deletions":201,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,63 +49,0 @@\n-\n-    \/**\n-     * Send any signal to java process on Unix. It currently does nothing on Windows.\n-     *\n-     * @return true if it was successful\n-     *\/\n-    public static native boolean sendSignal(int signalNum);\n-\n-    \/**\n-     * Force java process to dump core.\n-     *\n-     * This is done by sending SIGSEGV on unix systems.\n-     *\n-     * @return true if it was successful, false if not (for example on Windows)\n-     *\/\n-    public static native boolean dumpCore();\n-\n-    \/**\n-     * Get PID of java process.\n-     *\n-     * @return PID\n-     *\/\n-    public static native int getPid();\n-\n-    public static int getPid(Process process) {\n-        Throwable exception;\n-        try {\n-            Field pidField = process.getClass().getDeclaredField(\"pid\");\n-            pidField.setAccessible(true);\n-            return ((Integer) pidField.get(process)).intValue();\n-        } catch (NoSuchFieldException e) {\n-            exception = e;\n-        } catch (IllegalAccessException e) {\n-            exception = e;\n-        }\n-        \/\/ Try to get Windows handle\n-        try {\n-            Field handleField = process.getClass().getDeclaredField(\"handle\");\n-            handleField.setAccessible(true);\n-            long handle = ((Long) handleField.get(process)).longValue();\n-            return getWindowsPid(handle);\n-        } catch (NoSuchFieldException e) {\n-            exception = e;\n-        } catch (IllegalAccessException e) {\n-            exception = e;\n-        }\n-        throw new TestBug(\"Unable to determine pid from process class \" + process.getClass(), exception);\n-    }\n-\n-    private static native int getWindowsPid(long handle);\n-\n-    @SuppressWarnings(\"restriction\")\n-    public static void dumpHeapWithHotspotDiagnosticMXBean(String fileName) throws IOException {\n-        System.err.println(\"Dumping heap to \" + fileName);\n-\n-        File f = new File(fileName);\n-        if (f.exists())\n-            f.delete();\n-\n-        HotSpotDiagnosticMXBean b = ManagementFactory.getPlatformMXBeans(\n-                com.sun.management.HotSpotDiagnosticMXBean.class).get(0);\n-        b.dumpHeap(fileName, false);\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/ProcessUtils.java","additions":1,"deletions":64,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-\n-import jdk.test.lib.Utils;\n-\n-public class RandomEx extends Random {\n-    private final Map<Class<?>, Supplier<?>> map = new HashMap<>();\n-\n-    {\n-        map.put(Boolean.class, this::nextBoolean);\n-        map.put(boolean.class, this::nextBoolean);\n-        map.put(Byte.class, this::nextByte);\n-        map.put(byte.class, this::nextByte);\n-        map.put(Short.class, this::nextShort);\n-        map.put(short.class, this::nextShort);\n-        map.put(Character.class, this::nextChar);\n-        map.put(char.class, this::nextChar);\n-        map.put(Integer.class, this::nextInt);\n-        map.put(int.class, this::nextInt);\n-        map.put(Long.class, this::nextLong);\n-        map.put(long.class, this::nextLong);\n-        map.put(Float.class, this::nextFloat);\n-        map.put(float.class, this::nextFloat);\n-        map.put(Double.class, this::nextDouble);\n-        map.put(double.class, this::nextDouble);\n-    }\n-\n-    public RandomEx() {\n-        super(Utils.getRandomInstance().nextLong());\n-    }\n-\n-    public RandomEx(long seed) {\n-        super(seed);\n-    }\n-\n-    public byte nextByte() {\n-        return (byte) next(Byte.SIZE);\n-    }\n-\n-    public short nextShort() {\n-        return (short) next(Short.SIZE);\n-    }\n-\n-    public char nextChar() {\n-        return (char) next(Character.SIZE);\n-    }\n-\n-    public <T> T next(Predicate<T> p, T dummy) {\n-        T result;\n-        do {\n-            result = next(dummy);\n-        } while (!p.test(result));\n-        return result;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T next(T dummy) {\n-        Supplier<?> supplier = map.get(dummy.getClass());\n-        if (supplier == null) {\n-            throw new IllegalArgumentException(\"supplier for <\" +\n-                    dummy.getClass() + \">is not found\");\n-        }\n-        return (T) supplier.get();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/RandomEx.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.util.Random;\n-import java.util.function.Predicate;\n-\n-public class StringUtils {\n-\n-    public static byte[] binaryReplace(final byte[] src, String search,\n-            String replacement) {\n-        if (search.length() == 0)\n-            return src;\n-\n-        int nReplaced = 0;\n-\n-        try {\n-            final byte[] bSrch = search.getBytes(\"ASCII\");\n-            final byte[] bRepl = replacement.getBytes(\"ASCII\");\n-\n-            ByteArrayOutputStream out = new ByteArrayOutputStream();\n-            try {\n-                searching: for (int i = 0; i < src.length; i++) {\n-                    if (src[i] == bSrch[0]) {\n-                        replacing: do {\n-                            for (int ii = 1; ii < Math.min(bSrch.length,\n-                                    src.length - i); ii++)\n-                                if (src[i + ii] != bSrch[ii])\n-                                    break replacing;\n-\n-                            out.write(bRepl);\n-                            i += bSrch.length - 1;\n-                            nReplaced++;\n-                            continue searching;\n-                        } while (false);\n-                    }\n-\n-                    out.write(src[i]);\n-                }\n-\n-            return out.toByteArray();\n-\n-            } finally {\n-                out.close();\n-            }\n-        } catch (Exception e) {\n-            RuntimeException t = new RuntimeException(\"Test internal error\");\n-            t.initCause(e);\n-            throw t;\n-        }\n-    }\n-\n-    public static String generateString(Random rng, int length,\n-            Predicate<Character> predicate) {\n-        if (length <= 0) {\n-            throw new IllegalArgumentException(\"length <= 0\");\n-        }\n-        StringBuilder builder = new StringBuilder(length);\n-        for (int i = 0; i < length; ++i) {\n-            char tmp;\n-            do {\n-                tmp = (char) rng.nextInt(Character.MAX_VALUE);\n-            } while (!predicate.test(tmp));\n-            builder.append(tmp);\n-        }\n-        return builder.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/StringUtils.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share;\n-\n-import java.lang.reflect.Field;\n-\n-import jdk.internal.misc.Unsafe;\n-\n-@SuppressWarnings(\"restriction\")\n-public class UnsafeAccess {\n-    public static Unsafe unsafe;\n-\n-    static {\n-        try {\n-            unsafe = Unsafe.getUnsafe();\n-        } catch ( Exception e ) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/UnsafeAccess.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share;\n-\n-import com.sun.management.HotSpotDiagnosticMXBean;\n-import com.sun.management.VMOption;\n-\n-import java.lang.management.ManagementFactory;\n-import java.util.Objects;\n-\n-public class VMRuntimeEnvUtils {\n-    private static HotSpotDiagnosticMXBean DIAGNOSTIC_BEAN\n-            = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-\n-    private VMRuntimeEnvUtils() {\n-    }\n-\n-    public static boolean isJITEnabled() {\n-        boolean isJITEnabled = ManagementFactory.getCompilationMXBean() != null;\n-\n-        return isJITEnabled;\n-    }\n-\n-    \/**\n-     * Returns value of VM option.\n-     *\n-     * @param name option's name\n-     * @return value of option or {@code null}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     * @see HotSpotDiagnosticMXBean#getVMOption(String)\n-     *\/\n-    public static String getVMOption(String name) {\n-        Objects.requireNonNull(name);\n-        VMOption tmp;\n-        try {\n-            tmp = DIAGNOSTIC_BEAN.getVMOption(name);\n-        } catch (IllegalArgumentException e) {\n-            tmp = null;\n-        }\n-        return (tmp == null ? null : tmp.getValue());\n-    }\n-\n-    \/**\n-     * Returns value of VM option or default value.\n-     *\n-     * @param name         option's name\n-     * @param defaultValue default value\n-     * @return value of option or {@code defaultValue}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     * @see #getVMOption(String)\n-     *\/\n-    public static String getVMOption(String name, String defaultValue) {\n-        String result = getVMOption(name);\n-        return result == null ? defaultValue : result;\n-    }\n-\n-    \/**\n-     * Returns if a boolean VM option is enabled or not.\n-     *\n-     * @param name  option's name\n-     * @return true iff enabled\n-     * @throws IllegalArgumentException if naming non-boolean or non-existing option\n-     *\/\n-    public static boolean isVMOptionEnabled(String name) {\n-        String isSet = getVMOption(name, \"error\");\n-        if (isSet.equals(\"true\")) {\n-            return true;\n-        } else if (isSet.equals(\"false\")) {\n-            return false;\n-        }\n-        throw new IllegalArgumentException(name + \" is not a boolean option.\");\n-    }\n-\n-    \/**\n-     * Sets a specified value for VM option of given name.\n-     *\n-     * @param name  option's name\n-     * @param value new value\n-     * @throws NullPointerException     if name is null\n-     * @throws IllegalArgumentException if new value is invalid or if vm option\n-     *                                  is not writable.\n-     * @see HotSpotDiagnosticMXBean#setVMOption(String, String)\n-     *\/\n-    public static void setVMOption(String name, String value) {\n-        Objects.requireNonNull(name);\n-        DIAGNOSTIC_BEAN.setVMOption(name, value);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/VMRuntimeEnvUtils.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.monitoring.data;\n-\n-import java.lang.management.*;\n-import javax.management.*;\n-import java.io.Serializable;\n-\n-public class MemoryManagerData implements MemoryManagerMXBean, Serializable {\n-        private String[] memoryPoolNames;\n-        private String name;\n-        private boolean valid;\n-\n-        public MemoryManagerData(String[] memoryPoolNames, String name, boolean valid) {\n-                this.memoryPoolNames = memoryPoolNames;\n-                this.name = name;\n-                this.valid = valid;\n-        }\n-\n-        public MemoryManagerData(MemoryManagerMXBean memoryManager) {\n-                this.memoryPoolNames = memoryManager.getMemoryPoolNames();\n-                this.name = memoryManager.getName();\n-                this.valid = memoryManager.isValid();\n-        }\n-\n-        public String[] getMemoryPoolNames() {\n-                return memoryPoolNames;\n-        }\n-\n-        public String getName() {\n-                return name;\n-        }\n-\n-        public boolean isValid() {\n-                return valid;\n-        }\n-\n-    public ObjectName getObjectName() {\n-        return null;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/monitoring\/data\/MemoryManagerData.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.monitoring.data;\n-\n-import java.lang.management.MemoryPoolMXBean;\n-import java.io.Serializable;\n-\n-public class MemoryPoolData implements Serializable {\n-        private String name;\n-        private boolean valid;\n-        private MemoryUsageData usage;\n-\n-        public MemoryPoolData(String name, boolean valid, MemoryUsageData usage) {\n-                this.name = name;\n-                this.valid = valid;\n-        }\n-\n-        public MemoryPoolData(MemoryPoolMXBean memoryManager) {\n-                this.name = memoryManager.getName();\n-                this.valid = memoryManager.isValid();\n-                this.usage = new MemoryUsageData(memoryManager.getUsage());\n-        }\n-\n-        public String getName() {\n-                return name;\n-        }\n-\n-        public boolean hasName(String name) {\n-                return this.name.equals(name);\n-        }\n-\n-        public boolean isValid() {\n-                return valid;\n-        }\n-\n-        public MemoryUsageData getUsage() {\n-                return usage;\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/monitoring\/data\/MemoryPoolData.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.monitoring.data;\n-\n-import java.io.Serializable;\n-import java.lang.management.MemoryUsage;\n-import nsk.share.log.Log;\n-\n-public class MemoryUsageData implements Serializable {\n-        private long init;\n-        private long used;\n-        private long committed;\n-        private long max;\n-\n-        public MemoryUsageData(long init, long used, long committed, long max) {\n-                this.init = init;\n-                this.used = used;\n-                this.committed = committed;\n-                this.max = max;\n-        }\n-\n-        public MemoryUsageData(MemoryUsage usage) {\n-                this.init = usage.getInit();\n-                this.used = usage.getUsed();\n-                this.committed = usage.getCommitted();\n-                this.max = usage.getMax();\n-        }\n-\n-        public MemoryUsageData(MemoryUsageData usage, MemoryUsageData usage1) {\n-                this.init = usage.getInit() + usage1.getInit();\n-                this.used = usage.getUsed() + usage1.getUsed();\n-                this.committed = usage.getCommitted() + usage1.getCommitted();\n-                this.max = usage.getMax() + usage1.getMax();\n-        }\n-\n-        public long getInit() {\n-                return init;\n-        }\n-\n-        public long getUsed() {\n-                return used;\n-        }\n-\n-        public long getMax() {\n-                return max;\n-        }\n-\n-        public long getFree() {\n-                return committed - used;\n-        }\n-\n-        public long getCommitted() {\n-                return committed;\n-        }\n-\n-        public void log(Log log) {\n-                log.info(\"    Init: \" + init);\n-                log.info(\"    Used: \" + used);\n-                log.info(\"    Committed: \" + committed);\n-                log.info(\"    Max: \" + max);\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/monitoring\/data\/MemoryUsageData.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.process;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-\n-public class CmdExecutor extends ProcessExecutor {\n-    private final StringBuilder cmd = new StringBuilder();\n-    @Override\n-    public void clearArgs() {\n-        cmd.setLength(0);\n-    }\n-\n-    @Override\n-    public void addArg(String arg) {\n-        cmd.append(\" \" + arg);\n-    }\n-\n-    @Override\n-    public void addArgs(String[] args) {\n-        for (String arg : args) {\n-            addArg(arg);\n-        }\n-    }\n-\n-    @Override\n-    public void addArgs(Collection<String> args) {\n-        for (String arg : args) {\n-            addArg(arg);\n-        }\n-    }\n-\n-    @Override\n-    protected Process createProcess() throws IOException {\n-        return Runtime.getRuntime().exec(cmd.toString());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return cmd.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/CmdExecutor.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.process;\n-\n-import java.util.List;\n-\n-public interface MessageInput {\n-        public boolean waitForStart(long timeout) throws InterruptedException;\n-        public boolean waitForMessage(long timeout) throws InterruptedException;\n-        public boolean waitForMessage(String msg, long timeout) throws InterruptedException;\n-        public String getMessage();\n-        public List<String> getMessages();\n-        public List<String> getMessages(int to);\n-        public List<String> getMessages(int from, int to);\n-        public boolean waitForFinish(long timeout) throws InterruptedException;\n-        public void reset();\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/MessageInput.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.process;\n-\n-public interface MessageOutput {\n-        public void start();\n-        public void send(String msg);\n-        public void finish();\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/MessageOutput.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.process;\n-\n-import java.util.List;\n-\n-public class ProcessHandler implements MessageInput, MessageOutput {\n-        private StreamMessageInput stdout = new StreamMessageInput();\n-        private StreamMessageInput stderr = new StreamMessageInput();\n-        private StreamMessageOutput stdin = new StreamMessageOutput();\n-\n-        public ProcessHandler() {\n-        }\n-\n-        public ProcessHandler(ProcessExecutor exec) {\n-                bind(exec);\n-        }\n-\n-        public void bind(ProcessExecutor exec) {\n-                exec.addStdOutListener(stdout.createListener());\n-                exec.addStdErrListener(stderr.createListener());\n-                exec.start();\n-                stdin.bind(exec.getStdIn());\n-        }\n-\n-        public boolean waitForStart(long timeout) throws InterruptedException {\n-                return stdout.waitForStart(timeout) && stderr.waitForStart(timeout);\n-        }\n-\n-        public boolean waitForMessage(long timeout) throws InterruptedException {\n-                return stdout.waitForMessage(timeout);\n-        }\n-\n-        public boolean waitForMessage(String msg, long timeout) throws InterruptedException {\n-                return stdout.waitForMessage(msg, timeout);\n-        }\n-\n-        public String getMessage() {\n-                return stdout.getMessage();\n-        }\n-\n-        public List<String> getMessages() {\n-                return stdout.getMessages();\n-        }\n-\n-        public List<String> getMessages(int to) {\n-                return stdout.getMessages(to);\n-        }\n-\n-        public List<String> getMessages(int from, int to) {\n-                return stdout.getMessages(from, to);\n-        }\n-\n-        public boolean waitForStdErrMessage(String msg, long timeout) throws InterruptedException {\n-                return stderr.waitForMessage(msg, timeout);\n-        }\n-\n-        public String getStdErrMessage() {\n-                return stderr.getMessage();\n-        }\n-\n-        public boolean waitForFinish(long timeout) throws InterruptedException {\n-                return stdout.waitForFinish(timeout) && stderr.waitForFinish(timeout);\n-        }\n-\n-        public void start() {\n-                stdin.start();\n-        }\n-\n-        public void send(String msg) {\n-                stdin.send(msg);\n-        }\n-\n-        public void finish() {\n-                stdin.finish();\n-        }\n-\n-        public void reset() {\n-                stdout.reset();\n-                stderr.reset();\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/ProcessHandler.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.process;\n-\n-import java.util.List;\n-import java.util.ArrayList;\n-import nsk.share.TestBug;\n-\n-public class StreamMessageInput implements MessageInput {\n-        private Object sync = new Object();\n-        private List<String> lines = new ArrayList<String>();\n-        private int position = 0;\n-        private volatile boolean active = false;\n-        private volatile Throwable exception;\n-\n-        public StreamMessageInput() {\n-        }\n-\n-        public StreamMessageInput(StreamReader sd) {\n-                bind(sd);\n-        }\n-\n-        public StreamListener createListener() {\n-                return new Listener();\n-        }\n-\n-        public void bind(StreamReader sd) {\n-                sd.addListener(createListener());\n-        }\n-\n-        public boolean isActive() {\n-                return active;\n-        }\n-\n-        public boolean isException() {\n-                return exception != null;\n-        }\n-\n-        public Throwable getException() {\n-                return exception;\n-        }\n-\n-        public boolean waitForStart(long timeout) throws InterruptedException {\n-                long startTime = System.currentTimeMillis();\n-                long curTime = startTime;\n-                synchronized (sync) {\n-                        while (!active && curTime - startTime < timeout) {\n-                                sync.wait(curTime - startTime);\n-                                curTime = System.currentTimeMillis();\n-                        }\n-                }\n-                return active;\n-        }\n-\n-        public boolean waitForFinish(long timeout) throws InterruptedException {\n-                long startTime = System.currentTimeMillis();\n-                long curTime = startTime;\n-                synchronized (sync) {\n-                        while (active && curTime - startTime < timeout) {\n-                                sync.wait(curTime - startTime);\n-                                curTime = System.currentTimeMillis();\n-                        }\n-                }\n-                return !active;\n-        }\n-\n-        public boolean waitForMessage(String msg, long timeout) throws InterruptedException {\n-                long startTime = System.currentTimeMillis();\n-                long curTime = startTime;\n-                int n = position;\n-                synchronized (sync) {\n-                        while (curTime - startTime < timeout) {\n-                                while (n < lines.size()) {\n-                                        \/\/ System.out.println(\"Check: \" + lines.get(n));\n-                                        if (msg == null || lines.get(n++).contains(msg)) {\n-                                                return true;\n-                                        }\n-                                }\n-                                sync.wait(timeout - (curTime - startTime));\n-                                curTime = System.currentTimeMillis();\n-                        }\n-                        return false;\n-                }\n-        }\n-\n-        public boolean waitForMessage(long timeout) throws InterruptedException {\n-                return waitForMessage(null, timeout);\n-        }\n-\n-        public String getMessage() {\n-                if (position < lines.size())\n-                        return lines.get(position++);\n-                else\n-                        return null;\n-        }\n-\n-        public String getMessage(int index) {\n-                return lines.get(index);\n-        }\n-\n-        public int getPosition() {\n-                return position;\n-        }\n-\n-        public void setPosition(int position) {\n-                this.position = position;\n-        }\n-\n-        public int getMessageCount() {\n-                return lines.size();\n-        }\n-\n-        public List<String> getMessages() {\n-                return getMessages(position, lines.size());\n-        }\n-\n-        public List<String> getMessages(int to) {\n-                return getMessages(position, to);\n-        }\n-\n-        public List<String> getMessages(int from, int to) {\n-                synchronized (sync) {\n-                        if (to < 0)\n-                                to = lines.size() + to;\n-                        position = Math.max(position, to);\n-                        return new ArrayList<String>(lines.subList(from, to));\n-                }\n-        }\n-\n-        public void reset() {\n-                synchronized (sync) {\n-                        position = lines.size();\n-                }\n-        }\n-\n-        private class Listener implements StreamListener {\n-                @Override\n-                public void onStart() {\n-                        synchronized (sync) {\n-                                active = true;\n-                                sync.notifyAll();\n-                        }\n-                }\n-\n-                @Override\n-                public void onRead(String line) {\n-                        \/\/System.out.println(\"onRead: \" + line);\n-                        synchronized (sync) {\n-                                lines.add(line);\n-                                sync.notifyAll();\n-                        }\n-                }\n-\n-                @Override\n-                public void onFinish() {\n-                        synchronized (sync) {\n-                                active = false;\n-                                sync.notifyAll();\n-                        }\n-                }\n-\n-                @Override\n-                public void onException(Throwable e) {\n-                        exception = e;\n-                }\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/StreamMessageInput.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.process;\n-\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.io.IOException;\n-import nsk.share.TestFailure;\n-\n-public class StreamMessageOutput implements MessageOutput {\n-        private OutputStream out;\n-        private PrintStream pout;\n-\n-        public StreamMessageOutput() {\n-        }\n-\n-        public StreamMessageOutput(OutputStream out) {\n-                bind(out);\n-        }\n-\n-        public void bind(OutputStream out) {\n-                this.out = out;\n-                this.pout = new PrintStream(out, true); \/\/ Autoflush is important\n-        }\n-\n-        public void start() {\n-        }\n-\n-        public void send(String msg) {\n-                pout.println(msg);\n-        }\n-\n-        public void finish() {\n-                pout.close();\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/process\/StreamMessageOutput.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.transform;\n-\n-import java.lang.instrument.ClassFileTransformer;\n-import java.lang.instrument.IllegalClassFormatException;\n-import java.security.ProtectionDomain;\n-\n-public abstract class AbstractClassFileTransformer\n-        implements ClassFileTransformer {\n-    protected abstract boolean shouldBeTransformed(String name);\n-\n-    protected abstract byte[] transformClass(byte[] bytes);\n-\n-    @Override\n-    public byte[] transform(ClassLoader loader, String className,\n-            Class<?> classBeingRedefined, ProtectionDomain protectionDomain,\n-            byte[] classfileBuffer) throws IllegalClassFormatException {\n-        if (shouldBeTransformed(className)) {\n-            return transformClass(classfileBuffer);\n-        }\n-        return null;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/transform\/AbstractClassFileTransformer.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.transform;\n-\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-\n-public abstract class AnnotationAppender {\n-    private final String desc;\n-    private final boolean visible;\n-    private boolean annotationPresent;\n-\n-    public AnnotationAppender(String desc, boolean visible) {\n-        this.desc = desc;\n-        this.visible = visible;\n-    }\n-\n-    public void checkAnnotation(String desc, boolean isVisible) {\n-        annotationPresent |= visible == isVisible && this.desc.equals(desc);\n-    }\n-\n-    public void addAnnotation(VisitAnnotation func) {\n-        if (shouldAdd()) {\n-            AnnotationVisitor av = func.visit(desc, true);\n-            if (av != null) {\n-                postCreate(av);\n-                av.visitEnd();\n-                annotationPresent = true;\n-            }\n-        }\n-    }\n-\n-    protected boolean shouldAdd() {\n-        return !annotationPresent;\n-    }\n-\n-    protected abstract void postCreate(AnnotationVisitor av);\n-\n-    @FunctionalInterface\n-    public static interface VisitAnnotation {\n-        AnnotationVisitor visit(String desc, boolean visible);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/transform\/AnnotationAppender.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.transform;\n-\n-import vm.share.FileUtils;\n-\n-public class TransformingClassLoader extends ClassLoader {\n-    private final AbstractClassFileTransformer transformer;\n-\n-    protected TransformingClassLoader(ClassLoader parent,\n-            AbstractClassFileTransformer transformer) {\n-        super(parent);\n-        this.transformer = transformer;\n-    }\n-\n-    @Override\n-    protected Class<?> loadClass(String name, boolean resolve)\n-            throws ClassNotFoundException {\n-        if (!transformer.shouldBeTransformed(name)) {\n-            return super.loadClass(name, resolve);\n-        }\n-        synchronized (getClassLoadingLock(name)) {\n-            \/\/ First, check if the class has already been loaded\n-            Class<?> c = findLoadedClass(name);\n-            if (c == null) {\n-                try {\n-                    byte[] bytes = FileUtils.readClass(name);\n-                    bytes = transformer.transformClass(bytes);\n-                    c = defineClass(name, bytes, 0, bytes.length);\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                    return super.loadClass(name, resolve);\n-                }\n-            }\n-            if (resolve) {\n-                resolveClass(c);\n-            }\n-            return c;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/transform\/TransformingClassLoader.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -39,2 +39,0 @@\n-java\/lang\/instrument\/NativeMethodPrefixAgent.java 8307169 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -615,1 +615,0 @@\n-com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java 8039280 generic-all\n@@ -622,1 +621,0 @@\n-javax\/net\/ssl\/SSLSession\/CertMsgCheck.java                      8326705 generic-all\n@@ -626,2 +624,0 @@\n-security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java#teliasonerarootcav1  8333640 generic-all\n-\n@@ -729,3 +725,0 @@\n-java\/util\/Locale\/LocaleProvidersRun.java                        8268379 macosx-x64\n-sun\/util\/locale\/provider\/CalendarDataRegression.java            8268379 macosx-x64\n-\n@@ -799,1 +792,0 @@\n-java\/awt\/print\/Dialog\/RestoreActiveWindowTest\/RestoreActiveWindowTest.java 8185429 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -262,0 +262,2 @@\n+# Tests in this group are manual as they depend on external infra\n+# and may fail with external reasons, for instance - change in CA test portal.\n@@ -629,0 +631,1 @@\n+    :jdk_security_infra \\\n@@ -632,1 +635,0 @@\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java \\\n@@ -672,1 +674,1 @@\n-   -:jdk_security\n\\ No newline at end of file\n+   -:jdk_security\n","filename":"test\/jdk\/TEST.groups","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+        setDelay(50);\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/gtk\/bug6492108.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8333542\n+ * @summary Missed breakpoint due to JVM not blocking other threads while\n+ *          delivering a ClassPrepareEvent.\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g BreakpointOnClassPrepare.java\n+ * @run driver BreakpointOnClassPrepare SUSPEND_NONE\n+ * @run driver BreakpointOnClassPrepare SUSPEND_EVENT_THREAD\n+ * @run driver BreakpointOnClassPrepare SUSPEND_ALL\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+\n+\/\/ The debuggee spawns 50 threads that call LoadedClass.foo(). The debugger enables\n+\/\/ ClassPrepareEvent for LoadedClass, and sets a breakpoint on LoadedClass.foo() when\n+\/\/ the ClassPrepareEvent arrives. The debugger expects 50 breakpoints to be hit.\n+\/\/ This verifies that the thread that causes the generation of the ClassPrepareEvent\n+\/\/ has properly blocked all other threads from executing LoadedClass.foo() until the\n+\/\/ ClassPrepareEvent has been delivered.\n+\n+class LoadedClass {\n+    static void foo(int k) {\n+        System.out.println(\"HIT = \" + k); \/\/ set breakpoint here\n+    }\n+}\n+\n+class BreakpointOnClassPrepareTarg {\n+    public static void main(String[] args) throws InterruptedException {\n+        System.out.println(\"Start\");\n+        Thread threads[] = new Thread[BreakpointOnClassPrepare.NUM_BREAKPOINTS];\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            int k = i;\n+            Thread t = DebuggeeWrapper.newThread(() -> {\n+                System.out.println(\"k = \" + k);\n+                LoadedClass.foo(k);\n+            });\n+            threads[i] = t;\n+            t.setDaemon(true);\n+            t.setName(\"MyThread-\" + k);\n+            t.start();\n+        }\n+\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            try {\n+                Thread t = threads[i];\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        System.out.println(\"Finish\");\n+    }\n+}\n+\n+    \/********** test program **********\/\n+\n+public class BreakpointOnClassPrepare extends TestScaffold {\n+    ClassType targetClass;\n+    ThreadReference mainThread;\n+\n+    BreakpointOnClassPrepare(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new BreakpointOnClassPrepare(args).startTests();\n+    }\n+\n+    \/********** event handlers **********\/\n+\n+    static final int NUM_BREAKPOINTS = 50;\n+    int bkptCount;\n+    BreakpointRequest bkptRequest;\n+\n+    public void breakpointReached(BreakpointEvent event) {\n+        bkptCount++;\n+        String threadInfo;\n+        try {\n+            threadInfo = event.thread().toString();\n+        } catch (ObjectCollectedException e) {\n+            \/\/ It's possible the Thread already terminated and was collected\n+            \/\/ if the SUSPEND_NONE policy was used.\n+            threadInfo = \"(thread collected)\";\n+        }\n+        System.out.println(\"Got BreakpointEvent: \" + bkptCount + \" for thread \" + threadInfo);\n+    }\n+\n+    public void vmDisconnected(VMDisconnectEvent event) {\n+        println(\"Got VMDisconnectEvent\");\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        \/* Determine which suspend policy to use. *\/\n+        int policy;\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Invalid number of args: \" + args.length);\n+        }\n+        String policyString = args[0];\n+        if (policyString.equals(\"SUSPEND_NONE\")) {\n+            policy = EventRequest.SUSPEND_NONE;\n+        } else if (policyString.equals(\"SUSPEND_ALL\")) {\n+            policy = EventRequest.SUSPEND_ALL;\n+        } else if (policyString.equals(\"SUSPEND_EVENT_THREAD\")) {\n+            policy = EventRequest.SUSPEND_EVENT_THREAD;\n+        } else {\n+            throw new RuntimeException(\"Invalid suspend policy: \" + policyString);\n+        }\n+\n+        \/* Stop when the target is loaded. *\/\n+        BreakpointEvent bpe = startToMain(\"BreakpointOnClassPrepareTarg\");\n+\n+        \/* Stop when \"LoadedClass\" is loaded. *\/\n+        EventRequestManager erm = vm().eventRequestManager();\n+        ClassPrepareEvent cpe = resumeToPrepareOf(\"LoadedClass\");\n+        println(\"Got ClassPrepareEvent: \" + cpe);\n+\n+        \/* Set a breakpoint for each time LoadedClass.foo() is called. *\/\n+        ClassType loadedClass = (ClassType)cpe.referenceType() ;\n+        Location loc1 = findMethodLocation(loadedClass,  \"foo\", \"(I)V\", 1);\n+        bkptRequest = erm.createBreakpointRequest(loc1);\n+        bkptRequest.setSuspendPolicy(policy);\n+        bkptRequest.enable();\n+\n+        listenUntilVMDisconnect();\n+\n+        if (!testFailed && bkptCount == NUM_BREAKPOINTS) {\n+            println(\"BreakpointOnClassPrepare: passed\");\n+        } else {\n+            throw new Exception(\"BreakpointOnClassPrepare: failed. bkptCount == \" + bkptCount);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/BreakpointOnClassPrepare.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -292,0 +292,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target()                .run();\n@@ -416,0 +417,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall()                 .run(this);\n@@ -1854,0 +1856,89 @@\n+\/\/ The debugger reads and publishes an object with eliminated locking to an instance field.\n+\/\/ A 2nd thread in the debuggee finds it there and changes its state using a synchronized method.\n+\/\/ Without eager relocking the accesses are unsynchronized which can be observed.\n+\/\/ This is a variant of EARelockingSimpleWithAccessInOtherThread with a dynamic call (not devirtualized).\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        String l1ClassName = EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target.SyncCounter.class.getName();\n+        ObjectReference ctr = getLocalRef(bpe.thread().frame(2), l1ClassName, \"l1\");\n+        setField(testCase, \"sharedCounter\", ctr);\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target extends EATestCaseBaseTarget {\n+\n+    public static final BrkPtDispatchA[] disp =\n+        {new BrkPtDispatchA(), new BrkPtDispatchB(), new BrkPtDispatchC(), new BrkPtDispatchD()};\n+\n+    public static class BrkPtDispatchA {\n+        public EATestCaseBaseTarget testCase;\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchB extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchC extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchD extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() {\n+            testCase.dontinline_brkpt();\n+        }\n+    }\n+\n+    public static class SyncCounter {\n+        private int val;\n+        public synchronized int inc() { return val++; }\n+    }\n+\n+    public volatile SyncCounter sharedCounter;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        for (BrkPtDispatchA d : disp) {\n+            d.testCase = this;\n+        }\n+        doLoop = true;\n+        new Thread(() -> {\n+                while (doLoop) {\n+                    SyncCounter ctr = sharedCounter;\n+                    if (ctr != null) {\n+                        ctr.inc();\n+                    }\n+                }\n+            }).start();\n+    }\n+\n+    public int dispCount;\n+    public void dontinline_testMethod() {\n+        SyncCounter l1 = new SyncCounter();\n+        synchronized (l1) {      \/\/ Eliminated locking\n+            l1.inc();\n+            \/\/ Use different types for the subsequent call to prevent devirtualization.\n+            BrkPtDispatchA d = disp[(dispCount++) & 3];\n+            d.dontinline_brkpt();  \/\/ Dynamic call. Debugger publishes l1 to sharedCounter.\n+            iResult = l1.inc();    \/\/ Changes by the 2nd thread will be observed if l1\n+                                   \/\/ was not relocked before passing it to the debugger.\n+        }\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-\n@@ -225,0 +224,2 @@\n+        \/\/ Account for threads using CPU for a few millis after their WAITING state is visible:\n+        goSleep(500);\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadCpuTimeArray.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8251496\n- * @summary Tests for methods in Authenticator\n- * @run testng\/othervm AuthenticatorTest\n- *\/\n-\n-import com.sun.net.httpserver.Authenticator;\n-import com.sun.net.httpserver.BasicAuthenticator;\n-import com.sun.net.httpserver.HttpPrincipal;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\n-public class AuthenticatorTest {\n-    @Test\n-    public void testFailure() {\n-        var failureResult = new Authenticator.Failure(666);\n-        assertEquals(failureResult.getResponseCode(), 666);\n-    }\n-\n-    @Test\n-    public void testRetry() {\n-        var retryResult = new Authenticator.Retry(333);\n-        assertEquals(retryResult.getResponseCode(), 333);\n-    }\n-\n-    @Test\n-    public void TestSuccess() {\n-        var principal = new HttpPrincipal(\"test\", \"123\");\n-        var successResult = new Authenticator.Success(principal);\n-        assertEquals(successResult.getPrincipal(), principal);\n-        assertEquals(\"test\", principal.getName());\n-        assertEquals(\"123\", principal.getRealm());\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8251496\n+ * @summary Tests for methods in Authenticator\n+ * @run junit AuthenticatorTest\n+ *\/\n+\n+import com.sun.net.httpserver.Authenticator;\n+import com.sun.net.httpserver.HttpPrincipal;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+public class AuthenticatorTest {\n+    @Test\n+    public void testFailure() {\n+        var failureResult = new Authenticator.Failure(666);\n+        assertEquals(666, failureResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testRetry() {\n+        var retryResult = new Authenticator.Retry(333);\n+        assertEquals(333, retryResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testSuccess() {\n+        var principal = new HttpPrincipal(\"test\", \"123\");\n+        var successResult = new Authenticator.Success(principal);\n+        assertEquals(principal, successResult.getPrincipal());\n+        assertEquals(\"test\", principal.getUsername());\n+        assertEquals(\"123\", principal.getRealm());\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib \/java\/security\/testlibrary\n@@ -28,1 +29,1 @@\n- * @run main\/manual Default\n+ * @run main\/othervm Default\n@@ -32,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -33,0 +36,1 @@\n+import java.io.*;\n@@ -35,16 +39,25 @@\n-   public static void main(String args[]) throws Exception {\n-        TextCallbackHandler h = new TextCallbackHandler();\n-        NameCallback nc = new NameCallback(\"Name: \", \"charlie\");\n-        ConfirmationCallback cc = new ConfirmationCallback\n-                        (\"Correct?\",\n-                        ConfirmationCallback.INFORMATION,\n-                        ConfirmationCallback.YES_NO_OPTION,\n-                        ConfirmationCallback.NO);\n-\n-        Callback[] callbacks = { nc, cc };\n-        h.handle(callbacks);\n-\n-        if (cc.getSelectedIndex() == ConfirmationCallback.YES) {\n-            System.out.println(\"yes\");\n-        } else {\n-            System.out.println(\"no\");\n+    public static void main(String args[]) throws Exception {\n+        InputStream in = System.in;\n+        PrintStream err = System.err;\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final String defaultName = \"charlie\";\n+        final String simulatedInput = \"-1\\n-1\\n\";\n+        HumanInputStream humanInputStream = new HumanInputStream(simulatedInput);\n+\n+        try (PrintStream prints = new PrintStream(baos)) {\n+            System.setIn(humanInputStream);\n+            System.setErr(prints);\n+            NameCallback nameCallback = new NameCallback(\"Name: \", defaultName);\n+            ConfirmationCallback confirmationCallback = new ConfirmationCallback(\n+                    \"Correct?\",\n+                    ConfirmationCallback.INFORMATION,\n+                    ConfirmationCallback.YES_NO_OPTION,\n+                    ConfirmationCallback.NO);\n+            new TextCallbackHandler().handle(new Callback[]{nameCallback, confirmationCallback});\n+\n+            Asserts.assertEquals(nameCallback.getDefaultName(), defaultName);\n+            Asserts.assertEquals(confirmationCallback.getSelectedIndex(), ConfirmationCallback.NO);\n+\n+        } finally {\n+            System.setIn(in);\n+            System.setErr(err);\n@@ -52,1 +65,5 @@\n-   }\n+\n+        \/\/ check that the default name and confirmation were visible in the output\n+        Asserts.assertTrue(baos.toString().contains(String.format(\"Name:  [%s]\", defaultName)));\n+        Asserts.assertTrue(baos.toString().contains(\"1. No [default]\"));\n+    }\n","filename":"test\/jdk\/com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334366\n+ * @key headful printer\n+ * @summary Verifies original pageobject is returned unmodified\n+ *          on cancelling pagedialog\n+ * @requires (os.family == \"windows\")\n+ * @run main PageDialogCancelTest\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.print.PageFormat;\n+import java.awt.print.PrinterJob;\n+\n+public class PageDialogCancelTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n+        PageFormat oldFormat = new PageFormat();\n+        Robot robot = new Robot();\n+        Thread t1 = new Thread(() -> {\n+            robot.delay(2000);\n+            robot.keyPress(KeyEvent.VK_ESCAPE);\n+            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+            robot.waitForIdle();\n+        });\n+        t1.start();\n+        PageFormat newFormat = pj.pageDialog(oldFormat);\n+        if (!newFormat.equals(oldFormat)) {\n+            throw new RuntimeException(\"Original PageFormat not returned on cancelling PageDialog\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PageDialogCancelTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- @ @key printer\n+ * @key printer\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/XparColor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -386,1 +385,6 @@\n-            assertEquals(MemorySegment.ofAddress(42).reinterpret(arena, s -> counter.incrementAndGet()).scope(), arena.scope());\n+            assertEquals(MemorySegment.ofAddress(42).reinterpret(arena, _ -> counter.incrementAndGet()).scope(), arena.scope());\n+            \/\/ check read-only state\n+            assertFalse(MemorySegment.ofAddress(42).reinterpret(100).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(100).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(100, Arena.ofAuto(), null).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(arena, _ -> counter.incrementAndGet()).isReadOnly());\n@@ -388,1 +392,1 @@\n-        assertEquals(counter.get(), 2);\n+        assertEquals(counter.get(), 3);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.reflect.Method;\n@@ -37,0 +38,4 @@\n+import org.junit.jupiter.api.extension.AfterTestExecutionCallback;\n+import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n@@ -51,0 +56,1 @@\n+@ExtendWith(IO.TimingExtension.class)\n@@ -65,0 +71,5 @@\n+            try {\n+                var outputAnalyzer = ProcessTools.executeProcess(\n+                        expect.toAbsolutePath().toString(), \"-version\");\n+                outputAnalyzer.reportDiagnosticSummary();\n+            } catch (Exception _) { }\n@@ -177,0 +188,37 @@\n+\n+\n+    \/\/ adapted from https:\/\/junit.org\/junit5\/docs\/current\/user-guide\/#extensions-lifecycle-callbacks-timing-extension\n+    \/\/ remove after CODETOOLS-7903752 propagates to jtreg that this test is routinely run by\n+\n+    public static class TimingExtension implements BeforeTestExecutionCallback,\n+            AfterTestExecutionCallback {\n+\n+        private static final System.Logger logger = System.getLogger(\n+                TimingExtension.class.getName());\n+\n+        private static final String START_TIME = \"start time\";\n+\n+        @Override\n+        public void beforeTestExecution(ExtensionContext context) {\n+            getStore(context).put(START_TIME, time());\n+        }\n+\n+        @Override\n+        public void afterTestExecution(ExtensionContext context) {\n+            Method testMethod = context.getRequiredTestMethod();\n+            long startTime = getStore(context).remove(START_TIME, long.class);\n+            long duration = time() - startTime;\n+\n+            logger.log(System.Logger.Level.INFO, () ->\n+                    String.format(\"Method [%s] took %s ms.\", testMethod.getName(), duration));\n+        }\n+\n+        private ExtensionContext.Store getStore(ExtensionContext context) {\n+            return context.getStore(ExtensionContext.Namespace.create(getClass(),\n+                    context.getRequiredTestMethod()));\n+        }\n+\n+        private long time() {\n+            return System.nanoTime() \/ 1_000_000;\n+        }\n+    }\n","filename":"test\/jdk\/java\/io\/IO\/IO.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+set timeout -1\n@@ -33,1 +34,2 @@\n-        puts \"timeout\"; exit 1\n+        puts \"timeout\"\n+        exit 1\n","filename":"test\/jdk\/java\/io\/IO\/input.exp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,3 +24,1 @@\n-################################################################################\n-# This script does not expect\/verify anything and is only used to simulate tty #\n-################################################################################\n+# This script doesn't verify any output strings, it's only used to simulate tty\n@@ -28,1 +26,4 @@\n-# Use `noecho` below, otherwise, expect will output the expanded \"spawn ...\"\n+set stty_init \"rows 24 cols 80\"\n+set timeout -1\n+\n+# Use `-noecho` below, otherwise, expect will output the expanded \"spawn ...\"\n@@ -30,0 +31,1 @@\n+# counterpart\n@@ -32,1 +34,10 @@\n-expect eof\n+\n+expect {\n+    eof {\n+        exit 0\n+    }\n+    timeout {\n+        puts \"timeout\"\n+        exit 1\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/IO\/output.exp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-        return cf.transform(cf.parse(classBytes), ClassTransform.dropping(ce ->\n+        return cf.transformClass(cf.parse(classBytes), ClassTransform.dropping(ce ->\n@@ -220,1 +220,1 @@\n-        return cf.transform(cf.parse(classBytes), ClassTransform.dropping(ce ->\n+        return cf.transformClass(cf.parse(classBytes), ClassTransform.dropping(ce ->\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BadCanonicalCtrTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-        return cf.transform(cf.parse(classBytes), ClassTransform.endHandler(clb -> {\n+        return cf.transformClass(cf.parse(classBytes), ClassTransform.endHandler(clb -> {\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ProhibitedMethods.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,1 +234,1 @@\n-        return cf.transform(model, new SerialPersistentFieldsVisitor(model.thisClass().asSymbol(), spf));\n+        return cf.transformClass(model, new SerialPersistentFieldsVisitor(model.thisClass().asSymbol(), spf));\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialPersistentFieldsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-        return cf.transform(oldModel, new ClassTransform() {\n+        return cf.transformClass(oldModel, new ClassTransform() {\n","filename":"test\/jdk\/java\/lang\/ModuleTests\/AnnotationsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-        var bytes = ClassFile.of().transform(model, transform);\n+        var bytes = ClassFile.of().transformClass(model, transform);\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-                    classData = cf.transform(cf.parse(classData), replaced.get(name));\n+                    classData = cf.transformClass(cf.parse(classData), replaced.get(name));\n","filename":"test\/jdk\/java\/lang\/invoke\/8022701\/BogoLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,0 @@\n-        if (vstr == null)\n-            vstr = System.getProperty(\"test.verbose\");\n","filename":"test\/jdk\/java\/lang\/invoke\/PrivateInvokeTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,798 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/* @test\n+ * @bug 8335060\n+ * @summary unit tests of TypeConvertingMethodAdapter\n+ * @run junit TypeConvertingTest\n+ *\/\n+public class TypeConvertingTest {\n+\n+    static void smallBooleanC(boolean b) {\n+        assertTrue(b);\n+    }\n+\n+    static void bigBooleanC(Boolean b) {\n+        assertTrue(b);\n+    }\n+\n+    static void smallByteC(byte b) {\n+        assertEquals(1, b);\n+    }\n+\n+    static void bigByteC(Byte b) {\n+        assertEquals((byte)1, b);\n+    }\n+\n+    static void smallShortC(short s) {\n+        assertEquals(1, s);\n+    }\n+\n+    static void bigShortC(Short s) {\n+        assertEquals((short)1, s);\n+    }\n+\n+    static void smallCharC(char c) {\n+        assertEquals(1, c);\n+    }\n+\n+    static void bigCharC(Character c) {\n+        assertEquals((char)1, c);\n+    }\n+\n+    static void smallIntC(int i) {\n+        assertEquals(1, i);\n+    }\n+\n+    static void bigIntC(Integer i) {\n+        assertEquals(1, i);\n+    }\n+\n+    static void smallLongC(long l) {\n+        assertEquals(1, l);\n+    }\n+\n+    static void bigLongC(Long l) {\n+        assertEquals(1, l);\n+    }\n+\n+    static void smallFloatC(float f) {\n+        assertEquals(1.0f, f);\n+    }\n+\n+    static void bigFloatC(Float f) {\n+        assertEquals(1.0f, f);\n+    }\n+\n+    static void smallDoubleC(double d) {\n+        assertEquals(1.0, d);\n+    }\n+\n+    static void bigDoubleC(Double d) {\n+        assertEquals(1.0, d);\n+    }\n+\n+    static void numberC(Number n) {\n+        assertEquals(1, n.intValue());\n+    }\n+\n+\n+    static boolean smallBooleanS() {return true;}\n+\n+    static Boolean bigBooleanS() {return true;}\n+\n+    static byte smallByteS() {return 1;}\n+\n+    static Byte bigByteS() {return 1;}\n+\n+    static short smallShortS() {return 1;}\n+\n+    static Short bigShortS() {return 1;}\n+\n+    static char smallCharS() {return 1;}\n+\n+    static Character bigCharS() {return 1;}\n+\n+    static int smallIntS() {return 1;}\n+\n+    static Integer bigIntS() {return 1;}\n+\n+    static long smallLongS() {return 1;}\n+\n+    static Long bigLongS() {return 1l;}\n+\n+    static float smallFloatS() {return 1;}\n+\n+    static Float bigFloatS() {return 1f;}\n+\n+    static double smallDoubleS() {return 1;}\n+\n+    static Double bigDoubleS() {return 1d;}\n+\n+    static Number numberS() {return 1;}\n+\n+\n+    interface GenericC<T> {\n+        void m(T t);\n+    }\n+\n+    interface SmallBooleanC {\n+        void m(boolean b);\n+    }\n+\n+    interface BigBooleanC {\n+        void m(Boolean b);\n+    }\n+\n+    interface SmallByteC {\n+        void m(byte b);\n+    }\n+\n+    interface BigByteC {\n+        void m(Byte b);\n+    }\n+\n+    interface SmallShortC {\n+        void m(short s);\n+    }\n+\n+    interface BigShortC {\n+        void m(Short s);\n+    }\n+\n+    interface SmallCharC {\n+        void m(char c);\n+    }\n+\n+    interface BigCharC {\n+        void m(Character c);\n+    }\n+\n+    interface SmallIntC {\n+        void m(int i);\n+    }\n+\n+    interface BigIntC {\n+        void m(Integer i);\n+    }\n+\n+    interface SmallLongC {\n+        void m(long l);\n+    }\n+\n+    interface BigLongC {\n+        void m(Long l);\n+    }\n+\n+    interface SmallFloatC {\n+        void m(float f);\n+    }\n+\n+    interface BigFloatC {\n+        void m(Float f);\n+    }\n+\n+    interface SmallDoubleC {\n+        void m(double d);\n+    }\n+\n+    interface BigDoubleC {\n+        void m(Double d);\n+    }\n+\n+    interface BigNumberC {\n+        void m(Number n);\n+    }\n+\n+\n+    interface GenericS<T> {\n+        T m();\n+    }\n+\n+    interface SmallBooleanS {\n+        boolean m();\n+    }\n+\n+    interface BigBooleanS {\n+        Boolean m();\n+    }\n+\n+    interface SmallByteS {\n+        byte m();\n+    }\n+\n+    interface BigByteS {\n+        Byte m();\n+    }\n+\n+    interface SmallShortS {\n+        short m();\n+    }\n+\n+    interface BigShortS {\n+        Short m();\n+    }\n+\n+    interface SmallCharS {\n+        char m();\n+    }\n+\n+    interface BigCharS {\n+        Character m();\n+    }\n+\n+    interface SmallIntS {\n+        int m();\n+    }\n+\n+    interface BigIntS {\n+        Integer m();\n+    }\n+\n+    interface SmallLongS {\n+        long m();\n+    }\n+\n+    interface BigLongS {\n+        Long m();\n+    }\n+\n+    interface SmallFloatS {\n+        float m();\n+    }\n+\n+    interface BigFloatS {\n+        Float m();\n+    }\n+\n+    interface SmallDoubleS {\n+        double m();\n+    }\n+\n+    interface BigDoubleS {\n+        Double m();\n+    }\n+\n+    interface BigNumberS {\n+        Number m();\n+    }\n+\n+\n+    static void testGenericBoolean(GenericC<Boolean> t) {\n+        t.m(true);\n+    }\n+\n+    static void testGenericByte(GenericC<Byte> t) {\n+        t.m((byte)1);\n+    }\n+\n+    static void testGenericShort(GenericC<Short> t) {\n+        t.m((short)1);\n+    }\n+\n+    static void testGenericChar(GenericC<Character> t) {\n+        t.m((char)1);\n+    }\n+\n+    static void testGenericInt(GenericC<Integer> t) {\n+        t.m(1);\n+    }\n+\n+    static void testGenericLong(GenericC<Long> t) {\n+        t.m(1l);\n+    }\n+\n+    static void testGenericFloat(GenericC<Float> t) {\n+        t.m(1.0f);\n+    }\n+\n+    static void testGenericDouble(GenericC<Double> t) {\n+        t.m(1.0d);\n+    }\n+\n+    static void testGenericNumber(GenericC<Number> t) {\n+        t.m(1);\n+    }\n+\n+    static void testSmallBoolean(SmallBooleanC t) {\n+        t.m(true);\n+    }\n+\n+    static void testSmallByte(SmallByteC t) {\n+        t.m((byte)1);\n+    }\n+\n+    static void testSmallShort(SmallShortC t) {\n+        t.m((short)1);\n+    }\n+\n+    static void testSmallChar(SmallCharC t) {\n+        t.m((char)1);\n+    }\n+\n+    static void testSmallInt(SmallIntC t) {\n+        t.m(1);\n+    }\n+\n+    static void testSmallLong(SmallLongC t) {\n+        t.m(1l);\n+    }\n+\n+    static void testSmallFloat(SmallFloatC t) {\n+        t.m(1.0f);\n+    }\n+\n+    static void testSmallDouble(SmallDoubleC t) {\n+        t.m(1.0d);\n+    }\n+\n+    static void testBigBoolean(BigBooleanC t) {\n+        t.m(true);\n+    }\n+\n+    static void testBigByte(BigByteC t) {\n+        t.m((byte)1);\n+    }\n+\n+    static void testBigShort(BigShortC t) {\n+        t.m((short)1);\n+    }\n+\n+    static void testBigChar(BigCharC t) {\n+        t.m((char)1);\n+    }\n+\n+    static void testBigInt(BigIntC t) {\n+        t.m(1);\n+    }\n+\n+    static void testBigLong(BigLongC t) {\n+        t.m(1l);\n+    }\n+\n+    static void testBigFloat(BigFloatC t) {\n+        t.m(1.0f);\n+    }\n+\n+    static void testBigDouble(BigDoubleC t) {\n+        t.m(1.0d);\n+    }\n+\n+    static void testBigNumber(BigNumberC t) {\n+        t.m(1);\n+    }\n+\n+\n+    static void testGenericBoolean(GenericS<Boolean> t) {\n+        assertEquals(true, t.m());\n+    }\n+\n+    static void testGenericByte(GenericS<Byte> t) {\n+        assertEquals((byte)1, t.m());\n+    }\n+\n+    static void testGenericShort(GenericS<Short> t) {\n+        assertEquals((short)1, t.m());\n+    }\n+\n+    static void testGenericChar(GenericS<Character> t) {\n+        assertEquals((char)1, t.m());\n+    }\n+\n+    static void testGenericInt(GenericS<Integer> t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testGenericLong(GenericS<Long> t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testGenericFloat(GenericS<Float> t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testGenericDouble(GenericS<Double> t) {\n+        assertEquals(1.0d, t.m());\n+    }\n+\n+    static void testGenericNumber(GenericS<Number> t) {\n+        assertEquals(1, t.m().intValue());\n+    }\n+\n+    static void testSmallBoolean(SmallBooleanS t) {\n+        assertEquals(true, t.m());\n+    }\n+\n+    static void testSmallByte(SmallByteS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallShort(SmallShortS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallChar(SmallCharS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallInt(SmallIntS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallLong(SmallLongS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testSmallFloat(SmallFloatS t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testSmallDouble(SmallDoubleS t) {\n+        assertEquals(1.0d, t.m());\n+    }\n+\n+    static void testBigBoolean(BigBooleanS t) {\n+        assertEquals(true, t.m());\n+    }\n+\n+    static void testBigByte(BigByteS t) {\n+        assertEquals((byte)1, t.m());\n+    }\n+\n+    static void testBigShort(BigShortS t) {\n+        assertEquals((short)1, t.m());\n+    }\n+\n+    static void testBigChar(BigCharS t) {\n+        assertEquals((char)1, t.m());\n+    }\n+\n+    static void testBigInt(BigIntS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testBigLong(BigLongS t) {\n+        assertEquals(1, t.m());\n+    }\n+\n+    static void testBigFloat(BigFloatS t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testBigDouble(BigDoubleS t) {\n+        assertEquals(1.0f, t.m());\n+    }\n+\n+    static void testBigNumber(BigNumberS t) {\n+        assertEquals(1, t.m().intValue());\n+    }\n+\n+\n+    @Test\n+    void testGenericBoolean() {\n+        testGenericBoolean(TypeConvertingTest::smallBooleanC);\n+        testGenericBoolean(TypeConvertingTest::bigBooleanC);\n+\n+        testGenericBoolean(TypeConvertingTest::smallBooleanS);\n+        testGenericBoolean(TypeConvertingTest::bigBooleanS);\n+    }\n+\n+    @Test\n+    void testGenericByte() {\n+        testGenericByte(TypeConvertingTest::smallByteC);\n+        testGenericByte(TypeConvertingTest::bigByteC);\n+        testGenericByte(TypeConvertingTest::smallShortC);\n+        testGenericByte(TypeConvertingTest::smallIntC);\n+        testGenericByte(TypeConvertingTest::smallLongC);\n+        testGenericByte(TypeConvertingTest::smallFloatC);\n+        testGenericByte(TypeConvertingTest::smallDoubleC);\n+        testGenericByte(TypeConvertingTest::numberC);\n+\n+        testGenericByte(TypeConvertingTest::smallByteS);\n+        testGenericByte(TypeConvertingTest::bigByteS);\n+    }\n+\n+    @Test\n+    void testGenericShort() {\n+        testGenericShort(TypeConvertingTest::smallShortC);\n+        testGenericShort(TypeConvertingTest::bigShortC);\n+        testGenericShort(TypeConvertingTest::smallIntC);\n+        testGenericShort(TypeConvertingTest::smallLongC);\n+        testGenericShort(TypeConvertingTest::smallFloatC);\n+        testGenericShort(TypeConvertingTest::smallDoubleC);\n+        testGenericShort(TypeConvertingTest::numberC);\n+\n+        testGenericShort(TypeConvertingTest::smallShortS);\n+        testGenericShort(TypeConvertingTest::bigShortS);\n+    }\n+\n+    @Test\n+    void testGenericChar() {\n+        testGenericChar(TypeConvertingTest::smallCharC);\n+        testGenericChar(TypeConvertingTest::bigCharC);\n+        testGenericChar(TypeConvertingTest::smallIntC);\n+        testGenericChar(TypeConvertingTest::smallLongC);\n+        testGenericChar(TypeConvertingTest::smallFloatC);\n+        testGenericChar(TypeConvertingTest::smallDoubleC);\n+\n+        testGenericChar(TypeConvertingTest::smallCharS);\n+        testGenericChar(TypeConvertingTest::bigCharS);\n+    }\n+\n+    @Test\n+    void testGenericInt() {\n+        testGenericInt(TypeConvertingTest::smallIntC);\n+        testGenericInt(TypeConvertingTest::bigIntC);\n+        testGenericInt(TypeConvertingTest::smallLongC);\n+        testGenericInt(TypeConvertingTest::smallFloatC);\n+        testGenericInt(TypeConvertingTest::smallDoubleC);\n+        testGenericInt(TypeConvertingTest::numberC);\n+\n+        testGenericInt(TypeConvertingTest::smallIntS);\n+        testGenericInt(TypeConvertingTest::bigIntS);\n+    }\n+\n+    @Test\n+    void testGenericLong() {\n+        testGenericLong(TypeConvertingTest::smallLongC);\n+        testGenericLong(TypeConvertingTest::bigLongC);\n+        testGenericLong(TypeConvertingTest::smallFloatC);\n+        testGenericLong(TypeConvertingTest::smallDoubleC);\n+        testGenericLong(TypeConvertingTest::numberC);\n+\n+        testGenericLong(TypeConvertingTest::smallLongS);\n+        testGenericLong(TypeConvertingTest::bigLongS);\n+    }\n+\n+    @Test\n+    void testGenericFloat() {\n+        testGenericFloat(TypeConvertingTest::smallFloatC);\n+        testGenericFloat(TypeConvertingTest::bigFloatC);\n+        testGenericFloat(TypeConvertingTest::smallDoubleC);\n+        testGenericFloat(TypeConvertingTest::numberC);\n+\n+        testGenericFloat(TypeConvertingTest::smallFloatS);\n+        testGenericFloat(TypeConvertingTest::bigFloatS);\n+    }\n+\n+    @Test\n+    void testGenericDouble() {\n+        testGenericDouble(TypeConvertingTest::smallDoubleC);\n+        testGenericDouble(TypeConvertingTest::bigDoubleC);\n+        testGenericDouble(TypeConvertingTest::numberC);\n+\n+        testGenericDouble(TypeConvertingTest::smallDoubleS);\n+        testGenericDouble(TypeConvertingTest::bigDoubleS);\n+    }\n+\n+    @Test\n+    void testGenericNumber() {\n+        testGenericNumber(TypeConvertingTest::numberC);\n+\n+        testGenericNumber(TypeConvertingTest::numberS);\n+    }\n+\n+    @Test\n+    void testSmallBoolean() {\n+        testSmallBoolean(TypeConvertingTest::smallBooleanC);\n+        testSmallBoolean(TypeConvertingTest::bigBooleanC);\n+\n+        testSmallBoolean(TypeConvertingTest::smallBooleanS);\n+        testSmallBoolean(TypeConvertingTest::bigBooleanS);\n+    }\n+\n+    @Test\n+    void testSmallByte() {\n+        testSmallByte(TypeConvertingTest::smallByteC);\n+        testSmallByte(TypeConvertingTest::bigByteC);\n+        testSmallByte(TypeConvertingTest::smallShortC);\n+        testSmallByte(TypeConvertingTest::smallIntC);\n+        testSmallByte(TypeConvertingTest::smallLongC);\n+        testSmallByte(TypeConvertingTest::smallFloatC);\n+        testSmallByte(TypeConvertingTest::smallDoubleC);\n+        testSmallByte(TypeConvertingTest::numberC);\n+\n+        testSmallByte(TypeConvertingTest::smallByteS);\n+        testSmallByte(TypeConvertingTest::bigByteS);\n+    }\n+\n+    @Test\n+    void testSmallShort() {\n+        testSmallShort(TypeConvertingTest::smallShortC);\n+        testSmallShort(TypeConvertingTest::bigShortC);\n+        testSmallShort(TypeConvertingTest::smallIntC);\n+        testSmallShort(TypeConvertingTest::smallLongC);\n+        testSmallShort(TypeConvertingTest::smallFloatC);\n+        testSmallShort(TypeConvertingTest::smallDoubleC);\n+        testSmallShort(TypeConvertingTest::numberC);\n+\n+        testSmallShort(TypeConvertingTest::smallShortS);\n+        testSmallShort(TypeConvertingTest::bigShortS);\n+    }\n+\n+    @Test\n+    void testSmallChar() {\n+        testSmallChar(TypeConvertingTest::smallCharC);\n+        testSmallChar(TypeConvertingTest::bigCharC);\n+        testSmallChar(TypeConvertingTest::smallIntC);\n+        testSmallChar(TypeConvertingTest::smallLongC);\n+        testSmallChar(TypeConvertingTest::smallFloatC);\n+        testSmallChar(TypeConvertingTest::smallDoubleC);\n+\n+        testSmallChar(TypeConvertingTest::smallCharS);\n+        testSmallChar(TypeConvertingTest::bigCharS);\n+    }\n+\n+    @Test\n+    void testSmallInt() {\n+        testSmallInt(TypeConvertingTest::smallIntC);\n+        testSmallInt(TypeConvertingTest::bigIntC);\n+        testSmallInt(TypeConvertingTest::smallLongC);\n+        testSmallInt(TypeConvertingTest::smallFloatC);\n+        testSmallInt(TypeConvertingTest::smallDoubleC);\n+        testSmallInt(TypeConvertingTest::numberC);\n+\n+        testSmallInt(TypeConvertingTest::smallIntS);\n+        testSmallInt(TypeConvertingTest::bigIntS);\n+    }\n+\n+    @Test\n+    void testSmallLong() {\n+        testSmallLong(TypeConvertingTest::smallLongC);\n+        testSmallLong(TypeConvertingTest::bigLongC);\n+        testSmallLong(TypeConvertingTest::smallFloatC);\n+        testSmallLong(TypeConvertingTest::smallDoubleC);\n+        testSmallLong(TypeConvertingTest::numberC);\n+\n+        testSmallLong(TypeConvertingTest::smallLongS);\n+        testSmallLong(TypeConvertingTest::bigLongS);\n+    }\n+\n+    @Test\n+    void testSmallFloat() {\n+        testSmallFloat(TypeConvertingTest::smallFloatC);\n+        testSmallFloat(TypeConvertingTest::bigFloatC);\n+        testSmallFloat(TypeConvertingTest::smallDoubleC);\n+        testSmallFloat(TypeConvertingTest::numberC);\n+\n+        testSmallFloat(TypeConvertingTest::smallFloatS);\n+        testSmallFloat(TypeConvertingTest::bigFloatS);\n+    }\n+\n+    @Test\n+    void testSmallDouble() {\n+        testSmallDouble(TypeConvertingTest::smallDoubleC);\n+        testSmallDouble(TypeConvertingTest::bigDoubleC);\n+        testSmallDouble(TypeConvertingTest::numberC);\n+\n+        testSmallDouble(TypeConvertingTest::smallDoubleS);\n+        testSmallDouble(TypeConvertingTest::bigDoubleS);\n+    }\n+\n+    @Test\n+    void testBigBoolean() {\n+        testBigBoolean(TypeConvertingTest::smallBooleanC);\n+        testBigBoolean(TypeConvertingTest::bigBooleanC);\n+\n+        testBigBoolean(TypeConvertingTest::smallBooleanS);\n+        testBigBoolean(TypeConvertingTest::bigBooleanS);\n+    }\n+\n+    @Test\n+    void testBigByte() {\n+        testBigByte(TypeConvertingTest::smallByteC);\n+        testBigByte(TypeConvertingTest::bigByteC);\n+        testBigByte(TypeConvertingTest::smallShortC);\n+        testBigByte(TypeConvertingTest::smallIntC);\n+        testBigByte(TypeConvertingTest::smallLongC);\n+        testBigByte(TypeConvertingTest::smallFloatC);\n+        testBigByte(TypeConvertingTest::smallDoubleC);\n+        testBigByte(TypeConvertingTest::numberC);\n+\n+        testBigByte(TypeConvertingTest::smallByteS);\n+        testBigByte(TypeConvertingTest::bigByteS);\n+    }\n+\n+    @Test\n+    void testBigShort() {\n+        testBigShort(TypeConvertingTest::smallShortC);\n+        testBigShort(TypeConvertingTest::bigShortC);\n+        testBigShort(TypeConvertingTest::smallIntC);\n+        testBigShort(TypeConvertingTest::smallLongC);\n+        testBigShort(TypeConvertingTest::smallFloatC);\n+        testBigShort(TypeConvertingTest::smallDoubleC);\n+        testBigShort(TypeConvertingTest::numberC);\n+\n+        testBigShort(TypeConvertingTest::smallShortS);\n+        testBigShort(TypeConvertingTest::bigShortS);\n+    }\n+\n+    @Test\n+    void testBigChar() {\n+        testBigChar(TypeConvertingTest::smallCharC);\n+        testBigChar(TypeConvertingTest::bigCharC);\n+        testBigChar(TypeConvertingTest::smallIntC);\n+        testBigChar(TypeConvertingTest::smallLongC);\n+        testBigChar(TypeConvertingTest::smallFloatC);\n+        testBigChar(TypeConvertingTest::smallDoubleC);\n+\n+        testBigChar(TypeConvertingTest::smallCharS);\n+        testBigChar(TypeConvertingTest::bigCharS);\n+    }\n+\n+    @Test\n+    void testBigInt() {\n+        testBigInt(TypeConvertingTest::smallIntC);\n+        testBigInt(TypeConvertingTest::bigIntC);\n+        testBigInt(TypeConvertingTest::smallLongC);\n+        testBigInt(TypeConvertingTest::smallFloatC);\n+        testBigInt(TypeConvertingTest::smallDoubleC);\n+        testBigInt(TypeConvertingTest::numberC);\n+\n+        testBigInt(TypeConvertingTest::smallIntS);\n+        testBigInt(TypeConvertingTest::bigIntS);\n+    }\n+\n+    @Test\n+    void testBigLong() {\n+        testBigLong(TypeConvertingTest::smallLongC);\n+        testBigLong(TypeConvertingTest::bigLongC);\n+        testBigLong(TypeConvertingTest::smallFloatC);\n+        testBigLong(TypeConvertingTest::smallDoubleC);\n+        testBigLong(TypeConvertingTest::numberC);\n+\n+        testBigLong(TypeConvertingTest::smallLongS);\n+        testBigLong(TypeConvertingTest::bigLongS);\n+    }\n+\n+    @Test\n+    void testBigFloat() {\n+        testBigFloat(TypeConvertingTest::smallFloatC);\n+        testBigFloat(TypeConvertingTest::bigFloatC);\n+        testBigFloat(TypeConvertingTest::smallDoubleC);\n+        testBigFloat(TypeConvertingTest::numberC);\n+\n+        testBigFloat(TypeConvertingTest::smallFloatS);\n+        testBigFloat(TypeConvertingTest::bigFloatS);\n+    }\n+\n+    @Test\n+    void testBigDouble() {\n+        testBigDouble(TypeConvertingTest::smallDoubleC);\n+        testBigDouble(TypeConvertingTest::bigDoubleC);\n+        testBigDouble(TypeConvertingTest::numberC);\n+\n+        testBigDouble(TypeConvertingTest::smallDoubleS);\n+        testBigDouble(TypeConvertingTest::bigDoubleS);\n+    }\n+\n+    @Test\n+    void testBigNumber() {\n+        testBigNumber(TypeConvertingTest::numberC);\n+\n+        testBigNumber(TypeConvertingTest::numberS);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/TypeConvertingTest.java","additions":798,"deletions":0,"binary":false,"changes":798,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-                    classData = cf.transform(cf.parse(classData), replaced.get(name));\n+                    classData = cf.transformClass(cf.parse(classData), replaced.get(name));\n","filename":"test\/jdk\/java\/lang\/invoke\/accessProtectedSuper\/BogoLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-                os.write (reply2.getBytes());\n+                os.write ((reply2+\"HelloAgain\").getBytes());\n","filename":"test\/jdk\/java\/net\/Authenticator\/BasicTest4.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+        \/\/ retains only network interface whose bound addresses match\n@@ -67,2 +68,17 @@\n-                                      .map(nif -> new Object[] { new InetSocketAddress(a, 0), nif })\n-                                      .forEach(list::add) );\n+                .filter(nif -> nif.inetAddresses().toList().contains(a))\n+                .map(nif -> new Object[] { new InetSocketAddress(a, 0), nif })\n+                .forEach(list::add) );\n+        \/\/ any network interface should work with the wildcard address\n+        nc.multicastInterfaces(true)\n+                .map(nif -> new Object[] {new InetSocketAddress(0), nif})\n+                .forEach(list::add);\n+        return list.stream().toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"interfaces\")\n+    public Object[][] interfaces() throws Exception {\n+        List<Object[]> list = new ArrayList<>();\n+        NetworkConfiguration nc = NetworkConfiguration.probe();\n+        nc.multicastInterfaces(true)\n+                .map(nif -> new Object[] {nif})\n+                .forEach(list::add);\n@@ -85,2 +101,2 @@\n-    @Test(dataProvider = \"scenarios\")\n-    public void testSetGetInterfaceUnbound(InetSocketAddress ignore, NetworkInterface nif)\n+    @Test(dataProvider = \"interfaces\")\n+    public void testSetGetInterfaceUnbound(NetworkInterface nif)\n@@ -109,2 +125,2 @@\n-    @Test(dataProvider = \"scenarios\")\n-    public void testSetGetOptionUnbound(InetSocketAddress ignore, NetworkInterface nif)\n+    @Test(dataProvider = \"interfaces\")\n+    public void testSetGetOptionUnbound(NetworkInterface nif)\n@@ -142,2 +158,2 @@\n-    public void testGettInterfaceUnbound() throws Exception {\n-        out.println(\"\\n\\n--- testGettInterfaceUnbound \");\n+    public void testGetInterfaceUnbound() throws Exception {\n+        out.println(\"\\n\\n--- testGetInterfaceUnbound \");\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/IPMulticastIF.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335135\n+ * @library \/test\/lib\n+ * @summary Check that reading from inputStream throws an IOException\n+ *          if the fixed response stream is closed before reading all bytes.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+\n+public class TruncatedFixedResponse implements Runnable {\n+\n+    ServerSocket ss;\n+\n+    \/*\n+     * Our \"http\" server to return a truncated fixed response\n+     *\/\n+    public void run() {\n+        try {\n+            Socket s = ss.accept();\n+\n+            BufferedReader in = new BufferedReader(\n+                    new InputStreamReader(s.getInputStream()));\n+            while (true) {\n+                String req = in.readLine();\n+                if (req.isEmpty()) {\n+                    break;\n+                }\n+            }\n+            PrintStream out = new PrintStream(\n+                    new BufferedOutputStream(s.getOutputStream()));\n+\n+            \/* send the header *\/\n+            out.print(\"HTTP\/1.1 200\\r\\n\");\n+            out.print(\"Content-Length: 100\\r\\n\");\n+            out.print(\"Content-Type: text\/html\\r\\n\");\n+            out.print(\"\\r\\n\");\n+            out.print(\"Some content, but too short\");\n+            out.close();\n+            s.close();\n+            ss.close();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    TruncatedFixedResponse() throws Exception {\n+        \/* start the server *\/\n+        ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        new Thread(this).start();\n+\n+        \/* establish http connection to server *\/\n+        URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(ss.getLocalPort())\n+                .path(\"\/foo\")\n+                .toURL();\n+        HttpURLConnection http = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);\n+\n+        try (InputStream in = http.getInputStream()) {\n+            while (in.read() != -1) {\n+                \/\/ discard response\n+            }\n+            throw new AssertionError(\"Expected IOException was not thrown\");\n+        } catch (IOException ex) {\n+            System.out.println(\"Got expected exception: \" + ex);\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        new TruncatedFixedResponse();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLConnection\/TruncatedFixedResponse.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -72,0 +74,2 @@\n+                \/\/ weed off stray datagrams\n+                if (ip.getPort() != dst.getPort()) continue;\n@@ -114,3 +118,26 @@\n-            DatagramChannel dc = DatagramChannel.open();\n-            ds = dc.socket();\n-            ds.bind(new InetSocketAddress(0));\n+            int attempts = 0;\n+            DatagramChannel toclose = null;\n+            while (true) {\n+                DatagramChannel dc = DatagramChannel.open();\n+                ds = dc.socket();\n+                if (Platform.isOSX() && dst.getAddress().isLoopbackAddress()) {\n+                    \/\/ avoid binding to the wildcard on macOS if possible, in order to limit\n+                    \/\/ potential port conflict issues\n+                    ds.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+                } else {\n+                    ds.bind(new InetSocketAddress(0));\n+                }\n+                \/\/ on some systems it may be possible to bind two sockets\n+                \/\/ to the same port if one of them is bound to the wildcard,\n+                \/\/ if that happens, try again...\n+                if (ds.getLocalPort() == dst.getPort()) {\n+                    if (toclose != null) toclose.close();\n+                    toclose = dc;\n+                    if (++attempts == 10) {\n+                        throw new AssertionError(\"Couldn't allocate port for client socket\");\n+                    }\n+                    continue;\n+                }\n+                if (toclose != null) toclose.close();\n+                break;\n+            }\n@@ -119,1 +146,2 @@\n-        out.println(\"socket: \" + ds);\n+        out.println(\"socket: \" + ds + \" bound to src: \"\n+                + ds.getLocalSocketAddress() + \", dst: \" + dst);\n@@ -144,1 +172,1 @@\n-                = TestServers.UdpEchoServer.startNewServer(100)) {\n+                = TestServers.UdpEchoServer.startNewServer(100, InetAddress.getLoopbackAddress())) {\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorBasic.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+\n@@ -45,2 +46,4 @@\n-            test(dc);\n-            test(dc);\n+            InetAddress lo = InetAddress.getLoopbackAddress();\n+            System.out.println(\"Testing with default family and \" + lo);\n+            test(dc, lo);\n+            test(dc, lo);\n@@ -52,2 +55,4 @@\n-                test(dc);\n-                test(dc);\n+                InetAddress lo4 = InetAddress.ofLiteral(\"127.0.0.1\");\n+                System.out.println(\"Testing with INET family and \" + lo4);\n+                test(dc, lo4);\n+                test(dc, lo4);\n@@ -60,2 +65,4 @@\n-                test(dc);\n-                test(dc);\n+                InetAddress lo6 = InetAddress.ofLiteral(\"::1\");\n+                System.out.println(\"Testing with INET6 family and \" + lo6);\n+                test(dc, lo6);\n+                test(dc, lo6);\n@@ -66,0 +73,4 @@\n+    static int getLocalPort(DatagramChannel ch) throws IOException {\n+        return ((InetSocketAddress) ch.getLocalAddress()).getPort();\n+    }\n+\n@@ -71,1 +82,1 @@\n-    static void test(DatagramChannel dc) throws IOException {\n+    static void test(DatagramChannel dc, InetAddress lo) throws IOException {\n@@ -73,1 +84,1 @@\n-            server.bind(new InetSocketAddress(0));\n+            server.bind(new InetSocketAddress(lo, 0));\n@@ -75,2 +86,4 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n-            dc.connect(new InetSocketAddress(lh, server.socket().getLocalPort()));\n+            SocketAddress dcbound = dc.getLocalAddress();\n+            dc.connect(new InetSocketAddress(lo, server.socket().getLocalPort()));\n+            System.out.println(\"dc bound to \" + dcbound + \" and connected from \" +\n+                    dc.getLocalAddress() + \" to \" + dc.getRemoteAddress());\n@@ -80,2 +93,8 @@\n-            ByteBuffer bb = ByteBuffer.allocate(100);\n-            server.receive(bb);\n+            if (getLocalPort(dc) != getLocalPort(server)) {\n+                ByteBuffer bb = ByteBuffer.allocate(100);\n+                server.receive(bb);\n+            } else {\n+                \/\/ some systems may allow dc and server to bind to the same port.\n+                \/\/ when that happen the datagram may never be received\n+                System.out.println(\"Server and clients are bound to the same port: skipping receive\");\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Disconnect.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-            ByteBuffer src = ByteBuffer.wrap(\"hello\".getBytes(\"UTF-8\"));\n+            String str = \"hello \" + System.nanoTime();\n+            ByteBuffer src = ByteBuffer.wrap(str.getBytes(\"UTF-8\"));\n@@ -145,0 +146,1 @@\n+            src.flip();\n@@ -160,0 +162,5 @@\n+                        if (src.mismatch(dst) != -1) {\n+                            System.out.println(\"src: \" + src + \"not equal to dst: \" + dst);\n+                            dst.clear();\n+                            continue;\n+                        }\n@@ -163,1 +170,2 @@\n-                            assertTrue(senderPort != localPort, \"Unexpected message\");\n+                            assertTrue(senderPort != localPort,\n+                                    \"Unexpected message: localPort=\" + localPort);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Loopback.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8334719\n+ * @summary verifies that if a registered channel has in-progress operations, then\n+ *          the Selector during its deferred close implementation won't prematurely release\n+ *          the channel's resources\n+ *\n+ * @comment we use a patched java.net.InetSocketAddress to allow the test to intentionally\n+ *          craft some delays at specific locations in the implementation of InetSocketAddress\n+ *          to trigger race conditions\n+ * @compile\/module=java.base java\/net\/InetSocketAddress.java\n+ * @run junit\/othervm DeferredCloseTest\n+ *\/\n+public class DeferredCloseTest {\n+\n+    private static final int NUM_ITERATIONS = 10;\n+    private static final InetSocketAddress BIND_ADDR = new InetSocketAddress(\n+            InetAddress.getLoopbackAddress(), 0);\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+        \/\/ configure our patched java.net.InetSocketAddress implementation\n+        \/\/ to introduce delay in certain methods which get invoked\n+        \/\/ internally from the DC.send() implementation\n+        InetSocketAddress.enableDelay();\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() throws Exception {\n+        \/\/ delays in patched InetSocketAddress are no longer needed\n+        InetSocketAddress.disableDelay();\n+    }\n+\n+    private static Stream<Arguments> dcOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.send() till there's a ClosedChannelException\n+                        \"DC.send()\",\n+                        null,\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                \/\/ We send to ourselves. Target, content and\n+                                \/\/ receipt of the Datagram isn't of importance\n+                                \/\/ in this test.\n+                                SocketAddress target = dc.getLocalAddress();\n+                                System.out.println(\"DC: \" + dc + \" sending to \" + target);\n+                                while (true) {\n+                                    bb.clear();\n+                                    dc.send(bb, target);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.receive() till there's a ClosedChannelException\n+                        \"DC.receive()\",\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                SocketAddress target = dc.getLocalAddress();\n+                                ByteBuffer sendBB = ByteBuffer.allocate(100);\n+                                \/\/ first send() a few datagrams so that subsequent\n+                                \/\/ receive() does receive them and thus triggers\n+                                \/\/ the potential race with the deferred close\n+                                for (int i = 0; i < 5; i++) {\n+                                    sendBB.clear();\n+                                    dc.send(sendBB, target);\n+                                }\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        },\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                ByteBuffer rcvBB = ByteBuffer.allocate(10);\n+                                while (true) {\n+                                    rcvBB.clear();\n+                                    dc.receive(rcvBB);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for DatagramChannel.\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"dcOperations\")\n+    public void testDatagramChannel(String opName, Function<DatagramChannel, Void> preOp,\n+                                    Function<DatagramChannel, Void> dcOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s DatagramChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     DatagramChannel dc = DatagramChannel.open()) {\n+                    \/\/ create a non-blocking bound DatagramChannel\n+                    dc.bind(BIND_ADDR);\n+                    dc.configureBlocking(false);\n+                    \/\/ register the DatagramChannel with a selector\n+                    \/\/ (doesn't matter the interestOps)\n+                    SelectionKey key = dc.register(sel, SelectionKey.OP_READ);\n+                    if (preOp != null) {\n+                        preOp.apply(dc);\n+                    }\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start operation on the DC\n+                        opStartLatch.countDown();\n+                        return dcOperation.apply(dc);\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static Stream<Arguments> scOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        \"SC.write()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" writing\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.write(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        \"SC.read()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" reading\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.read(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for SocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"scOperations\")\n+    public void testSocketChannel(String opName, Function<SocketChannel, Void> scOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(3)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     SocketChannel sc = SocketChannel.open()) {\n+                    \/\/ create and bind a SocketChannel\n+                    sc.bind(BIND_ADDR);\n+                    \/\/ stay in blocking mode till the SocketChannel is connected\n+                    sc.configureBlocking(true);\n+                    Future<SocketChannel> acceptedChannel;\n+                    SocketChannel conn;\n+                    \/\/ create a remote server and connect to it\n+                    try (ServerSocketChannel server = ServerSocketChannel.open()) {\n+                        server.bind(BIND_ADDR);\n+                        SocketAddress remoteAddr = server.getLocalAddress();\n+                        acceptedChannel = executor.submit(new ConnAcceptor(server));\n+                        System.out.println(\"connecting to \" + remoteAddr);\n+                        sc.connect(remoteAddr);\n+                        conn = acceptedChannel.get();\n+                    }\n+                    try (conn) {\n+                        \/\/ switch to non-blocking\n+                        sc.configureBlocking(false);\n+                        System.out.println(\"switched to non-blocking: \" + sc);\n+                        \/\/ register the SocketChannel with a selector\n+                        \/\/ (doesn't matter the interestOps)\n+                        SelectionKey key = sc.register(sel, SelectionKey.OP_READ);\n+                        CountDownLatch opStartLatch = new CountDownLatch(1);\n+                        runTest(executor, key, () -> {\n+                            \/\/ notify that we will now start operation on the SC\n+                            opStartLatch.countDown();\n+                            return scOperation.apply(sc);\n+                        }, opStartLatch);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for ServerSocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testServerSocketChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s ServerSocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                    \/\/ create and bind a ServerSocketChannel\n+                    ssc.bind(BIND_ADDR);\n+                    ssc.configureBlocking(false);\n+                    \/\/ register the ServerSocketChannel with a selector\n+                    SelectionKey key = ssc.register(sel, SelectionKey.OP_ACCEPT);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start accept()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SSC.accept() till there's a ClosedChannelException\n+                        try {\n+                            while (true) {\n+                                ssc.accept();\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SinkChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSinkChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SinkChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SinkChannel sink = pipe.sink()) {\n+                    sink.configureBlocking(false);\n+                    SelectionKey key = sink.register(sel, SelectionKey.OP_WRITE);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start write()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                sink.write(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SourceChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSourceChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SourceChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SourceChannel source = pipe.source()) {\n+                    source.configureBlocking(false);\n+                    SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start read()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                source.read(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * SelectableChannel implementations internally have a deferred close implementation. When a\n+     * channel is registered with a Selector and close() is invoked on the channel from a certain\n+     * thread, then the implementation of close() defers the actual close if the channel has\n+     * in-progress operations (for example, read\/write\/send\/receive and such) in some other thread.\n+     * A subsequent operation through the Selector (like Selector.select()) then completes the\n+     * deferred close (waiting for any in-progress operations to complete). This test method\n+     * verifies that the deferred close implementation doesn't prematurely close and release\n+     * the resources used by the channel, while there are in-progress operations.\n+     * <p>\n+     * Launches 2 threads, T1 and T2. When T1 and T2 are in progress, this method closes the\n+     * channel that is registered with the Selector.\n+     * T1 is running the channelOperation (which keeps running operations on the channel).\n+     * T2 is running a task which keeps invoking Selector.select(), until the channel is closed.\n+     * When T2 notices that the channel is closed, it cancels the selectionKey and then\n+     * invokes one last Selector.select() operation to finish the deferred close of the channel.\n+     *\/\n+    private static void runTest(ExecutorService executor, SelectionKey selectionKey,\n+                                Callable<Void> channelOperation, CountDownLatch chanOpStartLatch)\n+            throws Exception {\n+\n+        SelectableChannel channel = selectionKey.channel();\n+        assertFalse(channel.isBlocking(), \"channel isn't non-blocking: \" + channel);\n+        selectionKey.selector().selectNow();\n+        \/\/ run the channel operations\n+        Future<?> channelOpResult = executor.submit(channelOperation);\n+        CountDownLatch selectorTaskStartLatch = new CountDownLatch(1);\n+        \/\/ run the Selector.select() task\n+        Future<?> selectorTaskResult = executor.submit(\n+                new SelectorTask(selectionKey, selectorTaskStartLatch));\n+        \/\/ await for the channel operation task and the selector task to start\n+        chanOpStartLatch.await();\n+        selectorTaskStartLatch.await();\n+        \/\/ close the channel while it's still registered with the Selector,\n+        \/\/ so that the close is deferred by the channel implementations.\n+        System.out.println(\"closing channel: \" + channel);\n+        assertTrue(channel.isOpen(), \"channel already closed: \" + channel);\n+        assertTrue(channel.isRegistered(), \"channel isn't registered: \" + channel);\n+        channel.close();\n+        \/\/ wait for the operation on the channel and the selector task to complete\n+        channelOpResult.get();\n+        selectorTaskResult.get();\n+    }\n+\n+    \/*\n+     * Keeps invoking Selector.select() until the channel is closed, after which\n+     * it cancels the SelectionKey and does one last Selector.select() to finish\n+     * the deferred close.\n+     *\/\n+    private static final class SelectorTask implements Callable<Void> {\n+        private final SelectionKey selectionKey;\n+        private final CountDownLatch startedLatch;\n+\n+        private SelectorTask(SelectionKey selectionKey, CountDownLatch startedLatch) {\n+            this.selectionKey = Objects.requireNonNull(selectionKey);\n+            this.startedLatch = startedLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            try {\n+                Selector selector = selectionKey.selector();\n+                SelectableChannel channel = selectionKey.channel();\n+                \/\/ notify that the task has started\n+                startedLatch.countDown();\n+                while (true) {\n+                    selector.select(10);\n+                    if (!channel.isOpen()) {\n+                        \/\/ the channel is (defer) closed, cancel the registration and then\n+                        \/\/ issue a select() so that the Selector finishes the deferred\n+                        \/\/ close of the channel.\n+                        System.out.println(\"channel: \" + channel + \" isn't open,\" +\n+                                \" now cancelling key: \" + selectionKey);\n+                        selectionKey.cancel();\n+                        System.out.println(\"initiating select after key cancelled: \" + selectionKey);\n+                        selector.select(5);\n+                        break;\n+                    }\n+                }\n+            } catch (ClosedSelectorException _) {\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class ConnAcceptor implements Callable<SocketChannel> {\n+        private final ServerSocketChannel serverSocketChannel;\n+\n+        private ConnAcceptor(ServerSocketChannel serverSocketChannel) {\n+            this.serverSocketChannel = serverSocketChannel;\n+        }\n+\n+        @Override\n+        public SocketChannel call() throws Exception {\n+            SocketChannel accepted = serverSocketChannel.accept();\n+            System.out.println(\"Accepted connection: \" + accepted);\n+            return accepted;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/DeferredCloseTest.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.net;\n+\n+\n+import java.util.Locale;\n+\n+\/\/ Patched implementation only meant to be used in certain tests\n+public class InetSocketAddress extends SocketAddress {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 5076001401234631237L;\n+\n+    private static boolean enableDelay;\n+\n+    static {\n+        System.out.println(\"patched InetSocketAddress class in use\");\n+    }\n+\n+    private final String hostname;\n+    private final InetAddress addr;\n+    private final int port;\n+\n+    public InetSocketAddress(int port) {\n+        this(InetAddress.anyLocalAddress(), port);\n+    }\n+\n+    public InetSocketAddress(InetAddress addr, int port) {\n+        this(null,\n+                addr == null ? InetAddress.anyLocalAddress() : addr,\n+                checkPort(port));\n+    }\n+\n+    public InetSocketAddress(String hostname, int port) {\n+        checkHost(hostname);\n+        InetAddress addr = null;\n+        String host = null;\n+        try {\n+            addr = InetAddress.getByName(hostname);\n+        } catch (UnknownHostException e) {\n+            host = hostname;\n+        }\n+        this.hostname = host;\n+        this.addr = addr;\n+        this.port = checkPort(port);\n+    }\n+\n+    public static InetSocketAddress createUnresolved(String host, int port) {\n+        return new InetSocketAddress(checkHost(host), null, checkPort(port));\n+    }\n+\n+    public static void enableDelay() {\n+        enableDelay = true;\n+    }\n+\n+    public static void disableDelay() {\n+        enableDelay = false;\n+    }\n+\n+    private InetSocketAddress(String hostname, InetAddress addr, int port) {\n+        this.hostname = hostname;\n+        this.addr = addr;\n+        this.port = port;\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the port number.\n+     *\n+     * @return the port number.\n+     *\/\n+    public final int getPort() {\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+        return this.port;\n+    }\n+\n+    \/**\n+     * Gets the {@code InetAddress}.\n+     *\n+     * @return the InetAddress or {@code null} if it is unresolved.\n+     *\/\n+    public final InetAddress getAddress() {\n+        return this.addr;\n+    }\n+\n+    public final String getHostName() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            return addr.getHostName();\n+        }\n+        return null;\n+    }\n+\n+    public final String getHostString() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            if (addr.holder().getHostName() != null) {\n+                return addr.holder().getHostName();\n+            } else {\n+                return addr.getHostAddress();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public final boolean isUnresolved() {\n+        return addr == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String formatted;\n+        if (isUnresolved()) {\n+            formatted = hostname + \"\/<unresolved>\";\n+        } else {\n+            formatted = addr.toString();\n+            if (addr instanceof Inet6Address) {\n+                int i = formatted.lastIndexOf(\"\/\");\n+                formatted = formatted.substring(0, i + 1)\n+                        + \"[\" + formatted.substring(i + 1) + \"]\";\n+            }\n+        }\n+        return formatted + \":\" + port;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object other) {\n+        if (!(other instanceof InetSocketAddress that)) {\n+            return false;\n+        }\n+        boolean sameIP;\n+        if (addr != null) {\n+            sameIP = addr.equals(that.addr);\n+        } else if (hostname != null) {\n+            sameIP = (that.addr == null) &&\n+                    hostname.equalsIgnoreCase(that.hostname);\n+        } else {\n+            sameIP = (that.addr == null) && (that.hostname == null);\n+        }\n+        return sameIP && (port == that.port);\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        if (addr != null) {\n+            return addr.hashCode() + port;\n+        }\n+        if (hostname != null) {\n+            return hostname.toLowerCase(Locale.ROOT).hashCode() + port;\n+        }\n+        return port;\n+    }\n+\n+    private static int checkPort(int port) {\n+        if (port < 0 || port > 0xFFFF)\n+            throw new IllegalArgumentException(\"port out of range:\" + port);\n+        return port;\n+    }\n+\n+    private static String checkHost(String hostname) {\n+        if (hostname == null)\n+            throw new IllegalArgumentException(\"hostname can't be null\");\n+        return hostname;\n+    }\n+\n+    private static void doDelay() {\n+        System.out.println(\"intentional delay injected in InetSocketAddress\");\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/java.base\/java\/net\/InetSocketAddress.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -500,0 +500,1 @@\n+        protected final InetAddress bindAddress; \/\/local address to bind to; can be null.\n@@ -512,0 +513,12 @@\n+            this(linger, null);\n+        }\n+\n+        \/**\n+         * Creates a new abstract UDP server.\n+         *\n+         * @param linger the amount of time the server should wait before\n+         *          responding to requests.\n+         * @param bindAddress the address to bind to. If {@code null}, will\n+         *                    bind to InetAddress.getLocalHost();\n+         *\/\n+        protected AbstractUdpServer(long linger, InetAddress bindAddress) {\n@@ -513,0 +526,1 @@\n+            this.bindAddress = bindAddress;\n@@ -577,0 +591,1 @@\n+            InetAddress lh = bindAddress == null ? InetAddress.getLocalHost() : bindAddress;\n@@ -578,1 +593,1 @@\n-                    newDatagramSocket(0, InetAddress.getLocalHost());\n+                    newDatagramSocket(0, lh);\n@@ -762,1 +777,5 @@\n-            super(linger);\n+            this(linger, null);\n+        }\n+\n+        public UdpEchoServer(long linger, InetAddress bindAddress) {\n+            super(linger, bindAddress);\n@@ -798,1 +817,5 @@\n-            final UdpEchoServer echoServer = new UdpEchoServer(linger);\n+            return startNewServer(0, InetAddress.getLocalHost());\n+        }\n+\n+        public static UdpEchoServer startNewServer(long linger, InetAddress bindAddress) throws IOException {\n+            final UdpEchoServer echoServer = new UdpEchoServer(linger, bindAddress);\n","filename":"test\/jdk\/java\/nio\/channels\/TestServers.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-\/* @test\n- * @bug 8011536 8151430 8316304\n+\/* @test id=tmp\n+ * @bug 8011536 8151430 8316304 8334339\n@@ -27,1 +27,1 @@\n- *     that support it.\n+ *     that support it, tests using \/tmp directory.\n@@ -33,0 +33,9 @@\n+\/* @test id=cwd\n+ * @summary Basic test for creationTime attribute on platforms\/file systems\n+ *     that support it, tests using the test scratch directory, the test\n+ *     scratch directory maybe at diff disk partition to \/tmp on linux.\n+ * @library  ..\/.. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main CreationTime .\n+ *\/\n+\n@@ -41,0 +50,1 @@\n+import jtreg.SkippedException;\n@@ -71,2 +81,8 @@\n-            err.println(\"File creation time reported as: \" + creationTime);\n-            throw new RuntimeException(\"Expected to be close to: \" + now);\n+            System.out.println(\"creationTime.toMillis() == \" + creationTime.toMillis());\n+            \/\/ If the file system doesn't support birth time, then skip this test\n+            if (creationTime.toMillis() == 0) {\n+                throw new SkippedException(\"birth time not support for: \" + file);\n+            } else {\n+                err.println(\"File creation time reported as: \" + creationTime);\n+                throw new RuntimeException(\"Expected to be close to: \" + now);\n+            }\n@@ -98,1 +114,1 @@\n-        System.out.println(\"supportsCreationTimeRead == \" + supportsCreationTimeRead);\n+        System.out.println(top + \" supportsCreationTimeRead == \" + supportsCreationTimeRead);\n@@ -130,1 +146,6 @@\n-        Path dir = TestUtil.createTemporaryDirectory();\n+        Path dir;\n+        if (args.length == 0) {\n+            dir = TestUtil.createTemporaryDirectory();\n+        } else {\n+            dir = TestUtil.createTemporaryDirectory(args[0]);\n+        }\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+\/**\n+ * HumanInputStream tries to act like a human sitting in front of a computer\n+ * terminal typing on the keyboard while a program is running.\n+ * <p>\n+ * The program may call InputStream.read() and BufferedReader.readLine() in\n+ * various places. a call to B.readLine() will try to buffer as much input as\n+ * possible. Thus, a trivial InputStream will find it impossible to feed\n+ * anything to I.read() after a B.readLine() call.\n+ * <p>\n+ * This is why HumanInputStream was created, which will only send a single line\n+ * to B.readLine(), no more, no less, and the next I.read() can have a chance\n+ * to read the exact character right after \"\\n\".\n+ *\n+ *\/\n+\n+public class HumanInputStream extends InputStream {\n+    byte[] src;\n+    int pos;\n+    int length;\n+    boolean inLine;\n+    int stopIt;\n+\n+    public HumanInputStream(String input) {\n+        src = input.getBytes();\n+        pos = 0;\n+        length = src.length;\n+        stopIt = 0;\n+        inLine = false;\n+    }\n+\n+    \/\/ the trick: when called through read(byte[], int, int),\n+    \/\/ return -1 twice after \"\\n\"\n+\n+    @Override public int read() throws IOException {\n+        int re;\n+        if(pos < length) {\n+            re = src[pos];\n+            if(inLine) {\n+                if(stopIt > 0) {\n+                    stopIt--;\n+                    re = -1;\n+                } else {\n+                    if(re == '\\n') {\n+                        stopIt = 2;\n+                    }\n+                    pos++;\n+                }\n+            } else {\n+                pos++;\n+            }\n+        } else {\n+            re = -1; \/\/throws new IOException(\"NO MORE TO READ\");\n+        }\n+        return re;\n+    }\n+    @Override public int read(byte[] buffer, int offset, int len) {\n+        inLine = true;\n+        try {\n+            return super.read(buffer, offset, len);\n+        } catch(Exception e) {\n+            throw new RuntimeException(\"HumanInputStream error\");\n+        } finally {\n+            inLine = false;\n+        }\n+    }\n+    @Override public int available() {\n+        if (pos < length) return 1;\n+        return 0;\n+    }\n+\n+    \/\/ test part\n+    static void assertTrue(boolean bool) {\n+        if (!bool)\n+            throw new RuntimeException();\n+    }\n+\n+    public static void test() throws Exception {\n+        class Tester {\n+            HumanInputStream is;\n+            BufferedReader reader;\n+            Tester(String s) {\n+                is = new HumanInputStream(s);\n+                reader = new BufferedReader(new InputStreamReader(is));\n+            }\n+\n+            \/\/ three kinds of test method\n+            \/\/ 1. read byte by byte from InputStream\n+            void testStreamReadOnce(int expection) throws Exception {\n+                assertTrue(is.read() == expection);\n+            }\n+            void testStreamReadMany(String expectation) throws Exception {\n+                char[] keys = expectation.toCharArray();\n+                for (char key : keys) {\n+                    assertTrue(is.read() == key);\n+                }\n+            }\n+            \/\/ 2. read a line with a newly created Reader\n+            void testReaderReadline(String expectation) throws Exception {\n+                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+            \/\/ 3. read a line with the old Reader\n+            void testReaderReadline2(String expectation) throws Exception  {\n+                String s = reader.readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+        }\n+\n+        Tester test;\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline2(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"1\\n2\");\n+        test.testStreamReadMany(\"1\\n2\");\n+        test.testStreamReadOnce(-1);\n+\n+        test = new Tester(\"12\\n234\");\n+        test.testStreamReadOnce('1');\n+        test.testReaderReadline(\"2\");\n+        test.testStreamReadOnce('2');\n+        test.testReaderReadline2(\"34\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"changeit\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(\"Name\");\n+        test.testReaderReadline(\"Country\");\n+        test.testReaderReadline(\"Yes\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"Me\\nHere\\n\");\n+        test.testReaderReadline2(\"Me\");\n+        test.testReaderReadline2(\"Here\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/testlibrary\/HumanInputStream.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4018937 8008577 8174269\n+ * @bug 4018937 8008577 8174269 8333755\n@@ -32,2 +32,6 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.DecimalFormat;\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n@@ -546,1 +550,5 @@\n-         * DecimalFormat.parse() for some cases.\n+         * DecimalFormat.parse() for some cases. This is because parsing integer\n+         * only will return a successful parse for the subformat, but since the index\n+         * returned is not equal to the length, at the MessageFormat level, this\n+         * will be interpreted as a failed parse, and so the DecimalFormat index\n+         * should be reflected as the MessageFormat errorIndex.\n@@ -551,5 +559,3 @@\n-        {2, 0},         \/\/ parsing stopped at '(' because cannot find ')'\n-        {2, 0},         \/\/ parsing stopped at the first numeric\n-                        \/\/ because cannot find '%'\n-        {2, 0},         \/\/ parsing stopped at the first numeric\n-                        \/\/ because cannot find '%'\n+        {30, 0},        \/\/ parsing stopped at '.'\n+        {31, 0},        \/\/ parsing stopped at '.'\n+        {32, 0},        \/\/ parsing stopped at '.'\n@@ -558,1 +564,0 @@\n-\n@@ -561,2 +566,1 @@\n-                        \/\/ because cannot find '%'\n-        {2, 0},         \/\/ parsing stopped at '(' because cannot find ')'\n+        {57, 0},        \/\/ parsing stopped at '.'\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalParse.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485\n+ * @bug 8327640 8331485 8333755\n@@ -37,0 +37,1 @@\n+import org.junit.jupiter.api.BeforeEach;\n@@ -75,11 +76,12 @@\n-\n-\n-    \/\/ All NumberFormats should parse strictly\n-    static {\n-        dFmt.setStrict(true);\n-        pFmt.setStrict(true);\n-        cFmt.setStrict(true);\n-        cmpctFmt.setStrict(true);\n-        \/\/ To effectively test strict compactNumberFormat parsing\n-        cmpctFmt.setParseIntegerOnly(false);\n-        cmpctFmt.setGroupingUsed(true);\n+    private static final NumberFormat[] FORMATS = new NumberFormat[]{dFmt, cFmt, pFmt, cmpctFmt};\n+\n+    \/\/ Restore defaults before runs\n+    @BeforeEach\n+    void beforeEach() {\n+        for (NumberFormat fmt : FORMATS) {\n+            fmt.setStrict(true);\n+            fmt.setParseIntegerOnly(false);\n+            fmt.setGroupingUsed(true);\n+        }\n+        \/\/ Grouping Size is not defined at NumberFormat level\n+        \/\/ Compact needs to manually init grouping size\n@@ -117,0 +119,14 @@\n+\n+    \/\/ 8333755: Check that parsing with integer only against a suffix value works\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void integerOnlyParseWithSuffixTest() {\n+        \/\/ Some pattern with a suffix\n+        DecimalFormat fmt = new DecimalFormat(\"0.00b\");\n+        fmt.setParseIntegerOnly(true);\n+        assertEquals(5d, successParse(fmt, \"5.55b\", 1));\n+        assertEquals(5d, successParse(fmt, \"5b\", 2));\n+        assertEquals(5555d, successParse(fmt, \"5,555.55b\", 5));\n+        assertEquals(5d, successParse(fmt, \"5.55E55b\", 1));\n+    }\n+\n@@ -173,1 +189,0 @@\n-        dFmt.setGroupingUsed(true);\n@@ -176,2 +191,3 @@\n-    \/\/ Exception should be thrown if decimal separator occurs anywhere\n-    \/\/ Don't pass badParseStrings for same reason as previous method.\n+    \/\/ 8333755: Parsing behavior should follow normal strict behavior\n+    \/\/ However the index returned, should be before decimal point\n+    \/\/ and the value parsed equal to the integer portion\n@@ -179,4 +195,2 @@\n-    @MethodSource({\"validParseStrings\", \"integerOnlyParseStrings\"})\n-    public void numFmtStrictIntegerOnlyUsed(String toParse) {\n-        \/\/ When integer only is true, if a decimal separator is found,\n-        \/\/ a failure should occur\n+    @MethodSource(\"validIntegerOnlyParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsedTest(String toParse, Number expVal) {\n@@ -184,3 +198,3 @@\n-        int failIndex = toParse.indexOf(dfs.getDecimalSeparator());\n-        if (failIndex > -1) {\n-            failParse(dFmt, toParse, failIndex);\n+        int expectedIndex = toParse.indexOf(dfs.getDecimalSeparator());\n+        if (expectedIndex > -1) {\n+            assertEquals(successParse(dFmt, toParse, expectedIndex), expVal);\n@@ -188,1 +202,1 @@\n-            successParse(dFmt, toParse);\n+            assertEquals(successParse(dFmt, toParse), expVal);\n@@ -190,1 +204,9 @@\n-        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ 8333755: Parsing behavior should follow normal strict behavior\n+    \/\/ when it comes to failures.\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsedFailTest(String toParse, int expectedErrorIndex) {\n+        dFmt.setParseIntegerOnly(true);\n+        failParse(dFmt, toParse, expectedErrorIndex);\n@@ -273,0 +295,12 @@\n+    @ParameterizedTest\n+    @MethodSource({\"validIntegerOnlyParseStrings\", \"compactValidIntegerOnlyParseStrings\"})\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseIntOnlyTest(String toParse, double expectedValue) {\n+        \/\/ compact does not accept exponents\n+        if (toParse.indexOf('E') > -1) {\n+            return;\n+        }\n+        cmpctFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+    }\n+\n@@ -282,1 +316,7 @@\n-    private double successParse(NumberFormat fmt, String toParse) {\n+    private Number successParse(NumberFormat fmt, String toParse) {\n+        return successParse(fmt, toParse, toParse.length());\n+    }\n+\n+    \/\/ Overloaded method that allows for an expected ParsePosition index value\n+    \/\/ that is not the string length.\n+    private Number successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n@@ -295,1 +335,1 @@\n-        assertEquals(toParse.length(), pp.getIndex(),\n+        assertEquals(expectedIndex, pp.getIndex(),\n@@ -391,1 +431,3 @@\n-                Arguments.of(\"1,234,a\", 5))\n+                Arguments.of(\"1,234,a\", 5),\n+                \/\/ Double decimal\n+                Arguments.of(\"1,234..5\", 5))\n@@ -400,0 +442,2 @@\n+                Arguments.of(\"1,234.55\", 1234.55d),\n+                Arguments.of(\"1,234.5\", 1234.5d),\n@@ -417,4 +461,3 @@\n-    \/\/ Separate test data set for integer only. Can not use \"badParseStrings\", as\n-    \/\/ there is test data where the failure may occur from some other issue,\n-    \/\/ not related to grouping\n-    private static Stream<Arguments> integerOnlyParseStrings() {\n+    \/\/ Separate test data set for integer only.\n+    \/\/ Valid parse strings, that would parse successfully for integer\/non-integer parse\n+    private static Stream<Arguments> validIntegerOnlyParseStrings() {\n@@ -422,6 +465,9 @@\n-                Arguments.of(\"234.a\"),\n-                Arguments.of(\"234.a1\"),\n-                Arguments.of(\"234.1\"),\n-                Arguments.of(\"234.1a\"),\n-                Arguments.of(\"234.\"))\n-                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+                Arguments.of(\"234\", 234d),\n+                Arguments.of(\"234.\", 234d),\n+                Arguments.of(\"234.1\", 234d),\n+                Arguments.of(\"1,234.1\", 1234d),\n+                Arguments.of(\"234.12345\", 234d),\n+                Arguments.of(\"234.543E23\", 234d),\n+                Arguments.of(\"234,000.55E22\", 234000d),\n+                Arguments.of(\"234E22\", 234E22))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n@@ -517,0 +563,6 @@\n+    private static Stream<Arguments> compactValidIntegerOnlyParseStrings() {\n+        return validIntegerOnlyParseStrings().map(args -> Arguments.of(\n+                args.get()[0] + \"K\", (double) args.get()[1] * 1000)\n+        );\n+    }\n+\n@@ -529,1 +581,4 @@\n-            } else if (c == '0') {\n+            } else if (c == 'E') {\n+                sb.append(dfs.getExponentSeparator());\n+            }\n+            else if (c == '0') {\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":93,"deletions":38,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    static final String datafile = \"tablea1.txt\";\n+    static final String datafile = \"ISO4217-list-one.txt\";\n","filename":"test\/jdk\/java\/util\/Currency\/CheckDataVersion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8264792\n+ *      8264792 8334653\n@@ -62,1 +62,1 @@\n-    \/\/ 'tablea1.txt' should be up-to-date before testing\n+    \/\/ 'ISO4217-list-one.txt' should be up-to-date before testing\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-# Amendments up until ISO 4217 AMENDMENT NUMBER 176\n-#   (As of 06 December 2023)\n+# Amendments up until ISO 4217 AMENDMENT NUMBER 177\n+#   (As of 20 June 2024)\n@@ -9,1 +9,1 @@\n-DATAVERSION=176\n+DATAVERSION=177\n@@ -279,1 +279,1 @@\n-ZW\tZWL\t932\t2\n+ZW\tZWG\t924\t2\n","filename":"test\/jdk\/java\/util\/Currency\/ISO4217-list-one.txt","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/util\/Currency\/tablea1.txt","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8208746 8209775 8264792 8274658 8283277 8296239 8321480\n+ *      8208746 8209775 8264792 8274658 8283277 8296239 8321480 8334653\n@@ -63,1 +63,2 @@\n- * based on ISO 4217. The golden-data file (ISO 4217 data) 'tablea1.txt' has the following\n+ * based on ISO 4217. The golden-data file, 'ISO4217-list-one.txt', based on the\n+ * “List one: Currency, fund and precious metal codes” has the following\n@@ -71,1 +72,1 @@\n-            \"test.src\", \".\"), \"tablea1.txt\");\n+            \"test.src\", \".\"), \"ISO4217-list-one.txt\");\n@@ -92,1 +93,1 @@\n-                    + \"YUM-ZMK-ZWD-ZWN-ZWR\";\n+                    + \"YUM-ZMK-ZWD-ZWL-ZWN-ZWR\";\n","filename":"test\/jdk\/java\/util\/Currency\/ValidateISO4217.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      8327631 8332424\n+ *      8327631 8332424 8334418\n@@ -30,1 +30,1 @@\n- *          (LSR Revision: 2024-05-16) with Locale and Locale.LanguageRange\n+ *          (LSR Revision: 2024-06-14) with Locale and Locale.LanguageRange\n","filename":"test\/jdk\/java\/util\/Locale\/LanguageSubtagRegistryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4354216 8213127\n+ * @bug 4354216 8213127 8334333\n@@ -35,0 +35,1 @@\n+ *        jdk.test.lib.Platform\n@@ -53,0 +54,2 @@\n+import jdk.test.lib.Platform;\n+import jtreg.SkippedException;\n@@ -56,0 +59,3 @@\n+        if (Platform.isRoot() && !Platform.isWindows()) {\n+            throw new SkippedException(\"Unable to create an unreadable properties file.\");\n+        }\n@@ -101,1 +107,1 @@\n-        if(path.toFile().exists()) {\n+        if (path.toFile().exists()) {\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/MissingResourceCauseTestRun.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-                    throw new RuntimeException();\n+                    throw new RuntimeException(\"Execution time limit exceeded!\");\n@@ -269,1 +269,1 @@\n-                            throw new RuntimeException();\n+                            throw new RuntimeException(\"Execution time limit exceeded!\");\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/WhileOpStatefulTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @comment Running with -Xcomp is likely to cause a timeout from ServerCommunicatorAdmin\n+ *          before addNotificationListener can complete.\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotifReconnectDeadlockTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,6 +43,12 @@\n-        if (server.getSession(client1).getSessionContext() == null) {\n-            for (Exception e : server.getExceptionList()) {\n-                System.out.println(\"Looking at \" + e.getClass() + \" \" +\n-                    e.getMessage());\n-                if (e.getMessage().contains(args[0])) {\n-                    System.out.println(\"Found correct exception: \" + args[0] +\n+\n+        server.getSession(client1).getSessionContext();\n+        server.done();\n+\n+        var eList = server.getExceptionList();\n+        System.out.println(\"Exception list size is \" + eList.size());\n+\n+        for (Exception e : eList) {\n+            System.out.println(\"Looking at \" + e.getClass() + \" \" +\n+                e.getMessage());\n+            if (e.getMessage().contains(args[0])) {\n+                System.out.println(\"Found correct exception: \" + args[0] +\n@@ -50,4 +56,3 @@\n-                    return;\n-                } else {\n-                    System.out.println(\"No \\\"\" + args[0] + \"\\\" found.\");\n-                }\n+                return;\n+            } else {\n+                System.out.println(\"No \\\"\" + args[0] + \"\\\" found.\");\n@@ -55,2 +60,0 @@\n-\n-            throw new Exception(\"Failed to find expected alert: \" + args[0]);\n@@ -58,0 +61,2 @@\n+\n+        throw new Exception(\"Failed to find expected alert: \" + args[0]);\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile);\n+            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+                \"\/\" + pathToStores + \"\/\" + keyStoreFile);\n@@ -116,2 +116,2 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile);\n+            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+                \"\/\" + pathToStores + \"\/\" + trustStoreFile);\n@@ -151,1 +151,0 @@\n-        boolean exit = false;\n@@ -160,1 +159,2 @@\n-                sslContext.init(TLSBase.getKeyManager(builder.km), TLSBase.getTrustManager(builder.tm), null);\n+                sslContext.init(TLSBase.getKeyManager(builder.km),\n+                    TLSBase.getTrustManager(builder.tm), null);\n@@ -166,1 +166,1 @@\n-                System.err.println(e.getMessage());\n+                System.err.println(\"Failure during server initialization\");\n@@ -181,0 +181,1 @@\n+                            System.out.println(\"Caught \" + e.getMessage());\n@@ -206,1 +207,2 @@\n-                sslContext.init(TLSBase.getKeyManager(km), TLSBase.getTrustManager(tm), null);\n+                sslContext.init(TLSBase.getKeyManager(km),\n+                    TLSBase.getTrustManager(tm), null);\n@@ -212,1 +214,1 @@\n-                System.err.println(e.getMessage());\n+                System.err.println(\"Failure during server initialization\");\n@@ -227,0 +229,1 @@\n+                                System.out.println(\"Caught \" + e.getMessage());\n@@ -228,0 +231,1 @@\n+                                exceptionList.add(e);\n@@ -242,1 +246,1 @@\n-                t.interrupt();\n+                t.join(5000);\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Point;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.JToggleButton;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+import javax.swing.UIManager;\n+import javax.swing.table.DefaultTableModel;\n+\n+import java.util.function.Predicate;\n+\n+\/*\n+ * @test\n+ * @bug 6967482\n+ * @key headful\n+ * @summary Test to check if TAB is working on JTable after JFileChooser is\n+ *          closed\n+ * @run main TABTestONFCExit\n+ *\/\n+\n+public class TABTestONFCExit {\n+    private static JTable table;\n+    private static JFileChooser fc;\n+    private static JFrame frame;\n+    private static Robot robot;\n+    private static volatile Point loc;\n+    private static volatile Rectangle rect;\n+    private static volatile int selectedColumnBeforeTabPress;\n+    private static volatile int selectedColumnAfterTabPress;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n+        UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+        try {\n+            SwingUtilities.invokeAndWait(TABTestONFCExit::initialize);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            SwingUtilities.invokeAndWait(TABTestONFCExit::clickDetails);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                loc = table.getLocationOnScreen();\n+                rect = table.getCellRect(0, 0, true);\n+            });\n+\n+            onClick(loc, rect);\n+\n+            SwingUtilities.invokeAndWait(() ->\n+                    selectedColumnBeforeTabPress = table.getSelectedColumn());\n+\n+            robot.keyPress(KeyEvent.VK_TAB);\n+            robot.keyRelease(KeyEvent.VK_TAB);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            SwingUtilities.invokeAndWait(() ->\n+                    selectedColumnAfterTabPress = table.getSelectedColumn());\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            if (selectedColumnAfterTabPress == selectedColumnBeforeTabPress) {\n+                throw new RuntimeException(\"TAB failed to move cell!\");\n+            }\n+            System.out.println(\"Test Passed\" );\n+\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void onClick(Point loc, Rectangle cellRect) {\n+        robot.mouseMove(loc.x + cellRect.x + cellRect.width \/ 2,\n+                loc.y + cellRect.y + cellRect.height \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+        robot.delay(100);\n+    }\n+\n+    private static void initialize() {\n+        frame = new JFrame(\"Tab Test\");\n+        fc = new JFileChooser();\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        frame.add(getJTable(), BorderLayout.NORTH);\n+        frame.add(fc, BorderLayout.SOUTH);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private static JTable getJTable() {\n+        if (table == null) {\n+            table = new JTable();\n+            table.setModel(new DefaultTableModel(5, 5));\n+        }\n+        return table;\n+    }\n+    private static void clickDetails() {\n+        AbstractButton details = findDetailsButton(fc);\n+        if (details == null) {\n+            throw new Error(\"Couldn't find 'Details' button in JFileChooser\");\n+        }\n+        details.doClick();\n+    }\n+\n+    private static AbstractButton findDetailsButton(final Container container) {\n+        Component result = findComponent(container,\n+                c -> c instanceof JToggleButton button\n+                        && \"Details\".equals(button.getToolTipText()));\n+        return (AbstractButton) result;\n+    }\n+\n+    private static Component findComponent(final Container container,\n+                                           final Predicate<Component> predicate) {\n+        for (Component child : container.getComponents()) {\n+            if (predicate.test(child)) {\n+                return child;\n+            }\n+            if (child instanceof Container cont && cont.getComponentCount() > 0) {\n+                Component result = findComponent(cont, predicate);\n+                if (result != null) {\n+                    return result;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/TABTestONFCExit.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5021949\n+ * @summary  Verifies JSplitPane setEnabled(false) disables one touch expandable clicks\n+ * @run main TestSplitPaneEnableTest\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.event.InputEvent;\n+import javax.swing.JButton;\n+import javax.swing.JSplitPane;\n+import javax.swing.plaf.basic.BasicSplitPaneDivider;\n+import javax.swing.plaf.basic.BasicSplitPaneUI;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class TestSplitPaneEnableTest {\n+    private static JButton leftOneTouchButton;\n+    private static JButton rightOneTouchButton;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            if (laf.getClassName().toLowerCase().contains(\"gtk\")) {\n+                continue;\n+            }\n+            System.out.println(\"Testing LAF : \" + laf.getClassName());\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                setLookAndFeel(laf);\n+                JSplitPane jsp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n+                                                new JButton(\"Left\"), new JButton(\"Right\"));\n+                jsp.setUI(new TestSplitPaneUI());\n+                jsp.setOneTouchExpandable(true);\n+                jsp.setEnabled(false);\n+                if (leftOneTouchButton.isEnabled()) {\n+                    throw new RuntimeException(\"leftButton is enabled for disabled JSplitPane\");\n+                }\n+                if (rightOneTouchButton.isEnabled()) {\n+                    throw new RuntimeException(\"rightButton is enabled for disabled JSplitPane\");\n+                }\n+\n+            });\n+        }\n+    }\n+\n+    static class TestSplitPaneUI extends BasicSplitPaneUI {\n+\n+        public TestSplitPaneUI() {\n+            super();\n+        }\n+\n+        public BasicSplitPaneDivider createDefaultDivider() {\n+            return new TestSplitPaneDivider(this);\n+        }\n+    }\n+\n+    static class TestSplitPaneDivider extends BasicSplitPaneDivider {\n+\n+        public TestSplitPaneDivider(BasicSplitPaneUI ui) {\n+            super(ui);\n+        }\n+\n+        protected JButton createLeftOneTouchButton() {\n+            leftOneTouchButton = super.createLeftOneTouchButton();\n+            return leftOneTouchButton;\n+        }\n+\n+        protected JButton createRightOneTouchButton() {\n+            rightOneTouchButton = super.createRightOneTouchButton();\n+            return rightOneTouchButton;\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JSplitPane\/TestSplitPaneEnableTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-            byte[] newBytes = cc.transform(cm, t);\n+            byte[] newBytes = cc.transformClass(cm, t);\n@@ -82,1 +82,1 @@\n-            byte[] newBytes = cc.transform(cm, t);\n+            byte[] newBytes = cc.transformClass(cm, t);\n@@ -104,1 +104,1 @@\n-        byte[] newBytes = cc.transform(cm, transform);\n+        byte[] newBytes = cc.transformClass(cm, transform);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            cc.verify(cc.transform(clm, (clb, cle) -> {\n+            cc.verify(cc.transformClass(clm, (clb, cle) -> {\n@@ -306,1 +306,1 @@\n-        return ClassFile.of().transform(target,\n+        return ClassFile.of().transformClass(target,\n@@ -337,1 +337,1 @@\n-                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                    .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-        byte[] newBytes = cc.transform(cm, (cb, ce) -> {\n+        byte[] newBytes = cc.transformClass(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/BSMTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        MethodHandles.lookup().defineClass(cc.transform(cm, transform));\n+        MethodHandles.lookup().defineClass(cc.transformClass(cm, transform));\n","filename":"test\/jdk\/jdk\/classfile\/ClassBuildingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-        byte[] newBytes = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(res)).transform(classModel,\n+        byte[] newBytes = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(res)).transformClass(classModel,\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        Files.write(root.resolve(targetClassFile), cc.transform(cc.parse(root.resolve(sourceClassFile)), ClassTransform.transformingMethodBodies((cob, coe) -> {\n+        Files.write(root.resolve(targetClassFile), cc.transformClass(cc.parse(root.resolve(sourceClassFile)), ClassTransform.transformingMethodBodies((cob, coe) -> {\n@@ -120,1 +120,1 @@\n-                Files.walk(JRT.getPath(\"modules\/java.base\/java\")),\n+                Files.walk(JRT.getPath(\"modules\/java.base\/java\/util\")),\n@@ -143,0 +143,1 @@\n+                || m == Transforms.NoOpTransform.CLASS_REMAPPER\n@@ -149,1 +150,1 @@\n-                                                .transform(ClassFile.of().parse(bytes), m.classTransform)\n+                                                .transformClass(ClassFile.of().parse(bytes), m.classTransform)\n@@ -193,1 +194,0 @@\n-    }\n@@ -195,4 +195,1 @@\n-    @ParameterizedTest\n-    @MethodSource(\"corpus\")\n-    void testReadAndTransform(Path path) throws IOException {\n-        byte[] bytes = Files.readAllBytes(path);\n+        \/\/ test read and transform\n@@ -216,1 +213,1 @@\n-                                      .transform(newModel,\n+                                      .transformClass(newModel,\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        bytes = cc.transform(cc.parse(bytes), ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+        bytes = cc.transformClass(cc.parse(bytes), ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n@@ -87,1 +87,1 @@\n-        cc.transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+        cc.transformClass(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n@@ -92,1 +92,1 @@\n-                cc.transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                cc.transformClass(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n@@ -98,1 +98,1 @@\n-                         .transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)));\n+                         .transformClass(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)));\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-        byte[] newClass = cc.transform(c, Transforms.threeLevelNoop);\n+        byte[] newClass = cc.transformClass(c, Transforms.threeLevelNoop);\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyCodeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-                cc.transform(cm, (cb, e) -> {\n+                cc.transformClass(cm, (cb, e) -> {\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyPrimitiveMatchCodeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNSTABLE_ATRIBUTES).transform(\n+                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNSTABLE_ATRIBUTES).transformClass(\n@@ -111,1 +111,1 @@\n-                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNKNOWN_ATTRIBUTES).transform(\n+                ClassFile.of(ClassFile.AttributesProcessingOption.DROP_UNKNOWN_ATTRIBUTES).transformClass(\n","filename":"test\/jdk\/jdk\/classfile\/OptionsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -148,1 +148,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -157,1 +157,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n@@ -166,1 +166,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n@@ -175,1 +175,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -184,1 +184,1 @@\n-                    CC_Fixed_Jumps.transform(\n+                    CC_Fixed_Jumps.transformClass(\n@@ -193,1 +193,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n@@ -202,1 +202,1 @@\n-                     CC_Not_Fixed_Jumps.transform(\n+                     CC_Not_Fixed_Jumps.transformClass(\n","filename":"test\/jdk\/jdk\/classfile\/ShortJumpsFixTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222 8320618\n+ * @bug 8305990 8320222 8320618 8335475\n@@ -39,0 +39,4 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -224,1 +228,1 @@\n-        var version49 = cc.parse(cc.transform(\n+        var version49 = cc.parse(cc.transformClass(\n@@ -232,1 +236,1 @@\n-         assertEmpty(cc.verify(cc.transform(\n+         assertEmpty(cc.verify(cc.transformClass(\n@@ -241,1 +245,1 @@\n-                -> clb.withMethodBody(\"test\", ConstantDescs.MTD_void, 0, cob\n+                -> clb.withMethodBody(\"test\", MTD_void, 0, cob\n@@ -315,0 +319,24 @@\n+\n+    @ParameterizedTest\n+    @EnumSource(ClassFile.StackMapsOption.class)\n+    void testEmptyCounters(ClassFile.StackMapsOption option) {\n+        var cf = ClassFile.of(option);\n+        var bytes = cf.build(ClassDesc.of(\"Test\"), clb -> clb\n+            .withMethodBody(\"a\", MTD_void, ACC_STATIC, CodeBuilder::return_)\n+            .withMethodBody(\"b\", MTD_void, 0, CodeBuilder::return_)\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        for (var method : cm.methods()) {\n+            var name = method.methodName();\n+            var code = method.code().orElseThrow();\n+            if (name.equalsString(\"a\")) {\n+                assertEquals(0, code.maxLocals()); \/\/ static method\n+                assertEquals(0, code.maxStack());\n+            } else {\n+                assertTrue(name.equalsString(\"b\"));\n+                assertEquals(1, code.maxLocals()); \/\/ instance method\n+                assertEquals(0, code.maxStack());\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n+        ClassModel newModel = cc.parse(cc.transformClass(cm, xform));\n@@ -77,1 +77,1 @@\n-        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n+        ClassModel newModel = cc.parse(cc.transformClass(cm, xform));\n@@ -95,1 +95,1 @@\n-        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n+        ClassModel newModel = cc.parse(cc.transformClass(cm, xform));\n","filename":"test\/jdk\/jdk\/classfile\/TestRecordComponent.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8336010\n@@ -29,0 +30,12 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.FieldTransform;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -42,0 +55,3 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+\n@@ -44,0 +60,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -100,2 +118,2 @@\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2foo))), \"foo\");\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar))), \"bar\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2foo))), \"foo\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar))), \"bar\");\n@@ -113,1 +131,1 @@\n-        assertEquals(invoke(cc.transform(cm, transform)), \"baz\");\n+        assertEquals(invoke(cc.transformClass(cm, transform)), \"baz\");\n@@ -124,3 +142,148 @@\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n-        assertEquals(invoke(cc.transform(cm, transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n+        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n+    }\n+\n+    \/**\n+     * Test to ensure class elements, such as field and\n+     * methods defined with transform\/with, are visible\n+     * to next transforms.\n+     *\/\n+    @Test\n+    void testClassChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+        var otherCm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethodBody(\"baz\", MTD_void, ACC_STATIC, CodeBuilder::return_)\n+            .withField(\"baz\", CD_long, ACC_STATIC)));\n+\n+        var methodBaz = otherCm.methods().getFirst();\n+        var fieldBaz = otherCm.fields().getFirst();\n+\n+        ClassTransform transform1 = ClassTransform.endHandler(cb -> {\n+            ClassBuilder ret;\n+            ret = cb.withMethodBody(\"bar\", MTD_void, ACC_STATIC, CodeBuilder::return_);\n+            assertSame(cb, ret);\n+            ret = cb.transformMethod(methodBaz, MethodTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+            ret = cb.withField(\"bar\", CD_int, ACC_STATIC);\n+            assertSame(cb, ret);\n+            ret = cb.transformField(fieldBaz, FieldTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+        });\n+\n+        Set<String> methodNames = new HashSet<>();\n+        Set<String> fieldNames = new HashSet<>();\n+        ClassTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof MethodModel mm) {\n+                methodNames.add(mm.methodName().stringValue());\n+            }\n+            if (ce instanceof FieldModel fm) {\n+                fieldNames.add(fm.fieldName().stringValue());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transformClass(cm, transform1.andThen(transform2));\n+\n+        assertEquals(Set.of(INIT_NAME, \"foo\", \"bar\", \"baz\"), methodNames);\n+        assertEquals(Set.of(\"bar\", \"baz\"), fieldNames);\n+    }\n+\n+    \/**\n+     * Test to ensure method elements, such as generated\n+     * or transformed code, are visible to transforms.\n+     *\/\n+    @Test\n+    void testMethodChaining() throws Exception {\n+        var mtd = MethodTypeDesc.of(CD_String);\n+\n+        var cf = ClassFile.of();\n+\n+        \/\/ withCode\n+        var cm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethod(\"baz\", mtd, ACC_STATIC | ACC_NATIVE, _ -> {})));\n+\n+        MethodTransform transform1 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.withCode(cob -> cob.loadConstant(\"foo\").areturn());\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawWithCode = { false };\n+        MethodTransform transform2 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawWithCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(transform1.andThen(transform2)));\n+\n+        assertTrue(sawWithCode[0], \"Code attribute generated not visible\");\n+\n+        \/\/ transformCode\n+        var outerCm = cf.parse(testClassPath);\n+        var foo = outerCm.methods().stream()\n+            .filter(m -> m.flags().has(AccessFlag.STATIC))\n+            .findFirst().orElseThrow();\n+\n+        MethodTransform transform3 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.transformCode(foo.code().orElseThrow(), CodeTransform.ACCEPT_ALL);\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawTransformCode = { false };\n+        MethodTransform transform4 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawTransformCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(transform3.andThen(transform4)));\n+\n+        assertTrue(sawTransformCode[0], \"Code attribute transformed not visible\");\n+    }\n+\n+    \/**\n+     * Test to ensure code elements, such as code block\n+     * begin and end labels, are visible to transforms.\n+     *\/\n+    @Test\n+    void testCodeChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+\n+        CodeTransform transform1 = new CodeTransform() {\n+            @Override\n+            public void atStart(CodeBuilder builder) {\n+                builder.block(bcb -> {\n+                    bcb.loadConstant(9876L);\n+                    bcb.goto_(bcb.endLabel());\n+                });\n+            }\n+\n+            @Override\n+            public void accept(CodeBuilder builder, CodeElement element) {\n+                builder.with(element);\n+            }\n+        };\n+        Set<Label> leaveLabels = new HashSet<>();\n+        Set<Label> targetedLabels = new HashSet<>();\n+        CodeTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof BranchInstruction bi) {\n+                leaveLabels.add(bi.target());\n+            }\n+            if (ce instanceof LabelTarget lt) {\n+                targetedLabels.add(lt.label());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(MethodTransform\n+            .transformingCode(transform1.andThen(transform2))));\n+\n+        leaveLabels.removeIf(targetedLabels::contains);\n+        assertTrue(leaveLabels.isEmpty(), () -> \"Some labels are not bounded: \" + leaveLabels);\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":170,"deletions":7,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        byte[] brokenClassBytes = cc.transform(classModel,\n+        byte[] brokenClassBytes = cc.transformClass(classModel,\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-        return ClassFile.of().transform(m, ClassTransform.endHandler(cb -> cb.with(RuntimeVisibleAnnotationsAttribute.of(annos))));\n+        return ClassFile.of().transformClass(m, ClassTransform.endHandler(cb -> cb.with(RuntimeVisibleAnnotationsAttribute.of(annos))));\n@@ -78,1 +78,1 @@\n-                    m2 = cc.parse(cc.transform(m, SWAP_ANNO_TRANSFORM));\n+                    m2 = cc.parse(cc.transformClass(m, SWAP_ANNO_TRANSFORM));\n@@ -122,1 +122,1 @@\n-                    m2 = cc.parse(cc.transform(m, (cb, ce) -> {\n+                    m2 = cc.parse(cc.transformClass(m, (cb, ce) -> {\n@@ -148,1 +148,1 @@\n-        return ClassFile.of().transform(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n+        return ClassFile.of().transformClass(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n@@ -175,1 +175,1 @@\n-        return ClassFile.of().transform(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n+        return ClassFile.of().transformClass(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/AnnotationsExamples.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -74,1 +74,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -83,1 +83,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -92,1 +92,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withSuperclass(superclass)));\n+        return ClassFile.of().transformClass(cm, ClassTransform.endHandler(cb -> cb.withSuperclass(superclass)));\n@@ -96,1 +96,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -107,1 +107,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n+        return ClassFile.of().transformClass(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n@@ -136,1 +136,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n+        return ClassFile.of().transformClass(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n@@ -163,1 +163,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute));\n+        return ClassFile.of().transformClass(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute));\n@@ -167,1 +167,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n@@ -179,1 +179,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute)\n+        return ClassFile.of().transformClass(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute)\n@@ -190,1 +190,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.dropping(e -> e instanceof FieldModel fm\n+        return ClassFile.of().transformClass(cm, ClassTransform.dropping(e -> e instanceof FieldModel fm\n@@ -195,1 +195,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withField(\"cool\", ClassDesc.ofDescriptor(\"(I)D\"), ClassFile.ACC_PUBLIC)));\n+        return ClassFile.of().transformClass(cm, ClassTransform.endHandler(cb -> cb.withField(\"cool\", ClassDesc.ofDescriptor(\"(I)D\"), ClassFile.ACC_PUBLIC)));\n@@ -199,1 +199,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingFields((fb, fe) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingFields((fb, fe) -> {\n@@ -208,1 +208,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingFields((fb, fe) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingFields((fb, fe) -> {\n@@ -217,1 +217,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethods(\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethods(\n@@ -261,1 +261,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethodBodies(transform));\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethodBodies(transform));\n@@ -265,1 +265,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n@@ -277,1 +277,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+        return ClassFile.of().transformClass(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-        return ClassFile.of().transform(cm, (cb, ce) -> {\n+        return ClassFile.of().transformClass(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExperimentalTransformExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-        return ClassFile.of().transform(cm, ClassTransform.ACCEPT_ALL);\n+        return ClassFile.of().transformClass(cm, ClassTransform.ACCEPT_ALL);\n@@ -45,1 +45,1 @@\n-        return ClassFile.of().transform(cm, (b, e) -> {\n+        return ClassFile.of().transformClass(cm, (b, e) -> {\n@@ -52,1 +52,1 @@\n-        return ClassFile.of().transform(cm, (b, e) ->\n+        return ClassFile.of().transformClass(cm, (b, e) ->\n@@ -60,1 +60,1 @@\n-        return ClassFile.of().transform(cm, (b, e) -> {\n+        return ClassFile.of().transformClass(cm, (b, e) -> {\n@@ -67,1 +67,1 @@\n-        return ClassFile.of().transform(cm, (b, e) -> {\n+        return ClassFile.of().transformClass(cm, (b, e) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/TransformExamples.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -261,2 +261,2 @@\n-                        case IFNONNULL -> cob.if_nonnull(target);\n-                        case IFNULL -> cob.if_null(target);\n+                        case IFNONNULL -> cob.ifnonnull(target);\n+                        case IFNULL -> cob.ifnull(target);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-            this.transform = bytes -> cc.transform(cc.parse(bytes), classTransform);\n+            this.transform = bytes -> cc.transformClass(cc.parse(bytes), classTransform);\n@@ -215,1 +215,1 @@\n-            return cc.transform(cm, (cb, ce) -> {\n+            return cc.transformClass(cm, (cb, ce) -> {\n@@ -256,1 +256,1 @@\n-            return cc.transform(cm, new ClassTransform() {\n+            return cc.transformClass(cm, new ClassTransform() {\n@@ -294,1 +294,1 @@\n-            return cc.transform(cm, (builder, element) -> {\n+            return cc.transformClass(cm, (builder, element) -> {\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @requires (os.family == \"linux\" & !vm.musl)\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build TestSystemSettings\n+ * @run main\/othervm TestSystemSettings\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSystemSettings {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XshowSettings:system\", \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"System not containerized.\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestSystemSettings.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -146,17 +147,27 @@\n-        CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n-\n-        try (Recording r = new Recording()) {\n-            r.start();\n-            List<Emitter> emitters = new ArrayList<>();\n-            for (int i = 0; i < THREAD_COUNT; i++) {\n-                Emitter e = new Emitter(barrier);\n-                e.start();\n-                emitters.add(e);\n-            }\n-            \/\/ Thread buffers should now have one event each\n-            barrier.await();\n-            \/\/ Add another event to each thread buffer, so\n-            \/\/ events are bound to come out of order when they\n-            \/\/ are flushed\n-            for (Emitter e : emitters) {\n-                e.join();\n+        while (true) {\n+            CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n+            try (Recording r = new Recording()) {\n+                r.start();\n+                List<Emitter> emitters = new ArrayList<>();\n+                for (int i = 0; i < THREAD_COUNT; i++) {\n+                    Emitter e = new Emitter(barrier);\n+                    e.start();\n+                    emitters.add(e);\n+                }\n+                \/\/ Thread buffers should now have one event each\n+                barrier.await();\n+                \/\/ Add another event to each thread buffer, so\n+                \/\/ events are bound to come out of order when they\n+                \/\/ are flushed\n+                for (Emitter e : emitters) {\n+                    e.join();\n+                }\n+                r.stop();\n+                Path p = Utils.createTempFile(\"recording\", \".jfr\");\n+                r.dump(p);\n+                \/\/ Order is only guaranteed within a segment.\n+                int segments = countSegments(p);\n+                if (segments < 2) {\n+                    return p;\n+                }\n+                System.out.println(\"File contains more than one segment (\" + segments + \"). Retrying.\");\n@@ -164,4 +175,9 @@\n-            r.stop();\n-            Path p = Utils.createTempFile(\"recording\", \".jfr\");\n-            r.dump(p);\n-            return p;\n+        }\n+    }\n+\n+    private static int countSegments(Path file) throws Exception {\n+        AtomicInteger segments = new AtomicInteger();\n+        try (EventStream es = EventStream.openFile(file)) {\n+            es.onFlush(segments::incrementAndGet);\n+            es.start();\n+            return segments.get();\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestOrdered.java","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @build jdk.jfr.api.consumer.streaming.TestProcess\n@@ -43,0 +44,16 @@\n+        while (true) {\n+            try {\n+                testExit();\n+                return;\n+            } catch (RuntimeException e) {\n+                String message = String.valueOf(e.getMessage());\n+                \/\/ If the test application crashes during startup, retry.\n+                if (!message.contains(\"is no longer alive\")) {\n+                    throw e;\n+                }\n+                System.out.println(\"Application not alive when trying to get repository. Retrying.\");\n+            }\n+        }\n+    }\n+\n+    private static void testExit() throws Exception {\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestJVMExit.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-        return cf.transform(cf.parse(bytes), (clb, ce) -> {\n+        return cf.transformClass(cf.parse(bytes), (clb, ce) -> {\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestInstrumentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                result = cf.transform(cf.parse(bytes), (clb, ce) -> {\n+                result = cf.transformClass(cf.parse(bytes), (clb, ce) -> {\n","filename":"test\/jdk\/jdk\/jfr\/javaagent\/TestEventInstrumentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.Name;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test TestHiddenWait\n+ * @key jfr\n+ * @summary Checks that JFR code don't emit noise in the form of ThreadSleep and JavaMonitorWait events.\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestHiddenWait\n+ *\/\n+public class TestHiddenWait {\n+    static final String PERIODIC_EVENT_NAME = \"test.Periodic\";\n+\n+    @Name(PERIODIC_EVENT_NAME)\n+    public static class PeriodicEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        FlightRecorder.addPeriodicEvent(PeriodicEvent.class,  () -> {\n+            PeriodicEvent event = new PeriodicEvent();\n+            event.commit();\n+        });\n+        try (Recording r = new Recording()) {\n+            AtomicLong counter = new AtomicLong();\n+            r.enable(\"jdk.ThreadSleep\").withoutThreshold();\n+            r.enable(\"jdk.JavaMonitorWait\").withoutThreshold();\n+            r.enable(PERIODIC_EVENT_NAME).withPeriod(Duration.ofMillis(100));\n+            r.start();\n+            \/\/ Triggers Object.wait() in stream barrier\n+            try (RecordingStream b = new RecordingStream()) {\n+                b.startAsync();\n+                b.stop();\n+            }\n+            \/\/ Wait for for periodic events\n+            try (RecordingStream s = new RecordingStream()) {\n+                s.onEvent(PERIODIC_EVENT_NAME, e -> {\n+                    if (counter.incrementAndGet() >= 2) {\n+                        s.close();\n+                    }\n+                });\n+                s.start();\n+            }\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (RecordedEvent event : events) {\n+                if (!event.getEventType().getName().equals(PERIODIC_EVENT_NAME)) {\n+                    System.out.println(event);\n+                    throw new Exception(\"Didn't expect ThreadSleep or JavaMonitorWait events\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestHiddenWait.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run main\/othervm -XX:TLABSize=2k jdk.jfr.jvm.TestWaste\n+ * @run main\/othervm -Xlog:jfr+system+parser=debug -XX:TLABSize=2k jdk.jfr.jvm.TestWaste\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestWaste.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return ClassFile.of().transform(classModel,\n+        return ClassFile.of().transformClass(classModel,\n","filename":"test\/jdk\/jdk\/lambda\/separate\/ClassToInterfaceConverter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n@@ -45,3 +45,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca1 CRL\n@@ -56,3 +56,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca2 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca2 CRL\n@@ -67,3 +67,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca3 CRL\n@@ -78,3 +78,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca4 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca4 CRL\n@@ -89,3 +89,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca CRL\n@@ -100,3 +100,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass3ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass3ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca CRL\n@@ -111,3 +111,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop comodorsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodorsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop comodorsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop comodorsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodorsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop comodorsaca CRL\n@@ -122,3 +122,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop comodoeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodoeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop comodoeccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop comodoeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodoeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop comodoeccca CRL\n@@ -133,3 +133,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop usertrustrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrustrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop usertrustrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop usertrustrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrustrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop usertrustrsaca CRL\n@@ -144,3 +144,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop usertrusteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrusteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop usertrusteccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop usertrusteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrusteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop usertrusteccca CRL\n@@ -155,2 +155,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx1 DEFAULT\n@@ -165,2 +165,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx2 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx2 DEFAULT\n@@ -175,3 +175,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignrootcar6 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignrootcar6 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignrootcar6 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsignrootcar6 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignrootcar6 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsignrootcar6 CRL\n@@ -186,3 +186,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop entrustrootcaec1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcaec1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop entrustrootcaec1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop entrustrootcaec1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcaec1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop entrustrootcaec1 CRL\n@@ -197,3 +197,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop entrustrootcag4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcag4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop entrustrootcag4 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop entrustrootcag4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcag4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop entrustrootcag4 CRL\n@@ -208,3 +208,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop godaddyrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop godaddyrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop godaddyrootg2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop godaddyrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop godaddyrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop godaddyrootg2ca CRL\n@@ -219,3 +219,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop starfieldrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop starfieldrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop starfieldrootg2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop starfieldrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop starfieldrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop starfieldrootg2ca CRL\n@@ -230,2 +230,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigneccrootcar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigneccrootcar4 DEFAULT\n@@ -240,2 +240,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar1 DEFAULT\n@@ -250,2 +250,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar2 DEFAULT\n@@ -260,2 +260,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar3 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar3 DEFAULT\n@@ -270,2 +270,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar4 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 DEFAULT\n@@ -280,3 +280,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop microsoftecc2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftecc2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop microsoftecc2017 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop microsoftecc2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftecc2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop microsoftecc2017 CRL\n@@ -291,3 +291,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop microsoftrsa2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftrsa2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop microsoftrsa2017 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop microsoftrsa2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftrsa2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop microsoftrsa2017 CRL\n@@ -302,3 +302,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca1g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca1g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca1g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca1g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca1g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca1g3 CRL\n@@ -313,3 +313,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca2g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca2g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca2g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca2g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca2g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca2g3 CRL\n@@ -324,3 +324,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca3g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca3g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca3g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca3g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca3g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca3g3 CRL\n@@ -335,3 +335,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop digicerttlseccrootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlseccrootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop digicerttlseccrootg5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop digicerttlseccrootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlseccrootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop digicerttlseccrootg5 CRL\n@@ -346,3 +346,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop digicerttlsrsarootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlsrsarootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop digicerttlsrsarootg5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop digicerttlsrsarootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlsrsarootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop digicerttlsrsarootg5 CRL\n@@ -357,3 +357,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrootrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrootrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrootrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrootrsaca CRL\n@@ -368,3 +368,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrootevrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootevrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrootevrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrootevrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootevrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrootevrsaca CRL\n@@ -379,3 +379,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrooteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrooteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrooteccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrooteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrooteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrooteccca CRL\n@@ -390,3 +390,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop teliasonerarootcav1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliasonerarootcav1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop teliasonerarootcav1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop teliasonerarootcav1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliasonerarootcav1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop teliasonerarootcav1 CRL\n@@ -401,3 +401,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop twcaglobalrootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop twcaglobalrootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop twcaglobalrootca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop twcaglobalrootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop twcaglobalrootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop twcaglobalrootca CRL\n@@ -412,3 +412,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certignarootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certignarootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop certignarootca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certignarootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certignarootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop certignarootca CRL\n@@ -423,3 +423,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustcommercialca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n@@ -434,3 +434,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustnetworkingca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n@@ -445,3 +445,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n@@ -456,3 +456,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n@@ -467,3 +467,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop teliarootcav2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliarootcav2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop teliarootcav2 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop teliarootcav2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliarootcav2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop teliarootcav2 CRL\n@@ -478,3 +478,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop emsignrootcag1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsignrootcag1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop emsignrootcag1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop emsignrootcag1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsignrootcag1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop emsignrootcag1 CRL\n@@ -489,3 +489,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop emsigneccrootcag3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsigneccrootcag3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop emsigneccrootcag3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop emsigneccrootcag3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsigneccrootcag3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop emsigneccrootcag3 CRL\n@@ -500,2 +500,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certainlyrootr1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyrootr1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certainlyrootr1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyrootr1 DEFAULT\n@@ -510,2 +510,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certainlyroote1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyroote1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certainlyroote1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyroote1 DEFAULT\n@@ -520,3 +520,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n@@ -531,3 +531,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n@@ -537,1 +537,3 @@\n- * Collection of certificate validation tests for interoperability with external CAs\n+ * Collection of certificate validation tests for interoperability with external CAs.\n+ * These tests are marked as manual as they depend on external infrastructure and may fail\n+ * with external reasons, for instance - change in CA test portal.\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":135,"deletions":133,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath CertignaCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CertignaCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CertignaCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CertignaCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CertignaCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath DTrustCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath DTrustCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DTrustCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DTrustCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/DTrustCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=ocsp,certpath DigicertCSRootG5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath DigicertCSRootG5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=ocsp,certpath DigicertCSRootG5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DigicertCSRootG5 CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/DigicertCSRootG5.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath EmSignRootG2CA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath EmSignRootG2CA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath EmSignRootG2CA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath EmSignRootG2CA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/EmSignRootG2CA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath HaricaCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath HaricaCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath HaricaCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath HaricaCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/HaricaCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath LuxTrustCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath LuxTrustCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath LuxTrustCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath LuxTrustCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/LuxTrustCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm HttpsURLConnectionTest https:\/\/github.com KeychainStore-Root\n+ * @run main\/othervm\/manual HttpsURLConnectionTest https:\/\/github.com KeychainStore-Root\n","filename":"test\/jdk\/security\/infra\/javax\/net\/ssl\/HttpsURLConnectionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,1 +176,1 @@\n-                    is.read ();\n+                    System.out.println(\"client got expected exception: \"+ioe);\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamCloseWithWrongContentLength.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @bug 8330842\n+ * @summary test AES CTS multipart operations with SunPKCS11\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=120 TestCipherTextStealingMultipart\n+ *\/\n+\n+public class TestCipherTextStealingMultipart extends PKCS11Test {\n+    private static final String LF = System.lineSeparator();\n+    private static final String ALGORITHM = \"AES\/CTS\/NoPadding\";\n+    private static final int BLOCK_SIZE = 16;\n+    private static final Key KEY =\n+            new SecretKeySpec(\"AbCdEfGhIjKlMnOp\".getBytes(), \"AES\");\n+    private static final IvParameterSpec IV =\n+            new IvParameterSpec(\"1234567890aBcDeF\".getBytes());\n+\n+    private static final StringBuilder chunksDesc = new StringBuilder();\n+    private static Provider sunPKCS11;\n+    private static Cipher sunJCECipher;\n+\n+    private static byte[][] generateChunks(int totalLength, int[] chunkSizes) {\n+        chunksDesc.setLength(0);\n+        chunksDesc.append(\"Testing with \").append(totalLength)\n+                .append(\" bytes distributed in \").append(chunkSizes.length)\n+                .append(\" multipart updates:\").append(LF);\n+        int byteIdx = 0;\n+        byte[][] plaintextChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            for (int i = 0; i < chunk.length; i++) {\n+                chunk[i] = (byte) ('A' + byteIdx++ \/ BLOCK_SIZE);\n+            }\n+            chunksDesc.append(\"  \").append(repr(chunk)).append(LF);\n+            plaintextChunks[chunkIdx] = chunk;\n+        }\n+        return plaintextChunks;\n+    }\n+\n+    private static byte[] computeExpected(byte[] jointPlaintext)\n+            throws Exception {\n+        byte[] ciphertext = sunJCECipher.doFinal(jointPlaintext);\n+        if (ciphertext.length != jointPlaintext.length) {\n+            throw new Exception(\"In CTS mode, ciphertext and plaintext should\" +\n+                    \" have the same length. However, SunJCE's CTS cipher \" +\n+                    \"returned a ciphertext of \" + ciphertext.length + \" bytes\" +\n+                    \" and plaintext has \" + jointPlaintext.length + \" bytes.\");\n+        }\n+        return ciphertext;\n+    }\n+\n+    private static byte[] join(byte[][] inputChunks, int totalLength) {\n+        ByteBuffer outputBuf = ByteBuffer.allocate(totalLength);\n+        for (byte[] inputChunk : inputChunks) {\n+            outputBuf.put(inputChunk);\n+        }\n+        return outputBuf.array();\n+    }\n+\n+    private static byte[][] split(byte[] input, int[] chunkSizes) {\n+        ByteBuffer inputBuf = ByteBuffer.wrap(input);\n+        byte[][] outputChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            inputBuf.get(chunk);\n+            outputChunks[chunkIdx] = chunk;\n+        }\n+        return outputChunks;\n+    }\n+\n+    private enum CheckType {CIPHERTEXT, PLAINTEXT}\n+\n+    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER}\n+\n+    private static void check(CheckType checkType, OutputType outputType,\n+            byte[] expected, ByteBuffer actualBuf) throws Exception {\n+        byte[] actual;\n+        if (actualBuf.hasArray()) {\n+            actual = actualBuf.array();\n+        } else {\n+            actual = new byte[actualBuf.position()];\n+            actualBuf.position(0).get(actual);\n+        }\n+        if (!Arrays.equals(actual, expected)) {\n+            throw new Exception(\"After \" + switch (checkType) {\n+                case CIPHERTEXT -> \"encrypting\";\n+                case PLAINTEXT -> \"decrypting\";\n+            } + \" into a \" + switch (outputType) {\n+                case BYTE_ARRAY -> \"byte[]\";\n+                case DIRECT_BYTE_BUFFER -> \"direct ByteBuffer\";\n+            } + \", \" + checkType.name().toLowerCase() + \"s don't match:\" + LF +\n+                    \"  Expected: \" + repr(expected) + LF +\n+                    \"    Actual: \" + repr(actual));\n+        }\n+    }\n+\n+    private static ByteBuffer encryptOrDecryptMultipart(int operation,\n+            OutputType outputType, byte[][] inputChunks, int totalLength)\n+            throws Exception {\n+        Cipher cipher = Cipher.getInstance(ALGORITHM, sunPKCS11);\n+        cipher.init(operation, KEY, IV);\n+        ByteBuffer output = null;\n+        int outOfs = 1;\n+        switch (outputType) {\n+            case BYTE_ARRAY -> {\n+                output = ByteBuffer.allocate(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    output.put(cipher.update(inputChunk));\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                byte[] tmpOut = new byte[cipher.getOutputSize(0) + outOfs];\n+                cipher.doFinal(tmpOut, outOfs);\n+                output.put(tmpOut, outOfs, tmpOut.length - outOfs);\n+            }\n+            case DIRECT_BYTE_BUFFER -> {\n+                output = ByteBuffer.allocateDirect(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    cipher.update(ByteBuffer.wrap(inputChunk), output);\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                ByteBuffer tmpOut = ByteBuffer.allocateDirect(\n+                        cipher.getOutputSize(0) + outOfs);\n+                tmpOut.position(outOfs);\n+                cipher.doFinal(ByteBuffer.allocate(0), tmpOut);\n+                tmpOut.position(outOfs);\n+                output.put(tmpOut);\n+            }\n+        }\n+        return output;\n+    }\n+\n+    private static void doMultipart(int... chunkSizes) throws Exception {\n+        int totalLength = IntStream.of(chunkSizes).sum();\n+        byte[][] plaintextChunks = generateChunks(totalLength, chunkSizes);\n+        byte[] jointPlaintext = join(plaintextChunks, totalLength);\n+        byte[] expectedCiphertext = computeExpected(jointPlaintext);\n+        byte[][] ciphertextChunks = split(expectedCiphertext, chunkSizes);\n+\n+        for (OutputType outputType : OutputType.values()) {\n+            \/\/ Encryption test\n+            check(CheckType.CIPHERTEXT, outputType, expectedCiphertext,\n+                    encryptOrDecryptMultipart(Cipher.ENCRYPT_MODE, outputType,\n+                            plaintextChunks, totalLength));\n+            \/\/ Decryption test\n+            check(CheckType.PLAINTEXT, outputType, jointPlaintext,\n+                    encryptOrDecryptMultipart(Cipher.DECRYPT_MODE, outputType,\n+                            ciphertextChunks, totalLength));\n+        }\n+    }\n+\n+    private static String repr(byte[] data) {\n+        if (data == null) {\n+            return \"<null>\";\n+        }\n+        if (data.length == 0) {\n+            return \"<empty []>\";\n+        }\n+        String lenRepr = \" (\" + data.length + \" bytes)\";\n+        for (byte b : data) {\n+            if (b < 32 || b > 126) {\n+                return HexFormat.ofDelimiter(\":\").formatHex(data) + lenRepr;\n+            }\n+        }\n+        return new String(data, StandardCharsets.US_ASCII) + lenRepr;\n+    }\n+\n+    private static void initialize() throws Exception {\n+        sunJCECipher = Cipher.getInstance(ALGORITHM, \"SunJCE\");\n+        sunJCECipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        initialize();\n+        main(new TestCipherTextStealingMultipart(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        sunPKCS11 = p;\n+        try {\n+            \/\/ Test relevant combinations for 2, 3, and 4 update operations\n+            int aesBSize = 16;\n+            int[] points = new int[]{1, aesBSize - 1, aesBSize, aesBSize + 1};\n+            for (int size1 : points) {\n+                for (int size2 : points) {\n+                    if (size1 + size2 >= aesBSize) {\n+                        doMultipart(size1, size2);\n+                    }\n+                    for (int size3 : points) {\n+                        if (size1 + size2 + size3 >= aesBSize) {\n+                            doMultipart(size1, size2, size3);\n+                        }\n+                        for (int size4 : points) {\n+                            if (size1 + size2 + size3 + size4 >= aesBSize) {\n+                                doMultipart(size1, size2, size3, size4);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            doMultipart(17, 17, 17, 17, 17);\n+            doMultipart(4, 2, 7, 1, 6, 12);\n+            doMultipart(2, 15, 21, 26, 31, 26, 5, 30);\n+            doMultipart(7, 12, 26, 8, 15, 2, 17, 16, 21, 2, 32, 29);\n+            doMultipart(6, 7, 6, 1, 5, 16, 14, 1, 10, 16, 17, 8, 1, 13, 12);\n+            doMultipart(16, 125, 19, 32, 32, 16, 17,\n+                    31, 19, 13, 16, 16, 32, 16, 16);\n+            doMultipart(5, 30, 11, 9, 6, 14, 20, 6,\n+                    5, 18, 31, 33, 15, 29, 7, 9);\n+            doMultipart(105, 8, 21, 27, 30, 101, 15, 20,\n+                    23, 33, 26, 6, 8, 2, 13, 17);\n+        } catch (Exception e) {\n+            System.out.print(chunksDesc);\n+            throw e;\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherTextStealingMultipart.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898461 6604496\n+ * @bug 4898461 6604496 8330842\n@@ -83,1 +83,2 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n@@ -86,1 +87,1 @@\n-    private static StringBuffer debugBuf = new StringBuffer();\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -131,4 +132,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-                debugBuf = new StringBuffer();\n-            }\n+            System.out.println(debugBuf);\n@@ -174,2 +172,1 @@\n-        perfOut(\"stream InBuf + stream OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n@@ -187,2 +184,1 @@\n-        perfOut(\"non-direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -200,2 +196,1 @@\n-        perfOut(\"direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -218,2 +213,1 @@\n-        perfOut(\"direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -234,2 +228,1 @@\n-        perfOut(\"non-direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -241,1 +234,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n@@ -244,4 +237,2 @@\n-    private static void perfOut(String msg) {\n-        if (debugBuf != null) {\n-            debugBuf.append(\"PERF>\" + msg);\n-        }\n+    private static void perfOut(String msg, long elapsed) {\n+        debugOut(\"PERF> \" + msg + \", elapsed: \" + elapsed + \" ns\\n\");\n@@ -251,3 +242,1 @@\n-        if (debugBuf != null) {\n-            debugBuf.append(msg);\n-        }\n+        debugBuf.append(msg);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898484 6604496 8001284\n+ * @bug 4898484 6604496 8001284 8330842\n@@ -71,1 +71,3 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n@@ -74,1 +76,1 @@\n-    private static StringBuffer debugBuf;\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -114,3 +116,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-            }\n+            System.out.println(debugBuf);\n@@ -125,1 +125,0 @@\n-        debugBuf = new StringBuffer();\n@@ -217,1 +216,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -794,2 +794,2 @@\n-                        .orElseThrow(() -> new SkippedException(\n-                        \"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n+                        .orElseThrow(() ->\n+                            new RuntimeException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-        verifyExtraAttrs(ZIPFILENAME);\n+        verifyExternalFileAttributes(ZIPFILENAME);\n@@ -85,1 +85,1 @@\n-        verifyExtraAttrs(ZIPFILENAME);\n+        verifyExternalFileAttributes(ZIPFILENAME);\n@@ -98,2 +98,2 @@\n-    private static void verifyExtraAttrs(String zipFileName) throws IOException {\n-        \/\/ the 16 bit extra attributes value should equal 0xa1ff - look for that pattern.\n+    private static void verifyExternalFileAttributes(String zipFileName) throws IOException {\n+        \/\/ the 16 bit 'external file attributes' value should equal 0xa1ff - look for that pattern.\n@@ -110,1 +110,1 @@\n-            throw new RuntimeException(\"extra attribute value not detected\");\n+            throw new RuntimeException(\"external file attribute value not detected\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/SymLinkTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/java\/security\/testlibrary\n@@ -1868,169 +1869,1 @@\n-}\n-\n-\/**\n- * HumanInputStream tries to act like a human sitting in front of a computer\n- * terminal typing on the keyboard while the keytool program is running.\n- *\n- * keytool has called InputStream.read() and BufferedReader.readLine() in\n- * various places. a call to B.readLine() will try to buffer as much input as\n- * possible. Thus, a trivial InputStream will find it impossible to feed\n- * anything to I.read() after a B.readLine() call.\n- *\n- * This is why i create HumanInputStream, which will only send a single line\n- * to B.readLine(), no more, no less, and the next I.read() can have a chance\n- * to read the exact character right after \"\\n\".\n- *\n- * I don't know why HumanInputStream works.\n- *\/\n-class HumanInputStream extends InputStream {\n-    byte[] src;\n-    int pos;\n-    int length;\n-    boolean inLine;\n-    int stopIt;\n-\n-    public HumanInputStream(String input) {\n-        src = input.getBytes();\n-        pos = 0;\n-        length = src.length;\n-        stopIt = 0;\n-        inLine = false;\n-    }\n-\n-    \/\/ the trick: when called through read(byte[], int, int),\n-    \/\/ return -1 twice after \"\\n\"\n-\n-    @Override public int read() throws IOException {\n-        int re;\n-        if(pos < length) {\n-            re = src[pos];\n-            if(inLine) {\n-                if(stopIt > 0) {\n-                    stopIt--;\n-                    re = -1;\n-                } else {\n-                    if(re == '\\n') {\n-                        stopIt = 2;\n-                    }\n-                    pos++;\n-                }\n-            } else {\n-                pos++;\n-            }\n-        } else {\n-            re = -1;\/\/throw new IOException(\"NO MORE TO READ\");\n-        }\n-        \/\/if (re < 32) System.err.printf(\"[%02d]\", re);\n-        \/\/else System.err.printf(\"[%c]\", (char)re);\n-        return re;\n-    }\n-    @Override public int read(byte[] buffer, int offset, int len) {\n-        inLine = true;\n-        try {\n-            int re = super.read(buffer, offset, len);\n-            return re;\n-        } catch(Exception e) {\n-            throw new RuntimeException(\"HumanInputStream error\");\n-        } finally {\n-            inLine = false;\n-        }\n-    }\n-    @Override public int available() {\n-        if(pos < length) return 1;\n-        return 0;\n-    }\n-\n-    \/\/ test part\n-    static void assertTrue(boolean bool) {\n-        if(!bool)\n-            throw new RuntimeException();\n-    }\n-\n-    public static void test() throws Exception {\n-\n-        class Tester {\n-            HumanInputStream is;\n-            BufferedReader reader;\n-            Tester(String s) {\n-                is = new HumanInputStream(s);\n-                reader = new BufferedReader(new InputStreamReader(is));\n-            }\n-\n-            \/\/ three kinds of test method\n-            \/\/ 1. read byte by byte from InputStream\n-            void testStreamReadOnce(int expection) throws Exception {\n-                assertTrue(is.read() == expection);\n-            }\n-            void testStreamReadMany(String expection) throws Exception {\n-                char[] keys = expection.toCharArray();\n-                for(int i=0; i<keys.length; i++) {\n-                    assertTrue(is.read() == keys[i]);\n-                }\n-            }\n-            \/\/ 2. read a line with a newly created Reader\n-            void testReaderReadline(String expection) throws Exception {\n-                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-            \/\/ 3. read a line with the old Reader\n-            void testReaderReadline2(String expection) throws Exception  {\n-                String s = reader.readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-        }\n-\n-        Tester test;\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline2(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"1\\n2\");\n-        test.testStreamReadMany(\"1\\n2\");\n-        test.testStreamReadOnce(-1);\n-\n-        test = new Tester(\"12\\n234\");\n-        test.testStreamReadOnce('1');\n-        test.testReaderReadline(\"2\");\n-        test.testStreamReadOnce('2');\n-        test.testReaderReadline2(\"34\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"changeit\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(\"Name\");\n-        test.testReaderReadline(\"Country\");\n-        test.testReaderReadline(\"Yes\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"Me\\nHere\\n\");\n-        test.testReaderReadline2(\"Me\");\n-        test.testReaderReadline2(\"Here\");\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/KeyToolTest.java","additions":3,"deletions":170,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11\n+ * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11 \/java\/security\/testlibrary\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/NssTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332124\n+ * @summary Test to verify jcmd accepts the \"-help\", \"--help\" and \"-h\" suboptions as a command argument\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm TestJcmdSubcommandHelp\n+ *\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\n+public class TestJcmdSubcommandHelp {\n+\n+    private static final String HELP_ONE_DASH = \"-help\";\n+    private static final String HELP_TWO_DASH = \"--help\";\n+    private static final String SINGLE_H = \"-h\";\n+    private static final String CMD = \"VM.metaspace\";\n+    private static final String ILLEGAL = \"IllegalArgumentException: Unknown argument\";\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Sanity check with empty input\n+        OutputAnalyzer output = JcmdBase.jcmd();\n+        output.shouldContain(\"The following commands are available:\");\n+\n+        \/\/ Sanity check with existing usage for \"help <cmd>\"\n+        output = JcmdBase.jcmd(\"help\", CMD);\n+        String expectedOutput = output.getOutput();\n+        output.shouldNotContain(\"Unknown diagnostic command\");\n+\n+        testExpectedUsage(HELP_ONE_DASH, expectedOutput);\n+        testExpectedUsage(HELP_TWO_DASH, expectedOutput);\n+        testExpectedUsage(SINGLE_H, expectedOutput);\n+\n+        testIgnoreAdditionalArgs(HELP_ONE_DASH, expectedOutput);\n+        testIgnoreAdditionalArgs(HELP_TWO_DASH, expectedOutput);\n+        testIgnoreAdditionalArgs(SINGLE_H, expectedOutput);\n+\n+        testIgnoreTrailingSpaces(HELP_ONE_DASH, expectedOutput);\n+        testIgnoreTrailingSpaces(HELP_TWO_DASH, expectedOutput);\n+        testIgnoreTrailingSpaces(SINGLE_H, expectedOutput);\n+\n+        testSimilarCommand(HELP_ONE_DASH + \"less\", ILLEGAL);\n+        testSimilarCommand(HELP_TWO_DASH + \"me\", ILLEGAL);\n+        testSimilarCommand(SINGLE_H + \"ello\", ILLEGAL);\n+    }\n+\n+    private static void testExpectedUsage(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutput(new String[] {CMD, helpOption}, expectedOutput,\n+                \"Expected jcmd to accept '%s' suboption as a command argument and issue the same help output.\".formatted(helpOption));\n+    }\n+\n+    private static void testIgnoreAdditionalArgs(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutput(new String[] {CMD, helpOption, \"basic\"}, expectedOutput,\n+                \"Expected jcmd to accept '%s' suboption with additional arguments after help.\".formatted(helpOption));\n+    }\n+\n+    private static void testIgnoreTrailingSpaces(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutput(new String[] {CMD, \"%s    \".formatted(helpOption)}, expectedOutput,\n+                \"Expected jcmd to accept '%s' suboption with trailing spaces\".formatted(helpOption));\n+    }\n+\n+    private static void testSimilarCommand(String helpOption, String expectedOutput) throws Exception {\n+        verifyOutputContains(new String[] {CMD, helpOption}, expectedOutput,\n+                \"Expected jcmd to NOT accept '%s' suboption with trailing content\".formatted(helpOption));\n+    }\n+\n+    private static void verifyOutputContains(String[] args, String expectedOutput, String errorMessage) throws Exception {\n+        OutputAnalyzer output = JcmdBase.jcmd(args);\n+        String issuedOutput = output.getOutput();\n+        if (!issuedOutput.contains(expectedOutput)) {\n+            printDifferingOutputs(expectedOutput, issuedOutput);\n+            throw new Exception(errorMessage);\n+        }\n+    }\n+\n+    private static void verifyOutput(String[] args, String expectedOutput, String errorMessage) throws Exception {\n+        OutputAnalyzer output = JcmdBase.jcmd(args);\n+        String issuedOutput = output.getOutput();\n+        if (!expectedOutput.equals(issuedOutput)) {\n+            printDifferingOutputs(expectedOutput, issuedOutput);\n+            throw new Exception(errorMessage);\n+        }\n+    }\n+\n+    private static void printDifferingOutputs(String expectedOutput, String issuedOutput) {\n+        System.out.println(\"Expected output: \");\n+        System.out.println(expectedOutput);\n+        System.out.println(\"Issued output: \");\n+        System.out.println(issuedOutput);\n+    }\n+}\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdSubcommandHelp.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -359,1 +359,1 @@\n-        assertEquals(stdout.size(), 1, \"Output should contain one line\");\n+        assertEquals(stdout.size(), 2, \"Output should contain two lines\"); \/\/ includes deprecation warning\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatdTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+        new ToolHelpSpec(\"jnativescan\", 1,   1,   1,   0,         1,    0,     1),     \/\/ -?, -h, --help, -help accepted but not documented.\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -390,1 +390,0 @@\n-        vmOptFinalFlag(map, \"UseVtableBasedCHA\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+langtools_jnativescan = \\\n+    tools\/all \\\n+    tools\/jnativescan\n+\n","filename":"test\/langtools\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8322708\n+ * @summary  Test to make sure global tags work properly\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestGlobalHtml\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+\n+public class TestGlobalHtml extends JavadocTester {\n+    ToolBox tb = new ToolBox();\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestGlobalHtml();\n+        tester.runTests();\n+    }\n+\n+    @Test\n+    public void testGlobalTags() {\n+        javadoc(\"--allow-script-in-comments\",\n+                \"-d\",\n+                \"out-global\",\n+                \"-sourcepath\",\n+                testSrc,\n+                \"pkg1\");\n+        checkExit(Exit.OK);\n+    }\n+\n+    @Test\n+    public void testNegative(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+                \/**\n+                 * class comment\n+                 * <a href=\"https:\/\/openjdk.org\/\">Hyperlink to the OpenJDK website<\/a>\n+                 *\/\n+                public class C {\n+                    \/**\n+                     * <form>\n+                     *   <label for=\"methodname\">Method name:<\/label><br>\n+                     *   <input type=\"text\" id=\"methodname\" name=\"methodname\"><br>\n+                     *   <label for=\"paramname\">Method Parameter:<\/label><br>\n+                     *   <input type=\"text\" id=\"paramname\" name=\"paramname\">\n+                     * <\/form>\n+                     *\/\n+                    public C() {\n+                    }\n+                }\n+                \"\"\");\n+\n+        javadoc(\"--allow-script-in-comments\",\n+                \"-d\",\n+                \"out-negative\",\n+                \"-sourcepath\",\n+                src.toString(),\n+                \"p\");\n+        checkExit(Exit.ERROR);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/TestGlobalHtml\/TestGlobalHtml.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg1;\n+\n+\n+\/**\n+ * <div inert>\n+ * <p> This content is inert and not interactable.<\/p>\n+ * <a href=\"https:\/\/openjdk.org\/\" title=\"OpenJDK's Website\" tabindex=\"0\">\n+ * Visit OpenJDK's Website!\n+ * <\/a>\n+ * <\/div>\n+ *\n+ * <div>\n+ *   <p autocapitalize=\"on\">This content is interactable.<\/p>\n+ *   <a href=\"https:\/\/openjdk.org\/\" title=\"OpenJDK's Website\" tabindex=\"0\">\n+ *     Visit OpenJDK's Website!\n+ *   <\/a>\n+ * <\/div>\n+ *\n+ *\n+ * <div dir=\"ltr\" lang=\"en\">\n+ *   <p itemprop=\"description\">This is used in a jtreg test to check that global HTML tags are allowed<\/p>\n+ *   <ul spellcheck=\"true\">\n+ *     <li>Class C<\/li>\n+ *     <li>Has a default constructor<\/li>\n+ *   <\/ul>\n+ * <\/div>\n+ *\n+ * <p contenteditable=\"true\" inputmode=\"text\">Here is a description of the class and methods:<\/p>\n+ *\n+ * <ol draggable=\"true\" tabindex=\"0\">\n+ *   <li><p accesskey=\"1\" data-element-type=\"constructor\" title=\"Class Details\">Has a default constructor<\/p><\/li>\n+ *   <li><p accesskey=\"2\" data-element-type=\"toString\" title=\"Methods Summary\">Overrides toString method<\/p><\/li>\n+ *   <li><p accesskey=\"3\" data-element-type=\"other\" title=\"Usage Example\">Is used for testing<\/p><\/li>\n+ * <\/ol>\n+ *\n+ * <div itemscope>\n+ *   <p itemprop=\"name\">C1<\/p>\n+ *   <p itemprop=\"description\">C1<\/p>\n+ * <\/div>\n+ *\/\n+public class C1 {\n+\n+    \/**\n+     * <p lang=\"en\" accesskey=\"D\" autocapitalize=\"on\" draggable=\"true\" spellcheck=\"false\">\n+     * Default constructor for the {@code C1} class. (this content is draggable!) <\/p>\n+     * <div lang=\"en\" contenteditable=\"true\">\n+     *   <p itemprop=\"creator\">Author: try editing this content!<\/p>\n+     *   <p title=\"Creation Date\">Created on: June 14 2024<\/p>\n+     * <\/div>\n+     *\/\n+    public C1() {\n+    }\n+\n+    \/**\n+     * A method in C1\n+     *\n+     * <p lang=\"en\" inputmode=\"numeric\">simple method.<\/p>\n+     *\n+     * <div itemprop=\"method\" itemscope>\n+     *   <p itemprop=\"name\">method m<\/p>\n+     *   <p itemprop=\"description\">the method m does nothing<\/p>\n+     * <\/div>\n+     *\/\n+    public void m() {\n+    }\n+\n+    \/**\n+     * A toString Override.\n+     *\n+     * <p dir=\"ltr\" spellcheck=\"true\">returns a String Object.<\/p>\n+     *\n+     * <div itemprop=\"method\" itemscope>\n+     *   <p itemprop=\"name\">toString<\/p>\n+     * <\/div>\n+     *\n+     * @return a string.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return \"C1\";\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/TestGlobalHtml\/pkg1\/C1.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334433\n+ * @summary Verify that when running JShell on platforms that support FFMTerminalProvider,\n+ *          no new processes are spawned.\n+ * @requires os.family == \"windows\" | os.family == \"mac\" | os.family == \"linux\"\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavaTask TerminalNoExecTest\n+ * @run main TerminalNoExecTest\n+ *\/\n+\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jshell.tool.JavaShellToolBuilder;\n+\n+import toolbox.ToolBox;\n+\n+public class TerminalNoExecTest {\n+\n+    public static void main(String... args) throws Exception {\n+        if (args.length > 0) {\n+            AtomicBoolean spawnedNewProcess = new AtomicBoolean();\n+            try (var rs = new RecordingStream()) {\n+                rs.enable(\"jdk.ProcessStart\").withoutThreshold();\n+                rs.onEvent(evt -> {\n+                    System.err.println(\"evt: \" + evt);\n+                    spawnedNewProcess.set(true);\n+                });\n+                rs.startAsync();\n+                JavaShellToolBuilder.builder().run(\"--execution=local\", \"--no-startup\");\n+                rs.stop();\n+            }\n+            if (spawnedNewProcess.get()) {\n+                System.err.println(\"Spawned a new process!\");\n+                System.exit(1);\n+            }\n+            System.exit(0);\n+        } else {\n+            Path testScript = Paths.get(\"do-exit\");\n+            try (Writer w = Files.newBufferedWriter(testScript)) {\n+                w.append(\"\/exit\\n\");\n+            }\n+\n+            ToolBox tb = new ToolBox();\n+            Process target =\n+                new ProcessBuilder(tb.getJDKTool(\"java\").toString(),\n+                                   \"-classpath\", System.getProperty(\"java.class.path\"),\n+                                   TerminalNoExecTest.class.getName(),\n+                                   \"run-test\")\n+                        .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectInput(testScript.toFile())\n+                        .start();\n+\n+            target.waitFor();\n+\n+            int exitCode = target.exitValue();\n+\n+            if (exitCode != 0) {\n+                throw new AssertionError(\"Incorrect exit value, expected 0, got: \" + exitCode);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/TerminalNoExecTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- *      8239536 8247456 8246774 8238173 8292625 8306560\n+ *      8239536 8247456 8246774 8238173 8292625 8306560 8328536\n@@ -967,0 +967,7 @@\n+    @Test\n+    public void testSwitchExpressionYieldUnknownType() {\n+        test(a -> assertCommandOutputContains(a,\n+                \"I m(I i, int x) { return switch (x) { default -> i; }; } \",\n+                \"created method m(I,int), however, it cannot be referenced until class I is declared\"));\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-        byte[] bazBytes = ClassFile.of().transform(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n+        byte[] bazBytes = ClassFile.of().transformClass(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n@@ -203,1 +203,1 @@\n-            bazBytes = ClassFile.of().transform(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n+            bazBytes = ClassFile.of().transformClass(baz, ClassTransform.transformingMethods((methodBuilder, methodElement) -> {\n","filename":"test\/langtools\/tools\/javac\/MethodParametersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333766\n+ * @summary Test for compiler crash when anonymous class created in early lambda\n+ *\/\n+\n+public class AnonSuperLambdaCrash {\n+    class Inner {\n+        Inner() {\n+            this(() -> new Object() { { AnonSuperLambdaCrash.this.hashCode(); } });\n+        }\n+        Inner(Runnable r) {\n+            r.run();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new AnonSuperLambdaCrash().new Inner();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/AnonSuperLambdaCrash.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalTest1 {\n+\n+    class Test {\n+        Test() {\n+            class InnerLocal { }\n+            Runnable r = () -> new InnerLocal();\n+            r.run();\n+            super();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest1().new Test();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest1.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalTest4 {\n+\n+    class Test {\n+        Test() {\n+            class InnerLocal { }\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    new InnerLocal();\n+                }\n+            };\n+            r.run();\n+            super();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest4().new Test();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest4.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest5 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            class Foo implements Runnable {\n+                public void run() {\n+                    System.out.println(x + y);\n+                }\n+            }\n+            super(new Foo());\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest5().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest5.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest6 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            super(new Runnable() {\n+                public void run() {\n+                    System.out.println(x + y);\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest6().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest6.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest7 {\n+\n+    int y;\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            super(() -> System.out.println(x + y));\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest7().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest7.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8334037\n+ * @summary Test for compiler crash when local class created in early lambda\n+ * @enablePreview\n+ *\/\n+\n+public class LambdaLocalEarlyCrash {\n+    interface A { }\n+\n+    class Inner {\n+       Inner() {\n+          this(() -> {\n+             class Local {\n+                void g() {\n+                   m();\n+                }\n+             }\n+             new Local().g(); \/\/ error\n+          });\n+       }\n+\n+       Inner(Runnable tr) {\n+          tr.run();\n+       }\n+    }\n+\n+    void m() {\n+       System.out.println(\"Hello\");\n+    }\n+\n+    public static void main(String[] args) {\n+       new LambdaLocalEarlyCrash().new Inner();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/LambdaLocalEarlyCrash.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8194743\n+ * @bug 8334252\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/LambdaOuterCapture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334757\n+ * @compile\/fail\/ref=CantAnnotateClassWithTypeVariable.out -XDrawDiagnostics CantAnnotateClassWithTypeVariable.java\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+public class CantAnnotateClassWithTypeVariable {\n+  @Target(ElementType.TYPE_USE)\n+  @interface TA {}\n+\n+  static class A {\n+    static class B<T> {}\n+  }\n+\n+  <T> @TA A.B<T> f() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateClassWithTypeVariable.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CantAnnotateClassWithTypeVariable.java:18:14: compiler.err.type.annotation.inadmissible: (compiler.misc.type.annotation.1: @CantAnnotateClassWithTypeVariable.TA), CantAnnotateClassWithTypeVariable.A, @CantAnnotateClassWithTypeVariable.TA CantAnnotateClassWithTypeVariable.A.B<T>\n+1 error\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateClassWithTypeVariable.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +188,1 @@\n-        byte[] Bytes = ClassFile.of().transform(cf, ClassTransform\n+        byte[] Bytes = ClassFile.of().transformClass(cf, ClassTransform\n","filename":"test\/langtools\/tools\/javac\/classreader\/8171132\/BadConstantValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +152,1 @@\n-        bytes = cf.transform(classModel, classTransform);\n+        bytes = cf.transformClass(classModel, classTransform);\n","filename":"test\/langtools\/tools\/javac\/classreader\/BadMethodParameter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        ClassFile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof ClassFileVersion)\n+        ClassFile.of().transformClass(cf, ClassTransform.dropping(ce -> ce instanceof ClassFileVersion)\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/BadClassfile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -5,0 +6,2 @@\n+T7188968.java:22:9: compiler.warn.unchecked.meth.invocation.applied: kindname.constructor, <init>, java.util.List<X>,java.lang.Object, java.util.List,unknown, kindname.class, T7188968.Foo\n+T7188968.java:22:19: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), java.util.List, java.util.List<X>\n@@ -6,0 +9,2 @@\n+T7188968.java:23:20: compiler.warn.unchecked.meth.invocation.applied: kindname.method, makeFoo, java.util.List<Z>,java.lang.Object, java.util.List,unknown, kindname.class, T7188968.Foo\n+T7188968.java:23:21: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), java.util.List, java.util.List<Z>\n@@ -7,1 +12,1 @@\n-1 warning\n+6 warnings\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7188968\/T7188968.out","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8198378\n+ * @bug 8198378 8335385\n@@ -56,1 +56,3 @@\n-                   \"package p; public class B { public static class I { } }\")\n+                   \"package p; public class B { public static class I { } }\",\n+                   \"package m; public class A { }\",\n+                   \"package m; public class B { public static class I { } }\")\n@@ -68,0 +70,3 @@\n+        Files.delete(Paths.get(\".\", \"m\", \"A.class\"));\n+        Files.delete(Paths.get(\".\", \"m\", \"B$I.class\"));\n+\n@@ -72,0 +77,4 @@\n+        doTest(\"import m.A;\",\n+               \"\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"1 error\");\n@@ -77,0 +86,5 @@\n+        doTest(\"import m.A;\",\n+               \"A a;\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"Test.java:2:33: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -82,0 +96,5 @@\n+        doTest(\"import m.A;\",\n+               \"void test() { A a; }\",\n+               \"Test.java:2:9: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.package, m, null)\",\n+               \"Test.java:2:47: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -85,0 +104,3 @@\n+        doTest(\"import m.*;\",\n+               \"\",\n+               (String[]) null);\n@@ -89,0 +111,4 @@\n+        doTest(\"import m.*;\",\n+               \"A a;\",\n+               \"Test.java:2:33: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -93,0 +119,4 @@\n+        doTest(\"import m.*;\",\n+               \"void test() { A a; }\",\n+               \"Test.java:2:47: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -98,0 +128,4 @@\n+        doTest(\"import m.B.I;\",\n+               \"\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -101,1 +135,7 @@\n-               \"1 error\");\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"import m.B.I;\",\n+               \"I i;\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -105,1 +145,7 @@\n-               \"1 error\");\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"import m.B.I;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:11: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -109,0 +155,3 @@\n+        doTest(\"import m.B.*;\",\n+               \"\",\n+               (String[]) null);\n@@ -113,0 +162,8 @@\n+        doTest(\"import m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n+        doTest(\"import m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:35: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -117,0 +174,4 @@\n+        doTest(\"import m.B.*;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:49: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n@@ -122,0 +183,4 @@\n+        doTest(\"import static m.B.I;\",\n+               \"\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -126,0 +191,4 @@\n+        doTest(\"import static m.B.I;\",\n+               \"I i;\",\n+               \"Test.java:2:42: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -130,0 +199,5 @@\n+        doTest(\"import static m.B.I;\",\n+               \"void test() { I i; }\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:56: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -134,0 +208,4 @@\n+        doTest(\"import static m.B.*;\",\n+               \"\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -138,0 +216,4 @@\n+        doTest(\"import static m.B.*;\",\n+               \"I i;\",\n+               \"Test.java:2:42: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"1 error\");\n@@ -142,0 +224,5 @@\n+        doTest(\"import static m.B.*;\",\n+               \"void test() { M m; }\",\n+               \"Test.java:2:1: compiler.err.cant.access: m.B.I, (compiler.misc.class.file.not.found: m.B$I)\",\n+               \"Test.java:2:56: compiler.err.cant.resolve.location: kindname.class, M, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n@@ -149,1 +236,2 @@\n-                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS,\n+                     expectedOutput != null ? 1 : 0)\n","filename":"test\/langtools\/tools\/javac\/importscope\/BadClassFileDuringImport.java","additions":94,"deletions":6,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-MethodReference23.java:53:16: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, , MethodReference23)\n+MethodReference23.java:53:16: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, MethodReference23, MethodReference23)\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference23.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,15 @@\n-                    this(name, moonsCount, java.lang.invoke.LambdaMetafactory.metafactory(name, Universe.Galaxy.this, Universe.Galaxy.SolarSystem.this));\n+                    this(name, moonsCount, ()->{\n+                        String n = name;\n+                        StringBuffer buf = new StringBuffer();\n+                        buf.append(\"This planet belongs to the galaxy \" + Galaxy.this.name + \" with \" + starsCount + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Universe.Galaxy.this.name + \" with \" + starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Galaxy.this.name() + \" with \" + starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the galaxy \" + Universe.Galaxy.this.name() + \" with \" + (Universe.Galaxy.this).starsCount() + \" stars\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + SolarSystem.this.name + \" with \" + planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Galaxy.SolarSystem.this.name + \" with \" + planetsCount() + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + (SolarSystem.this).name + \" with \" + planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Universe.Galaxy.SolarSystem.this.name + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + Universe.Galaxy.SolarSystem.this.name.toLowerCase().toUpperCase() + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        buf.append(\"This planet belongs to the solar system \" + copy(Universe.Galaxy.SolarSystem.this).name.toLowerCase().toUpperCase() + \" with \" + Universe.Galaxy.SolarSystem.this.planetsCount + \" planets\\n\");\n+                        if (!buf.toString().equals(output)) throw new AssertionError(\"Unexpected value\\n\" + buf);\n+                    });\n@@ -79,16 +93,0 @@\n-                \n-                \/*synthetic*\/ private static void lambda$new$0(\/*synthetic*\/ final String name, \/*synthetic*\/ final Universe.Galaxy Universe$Galaxy$this, \/*synthetic*\/ final Universe.Galaxy.SolarSystem Universe$Galaxy$SolarSystem$this) {\n-                    String n = name;\n-                    StringBuffer buf = new StringBuffer();\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name + \" with \" + Universe$Galaxy$this.starsCount + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name + \" with \" + Universe$Galaxy$this.starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name() + \" with \" + Universe$Galaxy$this.starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the galaxy \" + Universe$Galaxy$this.name() + \" with \" + (Universe$Galaxy$this).starsCount() + \" stars\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount() + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + (Universe$Galaxy$SolarSystem$this).name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.name.toLowerCase().toUpperCase() + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    buf.append(\"This planet belongs to the solar system \" + Universe$Galaxy$SolarSystem$this.copy(Universe$Galaxy$SolarSystem$this).name.toLowerCase().toUpperCase() + \" with \" + Universe$Galaxy$SolarSystem$this.planetsCount + \" planets\\n\");\n-                    if (!buf.toString().equals(output)) throw new AssertionError(\"Unexpected value\\n\" + buf);\n-                }\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8129740\/Universe.java.out","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-MethodRefToInnerWithoutOuter.java:22:31: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: TestString, , MethodRefToInnerBase)\n+MethodRefToInnerWithoutOuter.java:22:31: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: TestString, java.lang.String, MethodRefToInnerBase)\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodRefToInnerWithoutOuter.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-            byte[] newBytes = ClassFile.of().transform(cf,\n+            byte[] newBytes = ClassFile.of().transformClass(cf,\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,1 @@\n-        byte[] newBytes = ClassFile.of().transform(cm, ClassTransform.dropping(ce -> ce instanceof ModuleResolutionAttribute).\n+        byte[] newBytes = ClassFile.of().transformClass(cm, ClassTransform.dropping(ce -> ce instanceof ModuleResolutionAttribute).\n","filename":"test\/langtools\/tools\/javac\/modules\/IncubatingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,1 @@\n-        byte[] newBytes = ClassFile.of().transform(cm1, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n+        byte[] newBytes = ClassFile.of().transformClass(cm1, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n","filename":"test\/langtools\/tools\/javac\/modules\/JavaBaseTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-        byte[] newBytes = ClassFile.of().transform(cm, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n+        byte[] newBytes = ClassFile.of().transformClass(cm, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute).\n","filename":"test\/langtools\/tools\/javac\/modules\/OpenModulesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,4 @@\n+        test.disambiguationTest(\"R r when (x > 0)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"R(int x) when (x > 0)\",\n+                                 ExpressionType.PATTERN);\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1073,1 +1073,1 @@\n-                                       cf.transform(cf.parse(moduleInfo),\n+                                       cf.transformClass(cf.parse(moduleInfo),\n@@ -1182,1 +1182,1 @@\n-            byte[] newData = cf.transform(cm, (builder, element) -> {\n+            byte[] newData = cf.transformClass(cm, (builder, element) -> {\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,1 @@\n-        byte[] newClassFileBytes = ClassFile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute)\n+        byte[] newClassFileBytes = ClassFile.of().transformClass(cf, ClassTransform.dropping(ce -> ce instanceof ModuleAttribute)\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestOrigin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,0 +206,31 @@\n+    @Test\n+    public void testErroneousTarget() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          public Undefined g(Undefined u) {\n+                              return switch (0) {\n+                                  default -> u;\n+                              };\n+                          }\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL, 1)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:2:24: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:12: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335136\n+ * @summary Underscore as parameter name in one-parameter functional types fails to compile in yield statement if not enclosed in parentheses\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.JavacTask toolbox.ToolBox toolbox.Task\n+ * @run main ExpressionSwitchUnderscoreAfterYield\n+ *\/\n+\n+import toolbox.*;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class ExpressionSwitchUnderscoreAfterYield extends TestRunner {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    private final Path ROOT = Path.of(\".\");\n+\n+    public ExpressionSwitchUnderscoreAfterYield() {\n+        super(System.err);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new ExpressionSwitchUnderscoreAfterYield().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(f -> {\n+            if (f.getName().endsWith(\"_ShouldFailToCompile\")) {\n+                return new Object[]{\n+                        List.of(\n+                                FailParams.UNDERSCORE_YIELDED,\n+                                FailParams.ASSIGNMENT_TO_UNDERSCORE_IN_YIELD\n+                        )\n+                };\n+            }\n+            return new Object[0];\n+        });\n+    }\n+\n+    @Test\n+    public void testUnderscoreAsParameterNameInLambda_ShouldCompileFine() throws Exception {\n+        var code = \"\"\"\n+                        import java.util.function.*;\n+                        \\s\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Consumer<Object> result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _ -> {};\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\";\n+        tb.writeJavaFiles(ROOT, code);\n+        new toolbox.JavacTask(tb)\n+                .files(tb.findJavaFiles(ROOT))\n+                .run(Task.Expect.SUCCESS);\n+    }\n+\n+    public record FailParams(String code, List<String> expectedDiagnosticMessage) {\n+        public static FailParams UNDERSCORE_YIELDED = new FailParams(\n+                \"\"\"\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Object result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _;\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\",\n+                List.of(\"Test.java:5:23: compiler.err.use.of.underscore.not.allowed.non.variable\", \"1 error\")\n+        );\n+\n+        public static FailParams ASSIGNMENT_TO_UNDERSCORE_IN_YIELD = new FailParams(\n+                \"\"\"\n+                        public class Test {\n+                            public static void main(String[] args) {\n+                                Object result = switch (1) {\n+                                    case 1 -> {\n+                                        yield _ = 1;\n+                                    }\n+                                    default -> null;\n+                                };\n+                            }\n+                        }\n+                        \"\"\",\n+                List.of(\"Test.java:5:23: compiler.err.use.of.underscore.not.allowed.non.variable\", \"1 error\")\n+        );\n+    }\n+\n+    @Test\n+    public void testUnderscoreAsParameterNameInLambda_ShouldFailToCompile(List<FailParams> params) throws Exception {\n+        for (var param : params) {\n+            tb.writeJavaFiles(ROOT, param.code);\n+            Task.Result result = new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\")\n+                    .files(tb.findJavaFiles(ROOT))\n+                    .run(Task.Expect.FAIL);\n+            tb.checkEqual(param.expectedDiagnosticMessage, result.getOutputLines(Task.OutputKind.DIRECT));\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchUnderscoreAfterYield.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335385\n+ * @summary Verify that BadClassFile related to imports are handled properly.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ASTAttributesFilledForReferencesOnMissingTypes\n+ *\/\n+\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.Element;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class ASTAttributesFilledForReferencesOnMissingTypes {\n+    public static void main(String... args) throws Exception {\n+        new ASTAttributesFilledForReferencesOnMissingTypes().run();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    void run() throws Exception {\n+        new JavacTask(tb)\n+          .outdir(\".\")\n+          .sources(\"package p; public class A { }\",\n+                   \"package p; public class B { public static class I { } public static class M { } }\",\n+                   \"package p; public class C { }\")\n+          .run()\n+          .writeAll();\n+\n+        try (OutputStream out = Files.newOutputStream(Paths.get(\".\", \"p\", \"A.class\"))) {\n+            out.write(\"broken\".getBytes(\"UTF-8\"));\n+        }\n+\n+        try (OutputStream out = Files.newOutputStream(Paths.get(\".\", \"p\", \"B$I.class\"))) {\n+            out.write(\"broken\".getBytes(\"UTF-8\"));\n+        }\n+\n+        Files.delete(Paths.get(\".\", \"p\", \"C.class\"));\n+        Files.delete(Paths.get(\".\", \"p\", \"B$M.class\"));\n+\n+        \/\/tests for findIdent (must be in some global scope):\n+        doTest(\"\"\"\n+               package p;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.*;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               package p;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, p.Test, null)\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.*;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"1 error\");\n+\n+        \/\/tests for findIdentInPackage:\n+        doTest(\"\"\"\n+               import p.A;\n+               public class Test {\n+                   A a;\n+               }\n+               \"\"\",\n+               \"Test.java:1:9: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, A, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.A a;\n+               }\n+               \"\"\",\n+               \"Test.java:2:6: compiler.err.cant.access: p.A, (compiler.misc.bad.class.file.header: A.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               import p.C;\n+               public class Test {\n+                   C c;\n+               }\n+               \"\"\",\n+               \"Test.java:1:9: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.package, p, null)\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.C c;\n+               }\n+               \"\"\",\n+               \"Test.java:2:6: compiler.err.cant.resolve.location: kindname.class, C, , , (compiler.misc.location: kindname.package, p, null)\",\n+               \"1 error\");\n+\n+        \/\/tests for findIdentInType:\n+        doTest(\"\"\"\n+               import p.B.I;\n+               public class Test {\n+                   I i;\n+               }\n+               \"\"\",\n+               \"Test.java:1:11: compiler.err.cant.access: p.B.I, (compiler.misc.bad.class.file.header: B$I.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, I, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               import p.B.M;\n+               public class Test {\n+                   M m;\n+               }\n+               \"\"\",\n+               \"Test.java:1:11: compiler.err.cant.access: p.B.M, (compiler.misc.class.file.not.found: p.B$M)\",\n+               \"Test.java:3:5: compiler.err.cant.resolve.location: kindname.class, M, , , (compiler.misc.location: kindname.class, Test, null)\",\n+               \"2 errors\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.B.I i;\n+               }\n+               \"\"\",\n+               \"Test.java:2:8: compiler.err.cant.access: p.B.I, (compiler.misc.bad.class.file.header: B$I.class, (compiler.misc.illegal.start.of.class.file))\",\n+               \"1 error\");\n+        doTest(\"\"\"\n+               public class Test {\n+                   p.B.M m;\n+               }\n+               \"\"\",\n+               \"Test.java:2:8: compiler.err.cant.access: p.B.M, (compiler.misc.class.file.not.found: p.B$M)\",\n+               \"1 error\");\n+    }\n+\n+    void doTest(String code, String... expectedOutput) {\n+        List<String> log = new JavacTask(tb)\n+                .classpath(\".\")\n+                .sources(code)\n+                .options(\"-XDrawDiagnostics\")\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            if (e.getKind() != TaskEvent.Kind.ANALYZE) {\n+                                return ;\n+                            }\n+                            Trees trees = Trees.instance(task);\n+                            new TreePathScanner<Void, Void>() {\n+                                @Override\n+                                public Void visitIdentifier(IdentifierTree node, Void p) {\n+                                    validateAttributes();\n+                                    return super.visitIdentifier(node, p);\n+                                }\n+                                @Override\n+                                public Void visitMemberSelect(MemberSelectTree node, Void p) {\n+                                    if (!node.getIdentifier().contentEquals(\"*\")) {\n+                                        validateAttributes();\n+                                    }\n+                                    return super.visitMemberSelect(node, p);\n+                                }\n+                                void validateAttributes() {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    if (el == null) {\n+                                        throw new AssertionError(\"A null sym attribute for: \" + getCurrentPath().getLeaf() + \"!\");\n+                                    }\n+                                }\n+                            }.scan(e.getCompilationUnit(), null);\n+                        }\n+                    });\n+                })\n+                .run(expectedOutput != null ? Task.Expect.FAIL : Task.Expect.SUCCESS,\n+                     expectedOutput != null ? 1 : 0)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (expectedOutput != null && !log.equals(Arrays.asList(expectedOutput))) {\n+            throw new AssertionError(\"Unexpected output: \" + log);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/tree\/ASTAttributesFilledForReferencesOnMissingTypes.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8333748\n+ * @summary javap should not fail if reserved access flag bits are set to 1\n+ * @library \/tools\/lib\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n+ * @enablePreview\n+ * @run junit UndefinedAccessFlagTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UndefinedAccessFlagTest {\n+\n+    final ToolBox toolBox = new ToolBox();\n+\n+    enum TestLocation {\n+        NONE(false), CLASS, FIELD, METHOD, INNER_CLASS(false);\n+\n+        final boolean fails;\n+        TestLocation() { this(true); }\n+        TestLocation(boolean fails) { this.fails = fails; }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestLocation.class)\n+    void test(TestLocation location) throws Throwable {\n+        var cf = of();\n+        ClassModel cm;\n+        try (var is = UndefinedAccessFlagTest.class.getResourceAsStream(\n+            \"\/UndefinedAccessFlagTest$SampleInnerClass.class\"\n+        )) {\n+            cm = cf.parse(is.readAllBytes());\n+        }\n+        var bytes = cf.transformClass(cm, (cb, ce) -> {\n+            switch (ce) {\n+                case AccessFlags flags when location == TestLocation.CLASS -> cb\n+                    .withFlags(flags.flagsMask() | ACC_PRIVATE);\n+                case FieldModel f when location == TestLocation.FIELD -> cb\n+                    .transformField(f, (fb, fe) -> {\n+                        if (fe instanceof AccessFlags flags) {\n+                            fb.withFlags(flags.flagsMask() | ACC_SYNCHRONIZED);\n+                        } else {\n+                            fb.with(fe);\n+                        }\n+                    });\n+                case MethodModel m when location == TestLocation.METHOD -> cb\n+                    .transformMethod(m, (mb, me) -> {\n+                        if (me instanceof AccessFlags flags) {\n+                            mb.withFlags(flags.flagsMask() | ACC_INTERFACE);\n+                        } else {\n+                            mb.with(me);\n+                        }\n+                    });\n+                case InnerClassesAttribute attr when location == TestLocation.INNER_CLASS -> cb\n+                    .with(InnerClassesAttribute.of(attr.classes().stream()\n+                        .map(ic -> InnerClassInfo.of(ic.innerClass(), ic.outerClass(), ic.innerName(), ic.flagsMask() | 0x0020))\n+                        .toList()));\n+                default -> cb.with(ce);\n+            }\n+        });\n+\n+        Files.write(Path.of(\"transformed.class\"), bytes);\n+\n+        var lines = new JavapTask(toolBox)\n+            .classes(\"transformed.class\")\n+            .options(\"-c\", \"-p\", \"-v\")\n+            .run(location.fails ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        \/\/ No termination when access flag error happens\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"java.lang.String field;\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"UndefinedAccessFlagTest$SampleInnerClass();\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"void method();\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"SampleInnerClass=class UndefinedAccessFlagTest$SampleInnerClass of class UndefinedAccessFlagTest\")));\n+\n+        \/\/ Remove non-error lines\n+        assertTrue(lines.removeIf(st -> !st.startsWith(\"Error:\")));\n+        \/\/ Desired locations has errors\n+        assertTrue(location == TestLocation.NONE || !lines.isEmpty());\n+        \/\/ Access Flag errors only\n+        assertTrue(lines.stream().allMatch(l -> l.contains(\"Access Flags:\")), () -> String.join(\"\\n\", lines));\n+    }\n+\n+    static class SampleInnerClass {\n+        String field;\n+        void method() {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+import java.io.StringWriter;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+public class JNativeScanTestBase {\n+\n+    public static final String MODULE_PATH = \"mods\";\n+\n+    private static final ToolProvider JNATIVESCAN_TOOL = ToolProvider.findFirst(\"jnativescan\")\n+            .orElseThrow(() -> new RuntimeException(\"jnativescan tool not found\"));\n+\n+    public static OutputAnalyzer jnativescan(String... args) {\n+        return run(JNATIVESCAN_TOOL, args);\n+    }\n+\n+    private static OutputAnalyzer run(ToolProvider tp, String[] commands) {\n+        int rc;\n+        StringWriter sw = new StringWriter();\n+        StringWriter esw = new StringWriter();\n+\n+        try (PrintWriter pw = new PrintWriter(sw);\n+             PrintWriter epw = new PrintWriter(esw)) {\n+            System.out.println(\"Running \" + tp.name() + \", Command: \" + Arrays.toString(commands));\n+            rc = tp.run(pw, epw, commands);\n+        }\n+        OutputAnalyzer output = new OutputAnalyzer(sw.toString(), esw.toString(), rc);\n+        output.outputTo(System.out);\n+        output.errorTo(System.err);\n+        return output;\n+    }\n+\n+    public static Path makeModularJar(String moduleName) throws IOException {\n+        Path jarPath = Path.of(MODULE_PATH, moduleName + \".jar\");\n+        Path moduleRoot = moduleRoot(moduleName);\n+        JarUtils.createJarFile(jarPath, moduleRoot);\n+        return jarPath;\n+    }\n+\n+    public static Path moduleRoot(String name) {\n+        return Path.of(System.getProperty(\"test.module.path\")).resolve(name);\n+    }\n+\n+    public static OutputAnalyzer assertSuccess(OutputAnalyzer output) {\n+        if (output.getExitValue() != 0) {\n+            throw new IllegalStateException(\"tool run failed\");\n+        }\n+        return output;\n+    }\n+\n+    public static OutputAnalyzer assertFailure(OutputAnalyzer output) {\n+        if (output.getExitValue() == 0) {\n+            throw new IllegalStateException(\"tool run succeeded\");\n+        }\n+        return output;\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/JNativeScanTestBase.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     cases.classpath.arrayref.App\n+ * @run junit TestArrayTypeRefs\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestArrayTypeRefs extends JNativeScanTestBase {\n+\n+    static Path ARRAY_REF;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        ARRAY_REF = Path.of(\"arrayref.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(ARRAY_REF, testClasses, Path.of(\"arrayref\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", ARRAY_REF.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"<no restricted methods>\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestArrayTypeRefs.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     org.singlejar\/* org.lib\/* org.myapp\/* org.service\/*\n+ *     cases.classpath.singlejar.main.Main\n+ *     cases.classpath.lib.Lib\n+ *     cases.classpath.app.App\n+ *     cases.classpath.unnamed_package.UnnamedPackage\n+ * @run junit TestJNativeScan\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class TestJNativeScan extends JNativeScanTestBase {\n+\n+    static Path TEST_CLASSES;\n+\n+    static Path CLASS_PATH_APP;\n+    static Path SINGLE_JAR_CLASS_PATH;\n+    static Path SINGLE_JAR_MODULAR;\n+    static Path ORG_MYAPP;\n+    static Path ORG_LIB;\n+    static Path UNNAMED_PACKAGE_JAR;\n+    static Path LIB_JAR;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        SINGLE_JAR_CLASS_PATH = Path.of(\"singleJar.jar\");\n+        TEST_CLASSES = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(SINGLE_JAR_CLASS_PATH, TEST_CLASSES, Path.of(\"main\", \"Main.class\"));\n+\n+        LIB_JAR = Path.of(\"lib.jar\");\n+        JarUtils.createJarFile(LIB_JAR, TEST_CLASSES, Path.of(\"lib\", \"Lib.class\"));\n+        Manifest manifest = new Manifest();\n+        Attributes mainAttrs = manifest.getMainAttributes();\n+        mainAttrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\"); \/\/ need version or other attributes will be ignored\n+        mainAttrs.putValue(\"Class-Path\", \"lib.jar non-existent.jar\");\n+        CLASS_PATH_APP = Path.of(\"app.jar\");\n+        JarUtils.createJarFile(CLASS_PATH_APP, manifest, TEST_CLASSES, Path.of(\"app\", \"App.class\"));\n+\n+        SINGLE_JAR_MODULAR = makeModularJar(\"org.singlejar\");\n+        ORG_MYAPP = makeModularJar(\"org.myapp\");\n+        ORG_LIB = makeModularJar(\"org.lib\");\n+        makeModularJar(\"org.service\");\n+\n+        UNNAMED_PACKAGE_JAR = Path.of(\"unnamed_package.jar\");\n+        JarUtils.createJarFile(UNNAMED_PACKAGE_JAR, TEST_CLASSES, Path.of(\"UnnamedPackage.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", SINGLE_JAR_CLASS_PATH.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(\"main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testSingleJarModulePath() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"org.singlejar\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.singlejar\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testWithDepModule() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"org.myapp\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.lib\")\n+                .stdoutShouldContain(\"org.lib.Lib\")\n+                .stdoutShouldContain(\"org.lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\")\n+                .stdoutShouldContain(\"org.service\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testAllModulePath() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.singlejar\")\n+                .stdoutShouldContain(\"org.lib\")\n+                .stdoutShouldContain(\"org.service\");\n+    }\n+\n+    @Test\n+    public void testClassPathAttribute() {\n+        assertSuccess(jnativescan(\"--class-path\", CLASS_PATH_APP.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testInvalidRelease() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\", \"--release\", \"asdf\"))\n+                .stderrShouldContain(\"Invalid release\");\n+    }\n+\n+    @Test\n+    public void testReleaseNotSupported() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\", \"--release\", \"9999999\"))\n+                .stderrShouldContain(\"Release: 9999999 not supported\");\n+    }\n+\n+    @Test\n+    public void testFileDoesNotExist() {\n+        assertFailure(jnativescan(\"--class-path\", \"non-existent.jar\"))\n+                .stderrShouldContain(\"Path does not appear to be a jar file, or directory containing classes\");\n+    }\n+\n+    @Test\n+    public void testModuleNotAJarFile() {\n+        String modulePath = moduleRoot(\"org.myapp\").toString() + File.pathSeparator + ORG_LIB.toString();\n+        assertSuccess(jnativescan(\"--module-path\", modulePath,\n+                        \"--add-modules\", \"ALL-MODULE-PATH\"))\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testPrintNativeAccess() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH,\n+                                  \"-add-modules\", \"org.singlejar,org.myapp\",\n+                                  \"--print-native-access\"))\n+                .stdoutShouldMatch(\"org.lib,org.service,org.singlejar\");\n+    }\n+\n+    @Test\n+    public void testNoDuplicateNames() {\n+        String classPath = SINGLE_JAR_CLASS_PATH + File.pathSeparator + CLASS_PATH_APP;\n+        OutputAnalyzer output = assertSuccess(jnativescan(\"--class-path\", classPath, \"--print-native-access\"));\n+        String[] moduleNames = output.getStdout().split(\",\");\n+        Set<String> names = new HashSet<>();\n+        for (String name : moduleNames) {\n+            assertTrue(names.add(name.strip()));\n+        }\n+    }\n+\n+    @Test\n+    public void testUnnamedPackage() {\n+        assertSuccess(jnativescan(\"--class-path\", UNNAMED_PACKAGE_JAR.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldNotContain(\".UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"UnnamedPackage::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testPositionalArguments() {\n+        assertFailure(jnativescan(\"foo\"))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"jnativescan does not accept positional arguments\");\n+    }\n+\n+    @Test\n+    public void testMissingRootModules() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"Missing required option(s) [add-modules]\");\n+    }\n+\n+    @Test\n+    public void testClassPathDirectory() {\n+        assertSuccess(jnativescan(\"--class-path\", TEST_CLASSES.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"UnnamedPackage::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(\"main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testMultipleClassPathJars() {\n+        \/\/ make sure all of these are reported, even when they are all in the ALL-UNNAMED module\n+        String classPath = UNNAMED_PACKAGE_JAR\n+                + File.pathSeparator + SINGLE_JAR_CLASS_PATH\n+                + File.pathSeparator + LIB_JAR;\n+        assertSuccess(jnativescan(\"--class-path\", classPath))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(UNNAMED_PACKAGE_JAR.toString())\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(LIB_JAR.toString())\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(SINGLE_JAR_CLASS_PATH.toString());\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestJNativeScan.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ * @compile --release 20 cases\/classpath\/missingsystem\/App.java\n+ * @run junit TestMissingSystemClass\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestMissingSystemClass extends JNativeScanTestBase {\n+\n+    static Path MISSING_SYSTEM;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        MISSING_SYSTEM = Path.of(\"missingsystem.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(MISSING_SYSTEM, testClasses, Path.of(\"missingsystem\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertFailure(jnativescan(\"--class-path\", MISSING_SYSTEM.toString(), \"--release\", \"21\"))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"Error while processing method\")\n+                .stderrShouldContain(\"missingsystem.App::main(String[])void\")\n+                .stderrShouldContain(\"CAUSED BY:\")\n+                .stderrShouldContain(\"System class can not be found\")\n+                .stderrShouldContain(\"java.lang.Compiler\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestMissingSystemClass.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     cases.classpath.subclassref.App\n+ * @run junit TestSubclassRefs\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestSubclassRefs extends JNativeScanTestBase {\n+\n+    static Path SUBCLASS_REF;\n+\n+    @BeforeAll\n+    public static void before() throws IOException {\n+        SUBCLASS_REF = Path.of(\"subclassref.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(SUBCLASS_REF, testClasses, Path.of(\"subclassref\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", SUBCLASS_REF.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"<no restricted methods>\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestSubclassRefs.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package app;\n+\n+import lib.Lib;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        Lib.doIt();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/app\/App.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package arrayref;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        \/\/ reference an array method to see that\n+        \/\/ RestrictedMethodFinder correctly handles\n+        \/\/ references to array methods\n+        args.clone();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/arrayref\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package lib;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+public class Lib {\n+    public static void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/lib\/Lib.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package missingsystem;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        \/\/ this class was present in Java 20, but removed in 21\n+        \/\/ if we compile with --release 20, but run jnativescan\n+        \/\/ with --release 21, we should get an error\n+        java.lang.Compiler.enable();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/missingsystem\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package main;\n+\n+import java.lang.foreign.*;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/singlejar\/main\/Main.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package subclassref;\n+\n+import java.util.List;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        List<String> l = List.of(args);\n+        l.stream(); \/\/ List does not declare stream()\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/subclassref\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.*;\n+\n+public class UnnamedPackage {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/unnamed_package\/UnnamedPackage.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module org.lib {\n+    exports org.lib;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.lib;\n+\n+import java.lang.foreign.*;\n+\n+public class Lib {\n+    public static void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/org\/lib\/Lib.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.lib;\n+\n+public interface Service {\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/org\/lib\/Service.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module org.myapp {\n+    requires org.lib;\n+\n+    uses org.lib.Service;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.myapp\/module-info.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.myapp.main;\n+\n+import org.lib.Lib;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        Lib.doIt();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.myapp\/org\/myapp\/main\/Main.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.service {\n+    requires org.lib;\n+\n+    provides org.lib.Service with org.service.ServiceImpl;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.service\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.service;\n+\n+import org.lib.Service;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+public class ServiceImpl implements Service {\n+    public void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.service\/org\/service\/ServiceImpl.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.singlejar {\n+\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.singlejar\/module-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.singlejar.main;\n+\n+import java.lang.foreign.*;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.singlejar\/org\/singlejar\/main\/Main.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import static java.util.Locale.ROOT;\n@@ -137,1 +138,1 @@\n-        return osName.toLowerCase().startsWith(osname.toLowerCase());\n+        return osName.toLowerCase(ROOT).startsWith(osname.toLowerCase(ROOT));\n@@ -178,1 +179,1 @@\n-        return (jdkDebug.toLowerCase().contains(\"debug\"));\n+        return (jdkDebug.toLowerCase(ROOT).contains(\"debug\"));\n@@ -182,1 +183,1 @@\n-        return (jdkDebug.toLowerCase().equals(\"slowdebug\"));\n+        return (jdkDebug.toLowerCase(ROOT).equals(\"slowdebug\"));\n@@ -186,1 +187,1 @@\n-        return (jdkDebug.toLowerCase().equals(\"fastdebug\"));\n+        return (jdkDebug.toLowerCase(ROOT).equals(\"fastdebug\"));\n@@ -353,2 +354,2 @@\n-        if (System.getProperty(\"os.name\").toLowerCase().contains(\"linux\") &&\n-                System.getProperty(\"os.version\").toLowerCase().contains(\"el\")) {\n+        if (System.getProperty(\"os.name\").toLowerCase(ROOT).contains(\"linux\") &&\n+                System.getProperty(\"os.version\").toLowerCase(ROOT).contains(\"el\")) {\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -72,0 +72,10 @@\n+        testContainerized(m, inContainer);\n+    }\n+\n+    private void testContainerized(Metrics m, boolean inContainer) {\n+        if (m.isContainerized() != inContainer) {\n+            throw new RuntimeException(\"containerized test failed. \" +\n+                                       \"Expected isContainerized()==\" + inContainer +\n+                                       \" but got '\" + m.isContainerized() + \"'\");\n+        }\n+        System.out.println(\"testContainerized() PASSED!\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,0 +122,2 @@\n+  public native long getInUseMonitorCount();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Random;\n@@ -51,0 +52,23 @@\n+    @Param(\"500\")\n+    private int size;\n+\n+    private char[] chars;\n+    private char[] res;\n+\n+    @Setup\n+    public void setup() {\n+        Random r  = new Random(0);\n+        chars     = new char[size];\n+        res       = new char[size];\n+        for (int i = 0; i < size; i++) {\n+            chars[i] = (char)r.nextInt(Character.MAX_VALUE + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void reverseBytes() {\n+        for (int i = 0; i < size; i++) {\n+            res[i] = Character.reverseBytes(chars[i]);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Characters.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class Shorts {\n+\n+    @Param(\"500\")\n+    private int size;\n+\n+    private short[] shorts;\n+    private short[] res;\n+\n+    @Setup\n+    public void setup() {\n+        Random r  = new Random(0);\n+        shorts     = new short[size];\n+        res       = new short[size];\n+        for (int i = 0; i < size; i++) {\n+            shorts[i] = (short)(r.nextInt(Character.MAX_VALUE + 1) + Short.MIN_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void reverseBytes() {\n+        for (int i = 0; i < size; i++) {\n+            res[i] = Short.reverseBytes(shorts[i]);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Shorts.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -244,11 +244,60 @@\n-    public String toStringCharWithFloat8() {\n-        StringBuilder result = new StringBuilder();\n-        result.append(113.110F);\n-        result.append(156456.36435637F);\n-        result.append(65436434.64632F);\n-        result.append(42654634.64540F);\n-        result.append(63464351.64537F);\n-        result.append(634564.645711F);\n-        result.append(64547.64311F);\n-        result.append(4763456341.64531F);\n-        return result.toString();\n+    public int appendWithFloat8Latin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        buf.append(113.110F);\n+        buf.append(156456.36435637F);\n+        buf.append(65436434.64632F);\n+        buf.append(42654634.64540F);\n+        buf.append(63464351.64537F);\n+        buf.append(634564.645711F);\n+        buf.append(64547.64311F);\n+        buf.append(4763456341.64531F);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithFloat8Utf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        buf.append(113.110F);\n+        buf.append(156456.36435637F);\n+        buf.append(65436434.64632F);\n+        buf.append(42654634.64540F);\n+        buf.append(63464351.64537F);\n+        buf.append(634564.645711F);\n+        buf.append(64547.64311F);\n+        buf.append(4763456341.64531F);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithDouble8Latin1() {\n+        StringBuilder buf = sbLatin1;\n+        buf.setLength(0);\n+        buf.append(0.3005216476500575D);\n+        buf.append(0.39727691577802204D);\n+        buf.append(0.9869700323149287D);\n+        buf.append(42654634.645403256D);\n+        buf.append(63464351.645371353D);\n+        buf.append(634564.645711246D);\n+        buf.append(64547.6431172363D);\n+        buf.append(4763456341.64531675D);\n+        return buf.length();\n+    }\n+\n+\n+    @Benchmark\n+    public int appendWithDouble8Utf16() {\n+        StringBuilder buf = sbUtf16;\n+        buf.setLength(0);\n+        buf.append(0.3005216476500575D);\n+        buf.append(0.39727691577802204D);\n+        buf.append(0.9869700323149287D);\n+        buf.append(42654634.645403256D);\n+        buf.append(63464351.645371353D);\n+        buf.append(634564.645711246D);\n+        buf.append(64547.6431172363D);\n+        buf.append(4763456341.64531675D);\n+        return buf.length();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringBuilders.java","additions":60,"deletions":11,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-            bh.consume(cc.transform(cc.parse(bytes), transform.transform));\n+            bh.consume(cc.transformClass(cc.parse(bytes), transform.transform));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdHocAdapt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-        bh.consume(sharedCP.transform(benchModel, threeLevelNoop));\n+        bh.consume(sharedCP.transformClass(benchModel, threeLevelNoop));\n@@ -108,1 +108,1 @@\n-        bh.consume(newCP.transform(benchModel, threeLevelNoop));\n+        bh.consume(newCP.transformClass(benchModel, threeLevelNoop));\n@@ -114,1 +114,1 @@\n-        bh.consume(sharedCP.transform(benchModel, addNOP));\n+        bh.consume(sharedCP.transformClass(benchModel, addNOP));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ClassfileBenchmark.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-            bh.consume(cc.transform(cm, threeLevelNoop));\n+            bh.consume(cc.transformClass(cm, threeLevelNoop));\n@@ -55,1 +55,1 @@\n-            bh.consume(cc.transform(cm, threeLevelNoop));\n+            bh.consume(cc.transformClass(cm, threeLevelNoop));\n@@ -65,1 +65,1 @@\n-            bh.consume(cc.transform(cm, threeLevelNoop));\n+            bh.consume(cc.transformClass(cm, threeLevelNoop));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ParseOptions.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-        cc.transform(clm, ClassTransform.transformingMethodBodies((cob, coe) -> {\n+        cc.transformClass(clm, ClassTransform.transformingMethodBodies((cob, coe) -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RebuildMethodBodies.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-            this.transform = bytes -> cc.transform(cc.parse(bytes), classTransform);\n+            this.transform = bytes -> cc.transformClass(cc.parse(bytes), classTransform);\n@@ -201,1 +201,1 @@\n-            return cc.transform(cm, (cb, ce) -> {\n+            return cc.transformClass(cm, (cb, ce) -> {\n@@ -242,1 +242,1 @@\n-            return cc.transform(cm, new ClassTransform() {\n+            return cc.transformClass(cm, new ClassTransform() {\n@@ -280,1 +280,1 @@\n-            return cc.transform(cm, (builder, element) -> {\n+            return cc.transformClass(cm, (builder, element) -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.vm.compiler;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.random.RandomGeneratorFactory;\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@Fork(value = 1)\n-public class CMove {\n-    static final int SIZE = 1000000;\n-\n-    @Param({\"0.003\", \"0.006\", \"0.01\", \"0.02\", \"0.03\", \"0.06\", \"0.1\", \"0.2\", \"0.3\", \"0.6\"})\n-    double freq;\n-\n-    boolean[] conds;\n-\n-    @Setup(Level.Iteration)\n-    public void setup() {\n-        var r = RandomGeneratorFactory.getDefault().create(1);\n-        conds = new boolean[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            conds[i] = r.nextDouble() < freq;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void run(Blackhole bh) {\n-        for (int i = 0; i < conds.length; i++) {\n-            bh.consume(conds[i] ? 2 : 1);\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/CMove.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorLoadToStoreForwarding {\n+    @Param({\"2048\"})\n+    public int SIZE;\n+\n+    private int[] aI;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aI = new int[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            aI[i] = r.nextInt();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_00() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 0] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_01() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 1] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_02() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 2] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_03() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 3] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_04() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 4] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_05() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 5] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_06() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 6] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_07() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 7] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_08() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 8] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_09() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 9] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_10() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 10] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_11() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 11] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_12() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 12] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_13() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 13] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_14() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 14] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_15() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 15] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_16() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 16] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_17() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 17] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_18() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 18] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_19() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 19] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void benchmark_20() {\n+        for (int i = 20; i < SIZE; i++) {\n+            aI[i] = aI[i - 20] + 1;\n+        }\n+    }\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class VectorLoadToStoreForwardingSuperWord extends VectorLoadToStoreForwarding {}\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class VectorLoadToStoreForwardingNoSuperWord extends VectorLoadToStoreForwarding {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorLoadToStoreForwarding.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"}]}