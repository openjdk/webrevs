{"files":[{"patch":"@@ -329,10 +329,0 @@\n-\n-        if (!env.info.ctorPrologue &&\n-                v.isStrict() &&\n-                v.owner.kind == TYP &&\n-                v.owner == env.enclClass.sym &&\n-                (v.flags() & STATIC) == 0 &&\n-                (base == null ||\n-                        TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))) {\n-            log.error(pos, Errors.CantRefAfterCtorCalled(v));\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3095,0 +3095,11 @@\n+                    \/\/ strict fields should have been initialized at this point\n+                    for (int i = firstadr; i < nextadr; i++) {\n+                        JCVariableDecl vardecl = vardecls[i];\n+                        VarSymbol var = vardecl.sym;\n+                        boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                var.owner.kind == TYP;\n+                        if (var.owner == classDef.sym && !var.isStatic() && var.isStrict() && !isInstanceRecordField) {\n+                            checkInit(TreeInfo.diagEndPos(tree), var, Errors.StrictFieldNotHaveBeenInitializedBeforeSuper(var));\n+                        }\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4259,4 +4259,0 @@\n-# 0: symbol or name\n-compiler.err.cant.ref.after.ctor.called=\\\n-    cannot assign to {0} after supertype constructor has been called\n-\n@@ -4267,0 +4263,4 @@\n+compiler.err.strict.field.not.have.been.initialized.before.super=\\\n+    strict field {0} is not initialized before the supertype constructor has been called\n+\n+# 0: symbol\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.cant.ref.after.ctor.called\n+\/\/ key: compiler.err.strict.field.not.have.been.initialized.before.super\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FieldAssigmentAfterSuper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.strict.field.not.have.been.initialized.before.super\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+value class Point {\n+    int x;\n+    int y;\n+    Point (int x, int y) {\n+        this.x = x;\n+        \/\/ y hasn't been initialized\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StrictFieldNotInitialized.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -334,1 +334,1 @@\n-                    \"compiler.err.var.might.not.have.been.initialized\",\n+                    \"compiler.err.strict.field.not.have.been.initialized.before.super\",\n@@ -894,1 +894,1 @@\n-        assertFail(\"compiler.err.cant.ref.after.ctor.called\",\n+        assertFail(\"compiler.err.strict.field.not.have.been.initialized.before.super\",\n@@ -927,1 +927,1 @@\n-        assertFail(\"compiler.err.cant.ref.after.ctor.called\",\n+        assertFail(\"compiler.err.strict.field.not.have.been.initialized.before.super\",\n@@ -1098,1 +1098,1 @@\n-            assertFail(\"compiler.err.var.not.initialized.in.default.constructor\",\n+            assertFail(\"compiler.err.strict.field.not.have.been.initialized.before.super\",\n@@ -1106,1 +1106,1 @@\n-            assertFail(\"compiler.err.cant.ref.after.ctor.called\",\n+            assertFail(\"compiler.err.strict.field.not.have.been.initialized.before.super\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}