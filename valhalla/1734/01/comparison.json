{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.value.ValueClass;\n@@ -1714,9 +1713,2 @@\n-        while (true) {\n-            Object witness = getFlatValueVolatile(o, offset, layout, valueType);\n-            if (witness != expected) {\n-                return false;\n-            }\n-            if (compareAndSetFlatValueAsBytes(o, offset, layout, valueType, witness, x)) {\n-                return true;\n-            }\n-        }\n+        Object[] array = newSpecialArray(valueType, 2, layout);\n+        return compareAndSetFlatValueAsBytes(array, o, offset, layout, valueType, expected, x);\n@@ -1756,9 +1748,3 @@\n-        while (true) {\n-            Object witness = getFlatValueVolatile(o, offset, layout, valueType);\n-            if (witness != expected) {\n-                return witness;\n-            }\n-            if (compareAndSetFlatValueAsBytes(o, offset, layout, valueType, witness, x)) {\n-                return witness;\n-            }\n-        }\n+        Object[] array = newSpecialArray(valueType, 2, layout);\n+        compareAndSetFlatValueAsBytes(array, o, offset, layout, valueType, expected, x);\n+        return array[0];\n@@ -2880,1 +2866,1 @@\n-    private boolean compareAndSetFlatValueAsBytes(Object o, long offset, int layout, Class<?> valueType, Object expected, Object x) {\n+    private boolean compareAndSetFlatValueAsBytes(Object[] array, Object o, long offset, int layout, Class<?> valueType, Object expected, Object x) {\n@@ -2886,6 +2872,8 @@\n-        Object[] expectedArray = newSpecialArray(valueType, 1, layout);\n-        Object xArray = newSpecialArray(valueType, 1, layout);\n-        long base = arrayInstanceBaseOffset(expectedArray);\n-        int scale = arrayInstanceIndexScale(expectedArray);\n-        putFlatValue(expectedArray, base, layout, valueType, expected);\n-        putFlatValue(xArray, base, layout, valueType, x);\n+\n+        \/\/ array 0: witness (to translate to object), 1: x (to translate to raw)\n+        \/\/ caller pass the array so it can capture the witness if needed\n+        \/\/ we must witness the raw value instead of the value object, otherwise\n+        \/\/ garbage value can cause failure\n+        long base = arrayInstanceBaseOffset(array);\n+        int scale = arrayInstanceIndexScale(array);\n+        putFlatValue(array, base + scale, layout, valueType, x); \/\/ translate x to raw bytes\n@@ -2894,3 +2882,12 @@\n-                byte expectedByte = getByte(expectedArray, base);\n-                byte xByte = getByte(xArray, base);\n-                return compareAndSetByte(o, offset, expectedByte, xByte);\n+                do {\n+                    byte witnessByte = getByteVolatile(o, offset);\n+                    putByte(array, base, witnessByte); \/\/ translate witness to value object\n+                    Object witness = getFlatValue(array, base, layout, valueType);\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    byte xByte = getByte(array, base + scale);\n+                    if (compareAndSetByte(o, offset, witnessByte, xByte)) {\n+                        return true;\n+                    }\n+                } while (true);\n@@ -2899,3 +2896,12 @@\n-                short expectedShort = getShort(expectedArray, base);\n-                short xShort = getShort(xArray, base);\n-                return compareAndSetShort(o, offset, expectedShort, xShort);\n+                do {\n+                    short witnessShort = getShortVolatile(o, offset);\n+                    putShort(array, base, witnessShort); \/\/ translate witness to value object\n+                    Object witness = getFlatValue(array, base, layout, valueType);\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    short xShort = getShort(array, base + scale);\n+                    if (compareAndSetShort(o, offset, witnessShort, xShort)) {\n+                        return true;\n+                    }\n+                } while (true);\n@@ -2904,3 +2910,12 @@\n-                int expectedInt = getInt(expectedArray, base);\n-                int xInt = getInt(xArray, base);\n-                return compareAndSetInt(o, offset, expectedInt, xInt);\n+                do {\n+                    int witnessInt = getIntVolatile(o, offset);\n+                    putInt(array, base, witnessInt); \/\/ translate witness to value object\n+                    Object witness = getFlatValue(array, base, layout, valueType);\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    int xInt = getInt(array, base + scale);\n+                    if (compareAndSetInt(o, offset, witnessInt, xInt)) {\n+                        return true;\n+                    }\n+                } while (true);\n@@ -2909,3 +2924,12 @@\n-                long expectedLong = getLong(expectedArray, base);\n-                long xLong = getLong(xArray, base);\n-                return compareAndSetLong(o, offset, expectedLong, xLong);\n+                do {\n+                    long witnessLong = getLongVolatile(o, offset);\n+                    putLong(array, base, witnessLong); \/\/ translate witness to value object\n+                    Object witness = getFlatValue(array, base, layout, valueType);\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    long xLong = getLong(array, base + scale);\n+                    if (compareAndSetLong(o, offset, witnessLong, xLong)) {\n+                        return true;\n+                    }\n+                } while (true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":62,"deletions":38,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.internal.misc.Unsafe;\n+\n+import java.lang.reflect.Field;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.valhalla.inlinetypes.TestCompareAndExchange\n+ *\/\n+\n+\/*\n+ * My command line: java -cp \/home\/chagedor\/JTwork\/classes\/compiler\/valhalla\/inlinetypes\/TestCompareAndExchange.d:\/home\/chagedor\/valhalla3\/open\/test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes:\/home\/chagedor\/JTwork\/classes\/compiler\/valhalla\/inlinetypes\/TestCompareAndExchange.d\/test\/lib:\/home\/chagedor\/valhalla3\/open\/test\/lib:\/home\/chagedor\/valhalla3\/open\/test\/hotspot\/jtreg:\/home\/chagedor\/jtreg\/lib\/javatest.jar:\/home\/chagedor\/jtreg\/lib\/jtreg.jar -Djava.library.path=. -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Dir.framework.server.port=35391 --enable-preview --add-exports java.base\/jdk.internal.value=ALL-UNNAMED --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED -XX:-BackgroundCompilation -DWarmup=10000 -XX:CompileCommand=dontinline,*Unsafe*::getFlatValue* -XX:CompileCommand=dontinline,*Unsafe*::putFlatValue* -DIgnoreCompilerControls=true -XX:-TieredCompilation -XX:CompileOnly=*Small*::*,*::test70 -XX:CompileCommand=dontinline,*Unsafe::array* -XX:DisableIntrinsic=_compareAndSetLong,_compareAndSetInt,_compareAndSetByte,_compareAndSetShort -DReproduce=true compiler.lib.ir_framework.test.TestVM compiler.valhalla.inlinetypes.TestCompareAndExchange\n+ *\/\n+@ForceCompileClassInitializer\n+public class TestCompareAndExchange {\n+\n+\n+    public static void main(String[] args) {\n+        InlineTypes.getFramework()\n+                .addFlags(\"--enable-preview\",\n+                          \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                          \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                          \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\")\n+                .addFlags(\"-XX:-BackgroundCompilation -DWarmup=10000 -XX:CompileCommand=dontinline,*Unsafe*::getFlatValue* -XX:CompileCommand=dontinline,*Unsafe*::putFlatValue* -DIgnoreCompilerControls=true -XX:-TieredCompilation -XX:CompileOnly=*Small*::*,*::test70 -XX:CompileCommand=dontinline,*Unsafe::array* -XX:DisableIntrinsic=_compareAndSetLong,_compareAndSetInt,_compareAndSetByte,_compareAndSetShort -DReproduce=true\".split(\" \"))\n+                .start();\n+    }\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+\n+    static public value class SmallValue {\n+        byte a = (byte)0x12;\n+        byte b = (byte)0x34;\n+        byte c = (byte)0x56;\n+        byte d = (byte)0x78;\n+        byte e = (byte)0x9a;\n+\n+        @ForceInline\n+        static SmallValue create() {\n+            return new SmallValue();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"a: \" + a + \", b: \" + b;\n+        }\n+    }\n+\n+    SmallValue test63_vt;\n+    private static final long TEST63_VT_OFFSET;\n+    static {\n+        try {\n+            Field test63_vt_Field = TestCompareAndExchange.class.getDeclaredField(\"test63_vt\");\n+            TEST63_VT_OFFSET = U.objectFieldOffset(test63_vt_Field);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object, non-inline arguments to compare and set\n+    @Test\n+    public Object test70(Object expected, Object x) {\n+        return U.compareAndExchangeFlatValue(this, TEST63_VT_OFFSET, 4, SmallValue.class, expected, x);\n+    }\n+\n+    @Run(test = \"test70\")\n+    public void test70_verifier() {\n+        test63_vt = SmallValue.create();\n+        test70(SmallValue.create(), SmallValue.create());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCompareAndExchange.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -802,2 +802,0 @@\n-java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessValue.java 8367346 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}