{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.value.ValueClass;\n@@ -1714,9 +1713,2 @@\n-        while (true) {\n-            Object witness = getFlatValueVolatile(o, offset, layout, valueType);\n-            if (witness != expected) {\n-                return false;\n-            }\n-            if (compareAndSetFlatValueAsBytes(o, offset, layout, valueType, witness, x)) {\n-                return true;\n-            }\n-        }\n+        Object[] array = newSpecialArray(valueType, 2, layout);\n+        return compareAndSetFlatValueAsBytes(array, o, offset, layout, valueType, expected, x);\n@@ -1756,9 +1748,3 @@\n-        while (true) {\n-            Object witness = getFlatValueVolatile(o, offset, layout, valueType);\n-            if (witness != expected) {\n-                return witness;\n-            }\n-            if (compareAndSetFlatValueAsBytes(o, offset, layout, valueType, witness, x)) {\n-                return witness;\n-            }\n-        }\n+        Object[] array = newSpecialArray(valueType, 2, layout);\n+        compareAndSetFlatValueAsBytes(array, o, offset, layout, valueType, expected, x);\n+        return array[0];\n@@ -2880,12 +2866,13 @@\n-    private boolean compareAndSetFlatValueAsBytes(Object o, long offset, int layout, Class<?> valueType, Object expected, Object x) {\n-        \/\/ We turn the payload of an atomic value into a numeric value (of suitable type)\n-        \/\/ by storing the value into an array element (of matching layout) and by reading\n-        \/\/ back the array element as an integral value. After which we can implement the CAS\n-        \/\/ as a plain numeric CAS. Note: this only works if the payload contains no oops\n-        \/\/ (see VarHandles::isAtomicFlat).\n-        Object[] expectedArray = newSpecialArray(valueType, 1, layout);\n-        Object xArray = newSpecialArray(valueType, 1, layout);\n-        long base = arrayInstanceBaseOffset(expectedArray);\n-        int scale = arrayInstanceIndexScale(expectedArray);\n-        putFlatValue(expectedArray, base, layout, valueType, expected);\n-        putFlatValue(xArray, base, layout, valueType, x);\n+    private boolean compareAndSetFlatValueAsBytes(Object[] array, Object o, long offset, int layout, Class<?> valueType, Object expected, Object x) {\n+        \/\/ We can convert between a value object and a binary value (of suitable size) using array elements.\n+        \/\/ This only works if the payload contains no oops (see VarHandles::isAtomicFlat).\n+        \/\/ Thus, we can implement the CAS with a plain numeric CAS.\n+\n+        \/\/ array[0]: witness (put as binary, get as object), at base\n+        \/\/ array[1]: x (put as object, get as binary), at base + scale\n+        \/\/ When witness == expected, the witness binary may be different from the expected binary.\n+        \/\/ This happens when compiler does not zero unused positions in the witness.\n+        \/\/ So we must obtain the witness binary and use it as expected binary for the numeric CAS.\n+        long base = arrayInstanceBaseOffset(array);\n+        int scale = arrayInstanceIndexScale(array);\n+        putFlatValue(array, base + scale, layout, valueType, x); \/\/ put x as object\n@@ -2894,3 +2881,12 @@\n-                byte expectedByte = getByte(expectedArray, base);\n-                byte xByte = getByte(xArray, base);\n-                return compareAndSetByte(o, offset, expectedByte, xByte);\n+                do {\n+                    byte witnessByte = getByteVolatile(o, offset);\n+                    putByte(array, base, witnessByte); \/\/ put witness as binary\n+                    Object witness = getFlatValue(array, base, layout, valueType); \/\/ get witness as object\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    byte xByte = getByte(array, base + scale); \/\/ get x as binary\n+                    if (compareAndSetByte(o, offset, witnessByte, xByte)) {\n+                        return true;\n+                    }\n+                } while (true);\n@@ -2899,3 +2895,12 @@\n-                short expectedShort = getShort(expectedArray, base);\n-                short xShort = getShort(xArray, base);\n-                return compareAndSetShort(o, offset, expectedShort, xShort);\n+                do {\n+                    short witnessShort = getShortVolatile(o, offset);\n+                    putShort(array, base, witnessShort); \/\/ put witness as binary\n+                    Object witness = getFlatValue(array, base, layout, valueType); \/\/ get witness as object\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    short xShort = getShort(array, base + scale); \/\/ get x as binary\n+                    if (compareAndSetShort(o, offset, witnessShort, xShort)) {\n+                        return true;\n+                    }\n+                } while (true);\n@@ -2904,3 +2909,12 @@\n-                int expectedInt = getInt(expectedArray, base);\n-                int xInt = getInt(xArray, base);\n-                return compareAndSetInt(o, offset, expectedInt, xInt);\n+                do {\n+                    int witnessInt = getIntVolatile(o, offset);\n+                    putInt(array, base, witnessInt); \/\/ put witness as binary\n+                    Object witness = getFlatValue(array, base, layout, valueType); \/\/ get witness as object\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    int xInt = getInt(array, base + scale); \/\/ get x as binary\n+                    if (compareAndSetInt(o, offset, witnessInt, xInt)) {\n+                        return true;\n+                    }\n+                } while (true);\n@@ -2909,3 +2923,12 @@\n-                long expectedLong = getLong(expectedArray, base);\n-                long xLong = getLong(xArray, base);\n-                return compareAndSetLong(o, offset, expectedLong, xLong);\n+                do {\n+                    long witnessLong = getLongVolatile(o, offset);\n+                    putLong(array, base, witnessLong); \/\/ put witness as binary\n+                    Object witness = getFlatValue(array, base, layout, valueType);\n+                    if (witness != expected) {\n+                        return false;\n+                    }\n+                    long xLong = getLong(array, base + scale); \/\/ get x as binary\n+                    if (compareAndSetLong(o, offset, witnessLong, xLong)) {\n+                        return true;\n+                    }\n+                } while (true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":66,"deletions":43,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -801,2 +801,0 @@\n-java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessValue.java 8367346 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}