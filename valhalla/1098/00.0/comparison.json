{"files":[{"patch":"@@ -140,1 +140,1 @@\n-        DISABLED_WARNINGS := $(DISABLED_WARNINGS_java), \\\n+        DISABLED_WARNINGS := $(DISABLED_WARNINGS_java) preview, \\\n","filename":"make\/CompileJavaModules.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,5 +144,0 @@\n-\n-  # Workaround stylesheet bug\n-  HEADER_STYLE := style=\"margin-top: 9px;\"\n-else\n-  HEADER_STYLE := style=\"margin-top: 14px;\"\n@@ -344,1 +339,1 @@\n-  $1_HEADER_TITLE := <div $$(HEADER_STYLE)><strong>$$($1_SHORT_NAME)<\/strong> \\\n+  $1_HEADER_TITLE := <div><strong>$$($1_SHORT_NAME)<\/strong> \\\n@@ -652,1 +647,1 @@\n-  HEADER_RIGHT_SIDE_INFO := <strong>$(subst &amp;,&,$(JDK_SHORT_NAME))$(DRAFT_MARKER_STR)<\/strong>\n+  HEADER_RIGHT_SIDE_INFO := <strong>$(subst &amp;,&,$(JDK_SHORT_NAME))<\/strong>$(DRAFT_MARKER_STR)\n","filename":"make\/Docs.gmk","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -972,4 +972,10 @@\n-  # The ct.sym generation uses all the moduleinfos as input\n-  jdk.compiler-gendata: $(GENSRC_MODULEINFO_TARGETS) $(JAVA_TARGETS)\n-  # jdk.compiler-gendata needs the BUILD_JDK. If the BUILD_JDK was supplied\n-  # externally, no extra prerequisites are needed.\n+  # jdk.compiler gendata generates ct.sym, which requires all generated\n+  # java source and compiled classes present.\n+  jdk.compiler-gendata: $(JAVA_TARGETS)\n+\n+  # jdk.javadoc gendata generates element-list, which requires all java sources\n+  # but not compiled classes.\n+  jdk.javadoc-gendata: $(GENSRC_TARGETS)\n+\n+  # ct.sym and element-list generation also needs the BUILD_JDK. If the\n+  # BUILD_JDK was supplied externally, no extra prerequisites are needed.\n@@ -981,0 +987,1 @@\n+      jdk.javadoc-gendata: create-buildjdk\n@@ -986,0 +993,1 @@\n+    jdk.javadoc-gendata: jdk.compiler-launchers\n","filename":"make\/Main.gmk","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,5 @@\n-DISABLED_WARNINGS_java += this-escape restricted preview\n+# The base module should be built with all warnings enabled. When a\n+# new warning is added to javac, it can be temporarily added to the\n+# disabled warnings list.\n+#\n+DISABLED_WARNINGS_java +=\n@@ -40,1 +44,2 @@\n-    java\/lang\/classfile\/components\/snippet-files\n+    java\/lang\/classfile\/components\/snippet-files \\\n+    java\/lang\/foreign\/snippet-files\n","filename":"make\/modules\/java.base\/Java.gmk","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+        -XDsuppressNotes \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2381,1 +2381,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n@@ -4698,1 +4698,1 @@\n-\/\/ nullptr Pointer Immediate\n+\/\/ Null Pointer Immediate\n@@ -4830,1 +4830,1 @@\n-\/\/ Narrow nullptr Pointer Immediate\n+\/\/ Narrow Null Pointer Immediate\n@@ -7254,1 +7254,1 @@\n-  format %{ \"mov  $dst, $con\\t# nullptr ptr\" %}\n+  format %{ \"mov  $dst, $con\\t# null pointer\" %}\n@@ -7268,1 +7268,1 @@\n-  format %{ \"mov  $dst, $con\\t# nullptr ptr\" %}\n+  format %{ \"mov  $dst, $con\\t# null pointer\" %}\n@@ -7310,1 +7310,1 @@\n-  format %{ \"mov  $dst, $con\\t# compressed nullptr ptr\" %}\n+  format %{ \"mov  $dst, $con\\t# compressed null pointer\" %}\n@@ -8324,1 +8324,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishld\" %}\n@@ -8378,1 +8378,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishst\\n\\tdmb ishld\" %}\n@@ -8382,1 +8382,2 @@\n-    __ membar(Assembler::LoadStore|Assembler::StoreStore);\n+    __ membar(Assembler::StoreStore);\n+    __ membar(Assembler::LoadStore);\n@@ -17191,17 +17192,1 @@\n-                     $result$$Register, $cnt$$Register, 1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_equalsU(iRegP_R1 str1, iRegP_R3 str2, iRegI_R4 cnt,\n-                        iRegI_R0 result, rFlagsReg cr)\n-%{\n-  predicate(((StrEqualsNode*)n)->encoding() == StrIntrinsicNode::UU);\n-  match(Set result (StrEquals (Binary str1 str2) cnt));\n-  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL cr);\n-\n-  format %{ \"String Equals $str1,$str2,$cnt -> $result\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_equals($str1$$Register, $str2$$Register,\n-                     $result$$Register, $cnt$$Register, 2);\n+                     $result$$Register, $cnt$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":11,"deletions":26,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -847,5 +847,3 @@\n-      if (StubRoutines::dlog() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc->args());\n-      }\n+      \/\/ Math.log intrinsic is not implemented on AArch64 (see JDK-8210858),\n+      \/\/ but we can still call the shared runtime.\n+      __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc->args());\n@@ -854,5 +852,1 @@\n-      if (StubRoutines::dlog10() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc->args());\n-      }\n+      __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc->args());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ The object's monitor m is unlocked iff m->owner == nullptr,\n@@ -145,1 +145,1 @@\n-  \/\/ Try to CAS m->owner from NULL to current thread.\n+  \/\/ Try to CAS m->owner from null to current thread.\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-  product(ccstr, OnSpinWaitInst, \"none\", DIAGNOSTIC,                    \\\n+  product(ccstr, OnSpinWaitInst, \"yield\", DIAGNOSTIC,                   \\\n@@ -133,0 +133,2 @@\n+  product(bool, AlwaysMergeDMB, false, DIAGNOSTIC,                      \\\n+          \"Always merge DMB instructions in code emission\")             \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2235,7 +2235,12 @@\n-    \/\/ We are merging two memory barrier instructions.  On AArch64 we\n-    \/\/ can do this simply by ORing them together.\n-    bar->set_kind(bar->get_kind() | order_constraint);\n-    BLOCK_COMMENT(\"merged membar\");\n-  } else {\n-    code()->set_last_insn(pc());\n-    dmb(Assembler::barrier(order_constraint));\n+    \/\/ Don't promote DMB ST|DMB LD to DMB (a full barrier) because\n+    \/\/ doing so would introduce a StoreLoad which the caller did not\n+    \/\/ intend\n+    if (AlwaysMergeDMB || bar->get_kind() == order_constraint\n+        || bar->get_kind() == AnyAny\n+        || order_constraint == AnyAny) {\n+      \/\/ We are merging two memory barrier instructions.  On AArch64 we\n+      \/\/ can do this simply by ORing them together.\n+      bar->set_kind(bar->get_kind() | order_constraint);\n+      BLOCK_COMMENT(\"merged membar\");\n+      return;\n+    }\n@@ -2243,0 +2248,2 @@\n+  code()->set_last_insn(pc());\n+  dmb(Assembler::barrier(order_constraint));\n@@ -4427,0 +4434,2 @@\n+    \/\/ Registers v0..v7 are used as data registers.\n+    \/\/ Registers v16..v31 are used as tmp registers.\n@@ -4428,14 +4437,15 @@\n-    ldrq(v1, Address(buf, 0x10));\n-    ldrq(v2, Address(buf, 0x20));\n-    ldrq(v3, Address(buf, 0x30));\n-    ldrq(v4, Address(buf, 0x40));\n-    ldrq(v5, Address(buf, 0x50));\n-    ldrq(v6, Address(buf, 0x60));\n-    ldrq(v7, Address(buf, 0x70));\n-    ldrq(v8, Address(pre(buf, 0x80)));\n-\n-    movi(v25, T4S, 0);\n-    mov(v25, S, 0, crc);\n-    eor(v1, T16B, v1, v25);\n-\n-    ldrq(v0, Address(table));\n+    ldrq(v0, Address(buf, 0x10));\n+    ldrq(v1, Address(buf, 0x20));\n+    ldrq(v2, Address(buf, 0x30));\n+    ldrq(v3, Address(buf, 0x40));\n+    ldrq(v4, Address(buf, 0x50));\n+    ldrq(v5, Address(buf, 0x60));\n+    ldrq(v6, Address(buf, 0x70));\n+    ldrq(v7, Address(pre(buf, 0x80)));\n+\n+    movi(v31, T4S, 0);\n+    mov(v31, S, 0, crc);\n+    eor(v0, T16B, v0, v31);\n+\n+    \/\/ Register v16 contains constants from the crc table.\n+    ldrq(v16, Address(table));\n@@ -4446,39 +4456,41 @@\n-    pmull (v9,  T1Q, v1, v0, T1D);\n-    pmull2(v10, T1Q, v1, v0, T2D);\n-    ldrq(v1, Address(buf, 0x10));\n-    eor3(v1, T16B, v9,  v10, v1);\n-\n-    pmull (v11, T1Q, v2, v0, T1D);\n-    pmull2(v12, T1Q, v2, v0, T2D);\n-    ldrq(v2, Address(buf, 0x20));\n-    eor3(v2, T16B, v11, v12, v2);\n-\n-    pmull (v13, T1Q, v3, v0, T1D);\n-    pmull2(v14, T1Q, v3, v0, T2D);\n-    ldrq(v3, Address(buf, 0x30));\n-    eor3(v3, T16B, v13, v14, v3);\n-\n-    pmull (v15, T1Q, v4, v0, T1D);\n-    pmull2(v16, T1Q, v4, v0, T2D);\n-    ldrq(v4, Address(buf, 0x40));\n-    eor3(v4, T16B, v15, v16, v4);\n-\n-    pmull (v17, T1Q, v5, v0, T1D);\n-    pmull2(v18, T1Q, v5, v0, T2D);\n-    ldrq(v5, Address(buf, 0x50));\n-    eor3(v5, T16B, v17, v18, v5);\n-\n-    pmull (v19, T1Q, v6, v0, T1D);\n-    pmull2(v20, T1Q, v6, v0, T2D);\n-    ldrq(v6, Address(buf, 0x60));\n-    eor3(v6, T16B, v19, v20, v6);\n-\n-    pmull (v21, T1Q, v7, v0, T1D);\n-    pmull2(v22, T1Q, v7, v0, T2D);\n-    ldrq(v7, Address(buf, 0x70));\n-    eor3(v7, T16B, v21, v22, v7);\n-\n-    pmull (v23, T1Q, v8, v0, T1D);\n-    pmull2(v24, T1Q, v8, v0, T2D);\n-    ldrq(v8, Address(pre(buf, 0x80)));\n-    eor3(v8, T16B, v23, v24, v8);\n+    pmull (v17,  T1Q, v0, v16, T1D);\n+    pmull2(v18, T1Q, v0, v16, T2D);\n+    ldrq(v0, Address(buf, 0x10));\n+    eor3(v0, T16B, v17,  v18, v0);\n+\n+    pmull (v19, T1Q, v1, v16, T1D);\n+    pmull2(v20, T1Q, v1, v16, T2D);\n+    ldrq(v1, Address(buf, 0x20));\n+    eor3(v1, T16B, v19, v20, v1);\n+\n+    pmull (v21, T1Q, v2, v16, T1D);\n+    pmull2(v22, T1Q, v2, v16, T2D);\n+    ldrq(v2, Address(buf, 0x30));\n+    eor3(v2, T16B, v21, v22, v2);\n+\n+    pmull (v23, T1Q, v3, v16, T1D);\n+    pmull2(v24, T1Q, v3, v16, T2D);\n+    ldrq(v3, Address(buf, 0x40));\n+    eor3(v3, T16B, v23, v24, v3);\n+\n+    pmull (v25, T1Q, v4, v16, T1D);\n+    pmull2(v26, T1Q, v4, v16, T2D);\n+    ldrq(v4, Address(buf, 0x50));\n+    eor3(v4, T16B, v25, v26, v4);\n+\n+    pmull (v27, T1Q, v5, v16, T1D);\n+    pmull2(v28, T1Q, v5, v16, T2D);\n+    ldrq(v5, Address(buf, 0x60));\n+    eor3(v5, T16B, v27, v28, v5);\n+\n+    pmull (v29, T1Q, v6, v16, T1D);\n+    pmull2(v30, T1Q, v6, v16, T2D);\n+    ldrq(v6, Address(buf, 0x70));\n+    eor3(v6, T16B, v29, v30, v6);\n+\n+    \/\/ Reuse registers v23, v24.\n+    \/\/ Using them won't block the first instruction of the next iteration.\n+    pmull (v23, T1Q, v7, v16, T1D);\n+    pmull2(v24, T1Q, v7, v16, T2D);\n+    ldrq(v7, Address(pre(buf, 0x80)));\n+    eor3(v7, T16B, v23, v24, v7);\n@@ -4490,1 +4502,2 @@\n-    ldrq(v0, Address(table, 0x10));\n+    \/\/ Use v31 for constants because v16 can be still in use.\n+    ldrq(v31, Address(table, 0x10));\n@@ -4492,3 +4505,3 @@\n-    pmull (v10,  T1Q, v1, v0, T1D);\n-    pmull2(v11, T1Q, v1, v0, T2D);\n-    eor3(v1, T16B, v10, v11, v5);\n+    pmull (v17,  T1Q, v0, v31, T1D);\n+    pmull2(v18, T1Q, v0, v31, T2D);\n+    eor3(v0, T16B, v17, v18, v4);\n@@ -4496,3 +4509,3 @@\n-    pmull (v12, T1Q, v2, v0, T1D);\n-    pmull2(v13, T1Q, v2, v0, T2D);\n-    eor3(v2, T16B, v12, v13, v6);\n+    pmull (v19, T1Q, v1, v31, T1D);\n+    pmull2(v20, T1Q, v1, v31, T2D);\n+    eor3(v1, T16B, v19, v20, v5);\n@@ -4500,3 +4513,3 @@\n-    pmull (v14, T1Q, v3, v0, T1D);\n-    pmull2(v15, T1Q, v3, v0, T2D);\n-    eor3(v3, T16B, v14, v15, v7);\n+    pmull (v21, T1Q, v2, v31, T1D);\n+    pmull2(v22, T1Q, v2, v31, T2D);\n+    eor3(v2, T16B, v21, v22, v6);\n@@ -4504,3 +4517,3 @@\n-    pmull (v16, T1Q, v4, v0, T1D);\n-    pmull2(v17, T1Q, v4, v0, T2D);\n-    eor3(v4, T16B, v16, v17, v8);\n+    pmull (v23, T1Q, v3, v31, T1D);\n+    pmull2(v24, T1Q, v3, v31, T2D);\n+    eor3(v3, T16B, v23, v24, v7);\n@@ -4509,14 +4522,17 @@\n-    ldrq(v5, Address(table, 0x20));\n-    pmull (v10, T1Q, v1, v5, T1D);\n-    pmull2(v11, T1Q, v1, v5, T2D);\n-    eor3(v4, T16B, v4, v10, v11);\n-\n-    ldrq(v6, Address(table, 0x30));\n-    pmull (v12, T1Q, v2, v6, T1D);\n-    pmull2(v13, T1Q, v2, v6, T2D);\n-    eor3(v4, T16B, v4, v12, v13);\n-\n-    ldrq(v7, Address(table, 0x40));\n-    pmull (v14, T1Q, v3, v7, T1D);\n-    pmull2(v15, T1Q, v3, v7, T2D);\n-    eor3(v1, T16B, v4, v14, v15);\n+    \/\/ Use v17 for constants because v31 can be still in use.\n+    ldrq(v17, Address(table, 0x20));\n+    pmull (v25, T1Q, v0, v17, T1D);\n+    pmull2(v26, T1Q, v0, v17, T2D);\n+    eor3(v3, T16B, v3, v25, v26);\n+\n+    \/\/ Use v18 for constants because v17 can be still in use.\n+    ldrq(v18, Address(table, 0x30));\n+    pmull (v27, T1Q, v1, v18, T1D);\n+    pmull2(v28, T1Q, v1, v18, T2D);\n+    eor3(v3, T16B, v3, v27, v28);\n+\n+    \/\/ Use v19 for constants because v18 can be still in use.\n+    ldrq(v19, Address(table, 0x40));\n+    pmull (v29, T1Q, v2, v19, T1D);\n+    pmull2(v30, T1Q, v2, v19, T2D);\n+    eor3(v0, T16B, v3, v29, v30);\n@@ -4527,2 +4543,2 @@\n-    mov(tmp0, v1, D, 0);\n-    mov(tmp1, v1, D, 1);\n+    mov(tmp0, v0, D, 0);\n+    mov(tmp1, v0, D, 1);\n@@ -5722,1 +5738,0 @@\n-\/\/ elem_size is the element size in bytes: either 1 or 2.\n@@ -5729,1 +5744,1 @@\n-                                   Register result, Register cnt1, int elem_size)\n+                                   Register result, Register cnt1)\n@@ -5736,1 +5751,0 @@\n-  assert(elem_size == 1 || elem_size == 2, \"must be 2 or 1 byte\");\n@@ -5741,2 +5755,1 @@\n-    const char kind = (elem_size == 2) ? 'U' : 'L';\n-    snprintf(comment, sizeof comment, \"{string_equals%c\", kind);\n+    snprintf(comment, sizeof comment, \"{string_equalsL\");\n@@ -5791,2 +5804,1 @@\n-  if (elem_size == 1) { \/\/ Only needed when comparing 1-byte elements\n-    tbz(cnt1, 0, SAME); \/\/ 0-1 bytes left.\n+  tbz(cnt1, 0, SAME); \/\/ 0-1 bytes left.\n@@ -5794,5 +5806,4 @@\n-      ldrb(tmp1, a1);\n-      ldrb(tmp2, a2);\n-      eorw(tmp1, tmp1, tmp2);\n-      cbnzw(tmp1, DONE);\n-    }\n+    ldrb(tmp1, a1);\n+    ldrb(tmp2, a2);\n+    eorw(tmp1, tmp1, tmp2);\n+    cbnzw(tmp1, DONE);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":112,"deletions":101,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -1482,2 +1482,1 @@\n-  void string_equals(Register a1, Register a2, Register result, Register cnt1,\n-                     int elem_size);\n+  void string_equals(Register a1, Register a2, Register result, Register cnt1);\n@@ -1510,5 +1509,0 @@\n-  void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,\n-                FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,\n-                FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,\n-                FloatRegister tmpC4, Register tmp1, Register tmp2,\n-                Register tmp3, Register tmp4, Register tmp5);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5354,13 +5354,0 @@\n-  address generate_dlog() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"dlog\");\n-    address entry = __ pc();\n-    FloatRegister vtmp0 = v0, vtmp1 = v1, vtmp2 = v2, vtmp3 = v3, vtmp4 = v4,\n-        vtmp5 = v5, tmpC1 = v16, tmpC2 = v17, tmpC3 = v18, tmpC4 = v19;\n-    Register tmp1 = r0, tmp2 = r1, tmp3 = r2, tmp4 = r3, tmp5 = r4;\n-    __ fast_log(vtmp0, vtmp1, vtmp2, vtmp3, vtmp4, vtmp5, tmpC1, tmpC2, tmpC3,\n-        tmpC4, tmp1, tmp2, tmp3, tmp4, tmp5);\n-    return entry;\n-  }\n-\n-\n@@ -5514,0 +5501,26 @@\n+  \/\/ r0 = input (float16)\n+  \/\/ v0 = result (float)\n+  \/\/ v1 = temporary float register\n+  address generate_float16ToFloat() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+    address entry = __ pc();\n+    BLOCK_COMMENT(\"Entry:\");\n+    __ flt16_to_flt(v0, r0, v1);\n+    __ ret(lr);\n+    return entry;\n+  }\n+\n+  \/\/ v0 = input (float)\n+  \/\/ r0 = result (float16)\n+  \/\/ v1 = temporary float register\n+  address generate_floatToFloat16() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+    address entry = __ pc();\n+    BLOCK_COMMENT(\"Entry:\");\n+    __ flt_to_flt16(r0, v0, v1);\n+    __ ret(lr);\n+    return entry;\n+  }\n+\n@@ -8488,5 +8501,0 @@\n-    \/\/ Disabled until JDK-8210858 is fixed\n-    \/\/ if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog)) {\n-    \/\/   StubRoutines::_dlog = generate_dlog();\n-    \/\/ }\n-\n@@ -8501,0 +8509,6 @@\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToFloat) &&\n+        vmIntrinsics::is_intrinsic_available(vmIntrinsics::_floatToFloat16)) {\n+      StubRoutines::_hf2f = generate_float16ToFloat();\n+      StubRoutines::_f2hf = generate_floatToFloat16();\n+    }\n+\n@@ -8507,0 +8521,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -2483,0 +2483,2 @@\n+    Register mdo = klass_RInfo;\n+    metadata2reg(md->constant_encoding(), mdo);\n@@ -2486,2 +2488,0 @@\n-    Register mdo = klass_RInfo;\n-    metadata2reg(md->constant_encoding(), mdo);\n@@ -2493,0 +2493,8 @@\n+\n+    NearLabel update_done;\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj);\n+    type_profile_helper(mdo, md, data, recv, Rtmp1, &update_done);\n+    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+    __ add2mem_64(counter_addr, DataLayout::counter_increment, Rtmp1);\n+    __ bind(update_done);\n@@ -2497,3 +2505,2 @@\n-  NearLabel profile_cast_failure, profile_cast_success;\n-  Label *failure_target = op->should_profile() ? &profile_cast_failure : failure;\n-  Label *success_target = op->should_profile() ? &profile_cast_success : success;\n+  Label *failure_target = failure;\n+  Label *success_target = success;\n@@ -2539,1 +2546,0 @@\n-      CHECK_BAILOUT2(profile_cast_failure, profile_cast_success);\n@@ -2545,16 +2551,1 @@\n-  if (op->should_profile()) {\n-    Register mdo = klass_RInfo, recv = k_RInfo;\n-    assert_different_registers(obj, mdo, recv);\n-    __ bind(profile_cast_success);\n-    metadata2reg(md->constant_encoding(), mdo);\n-    __ load_klass(recv, obj);\n-    type_profile_helper(mdo, md, data, recv, Rtmp1, success);\n-    __ branch_optimized(Assembler::bcondAlways, *success);\n-\n-    __ bind(profile_cast_failure);\n-    metadata2reg(md->constant_encoding(), mdo);\n-    __ add2mem_64(Address(mdo, md->byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);\n-    __ branch_optimized(Assembler::bcondAlways, *failure);\n-  } else {\n-    __ branch_optimized(Assembler::bcondAlways, *success);\n-  }\n+  __ branch_optimized(Assembler::bcondAlways, *success);\n@@ -2590,3 +2581,3 @@\n-    NearLabel profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = op->should_profile() ? &profile_cast_success : &done;\n-    Label *failure_target = op->should_profile() ? &profile_cast_failure : stub->entry();\n+    NearLabel done;\n+    Label *success_target = &done;\n+    Label *failure_target = stub->entry();\n@@ -2595,0 +2586,2 @@\n+      Register mdo = klass_RInfo;\n+      metadata2reg(md->constant_encoding(), mdo);\n@@ -2598,2 +2591,0 @@\n-      Register mdo = klass_RInfo;\n-      metadata2reg(md->constant_encoding(), mdo);\n@@ -2605,0 +2596,8 @@\n+\n+      NearLabel update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value);\n+      type_profile_helper(mdo, md, data, recv, Rtmp1, &update_done);\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ add2mem_64(counter_addr, DataLayout::counter_increment, Rtmp1);\n+      __ bind(update_done);\n@@ -2622,1 +2621,0 @@\n-    CHECK_BAILOUT3(profile_cast_success, profile_cast_failure, done);\n@@ -2626,15 +2624,0 @@\n-    if (op->should_profile()) {\n-      Register mdo = klass_RInfo, recv = k_RInfo;\n-      assert_different_registers(value, mdo, recv);\n-      __ bind(profile_cast_success);\n-      metadata2reg(md->constant_encoding(), mdo);\n-      __ load_klass(recv, value);\n-      type_profile_helper(mdo, md, data, recv, Rtmp1, &done);\n-      __ branch_optimized(Assembler::bcondAlways, done);\n-\n-      __ bind(profile_cast_failure);\n-      metadata2reg(md->constant_encoding(), mdo);\n-      __ add2mem_64(Address(mdo, md->byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);\n-      __ branch_optimized(Assembler::bcondAlways, *stub->entry());\n-    }\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":28,"deletions":45,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -450,3 +450,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  profile_typecheck_failed(Rtmp1, Rtmp2);\n@@ -1428,1 +1425,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2, true);\n+    record_klass_in_profile(receiver, mdp, reg2);\n@@ -1451,1 +1448,1 @@\n-                                        Label& done, bool is_virtual_call) {\n+                                        Label& done) {\n@@ -1453,3 +1450,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1490,10 +1485,6 @@\n-        if (is_virtual_call) {\n-          z_brz(found_null);\n-          \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-          z_bru(done);\n-          bind(found_null);\n-        } else {\n-          z_brnz(done);\n-        }\n+        z_brz(found_null);\n+        \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        z_bru(done);\n+        bind(found_null);\n@@ -1506,1 +1497,1 @@\n-      record_klass_in_profile_helper(receiver, mdp, reg2, start_row + 1, done, is_virtual_call);\n+      record_klass_in_profile_helper(receiver, mdp, reg2, start_row + 1, done);\n@@ -1553,2 +1544,1 @@\n-                                                        Register mdp, Register reg2,\n-                                                        bool is_virtual_call) {\n+                                                        Register mdp, Register reg2) {\n@@ -1558,1 +1548,1 @@\n-  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done, is_virtual_call);\n+  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done);\n@@ -1618,18 +1608,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp, Register tmp) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter. We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, tmp, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n@@ -1649,1 +1621,1 @@\n-      record_klass_in_profile(klass, mdp, reg2, false);\n+      record_klass_in_profile(klass, mdp, reg2);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":15,"deletions":43,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -819,2 +819,2 @@\n-  void emit_data(jint data, relocInfo::relocType    rtype, int format);\n-  void emit_data(jint data, RelocationHolder const& rspec, int format);\n+  void emit_data(jint data, relocInfo::relocType    rtype, int format = 0);\n+  void emit_data(jint data, RelocationHolder const& rspec, int format = 0);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5314,0 +5314,36 @@\n+#ifdef _LP64\n+void C2_MacroAssembler::vector_compress_expand_avx2(int opcode, XMMRegister dst, XMMRegister src,\n+                                                    XMMRegister mask, Register rtmp, Register rscratch,\n+                                                    XMMRegister permv, XMMRegister xtmp, BasicType bt,\n+                                                    int vec_enc) {\n+  assert(type2aelembytes(bt) >= 4, \"\");\n+  assert(opcode == Op_CompressV || opcode == Op_ExpandV, \"\");\n+  address compress_perm_table = nullptr;\n+  address expand_perm_table = nullptr;\n+  if (type2aelembytes(bt) == 8) {\n+    compress_perm_table = StubRoutines::x86::compress_perm_table64();\n+    expand_perm_table  = StubRoutines::x86::expand_perm_table64();\n+    vmovmskpd(rtmp, mask, vec_enc);\n+  } else {\n+    compress_perm_table = StubRoutines::x86::compress_perm_table32();\n+    expand_perm_table = StubRoutines::x86::expand_perm_table32();\n+    vmovmskps(rtmp, mask, vec_enc);\n+  }\n+  shlq(rtmp, 5); \/\/ for 32 byte permute row.\n+  if (opcode == Op_CompressV) {\n+    lea(rscratch, ExternalAddress(compress_perm_table));\n+  } else {\n+    lea(rscratch, ExternalAddress(expand_perm_table));\n+  }\n+  addptr(rtmp, rscratch);\n+  vmovdqu(permv, Address(rtmp));\n+  vpermps(dst, permv, src, Assembler::AVX_256bit);\n+  vpxor(xtmp, xtmp, xtmp, vec_enc);\n+  \/\/ Blend the result with zero vector using permute mask, each column entry\n+  \/\/ in a permute table row contains either a valid permute index or a -1 (default)\n+  \/\/ value, this can potentially be used as a blending mask after\n+  \/\/ compressing\/expanding the source vector lanes.\n+  vblendvps(dst, dst, xtmp, permv, vec_enc, false, permv);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,0 +394,4 @@\n+\n+  void vector_compress_expand_avx2(int opcode, XMMRegister dst, XMMRegister src, XMMRegister mask,\n+                                   Register rtmp, Register rscratch, XMMRegister permv, XMMRegister xtmp,\n+                                   BasicType bt, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2582,1 +2582,3 @@\n-  if (is_simm32(src)) {\n+  if (is_uimm32(src)) {\n+    movl(dst, checked_cast<uint32_t>(src));\n+  } else if (is_simm32(src)) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -970,0 +970,86 @@\n+address StubGenerator::generate_compress_perm_table(const char *stub_name, int32_t esize) {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  address start = __ pc();\n+  if (esize == 32) {\n+    \/\/ Loop to generate 256 x 8 int compression permute index table. A row is\n+    \/\/ accessed using 8 bit index computed using vector mask. An entry in\n+    \/\/ a row holds either a valid permute index corresponding to set bit position\n+    \/\/ or a -1 (default) value.\n+    for (int mask = 0; mask < 256; mask++) {\n+      int ctr = 0;\n+      for (int j = 0; j < 8; j++) {\n+        if (mask & (1 << j)) {\n+          __ emit_data(j, relocInfo::none);\n+          ctr++;\n+        }\n+      }\n+      for (; ctr < 8; ctr++) {\n+        __ emit_data(-1, relocInfo::none);\n+      }\n+    }\n+  } else {\n+    assert(esize == 64, \"\");\n+    \/\/ Loop to generate 16 x 4 long compression permute index table. A row is\n+    \/\/ accessed using 4 bit index computed using vector mask. An entry in\n+    \/\/ a row holds either a valid permute index pair for a quadword corresponding\n+    \/\/ to set bit position or a -1 (default) value.\n+    for (int mask = 0; mask < 16; mask++) {\n+      int ctr = 0;\n+      for (int j = 0; j < 4; j++) {\n+        if (mask & (1 << j)) {\n+          __ emit_data(2 * j, relocInfo::none);\n+          __ emit_data(2 * j + 1, relocInfo::none);\n+          ctr++;\n+        }\n+      }\n+      for (; ctr < 4; ctr++) {\n+        __ emit_data64(-1L, relocInfo::none);\n+      }\n+    }\n+  }\n+  return start;\n+}\n+\n+address StubGenerator::generate_expand_perm_table(const char *stub_name, int32_t esize) {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+  address start = __ pc();\n+  if (esize == 32) {\n+    \/\/ Loop to generate 256 x 8 int expand permute index table. A row is accessed\n+    \/\/ using 8 bit index computed using vector mask. An entry in a row holds either\n+    \/\/ a valid permute index (starting from least significant lane) placed at poisition\n+    \/\/ corresponding to set bit position or a -1 (default) value.\n+    for (int mask = 0; mask < 256; mask++) {\n+      int ctr = 0;\n+      for (int j = 0; j < 8; j++) {\n+        if (mask & (1 << j)) {\n+          __ emit_data(ctr++, relocInfo::none);\n+        } else {\n+          __ emit_data(-1, relocInfo::none);\n+        }\n+      }\n+    }\n+  } else {\n+    assert(esize == 64, \"\");\n+    \/\/ Loop to generate 16 x 4 long expand permute index table. A row is accessed\n+    \/\/ using 4 bit index computed using vector mask. An entry in a row holds either\n+    \/\/ a valid doubleword permute index pair representing a quadword index (starting\n+    \/\/ from least significant lane) placed at poisition corresponding to set bit\n+    \/\/ position or a -1 (default) value.\n+    for (int mask = 0; mask < 16; mask++) {\n+      int ctr = 0;\n+      for (int j = 0; j < 4; j++) {\n+        if (mask & (1 << j)) {\n+          __ emit_data(2 * ctr, relocInfo::none);\n+          __ emit_data(2 * ctr + 1, relocInfo::none);\n+          ctr++;\n+        } else {\n+          __ emit_data64(-1L, relocInfo::none);\n+        }\n+      }\n+    }\n+  }\n+  return start;\n+}\n+\n@@ -4268,0 +4354,7 @@\n+  if (VM_Version::supports_avx2() && !VM_Version::supports_avx512vl()) {\n+    StubRoutines::x86::_compress_perm_table32 = generate_compress_perm_table(\"compress_perm_table32\", 32);\n+    StubRoutines::x86::_compress_perm_table64 = generate_compress_perm_table(\"compress_perm_table64\", 64);\n+    StubRoutines::x86::_expand_perm_table32 = generate_expand_perm_table(\"expand_perm_table32\", 32);\n+    StubRoutines::x86::_expand_perm_table64 = generate_expand_perm_table(\"expand_perm_table64\", 64);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,4 @@\n+  address generate_compress_perm_table(const char *stub_name, int32_t esize);\n+\n+  address generate_expand_perm_table(const char *stub_name, int32_t esize);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -812,1 +812,2 @@\n-    _features = feature_flags();\n+    _features = feature_flags(); \/\/ These can be changed by VM settings\n+    _cpu_features = _features;   \/\/ Preserve features\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1428,0 +1428,2 @@\n+    case Op_CompressV:\n+    case Op_ExpandV:\n@@ -1662,6 +1664,0 @@\n-    case Op_CompressV:\n-    case Op_ExpandV:\n-      if (!VM_Version::supports_avx512vl()) {\n-        return false;\n-      }\n-      break;\n@@ -1706,1 +1702,1 @@\n-bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n@@ -1955,1 +1951,1 @@\n-      if (size_in_bits < 128 ) {\n+      if (!is_LP64 && !VM_Version::supports_avx512vl() && size_in_bits < 512) {\n@@ -1958,1 +1954,1 @@\n-      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+      if (size_in_bits < 128 ) {\n@@ -1961,1 +1957,0 @@\n-      break;\n@@ -2288,1 +2283,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n@@ -7855,1 +7850,1 @@\n-            n->in(2)->bottom_type()->isa_vectmask() == NULL &&\n+            n->in(2)->bottom_type()->isa_vectmask() == nullptr &&\n@@ -9215,0 +9210,17 @@\n+#ifdef _LP64\n+instruct vcompress_reg_avx(vec dst, vec src, vec mask, rRegI rtmp, rRegL rscratch, vec perm, vec xtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n) <= 32);\n+  match(Set dst (CompressV src mask));\n+  match(Set dst (ExpandV src mask));\n+  effect(TEMP_DEF dst, TEMP perm, TEMP xtmp, TEMP rtmp, TEMP rscratch, KILL cr);\n+  format %{ \"vector_compress $dst, $src, $mask \\t!using $xtmp, $rtmp, $rscratch and $perm as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    __ vector_compress_expand_avx2(opcode, $dst$$XMMRegister, $src$$XMMRegister, $mask$$XMMRegister, $rtmp$$Register,\n+                                   $rscratch$$Register, $perm$$XMMRegister, $xtmp$$XMMRegister, bt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif\n@@ -9217,0 +9229,1 @@\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3396,1 +3396,1 @@\n-\/\/ nullptr Pointer Immediate\n+\/\/ Null Pointer Immediate\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2197,1 +2197,1 @@\n-\/\/ nullptr Pointer Immediate\n+\/\/ Null Pointer Immediate\n@@ -2225,1 +2225,1 @@\n-\/\/ nullptr Pointer Immediate\n+\/\/ Null Pointer Immediate\n@@ -4936,1 +4936,1 @@\n-  format %{ \"xorq    $dst, $src\\t# compressed nullptr ptr\" %}\n+  format %{ \"xorq    $dst, $src\\t# compressed null pointer\" %}\n@@ -5203,1 +5203,1 @@\n-\/\/ Store nullptr Pointer, mark word, or other simple pointer constant.\n+\/\/ Store Null Pointer, mark word, or other simple pointer constant.\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -472,3 +472,5 @@\n-  \/\/ Caution: do not use do_Op2(x) here for now since\n-  \/\/          we map the condition to the op for now!\n-  move_const_to_right(x);\n+  \/\/ Currently, Canonicalizer is only used by GraphBuilder,\n+  \/\/ and IfOp is not created by GraphBuilder but only later\n+  \/\/ when eliminating conditional expressions with CE_Eliminator,\n+  \/\/ so this method will not be called.\n+  ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -479,0 +479,3 @@\n+    \/\/ Lock to access ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(md->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2231,1 +2231,1 @@\n-    if (bitmap_base == NULL) {\n+    if (bitmap_base == nullptr) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"oops\/methodData.inline.hpp\"\n@@ -90,2 +91,12 @@\n-    \/\/ Holding locks through safepoints is bad practice.\n-    MutexUnlocker mu(_mdo->extra_data_lock());\n+    \/\/ We are currently holding the extra_data_lock and ensuring\n+    \/\/ no safepoint breaks the lock.\n+    _mdo->check_extra_data_locked();\n+\n+    \/\/ We now want to cache some method data. This could cause a safepoint.\n+    \/\/ We temporarily release the lock and allow safepoints, and revert that\n+    \/\/ at the end of the scope. This is safe, since we currently do not hold\n+    \/\/ any extra_method_data: finish is called only after clean_extra_data,\n+    \/\/ and the outer scope that first aquired the lock should not hold any\n+    \/\/ extra_method_data while cleaning is performed, as the offsets can change.\n+    MutexUnlocker mu(_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -126,1 +137,4 @@\n-  MutexLocker ml(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not unintentionally broken by a safepoint\n+  MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -571,0 +585,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -595,0 +612,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -854,4 +854,4 @@\n-  oop* ptr = h.ptr_raw();\n-  if (ptr != nullptr) {\n-    assert(_handles.owner_of(ptr), \"Got unexpected handle \" PTR_FORMAT, p2i(ptr));\n-    NativeAccess<>::oop_store(ptr, oop(nullptr));\n+  if (!h.is_empty()) {\n+    assert(_handles.owner_of(h.ptr_raw()),\n+           \"Got unexpected handle \" PTR_FORMAT, p2i(h.ptr_raw()));\n+    h.replace(oop(nullptr));\n@@ -1023,1 +1023,5 @@\n-  out->print_cr(\" - class loader        \" INTPTR_FORMAT, p2i(_class_loader.ptr_raw()));\n+  if (!_unloading) {\n+    out->print_cr(\" - class loader        \" INTPTR_FORMAT, p2i(_class_loader.peek()));\n+  } else {\n+    out->print_cr(\" - class loader        <unloading, oop is bad>\");\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1116,0 +1116,5 @@\n+    \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n+    \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n+    assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n+    assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n+    ik->set_nest_host(shared_nest_host);\n@@ -1118,6 +1123,0 @@\n-  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n-  \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n-  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n-  assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n-  ik->set_nest_host(shared_nest_host);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -225,1 +225,0 @@\n-    case vmIntrinsics::_equalsU:\n@@ -540,1 +539,0 @@\n-  case vmIntrinsics::_equalsU:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -408,1 +408,0 @@\n-  do_intrinsic(_equalsU,                  java_lang_StringUTF16, equals_name, equalsB_signature,                 F_S)   \\\n@@ -602,2 +601,2 @@\n-  do_intrinsic(_notifyJvmtiVThreadHideFrames, java_lang_VirtualThread, notifyJvmtiHideFrames_name, bool_void_signature, F_RN) \\\n-  do_intrinsic(_notifyJvmtiVThreadDisableSuspend, java_lang_VirtualThread, notifyJvmtiDisableSuspend_name, bool_void_signature, F_RN) \\\n+  do_intrinsic(_notifyJvmtiVThreadHideFrames, java_lang_VirtualThread, notifyJvmtiHideFrames_name, bool_void_signature, F_SN) \\\n+  do_intrinsic(_notifyJvmtiVThreadDisableSuspend, java_lang_VirtualThread, notifyJvmtiDisableSuspend_name, bool_void_signature, F_SN) \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-void CodeBlob::print_code() {\n+void CodeBlob::print_code_on(outputStream* st) {\n@@ -241,1 +241,1 @@\n-  Disassembler::decode(this, tty);\n+  Disassembler::decode(this, st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-  void print_code();\n+  void print_code_on(outputStream* st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -701,6 +701,9 @@\n-    ttyLocker ttyl;\n-    tty->print_cr(\"implicit exception happened at \" INTPTR_FORMAT, p2i(pc));\n-    print();\n-    method()->print_codes();\n-    print_code();\n-    print_pcs();\n+\n+    \/\/ Keep tty output consistent. To avoid ttyLocker, we buffer in stream, and print all at once.\n+    stringStream ss;\n+    ss.print_cr(\"implicit exception happened at \" INTPTR_FORMAT, p2i(pc));\n+    print_on(&ss);\n+    method()->print_codes_on(&ss);\n+    print_code_on(&ss);\n+    print_pcs_on(&ss);\n+    tty->print(\"%s\", ss.as_string()); \/\/ print all at once\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,1 +243,1 @@\n-  virtual void print_pcs() = 0;\n+  virtual void print_pcs_on(outputStream* st) = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1033,1 +1033,1 @@\n-      print_pcs();\n+      print_pcs_on(tty);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -631,1 +631,0 @@\n-  void print_pcs() { print_pcs_on(tty); }\n@@ -645,2 +644,1 @@\n-  \/\/ void print_pcs()                             PRODUCT_RETURN;\n-  void print_pcs()                                { return; }\n+  void print_pcs_on(outputStream* st) { return; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -844,1 +844,1 @@\n-  JavaThread* new_thread = nullptr;\n+  Handle thread_oop(THREAD, JNIHandles::resolve_non_null(thread_handle));\n@@ -846,0 +846,7 @@\n+  if (java_lang_Thread::thread(thread_oop()) != nullptr) {\n+    assert(type == compiler_t, \"should only happen with reused compiler threads\");\n+    \/\/ The compiler thread hasn't actually exited yet so don't try to reuse it\n+    return nullptr;\n+  }\n+\n+  JavaThread* new_thread = nullptr;\n@@ -874,1 +881,0 @@\n-    Handle thread_oop(THREAD, JNIHandles::resolve_non_null(thread_handle));\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/softRefPolicy.hpp\"\n@@ -59,1 +60,0 @@\n-class SoftRefPolicy;\n@@ -108,0 +108,2 @@\n+  SoftRefPolicy _soft_ref_policy;\n+\n@@ -407,1 +409,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() = 0;\n+  SoftRefPolicy* soft_ref_policy() { return &_soft_ref_policy; }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1170,1 +1170,1 @@\n-JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide);\n+JVM_VirtualThreadHideFrames(JNIEnv* env, jclass clazz, jboolean hide);\n@@ -1173,1 +1173,1 @@\n-JVM_VirtualThreadDisableSuspend(JNIEnv* env, jobject vthread, jboolean enter);\n+JVM_VirtualThreadDisableSuspend(JNIEnv* env, jclass clazz, jboolean enter);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -712,1 +712,6 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    MethodData* mdo = h_method->method_data();\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n+    ProfileData* pdata = mdo->allocate_bci_to_data(current_bci, nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n@@ -182,9 +182,0 @@\n-static JavaThread* get_current_thread(bool allow_null=true) {\n-  Thread* thread = Thread::current_or_null_safe();\n-  if (thread == nullptr) {\n-    assert(allow_null, \"npe\");\n-    return nullptr;\n-  }\n-  return JavaThread::cast(thread);\n-}\n-\n@@ -195,1 +186,1 @@\n-  JavaThread* thread = get_current_thread();             \\\n+  JavaThread* thread = JavaThread::current_or_null();    \\\n@@ -206,1 +197,1 @@\n-  JavaThread* thread = get_current_thread();             \\\n+  JavaThread* thread = JavaThread::current_or_null();    \\\n@@ -222,1 +213,1 @@\n-  JavaThread* thread = get_current_thread();\n+  JavaThread* thread = JavaThread::current_or_null();\n@@ -1892,1 +1883,4 @@\n-  MutexLocker mu(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker mu(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -2616,1 +2610,1 @@\n-  JavaThread* thread = get_current_thread(false);\n+  JavaThread* thread = JavaThread::thread_from_jni_environment(hotspotEnv);\n@@ -3074,1 +3068,1 @@\n-  EventCompilerPhase event;\n+  EventCompilerPhase event(UNTIMED);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -579,1 +579,1 @@\n-  for (FieldStream fd(klass, false, false); !fd.eos(); fd.next()) {\n+  for (AllFieldStream fd(klass); !fd.done(); fd.next()) {\n@@ -622,1 +622,1 @@\n-    for (FieldStream fd(ik, false, false); !fd.eos(); fd.next()) {\n+    for (AllFieldStream fd(ik); !fd.done(); fd.next()) {\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n@@ -2764,1 +2764,0 @@\n-      ConditionalMutexLocker ml(mdo->extra_data_lock(), !SafepointSynchronize::is_at_safepoint());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -607,1 +607,1 @@\n-    } else if (_java_mirror.ptr_raw() == nullptr) {\n+    } else if (_java_mirror.is_empty()) {\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -553,1 +553,1 @@\n-void Method::print_invocation_count() {\n+void Method::print_invocation_count(outputStream* st) {\n@@ -555,7 +555,7 @@\n-  if (is_static()) tty->print(\"static \");\n-  if (is_final()) tty->print(\"final \");\n-  if (is_synchronized()) tty->print(\"synchronized \");\n-  if (is_native()) tty->print(\"native \");\n-  tty->print(\"%s::\", method_holder()->external_name());\n-  name()->print_symbol_on(tty);\n-  signature()->print_symbol_on(tty);\n+  if (is_static())       { st->print(\"static \"); }\n+  if (is_final())        { st->print(\"final \"); }\n+  if (is_synchronized()) { st->print(\"synchronized \"); }\n+  if (is_native())       { st->print(\"native \"); }\n+  st->print(\"%s::\", method_holder()->external_name());\n+  name()->print_symbol_on(st);\n+  signature()->print_symbol_on(st);\n@@ -565,1 +565,1 @@\n-    tty->print(\" {%d}\", code_size());\n+    st->print(\" {%d}\", code_size());\n@@ -567,1 +567,1 @@\n-  tty->cr();\n+  st->cr();\n@@ -574,3 +574,3 @@\n-  tty->print_cr (\"  interpreter_invocation_count: \" INT32_FORMAT_W(11), interpreter_invocation_count());\n-  tty->print_cr (\"  invocation_counter:           \" INT32_FORMAT_W(11), invocation_count());\n-  tty->print_cr (\"  backedge_counter:             \" INT32_FORMAT_W(11), backedge_count());\n+  st->print_cr (\"  interpreter_invocation_count: \" INT32_FORMAT_W(11), interpreter_invocation_count());\n+  st->print_cr (\"  invocation_counter:           \" INT32_FORMAT_W(11), invocation_count());\n+  st->print_cr (\"  backedge_counter:             \" INT32_FORMAT_W(11), backedge_count());\n@@ -579,1 +579,1 @@\n-    tty->print_cr (\"  decompile_count:              \" UINT32_FORMAT_W(11), method_data()->decompile_count());\n+    st->print_cr (\"  decompile_count:              \" UINT32_FORMAT_W(11), method_data()->decompile_count());\n@@ -584,1 +584,1 @@\n-    tty->print_cr (\"  compiled_invocation_count:    \" INT64_FORMAT_W(11), compiled_invocation_count());\n+    st->print_cr (\"  compiled_invocation_count:    \" INT64_FORMAT_W(11), compiled_invocation_count());\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -471,1 +471,1 @@\n-  void print_invocation_count();\n+  void print_invocation_count(outputStream* st);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1288,1 +1288,1 @@\n-    _extra_data_lock(Mutex::safepoint-2, \"MDOExtraData_lock\"),\n+    _extra_data_lock(Mutex::nosafepoint, \"MDOExtraData_lock\"),\n@@ -1449,0 +1449,2 @@\n+  check_extra_data_locked();\n+\n@@ -1499,1 +1501,3 @@\n-ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*& dp, bool concurrent) {\n+ProfileData* MethodData::bci_to_extra_data_find(int bci, Method* m, DataLayout*& dp) {\n+  check_extra_data_locked();\n+\n@@ -1520,7 +1524,2 @@\n-        \/\/ data->method() may be null in case of a concurrent\n-        \/\/ allocation. Maybe it's for the same method. Try to use that\n-        \/\/ entry in that case.\n-          if (data->method() == nullptr) {\n-            assert(concurrent, \"impossible because no concurrent allocation\");\n-            return nullptr;\n-          } else if (data->method() == m) {\n+          assert(data->method() != nullptr, \"method must be set\");\n+          if (data->method() == m) {\n@@ -1543,0 +1542,2 @@\n+  check_extra_data_locked();\n+\n@@ -1556,5 +1557,3 @@\n-  \/\/ Allocation in the extra data space has to be atomic because not\n-  \/\/ all entries have the same size and non atomic concurrent\n-  \/\/ allocation would result in a corrupted extra data space.\n-  ProfileData* result = bci_to_extra_data_helper(bci, m, dp, true);\n-  if (result != nullptr) {\n+  \/\/ Find if already exists\n+  ProfileData* result = bci_to_extra_data_find(bci, m, dp);\n+  if (result != nullptr || dp >= end) {\n@@ -1564,9 +1563,2 @@\n-  if (create_if_missing && dp < end) {\n-    MutexLocker ml(&_extra_data_lock);\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries.\n-    ProfileData* result = bci_to_extra_data_helper(bci, m, dp, false);\n-    if (result != nullptr || dp >= end) {\n-      return result;\n-    }\n-\n+  if (create_if_missing) {\n+    \/\/ Not found -> Allocate\n@@ -1799,0 +1791,2 @@\n+  check_extra_data_locked();\n+\n@@ -1840,0 +1834,2 @@\n+  check_extra_data_locked();\n+\n@@ -1884,0 +1880,2 @@\n+  check_extra_data_locked();\n+\n@@ -1921,0 +1919,4 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -1930,0 +1932,4 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -1943,0 +1949,13 @@\n+\n+#ifdef ASSERT\n+void MethodData::check_extra_data_locked() const {\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(!Thread::current()->is_Java_thread() ||\n+           JavaThread::current()->is_in_no_safepoint_scope(),\n+           \"JavaThread must have NoSafepointVerifier inside lock scope\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2403,1 +2403,1 @@\n-  ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*& dp, bool concurrent);\n+  ProfileData* bci_to_extra_data_find(int bci, Method* m, DataLayout*& dp);\n@@ -2545,5 +2545,1 @@\n-  uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();\n-                                                   assert(aid != nullptr, \"arg_info must be not null\");\n-                                                   assert(a >= 0 && a < aid->number_of_args(), \"valid argument number\");\n-                                                   return aid->arg_modified(a); }\n-\n+  uint arg_modified(int a);\n@@ -2554,5 +2550,1 @@\n-  void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();\n-                                                   assert(aid != nullptr, \"arg_info must be not null\");\n-                                                   assert(a >= 0 && a < aid->number_of_args(), \"valid argument number\");\n-                                                   aid->set_arg_modified(a, v); }\n-\n+  void set_arg_modified(int a, uint v);\n@@ -2606,0 +2598,2 @@\n+    check_extra_data_locked();\n+\n@@ -2632,1 +2626,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2647,1 +2644,1 @@\n-  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)limit_data_position()); }\n@@ -2764,0 +2761,1 @@\n+  void check_extra_data_locked() const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+  product(bool, StressMacroExpansion, false, DIAGNOSTIC,                    \\\n+          \"Randomize macro node expansion order\")                           \\\n+                                                                            \\\n@@ -342,3 +345,0 @@\n-  develop(bool, SuperWordRTDepCheck, false,                                 \\\n-          \"Enable runtime dependency checks.\")                              \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -249,1 +249,0 @@\n-  case vmIntrinsics::_equalsU:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -742,0 +742,3 @@\n+    if (C->print_inlining() && (is_mh_late_inline() || is_virtual_late_inline())) {\n+      C->print_inlining_update_delayed(this);\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1674,1 +1674,1 @@\n-SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields) :\n+SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint depth, uint n_fields) :\n@@ -1677,0 +1677,1 @@\n+  _depth(depth),\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -510,1 +510,1 @@\n-                                  \/\/ It is relative to the last (youngest) jvms->_scloff.\n+  uint _depth;                    \/\/ Depth of the JVM state the _first_index field refers to\n@@ -521,1 +521,1 @@\n-  SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields);\n+  SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint depth, uint n_fields);\n@@ -531,1 +531,1 @@\n-    return jvms->scloff() + _first_index;\n+    return jvms->of_depth(_depth)->scloff() + _first_index;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -860,1 +860,2 @@\n-  if (StressLCM || StressGCM || StressIGVN || StressCCP || StressIncrementalInlining) {\n+  if (StressLCM || StressGCM || StressIGVN || StressCCP ||\n+      StressIncrementalInlining || StressMacroExpansion) {\n@@ -2953,0 +2954,1 @@\n+    print_method(PHASE_BEFORE_MACRO_EXPANSION, 3);\n@@ -2958,1 +2960,1 @@\n-    print_method(PHASE_MACRO_EXPANSION, 2);\n+    print_method(PHASE_AFTER_MACRO_EXPANSION, 2);\n@@ -5673,0 +5675,10 @@\n+void Compile::shuffle_macro_nodes() {\n+  if (_macro_nodes.length() < 2) {\n+    return;\n+  }\n+  for (uint i = _macro_nodes.length() - 1; i >= 1; i--) {\n+    uint j = C->random() % (i + 1);\n+    swap(_macro_nodes.at(i), _macro_nodes.at(j));\n+  }\n+}\n+\n@@ -5692,1 +5704,1 @@\n-  EventCompilerPhase event;\n+  EventCompilerPhase event(UNTIMED);\n@@ -5731,1 +5743,1 @@\n-  EventCompilerPhase event;\n+  EventCompilerPhase event(UNTIMED);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -823,0 +823,1 @@\n+  void shuffle_macro_nodes();\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3826,1 +3826,4 @@\n-  Node* box = _gvn.transform(new BoxLockNode(next_monitor()));\n+  Node* box = new BoxLockNode(next_monitor());\n+  \/\/ Check for bailout after new BoxLockNode\n+  if (failing()) { return nullptr; }\n+  box = _gvn.transform(box);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -274,1 +274,3 @@\n-                                                                  first_ind, nfields);\n+                                                                  first_ind,\n+                                                                  sfpt->jvms()->depth(),\n+                                                                  nfields);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,1 +315,0 @@\n-  case vmIntrinsics::_equalsU:                  return inline_string_equals(StrIntrinsicNode::UU);\n@@ -3147,1 +3146,1 @@\n-    Node* hide = _gvn.transform(argument(1)); \/\/ hide argument for temporary VTMS transition notification\n+    Node* hide = _gvn.transform(argument(0)); \/\/ hide argument for temporary VTMS transition notification\n@@ -3170,1 +3169,1 @@\n-    Node* arg = _gvn.transform(argument(1)); \/\/ argument for notification\n+    Node* arg = _gvn.transform(argument(0)); \/\/ argument for notification\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,4 @@\n+  if (!RegMask::can_represent(reg, Compile::current()->sync_stack_slots())) {\n+    Compile::current()->record_method_not_compilable(\"must be able to represent all monitor slots in reg mask\");\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -865,1 +865,1 @@\n-  SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, nfields);\n+  SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, sfpt->jvms()->depth(), nfields);\n@@ -2982,0 +2982,3 @@\n+  if (StressMacroExpansion) {\n+    C->shuffle_macro_nodes();\n+  }\n@@ -3066,0 +3069,3 @@\n+      if (success) {\n+        C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n+      }\n@@ -3133,0 +3139,1 @@\n+    C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n@@ -3175,0 +3182,1 @@\n+    C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-  static bool match_rule_supported_superword(int opcode, int vlen, BasicType bt);\n+  static bool match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt);\n@@ -360,1 +360,1 @@\n-  static int superword_max_vector_size(const BasicType bt);\n+  static int max_vector_size_auto_vectorization(const BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -568,1 +568,0 @@\n-  bool    seems_stable_comparison() const;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,4 @@\n-    Node *box = _gvn.transform(new BoxLockNode(next_monitor()));\n+    Node *box = new BoxLockNode(next_monitor());\n+    \/\/ Check for bailout after new BoxLockNode\n+    if (failing()) { return; }\n+    box = _gvn.transform(box);\n@@ -1340,0 +1343,2 @@\n+    \/\/ Check for bailout in shared_lock\n+    if (failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1692,15 +1692,0 @@\n-\/\/ True if the comparison seems to be the kind that will not change its\n-\/\/ statistics from true to false.  See comments in adjust_map_after_if.\n-\/\/ This question is only asked along paths which are already\n-\/\/ classified as untaken (by seems_never_taken), so really,\n-\/\/ if a path is never taken, its controlling comparison is\n-\/\/ already acting in a stable fashion.  If the comparison\n-\/\/ seems stable, we will put an expensive uncommon trap\n-\/\/ on the untaken path.\n-bool Parse::seems_stable_comparison() const {\n-  if (C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if)) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -2322,1 +2307,2 @@\n-  return (seems_never_taken(prob) && seems_stable_comparison());\n+  return seems_never_taken(prob) &&\n+         !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -3539,0 +3525,1 @@\n+  if (failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -86,1 +87,3 @@\n-  flags(MACRO_EXPANSION,                \"Macro expand\") \\\n+  flags(BEFORE_MACRO_EXPANSION ,        \"Before Macro Expansion\") \\\n+  flags(AFTER_MACRO_EXPANSION_STEP,     \"After Macro Expansion Step\") \\\n+  flags(AFTER_MACRO_EXPANSION,          \"After Macro Expansion\") \\\n@@ -144,41 +147,0 @@\n-class PhaseNameIter {\n- private:\n-  char* _token;\n-  char* _saved_ptr;\n-  char* _list;\n-\n- public:\n-  PhaseNameIter(ccstrlist option) {\n-    _list = (char*) canonicalize(option);\n-    _saved_ptr = _list;\n-    _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n-  }\n-\n-  ~PhaseNameIter() {\n-    FREE_C_HEAP_ARRAY(char, _list);\n-  }\n-\n-  const char* operator*() const { return _token; }\n-\n-  PhaseNameIter& operator++() {\n-    _token = strtok_r(nullptr, \",\", &_saved_ptr);\n-    return *this;\n-  }\n-\n-  ccstrlist canonicalize(ccstrlist option_value) {\n-    char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n-    int i = 0;\n-    char current;\n-    while ((current = option_value[i]) != '\\0') {\n-      if (current == '\\n' || current == ' ') {\n-        canonicalized_list[i] = ',';\n-      } else {\n-        canonicalized_list[i] = current;\n-      }\n-      i++;\n-    }\n-    canonicalized_list[i] = '\\0';\n-    return canonicalized_list;\n-  }\n-};\n-\n@@ -197,1 +159,1 @@\n-    for (PhaseNameIter iter(option); *iter != nullptr && _valid; ++iter) {\n+    for (StringUtils::CommaSeparatedStringIterator iter(option); *iter != nullptr && _valid; ++iter) {\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":6,"deletions":44,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-    if (out->is_CountedLoopEnd()) {\n+    if (out->is_BaseCountedLoopEnd()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,1 +279,1 @@\n-    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(), vec_box, first_ind, n_fields);\n+    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(), vec_box, first_ind, sfpt->jvms()->depth(), n_fields);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4100,1 +4100,1 @@\n-JVM_ENTRY(void, JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide))\n+JVM_ENTRY(void, JVM_VirtualThreadHideFrames(JNIEnv* env, jclass clazz, jboolean hide))\n@@ -4114,1 +4114,1 @@\n-JVM_ENTRY(void, JVM_VirtualThreadDisableSuspend(JNIEnv* env, jobject vthread, jboolean enter))\n+JVM_ENTRY(void, JVM_VirtualThreadDisableSuspend(JNIEnv* env, jclass clazz, jboolean enter))\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4099,3 +4099,3 @@\n-\/\/ phase then the compiler has recorded all dependencies from startup.\n-\/\/ In that case we need only deoptimize and throw away all compiled code\n-\/\/ that depends on the class.\n+\/\/ phase or 'AlwaysRecordEvolDependencies' is true, then the compiler has\n+\/\/ recorded all dependencies from startup. In that case we need only\n+\/\/ deoptimize and throw away all compiled code that depends on the class.\n@@ -4103,7 +4103,7 @@\n-\/\/ If can_redefine_classes is obtained sometime after the onload\n-\/\/ phase then the dependency information may be incomplete. In that case\n-\/\/ the first call to RedefineClasses causes all compiled code to be\n-\/\/ thrown away. As can_redefine_classes has been obtained then\n-\/\/ all future compilations will record dependencies so second and\n-\/\/ subsequent calls to RedefineClasses need only throw away code\n-\/\/ that depends on the class.\n+\/\/ If can_redefine_classes is obtained sometime after the onload phase\n+\/\/ (and 'AlwaysRecordEvolDependencies' is false) then the dependency\n+\/\/ information may be incomplete. In that case the first call to\n+\/\/ RedefineClasses causes all compiled code to be thrown away. As\n+\/\/ can_redefine_classes has been obtained then all future compilations will\n+\/\/ record dependencies so second and subsequent calls to RedefineClasses\n+\/\/ need only throw away code that depends on the class.\n@@ -4114,0 +4114,1 @@\n+  assert(JvmtiExport::all_dependencies_are_recorded() || !AlwaysRecordEvolDependencies, \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+#include \"oops\/methodData.inline.hpp\"\n@@ -1232,1 +1233,0 @@\n-    MutexLocker mu(THREAD, mdo->extra_data_lock());\n@@ -1983,1 +1983,1 @@\n-  if (cp->cache() == NULL) {\n+  if (cp->cache() == nullptr) {\n@@ -2001,1 +2001,1 @@\n-  if (cp->cache() == NULL) {\n+  if (cp->cache() == nullptr) {\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -498,4 +498,0 @@\n-  { \"MaxGCMinorPauseMillis\",        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"MaxRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"MinRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"InitialRAMFraction\",           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -511,2 +507,0 @@\n-  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -530,0 +524,6 @@\n+  { \"MaxGCMinorPauseMillis\",        JDK_Version::jdk(8), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"MaxRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"MinRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"InitialRAMFraction\",           JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n@@ -555,1 +555,0 @@\n-  { \"DefaultMaxRAMFraction\",    \"MaxRAMFraction\"    },\n@@ -1124,12 +1123,1 @@\n-    if (strlen(locked_message_buf) == 0) {\n-      if (found_flag->is_bool() && !has_plus_minus) {\n-        jio_fprintf(defaultStream::error_stream(),\n-          \"Missing +\/- setting for VM option '%s'\\n\", argname);\n-      } else if (!found_flag->is_bool() && has_plus_minus) {\n-        jio_fprintf(defaultStream::error_stream(),\n-          \"Unexpected +\/- setting in VM option '%s'\\n\", argname);\n-      } else {\n-        jio_fprintf(defaultStream::error_stream(),\n-          \"Improperly specified VM option '%s'\\n\", argname);\n-      }\n-    } else {\n+    if (strlen(locked_message_buf) != 0) {\n@@ -1145,0 +1133,10 @@\n+    if (found_flag->is_bool() && !has_plus_minus) {\n+      jio_fprintf(defaultStream::error_stream(),\n+        \"Missing +\/- setting for VM option '%s'\\n\", argname);\n+    } else if (!found_flag->is_bool() && has_plus_minus) {\n+      jio_fprintf(defaultStream::error_stream(),\n+        \"Unexpected +\/- setting in VM option '%s'\\n\", argname);\n+    } else {\n+      jio_fprintf(defaultStream::error_stream(),\n+        \"Improperly specified VM option '%s'\\n\", argname);\n+    }\n@@ -1483,3 +1481,0 @@\n-                           !FLAG_IS_DEFAULT(MaxRAMFraction) ||\n-                           !FLAG_IS_DEFAULT(MinRAMFraction) ||\n-                           !FLAG_IS_DEFAULT(InitialRAMFraction) ||\n@@ -1501,14 +1496,0 @@\n-\n-  \/\/ Convert deprecated flags\n-  if (FLAG_IS_DEFAULT(MaxRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(MaxRAMFraction))\n-    MaxRAMPercentage = 100.0 \/ (double)MaxRAMFraction;\n-\n-  if (FLAG_IS_DEFAULT(MinRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(MinRAMFraction))\n-    MinRAMPercentage = 100.0 \/ (double)MinRAMFraction;\n-\n-  if (FLAG_IS_DEFAULT(InitialRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(InitialRAMFraction))\n-    InitialRAMPercentage = 100.0 \/ (double)InitialRAMFraction;\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":17,"deletions":36,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -425,1 +425,2 @@\n-  for (int i = 0; i < chunk->length(); i++) {\n+  \/\/ Start locking from outermost\/oldest frame\n+  for (int i = (chunk->length() - 1); i >= 0; i--) {\n@@ -1700,0 +1701,4 @@\n+  \/\/ These objects may escape when we return to Interpreter after deoptimization.\n+  \/\/ We need barrier so that stores that initialize these objects can't be reordered\n+  \/\/ with subsequent stores that make these objects accessible by other threads.\n+  OrderAccess::storestore();\n@@ -1738,1 +1743,1 @@\n-          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n+          ObjectSynchronizer::enter_for(obj, nullptr, deoptee_thread);\n@@ -1740,1 +1745,1 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n@@ -1744,1 +1749,1 @@\n-          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n+          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n@@ -1817,1 +1822,2 @@\n-      for (int j = 0; j < monitors->number_of_monitors(); j++) {\n+      \/\/ Unlock in reverse order starting from most nested monitor.\n+      for (int j = (monitors->number_of_monitors() - 1); j >= 0; j--) {\n@@ -1894,0 +1900,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(imm_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -2199,0 +2208,6 @@\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      \/\/ We must do this already now, since we cannot acquire this lock while\n+      \/\/ holding the tty lock (lock ordering by rank).\n+      MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -2200,0 +2215,1 @@\n+\n@@ -2234,0 +2250,3 @@\n+\n+        \/\/ We need to lock to read the ProfileData. But to keep the locks ordered, we need to\n+        \/\/ lock extra_data_lock before the tty lock.\n@@ -2409,0 +2428,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    ConditionalMutexLocker ml((trap_mdo != nullptr) ? trap_mdo->extra_data_lock() : nullptr,\n+                              (trap_mdo != nullptr),\n+                              Mutex::_no_safepoint_check_flag);\n@@ -2415,0 +2439,1 @@\n+\n@@ -2570,0 +2595,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n@@ -2652,0 +2679,4 @@\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2053,0 +2053,5 @@\n+                                                                            \\\n+  product(bool, AlwaysRecordEvolDependencies, true, EXPERIMENTAL,           \\\n+                \"Unconditionally record nmethod dependencies on class \"     \\\n+                \"rewriting\/transformation independently of the JVMTI \"      \\\n+                \"can_{retransform\/redefine}_classes capabilities.\")         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,0 +118,6 @@\n+#if INCLUDE_JVMTI\n+  if (AlwaysRecordEvolDependencies) {\n+    JvmtiExport::set_can_hotswap_or_post_breakpoint(true);\n+    JvmtiExport::set_all_dependencies_are_recorded(true);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-  if (_scopedValueCache.ptr_raw() != nullptr) { \/\/ i.e. if the OopHandle has been allocated\n+  if (!_scopedValueCache.is_empty()) { \/\/ i.e. if the OopHandle has been allocated\n@@ -749,0 +749,1 @@\n+  assert(java_lang_Thread::thread(threadObj()) == thread, \"must be alive\");\n@@ -2159,0 +2160,2 @@\n+\n+  assert(java_lang_Thread::thread(thread_oop()) == nullptr, \"must not be alive\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,0 +262,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-class FieldStream;\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -621,0 +621,4 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+        MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -63,0 +64,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -463,2 +465,3 @@\n-void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* current) {\n-  frame last_frame = current->last_frame();\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread) {\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+  frame last_frame = locking_thread->last_frame();\n@@ -477,1 +480,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -479,1 +482,1 @@\n-    current->print_active_stack_on(&ss);\n+    locking_thread->print_active_stack_on(&ss);\n@@ -488,1 +491,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -492,1 +495,1 @@\n-    if (current->has_last_Java_frame()) {\n+    if (locking_thread->has_last_Java_frame()) {\n@@ -494,1 +497,1 @@\n-      current->print_active_stack_on(&info_stream);\n+      locking_thread->print_active_stack_on(&info_stream);\n@@ -521,3 +524,24 @@\n-\/\/ The interpreter and compiler assembly code tries to lock using the fast path\n-\/\/ of this algorithm. Make sure to update that code if the following function is\n-\/\/ changed. The implementation is extremely sensitive to race condition. Be careful.\n+\n+void ObjectSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  \/\/ When called with locking_thread != Thread::current() some mechanism must synchronize\n+  \/\/ the locking_thread with respect to the current thread. Currently only used when\n+  \/\/ deoptimizing and re-locking locks. See Deoptimization::relock_objects\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+  assert(locking_thread == Thread::current() || !EnableValhalla, \"not supported, fix needed: JDK-8331766\");\n+  JavaThread* current = locking_thread;\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n+  if (!enter_fast_impl(obj, lock, locking_thread)) {\n+    \/\/ Inflated ObjectMonitor::enter_for is required\n+\n+    \/\/ An async deflation can race after the inflate_for() call and before\n+    \/\/ enter_for() can make the ObjectMonitor busy. enter_for() returns false\n+    \/\/ if we have lost the race to async deflation and we simply try again.\n+    while (true) {\n+      ObjectMonitor* monitor = inflate_for(locking_thread, obj(), inflate_cause_monitor_enter);\n+      if (monitor->enter_for(locking_thread)) {\n+        return;\n+      }\n+      assert(monitor->is_being_async_deflated(), \"must be\");\n+    }\n+  }\n+}\n@@ -526,0 +550,1 @@\n+  assert(current == Thread::current(), \"must be\");\n@@ -527,0 +552,20 @@\n+  if (!enter_fast_impl(obj, lock, current)) {\n+    \/\/ Inflated ObjectMonitor::enter is required\n+\n+    \/\/ An async deflation can race after the inflate() call and before\n+    \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n+    \/\/ we have lost the race to async deflation and we simply try again.\n+    while (true) {\n+      ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n+      if (monitor->enter(current)) {\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ The interpreter and compiler assembly code tries to lock using the fast path\n+\/\/ of this algorithm. Make sure to update that code if the following function is\n+\/\/ changed. The implementation is extremely sensitive to race condition. Be careful.\n+bool ObjectSynchronizer::enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  guarantee(!EnableValhalla || !obj->klass()->is_inline_klass(), \"Attempt to inflate inline type\");\n@@ -528,1 +573,1 @@\n-    handle_sync_on_value_based_class(obj, current);\n+    handle_sync_on_value_based_class(obj, locking_thread);\n@@ -531,1 +576,1 @@\n-  current->inc_held_monitor_count();\n+  locking_thread->inc_held_monitor_count();\n@@ -536,1 +581,1 @@\n-      LockStack& lock_stack = current->lock_stack();\n+      LockStack& lock_stack = locking_thread->lock_stack();\n@@ -548,1 +593,1 @@\n-            return;\n+            return true;\n@@ -553,1 +598,3 @@\n-      \/\/ All other paths fall-through to inflate-enter.\n+\n+      \/\/ Failed to fast lock.\n+      return false;\n@@ -561,1 +608,1 @@\n-          return;\n+          return true;\n@@ -563,2 +610,1 @@\n-        \/\/ Fall through to inflate() ...\n-                 current->is_lock_owned((address) mark.locker())) {\n+                 locking_thread->is_lock_owned((address) mark.locker())) {\n@@ -569,1 +615,1 @@\n-        return;\n+        return true;\n@@ -577,0 +623,3 @@\n+\n+      \/\/ Failed to fast lock.\n+      return false;\n@@ -582,9 +631,1 @@\n-  \/\/ An async deflation can race after the inflate() call and before\n-  \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n-  \/\/ we have lost the race to async deflation and we simply try again.\n-  while (true) {\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n-    if (monitor->enter(current)) {\n-      return;\n-    }\n-  }\n+  return false;\n@@ -1324,5 +1365,11 @@\n-\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n-\/\/ calculations as part of JVM\/TI tagging.\n-static bool is_lock_owned(Thread* thread, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n-  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n+ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop obj, const InflateCause cause) {\n+  assert(current == Thread::current(), \"must be\");\n+  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n+    return inflate_impl(JavaThread::cast(current), obj, cause);\n+  }\n+  return inflate_impl(nullptr, obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_for(JavaThread* thread, oop obj, const InflateCause cause) {\n+  assert(thread == Thread::current() || thread->is_obj_deopt_suspend(), \"must be\");\n+  return inflate_impl(thread, obj, cause);\n@@ -1331,2 +1378,1 @@\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop object,\n-                                           const InflateCause cause) {\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n@@ -1336,1 +1382,8 @@\n-\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n@@ -1345,4 +1398,4 @@\n-    \/\/                   is anonymous and the current thread owns the\n-    \/\/                   object lock, then we make the current thread the\n-    \/\/                   ObjectMonitor owner and remove the lock from the\n-    \/\/                   current thread's lock stack.\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n@@ -1360,3 +1413,4 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(current, object)) {\n-        inf->set_owner_from_anonymous(current);\n-        JavaThread::cast(current)->lock_stack().remove(object);\n+      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        inflating_thread->lock_stack().remove(object);\n@@ -1382,1 +1436,1 @@\n-    \/\/ Could be fast-locked either by current or by some other thread.\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n@@ -1386,2 +1440,2 @@\n-    \/\/ this thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to this thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n@@ -1395,1 +1449,1 @@\n-      bool own = is_lock_owned(current, object);\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n@@ -1397,2 +1451,2 @@\n-        \/\/ Owned by us.\n-        monitor->set_owner_from(nullptr, current);\n+        \/\/ Owned by inflating_thread.\n+        monitor->set_owner_from(nullptr, inflating_thread);\n@@ -1408,1 +1462,1 @@\n-          JavaThread::cast(current)->lock_stack().remove(object);\n+          inflating_thread->lock_stack().remove(object);\n@@ -1418,1 +1472,1 @@\n-          ResourceMark rm(current);\n+          ResourceMark rm;\n@@ -1517,1 +1571,1 @@\n-        ResourceMark rm(current);\n+        ResourceMark rm;\n@@ -1561,1 +1615,1 @@\n-      ResourceMark rm(current);\n+      ResourceMark rm;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":108,"deletions":54,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1892,1 +1892,0 @@\n-   declare_integer_type(Generation::Name)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -854,0 +854,2 @@\n+#define DEFAULT_PERFMAP_FILENAME \"\/tmp\/perf-<pid>.map\"\n+\n@@ -856,1 +858,1 @@\n-  _filename(\"filename\", \"Name of the map file\", \"STRING\", false)\n+  _filename(\"filename\", \"Name of the map file\", \"STRING\", false, DEFAULT_PERFMAP_FILENAME)\n@@ -862,1 +864,4 @@\n-  CodeCache::write_perf_map(_filename.value());\n+  \/\/ The check for _filename.is_set() is because we don't want to use\n+  \/\/ DEFAULT_PERFMAP_FILENAME, since it is meant as a description\n+  \/\/ of the default, not the actual default.\n+  CodeCache::write_perf_map(_filename.is_set() ? _filename.value() : nullptr);\n@@ -1018,0 +1023,2 @@\n+#define DEFAULT_CDS_ARCHIVE_FILENAME \"java_pid<pid>_<subcmd>.jsa\"\n+\n@@ -1021,1 +1028,2 @@\n-  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false)\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false,\n+            DEFAULT_CDS_ARCHIVE_FILENAME)\n@@ -1030,1 +1038,5 @@\n-  const char* file = _filename.value();\n+\n+  \/\/ The check for _filename.is_set() is because we don't want to use\n+  \/\/ DEFAULT_CDS_ARCHIVE_FILENAME, since it is meant as a description\n+  \/\/ of the default, not the actual default.\n+  const char* file = _filename.is_set() ? _filename.value() : nullptr;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -780,1 +780,1 @@\n-  if (_writer != NULL) {\n+  if (_writer != nullptr) {\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,2 +129,0 @@\n-  const static GrowableArrayView EMPTY;\n-\n@@ -355,3 +353,0 @@\n-template<typename E>\n-const GrowableArrayView<E> GrowableArrayView<E>::EMPTY(nullptr, 0, 0);\n-\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -341,0 +342,20 @@\n+\n+StringUtils::CommaSeparatedStringIterator::~CommaSeparatedStringIterator() {\n+  FREE_C_HEAP_ARRAY(char, _list);\n+}\n+\n+ccstrlist StringUtils::CommaSeparatedStringIterator::canonicalize(ccstrlist option_value) {\n+  char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n+  int i = 0;\n+  char current;\n+  while ((current = option_value[i]) != '\\0') {\n+    if (current == '\\n' || current == ' ') {\n+      canonicalized_list[i] = ',';\n+    } else {\n+      canonicalized_list[i] = current;\n+    }\n+    i++;\n+  }\n+  canonicalized_list[i] = '\\0';\n+  return canonicalized_list;\n+}\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,5 @@\n+#ifdef _WINDOWS\n+  \/\/ strtok_s is the Windows thread-safe equivalent of POSIX strtok_r\n+# define strtok_r strtok_s\n+#endif\n+\n@@ -56,0 +61,27 @@\n+\n+  class CommaSeparatedStringIterator {\n+  private:\n+    char* _token;\n+    char* _saved_ptr;\n+    char* _list;\n+\n+  public:\n+    CommaSeparatedStringIterator(ccstrlist option) {\n+      \/\/ Immediately make a private copy of option, and\n+      \/\/ replace spaces and newlines with comma.\n+      _list = (char*) canonicalize(option);\n+      _saved_ptr = _list;\n+      _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n+    }\n+\n+    ~CommaSeparatedStringIterator();\n+\n+    const char* operator*() const { return _token; }\n+\n+    CommaSeparatedStringIterator& operator++() {\n+      _token = strtok_r(nullptr, \",\", &_saved_ptr);\n+      return *this;\n+    }\n+\n+    ccstrlist canonicalize(ccstrlist option_value);\n+  };\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -400,0 +400,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -1997,3 +1998,2 @@\n-        } catch (OutOfMemoryError memerr) {\n-            throw new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n-                                             Arrays.toString(ifaces), memerr);\n+        } catch (OutOfMemoryError oome) {\n+            throw genInvalidObjectException(oome, ifaces);\n@@ -2011,3 +2011,2 @@\n-        } catch (OutOfMemoryError memerr) {\n-            throw new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n-                                             Arrays.toString(ifaces), memerr);\n+        } catch (OutOfMemoryError oome) {\n+            throw genInvalidObjectException(oome, ifaces);\n@@ -2023,0 +2022,8 @@\n+    \/\/ Generate an InvalidObjectException for an OutOfMemoryError\n+    \/\/ Use String.concat() to avoid string formatting invoke dynamic\n+    private static InvalidObjectException genInvalidObjectException(OutOfMemoryError oome,\n+                                                                    String[] ifaces) {\n+        return new InvalidObjectException(\"Proxy interface limit exceeded: \"\n+                .concat(Arrays.toString(ifaces)), oome);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+\n+import jdk.internal.event.SerializationMisdeclarationEvent;\n@@ -469,0 +471,4 @@\n+\n+        if (SerializationMisdeclarationEvent.enabled() && serializable) {\n+            SerializationMisdeclarationChecker.checkMisdeclarations(cl);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -43,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -48,0 +51,1 @@\n+import jdk.internal.misc.PreviewFeatures;\n@@ -52,0 +56,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -53,1 +59,1 @@\n-import jdk.internal.misc.PreviewFeatures;\n+import sun.invoke.util.Wrapper;\n@@ -69,0 +75,1 @@\n+    private static final boolean previewEnabled = PreviewFeatures.isEnabled();\n@@ -78,0 +85,2 @@\n+    private static final Map<TypePairs, String> typePairToName;\n+\n@@ -93,0 +102,1 @@\n+        typePairToName = TypePairs.initialize();\n@@ -138,6 +148,9 @@\n-     * @throws NullPointerException if any argument is {@code null}\n-     * @throws IllegalArgumentException if any element in the labels array is null, if the\n-     * invocation type is not not a method type of first parameter of a reference type,\n-     * second parameter of type {@code int} and with {@code int} as its return type,\n-     * or if {@code labels} contains an element that is not of type {@code String},\n-     * {@code Integer}, {@code Class} or {@code EnumDesc}.\n+     * @throws NullPointerException     if any argument is {@code null}\n+     * @throws IllegalArgumentException if any element in the labels array is null\n+     * @throws IllegalArgumentException if the invocation type is not a method type of first parameter of a reference type,\n+     *                                  second parameter of type {@code int} and with {@code int} as its return type,\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code String},\n+     *                                  {@code Integer}, {@code Long}, {@code Float}, {@code Double}, {@code Boolean},\n+     *                                  {@code Class} or {@code EnumDesc}.\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code Boolean}\n+     *                                  when {@code target} is a {@code Boolean.class}.\n@@ -151,0 +164,1 @@\n+        Class<?> selectorType = invocationType.parameterType(0);\n@@ -153,1 +167,0 @@\n-            || invocationType.parameterType(0).isPrimitive()\n@@ -158,2 +171,1 @@\n-        labels = labels.clone();\n-        Stream.of(labels).forEach(SwitchBootstraps::verifyLabel);\n+        Stream.of(labels).forEach(l -> verifyLabel(l, selectorType));\n@@ -161,1 +173,1 @@\n-        MethodHandle target = generateInnerClass(lookup, labels);\n+        MethodHandle target = generateTypeSwitch(lookup, selectorType, labels);\n@@ -168,1 +180,1 @@\n-    private static void verifyLabel(Object label) {\n+    private static void verifyLabel(Object label, Class<?> selectorType) {\n@@ -173,0 +185,1 @@\n+\n@@ -176,0 +189,8 @@\n+\n+            ((labelClass != Float.class &&\n+              labelClass != Long.class &&\n+              labelClass != Double.class &&\n+              labelClass != Boolean.class) ||\n+              ((selectorType.equals(boolean.class) || selectorType.equals(Boolean.class)) && labelClass != Boolean.class && labelClass != Class.class) ||\n+             !previewEnabled) &&\n+\n@@ -270,1 +291,1 @@\n-                                                                            generateInnerClass(lookup, labels),\n+                                                                            generateTypeSwitch(lookup, invocationType.parameterType(0), labels),\n@@ -274,1 +295,1 @@\n-            target = generateInnerClass(lookup, labels);\n+            target = generateTypeSwitch(lookup, invocationType.parameterType(0), labels);\n@@ -385,55 +406,66 @@\n-    @SuppressWarnings(\"removal\")\n-    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Object[] labels) {\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n-\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n-            clb.withFlags(AccessFlag.FINAL, (PreviewFeatures.isEnabled())  ? AccessFlag.IDENTITY : AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-               .withMethodBody(\"typeSwitch\",\n-                               TYPES_SWITCH_DESCRIPTOR,\n-                               ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                               cb -> {\n-                    cb.aload(0);\n-                    Label nonNullLabel = cb.newLabel();\n-                    cb.if_nonnull(nonNullLabel);\n-                    cb.iconst_m1();\n-                    cb.ireturn();\n-                    cb.labelBinding(nonNullLabel);\n-                    if (labels.length == 0) {\n-                        cb.constantInstruction(0)\n-                          .ireturn();\n-                        return ;\n-                    }\n-                    cb.iload(1);\n-                    Label dflt = cb.newLabel();\n-                    record Element(Label target, Label next, Object caseLabel) {}\n-                    List<Element> cases = new ArrayList<>();\n-                    List<SwitchCase> switchCases = new ArrayList<>();\n-                    Object lastLabel = null;\n-                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n-                        Object currentLabel = labels[idx];\n-                        Label target = cb.newLabel();\n-                        Label next;\n-                        if (lastLabel == null) {\n-                            next = dflt;\n-                        } else if (lastLabel.equals(currentLabel)) {\n-                            next = cases.getLast().next();\n-                        } else {\n-                            next = cases.getLast().target();\n-                        }\n-                        lastLabel = currentLabel;\n-                        cases.add(new Element(target, next, currentLabel));\n-                        switchCases.add(SwitchCase.of(idx, target));\n-                    }\n-                    cases = cases.reversed();\n-                    switchCases = switchCases.reversed();\n-                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n-                    for (int idx = 0; idx < cases.size(); idx++) {\n-                        Element element = cases.get(idx);\n-                        Label next = element.next();\n-                        cb.labelBinding(element.target());\n-                        if (element.caseLabel() instanceof Class<?> classLabel) {\n-                            Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n-                            if (classLabelConstableOpt.isPresent()) {\n-                                cb.aload(0);\n-                                cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+    private static Consumer<CodeBuilder> generateTypeSwitchSkeleton(Class<?> selectorType, Object[] labelConstants, List<EnumDesc<?>> enumDescs, List<Class<?>> extraClassLabels) {\n+        int SELECTOR_OBJ        = 0;\n+        int RESTART_IDX         = 1;\n+        int ENUM_CACHE          = 2;\n+        int EXTRA_CLASS_LABELS  = 3;\n+\n+        return cb -> {\n+            cb.aload(SELECTOR_OBJ);\n+            Label nonNullLabel = cb.newLabel();\n+            cb.if_nonnull(nonNullLabel);\n+            cb.iconst_m1();\n+            cb.ireturn();\n+            cb.labelBinding(nonNullLabel);\n+            if (labelConstants.length == 0) {\n+                cb.constantInstruction(0)\n+                        .ireturn();\n+                return;\n+            }\n+            cb.iload(RESTART_IDX);\n+            Label dflt = cb.newLabel();\n+            record Element(Label target, Label next, Object caseLabel) { }\n+            List<Element> cases = new ArrayList<>();\n+            List<SwitchCase> switchCases = new ArrayList<>();\n+            Object lastLabel = null;\n+            for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+                Object currentLabel = labelConstants[idx];\n+                Label target = cb.newLabel();\n+                Label next;\n+                if (lastLabel == null) {\n+                    next = dflt;\n+                } else if (lastLabel.equals(currentLabel)) {\n+                    next = cases.getLast().next();\n+                } else {\n+                    next = cases.getLast().target();\n+                }\n+                lastLabel = currentLabel;\n+                cases.add(new Element(target, next, currentLabel));\n+                switchCases.add(SwitchCase.of(idx, target));\n+            }\n+            cases = cases.reversed();\n+            switchCases = switchCases.reversed();\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n+            for (int idx = 0; idx < cases.size(); idx++) {\n+                Element element = cases.get(idx);\n+                Label next = element.next();\n+                cb.labelBinding(element.target());\n+                if (element.caseLabel() instanceof Class<?> classLabel) {\n+                    if (unconditionalExactnessCheck(selectorType, classLabel)) {\n+                        \/\/nothing - unconditionally use this case\n+                    } else if (classLabel.isPrimitive()) {\n+                        if (!selectorType.isPrimitive() && !Wrapper.isWrapperNumericOrBooleanType(selectorType)) {\n+                            \/\/ Object o = ...\n+                            \/\/ o instanceof Wrapped(float)\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(Wrapper.forBasicType(classLabel)\n+                                    .wrapperType()\n+                                    .describeConstable()\n+                                    .orElseThrow());\n+                            cb.ifeq(next);\n+                        } else if (!unconditionalExactnessCheck(Wrapper.asPrimitiveType(selectorType), classLabel)) {\n+                            \/\/ Integer i = ... or int i = ...\n+                            \/\/ o instanceof float\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            if (selectorType == long.class || selectorType == float.class || selectorType == double.class) {\n@@ -442,12 +474,25 @@\n-                                cb.aload(3);\n-                                cb.constantInstruction(extraClassLabels.size());\n-                                cb.invokeinterface(ConstantDescs.CD_List,\n-                                                   \"get\",\n-                                                   MethodTypeDesc.of(ConstantDescs.CD_Object,\n-                                                                     ConstantDescs.CD_int));\n-                                cb.checkcast(ConstantDescs.CD_Class);\n-                                cb.aload(0);\n-                                cb.invokevirtual(ConstantDescs.CD_Class,\n-                                                 \"isInstance\",\n-                                                 MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                   ConstantDescs.CD_Object));\n+                                cb.ifeq(notNumber);\n+                            }\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            if (selectorType == long.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"longValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_long));\n+                            } else if (selectorType == float.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"floatValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_float));\n+                            } else if (selectorType == double.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"doubleValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_double));\n+                            } else {\n+                                Label compare = cb.newLabel();\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"intValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_int));\n+                                cb.goto_(compare);\n+                                cb.labelBinding(notNumber);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.instanceof_(ConstantDescs.CD_Character);\n@@ -455,1 +500,6 @@\n-                                extraClassLabels.add(classLabel);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.checkcast(ConstantDescs.CD_Character);\n+                                cb.invokevirtual(ConstantDescs.CD_Character,\n+                                        \"charValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_char));\n+                                cb.labelBinding(compare);\n@@ -457,23 +507,6 @@\n-                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n-                            int enumIdx = enumDescs.size();\n-                            enumDescs.add(enumLabel);\n-                            cb.aload(2);\n-                            cb.constantInstruction(enumIdx);\n-                            cb.invokestatic(ConstantDescs.CD_Integer,\n-                                            \"valueOf\",\n-                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n-                                                              ConstantDescs.CD_int));\n-                            cb.aload(0);\n-                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n-                                               \"test\",\n-                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                 ConstantDescs.CD_Object,\n-                                                                 ConstantDescs.CD_Object));\n-                            cb.ifeq(next);\n-                        } else if (element.caseLabel() instanceof String stringLabel) {\n-                            cb.ldc(stringLabel);\n-                            cb.aload(0);\n-                            cb.invokevirtual(ConstantDescs.CD_Object,\n-                                             \"equals\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                               ConstantDescs.CD_Object));\n+\n+                            TypePairs typePair = TypePairs.of(Wrapper.asPrimitiveType(selectorType), classLabel);\n+                            String methodName = typePairToName.get(typePair);\n+                            cb.invokestatic(ExactConversionsSupport.class.describeConstable().orElseThrow(),\n+                                    methodName,\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n@@ -481,15 +514,6 @@\n-                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n-                            Label compare = cb.newLabel();\n-                            Label notNumber = cb.newLabel();\n-                            cb.aload(0);\n-                            cb.instanceof_(ConstantDescs.CD_Number);\n-                            cb.ifeq(notNumber);\n-                            cb.aload(0);\n-                            cb.checkcast(ConstantDescs.CD_Number);\n-                            cb.invokevirtual(ConstantDescs.CD_Number,\n-                                             \"intValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n-                            cb.goto_(compare);\n-                            cb.labelBinding(notNumber);\n-                            cb.aload(0);\n-                            cb.instanceof_(ConstantDescs.CD_Character);\n+                        }\n+                    } else {\n+                        Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                        if (classLabelConstableOpt.isPresent()) {\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(classLabelConstableOpt.orElseThrow());\n@@ -497,10 +521,14 @@\n-                            cb.aload(0);\n-                            cb.checkcast(ConstantDescs.CD_Character);\n-                            cb.invokevirtual(ConstantDescs.CD_Character,\n-                                             \"charValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n-                            cb.labelBinding(compare);\n-                            cb.ldc(integerLabel);\n-                            cb.if_icmpne(next);\n-                            throw new InternalError(\"Unsupported label type: \" +\n-                                                    element.caseLabel().getClass());\n+                            cb.aload(EXTRA_CLASS_LABELS);\n+                            cb.constantInstruction(extraClassLabels.size());\n+                            cb.invokeinterface(ConstantDescs.CD_List,\n+                                    \"get\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                            ConstantDescs.CD_int));\n+                            cb.checkcast(ConstantDescs.CD_Class);\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.invokevirtual(ConstantDescs.CD_Class,\n+                                    \"isInstance\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                            ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                            extraClassLabels.add(classLabel);\n@@ -509,6 +537,95 @@\n-                        cb.constantInstruction(idx);\n-                        cb.ireturn();\n-                    cb.labelBinding(dflt);\n-                    cb.constantInstruction(cases.size());\n-                    cb.ireturn();\n-                });\n+                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                    int enumIdx = enumDescs.size();\n+                    enumDescs.add(enumLabel);\n+                    cb.aload(ENUM_CACHE);\n+                    cb.constantInstruction(enumIdx);\n+                    cb.invokestatic(ConstantDescs.CD_Integer,\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                    ConstantDescs.CD_int));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                            \"test\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof String stringLabel) {\n+                    cb.ldc(stringLabel);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                    Label compare = cb.newLabel();\n+                    Label notNumber = cb.newLabel();\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Number);\n+                    cb.ifeq(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Number);\n+                    cb.invokevirtual(ConstantDescs.CD_Number,\n+                            \"intValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_int));\n+                    cb.goto_(compare);\n+                    cb.labelBinding(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Character);\n+                    cb.ifeq(next);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Character);\n+                    cb.invokevirtual(ConstantDescs.CD_Character,\n+                            \"charValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_char));\n+                    cb.labelBinding(compare);\n+\n+                    cb.ldc(integerLabel);\n+                    cb.if_icmpne(next);\n+                } else if ((element.caseLabel() instanceof Long ||\n+                        element.caseLabel() instanceof Float ||\n+                        element.caseLabel() instanceof Double ||\n+                        element.caseLabel() instanceof Boolean)) {\n+                    if (element.caseLabel() instanceof Boolean c) {\n+                        cb.constantInstruction(c ? 1 : 0);\n+                    } else {\n+                        cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                    }\n+                    cb.invokestatic(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                                    Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else {\n+                    throw new InternalError(\"Unsupported label type: \" +\n+                            element.caseLabel().getClass());\n+                }\n+                cb.constantInstruction(idx);\n+                cb.ireturn();\n+            }\n+            cb.labelBinding(dflt);\n+            cb.constantInstruction(cases.size());\n+            cb.ireturn();\n+        };\n+    }\n+\n+    \/*\n+     * Construct the method handle that represents the method int typeSwitch(Object, int, BiPredicate, List)\n+     *\/\n+    private static MethodHandle generateTypeSwitch(MethodHandles.Lookup caller, Class<?> selectorType, Object[] labelConstants) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())),\n+                clb -> {\n+                    clb.withFlags(AccessFlag.FINAL, (PreviewFeatures.isEnabled())  ? AccessFlag.IDENTITY : AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+                       .withMethodBody(\"typeSwitch\",\n+                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                       generateTypeSwitchSkeleton(selectorType, labelConstants, enumDescs, extraClassLabels));\n@@ -529,2 +646,7 @@\n-            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n-                                                                List.copyOf(extraClassLabels));\n+            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                       List.copyOf(extraClassLabels));\n+            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n+                                                             MethodType.methodType(int.class,\n+                                                                                   selectorType,\n+                                                                                   int.class));\n+            return typeSwitch;\n@@ -545,0 +667,57 @@\n+\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    private static boolean unconditionalExactnessCheck(Class<?> selectorType, Class<?> targetType) {\n+        Wrapper selectorWrapper = Wrapper.forBasicType(selectorType);\n+        Wrapper targetWrapper   = Wrapper.forBasicType(targetType);\n+        if (selectorType.isPrimitive() && targetType.equals(selectorWrapper.wrapperType())) {\n+            return true;\n+        }\n+        else if (selectorType.equals(targetType) ||\n+                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n+                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n+                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n+                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n+                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n+        return false;\n+    }\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in Lower\n+    record TypePairs(Class<?> from, Class<?> to) {\n+        public static TypePairs of(Class<?> from,  Class<?> to) {\n+            if (from == byte.class || from == short.class || from == char.class) {\n+                from = int.class;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public static Map<TypePairs, String> initialize() {\n+            Map<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(byte.class,   char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   short.class),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(int.class,    byte.class),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(int.class,    short.class),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(int.class,    char.class),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(int.class,    float.class),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   byte.class),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(long.class,   short.class),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(long.class,   char.class),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(long.class,   int.class),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(long.class,   float.class),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   double.class), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(float.class,  byte.class),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(float.class,  short.class),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(float.class,  char.class),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(float.class,  int.class),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(float.class,  long.class),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, byte.class),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(double.class, short.class),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(double.class, char.class),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(double.class, int.class),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(double.class, long.class),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, float.class),  \"isDoubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":318,"deletions":139,"binary":false,"changes":457,"status":"modified"},{"patch":"@@ -321,0 +321,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -955,1 +955,1 @@\n-    public static abstract sealed class BoundCodeAttribute\n+    public abstract static sealed class BoundCodeAttribute\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-                        .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new));\n+                        .map(this::mapSignature).toArray(Signature.ClassTypeSig[]::new));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -917,1 +917,1 @@\n-    public static abstract non-sealed class AdHocAttribute<T extends Attribute<T>>\n+    public abstract static non-sealed class AdHocAttribute<T extends Attribute<T>>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -726,3 +726,4 @@\n-     * garbage.  The resulting native pointer will never be zero, and will be\n-     * aligned for all value types.  Dispose of this memory by calling {@link\n-     * #freeMemory}, or resize it with {@link #reallocateMemory}.\n+     * garbage.  The resulting native pointer will be zero if and only if the\n+     * requested size is zero.  The resulting native pointer will be aligned for\n+     * all value types.   Dispose of this memory by calling {@link #freeMemory}\n+     * or resize it with {@link #reallocateMemory}.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -592,1 +592,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+            case PRIMITIVE_PATTERNS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,0 +270,1 @@\n+        PRIMITIVE_PATTERNS(JDK23, Fragments.FeaturePrimitivePatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,1 +358,1 @@\n-        return metadata.isEmpty() ? this : baseType();\n+        return metadata.isEmpty() ? this : stripMetadata();\n@@ -444,0 +444,6 @@\n+        \/**\n+         * Note: this visitor only needs to handle cases where\n+         * 'contained' types can be annotated. These cases are\n+         * described in JVMS 4.7.20.2 and are : classes (for type\n+         * parameters and enclosing types), wildcards, and arrays.\n+         *\/\n@@ -447,1 +453,1 @@\n-                return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);\n+                return super.visitClassType((ClassType) dropMetadata(t), aVoid);\n@@ -452,1 +458,1 @@\n-                return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);\n+                return super.visitArrayType((ArrayType) dropMetadata(t), aVoid);\n@@ -456,2 +462,2 @@\n-            public Type visitTypeVar(TypeVar t, Void aVoid) {\n-                return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);\n+            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n+                return super.visitWildcardType((WildcardType) dropMetadata(wt), aVoid);\n@@ -461,2 +467,13 @@\n-            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n-                return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);\n+            public Type visitType(Type t, Void aVoid) {\n+                return dropMetadata(t);\n+            }\n+\n+            private static Type dropMetadata(Type t) {\n+                if (t.getMetadata().isEmpty()) {\n+                    return t;\n+                }\n+                Type baseType = t.baseType();\n+                if (baseType.getMetadata().isEmpty()) {\n+                    return baseType;\n+                }\n+                return baseType.cloneWithMetadata(List.nil());\n@@ -483,14 +500,0 @@\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n-        return null;\n-    }\n-\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n-        @SuppressWarnings(\"unchecked\")\n-        A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);\n-        return tmp;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":25,"deletions":22,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -5053,0 +5053,46 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n+    \/** Check unconditionality between any combination of reference or primitive types.\n+     *\n+     *  Rules:\n+     *    an identity conversion\n+     *    a widening reference conversion\n+     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n+     *    a boxing conversion\n+     *    a boxing conversion followed by a widening reference conversion\n+     *\n+     *  @param source     Source primitive or reference type\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExact(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        return target.isPrimitive()\n+                ? isUnconditionallyExactPrimitives(source, target)\n+                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+    }\n+\n+    \/** Check unconditionality between primitive types.\n+     *\n+     *  - widening from one integral type to another,\n+     *  - widening from one floating point type to another,\n+     *  - widening from byte, short, or char to a floating point type,\n+     *  - widening from int to double.\n+     *\n+     *  @param selectorType     Type of selector\n+     *  @param targetType       Target type\n+     *\/\n+    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n+        if (isSameType(selectorType, targetType)) {\n+            return true;\n+        }\n+\n+        return (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n+                ((selectorType.hasTag(BYTE) && !targetType.hasTag(CHAR)) ||\n+                 (selectorType.hasTag(SHORT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))) ||\n+                 (selectorType.hasTag(CHAR)  && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag())))  ||\n+                 (selectorType.hasTag(INT)   && (targetType.hasTag(DOUBLE) || targetType.hasTag(LONG))) ||\n+                 (selectorType.hasTag(FLOAT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))));\n+    }\n+    \/\/ <\/editor-fold>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1633,0 +1633,2 @@\n+        boolean wrongContext = false;\n+\n@@ -1639,2 +1641,2 @@\n-            result = tree.type = types.createErrorType(resultInfo.pt);\n-            return;\n+            resultInfo = recoveryInfo;\n+            wrongContext = true;\n@@ -1678,1 +1680,1 @@\n-        result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);\n+        result = tree.type = wrongContext? types.createErrorType(pt()) : check(tree, owntype, KindSelector.VAL, resultInfo);\n@@ -1705,0 +1707,1 @@\n+            boolean booleanSwitch = types.isSameType(types.unboxedTypeOrType(seltype), syms.booleanType);\n@@ -1707,1 +1710,4 @@\n-            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch;\n+            if (seltype.isPrimitive() && !intSwitch) {\n+                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                patternSwitch = true;\n+            }\n@@ -1710,1 +1716,1 @@\n-                !intSwitch && !errorPrimitiveSwitch) {\n+                !intSwitch) {\n@@ -1714,3 +1720,0 @@\n-                if (errorPrimitiveSwitch) {\n-                    log.error(selector.pos(), Errors.SelectorTypeNotAllowed(seltype));\n-                }\n@@ -1732,0 +1735,1 @@\n+            JCCaseLabel unconditionalCaseLabel = null;\n@@ -1799,4 +1803,9 @@\n-                                } else if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n-                                    log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                } else if (!constants.add(pattype.constValue())) {\n-                                    log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                }\n+                                else {\n+                                    if (!stringSwitch && !intSwitch &&\n+                                            !((pattype.getTag().isInSuperClassesOf(LONG) || pattype.getTag().equals(BOOLEAN)) &&\n+                                              types.isSameType(types.unboxedTypeOrType(seltype), pattype))) {\n+                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (!constants.add(pattype.constValue())) {\n+                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                    }\n@@ -1811,0 +1820,2 @@\n+                        }  else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                            log.error(label.pos(), Errors.DefaultAndBothBooleanValues);\n@@ -1819,1 +1830,4 @@\n-                        if (!primaryType.hasTag(TYPEVAR)) {\n+\n+                        if (primaryType.isPrimitive()) {\n+                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                        } else if (!primaryType.hasTag(TYPEVAR)) {\n@@ -1822,3 +1836,1 @@\n-                        if (!errorPrimitiveSwitch) {\n-                            checkCastablePattern(pat.pos(), seltype, primaryType);\n-                        }\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n@@ -1847,2 +1859,1 @@\n-                                types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n-                                                patternType);\n+                                types.isUnconditionallyExact(seltype, patternType);\n@@ -1854,0 +1865,2 @@\n+                            } else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                                log.error(pat.pos(), Errors.UnconditionalPatternAndBothBooleanValues);\n@@ -1856,0 +1869,1 @@\n+                            unconditionalCaseLabel = label;\n@@ -1882,1 +1896,1 @@\n-                chk.checkSwitchCaseLabelDominated(cases);\n+                chk.checkSwitchCaseLabelDominated(unconditionalCaseLabel, cases);\n@@ -4120,2 +4134,7 @@\n-        Type exprtype = chk.checkNullOrRefType(\n-                tree.expr.pos(), attribExpr(tree.expr, env));\n+        Type exprtype = attribExpr(tree.expr, env);\n+        if (exprtype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            exprtype = chk.checkNullOrRefType(\n+                    tree.expr.pos(), exprtype);\n+        }\n@@ -4142,11 +4161,5 @@\n-        if (!clazztype.hasTag(TYPEVAR)) {\n-            clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n-        }\n-        if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n-            boolean valid = false;\n-            if (allowReifiableTypesInInstanceof) {\n-                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n-            } else {\n-                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                          Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n-                allowReifiableTypesInInstanceof = true;\n+        if (clazztype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            if (!clazztype.hasTag(TYPEVAR)) {\n+                clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n@@ -4154,2 +4167,12 @@\n-            if (!valid) {\n-                clazztype = types.createErrorType(clazztype);\n+            if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n+                boolean valid = false;\n+                if (allowReifiableTypesInInstanceof) {\n+                    valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n+                } else {\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    allowReifiableTypesInInstanceof = true;\n+                }\n+                if (!valid) {\n+                    clazztype = types.createErrorType(clazztype);\n+                }\n@@ -4175,6 +4198,3 @@\n-                   (!exprType.isPrimitive() ||\n-                    !pattType.isPrimitive() ||\n-                    !types.isSameType(exprType, pattType))) {\n-            chk.basicHandler.report(pos,\n-                    diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n-            return false;\n+                (!exprType.isPrimitive() || !pattType.isPrimitive() || !types.isSameType(exprType, pattType))) {\n+            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":60,"deletions":40,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -4901,1 +4901,1 @@\n-    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+    void checkSwitchCaseLabelDominated(JCCaseLabel unconditionalCaseLabel, List<JCCase> cases) {\n@@ -4906,0 +4906,2 @@\n+        boolean unconditionalFound = false;\n+\n@@ -4933,1 +4935,3 @@\n-                    if (types.isSubtype(currentType, testType) &&\n+                    boolean dominated = false;\n+                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n+                    if (types.isUnconditionallyExact(currentType, testType) &&\n@@ -4936,1 +4940,0 @@\n-                        boolean dominated = false;\n@@ -4946,3 +4949,9 @@\n-                        if (dominated) {\n-                            log.error(label.pos(), Errors.PatternDominated);\n-                        }\n+                    }\n+\n+                    \/\/ Domination can occur even when we have not an unconditional pair between case labels.\n+                    if (unconditionalFound && unconditionalCaseLabel != label) {\n+                        dominated = true;\n+                    }\n+\n+                    if (dominated) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n@@ -4959,1 +4968,1 @@\n-                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                case CONSTANTCASELABEL -> ((JCConstantCaseLabel) label).expr.type;\n@@ -4966,1 +4975,1 @@\n-            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+            if (!types.isUnconditionallyExact(currentPatternType, existingPatternType)) {\n@@ -4969,7 +4978,0 @@\n-            if (existingPatternType.isPrimitive()) {\n-                return types.isSameType(existingPatternType, currentPatternType);\n-            } else {\n-                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n-                    return false;\n-                }\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final HashMap<TypePairs, String> typePairToName;\n@@ -136,0 +137,1 @@\n+        typePairToName = TypePairs.initialize(syms);\n@@ -2931,0 +2933,172 @@\n+    \/**\n+     * All the exactness checks between primitive types that require a run-time\n+     * check are in {@code java.lang.runtime.ExactConversionsSupport}. Those methods\n+     * are in the form {@code ExactConversionsSupport.is<S>To<T>Exact} where both\n+     * {@code S} and {@code T} are primitive types and correspond to the runtime\n+     * action that will be executed to check whether a certain value (that is passed\n+     * as a parameter) can be converted to {@code T} without loss of information.\n+     *\n+     * Rewrite {@code instanceof if expr : Object} and Type is primitive type:\n+     *\n+     * {@snippet :\n+     *   Object v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; tmp$123 instanceof Float)\n+     * }\n+     *\n+     * Rewrite {@code instanceof if expr : wrapper reference type}\n+     *\n+     * {@snippet :\n+     *   Integer v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; tmp$123 != null && ExactConversionsSupport.intToFloatExact(tmp$123.intValue()))\n+     * }\n+     *\n+     * Rewrite {@code instanceof if expr : primitive}\n+     *\n+     * {@snippet :\n+     *   int v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; ExactConversionsSupport.intToFloatExact(tmp$123))\n+     * }\n+     *\n+     * More rewritings:\n+     * <ul>\n+     * <li>If the {@code instanceof} check is unconditionally exact rewrite to true.<\/li>\n+     * <li>If expression type is {@code Byte}, {@code Short}, {@code Integer}, ..., an\n+     *     unboxing conversion followed by a widening primitive conversion.<\/li>\n+     * <li>If expression type is a supertype: {@code Number}, a narrowing reference\n+     *     conversion followed by an unboxing conversion.<\/li>\n+     * <\/ul>\n+     *\/\n+    public void visitTypeTest(JCInstanceOf tree) {\n+        if (tree.expr.type.isPrimitive() || tree.pattern.type.isPrimitive()) {\n+            JCExpression exactnessCheck = null;\n+            JCExpression instanceOfExpr = translate(tree.expr);\n+\n+            \/\/ preserving the side effects of the value\n+            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    tree.expr.type,\n+                    currentMethodSym);\n+            JCStatement var = make.at(tree.pos())\n+                    .VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+\n+            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+                exactnessCheck = make\n+                        .LetExpr(List.of(var), make.Literal(BOOLEAN, 1).setType(syms.booleanType.constType(1)))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isReference()) {\n+                JCExpression nullCheck = makeBinary(NE,\n+                        make.Ident(dollar_s),\n+                        makeNull());\n+                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                    exactnessCheck = make\n+                            .LetExpr(List.of(var), nullCheck)\n+                            .setType(syms.booleanType);\n+                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                    exactnessCheck = getExactnessCheck(tree,\n+                            boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type)));\n+                } else {\n+                    exactnessCheck = make.at(tree.pos())\n+                            .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n+                            .setType(syms.booleanType);\n+                }\n+\n+                exactnessCheck = make.LetExpr(List.of(var), makeBinary(AND,\n+                        nullCheck,\n+                        exactnessCheck))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isPrimitive()) {\n+                JCIdent argument = make.Ident(dollar_s);\n+\n+                JCExpression exactnessCheckCall =\n+                        getExactnessCheck(tree, argument);\n+\n+                exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n+                        .setType(syms.booleanType);\n+            }\n+\n+            result = exactnessCheck;\n+        } else {\n+            tree.expr = translate(tree.expr);\n+            tree.pattern = translate(tree.pattern);\n+            result = tree;\n+        }\n+    }\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in SwitchBootstraps\n+    record TypePairs(TypeSymbol from, TypeSymbol to) {\n+        public static TypePairs of(Symtab syms, Type from, Type to) {\n+            if (from == syms.byteType || from == syms.shortType || from == syms.charType) {\n+                from = syms.intType;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public TypePairs(Type from, Type to) {\n+            this(from.tsym, to.tsym);\n+        }\n+\n+        public static HashMap<TypePairs, String> initialize(Symtab syms) {\n+            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(syms.byteType,   syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.shortType),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.intType,    syms.byteType),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.shortType),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.charType),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.floatType),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.byteType),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.shortType),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.charType),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.intType),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.floatType),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.doubleType), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.byteType),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.shortType),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.charType),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.intType),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.longType),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.byteType),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.shortType),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.charType),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.intType),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.longType),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.floatType),  \"isDoubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n+\n+    private JCExpression getExactnessCheck(JCInstanceOf tree, JCExpression argument) {\n+        TypePairs pair = TypePairs.of(syms, types.unboxedTypeOrType(tree.expr.type), tree.pattern.type);\n+\n+        Name exactnessFunction = names.fromString(typePairToName.get(pair));\n+\n+        \/\/ Resolve the exactness method\n+        Symbol ecsym = lookupMethod(tree.pos(),\n+                exactnessFunction,\n+                syms.exactConversionsSupportType,\n+                List.of(pair.from.type));\n+\n+        \/\/ Generate the method call ExactnessChecks.<exactness method>(<argument>);\n+        JCFieldAccess select = make.Select(\n+                make.QualIdent(syms.exactConversionsSupportType.tsym),\n+                exactnessFunction);\n+        select.sym = ecsym;\n+        select.setType(syms.booleanType);\n+\n+        JCExpression exactnessCheck = make.Apply(List.nil(),\n+                select,\n+                List.of(argument));\n+        exactnessCheck.setType(syms.booleanType);\n+        return exactnessCheck;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -1271,3 +1271,1 @@\n-                deferredDiagnosticHandler.reportDeferredDiagnostics();\n-                log.popDiagnosticHandler(deferredDiagnosticHandler);\n-                compiler.setDeferredDiagnosticHandler(null);\n+                compiler.reportDeferredDiagnosticAndClearHandler();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -552,0 +552,6 @@\n+compiler.err.unconditional.pattern.and.both.boolean.values=\\\n+    switch has both boolean values and an unconditional pattern\n+\n+compiler.err.default.and.both.boolean.values=\\\n+    switch has both boolean values and a default label\n+\n@@ -566,4 +572,0 @@\n-# 0: type\n-compiler.err.selector.type.not.allowed=\\\n-    selector type {0} is not allowed\n-\n@@ -2668,4 +2670,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types=\\\n-    pattern of type {1} is not applicable at {0}\n-\n@@ -3206,0 +3204,3 @@\n+compiler.misc.feature.primitive.patterns=\\\n+    primitive patterns\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -438,3 +438,4 @@\n-     * garbage.  The resulting native pointer will never be zero, and will be\n-     * aligned for all value types.  Dispose of this memory by calling {@link\n-     * #freeMemory}, or resize it with {@link #reallocateMemory}.\n+     * garbage.  The resulting native pointer will be zero if and only if the\n+     * requested size is zero.  The resulting native pointer will be aligned for\n+     * all value types.   Dispose of this memory by calling {@link #freeMemory}\n+     * or resize it with {@link #reallocateMemory}.\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java 8325264 macosx-aarch64\n+compiler\/intrinsics\/float16\/Binary16Conversion.java 8325264 macosx-aarch64\n+\n@@ -113,0 +116,2 @@\n+runtime\/os\/TestTransparentHugePageUsage.java 8324776 linux-all\n+runtime\/Thread\/TestAlwaysPreTouchStacks.java 8324781 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,0 +24,5 @@\n+# All tests\n+\n+all = \\\n+  :hotspot_all\n+\n@@ -31,0 +36,2 @@\n+# Component test groups\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()) + \"'\", inlineeCount);\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2241,1 +2241,1 @@\n-                                                                          CompilePhase.MACRO_EXPANSION,\n+                                                                          CompilePhase.AFTER_MACRO_EXPANSION,\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,4 @@\n-        final String versionPattern = \"java.[0-9][0-9][-].*\";\n+        \/\/ Pattern of a module version string.\n+        \/\/ e.g. JDK 22:     \"java 22\"\n+        \/\/      JDK 22.0.1: \"java 22.0.1\"\n+        final String versionPattern = \"java.[0-9][0-9].*\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/module\/ModuleOption.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        if (runnable == NULL)  return JNI_FALSE;\n+        if (runnable == nullptr)  return JNI_FALSE;\n@@ -45,1 +45,1 @@\n-        if (methodId == NULL)  return JNI_FALSE;\n+        if (methodId == nullptr)  return JNI_FALSE;\n@@ -52,1 +52,1 @@\n-        if (test_class_A == NULL)  return JNI_FALSE;\n+        if (test_class_A == nullptr)  return JNI_FALSE;\n@@ -55,1 +55,1 @@\n-        if (test_class_B == NULL)  return JNI_FALSE;\n+        if (test_class_B == nullptr)  return JNI_FALSE;\n@@ -58,1 +58,1 @@\n-        if (test_staticM_id == NULL)  return JNI_FALSE;\n+        if (test_staticM_id == nullptr)  return JNI_FALSE;\n@@ -61,1 +61,1 @@\n-        if (test_staticS_id == NULL)  return JNI_FALSE;\n+        if (test_staticS_id == nullptr)  return JNI_FALSE;\n@@ -64,1 +64,1 @@\n-        if (test_staticN_id == NULL)  return JNI_FALSE;\n+        if (test_staticN_id == nullptr)  return JNI_FALSE;\n@@ -67,1 +67,1 @@\n-        if (test_A_m_id == NULL)  return JNI_FALSE;\n+        if (test_A_m_id == nullptr)  return JNI_FALSE;\n@@ -70,1 +70,1 @@\n-        if (test_staticF_id == NULL)  return JNI_FALSE;\n+        if (test_staticF_id == nullptr)  return JNI_FALSE;\n@@ -73,1 +73,1 @@\n-        if (test_A_f_id == NULL)  return JNI_FALSE;\n+        if (test_A_f_id == nullptr)  return JNI_FALSE;\n@@ -108,2 +108,2 @@\n-          return NULL;\n-        } else if (obj == NULL) {\n+          return nullptr;\n+        } else if (obj == nullptr) {\n@@ -112,1 +112,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -121,2 +121,2 @@\n-          return NULL;\n-        } else if (obj == NULL) {\n+          return nullptr;\n+        } else if (obj == nullptr) {\n@@ -125,1 +125,1 @@\n-          return NULL;\n+          return nullptr;\n","filename":"test\/hotspot\/jtreg\/runtime\/clinit\/libClassInitBarrier.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-  char* csig = NULL;\n+  char* csig = nullptr;\n@@ -56,1 +56,1 @@\n-  jmethodID *methods = NULL;\n+  jmethodID *methods = nullptr;\n@@ -58,3 +58,3 @@\n-  if (clazz == NULL) {\n-    jni->FatalError(\"is_hidden_mid: Error: FindClass returned NULL for java\/lang\/Class\\n\");\n-    return NULL;\n+  if (clazz == nullptr) {\n+    jni->FatalError(\"is_hidden_mid: Error: FindClass returned null for java\/lang\/Class\\n\");\n+    return nullptr;\n@@ -65,1 +65,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -74,1 +74,1 @@\n-  static jmethodID is_hid_mid = NULL;\n+  static jmethodID is_hid_mid = nullptr;\n@@ -76,1 +76,1 @@\n-  if (is_hid_mid == NULL) {\n+  if (is_hid_mid == nullptr) {\n@@ -92,2 +92,2 @@\n-  char* sig = NULL;\n-  char* gsig = NULL;\n+  char* sig = nullptr;\n+  char* gsig = nullptr;\n@@ -107,2 +107,2 @@\n-  if (is_hidden && gsig == NULL) {\n-    LOG0(\"check_class_signature: FAIL: unexpected NULL generic signature for hidden class\\n\");\n+  if (is_hidden && gsig == nullptr) {\n+    LOG0(\"check_class_signature: FAIL: unexpected null generic signature for hidden class\\n\");\n@@ -156,2 +156,2 @@\n-  jobject loader = NULL;\n-  jclass* loader_classes = NULL;\n+  jobject loader = nullptr;\n+  jclass* loader_classes = nullptr;\n@@ -170,1 +170,1 @@\n-    char* sig = NULL;\n+    char* sig = nullptr;\n@@ -178,1 +178,1 @@\n-    err = jvmti->GetClassSignature(kls, &sig, NULL);\n+    err = jvmti->GetClassSignature(kls, &sig, nullptr);\n@@ -191,1 +191,1 @@\n-  char* sig = NULL;\n+  char* sig = nullptr;\n@@ -193,1 +193,1 @@\n-  jclass* interfaces = NULL;\n+  jclass* interfaces = nullptr;\n@@ -207,1 +207,1 @@\n-    err = jvmti->GetClassSignature(interfaces[i], &sig, NULL);\n+    err = jvmti->GetClassSignature(interfaces[i], &sig, nullptr);\n@@ -225,1 +225,1 @@\n-  char* source_file_name = NULL;\n+  char* source_file_name = nullptr;\n@@ -247,1 +247,1 @@\n-  char* source_file_name = NULL;\n+  char* source_file_name = nullptr;\n@@ -260,2 +260,2 @@\n-  char* sig = NULL;\n-  char* gsig = NULL;\n+  char* sig = nullptr;\n+  char* gsig = nullptr;\n@@ -273,2 +273,2 @@\n-    if (gsig == NULL) {\n-      LOG1(\"%s event: FAIL: GetClassSignature returned NULL generic signature for hidden class\\n\", event_name);\n+    if (gsig == nullptr) {\n+      LOG1(\"%s event: FAIL: GetClassSignature returned null generic signature for hidden class\\n\", event_name);\n@@ -303,1 +303,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -307,1 +307,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -337,1 +337,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -351,1 +351,1 @@\n-  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, NULL);\n+  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, nullptr);\n@@ -353,2 +353,2 @@\n-  if (exp_sig == NULL) {\n-    jni->FatalError(\"check_hidden_class: Error: JNI GetStringChars returned NULL for jstring\\n\");\n+  if (exp_sig == nullptr) {\n+    jni->FatalError(\"check_hidden_class: Error: JNI GetStringChars returned null for jstring\\n\");\n@@ -365,1 +365,1 @@\n-  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, NULL);\n+  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, nullptr);\n@@ -367,2 +367,2 @@\n-  if (exp_sig == NULL) {\n-    jni->FatalError(\"check_hidden_class_array: Error: JNI GetStringChars returned NULL for jstring\\n\");\n+  if (exp_sig == nullptr) {\n+    jni->FatalError(\"check_hidden_class_array: Error: JNI GetStringChars returned null for jstring\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HiddenClass\/libHiddenClassSigTest.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -446,2 +446,2 @@\n-java\/awt\/GridLayout\/ComponentPreferredSize\/ComponentPreferredSize.java 8238720 windows-all\n-java\/awt\/GridLayout\/ChangeGridSize\/ChangeGridSize.java   8238720 windows-all\n+java\/awt\/GridLayout\/ComponentPreferredSize\/ComponentPreferredSize.java 8238720,8324782 windows-all,macosx-all\n+java\/awt\/GridLayout\/ChangeGridSize\/ChangeGridSize.java   8238720,8324782 windows-all,macosx-all\n@@ -475,0 +475,3 @@\n+# This test fails on macOS 14\n+java\/awt\/Choice\/SelectNewItemTest\/SelectNewItemTest.java 8324782 macosx-all\n+\n@@ -688,0 +691,3 @@\n+# This test fails on macOS 14\n+javax\/swing\/plaf\/synth\/7158712\/bug7158712.java 8324782 macosx-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -23,0 +23,11 @@\n+###############################################################################\n+#\n+# All tests\n+#\n+\n+all = \\\n+    :jdk_all\n+\n+jdk_all = \\\n+    \/\n+\n","filename":"test\/jdk\/TEST.groups","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -363,1 +363,1 @@\n-                           \"  public static final java.lang.String AMP = \\\"&amp;&&lt;<&gt;>&apos;\\\\'\\\";\\n\\n\" +\n+                           \"  public static final java.lang.String AMP = \\\"&amp;&&lt;<&gt;>&apos;'\\\";\\n\\n\" +\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}