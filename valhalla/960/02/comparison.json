{"files":[{"patch":"@@ -140,0 +140,1 @@\n+JVM_GetZeroInstance\n@@ -159,0 +160,1 @@\n+JVM_IsImplicitlyConstructibleClass\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3451,1 +3451,1 @@\n-int java_lang_reflect_Field::_trusted_final_offset;\n+int java_lang_reflect_Field::_flags_offset;\n@@ -3461,1 +3461,1 @@\n-  macro(_trusted_final_offset,    k, vmSymbols::trusted_final_name(),    bool_signature,       false); \\\n+  macro(_flags_offset,     k, vmSymbols::flags_name(),     int_signature,    false); \\\n@@ -3526,2 +3526,2 @@\n-void java_lang_reflect_Field::set_trusted_final(oop field) {\n-  field->bool_field_put(_trusted_final_offset, true);\n+void java_lang_reflect_Field::set_flags(oop field, int value) {\n+  field->int_field_put(_flags_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -773,1 +773,1 @@\n-  static int _trusted_final_offset;\n+  static int _flags_offset;\n@@ -801,1 +801,1 @@\n-  static void set_trusted_final(oop field);\n+  static void set_flags(oop field, int value);\n@@ -1304,2 +1304,3 @@\n-    MN_REFERENCE_KIND_SHIFT  = 24, \/\/ refKind\n-    MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n+    MN_NULL_RESTRICTED_FIELD = 0x01000000, \/\/ null-restricted field\n+    MN_REFERENCE_KIND_SHIFT  = 26, \/\/ refKind\n+    MN_REFERENCE_KIND_MASK   = 0x3C000000 >> MN_REFERENCE_KIND_SHIFT,\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -304,1 +304,0 @@\n-  template(trusted_final_name,                        \"trustedFinal\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -582,0 +582,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsImplicitlyConstructibleClass(JNIEnv *env, jclass cls);\n+\n@@ -1137,0 +1140,3 @@\n+JNIEXPORT jobject JNICALL\n+JVM_GetZeroInstance(JNIEnv *env, jclass cls);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -426,0 +426,16 @@\n+JVM_ENTRY(jobject, JVM_GetZeroInstance(JNIEnv *env, jclass cls)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+  k->initialize(CHECK_NULL);\n+  if (!k->is_value_class()) {\n+    ResourceMark rm;\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), err_msg(\"%s not a value class\", k->external_name()));\n+  }\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  if (!vk->is_implicitly_constructible()) {\n+    ResourceMark rm;\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), err_msg(\"%s not implicitly constructible\", vk->external_name()));\n+  }\n+  oop v = vk->default_value();\n+  return JNIHandles::make_local(THREAD, v);\n+}\n+JVM_END\n@@ -1298,0 +1314,6 @@\n+JVM_ENTRY(jboolean, JVM_IsImplicitlyConstructibleClass(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  return ik->is_implicitly_constructible();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -141,1 +141,2 @@\n-  FLATTENED             = java_lang_invoke_MemberName::MN_FLAT_FIELD,\n+  FLAT_FIELD            = java_lang_invoke_MemberName::MN_FLAT_FIELD,\n+  NULL_RESTRICTED       = java_lang_invoke_MemberName::MN_NULL_RESTRICTED_FIELD,\n@@ -359,1 +360,2 @@\n-  if (fd.is_flat()) flags |= FLATTENED;;\n+  if (fd.is_flat()) flags |= FLAT_FIELD;\n+  if (fd.is_null_free_inline_type()) flags |= NULL_RESTRICTED;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -347,7 +347,0 @@\n-UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n-  InlineKlass* vk = InlineKlass::cast(k);\n-  oop v = vk->default_value();\n-  return JNIHandles::make_local(THREAD, v);\n-} UNSAFE_END\n-\n@@ -1007,1 +1000,0 @@\n-    {CC \"uninitializedDefaultValue\", CC \"(\" CLS \")\" OBJ,         FN_PTR(Unsafe_UninitializedDefaultValue)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -883,0 +883,2 @@\n+\n+  int flags = 0;\n@@ -884,1 +886,4 @@\n-    java_lang_reflect_Field::set_trusted_final(rh());\n+    flags |= TRUSTED_FINAL;\n+  }\n+  if (fd->is_null_free_inline_type()) {\n+    flags |= NULL_RESTRICTED;\n@@ -886,0 +891,2 @@\n+  java_lang_reflect_Field::set_flags(rh(), flags);\n+\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+    TRUSTED_FINAL     = 0x10,\n+    NULL_RESTRICTED   = 0x20,\n","filename":"src\/hotspot\/share\/runtime\/reflection.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -1964,1 +1965,1 @@\n-            Object obj = UNSAFE.uninitializedDefaultValue(clazz);\n+            Object obj = ValueClass.zeroInstance(clazz);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -634,3 +634,3 @@\n-            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flattened and non-flattened\n-            FT_LIMIT            = FT_LAST_WRAPPER+4;\n-    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {\n+            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flattened and non-flattened and null-restricted\n+            FT_LIMIT            = FT_LAST_WRAPPER+6;\n+    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, boolean isNullRestricted, int ftypeKind) {\n@@ -640,0 +640,1 @@\n+                + (isNullRestricted ? 1 : 0)\n@@ -644,1 +645,1 @@\n-            = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];\n+            = new LambdaForm[afIndex(AF_LIMIT, false, false, false, 0)];\n@@ -664,1 +665,0 @@\n-        boolean isVolatile = m.isVolatile();\n@@ -674,1 +674,1 @@\n-            preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);\n+            preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlat(), m.isNullRestricted(), ftype);\n@@ -679,1 +679,1 @@\n-        LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);\n+        LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlat(), m.isNullRestricted(), ftype);\n@@ -687,1 +687,2 @@\n-    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class<?> ftype) {\n+    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile,\n+                                                      boolean isValue, boolean isFlat, boolean isNullRestricted, Class<?> ftype) {\n@@ -689,1 +690,1 @@\n-        int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);\n+        int afIndex = afIndex(formOp, isVolatile, isFlat, isNullRestricted, ftypeKind);\n@@ -692,1 +693,1 @@\n-        lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);\n+        lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlat, isNullRestricted, ftypeKind);\n@@ -699,1 +700,3 @@\n-    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {\n+    private static Kind getFieldKind(boolean isGetter, boolean isVolatile,\n+                                     boolean isFlatValue, boolean isNullRestricted,\n+                                     Wrapper wrapper) {\n@@ -711,1 +714,2 @@\n-                    case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE\n+                                                     : isNullRestricted ? GET_NULL_RESTRICTED_REFERENCE_VOLATILE : GET_REFERENCE_VOLATILE;\n@@ -723,1 +727,2 @@\n-                    case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE\n+                                                     : isNullRestricted ? GET_NULL_RESTRICTED_REFERENCE : GET_REFERENCE;\n@@ -758,1 +763,1 @@\n-        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);\n+        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, false, ftype);\n@@ -761,1 +766,3 @@\n-    private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {\n+    private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile,\n+                                                          boolean isValue, boolean isFlat,\n+                                                          boolean isNullRestricted, int ftypeKind) {\n@@ -771,1 +778,1 @@\n-        Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);\n+        Kind kind = getFieldKind(isGetter, isVolatile, isFlat, isNullRestricted, fw);\n@@ -774,1 +781,1 @@\n-        boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;\n+        boolean hasValueTypeArg = isGetter ? isValue : isFlat;\n@@ -779,2 +786,2 @@\n-            linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)\n-                                     : MethodType.methodType(void.class, Object.class, long.class, ft);\n+            linkerType = isFlat ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)\n+                                : MethodType.methodType(void.class, Object.class, long.class, ft);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -264,0 +264,2 @@\n+        GET_NULL_RESTRICTED_REFERENCE(\"getNullRestrictedReference\"),\n+        GET_NULL_RESTRICTED_REFERENCE_VOLATILE(\"getNullRestrictedReferenceVolatile\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -436,1 +436,4 @@\n-    public boolean isFlattened() { return (flags & MN_FLATTENED) == MN_FLATTENED; }\n+    public boolean isFlat() { return (flags & MN_FLAT_FIELD) == MN_FLAT_FIELD; }\n+\n+    \/** Query whether this member is a null-restricted field *\/\n+    public boolean isNullRestricted() { return (flags & MN_NULL_RESTRICTED) == MN_NULL_RESTRICTED; }\n@@ -669,1 +672,1 @@\n-        assert(refKind == (isStatic() ? REF_getStatic : REF_getField));\n+        assert(refKind == (isStatic() ? REF_getStatic : REF_getField)) : \" refKind \" + refKind;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1566,0 +1566,6 @@\n+            public boolean isNullRestrictedField(MethodHandle mh) {\n+                var memberName = mh.internalMemberName();\n+                assert memberName.isField();\n+                return memberName.isNullRestricted();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -120,3 +120,4 @@\n-            MN_FLATTENED             = 0x00800000, \/\/ flattened field\n-            MN_REFERENCE_KIND_SHIFT  = 24, \/\/ refKind\n-            MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT;\n+            MN_FLAT_FIELD            = 0x00800000, \/\/ flat field\n+            MN_NULL_RESTRICTED       = 0x01000000, \/\/ null-restricted field\n+            MN_REFERENCE_KIND_SHIFT  = 26, \/\/ refKind\n+            MN_REFERENCE_KIND_MASK   = 0x3C000000 >> MN_REFERENCE_KIND_SHIFT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -5201,1 +5202,1 @@\n-            Object value = UNSAFE.uninitializedDefaultValue(type);\n+            Object value = ValueClass.zeroInstance(type);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                if (f.isFlattened()) {\n+                if (f.isFlat()) {\n@@ -64,2 +64,2 @@\n-                        ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type)\n-                        : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type));\n+                        ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted())\n+                        : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted()));\n@@ -68,2 +68,2 @@\n-                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)\n-                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type));\n+                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted())\n+                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted()));\n@@ -130,1 +130,1 @@\n-            if (f.isFlattened()) {\n+            if (f.isFlat()) {\n@@ -132,2 +132,2 @@\n-                        ? new VarHandleValues.FieldStaticReadOnly(decl, base, foffset, type)\n-                        : new VarHandleValues.FieldStaticReadWrite(decl, base, foffset, type));\n+                        ? new VarHandleValues.FieldStaticReadOnly(decl, base, foffset, type, f.isNullRestricted())\n+                        : new VarHandleValues.FieldStaticReadWrite(decl, base, foffset, type, f.isNullRestricted()));\n@@ -136,2 +136,2 @@\n-                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n-                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type);\n+                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.isNullRestricted())\n+                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.isNullRestricted());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+#if[Reference]\n+import jdk.internal.value.ValueClass;\n+#end[Reference]\n@@ -46,0 +49,3 @@\n+#if[Reference]\n+        final boolean nullRestricted;\n+#end[Reference]\n@@ -47,2 +53,2 @@\n-        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM, false);\n+        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldInstanceReadOnly.FORM, false);\n@@ -51,1 +57,1 @@\n-        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n@@ -59,0 +65,3 @@\n+#if[Reference]\n+            this.nullRestricted = nullRestricted;\n+#end[Reference]\n@@ -65,1 +74,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, vform, true);\n@@ -72,1 +81,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, vform, false);\n@@ -96,1 +105,1 @@\n-            return UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+            $type$ value = UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),\n@@ -98,0 +107,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -103,1 +118,1 @@\n-            return UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+            $type$ value = UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),\n@@ -105,0 +120,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -110,1 +131,1 @@\n-            return UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+            $type$ value = UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),\n@@ -112,0 +133,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -117,1 +144,1 @@\n-            return UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+            $type$ value = UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),\n@@ -119,0 +146,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -125,2 +158,2 @@\n-        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n+        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}, false);\n@@ -129,1 +162,1 @@\n-        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n@@ -131,1 +164,1 @@\n-            super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM, exact);\n+            super(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldInstanceReadWrite.FORM, exact);\n@@ -138,1 +171,1 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, true);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, true);\n@@ -145,1 +178,1 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, false);\n@@ -396,0 +429,1 @@\n+        final boolean nullRestricted;\n@@ -398,2 +432,2 @@\n-        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n+        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldStaticReadOnly.FORM, false);\n@@ -402,1 +436,1 @@\n-        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n@@ -410,0 +444,1 @@\n+            this.nullRestricted = nullRestricted;\n@@ -417,1 +452,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, vform, true);\n@@ -424,1 +459,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, vform, false);\n@@ -450,1 +485,1 @@\n-            return UNSAFE.get$Type$(handle.base,\n+            $type$ value = UNSAFE.get$Type$(handle.base,\n@@ -452,0 +487,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -457,1 +498,1 @@\n-            return UNSAFE.get$Type$Volatile(handle.base,\n+            $type$ value = UNSAFE.get$Type$Volatile(handle.base,\n@@ -459,0 +500,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -464,1 +511,1 @@\n-            return UNSAFE.get$Type$Opaque(handle.base,\n+            $type$ value = UNSAFE.get$Type$Opaque(handle.base,\n@@ -466,0 +513,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -471,1 +524,1 @@\n-            return UNSAFE.get$Type$Acquire(handle.base,\n+            $type$ value = UNSAFE.get$Type$Acquire(handle.base,\n@@ -473,0 +526,6 @@\n+#if[Reference]\n+            if (handle.nullRestricted && value == null) {\n+                return ValueClass.zeroInstance(handle.fieldType);\n+            }\n+#end[Reference]\n+            return value;\n@@ -480,2 +539,2 @@\n-        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n+        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, false);\n@@ -484,1 +543,1 @@\n-        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n@@ -486,1 +545,1 @@\n-            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n+            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldStaticReadWrite.FORM, exact);\n@@ -493,1 +552,1 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, true);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}{#if[Reference]?, nullRestricted}, true);\n@@ -500,1 +559,1 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}{#if[Reference]?, nullRestricted}, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":89,"deletions":30,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    private final boolean             trustedFinal;\n+    private final int                 flags;\n@@ -130,1 +130,1 @@\n-          boolean trustedFinal,\n+          int flags,\n@@ -140,1 +140,1 @@\n-        this.trustedFinal = trustedFinal;\n+        this.flags = flags;\n@@ -162,1 +162,1 @@\n-        Field res = new Field(clazz, name, type, modifiers, trustedFinal, slot, signature, annotations);\n+        Field res = new Field(clazz, name, type, modifiers, flags, slot, signature, annotations);\n@@ -1251,0 +1251,3 @@\n+    private static final int TRUST_FINAL     = 0x0010;\n+    private static final int NULL_RESTRICTED = 0x0020;\n+\n@@ -1252,1 +1255,5 @@\n-        return trustedFinal;\n+        return (flags & TRUST_FINAL) == TRUST_FINAL;\n+    }\n+\n+    \/* package-private *\/ boolean isNullRestricted() {\n+        return (flags & NULL_RESTRICTED) == NULL_RESTRICTED;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -181,0 +181,3 @@\n+                    assert !JLIA.isNullRestrictedField(getter) ||  (f1 != null && f2 != null) :\n+                            \"null restricted field \" + ftype.getName() + \" in container \" + type.getName();\n+\n@@ -241,0 +244,2 @@\n+                    assert !JLIA.isNullRestrictedField(getter) || f != null :\n+                            \"null restricted field \" + ftype.getName() + \" in container \" + type.getName();\n@@ -508,2 +513,3 @@\n-            System.out.println(type.getName() + \" valueHashCode \" + nonRecurTypeGetters + \" \" + recurTypeGetters);\n-\n+            if (VERBOSE) {\n+                System.out.println(type.getName() + \" valueHashCode \" + nonRecurTypeGetters + \" recursive types \" + recurTypeGetters);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    \/**\n+     * Returns true if the member of the given method handle is a null-restricted\n+     * field.\n+     *\/\n+    boolean isNullRestrictedField(MethodHandle mh);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -277,2 +278,2 @@\n-            \/\/ return an uninitialized default value if null\n-            ref = uninitializedDefaultValue(type);\n+            \/\/ return the zero instance if null\n+            ref = ValueClass.zeroInstance(type);\n@@ -287,2 +288,2 @@\n-            \/\/ return an uninitialized default value if null\n-            ref = uninitializedDefaultValue(type);\n+            \/\/ return the zero instance if null\n+            ref = ValueClass.zeroInstance(type);\n@@ -294,1 +295,8 @@\n-     * Returns an uninitialized default value of the given value type.\n+     * Fetches a reference value of the given type from a given null-restricted\n+     * Java variable.  The VM may lazily set a null-restricted non-flat field.\n+     * If the reference value is null, return a zero instance instead.\n+     *\n+     * @apiNote This API is temporary.  It will be replaced when CheckedType\n+     *          is implemented.\n+     *\n+     * @param type type\n@@ -296,1 +304,9 @@\n-    public native <V> V uninitializedDefaultValue(Class<?> type);\n+    public Object getNullRestrictedReference(Object o, long offset, Class<?> type) {\n+        Object ref = getReference(o, offset);\n+        return ref != null ? ref : ValueClass.zeroInstance(type);\n+    }\n+\n+    public Object getNullRestrictedReferenceVolatile(Object o, long offset, Class<?> type) {\n+        Object ref = getReferenceVolatile(o, offset);\n+        return ref != null ? ref : ValueClass.zeroInstance(type);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -498,16 +498,0 @@\n-\n-    \/**\n-     * Allocate an array of a value class type with components that behave in\n-     * the same way as a {@link jdk.internal.vm.annotation.NullRestricted}\n-     * field.\n-     * <p>\n-     * Because these behaviors are not specified by Java SE, arrays created with\n-     * this method should only be used by internal JDK code for experimental\n-     * purposes and should not affect user-observable outcomes.\n-     *\n-     * @throws IllegalArgumentException if {@code componentType} is not a\n-     *         value class type or is not annotated with\n-     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n-     *\/\n-    public static native Object[] newNullRestrictedArray(Class<?> componentType,\n-                                                         int length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.value;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+\/**\n+ * Utilities to access\n+ *\/\n+public class ValueClass {\n+    private static final JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n+\n+    \/**\n+     * Returns true if the given {@code Class} object is implicitly constructible\n+     *\/\n+    public static native boolean isImplicitlyConstructible(Class<?> cls);\n+\n+    \/**\n+     * Returns the default value of the given value class type.\n+     *\n+     * @throws IllegalArgumentException if {@code cls} is not a\n+     *         value class type or is not annotated with\n+     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n+     *\/\n+    public static native <T> T zeroInstance(Class<T> cls);\n+\n+    \/**\n+     * Allocate an array of a value class type with components that behave in\n+     * the same way as a {@link jdk.internal.vm.annotation.NullRestricted}\n+     * field.\n+     * <p>\n+     * Because these behaviors are not specified by Java SE, arrays created with\n+     * this method should only be used by internal JDK code for experimental\n+     * purposes and should not affect user-observable outcomes.\n+     *\n+     * @throws IllegalArgumentException if {@code componentType} is not a\n+     *         value class type or is not annotated with\n+     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n+     *\/\n+    public static native Object[] newNullRestrictedArray(Class<?> componentType,\n+                                                         int length);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -57,6 +57,0 @@\n-}\n-\n-JNIEXPORT jarray JNICALL\n-Java_jdk_internal_misc_VM_newNullRestrictedArray(JNIEnv *env, jclass cls, jclass elmClass, jint len)\n-{\n-    return JVM_NewNullRestrictedArray(env, elmClass, len);\n","filename":"src\/java.base\/share\/native\/libjava\/VM.c","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_value_ValueClass.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_value_ValueClass_isImplicitlyConstructible(JNIEnv *env, jclass dummy, jclass cls) {\n+    return JVM_IsImplicitlyConstructibleClass(env, cls);\n+}\n+\n+JNIEXPORT jobject JNICALL\n+Java_jdk_internal_value_ValueClass_zeroInstance(JNIEnv *env, jclass dummy, jclass cls) {\n+    return JVM_GetZeroInstance(env, cls);\n+}\n+\n+JNIEXPORT jarray JNICALL\n+Java_jdk_internal_value_ValueClass_newNullRestrictedArray(JNIEnv *env, jclass cls, jclass elmClass, jint len)\n+{\n+    return JVM_NewNullRestrictedArray(env, elmClass, len);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/ValueClass.c","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -26,1 +27,0 @@\n-import jdk.internal.misc.VM;\n@@ -32,5 +32,7 @@\n-* @test\n-* @summary Test several scenarios of class initialization failures\n-* @library \/test\/lib\n-* @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED ClassInitializationFailuresTest.java\n-* @run main\/othervm -XX:+EnableValhalla --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.ClassInitializationFailuresTest\n+ * @test\n+ * @summary Test several scenarios of class initialization failures\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.value\n+ * @compile ClassInitializationFailuresTest.java\n+ * @run main\/othervm -XX:+EnableValhalla runtime.valhalla.inlinetypes.ClassInitializationFailuresTest\n@@ -119,1 +121,1 @@\n-            BadTwo[] array = (BadTwo[])VM.newNullRestrictedArray(BadTwo.class, 10);\n+            BadTwo[] array = (BadTwo[]) ValueClass.newNullRestrictedArray(BadTwo.class, 10);\n@@ -127,1 +129,1 @@\n-            BadTwo[] array = (BadTwo[])VM.newNullRestrictedArray(BadTwo.class, 10);\n+            BadTwo[] array = (BadTwo[]) ValueClass.newNullRestrictedArray(BadTwo.class, 10);\n@@ -163,1 +165,1 @@\n-            array = (BadFour[])VM.newNullRestrictedArray(BadFour.class, 10);\n+            array = (BadFour[]) ValueClass.newNullRestrictedArray(BadFour.class, 10);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ClassInitializationFailuresTest.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -29,1 +30,0 @@\n-import jdk.internal.misc.VM;\n@@ -37,1 +37,0 @@\n- * @modules java.base\/jdk.internal.misc\n@@ -39,2 +38,4 @@\n- * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED NullRestrictedArrayTest.java\n- * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED -XX:+EnableValhalla NullRestrictedArrayTest\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ * @run main\/othervm -XX:+EnableValhalla NullRestrictedArrayTest\n@@ -69,1 +70,1 @@\n-        VM.newNullRestrictedArray(String.class, 4);\n+        ValueClass.newNullRestrictedArray(String.class, 4);\n@@ -88,1 +89,1 @@\n-        VM.newNullRestrictedArray(ValueClass1.class, -1);\n+        ValueClass.newNullRestrictedArray(ValueClass1.class, -1);\n@@ -105,1 +106,1 @@\n-        VM.newNullRestrictedArray(ValueClass2.class, 8);\n+        ValueClass.newNullRestrictedArray(ValueClass2.class, 8);\n@@ -124,1 +125,1 @@\n-        Object array = VM.newNullRestrictedArray(ValueClass3.class, 8);\n+        Object array = ValueClass.newNullRestrictedArray(ValueClass3.class, 8);\n@@ -145,1 +146,1 @@\n-        Object[] array = VM.newNullRestrictedArray(ValueClass4.class, 8);\n+        Object[] array = ValueClass.newNullRestrictedArray(ValueClass4.class, 8);\n@@ -165,1 +166,1 @@\n-        Object[] array = VM.newNullRestrictedArray(ValueClass4.class, 8);\n+        Object[] array = ValueClass.newNullRestrictedArray(ValueClass4.class, 8);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullRestrictedArrayTest.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -808,2 +808,0 @@\n-valhalla\/valuetypes\/ObjectMethods.java 8317150 generic-all\n-valhalla\/valuetypes\/SubstitutabilityTest.java 8317151 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.value\n+ * @compile -XDenablePrimitiveClasses NullRestrictedTest.java\n+ * @run junit\/othervm -XX:+EnableValhalla NullRestrictedTest\n+ * @run junit\/othervm -XX:+EnableValhalla -XX:InlineFieldMaxFlatSize=0 NullRestrictedTest\n+ *\/\n+public class NullRestrictedTest {\n+    @ImplicitlyConstructible\n+    static value class MyValueEmpty {\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class EmptyContainer {\n+        @NullRestricted\n+        MyValueEmpty empty = new MyValueEmpty();\n+    }\n+\n+    @Test\n+    public void lazyInitializedDefaultValue() {\n+        \/\/ VM lazily sets the null-restricted non-flat field to zero default\n+        assertTrue(new EmptyContainer() == ValueClass.zeroInstance(EmptyContainer.class));\n+    }\n+\n+    @Test\n+    public void testMethodHandle() throws Throwable {\n+        var mh = MethodHandles.lookup().findGetter(EmptyContainer.class, \"empty\", MyValueEmpty.class);\n+        assertTrue(mh.invoke(new EmptyContainer()) == ValueClass.zeroInstance(MyValueEmpty.class));\n+    }\n+\n+    @Test\n+    public void testVarHandle() throws Throwable {\n+        var vh = MethodHandles.lookup().findVarHandle(EmptyContainer.class, \"empty\", MyValueEmpty.class);\n+        assertTrue(vh.get(new EmptyContainer()) == ValueClass.zeroInstance(MyValueEmpty.class));\n+    }\n+\n+    @Test\n+    public void testField() throws Throwable {\n+        var f = EmptyContainer.class.getDeclaredField(\"empty\");\n+        assertTrue(f.get(new EmptyContainer()) == ValueClass.zeroInstance(MyValueEmpty.class));\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}