{"files":[{"patch":"@@ -322,2 +322,3 @@\n-                v.owner.isValueClass() &&\n-                !env.info.instanceInitializerBlock && \/\/ it is OK instance initializer blocks will go after super() anyways\n+                \/\/ it is OK, in value classes, instance initializer blocks will go after super() anyways\n+                ((v.owner.isValueClass() && !env.info.instanceInitializerBlock) ||\n+                        types.isNonNullable(v.type)) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1322,2 +1322,5 @@\n-                boolean isInstanceFieldOfValueClass = sym.owner.type.isValueClass() && (flags & STATIC) == 0;\n-                mask = !isInstanceFieldOfValueClass ? VarFlags : ExtendedVarFlags;\n+                boolean isInstanceFieldOfValueClass =\n+                        (sym.owner.type.isValueClass() && (flags & STATIC) == 0);\n+                boolean isNonNullableInstanceFieldOfNonValueClass =\n+                        (!sym.owner.type.isValueClass() && (flags & STATIC) == 0) && types.isNonNullable(sym.type);\n+                mask = isInstanceFieldOfValueClass || isNonNullableInstanceFieldOfNonValueClass ? ExtendedVarFlags : VarFlags;\n@@ -1326,0 +1329,2 @@\n+                } else if (isNonNullableInstanceFieldOfNonValueClass) {\n+                    implicit |= STRICT;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -428,0 +428,2 @@\n+        \/\/ initializers for non-nullable fields of non-value classes\n+        ListBuffer<JCStatement> initCodeNonNullableFields = new ListBuffer<>();\n@@ -429,1 +431,1 @@\n-        ListBuffer<JCStatement> initBlocks = new ListBuffer<>();\n+        ListBuffer<JCStatement> valueClassesInitBlocks = new ListBuffer<>();\n@@ -447,1 +449,1 @@\n-                        initBlocks.append(block);\n+                        valueClassesInitBlocks.append(block);\n@@ -465,1 +467,5 @@\n-                        initCode.append(init);\n+                        if (!vdef.sym.owner.isValueClass() && types.isNonNullable(vdef.sym.type)) {\n+                            initCodeNonNullableFields.append(init);\n+                        } else {\n+                            initCode.append(init);\n+                        }\n@@ -490,1 +496,1 @@\n-        if (initCode.length() != 0 || initBlocks.length() != 0) {\n+        if (initCode.length() != 0 || initCodeNonNullableFields.length() != 0 || valueClassesInitBlocks.length() != 0) {\n@@ -494,1 +500,1 @@\n-                normalizeMethod((JCMethodDecl)t, initCode.toList(), initBlocks.toList(), initTAlist);\n+                normalizeMethod((JCMethodDecl)t, initCode.toList(), initCodeNonNullableFields.toList(), valueClassesInitBlocks.toList(), initTAlist);\n@@ -557,1 +563,1 @@\n-    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initBlocks,  List<TypeCompound> initTAs) {\n+    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initCodeNonNullableFields, List<JCStatement> valueClassesInitBlocks, List<TypeCompound> initTAs) {\n@@ -563,1 +569,4 @@\n-                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.append(supercall).appendList(initBlocks)));\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.append(supercall).appendList(valueClassesInitBlocks)));\n+            } else if (!initCodeNonNullableFields.isEmpty()) {\n+                rewriteInitializersIfNeeded(md, initCodeNonNullableFields);\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCodeNonNullableFields.append(supercall).appendList(initCode)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-import java.util.List;\n+\n+import java.io.File;\n@@ -40,0 +41,2 @@\n+import java.util.List;\n+import java.util.Set;\n@@ -43,0 +46,5 @@\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.Field;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+\n@@ -853,0 +861,68 @@\n+\n+    @Test\n+    void testNonNullableFieldsAreStrict() throws Exception {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                    Test() {\n+                                        super();\n+                                        o = new Object();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.cant.ref.after.ctor.called\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                    Test() {\n+                                        o = new Object();\n+                                        super();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o = new Object();\n+                                    Test() {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o = new Object();\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+\n+        for (String source : List.of(\n+                \"\"\"\n+                class Test {\n+                    Object! o = new Object();\n+                }\n+                \"\"\"\n+        )) {\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                for (Field field : classFile.fields) {\n+                    if (!field.access_flags.is(Flags.STATIC)) {\n+                        Set<String> fieldFlags = field.access_flags.getFieldFlags();\n+                        Assert.check(fieldFlags.size() == 1 && fieldFlags.contains(\"ACC_STRICT\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"}]}