{"files":[{"patch":"@@ -1115,0 +1115,1 @@\n+  bool deoptimize_for_strict_static = false;\n@@ -1168,0 +1169,3 @@\n+    \/\/ Strict statics may require tracking if their class is not fully initialized.\n+    \/\/ For now we can bail out of the compiler and let the interpreter handle it.\n+    deoptimize_for_strict_static = result.is_strict_static_unset();\n@@ -1240,1 +1244,5 @@\n-  if (deoptimize_for_volatile || deoptimize_for_atomic || deoptimize_for_null_free || deoptimize_for_flat) {\n+  if (deoptimize_for_volatile  ||\n+      deoptimize_for_atomic    ||\n+      deoptimize_for_null_free ||\n+      deoptimize_for_flat      ||\n+      deoptimize_for_strict_static) {\n@@ -1257,0 +1265,3 @@\n+      if (deoptimize_for_strict_static) {\n+        tty->print_cr(\"Deoptimizing for patching strict static field reference\");\n+      }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -482,0 +482,12 @@\n+  \/\/ Strict statics may require tracking if their class is not fully initialized.\n+  \/\/ For now we can bail out of the compiler and let the interpreter handle it.\n+  if (is_static && result.is_strict_static_unset()) {\n+    \/\/ If we left out this logic, we would get (a) spurious <clinit>\n+    \/\/ failures for C2 code because compiled putstatic would not write\n+    \/\/ the \"unset\" bits, and (b) missed failures for too-early reads,\n+    \/\/ since the compiled getstatic would not check the \"unset\" bits.\n+    \/\/ Test C1 on <clinit> with \"-XX:TieredStopAtLevel=2 -Xcomp -Xbatch\".\n+    \/\/ Test C2 on <clinit> with \"-XX:-TieredCompilation -Xcomp -Xbatch\".\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1517,0 +1517,3 @@\n+    if (access_flags.is_strict() && access_flags.is_static()) {\n+      _has_strict_static_fields = true;\n+    }\n@@ -5292,0 +5295,1 @@\n+  ik->set_has_strict_static_fields(_has_strict_static_fields);\n@@ -5603,0 +5607,1 @@\n+  _has_strict_static_fields(false),\n@@ -6241,0 +6246,21 @@\n+\n+  \/\/ Strict static fields track initialization status from the beginning of time.\n+  \/\/ After this class runs <clinit>, they will be verified as being \"not unset\".\n+  \/\/ See Step 8 of InstanceKlass::initialize_impl.\n+  if (_has_strict_static_fields) {\n+    bool found_one = false;\n+    for (int i = 0; i < _temp_field_info->length(); i++) {\n+      FieldInfo& fi = *_temp_field_info->adr_at(i);\n+      if (fi.access_flags().is_strict() && fi.access_flags().is_static()) {\n+        found_one = true;\n+        if (fi.initializer_index() != 0) {\n+          \/\/ skip strict static fields with ConstantValue attributes\n+        } else {\n+          _fields_status->adr_at(fi.index())->update_strict_static_unset(true);\n+          _fields_status->adr_at(fi.index())->update_strict_static_unread(true);\n+        }\n+      }\n+    }\n+    assert(found_one == _has_strict_static_fields,\n+           \"correct prediction = %d\", (int)_has_strict_static_fields);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -211,0 +211,1 @@\n+  bool _has_strict_static_fields;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -231,0 +231,2 @@\n+    print_strict_fields(assert_unset_fields());\n+    print_strict_fields(target->assert_unset_fields());\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -795,0 +795,1 @@\n+  bool strict_static_final = info.is_strict() && info.is_static() && info.is_final();\n@@ -808,0 +809,13 @@\n+    assert(!info.is_strict_static_unset(), \"after initialization, no unset flags\");\n+  } else if (is_static && (info.is_strict_static_unset() || strict_static_final)) {\n+    \/\/ During <clinit>, closely track the state of strict statics.\n+    \/\/ 1. if we are reading an uninitialized strict static, throw\n+    \/\/ 2. if we are writing one, clear the \"unset\" flag\n+    \/\/\n+    \/\/ Note: If we were handling an attempted write of a null to a\n+    \/\/ null-restricted strict static, we would NOT clear the \"unset\"\n+    \/\/ flag.\n+    assert(klass->is_being_initialized(), \"else should have thrown\");\n+    assert(klass->is_reentrant_initialization(THREAD),\n+      \"<clinit> must be running in current thread\");\n+    klass->notify_strict_static_access(info.index(), is_put, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -316,0 +316,2 @@\n+    _fs_strict_static_unset,  \/\/ JVM_ACC_STRICT static field has not yet been set\n+    _fs_strict_static_unread, \/\/ SS field has not yet been read\n@@ -334,2 +336,4 @@\n-  bool is_access_watched()        { return test_flag(_fs_access_watched); }\n-  bool is_modification_watched()  { return test_flag(_fs_modification_watched); }\n+  bool is_access_watched()           { return test_flag(_fs_access_watched); }\n+  bool is_modification_watched()     { return test_flag(_fs_modification_watched); }\n+  bool is_strict_static_unset()      { return test_flag(_fs_strict_static_unset); }\n+  bool is_strict_static_unread()     { return test_flag(_fs_strict_static_unread); }\n@@ -340,0 +344,2 @@\n+  void update_strict_static_unset(bool z);\n+  void update_strict_static_unread(bool z);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -187,2 +187,4 @@\n-inline void FieldStatus::update_access_watched(bool z) { update_flag(_fs_access_watched, z); }\n-inline void FieldStatus::update_modification_watched(bool z) { update_flag(_fs_modification_watched, z); }\n+inline void FieldStatus::update_access_watched(bool z)           { update_flag(_fs_access_watched, z); }\n+inline void FieldStatus::update_modification_watched(bool z)     { update_flag(_fs_modification_watched, z); }\n+inline void FieldStatus::update_strict_static_unset(bool z)      { update_flag(_fs_strict_static_unset, z); }\n+inline void FieldStatus::update_strict_static_unread(bool z)     { update_flag(_fs_strict_static_unread, z); }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1511,0 +1511,30 @@\n+\n+    if (has_strict_static_fields() && !HAS_PENDING_EXCEPTION) {\n+      \/\/ Step 9 also verifies that strict static fields have been initialized.\n+      \/\/ Status bits were set in ClassFileParser::post_process_parsed_stream.\n+      \/\/ After <clinit>, bits must all be clear, or else we must throw an error.\n+      \/\/ This is an extremely fast check, so we won't bother with a timer.\n+      assert(fields_status() != nullptr, \"\");\n+      Symbol* bad_strict_static = nullptr;\n+      for (int index = 0; index < fields_status()->length(); index++) {\n+        \/\/ Very fast loop over single byte array looking for a set bit.\n+        if (fields_status()->adr_at(index)->is_strict_static_unset()) {\n+          \/\/ This strict static field has not been set by the class initializer.\n+          \/\/ Note that in the common no-error case, we read no field metadata.\n+          \/\/ We only unpack it when we need to report an error.\n+          FieldInfo fi = field(index);\n+          bad_strict_static = fi.name(constants());\n+          if (debug_logging_enabled) {\n+            ResourceMark rm(jt);\n+            const char* msg = format_strict_static_message(bad_strict_static);\n+            log_debug(class, init)(\"%s\", msg);\n+          } else {\n+            \/\/ If we are not logging, do not bother to look for a second offense.\n+            break;\n+          }\n+        }\n+      }\n+      if (bad_strict_static != nullptr) {\n+        throw_strict_static_exception(bad_strict_static, \"is unset after initialization of\", THREAD);\n+      }\n+    }\n@@ -1563,0 +1593,68 @@\n+void InstanceKlass::notify_strict_static_access(int field_index, bool is_writing, TRAPS) {\n+  guarantee(field_index >= 0 && field_index < fields_status()->length(), \"valid field index\");\n+  DEBUG_ONLY(FieldInfo debugfi = field(field_index));\n+  assert(debugfi.access_flags().is_strict(), \"\");\n+  assert(debugfi.access_flags().is_static(), \"\");\n+  FieldStatus& fs = *fields_status()->adr_at(field_index);\n+  LogTarget(Trace, class, init) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm(THREAD);\n+    LogStream ls(lt);\n+    FieldInfo fi = field(field_index);\n+    ls.print(\"notify %s %s %s%s \",\n+             external_name(), is_writing? \"Write\" : \"Read\",\n+             fs.is_strict_static_unset() ? \"Unset\" : \"(set)\",\n+             fs.is_strict_static_unread() ? \"+Unread\" : \"\");\n+    fi.print(&ls, constants());\n+  }\n+  if (fs.is_strict_static_unset()) {\n+    assert(fs.is_strict_static_unread(), \"ClassFileParser resp.\");\n+    \/\/ If it is not set, there are only two reasonable things we can do here:\n+    \/\/ - mark it set if this is putstatic\n+    \/\/ - throw an error (Read-Before-Write) if this is getstatic\n+\n+    \/\/ The unset state is (or should be) transient, and observable only in one\n+    \/\/ thread during the execution of <clinit>.  Something is wrong here as this\n+    \/\/ should not be possible\n+    guarantee(is_reentrant_initialization(THREAD), \"unscoped access to strict static\");\n+    if (is_writing) {\n+      \/\/ clear the \"unset\" bit, since the field is actually going to be written\n+      fs.update_strict_static_unset(false);\n+    } else {\n+      \/\/ throw an IllegalStateException, since we are reading before writing\n+      \/\/ see also InstanceKlass::initialize_impl, Step 8 (at end)\n+      Symbol* bad_strict_static = field(field_index).name(constants());\n+      throw_strict_static_exception(bad_strict_static, \"is unset before first read in\", CHECK);\n+    }\n+  } else {\n+    \/\/ Ensure no write after read for final strict statics\n+    FieldInfo fi = field(field_index);\n+    bool is_final = fi.access_flags().is_final();\n+    if (is_final) {\n+      \/\/ no final write after read, so observing a constant freezes it, as if <clinit> ended early\n+      \/\/ (maybe we could trust the constant a little earlier, before <clinit> ends)\n+      if (is_writing && !fs.is_strict_static_unread()) {\n+        Symbol* bad_strict_static = fi.name(constants());\n+        throw_strict_static_exception(bad_strict_static, \"is set after read (as final) in\", CHECK);\n+      } else if (!is_writing && fs.is_strict_static_unread()) {\n+        fs.update_strict_static_unread(false);\n+      }\n+    }\n+  }\n+}\n+\n+void InstanceKlass::throw_strict_static_exception(Symbol* field_name, const char* when, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  const char* msg = format_strict_static_message(field_name, when);\n+  THROW_MSG(vmSymbols::java_lang_IllegalStateException(), msg);\n+}\n+\n+const char* InstanceKlass::format_strict_static_message(Symbol* field_name, const char* when) {\n+  stringStream ss;\n+  ss.print(\"Strict static \\\"%s\\\" %s %s\",\n+           field_name->as_C_string(),\n+           when == nullptr ? \"is unset in\" : when,\n+           external_name());\n+  return ss.as_string();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -866,0 +866,7 @@\n+  \/\/ runtime support for strict statics\n+  bool has_strict_static_fields() const     { return _misc_flags.has_strict_static_fields(); }\n+  void set_has_strict_static_fields(bool b) { _misc_flags.set_has_strict_static_fields(b); }\n+  void notify_strict_static_access(int field_index, bool is_writing, TRAPS);\n+  const char* format_strict_static_message(Symbol* field_name, const char* doing_what = nullptr);\n+  void throw_strict_static_exception(Symbol* field_name, const char* when, TRAPS);\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    flag(has_strict_static_fields           , 1 << 19) \/* True if strict static fields declared *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -839,0 +839,21 @@\n+UNSAFE_ENTRY(void, Unsafe_NotifyStrictStaticAccess0(JNIEnv *env, jobject unsafe, jobject clazz,\n+                                                    jlong sfoffset, jboolean writing)) {\n+  assert(clazz != nullptr, \"clazz must not be null\");\n+\n+  oop mirror = JNIHandles::resolve_non_null(clazz);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+\n+  if (klass != nullptr && klass->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    fieldDescriptor fd;\n+    if (ik->find_local_field_from_offset((int)sfoffset, true, &fd)) {\n+      \/\/ Note: The Unsafe API takes an OFFSET, but the InstanceKlass wants the INDEX.\n+      \/\/ We could surface field indexes into Unsafe, but that's too much churn.\n+      ik->notify_strict_static_access(fd.index(), writing, CHECK);\n+      return;\n+    }\n+  }\n+  THROW(vmSymbols::java_lang_InternalError());\n+}\n+UNSAFE_END\n+\n@@ -1194,0 +1215,1 @@\n+    {CC \"notifyStrictStaticAccess0\", CC \"(\" CLS \"JZ)V\",  FN_PTR(Unsafe_NotifyStrictStaticAccess0)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+  \/\/ Unset strict static\n+  inline bool is_strict_static_unset()   const;\n+\n@@ -90,0 +93,1 @@\n+  bool is_strict()                const    { return access_flags().is_strict(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,5 @@\n+inline bool fieldDescriptor::is_strict_static_unset() const {\n+  return (is_strict() && is_static() &&\n+          field_holder()->field_status(index()).is_strict_static_unset());\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-        if (checkInitialized(member)) {\n+        if (checkInitialized()) {\n@@ -387,1 +387,1 @@\n-    private static boolean checkInitialized(MemberName member) {\n+    private boolean checkInitialized() {\n@@ -394,1 +394,6 @@\n-        return !UNSAFE.shouldBeInitialized(defc);\n+        boolean initializingStill = UNSAFE.shouldBeInitialized(defc);\n+        if (initializingStill && member.isStrict()) {\n+            \/\/ while <clinit> is running, we track access to strict static fields\n+            UNSAFE.notifyStrictStaticAccess(defc, staticOffset(this), member.isSetter());\n+        }\n+        return !initializingStill;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -392,0 +392,4 @@\n+    \/** Utility method to query the modifier flags of this member. *\/\n+    public boolean isStrict() {\n+        return Modifier.isStrict(flags);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1377,0 +1377,15 @@\n+    \/**\n+     * The reading or writing of strict static fields may require\n+     * special processing.  Notify the VM that such an event is about\n+     * to happen.  The VM may respond by throwing an exception, in the\n+     * case of a read of an uninitialized field.  If the VM allows the\n+     * method to return normally, no further calls are needed, with\n+     * the same arguments.\n+     *\/\n+    public void notifyStrictStaticAccess(Class<?> c, long staticFieldOffset, boolean writing) {\n+        if (c == null) {\n+            throw new NullPointerException();\n+        }\n+        notifyStrictStaticAccess0(c, staticFieldOffset, writing);\n+    }\n+\n@@ -4383,0 +4398,1 @@\n+    private native void notifyStrictStaticAccess0(Class<?> c, long staticFieldOffset, boolean writing);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -134,1 +134,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleBooleanFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -140,1 +140,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleByteFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -146,1 +146,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleCharacterFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -195,1 +195,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleDoubleFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -186,1 +186,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFloatFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -168,1 +168,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleIntegerFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -177,1 +177,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleLongFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -111,1 +111,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleObjectFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n@@ -156,1 +156,1 @@\n-        } catch (IllegalArgumentException|NullPointerException e) {\n+        } catch (IllegalArgumentException|IllegalStateException|NullPointerException e) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleShortFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticFieldsTest.java 8357141 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Bnoinit_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {} \/\/ Strict statics not initialized\n+}\n+*\/\n+\n+identity class Bnoinit_BAD version 69:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 0  locals 0\n+  {\n+         return;\n+  }\n+\n+} \/\/ end Class Bnoinit_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Bnoinit_BAD.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Brbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        int x = F2__STRICT; \/\/ Read before write\n+        F1__STRICT = \"hello\";\n+        F2__STRICT = 42;\n+    }\n+}\n+*\/\n+\n+identity class Brbefore_BAD version 69:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         getstatic         Field F2__STRICT:\"I\";\n+         istore_0;\n+         ldc               String \"hello\";\n+         putstatic         Field F1__STRICT:\"Ljava\/lang\/String;\";\n+         bipush            42;\n+         putstatic         Field F2__STRICT:\"I\";\n+         return;\n+  }\n+} \/\/ end Class Brbefore_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Brbefore_BAD.jasm","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Creflbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Creflbefore_BAD.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Creflbefore_BAD.class, \"F2__STRICT\");\n+\n+        int x = (int) getstaticReflective(FIELD_F2);  \/\/ Read before write\n+        System.out.println(\"Early read of F2=\" + x);\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n+identity class Creflbefore_BAD version 69:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 3\n+  {\n+         ldc               class Creflbefore_BAD;\n+         ldc               String \"F1__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         ldc               class Creflbefore_BAD;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_1;\n+         aload_1;\n+         invokestatic      Method StrictStaticFieldsTest.getstaticReflective:\"(Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object;\";\n+         checkcast         class java\/lang\/Integer;\n+         invokevirtual     Method java\/lang\/Integer.intValue:\"()I\";\n+         istore_2;\n+         getstatic         Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+         iload_2;\n+         invokedynamic     InvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\n+                           \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":\n+                           makeConcatWithConstants:\"(I)Ljava\/lang\/String;\" {\n+                             String \"Early read of F2=\\u0001\"\n+                           };\n+         invokevirtual     Method java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+         aload_0;\n+         ldc               String \"hello\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         aload_1;\n+         bipush            42;\n+         invokestatic      Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         return;\n+  }\n+\n+  BootstrapMethod          REF_invokeStatic:java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\n+                           \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";\n+                           {\n+                             String \"(early read of F2=\\u0001)\"\n+                           }\n+} \/\/ end Class Creflbefore_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Creflbefore_BAD.jasm","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Cwreflective_OK {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Cwreflective_OK.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Cwreflective_OK.class, \"F2__STRICT\");\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n+\n+identity class Cwreflective_OK version 69:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 2\n+  {\n+         ldc               class Cwreflective_OK;\n+         ldc               String \"F1__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         ldc               class Cwreflective_OK;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_1;\n+         aload_0;\n+         ldc               String \"hello\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         aload_1;\n+         bipush            42;\n+         invokestatic      Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         return;\n+  }\n+} \/\/ end Class Cwreflective_OK\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Cwreflective_OK.jasm","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349945\n+ * @summary Tracking of strict static fields\n+ * @enablePreview\n+ * @compile Bnoinit_BAD.jasm\n+ *          Brbefore_BAD.jasm\n+ *          Cwreflective_OK.jasm\n+ *          Creflbefore_BAD.jasm\n+ *          WriteAfterReadRefl.jasm\n+ * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED StrictStaticFieldsTest.java\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions StrictStaticFieldsTest\n+ *\/\n+\n+import java.lang.reflect.*;\n+import jdk.internal.vm.annotation.Strict;\n+\n+public class StrictStaticFieldsTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ --------------\n+        \/\/ POSITIVE TESTS\n+        \/\/ --------------\n+\n+        \/\/ Base Case\n+        printStatics(Aregular_OK.class);\n+\n+        \/\/ Strict statics initialized to null and zero\n+        printStatics(Anulls_OK.class);\n+\n+        \/\/ Assign strict static twice\n+        printStatics(Arepeat_OK.class);\n+\n+        \/\/ Read and write initialized strict static\n+        printStatics(Aupdate_OK.class);\n+\n+        \/\/ Reflectively set static fields\n+        printStaticsReflective(Cwreflective_OK.class);\n+\n+        \/\/ --------------\n+        \/\/ NEGATIVE TESTS\n+        \/\/ --------------\n+\n+        \/\/ Strict statics not initialized\n+        try {\n+            printStatics(Bnoinit_BAD.class);\n+            throw new RuntimeException(\"Should throw\");\n+        } catch(ExceptionInInitializerError ex) {\n+            Throwable e = (ex.getCause() != null) ? ex.getCause() : ex;\n+            if (!e.getMessage().contains(\"unset after initialization\")) {\n+                throw new RuntimeException(\"wrong exception: \" + e.getMessage());\n+            }\n+            e.printStackTrace();\n+        }\n+\n+        \/\/ Read before write\n+        try {\n+            printStatics(Brbefore_BAD.class);\n+            throw new RuntimeException(\"Should throw\");\n+        } catch(ExceptionInInitializerError ex) {\n+            Throwable e = (ex.getCause() != null) ? ex.getCause() : ex;\n+            if (!e.getMessage().contains(\"is unset before first read\")) {\n+                throw new RuntimeException(\"wrong exception: \" + e.getMessage());\n+            }\n+            e.printStackTrace();\n+        }\n+\n+        \/\/ Reflective read before write\n+        try {\n+            printStaticsReflective(Creflbefore_BAD.class);\n+            throw new RuntimeException(\"Should throw\");\n+        } catch(ExceptionInInitializerError ex) {\n+            Throwable e = (ex.getCause() != null) ? ex.getCause() : ex;\n+            if (!e.getMessage().contains(\"is unset before first read\")) {\n+                throw new RuntimeException(\"wrong exception: \" + e.getMessage());\n+            }\n+            e.printStackTrace();\n+        }\n+\n+        \/\/ Reflective write after read\n+        try {\n+            printStaticsReflective(WriteAfterReadRefl.class);\n+            throw new RuntimeException(\"Should throw\");\n+        } catch(ExceptionInInitializerError ex) {\n+            Throwable e = (ex.getCause() != null) ? ex.getCause() : ex;\n+            if (!e.getMessage().contains(\"set after read\")) {\n+                throw new RuntimeException(\"wrong exception: \" + e.getMessage());\n+            }\n+            e.printStackTrace();\n+        }\n+\n+        System.out.println(\"Passed\");\n+    }\n+\n+    static void printStatics(Class<?> cls) throws Exception {\n+        Field f1 = cls.getDeclaredField(\"F1__STRICT\");\n+        Field f2 = cls.getDeclaredField(\"F2__STRICT\");\n+        System.out.println(f1.get(null));\n+        System.out.println(f2.get(null));\n+    }\n+\n+    \/\/ Methods for reflective access\n+    static void printStaticsReflective(Class<?> cls) throws Exception {\n+        Field FIELD_F1 = findField(cls, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(cls, \"F2__STRICT\");\n+\n+        String f1 = (String)getstaticReflective(FIELD_F1);\n+        int f2 = (int)getstaticReflective(FIELD_F2);\n+\n+        System.out.println(f1);\n+        System.out.println(f2);\n+    }\n+\n+    static void putstaticReflective(Field f, Object x) {\n+        try {\n+            f.set(null, x);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    static Object getstaticReflective(Field f) {\n+        try {\n+            return f.get(null);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    static Field findField(Class<?> cls, String name) {\n+        try {\n+            return cls.getDeclaredField(name);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+}\n+\n+class Aregular_OK {\n+        @Strict static final String F1__STRICT = \"hello\";\n+        @Strict static final int    F2__STRICT = 42;\n+    }\n+\n+class Anulls_OK {\n+    @Strict static String F1__STRICT = null;\n+    @Strict static int    F2__STRICT = 0;\n+}\n+\n+class Arepeat_OK {\n+    @Strict static String F1__STRICT = \"hello\";\n+    @Strict static int    F2__STRICT = 42;\n+    static {\n+        System.out.print(\"(making second putstatic)\");\n+        F2__STRICT = 43;\n+    }\n+}\n+\n+class Aupdate_OK {\n+    @Strict static String F1__STRICT = \"hello\";\n+    @Strict static int    F2__STRICT = 42;\n+    static {\n+        System.out.println(\"(making getstatic and second putstatic)\");\n+        F2__STRICT++;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticFieldsTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349945\n+ * @summary test tracking of strict static fields\n+ * @enablePreview\n+ * @run main\/othervm StrictStaticTests\n+ *\n+ * @test id=C1only\n+ * @run main\/othervm -XX:TieredStopAtLevel=2 -Xcomp -Xbatch StrictStaticTests\n+ *\n+ * @test id=C2only\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp -Xbatch StrictStaticTests\n+ *\/\n+\n+import java.io.File;\n+import java.lang.classfile.*;\n+import java.lang.constant.*;\n+import java.lang.reflect.*;\n+import java.lang.invoke.*;\n+import java.nio.file.Files;\n+\n+import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodType.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+public class StrictStaticTests {\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+    private static final String THIS_PACKAGE = LOOKUP.lookupClass().getPackageName();\n+\n+    static Class<?> buildClass(String className,\n+                               Class<?> staticType,\n+                               int writeCount,   \/\/ how many putstatics? (0=>error)\n+                               byte readFlag,    \/\/ read before (-1) or after (1)?\n+                               int extraCount,   \/\/ how many extra strict statics?\n+                               boolean finals    \/\/ make them all finals?\n+                               ) throws Exception {\n+        ClassDesc cn = ClassDesc.of(className);\n+        ClassDesc CD_Integer = Integer.class.describeConstable().orElseThrow();\n+        String    VO_NAME = \"valueOf\";\n+        MethodTypeDesc VO_TYPE = MethodTypeDesc.of(CD_Integer, CD_int);\n+        String    SS_NAME = \"SS\";\n+        ClassDesc SS_TYPE = staticType.describeConstable().orElseThrow();\n+        String    XS_NAME = \"EXTRAS\";\n+        ClassDesc XS_TYPE = CD_boolean;\n+        String    PS_NAME = \"PLAIN\";\n+        ClassDesc PS_TYPE = CD_byte;\n+\n+        boolean prim = staticType.isPrimitive();\n+        boolean pop2 = staticType == double.class;\n+        final ConstantDesc SS_INIT, SS_INIT_2;\n+        if (!prim) {\n+            SS_INIT = \"foo\";\n+            SS_INIT_2 = null;\n+        } else if (!pop2) {\n+            SS_INIT = 1;\n+            SS_INIT_2 = 0;\n+        } else {\n+            SS_INIT = 3.14;\n+            SS_INIT_2 = 0.0;\n+        }\n+        int mods = (ClassFile.ACC_STATIC | ClassFile.ACC_STRICT |\n+                    (finals ? ClassFile.ACC_FINAL : 0));\n+        byte[] classBytes = ClassFile.of().build(cn, clb -> {\n+                clb.withFlags(ClassFile.ACC_FINAL);\n+                clb.withVersion(ClassFile.latestMajorVersion(), ClassFile.PREVIEW_MINOR_VERSION);\n+                clb.withField(SS_NAME, SS_TYPE, mods);\n+                for (int i = 0; i < extraCount; i++) {\n+                    clb.withField(XS_NAME+i, XS_TYPE, mods);\n+                    clb.withField(PS_NAME+i, PS_TYPE, mods & ~ClassFile.ACC_STRICT);\n+                }\n+                clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ClassFile.ACC_STATIC, cob -> {\n+                        \/\/ always store into the extra strict static(s)\n+                        for (int i = 0; i < extraCount\/2; i++) {\n+                            cob.loadConstant(i&1);\n+                            cob.putstatic(cn, XS_NAME+i, XS_TYPE);\n+                        }\n+                        if (readFlag < 0) {\n+                            \/\/ perform an early read, which must fail\n+                            cob.getstatic(cn, SS_NAME, SS_TYPE);\n+                            if (pop2) cob.pop2(); else cob.pop();\n+                        }\n+                        \/\/ perform any writes on the test field\n+                        ConstantDesc initializer = SS_INIT;\n+                        for (int i = 0; i < writeCount; i++) {\n+                            if (i == 1 && readFlag > 0) {\n+                                \/\/ do an extra read after the first write\n+                                if (readFlag > 0) {\n+                                    cob.getstatic(cn, SS_NAME, SS_TYPE);\n+                                    if (pop2) cob.pop2(); else cob.pop();\n+                                }\n+                            }\n+                            if (i > 0) initializer = SS_INIT_2;\n+                            cob.loadConstant(initializer);\n+                            cob.putstatic(cn, SS_NAME, SS_TYPE);\n+                            \/\/ if we write zero times we must fail\n+                        }\n+                        if (readFlag > 0) {\n+                            \/\/ do more extra reads\n+                            cob.getstatic(cn, SS_NAME, SS_TYPE);\n+                            if (prim) {\n+                                if (pop2) cob.pop2(); else cob.pop();\n+                            } else {\n+                                cob.loadConstant(initializer);\n+                                var L_skip = cob.newLabel();\n+                                cob.if_acmpeq(L_skip);\n+                                cob.loadConstant(null);\n+                                cob.athrow();  \/\/ NPE!\n+                                cob.labelBinding(L_skip);\n+                            }\n+                        }\n+                        \/\/ finish storing into the extra strict static(s)\n+                        for (int i = extraCount\/2; i < extraCount; i++) {\n+                            cob.loadConstant(i&1);\n+                            cob.putstatic(cn, XS_NAME+i, XS_TYPE);\n+                        }\n+                        cob.return_();\n+                    });\n+            });\n+        File c = new File(className + \".class\");\n+        c.createNewFile();\n+        Files.write(c.toPath(), classBytes);\n+\n+        var vererrs = ClassFile.of().verify(classBytes);\n+        if (vererrs != null && !vererrs.isEmpty()) {\n+            System.out.println(vererrs);\n+            var cm = ClassFile.of().parse(classBytes);\n+            System.out.println(cm.toDebugString());\n+        }\n+        ++COUNT;\n+        try {\n+            return LOOKUP.defineHiddenClass(classBytes, false).lookupClass();\n+        } catch (IllegalAccessException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    static int COUNT = 0;\n+\n+    private static final Class<?> STATIC_TYPES[] = {\n+        Object.class,\n+        String.class,\n+        int.class,\n+        boolean.class,\n+        double.class\n+    };\n+\n+    static boolean isSSFailure(Throwable ex) {\n+        return ex instanceof ExceptionInInitializerError &&\n+            ex.getCause() instanceof IllegalStateException;\n+    }\n+    static void testPositives() throws Exception {\n+        testPositives(false);\n+        testPositives(true);\n+    }\n+    static void testPositives(boolean finals) throws Exception {\n+        for (var staticType : STATIC_TYPES) {\n+            for (int writeCount = 1; writeCount <= 3; writeCount++) {\n+                for (byte readFlag = 0; readFlag <= 1; readFlag++) {\n+                    if (writeCount > readFlag)\n+                        continue;\n+                    for (int extraCount = 0; extraCount <= 3; extraCount++) {\n+                        if (extraCount > 0 && staticType != String.class)  continue;\n+                        var cn = String.format(\"Positive_T%s%s_W%d%s%s\",\n+                                               staticType.getSimpleName(),\n+                                               (finals ? \"_SSFinal\" : \"\"),\n+                                               writeCount,\n+                                               (readFlag > 0 ? \"_Rafter\" :\n+                                                readFlag < 0 ? \"_Rbefore\" : \"\"),\n+                                               (extraCount > 0 ? \"_E\"+extraCount : \"\"));\n+                        var cls = buildClass(cn, staticType, writeCount, readFlag, extraCount, finals);\n+                        try {\n+                            LOOKUP.ensureInitialized(cls);\n+                            if (VERBOSE)\n+                                System.out.printf(\"ok: %s: no throw\\n\", cn);\n+                        } catch (Throwable ex) {\n+                            reportThrow(false, ex, cn);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    static void testFailedWrites() throws Exception {\n+        testFailedWrites(false);\n+        testFailedWrites(true);\n+    }\n+    static void testFailedWrites(boolean finals) throws Exception {\n+        for (var staticType : STATIC_TYPES) {\n+            for (int writeCount = 0; writeCount <= 2; writeCount++) {\n+                for (byte readFlag = 0; readFlag <= 1; readFlag++) {\n+                    if (readFlag > 0 || writeCount > 0) {\n+                        if (!finals || writeCount < 2)\n+                            continue;\n+                        if (readFlag <= 0)\n+                            continue;  \/\/ Mode 2 fails only with R between 2W: W-R-W\n+                    }\n+                    for (int extraCount = 0; extraCount <= 3; extraCount++) {\n+                        if (extraCount > 0 && staticType != String.class)  continue;\n+                        var cn = String.format(\"BadWrite_T%s%s_W%d%s%s\",\n+                                               staticType.getSimpleName(),\n+                                               (finals ? \"_SSFinal\" : \"\"),\n+                                               writeCount,\n+                                               (readFlag > 0 ? \"_Rafter\" :\n+                                                readFlag < 0 ? \"_Rbefore\" : \"\"),\n+                                               (extraCount > 0 ? \"_E\"+extraCount : \"\"));\n+                        var cls = buildClass(cn, staticType, writeCount, readFlag, extraCount, finals);\n+                        try {\n+                            LOOKUP.ensureInitialized(cls);\n+                            throw new RuntimeException(cn);\n+                        } catch (Throwable ex) {\n+                            reportThrow(isSSFailure(ex), ex, cn);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    static void testFailedReads() throws Exception {\n+        testFailedReads(false);\n+        testFailedReads(true);\n+    }\n+    static void testFailedReads(boolean finals) throws Exception {\n+        for (var staticType : STATIC_TYPES) {\n+            for (int writeCount = 0; writeCount <= 1; writeCount++) {\n+                for (byte readFlag = -1; readFlag <= -1; readFlag++) {\n+                    for (int extraCount = 0; extraCount <= 3; extraCount++) {\n+                        if (extraCount > 0 && staticType != String.class)  continue;\n+                        var cn = String.format(\"BadRead_T%s%s_W%d_%s%s\",\n+                                               staticType.getSimpleName(),\n+                                               (finals ? \"_SSFinal\" : \"\"),\n+                                               writeCount,\n+                                               (readFlag > 0 ? \"_Rafter\" :\n+                                                readFlag < 0 ? \"_Rbefore\" : \"\"),\n+                                               (extraCount > 0 ? \"_E\"+extraCount : \"\"));\n+                        var cls = buildClass(cn, staticType, writeCount, readFlag, extraCount, finals);\n+                        try {\n+                            LOOKUP.ensureInitialized(cls);\n+                            throw new RuntimeException(cn);\n+                        } catch (Throwable ex) {\n+                            reportThrow(isSSFailure(ex), ex, cn);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean VERBOSE = true;\n+\n+    private static void reportThrow(boolean ok, Throwable ex, String cn) {\n+        if (!ok)  throw new RuntimeException(ex);\n+        if (VERBOSE) {\n+            if (ex instanceof ExceptionInInitializerError && ex.getCause() != null)\n+                ex = ex.getCause();\n+            String exs = ex.toString();\n+            exs = exs.replaceFirst(\"^[^ ]*IllegalStateException: \", \"ISE: \");\n+            exs = exs.replaceFirst(\" strictStatic[.][^ ]+\/0x[^ ]+\", \"...\");\n+            System.out.printf(\"%s: %s: %s\\n\", ok ? \"ok\" : \"FAIL\", cn, exs);\n+        }\n+    }\n+\n+\n+    public static void main(String... av) throws Exception {\n+        testPositives();\n+        testFailedWrites();\n+        testFailedReads();\n+        System.out.println(\"tested \" + COUNT + \" classes\");\n+        System.out.println(\"Passed\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticTests.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class WriteAfterReadRefl {\n+        @Strict static final String F1__STRICT;\n+        @Strict static final int    F2__STRICT;\n+        static {\n+            \/\/ Bytecode write\n+            F1__STRICT = \"foo\";\n+            F2__STRICT = 42;\n+\n+\n+            \/\/ Reflective read\n+            Field FIELD_F2 = findField(WriteAfterReadRefl.class, \"F2__STRICT\");\n+            int x = (int) getstaticReflective(FIELD_F2);\n+\n+            \/\/ Bytecode write after read (FAIL)\n+            F2__STRICT = 43;\n+        }\n+    }\n+*\/\n+\n+super class WriteAfterReadRefl version 69:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static final  Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static final Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 2\n+  {\n+         ldc               String \"foo\";\n+         putstatic         Field F1__STRICT:\"Ljava\/lang\/String;\";\n+         bipush            42;\n+         putstatic         Field F2__STRICT:\"I\";\n+         ldc               class WriteAfterReadRefl;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         aload_0;\n+         invokestatic      Method StrictStaticFieldsTest.getstaticReflective:\"(Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object;\";\n+         checkcast         class java\/lang\/Integer;\n+         invokevirtual     Method java\/lang\/Integer.intValue:\"()I\";\n+         istore_1;\n+         bipush            43;\n+         putstatic         Field F2__STRICT:\"I\";\n+         return;\n+  }\n+} \/\/ end Class WriteAfterReadRefl\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/WriteAfterReadRefl.jasm","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}