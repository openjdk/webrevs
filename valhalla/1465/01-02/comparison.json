{"files":[{"patch":"@@ -817,1 +817,1 @@\n-    \/\/ flag.  This does not happen today, but will with NR fields.\n+    \/\/ flag.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-    _fs_strict_static_unread, \/\/ SS field has not yet been read (EnforceStrictStatics=2 only)\n+    _fs_strict_static_unread, \/\/ SS field has not yet been read\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1641,1 +1641,1 @@\n-    \/\/ Experimentally, enforce additional proposed conditions after the first write.\n+    \/\/ Ensure no write after read for final strict statics\n@@ -1651,1 +1651,0 @@\n-        \/\/ log the read (this requires an extra status bit, with extra tests on it)\n@@ -1661,2 +1660,0 @@\n-  \/\/ FIXME: Maybe replace IllegalStateException with something more precise.\n-  \/\/ Perhaps a new-fangled UninitializedFieldException?\n@@ -1668,1 +1665,0 @@\n-  \/\/ we can use similar format strings for both -Xlog:class+init and for the ISE throw\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-    flag(is_implicitly_constructible        , 1 << 19) \/* the class has the ImplicitlyConstrutible annotation *\/ \\\n-    flag(has_strict_static_fields           , 1 << 20) \/* True if strict static fields declared *\/ \\\n+    flag(has_strict_static_fields           , 1 << 19) \/* True if strict static fields declared *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2058,1 +2058,0 @@\n-  \/\/ strict fields need special tracking during <clinit>; do not hand them out so early\n@@ -2060,3 +2059,2 @@\n-      !InstanceKlass::cast(k)->find_field(fieldname, signame, true, &fd) ||\n-      \/\/ strict fields need special tracking during <clinit>; do not hand them out so early\n-      (fd.access_flags().is_strict() && !InstanceKlass::cast(k)->is_initialized())) {\n+      !InstanceKlass::cast(k)->find_field(fieldname, signame, true, &fd)) {\n+    assert(InstanceKlass::cast(k)->is_initialized(), \"must be\");\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -828,0 +828,1 @@\n+        final int INIT_BAR  = (needsInit ? nameCursor++ : -1);\n@@ -831,1 +832,0 @@\n-        \/\/ N.B. pre-cast must happen before init barrier, if both are present\n@@ -833,1 +833,0 @@\n-        final int INIT_BAR  = (needsInit ? nameCursor++ : -1); \/\/ no exceptions after barrier\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,8 @@\n+\/*\n+class Bnoinit_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {} \/\/ Strict statics not initialized\n+}\n+*\/\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Bnoinit_BAD.jasm","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,0 +24,12 @@\n+\/*\n+class Brbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        int x = F2__STRICT; \/\/ Read before write\n+        F1__STRICT = \"hello\";\n+        F2__STRICT = 42;\n+    }\n+}\n+*\/\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Brbefore_BAD.jasm","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,0 +24,16 @@\n+\/*\n+class Creflbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Creflbefore_BAD.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Creflbefore_BAD.class, \"F2__STRICT\");\n+\n+        int x = (int) getstaticReflective(FIELD_F2);  \/\/ Read before write\n+        System.out.println(\"Early read of F2=\" + x);\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Creflbefore_BAD.jasm","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -24,0 +24,14 @@\n+\/*\n+class Cwreflective_OK {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Cwreflective_OK.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Cwreflective_OK.class, \"F2__STRICT\");\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Cwreflective_OK.jasm","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}