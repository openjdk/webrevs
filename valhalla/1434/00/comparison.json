{"files":[{"patch":"@@ -28,3 +28,0 @@\n-import jdk.internal.value.CheckedType;\n-import jdk.internal.value.NormalCheckedType;\n-import jdk.internal.value.NullRestrictedCheckedType;\n@@ -230,8 +227,0 @@\n-    \/**\n-     * Return {@code CheckedType} representing the type of this member.\n-     *\/\n-    public CheckedType getCheckedFieldType() {\n-        return isNullRestricted() ? NullRestrictedCheckedType.of(getFieldType())\n-                                  : NormalCheckedType.of(getFieldType());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.NullRestrictedCheckedType;\n@@ -64,2 +63,2 @@\n-                                    ? new VarHandleFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType(), layout)\n-                                    : new VarHandleFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType(), layout));\n+                                    ? new VarHandleFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted(), layout)\n+                                    : new VarHandleFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted(), layout));\n@@ -68,2 +67,2 @@\n-                                    ? new VarHandleNonAtomicFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType(), layout)\n-                                    : new VarHandleNonAtomicFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType(), layout));\n+                                    ? new VarHandleNonAtomicFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted(), layout)\n+                                    : new VarHandleNonAtomicFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted(), layout));\n@@ -74,2 +73,2 @@\n-                                    ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n-                                    : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n+                                    ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted())\n+                                    : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted()));\n@@ -78,2 +77,2 @@\n-                                    ? new VarHandleNonAtomicReferences.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n-                                    : new VarHandleNonAtomicReferences.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n+                                    ? new VarHandleNonAtomicReferences.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted())\n+                                    : new VarHandleNonAtomicReferences.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted()));\n@@ -84,2 +83,2 @@\n-                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n-                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n+                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted())\n+                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted()));\n@@ -150,2 +149,2 @@\n-                            ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n-                            : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType());\n+                            ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.isNullRestricted())\n+                            : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.isNullRestricted());\n@@ -154,2 +153,2 @@\n-                            ? new VarHandleNonAtomicReferences.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n-                            : new VarHandleNonAtomicReferences.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType()));\n+                            ? new VarHandleNonAtomicReferences.FieldStaticReadOnly(decl, base, foffset, type, f.isNullRestricted())\n+                            : new VarHandleNonAtomicReferences.FieldStaticReadWrite(decl, base, foffset, type, f.isNullRestricted()));\n@@ -159,2 +158,2 @@\n-                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n-                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType());\n+                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.isNullRestricted())\n+                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.isNullRestricted());\n@@ -210,1 +209,1 @@\n-                !(field.getCheckedFieldType() instanceof NullRestrictedCheckedType) ||\n+                !(field.isNullRestricted()) ||\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.value.CheckedType;\n-import jdk.internal.value.NullRestrictedCheckedType;\n@@ -51,1 +49,1 @@\n-        final CheckedType checkedFieldType;\n+        final boolean nullRestricted;\n@@ -57,2 +55,2 @@\n-        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldInstanceReadOnly.FORM, false);\n+        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, FieldInstanceReadOnly.FORM, false);\n@@ -61,1 +59,1 @@\n-        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n+        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout},\n@@ -68,1 +66,1 @@\n-            this.checkedFieldType = checkedFieldType;\n+            this.nullRestricted = nullRestricted;\n@@ -79,1 +77,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, true);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, vform, true);\n@@ -86,1 +84,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, false);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, vform, false);\n@@ -113,1 +111,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n+            if (value == null && handle.nullRestricted) {\n@@ -127,1 +125,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n+            if (value == null && handle.nullRestricted) {\n@@ -140,1 +138,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n+            if (value == null && handle.nullRestricted) {\n@@ -154,1 +152,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n+            if (value == null && handle.nullRestricted) {\n@@ -166,2 +164,2 @@\n-        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n+        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, false);\n@@ -170,1 +168,1 @@\n-        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n+        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout},\n@@ -172,1 +170,1 @@\n-            super(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldInstanceReadWrite.FORM, exact);\n+            super(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, FieldInstanceReadWrite.FORM, exact);\n@@ -179,1 +177,1 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, true);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, true);\n@@ -186,1 +184,1 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, false);\n@@ -192,1 +190,5 @@\n-            return handle.checkedFieldType.cast(value);\n+#if[Reference]\n+            if (value == null && handle.nullRestricted)\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n+#end[Reference]\n+            return handle.fieldType.cast(value);\n@@ -439,1 +441,1 @@\n-        final CheckedType checkedFieldType;\n+        final boolean nullRestricted;\n@@ -445,2 +447,2 @@\n-        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldStaticReadOnly.FORM, false);\n+        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, FieldStaticReadOnly.FORM, false);\n@@ -449,1 +451,1 @@\n-        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n+        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout},\n@@ -457,1 +459,1 @@\n-            this.checkedFieldType = checkedFieldType;\n+            this.nullRestricted = nullRestricted;\n@@ -468,1 +470,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, true);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, vform, true);\n@@ -475,1 +477,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, false);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, vform, false);\n@@ -504,2 +506,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n-                \/\/ return ValueClass.zeroInstance(handle.fieldType);\n+            if (value == null && handle.nullRestricted) {\n@@ -519,2 +520,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n-                \/\/return ValueClass.zeroInstance(handle.fieldType);\n+            if (value == null && handle.nullRestricted) {\n@@ -533,2 +533,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n-                \/\/return ValueClass.zeroInstance(handle.fieldType);\n+            if (value == null && handle.nullRestricted) {\n@@ -547,2 +546,1 @@\n-            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n-                \/\/return ValueClass.zeroInstance(handle.fieldType);\n+            if (value == null && handle.nullRestricted) {\n@@ -561,2 +559,2 @@\n-        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n+        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, false);\n@@ -565,1 +563,1 @@\n-        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n+        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}{#if[FlatValue]?, int layout},\n@@ -567,1 +565,1 @@\n-            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldStaticReadWrite.FORM, exact);\n+            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, FieldStaticReadWrite.FORM, exact);\n@@ -574,1 +572,1 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, true);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, true);\n@@ -581,1 +579,1 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}{#if[FlatValue]?, layout}, false);\n@@ -587,1 +585,1 @@\n-            return handle.checkedFieldType.cast(value);\n+            return handle.fieldType.cast(value);\n@@ -826,1 +824,1 @@\n-#end[Static]    \n+#end[Static]\n@@ -888,0 +886,3 @@\n+            if (value == null && ValueClass.isNullRestrictedArray(oarray)) {\n+                throw new NullPointerException(\"null not allowed for null-restricted array \" + oarray.getClass().toGenericString());\n+            }\n@@ -890,1 +891,1 @@\n-                return {#if[FlatValue]?ValueClass.componentCheckedType(oarray):handle.componentType}.cast(value);\n+                return handle.componentType.cast(value);\n@@ -892,1 +893,1 @@\n-                \/\/ Slow path: check value against argument array component checked type\n+                \/\/ Slow path: check value against argument array component type\n@@ -900,1 +901,1 @@\n-                return ValueClass.componentCheckedType(oarray).cast(value);\n+                return oarray.getClass().getComponentType().cast(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":47,"deletions":46,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.value;\n-\n-public sealed interface CheckedType permits NormalCheckedType, NullRestrictedCheckedType {\n-    Object cast(Object obj);\n-    boolean canCast(Object obj);\n-    Class<?> boundingClass();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/CheckedType.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.value;\n-\n-public final class NormalCheckedType implements CheckedType {\n-    private final Class<?> type;\n-    private NormalCheckedType(Class<?> cls) {\n-        this.type = cls;\n-    }\n-\n-    @Override\n-    public Object cast(Object obj) {\n-        return type.cast(obj);\n-    }\n-\n-    @Override\n-    public boolean canCast(Object obj) {\n-        return type.isAssignableFrom(obj.getClass());\n-    }\n-\n-    @Override\n-    public Class<?> boundingClass() {\n-        return type;\n-    }\n-\n-    \/**\n-     * {@returns a {@linkplain CheckedType checked type} for the given class if it is a checked type}\n-     *\n-     * A primitive type and {@code void} is not a checked type.\n-     *\n-     * @param cls {@code Class} object\n-     * @throws IllegalArgumentException if the given class is a primitive type\n-     *\/\n-    public static CheckedType of(Class<?> cls) {\n-        if (cls.isPrimitive())\n-            throw new IllegalArgumentException(cls.getName() + \" not a checked type\");\n-        return new NormalCheckedType(cls);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/NormalCheckedType.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.value;\n-\n-public final class NullRestrictedCheckedType implements CheckedType {\n-    private final Class<?> type;\n-    private NullRestrictedCheckedType(Class<?> cls) {\n-        this.type = cls;\n-    }\n-\n-    @Override\n-    public Object cast(Object obj) {\n-        if (obj == null) {\n-            throw new NullPointerException(\"null not allowed for null-restricted type \" + type.getName());\n-        }\n-        return type.cast(obj);\n-    }\n-\n-    @Override\n-    public boolean canCast(Object obj) {\n-        if (obj == null) return false;\n-        return type.isAssignableFrom(obj.getClass());\n-    }\n-\n-    @Override\n-    public Class<?> boundingClass() {\n-        return type;\n-    }\n-\n-    \/**\n-     * {@returns a {@linkplain NullRestrictedCheckedType null-restricted checked type}\n-     * for the given class if it is a checked type}\n-     *\n-     * A primitive type and {@code void} is not a checked type.\n-     *\n-     * @param cls {@code Class} object\n-     * @throws IllegalArgumentException if the given class is a primitive type\n-     * @throws IllegalArgumentException if the given class is not a value class\n-     *\/\n-    public static NullRestrictedCheckedType of(Class<?> cls) {\n-        if (cls.isPrimitive())\n-            throw new IllegalArgumentException(cls.getName() + \" not a checked type\");\n-        if (!cls.isValue()) {\n-            throw new IllegalArgumentException(cls.getName() + \" not a value class\");\n-        }\n-        return new NullRestrictedCheckedType(cls);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/NullRestrictedCheckedType.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -41,8 +41,0 @@\n-    \/**\n-     * {@return {@code CheckedType} representing the type of the given field}\n-     *\/\n-    public static CheckedType checkedType(Field f) {\n-        return isNullRestrictedField(f) ? NullRestrictedCheckedType.of(f.getType())\n-                                             : NormalCheckedType.of(f.getType());\n-    }\n-\n@@ -56,32 +48,0 @@\n-    \/**\n-     * {@return {@code CheckedType} representing the component type of the given array}\n-     *\/\n-    public static CheckedType componentCheckedType(Object array) {\n-        Class<?> componentType = array.getClass().getComponentType();\n-        return isNullRestrictedArray(array) ? NullRestrictedCheckedType.of(componentType)\n-                                            : NormalCheckedType.of(componentType);\n-    }\n-\n-    \/**\n-     * Allocate an array of a value class type with components that behave in\n-     * the same way as a {@link jdk.internal.vm.annotation.NullRestricted}\n-     * field.\n-     * <p>\n-     * Because these behaviors are not specified by Java SE, arrays created with\n-     * this method should only be used by internal JDK code for experimental\n-     * purposes and should not affect user-observable outcomes.\n-     *\n-     * @param componentType the CheckedType componentType\n-     * @param length length of the array\n-     * @param initVal the object to initialize NullRestricted arrays with\n-     * @throws IllegalArgumentException if {@code componentType} is not a value class type\n-     *\/\n-    public static Object[] newArrayInstance(CheckedType componentType, int length, Object initVal) {\n-        if (componentType instanceof NullRestrictedCheckedType) {\n-            \/\/ Only support atomic NullRestricted arrays\n-            return newNullRestrictedAtomicArray(componentType.boundingClass(), length, initVal);\n-        } else {\n-            return (Object[]) Array.newInstance(componentType.boundingClass(), length);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.value.NullRestrictedCheckedType;\n@@ -157,1 +156,1 @@\n-                            !(ValueClass.checkedType(field) instanceof NullRestrictedCheckedType) ||\n+                            !ValueClass.isNullRestrictedField(field) ||\n","filename":"test\/jdk\/valhalla\/valuetypes\/FlatVarHandleTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-import jdk.internal.value.CheckedType;\n-import jdk.internal.value.NullRestrictedCheckedType;\n@@ -81,1 +79,1 @@\n-    static Stream<Arguments> checkedTypes() throws ReflectiveOperationException {\n+    static Stream<Arguments> checkedField() throws ReflectiveOperationException {\n@@ -91,1 +89,1 @@\n-     * Test creating null-restricted arrays with CheckedType\n+     * Test creating null-restricted arrays\n@@ -94,2 +92,2 @@\n-    @MethodSource(\"checkedTypes\")\n-    public void testCheckedTypeArrays(Field field, Class<?> type, Object initValue,\n+    @MethodSource(\"checkedField\")\n+    public void testNullRestrictedArrays(Field field, Class<?> type, Object initValue,\n@@ -97,1 +95,2 @@\n-        CheckedType checkedType = ValueClass.checkedType(field);\n+        boolean nr = ValueClass.isNullRestrictedField(field);\n+        assertEquals(nr, nullRestricted);\n@@ -99,2 +98,3 @@\n-        assertTrue(checkedType.boundingClass() == type);\n-        Object[] array = ValueClass.newArrayInstance(checkedType, 4, initValue);\n+        Object[] array = nullRestricted\n+                ? ValueClass.newNullRestrictedAtomicArray(type, 4, initValue)\n+                : (Object[]) Array.newInstance(type, 4);\n@@ -102,1 +102,0 @@\n-        assertTrue(checkedType instanceof NullRestrictedCheckedType == nullRestricted);\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedArraysTest.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"}]}