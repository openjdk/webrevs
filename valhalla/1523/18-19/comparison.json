{"files":[{"patch":"@@ -321,16 +321,0 @@\n-\n-        \/\/ Check instance field assignments that appear in constructor prologues\n-        if (isEarlyReference(env, base, v)) {\n-\n-            \/\/ Field may not be inherited from a superclass\n-            if (v.owner != env.enclClass.sym) {\n-                log.error(pos, Errors.CantRefBeforeCtorCalled(v));\n-                return;\n-            }\n-\n-            \/\/ Field may not have an initializer\n-            if ((v.flags() & HASINIT) != 0) {\n-                log.error(pos, Errors.CantAssignInitializedBeforeCtorCalled(v));\n-                return;\n-            }\n-        }\n@@ -1332,5 +1316,1 @@\n-                if (isEarlyReference(\n-                        true,\n-                        localEnv,\n-                        tree.meth instanceof JCFieldAccess fa ? fa.selected : null,\n-                        msym))\n+                if (isEarlyReference(localEnv, tree.meth, msym))\n@@ -1409,2 +1389,0 @@\n-            if (isInLHS && !insideLambdaOrClassDef) return;\n-            tree = TreeInfo.skipParens(tree);\n@@ -1412,0 +1390,18 @@\n+            if (isInLHS && !insideLambdaOrClassDef) {\n+                \/\/ Check instance field assignments that appear in constructor prologues\n+                if (isEarlyReference(localEnv, tree, sym)) {\n+                    \/\/ Field may not be inherited from a superclass\n+                    if (sym.owner != localEnv.enclClass.sym) {\n+                        log.error(tree, Errors.CantRefBeforeCtorCalled(sym));\n+                        return;\n+                    }\n+\n+                    \/\/ Field may not have an initializer\n+                    if ((sym.flags() & HASINIT) != 0) {\n+                        log.error(tree, Errors.CantAssignInitializedBeforeCtorCalled(sym));\n+                        return;\n+                    }\n+                }\n+                return;\n+            }\n+            tree = TreeInfo.skipParens(tree);\n@@ -1438,7 +1434,3 @@\n-                        } else if (isEarlyReference( \/\/ now this is a `proper` instance field of the current class\n-                                        true,\n-                                        localEnv,\n-                                        tree.hasTag(SELECT) ? ((JCFieldAccess)tree).selected : null,\n-                                        sym\n-                                )) {\n-                            \/* references to fields of identity classes which happen to have initializers are\n+                        } else if (isEarlyReference(localEnv, tree, sym)) {\n+                            \/* now this is a `proper` instance field of the current class\n+                             * references to fields of identity classes which happen to have initializers are\n@@ -1459,0 +1451,25 @@\n+        \/**\n+         * Determine if the symbol appearance constitutes an early reference to the current class.\n+         *\n+         * <p>\n+         * This means the symbol is an instance field, or method, of the current class and it appears\n+         * in an early initialization context of it (i.e., one of its constructor prologues).\n+         *\n+         * @param env    The current environment\n+         * @param tree   the AST referencing the variable\n+         * @param sym    The symbol\n+         *\/\n+        private boolean isEarlyReference(Env<AttrContext> env, JCTree tree, Symbol sym) {\n+            JCTree base = tree instanceof JCFieldAccess fa ? fa.selected : null;\n+            if ((sym.flags() & STATIC) == 0 &&\n+                    (sym.kind == VAR || sym.kind == MTH) &&\n+                    sym.isMemberOf(env.enclClass.sym, types)) {\n+                \/\/ Allow \"Foo.this.x\" when \"Foo\" is (also) an outer class, as this refers to the outer instance\n+                if (base != null) {\n+                    return TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n@@ -1476,29 +1493,0 @@\n-    \/**\n-     * Determine if the symbol appearance constitutes an early reference to the current class.\n-     *\n-     * <p>\n-     * This means the symbol is an instance field, or method, of the current class and it appears\n-     * in an early initialization context of it (i.e., one of its constructor prologues).\n-     *\n-     * @param env    The current environment\n-     * @param base   Variable qualifier, if any, otherwise null\n-     * @param sym    The symbol\n-     *\/\n-    public boolean isEarlyReference(Env<AttrContext> env, JCTree base, Symbol sym) {\n-        return isEarlyReference(env.info.ctorPrologue, env, base, sym);\n-    }\n-\n-    public boolean isEarlyReference(boolean inPrologue, Env<AttrContext> env, JCTree base, Symbol sym) {\n-        if (inPrologue &&\n-                (sym.flags() & STATIC) == 0 &&\n-                (sym.kind == VAR || sym.kind == MTH) &&\n-                sym.isMemberOf(env.enclClass.sym, types)) {\n-            \/\/ Allow \"Foo.this.x\" when \"Foo\" is (also) an outer class, as this refers to the outer instance\n-            if (base != null) {\n-                return TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base);\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":47,"deletions":59,"binary":false,"changes":106,"status":"modified"}]}