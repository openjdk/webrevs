{"files":[{"patch":"@@ -1293,0 +1293,2 @@\n+        boolean insideLambdaOrClassDef = false;\n+\n@@ -1295,2 +1297,7 @@\n-            super.visitLambda(lambda);\n-            classDeclAndLambdaHelper(TreeInfo.symbolsFor(lambda.body));\n+            boolean previousInsideLambdaOrClassDef = insideLambdaOrClassDef;\n+            try {\n+                insideLambdaOrClassDef = true;\n+                super.visitLambda(lambda);\n+            } finally {\n+                insideLambdaOrClassDef = previousInsideLambdaOrClassDef;\n+            }\n@@ -1301,18 +1308,6 @@\n-            super.visitClassDef(classDecl);\n-            classDeclAndLambdaHelper(TreeInfo.symbolsFor(classDecl.defs));\n-        }\n-\n-        private void classDeclAndLambdaHelper(java.util.List<TreeInfo.SymAndTree> symbols) {\n-            for (TreeInfo.SymAndTree symAndTree : symbols) {\n-                Symbol sym = symAndTree.symbol();\n-                JCTree tree = TreeInfo.skipParens(symAndTree.tree());\n-                if (sym.kind == VAR &&\n-                        rs.isEarlyReference(\n-                                true, \/\/ localEnv could potentially have the `ctorPrologue` field set to false\n-                                localEnv,\n-                                tree instanceof JCFieldAccess fa ?\n-                                        fa.selected :\n-                                        null,\n-                                sym)) {\n-                    reportPrologueError(tree, sym);\n-                }\n+            boolean previousInsideLambdaOrClassDef = insideLambdaOrClassDef;\n+            try {\n+                insideLambdaOrClassDef = true;\n+                super.visitClassDef(classDecl);\n+            } finally {\n+                insideLambdaOrClassDef = previousInsideLambdaOrClassDef;\n@@ -1454,1 +1449,2 @@\n-                            if (!localEnv.enclClass.sym.isValueClass() && (sym.flags_field & HASINIT) != 0)\n+                            if (insideLambdaOrClassDef ||\n+                                (!localEnv.enclClass.sym.isValueClass() && (sym.flags_field & HASINIT) != 0))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -969,35 +969,0 @@\n-    public record SymAndTree(Symbol symbol, JCTree tree) {}\n-\n-    public static java.util.List<SymAndTree> symbolsFor(List<JCTree> nodes) {\n-        java.util.List<SymAndTree> result = new ArrayList<>();\n-        for (JCTree node : nodes) {\n-            java.util.List<SymAndTree> partialResult = symbolsFor(node);\n-            if (!partialResult.isEmpty()) {\n-                result.addAll(partialResult);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    public static java.util.List<SymAndTree> symbolsFor(JCTree node) {\n-        java.util.List<SymAndTree> result = new ArrayList<>();\n-        new TreeScanner() {\n-            @Override\n-            public void scan(JCTree tree) {\n-                super.scan(tree);\n-                if (tree != null) {\n-                    Symbol symbol = TreeInfo.symbolFor(tree);\n-                    if (symbol != null) {\n-                        result.add(new SymAndTree(symbol, tree));\n-                    }\n-                }\n-            }\n-\n-            @Override\n-            public void visitSelect(JCFieldAccess tree) {\n-                \/\/ do not go deeper\n-            }\n-        }.scan(node);\n-        return result;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"}]}