{"files":[{"patch":"@@ -127,0 +127,1 @@\n+    final LocalProxyVarsGen localProxyVarsGen;\n@@ -166,0 +167,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -1253,0 +1255,18 @@\n+                if (isConstructor) {\n+                    ListBuffer<JCTree> prologueCode = new ListBuffer<>();\n+                    for (JCTree stat : tree.body.stats) {\n+                        prologueCode.add(stat);\n+                        \/* gather all the stats in the body until a `super` or `this` constructor invocation is found,\n+                         * the constructor invocation will also be included\n+                         *\/\n+                        if (stat instanceof JCExpressionStatement expStmt &&\n+                                expStmt.expr instanceof JCMethodInvocation mi &&\n+                                TreeInfo.isConstructorCall(mi)) {\n+                            break;\n+                        }\n+                    }\n+                    if (!prologueCode.isEmpty()) {\n+                        CtorPrologueVisitor ctorPrologueVisitor = new CtorPrologueVisitor(localEnv);\n+                        ctorPrologueVisitor.scan(prologueCode.toList());\n+                    }\n+                }\n@@ -1264,0 +1284,189 @@\n+    class CtorPrologueVisitor extends TreeScanner {\n+        Env<AttrContext> localEnv;\n+        CtorPrologueVisitor(Env<AttrContext> localEnv) {\n+            this.localEnv = localEnv;\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda lambda) {\n+            super.visitLambda(lambda);\n+            \/\/ lambda in prologue\n+            classDeclAndLambdaHelper(TreeInfo.symbolsFor(lambda.body));\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl classDecl) {\n+            super.visitClassDef(classDecl);\n+            \/\/ local class in prologue\n+            classDeclAndLambdaHelper(TreeInfo.symbolsFor(classDecl.defs));\n+        }\n+\n+        private void classDeclAndLambdaHelper(java.util.List<TreeInfo.SymAndTree> symbols) {\n+            for (TreeInfo.SymAndTree symAndTree : symbols) {\n+                Symbol sym = symAndTree.symbol();\n+                JCTree tree = filter(symAndTree.tree());\n+                if (sym.kind == VAR &&\n+                        rs.isEarlyReference(\n+                                localEnv,\n+                                tree instanceof JCFieldAccess fa ?\n+                                        fa.selected :\n+                                        null,\n+                                (VarSymbol) sym)) {\n+                    reportPrologueError(tree, sym);\n+                }\n+            }\n+        }\n+\n+        private void reportPrologueError(JCTree tree, Symbol sym) {\n+            preview.checkSourceLevel(tree, Feature.FLEXIBLE_CONSTRUCTORS);\n+            log.error(tree, Errors.CantRefBeforeCtorCalled(sym));\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation tree) {\n+            super.visitApply(tree);\n+            Name name = TreeInfo.name(tree.meth);\n+            boolean isConstructorCall = name == names._this || name == names._super;\n+            Symbol msym = TreeInfo.symbolFor(tree.meth);\n+            if (!isConstructorCall && !msym.isStatic()) {\n+                if (msym.owner == env.enclClass.sym ||\n+                    msym.isMemberOf(env.enclClass.sym, types)) {\n+                    if (tree.meth instanceof JCFieldAccess fa) {\n+                        if (TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.sym.type, fa.selected)) {\n+                            reportPrologueError(tree.meth, msym);\n+                        }\n+                    } else {\n+                        reportPrologueError(tree.meth, msym);\n+                    }\n+                }\n+            }\n+            if (isConstructorCall) {\n+                if (tree.meth instanceof JCFieldAccess fa) {\n+                    if (TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.sym.type, fa.selected)) {\n+                        reportPrologueError(tree.meth, msym);\n+                    }\n+                }\n+            }\n+            \/\/ we still need to check the args\n+            for (JCExpression arg : tree.args) {\n+                analyzeTree(arg);\n+            }\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCNewClass tree) {\n+            super.visitNewClass(tree);\n+            checkNewClassAndMethRefs(tree, tree.type);\n+        }\n+\n+        @Override\n+        public void visitReference(JCMemberReference tree) {\n+            super.visitReference(tree);\n+            if (tree.getMode() == JCMemberReference.ReferenceMode.NEW) {\n+                checkNewClassAndMethRefs(tree, tree.expr.type);\n+            }\n+        }\n+\n+        void checkNewClassAndMethRefs(JCTree tree, Type t) {\n+            if (t.tsym.isEnclosedBy(env.enclClass.sym) &&\n+                    !t.tsym.isStatic() &&\n+                    !t.tsym.isDirectlyOrIndirectlyLocal()) {\n+                reportPrologueError(tree, t.getEnclosingType().tsym);\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            super.visitAssign(tree);\n+            if (tree.rhs.type.constValue() == null) {\n+                analyzeTree(tree.rhs);\n+            }\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            super.visitVarDef(tree);\n+            if (tree.init != null && tree.init.type.constValue() == null) {\n+                analyzeTree(tree.init);\n+            }\n+        }\n+\n+        JCTree filter(JCTree tree) {\n+            tree = TreeInfo.skipParens(tree);\n+            if (tree.hasTag(TYPECAST)) {\n+                tree = filter(((JCTypeCast)tree).expr);\n+            }\n+            return tree;\n+        }\n+\n+        void analyzeTree(JCTree jcTree) {\n+            jcTree = filter(jcTree);\n+            java.util.List<TreeInfo.SymAndTree> symbols = TreeInfo.symbolsFor(jcTree);\n+            for (TreeInfo.SymAndTree symAndTree : symbols) {\n+                Symbol sym = symAndTree.symbol();\n+                JCTree tree = filter(symAndTree.tree());\n+                if (!sym.isStatic() && !isMethodParam(tree)) {\n+                    if (sym.name == names._this || sym.name == names._super) {\n+                        if (TreeInfo.isExplicitThisReference(types, (ClassType)localEnv.enclClass.sym.type, tree)) {\n+                            reportPrologueError(tree, sym);\n+                        }\n+                    } else {\n+                        if (sym != null &&\n+                                !sym.owner.isAnonymous() &&\n+                                sym.owner != localEnv.enclClass.sym &&\n+                                sym.kind == VAR &&\n+                                sym.owner.kind == TYP) {\n+                            if (!tree.hasTag(IDENT) && !tree.hasTag(SELECT)) {\n+                                throw new AssertionError(\"unexpected tree \" + tree + \" with tag \" + tree.getTag());\n+                            }\n+                            Symbol owner = tree.hasTag(IDENT) ?\n+                                                sym.owner :\n+                                                ((JCFieldAccess)tree).selected.type.tsym;\n+                            if (localEnv.enclClass.sym.isSubClass(owner, types) &&\n+                                    sym.isInheritedIn(localEnv.enclClass.sym, types)) {\n+                                reportPrologueError(tree, sym);\n+                            }\n+                        } else {\n+                            if (!localEnv.enclClass.sym.isValueClass() &&\n+                                sym.kind == VAR &&\n+                                sym.owner.kind == TYP &&\n+                                ((sym.flags_field & HASINIT) != 0)) {\n+                                if (tree.hasTag(IDENT) ||\n+                                    TreeInfo.isExplicitThisReference(\n+                                            types,\n+                                            (ClassType)localEnv.enclClass.sym.type,\n+                                            tree)) {\n+                                    reportPrologueError(tree, sym);\n+                                }\n+                            }\n+                            if ((sym.isFinal() || sym.isStrict()) &&\n+                                    sym.kind == VAR &&\n+                                    sym.owner.kind == TYP)\n+                            localProxyVarsGen.addFinalOrStrictFieldReadInPrologue(localEnv.enclMethod, sym);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        boolean isMethodParam(JCTree tree) {\n+            JCTree treeToCheck = null;\n+            if (tree.hasTag(IDENT)) {\n+                treeToCheck = tree;\n+            } else if (tree instanceof JCFieldAccess) {\n+                JCFieldAccess fa = (JCFieldAccess) tree;\n+                while (fa.selected.hasTag(SELECT)) {\n+                    fa = (JCFieldAccess)fa.selected;\n+                }\n+                treeToCheck = fa;\n+            }\n+            if (treeToCheck != null) {\n+                Symbol sym = TreeInfo.symbolFor(treeToCheck instanceof JCFieldAccess fa ? fa.selected : treeToCheck);\n+                if (sym != null){\n+                    return sym.owner.kind == MTH;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -1336,0 +1545,4 @@\n+                        if (v.owner.kind == TYP && !v.isStatic() && v.isStrict()) {\n+                            CtorPrologueVisitor ctorPrologueVisitor = new CtorPrologueVisitor(initEnv);\n+                            ctorPrologueVisitor.scan(tree.init);\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -91,2 +91,2 @@\n-    private java.util.List<JCVariableDecl> strictInstanceFields;\n-    private Map<JCMethodDecl, Set<Symbol>> strictFieldsReadInPrologue = new HashMap<>();\n+    private java.util.List<JCVariableDecl> finalOrStrictInstanceFields;\n+    private Map<JCMethodDecl, Set<Symbol>> finalOrStrictFieldsReadInPrologue = new HashMap<>();\n@@ -108,2 +108,2 @@\n-    public void addStrictFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n-        Set<Symbol> fieldSet = strictFieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n+    public void addFinalOrStrictFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n+        Set<Symbol> fieldSet = finalOrStrictFieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n@@ -111,1 +111,1 @@\n-        strictFieldsReadInPrologue.put(constructor, fieldSet);\n+        finalOrStrictFieldsReadInPrologue.put(constructor, fieldSet);\n@@ -131,1 +131,1 @@\n-        java.util.List<JCVariableDecl> prevStrictInstanceFields = strictInstanceFields;\n+        java.util.List<JCVariableDecl> prevFinalOrStrictInstanceFields = finalOrStrictInstanceFields;\n@@ -134,1 +134,1 @@\n-            strictInstanceFields = tree.defs.stream()\n+            finalOrStrictInstanceFields = tree.defs.stream()\n@@ -137,1 +137,1 @@\n-                    .filter(vd -> vd.sym.isStrict() && !vd.sym.isStatic())\n+                    .filter(vd -> (vd.sym.isStrict() || vd.sym.isFinal()) && !vd.sym.isStatic())\n@@ -142,1 +142,1 @@\n-            strictInstanceFields = prevStrictInstanceFields;\n+            finalOrStrictInstanceFields = prevFinalOrStrictInstanceFields;\n@@ -147,6 +147,6 @@\n-        if (strictFieldsReadInPrologue.get(tree) != null) {\n-            Set<Symbol> fieldSet = strictFieldsReadInPrologue.get(tree);\n-            java.util.List<JCVariableDecl> strictFieldsRead = new ArrayList<>();\n-            for (JCVariableDecl sfield : strictInstanceFields) {\n-                if (fieldSet.contains(sfield.sym)) {\n-                    strictFieldsRead.add(sfield);\n+        if (finalOrStrictFieldsReadInPrologue.get(tree) != null) {\n+            Set<Symbol> fieldSet = finalOrStrictFieldsReadInPrologue.get(tree);\n+            java.util.List<JCVariableDecl> finalOrStrictFieldsRead = new ArrayList<>();\n+            for (JCVariableDecl field : finalOrStrictInstanceFields) {\n+                if (fieldSet.contains(field.sym)) {\n+                    finalOrStrictFieldsRead.add(field);\n@@ -155,2 +155,2 @@\n-            addLocalProxiesFor(tree, strictFieldsRead);\n-            strictFieldsReadInPrologue.remove(tree);\n+            addLocalProxiesFor(tree, finalOrStrictFieldsRead);\n+            finalOrStrictFieldsReadInPrologue.remove(tree);\n@@ -161,1 +161,1 @@\n-    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> multiAssignedStrictFields) {\n+    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> finalOrStrictFields) {\n@@ -165,1 +165,1 @@\n-        for (JCVariableDecl fieldDecl : multiAssignedStrictFields) {\n+        for (JCVariableDecl fieldDecl : finalOrStrictFields) {\n@@ -214,1 +214,1 @@\n-    Name newLocalName(String name) {\n+    private Name newLocalName(String name) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1540,10 +1540,0 @@\n-                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n-                        if (!env.tree.hasTag(ASSIGN) || !TreeInfo.isIdentOrThisDotIdent(((JCAssign)env.tree).lhs)) {\n-                            if (!sym.isStrictInstance()) {\n-                                return new RefBeforeCtorCalledError(sym);\n-                            } else {\n-                                localProxyVarsGen.addStrictFieldReadInPrologue(env.enclMethod, sym);\n-                                return sym;\n-                            }\n-                        }\n-                    }\n@@ -2057,2 +2047,0 @@\n-                        if (env1.info.ctorPrologue && env1 == env)\n-                            return new RefBeforeCtorCalledError(sym);\n@@ -3829,3 +3817,0 @@\n-                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n-                        \/\/ early construction context, stop search\n-                        return new RefBeforeCtorCalledError(sym);\n@@ -3891,4 +3876,0 @@\n-                    else if (env1.info.ctorPrologue &&\n-                            !isReceiverParameter(env, tree) &&\n-                            !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n-                        sym = new RefBeforeCtorCalledError(sym);\n@@ -3908,2 +3889,0 @@\n-                    if (env.info.ctorPrologue)\n-                        log.error(pos, Errors.CantRefBeforeCtorCalled(name));\n@@ -3945,0 +3924,1 @@\n+\n@@ -3952,58 +3932,0 @@\n-    \/**\n-     * Determine if an early instance field reference may appear in a constructor prologue.\n-     *\n-     * <p>\n-     * This is only allowed when:\n-     *  - The field is being assigned a value (i.e., written but not read)\n-     *  - The field is not inherited from a superclass\n-     *  - The assignment is not within a lambda, because that would require\n-     *    capturing 'this' which is not allowed prior to super().\n-     *\n-     * <p>\n-     * Note, this method doesn't catch all such scenarios, because this method\n-     * is invoked for symbol \"x\" only for \"x = 42\" but not for \"this.x = 42\".\n-     * We also don't verify that the field has no initializer, which is required.\n-     * To catch those cases, we rely on similar logic in Attr.checkAssignable().\n-     *\/\n-    private boolean isAllowedEarlyReference(DiagnosticPosition pos, Env<AttrContext> env, VarSymbol v) {\n-\n-        \/\/ Check assumptions\n-        Assert.check(env.info.ctorPrologue);\n-        Assert.check((v.flags_field & STATIC) == 0);\n-\n-        \/\/ The symbol must appear in the LHS of an assignment statement\n-        if (!(env.tree instanceof JCAssign assign))\n-            return false;\n-\n-        \/\/ The assignment statement must not be within a lambda\n-        if (env.info.isLambda)\n-            return false;\n-\n-        \/\/ Get the symbol's qualifier, if any\n-        JCExpression lhs = TreeInfo.skipParens(assign.lhs);\n-        JCExpression base;\n-        switch (lhs.getTag()) {\n-        case IDENT:\n-            base = null;\n-            break;\n-        case SELECT:\n-            JCFieldAccess select = (JCFieldAccess)lhs;\n-            base = select.selected;\n-            if (!TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))\n-                return false;\n-            break;\n-        default:\n-            return false;\n-        }\n-\n-        \/\/ If an early reference, the field must not be declared in a superclass\n-        if (isEarlyReference(env, base, v) && v.owner != env.enclClass.sym)\n-            return false;\n-\n-        \/\/ The flexible constructors feature must be enabled\n-        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n-\n-        \/\/ OK\n-        return true;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":79,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.ArrayList;\n@@ -967,0 +968,35 @@\n+    public record SymAndTree(Symbol symbol, JCTree tree) {}\n+\n+    public static java.util.List<SymAndTree> symbolsFor(List<JCTree> nodes) {\n+        java.util.List<SymAndTree> result = new ArrayList<>();\n+        for (JCTree node : nodes) {\n+            java.util.List<SymAndTree> partialResult = symbolsFor(node);\n+            if (!partialResult.isEmpty()) {\n+                result.addAll(partialResult);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public static java.util.List<SymAndTree> symbolsFor(JCTree node) {\n+        java.util.List<SymAndTree> result = new ArrayList<>();\n+        new TreeScanner() {\n+            @Override\n+            public void scan(JCTree tree) {\n+                super.scan(tree);\n+                if (tree != null) {\n+                    Symbol symbol = TreeInfo.symbolFor(tree);\n+                    if (symbol != null) {\n+                        result.add(new SymAndTree(symbol, tree));\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void visitSelect(JCFieldAccess tree) {\n+                \/\/ do not go deeper\n+            }\n+        }.scan(node);\n+        return result;\n+    }\n+\n@@ -1010,0 +1046,2 @@\n+        case TYPECAST:\n+            return symbolFor(((JCTypeCast)node).expr);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-InvalidThisAndSuperInConstructorArgTest.java:23:29: compiler.err.cant.ref.before.ctor.called: super\n-InvalidThisAndSuperInConstructorArgTest.java:26:28: compiler.err.cant.ref.before.ctor.called: super\n-InvalidThisAndSuperInConstructorArgTest.java:29:29: compiler.err.cant.ref.before.ctor.called: this\n-InvalidThisAndSuperInConstructorArgTest.java:32:28: compiler.err.cant.ref.before.ctor.called: this\n+InvalidThisAndSuperInConstructorArgTest.java:23:35: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:26:34: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:29:34: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:32:33: compiler.err.cant.ref.before.ctor.called: toString()\n@@ -9,1 +9,1 @@\n-InvalidThisAndSuperInConstructorArgTest.java:47:38: compiler.err.cant.ref.before.ctor.called: super\n+InvalidThisAndSuperInConstructorArgTest.java:47:44: compiler.err.cant.ref.before.ctor.called: get()\n@@ -12,1 +12,1 @@\n-InvalidThisAndSuperInConstructorArgTest.java:56:39: compiler.err.cant.ref.before.ctor.called: super\n+InvalidThisAndSuperInConstructorArgTest.java:56:45: compiler.err.cant.ref.before.ctor.called: get()\n","filename":"test\/langtools\/tools\/javac\/8278078\/InvalidThisAndSuperInConstructorArgTest.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(r = () -> System.out.println(\"hello\"));\n+        r = () -> System.out.println(\"hello\");\n+        this(r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview1.java:12:14: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview1.java:13:13: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(this.r = () -> System.out.println(\"hello\"));\n+        this.r = () -> System.out.println(\"hello\");\n+        this(this.r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview2.java:12:14: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview2.java:13:13: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(EarlyAssignmentNoPreview3.this.r = () -> System.out.println(\"hello\"));\n+        EarlyAssignmentNoPreview3.this.r = () -> System.out.println(\"hello\");\n+        this(EarlyAssignmentNoPreview3.this.r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview3.java:12:39: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview3.java:13:13: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,3 +20,3 @@\n-            y = x;                          \/\/ FAIL - early 'this' reference\n-            y = this.x;                     \/\/ FAIL - early 'this' reference\n-            y = Inner1.this.x;              \/\/ FAIL - early 'this' reference\n+            y = x;                          \/\/ OK - \"x\" belongs to this class\n+            y = this.x;                     \/\/ OK - \"x\" belongs to this class\n+            y = Inner1.this.x;              \/\/ OK - \"x\" belongs to this class\n@@ -97,1 +97,1 @@\n-            x = x + 1;                          \/\/ FAIL - illegal early access\n+            x = x + 1;                          \/\/ OK\n@@ -103,1 +103,1 @@\n-            this.x = this.x + 1;                \/\/ FAIL - illegal early access\n+            this.x = this.x + 1;                \/\/ OK\n@@ -109,1 +109,1 @@\n-            Inner4.this.x = Inner4.this.x + 1;  \/\/ FAIL - illegal early access\n+            Inner4.this.x = Inner4.this.x + 1;  \/\/ OK\n@@ -171,0 +171,9 @@\n+\n+    public static class Inner9 {\n+        int x = 1;\n+        int y;\n+        Inner9() {\n+            y = x; \/\/ FAIL, x has an initializer\n+            super();\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,4 +1,1 @@\n-EarlyAssignments.java:20:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:21:17: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:22:23: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:30:21: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:30:26: compiler.err.cant.ref.before.ctor.called: x\n@@ -16,3 +13,0 @@\n-EarlyAssignments.java:97:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:103:22: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:109:35: compiler.err.cant.ref.before.ctor.called: this\n@@ -22,2 +16,2 @@\n-EarlyAssignments.java:133:17: compiler.err.cant.ref.before.ctor.called: super\n-EarlyAssignments.java:138:23: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:133:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:138:28: compiler.err.cant.ref.before.ctor.called: x\n@@ -26,2 +20,3 @@\n-EarlyAssignments.java:167:13: compiler.err.cant.ref.before.ctor.called: this\n-26 errors\n+EarlyAssignments.java:167:18: compiler.err.cant.ref.before.ctor.called: EarlyAssignments.Inner8\n+EarlyAssignments.java:176:17: compiler.err.cant.ref.before.ctor.called: x\n+21 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=EarlyIndirectOuterCapture.out -XDrawDiagnostics EarlyIndirectOuterCapture.java\n+ * @compile EarlyIndirectOuterCapture.java\n@@ -21,1 +21,1 @@\n-                super(\/* which enclosing instance here ? *\/new InnerSuperclass() { });\n+                super(new InnerSuperclass() { }); \/\/ should this be accepted?, InnerSuperclass is not an inner class of InnerInnerOuter\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-EarlyIndirectOuterCapture.java:21:60: compiler.err.cant.ref.before.ctor.called: this\n-1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyLocalClass.java:11:32: compiler.err.cant.ref.before.ctor.called: this\n+EarlyLocalClass.java:11:37: compiler.err.cant.ref.before.ctor.called: hashCode()\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalClass.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        super((Runnable)() -> x);       \/\/ this should FAIL\n+        super((Runnable)() -> System.err.println(x));       \/\/ this should FAIL\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,5 +2,4 @@\n-SuperInitFails.java:61:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:66:9: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:71:23: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:76:23: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:93:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:61:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:66:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:71:28: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:76:29: compiler.err.cant.ref.before.ctor.called: hashCode()\n@@ -10,1 +9,1 @@\n-SuperInitFails.java:111:17: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:111:23: compiler.err.cant.ref.before.ctor.called: spliterator()\n@@ -12,1 +11,1 @@\n-SuperInitFails.java:124:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:124:9: compiler.err.cant.ref.before.ctor.called: SuperInitFails\n@@ -15,2 +14,2 @@\n-SuperInitFails.java:154:31: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:158:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:154:50: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:158:15: compiler.err.cant.ref.before.ctor.called: SuperInitFails\n@@ -21,1 +20,1 @@\n-SuperInitFails.java:185:28: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:185:32: compiler.err.cant.ref.before.ctor.called: x\n@@ -34,1 +33,1 @@\n-33 errors\n+32 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,4 +2,4 @@\n-ValueClassSuperInitFails.java:72:9: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:77:9: compiler.err.cant.ref.before.ctor.called: super\n-ValueClassSuperInitFails.java:82:33: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:87:33: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:72:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:77:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:82:38: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:87:39: compiler.err.cant.ref.before.ctor.called: hashCode()\n@@ -9,1 +9,1 @@\n-ValueClassSuperInitFails.java:122:17: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:122:23: compiler.err.cant.ref.before.ctor.called: spliterator()\n@@ -11,1 +11,1 @@\n-ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: ValueClassSuperInitFails\n@@ -14,2 +14,3 @@\n-ValueClassSuperInitFails.java:161:41: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:161:46: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:175:49: compiler.err.cant.ref.before.ctor.called: x\n+ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: ValueClassSuperInitFails\n@@ -27,1 +28,1 @@\n-24 errors\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CantReferenceBeforeConstructorTest.java:30:13: compiler.err.cant.ref.before.ctor.called: this\n+CantReferenceBeforeConstructorTest.java:30:17: compiler.err.cant.ref.before.ctor.called: CantReferenceBeforeConstructorTest.BB.CC()\n","filename":"test\/langtools\/tools\/javac\/cantReferenceBeforeCtor\/CantReferenceBeforeConstructorTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    int i;\n@@ -31,2 +32,0 @@\n-    int i;\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefBeforeConstr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-NewBeforeOuterConstructed.java:27:21: compiler.err.cant.ref.before.ctor.called: this\n+NewBeforeOuterConstructed.java:27:21: compiler.err.cant.ref.before.ctor.called: NewBeforeOuterConstructed\n","filename":"test\/langtools\/tools\/javac\/implicitThis\/NewBeforeOuterConstructed.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-NewBeforeOuterConstructed2.java:20:35: compiler.err.cant.ref.before.ctor.called: this\n+NewBeforeOuterConstructed2.java:20:35: compiler.err.cant.ref.before.ctor.called: NewBeforeOuterConstructed2\n","filename":"test\/langtools\/tools\/javac\/implicitThis\/NewBeforeOuterConstructed2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-MethodReferenceNoThisTest.java:22:15: compiler.err.cant.ref.before.ctor.called: this\n+MethodReferenceNoThisTest.java:22:15: compiler.err.cant.ref.before.ctor.called: MethodReferenceNoThisTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReferenceNoThisTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-MethodReferenceInConstructorInvocation.java:24:30: compiler.err.cant.ref.before.ctor.called: super\n+MethodReferenceInConstructorInvocation.java:24:36: compiler.err.cant.ref.before.ctor.called: getString()\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodReferenceInConstructorInvocation.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-DualNonDuplicateErrors.java:18:13: compiler.err.cant.ref.before.ctor.called: this\n@@ -3,0 +2,1 @@\n+DualNonDuplicateErrors.java:18:13: compiler.err.cant.ref.before.ctor.called: this\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/DualNonDuplicateErrors.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-        assertOK(\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -926,1 +926,1 @@\n-                    Runnable r = () -> { System.err.println(t); }; \/\/ compiler will generate a local proxy for `t`\n+                    Runnable r = () -> { System.err.println(t); }; \/\/ cant reference `t` from a lambda expression in the prologue\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}