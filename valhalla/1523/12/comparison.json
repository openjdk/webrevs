{"files":[{"patch":"@@ -127,0 +127,1 @@\n+    final LocalProxyVarsGen localProxyVarsGen;\n@@ -166,0 +167,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -1255,0 +1257,19 @@\n+                if (isConstructor) {\n+                    ListBuffer<JCTree> prologueCode = new ListBuffer<>();\n+                    for (JCTree stat : tree.body.stats) {\n+                        prologueCode.add(stat);\n+                        \/* gather all the stats in the body until a `super` or `this` constructor invocation is found,\n+                         * including the constructor invocation, that way we don't need to worry in the visitor below if\n+                         * if we are dealing or not with prologue code\n+                         *\/\n+                        if (stat instanceof JCExpressionStatement expStmt &&\n+                                expStmt.expr instanceof JCMethodInvocation mi &&\n+                                TreeInfo.isConstructorCall(mi)) {\n+                            break;\n+                        }\n+                    }\n+                    if (!prologueCode.isEmpty()) {\n+                        CtorPrologueVisitor ctorPrologueVisitor = new CtorPrologueVisitor(localEnv);\n+                        ctorPrologueVisitor.scan(prologueCode.toList());\n+                    }\n+                }\n@@ -1266,0 +1287,203 @@\n+    class CtorPrologueVisitor extends TreeScanner {\n+        Env<AttrContext> localEnv;\n+        CtorPrologueVisitor(Env<AttrContext> localEnv) {\n+            this.localEnv = localEnv;\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda lambda) {\n+            super.visitLambda(lambda);\n+            classDeclAndLambdaHelper(TreeInfo.symbolsFor(lambda.body));\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl classDecl) {\n+            super.visitClassDef(classDecl);\n+            classDeclAndLambdaHelper(TreeInfo.symbolsFor(classDecl.defs));\n+        }\n+\n+        private void classDeclAndLambdaHelper(java.util.List<TreeInfo.SymAndTree> symbols) {\n+            for (TreeInfo.SymAndTree symAndTree : symbols) {\n+                Symbol sym = symAndTree.symbol();\n+                JCTree tree = TreeInfo.skipParens(symAndTree.tree());\n+                if (sym.kind == VAR &&\n+                        rs.isEarlyReference(\n+                                true, \/\/ localEnv could potentially have the `ctorPrologue` field set to false\n+                                localEnv,\n+                                tree instanceof JCFieldAccess fa ?\n+                                        fa.selected :\n+                                        null,\n+                                sym)) {\n+                    reportPrologueError(tree, sym);\n+                }\n+            }\n+        }\n+\n+        private void reportPrologueError(JCTree tree, Symbol sym) {\n+            preview.checkSourceLevel(tree, Feature.FLEXIBLE_CONSTRUCTORS);\n+            log.error(tree, Errors.CantRefBeforeCtorCalled(sym));\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation tree) {\n+            super.visitApply(tree);\n+            Name name = TreeInfo.name(tree.meth);\n+            boolean isConstructorCall = name == names._this || name == names._super;\n+            Symbol msym = TreeInfo.symbolFor(tree.meth);\n+            \/\/ is this an instance method call or an illegal constructor invocation like: `this.super()`?\n+            if (msym != null && \/\/ for erroneous invocations msym can be null, ignore those\n+                (!isConstructorCall ||\n+                isConstructorCall && tree.meth.hasTag(SELECT))) {\n+                if (rs.isEarlyReference(\n+                        true,\n+                        localEnv,\n+                        tree.meth instanceof JCFieldAccess fa ? fa.selected : null,\n+                        msym))\n+                    reportPrologueError(tree.meth, msym);\n+            }\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            \/\/ skip if this identifier is part of a select, context is important here\n+            if (!analyzingSelect) {\n+                analyzeSymbol(tree);\n+            }\n+        }\n+\n+        boolean analyzingSelect = false;\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            \/\/ skip if part of a larger select, context is important here\n+            if (!analyzingSelect) {\n+                boolean previousAnalyzingSelect = analyzingSelect;\n+                try {\n+                    analyzingSelect = true;\n+                    super.visitSelect(tree);\n+                    analyzeSymbol(tree);\n+                } finally {\n+                    analyzingSelect = previousAnalyzingSelect;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCNewClass tree) {\n+            super.visitNewClass(tree);\n+            checkNewClassAndMethRefs(tree, tree.type);\n+        }\n+\n+        @Override\n+        public void visitReference(JCMemberReference tree) {\n+            super.visitReference(tree);\n+            if (tree.getMode() == JCMemberReference.ReferenceMode.NEW) {\n+                checkNewClassAndMethRefs(tree, tree.expr.type);\n+            }\n+        }\n+\n+        void checkNewClassAndMethRefs(JCTree tree, Type t) {\n+            if (t.tsym.isEnclosedBy(localEnv.enclClass.sym) &&\n+                    !t.tsym.isStatic() &&\n+                    !t.tsym.isDirectlyOrIndirectlyLocal()) {\n+                reportPrologueError(tree, t.getEnclosingType().tsym);\n+            }\n+        }\n+\n+        \/* if a symbol is in the LHS of an assignment expression we won't consider it as a candidate\n+         * for a proxy local variable later on\n+         *\/\n+        boolean isInLHS = false;\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            boolean previousIsInLHS = isInLHS;\n+            try {\n+                isInLHS = true;\n+                scan(tree.lhs);\n+            } finally {\n+                isInLHS = previousIsInLHS;\n+            }\n+            scan(tree.rhs);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            \/\/ ignore any declarative part, mainly to avoid scanning receiver parameters\n+            scan(tree.body);\n+        }\n+\n+        void analyzeSymbol(JCTree tree) {\n+            tree = TreeInfo.skipParens(tree);\n+            Symbol sym = TreeInfo.symbolFor(tree);\n+            if (sym != null) {\n+                if (!sym.isStatic() && !isMethodArgument(tree)) {\n+                    if (sym.name == names._this || sym.name == names._super) {\n+                        \/\/ are we seeing something like `this` or `CurrentClass.this` or `SuperClass.super::foo`?\n+                        if (TreeInfo.isExplicitThisReference(\n+                                types,\n+                                (ClassType)localEnv.enclClass.sym.type,\n+                                tree)) {\n+                            reportPrologueError(tree, sym);\n+                        }\n+                    } else if (sym.kind == VAR && sym.owner.kind == TYP) { \/\/ now fields only\n+                        if (sym.owner != localEnv.enclClass.sym) {\n+                            if (localEnv.enclClass.sym.isSubClass(sym.owner, types) &&\n+                                    sym.isInheritedIn(localEnv.enclClass.sym, types)) {\n+                                \/* if we are dealing with a field that doesn't belong to the current class, but the\n+                                 * field is inherited, this is an error. Unless, the super class is also an outer\n+                                 * class and the field's qualifier refers to the outer class\n+                                 *\/\n+                                if (tree.hasTag(IDENT) ||\n+                                    TreeInfo.isExplicitThisReference(\n+                                            types,\n+                                            (ClassType)localEnv.enclClass.sym.type,\n+                                            ((JCFieldAccess)tree).selected)) {\n+                                    reportPrologueError(tree, sym);\n+                                }\n+                            }\n+                        } else if (rs.isEarlyReference( \/\/ now this is a `proper` instance field of the current class\n+                                        true,\n+                                        localEnv,\n+                                        tree.hasTag(SELECT) ? ((JCFieldAccess)tree).selected : null,\n+                                        sym\n+                                )) {\n+                            \/* references to fields of identity classes which happen to have initializers are\n+                             * not allowed in the prologue\n+                             *\/\n+                            if (!localEnv.enclClass.sym.isValueClass() && (sym.flags_field & HASINIT) != 0)\n+                                reportPrologueError(tree, sym);\n+                            \/\/ we will need to generate a proxy for this field later on\n+                            if (!isInLHS)\n+                                localProxyVarsGen.addFieldReadInPrologue(localEnv.enclMethod, sym);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        boolean isMethodArgument(JCTree tree) {\n+            JCTree treeToCheck = null;\n+            if (tree.hasTag(IDENT)) {\n+                treeToCheck = tree;\n+            } else if (tree instanceof JCFieldAccess) {\n+                JCFieldAccess fa = (JCFieldAccess) tree;\n+                while (fa.selected.hasTag(SELECT)) {\n+                    fa = (JCFieldAccess)fa.selected;\n+                }\n+                treeToCheck = fa;\n+            }\n+            if (treeToCheck != null) {\n+                Symbol sym = TreeInfo.symbolFor(\n+                        treeToCheck instanceof JCFieldAccess fa ?\n+                                fa.selected :\n+                                treeToCheck\n+                );\n+                if (sym != null){\n+                    return sym.owner.kind == MTH;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -1338,0 +1562,5 @@\n+                        if (v.owner.kind == TYP && !v.isStatic() && v.isStrict()) {\n+                            \/\/ strict field initializers are inlined in constructor's prologues\n+                            CtorPrologueVisitor ctorPrologueVisitor = new CtorPrologueVisitor(initEnv);\n+                            ctorPrologueVisitor.scan(tree.init);\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Symtab;\n@@ -45,0 +46,1 @@\n+import com.sun.tools.javac.util.Assert;\n@@ -52,0 +54,1 @@\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n@@ -62,1 +65,1 @@\n-\/** This phase adds local variable proxies for strict fields that are read during the\n+\/** This phase adds local variable proxies for fields that are read during the\n@@ -87,0 +90,1 @@\n+    private final Symtab syms;\n@@ -91,2 +95,2 @@\n-    private java.util.List<JCVariableDecl> strictInstanceFields;\n-    private Map<JCMethodDecl, Set<Symbol>> strictFieldsReadInPrologue = new HashMap<>();\n+    private java.util.List<JCVariableDecl> instanceFields;\n+    private Map<JCMethodDecl, Set<Symbol>> fieldsReadInPrologue = new HashMap<>();\n@@ -102,0 +106,1 @@\n+        syms = Symtab.instance(context);\n@@ -108,2 +113,2 @@\n-    public void addStrictFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n-        Set<Symbol> fieldSet = strictFieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n+    public void addFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n+        Set<Symbol> fieldSet = fieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n@@ -111,1 +116,1 @@\n-        strictFieldsReadInPrologue.put(constructor, fieldSet);\n+        fieldsReadInPrologue.put(constructor, fieldSet);\n@@ -131,1 +136,1 @@\n-        java.util.List<JCVariableDecl> prevStrictInstanceFields = strictInstanceFields;\n+        java.util.List<JCVariableDecl> prevInstanceFields = instanceFields;\n@@ -134,1 +139,1 @@\n-            strictInstanceFields = tree.defs.stream()\n+            instanceFields = tree.defs.stream()\n@@ -137,1 +142,1 @@\n-                    .filter(vd -> vd.sym.isStrict() && !vd.sym.isStatic())\n+                    .filter(vd -> !vd.sym.isStatic())\n@@ -142,1 +147,1 @@\n-            strictInstanceFields = prevStrictInstanceFields;\n+            instanceFields = prevInstanceFields;\n@@ -147,6 +152,6 @@\n-        if (strictFieldsReadInPrologue.get(tree) != null) {\n-            Set<Symbol> fieldSet = strictFieldsReadInPrologue.get(tree);\n-            java.util.List<JCVariableDecl> strictFieldsRead = new ArrayList<>();\n-            for (JCVariableDecl sfield : strictInstanceFields) {\n-                if (fieldSet.contains(sfield.sym)) {\n-                    strictFieldsRead.add(sfield);\n+        if (fieldsReadInPrologue.get(tree) != null) {\n+            Set<Symbol> fieldSet = fieldsReadInPrologue.get(tree);\n+            java.util.List<JCVariableDecl> fieldsRead = new ArrayList<>();\n+            for (JCVariableDecl field : instanceFields) {\n+                if (fieldSet.contains(field.sym)) {\n+                    fieldsRead.add(field);\n@@ -155,2 +160,2 @@\n-            addLocalProxiesFor(tree, strictFieldsRead);\n-            strictFieldsReadInPrologue.remove(tree);\n+            addLocalProxiesFor(tree, fieldsRead);\n+            fieldsReadInPrologue.remove(tree);\n@@ -161,1 +166,1 @@\n-    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> multiAssignedStrictFields) {\n+    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> fields) {\n@@ -165,1 +170,1 @@\n-        for (JCVariableDecl fieldDecl : multiAssignedStrictFields) {\n+        for (JCVariableDecl fieldDecl : fields) {\n@@ -169,1 +174,8 @@\n-            JCVariableDecl localDecl = make.at(constructor.pos).VarDef(proxy, fieldDecl.init);\n+            JCVariableDecl localDecl;\n+            JCExpression initializer = fieldDecl.init;\n+            if (initializer == null && !fieldDecl.sym.isFinal() && !fieldDecl.sym.isStrict()) {\n+                initializer = fieldDecl.vartype.type.isPrimitive() ?\n+                                    make.at(constructor.pos).Literal(0) :\n+                                    make.at(constructor.pos).Literal(BOT, null).setType(syms.botType);\n+            }\n+            localDecl = make.at(constructor.pos).VarDef(proxy, initializer);\n@@ -214,1 +226,1 @@\n-    Name newLocalName(String name) {\n+    private Name newLocalName(String name) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1540,10 +1540,0 @@\n-                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n-                        if (!env.tree.hasTag(ASSIGN) || !TreeInfo.isIdentOrThisDotIdent(((JCAssign)env.tree).lhs)) {\n-                            if (!sym.isStrictInstance()) {\n-                                return new RefBeforeCtorCalledError(sym);\n-                            } else {\n-                                localProxyVarsGen.addStrictFieldReadInPrologue(env.enclMethod, sym);\n-                                return sym;\n-                            }\n-                        }\n-                    }\n@@ -2057,2 +2047,0 @@\n-                        if (env1.info.ctorPrologue && env1 == env)\n-                            return new RefBeforeCtorCalledError(sym);\n@@ -3829,3 +3817,0 @@\n-                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n-                        \/\/ early construction context, stop search\n-                        return new RefBeforeCtorCalledError(sym);\n@@ -3891,4 +3876,0 @@\n-                    else if (env1.info.ctorPrologue &&\n-                            !isReceiverParameter(env, tree) &&\n-                            !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n-                        sym = new RefBeforeCtorCalledError(sym);\n@@ -3908,2 +3889,0 @@\n-                    if (env.info.ctorPrologue)\n-                        log.error(pos, Errors.CantRefBeforeCtorCalled(name));\n@@ -3945,0 +3924,1 @@\n+\n@@ -3953,59 +3933,1 @@\n-     * Determine if an early instance field reference may appear in a constructor prologue.\n-     *\n-     * <p>\n-     * This is only allowed when:\n-     *  - The field is being assigned a value (i.e., written but not read)\n-     *  - The field is not inherited from a superclass\n-     *  - The assignment is not within a lambda, because that would require\n-     *    capturing 'this' which is not allowed prior to super().\n-     *\n-     * <p>\n-     * Note, this method doesn't catch all such scenarios, because this method\n-     * is invoked for symbol \"x\" only for \"x = 42\" but not for \"this.x = 42\".\n-     * We also don't verify that the field has no initializer, which is required.\n-     * To catch those cases, we rely on similar logic in Attr.checkAssignable().\n-     *\/\n-    private boolean isAllowedEarlyReference(DiagnosticPosition pos, Env<AttrContext> env, VarSymbol v) {\n-\n-        \/\/ Check assumptions\n-        Assert.check(env.info.ctorPrologue);\n-        Assert.check((v.flags_field & STATIC) == 0);\n-\n-        \/\/ The symbol must appear in the LHS of an assignment statement\n-        if (!(env.tree instanceof JCAssign assign))\n-            return false;\n-\n-        \/\/ The assignment statement must not be within a lambda\n-        if (env.info.isLambda)\n-            return false;\n-\n-        \/\/ Get the symbol's qualifier, if any\n-        JCExpression lhs = TreeInfo.skipParens(assign.lhs);\n-        JCExpression base;\n-        switch (lhs.getTag()) {\n-        case IDENT:\n-            base = null;\n-            break;\n-        case SELECT:\n-            JCFieldAccess select = (JCFieldAccess)lhs;\n-            base = select.selected;\n-            if (!TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))\n-                return false;\n-            break;\n-        default:\n-            return false;\n-        }\n-\n-        \/\/ If an early reference, the field must not be declared in a superclass\n-        if (isEarlyReference(env, base, v) && v.owner != env.enclClass.sym)\n-            return false;\n-\n-        \/\/ The flexible constructors feature must be enabled\n-        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n-\n-        \/\/ OK\n-        return true;\n-    }\n-\n-    \/**\n-     * Determine if the variable appearance constitutes an early reference to the current class.\n+     * Determine if the symbol appearance constitutes an early reference to the current class.\n@@ -4014,1 +3936,1 @@\n-     * This means the variable is an instance field of the current class and it appears\n+     * This means the symbol is an instance field, or method, of the current class and it appears\n@@ -4017,4 +3939,0 @@\n-     * <p>\n-     * Such a reference is only allowed for assignments to non-initialized fields that are\n-     * not inherited from a superclass, though that is not enforced by this method.\n-     *\n@@ -4023,1 +3941,1 @@\n-     * @param v      The variable\n+     * @param sym    The symbol\n@@ -4025,4 +3943,3 @@\n-    public boolean isEarlyReference(Env<AttrContext> env, JCTree base, VarSymbol v) {\n-        if (env.info.ctorPrologue &&\n-                (v.flags() & STATIC) == 0 &&\n-                v.isMemberOf(env.enclClass.sym, types)) {\n+    public boolean isEarlyReference(Env<AttrContext> env, JCTree base, Symbol sym) {\n+        return isEarlyReference(env.info.ctorPrologue, env, base, sym);\n+    }\n@@ -4030,0 +3947,5 @@\n+    public boolean isEarlyReference(boolean inPrologue, Env<AttrContext> env, JCTree base, Symbol sym) {\n+        if (inPrologue &&\n+                (sym.flags() & STATIC) == 0 &&\n+                (sym.kind == VAR || sym.kind == MTH) &&\n+                sym.isMemberOf(env.enclClass.sym, types)) {\n@@ -4034,2 +3956,0 @@\n-\n-            \/\/ It's an early reference to an instance field member of the current instance\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":12,"deletions":92,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -1549,2 +1549,0 @@\n-            protected boolean hasValueClasses;\n-            protected boolean hasStrictFields;\n@@ -1562,1 +1560,0 @@\n-                            boolean prevHasStrictFields = hasStrictFields;\n@@ -1575,1 +1572,0 @@\n-                                hasStrictFields = prevHasStrictFields;\n@@ -1582,1 +1578,0 @@\n-                hasValueClasses = node.sym.isValueClass();\n@@ -1622,6 +1617,0 @@\n-\n-            @Override\n-            public void visitVarDef(JCVariableDecl tree) {\n-                hasStrictFields |= tree.sym.isStrict();\n-                super.visitVarDef(tree);\n-            }\n@@ -1713,7 +1702,4 @@\n-            if (scanner.hasValueClasses || scanner.hasStrictFields) {\n-                if (shouldStop(CompileState.STRICT_FIELDS_PROXIES))\n-                    return;\n-                for (JCTree def : cdefs) {\n-                    LocalProxyVarsGen.instance(context).translateTopLevelClass(def, localMake);\n-                }\n-                compileStates.put(env, CompileState.STRICT_FIELDS_PROXIES);\n+            if (shouldStop(CompileState.STRICT_FIELDS_PROXIES))\n+                return;\n+            for (JCTree def : cdefs) {\n+                LocalProxyVarsGen.instance(context).translateTopLevelClass(def, localMake);\n@@ -1721,0 +1707,1 @@\n+            compileStates.put(env, CompileState.STRICT_FIELDS_PROXIES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.ArrayList;\n@@ -199,1 +200,2 @@\n-                return ident.name == names._this || ident.name == names._super;\n+                return ident.name == names._this && tree.type.tsym == currentClass.tsym ||\n+                       ident.name == names._super;\n@@ -967,0 +969,35 @@\n+    public record SymAndTree(Symbol symbol, JCTree tree) {}\n+\n+    public static java.util.List<SymAndTree> symbolsFor(List<JCTree> nodes) {\n+        java.util.List<SymAndTree> result = new ArrayList<>();\n+        for (JCTree node : nodes) {\n+            java.util.List<SymAndTree> partialResult = symbolsFor(node);\n+            if (!partialResult.isEmpty()) {\n+                result.addAll(partialResult);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public static java.util.List<SymAndTree> symbolsFor(JCTree node) {\n+        java.util.List<SymAndTree> result = new ArrayList<>();\n+        new TreeScanner() {\n+            @Override\n+            public void scan(JCTree tree) {\n+                super.scan(tree);\n+                if (tree != null) {\n+                    Symbol symbol = TreeInfo.symbolFor(tree);\n+                    if (symbol != null) {\n+                        result.add(new SymAndTree(symbol, tree));\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void visitSelect(JCFieldAccess tree) {\n+                \/\/ do not go deeper\n+            }\n+        }.scan(node);\n+        return result;\n+    }\n+\n@@ -1010,0 +1047,2 @@\n+        case TYPECAST:\n+            return symbolFor(((JCTypeCast)node).expr);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-InvalidThisAndSuperInConstructorArgTest.java:23:29: compiler.err.cant.ref.before.ctor.called: super\n-InvalidThisAndSuperInConstructorArgTest.java:26:28: compiler.err.cant.ref.before.ctor.called: super\n-InvalidThisAndSuperInConstructorArgTest.java:29:29: compiler.err.cant.ref.before.ctor.called: this\n-InvalidThisAndSuperInConstructorArgTest.java:32:28: compiler.err.cant.ref.before.ctor.called: this\n+InvalidThisAndSuperInConstructorArgTest.java:23:35: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:26:34: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:29:34: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:32:33: compiler.err.cant.ref.before.ctor.called: toString()\n@@ -9,1 +9,1 @@\n-InvalidThisAndSuperInConstructorArgTest.java:47:38: compiler.err.cant.ref.before.ctor.called: super\n+InvalidThisAndSuperInConstructorArgTest.java:47:44: compiler.err.cant.ref.before.ctor.called: get()\n@@ -12,1 +12,1 @@\n-InvalidThisAndSuperInConstructorArgTest.java:56:39: compiler.err.cant.ref.before.ctor.called: super\n+InvalidThisAndSuperInConstructorArgTest.java:56:45: compiler.err.cant.ref.before.ctor.called: get()\n","filename":"test\/langtools\/tools\/javac\/8278078\/InvalidThisAndSuperInConstructorArgTest.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(r = () -> System.out.println(\"hello\"));\n+        r = () -> System.out.println(\"hello\");\n+        this(r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview1.java:12:14: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview1.java:13:13: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(this.r = () -> System.out.println(\"hello\"));\n+        this.r = () -> System.out.println(\"hello\");\n+        this(this.r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview2.java:12:14: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview2.java:13:13: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(EarlyAssignmentNoPreview3.this.r = () -> System.out.println(\"hello\"));\n+        EarlyAssignmentNoPreview3.this.r = () -> System.out.println(\"hello\");\n+        this(EarlyAssignmentNoPreview3.this.r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview3.java:12:39: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview3.java:13:13: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,3 +20,3 @@\n-            y = x;                          \/\/ FAIL - early 'this' reference\n-            y = this.x;                     \/\/ FAIL - early 'this' reference\n-            y = Inner1.this.x;              \/\/ FAIL - early 'this' reference\n+            y = x;                          \/\/ OK - \"x\" belongs to this class\n+            y = this.x;                     \/\/ OK - \"x\" belongs to this class\n+            y = Inner1.this.x;              \/\/ OK - \"x\" belongs to this class\n@@ -97,1 +97,1 @@\n-            x = x + 1;                          \/\/ FAIL - illegal early access\n+            x = x + 1;                          \/\/ OK\n@@ -103,1 +103,1 @@\n-            this.x = this.x + 1;                \/\/ FAIL - illegal early access\n+            this.x = this.x + 1;                \/\/ OK\n@@ -109,1 +109,1 @@\n-            Inner4.this.x = Inner4.this.x + 1;  \/\/ FAIL - illegal early access\n+            Inner4.this.x = Inner4.this.x + 1;  \/\/ OK\n@@ -171,0 +171,9 @@\n+\n+    public static class Inner9 {\n+        int x = 1;\n+        int y;\n+        Inner9() {\n+            y = x; \/\/ FAIL, x has an initializer\n+            super();\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,4 +1,1 @@\n-EarlyAssignments.java:20:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:21:17: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:22:23: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:30:21: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:30:26: compiler.err.cant.ref.before.ctor.called: x\n@@ -16,3 +13,0 @@\n-EarlyAssignments.java:97:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:103:22: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:109:35: compiler.err.cant.ref.before.ctor.called: this\n@@ -22,2 +16,2 @@\n-EarlyAssignments.java:133:17: compiler.err.cant.ref.before.ctor.called: super\n-EarlyAssignments.java:138:23: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:133:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:138:28: compiler.err.cant.ref.before.ctor.called: x\n@@ -26,2 +20,3 @@\n-EarlyAssignments.java:167:13: compiler.err.cant.ref.before.ctor.called: this\n-26 errors\n+EarlyAssignments.java:167:18: compiler.err.cant.ref.before.ctor.called: EarlyAssignments.Inner8\n+EarlyAssignments.java:176:17: compiler.err.cant.ref.before.ctor.called: x\n+21 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=EarlyIndirectOuterCapture.out -XDrawDiagnostics EarlyIndirectOuterCapture.java\n+ * @compile EarlyIndirectOuterCapture.java\n@@ -21,1 +21,1 @@\n-                super(\/* which enclosing instance here ? *\/new InnerSuperclass() { });\n+                super(new InnerSuperclass() { }); \/\/ should this be accepted?, InnerSuperclass is not an inner class of InnerInnerOuter\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-EarlyIndirectOuterCapture.java:21:60: compiler.err.cant.ref.before.ctor.called: this\n-1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyLocalClass.java:11:32: compiler.err.cant.ref.before.ctor.called: this\n+EarlyLocalClass.java:11:37: compiler.err.cant.ref.before.ctor.called: hashCode()\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalClass.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        super((Runnable)() -> x);       \/\/ this should FAIL\n+        super((Runnable)() -> System.err.println(x));       \/\/ this should FAIL\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,5 +2,4 @@\n-SuperInitFails.java:61:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:66:9: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:71:23: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:76:23: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:93:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:61:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:66:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:71:28: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:76:29: compiler.err.cant.ref.before.ctor.called: hashCode()\n@@ -10,1 +9,1 @@\n-SuperInitFails.java:111:17: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:111:23: compiler.err.cant.ref.before.ctor.called: spliterator()\n@@ -12,1 +11,1 @@\n-SuperInitFails.java:124:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:124:9: compiler.err.cant.ref.before.ctor.called: SuperInitFails\n@@ -15,2 +14,2 @@\n-SuperInitFails.java:154:31: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:158:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:154:50: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:158:15: compiler.err.cant.ref.before.ctor.called: SuperInitFails\n@@ -21,0 +20,1 @@\n+SuperInitFails.java:185:32: compiler.err.cant.ref.before.ctor.called: x\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,4 +2,4 @@\n-ValueClassSuperInitFails.java:72:9: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:77:9: compiler.err.cant.ref.before.ctor.called: super\n-ValueClassSuperInitFails.java:82:33: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:87:33: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:72:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:77:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:82:38: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:87:39: compiler.err.cant.ref.before.ctor.called: hashCode()\n@@ -9,1 +9,1 @@\n-ValueClassSuperInitFails.java:122:17: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:122:23: compiler.err.cant.ref.before.ctor.called: spliterator()\n@@ -11,1 +11,1 @@\n-ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: ValueClassSuperInitFails\n@@ -14,2 +14,3 @@\n-ValueClassSuperInitFails.java:161:41: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:161:46: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:175:49: compiler.err.cant.ref.before.ctor.called: x\n+ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: ValueClassSuperInitFails\n@@ -27,1 +28,1 @@\n-24 errors\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CantReferenceBeforeConstructorTest.java:30:13: compiler.err.cant.ref.before.ctor.called: this\n+CantReferenceBeforeConstructorTest.java:30:17: compiler.err.cant.ref.before.ctor.called: CantReferenceBeforeConstructorTest.BB.CC()\n","filename":"test\/langtools\/tools\/javac\/cantReferenceBeforeCtor\/CantReferenceBeforeConstructorTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    int i;\n@@ -31,2 +32,0 @@\n-    int i;\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefBeforeConstr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-NewBeforeOuterConstructed.java:27:21: compiler.err.cant.ref.before.ctor.called: this\n+NewBeforeOuterConstructed.java:27:21: compiler.err.cant.ref.before.ctor.called: NewBeforeOuterConstructed\n","filename":"test\/langtools\/tools\/javac\/implicitThis\/NewBeforeOuterConstructed.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-NewBeforeOuterConstructed2.java:20:35: compiler.err.cant.ref.before.ctor.called: this\n+NewBeforeOuterConstructed2.java:20:35: compiler.err.cant.ref.before.ctor.called: NewBeforeOuterConstructed2\n","filename":"test\/langtools\/tools\/javac\/implicitThis\/NewBeforeOuterConstructed2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-MethodReferenceNoThisTest.java:22:15: compiler.err.cant.ref.before.ctor.called: this\n+MethodReferenceNoThisTest.java:22:15: compiler.err.cant.ref.before.ctor.called: MethodReferenceNoThisTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReferenceNoThisTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-MethodReferenceInConstructorInvocation.java:24:30: compiler.err.cant.ref.before.ctor.called: super\n+MethodReferenceInConstructorInvocation.java:24:36: compiler.err.cant.ref.before.ctor.called: getString()\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodReferenceInConstructorInvocation.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-        assertOK(\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -926,1 +926,1 @@\n-                    Runnable r = () -> { System.err.println(t); }; \/\/ compiler will generate a local proxy for `t`\n+                    Runnable r = () -> { System.err.println(t); }; \/\/ cant reference `t` from a lambda expression in the prologue\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}