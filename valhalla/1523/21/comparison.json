{"files":[{"patch":"@@ -127,0 +127,1 @@\n+    final LocalProxyVarsGen localProxyVarsGen;\n@@ -166,0 +167,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -304,3 +306,1 @@\n-            return;\n-        }\n-        if ((v.flags() & FINAL) != 0 &&\n+        } else if ((v.flags() & FINAL) != 0 &&\n@@ -317,17 +317,0 @@\n-            return;\n-        }\n-\n-        \/\/ Check instance field assignments that appear in constructor prologues\n-        if (rs.isEarlyReference(env, base, v)) {\n-\n-            \/\/ Field may not be inherited from a superclass\n-            if (v.owner != env.enclClass.sym) {\n-                log.error(pos, Errors.CantRefBeforeCtorCalled(v));\n-                return;\n-            }\n-\n-            \/\/ Field may not have an initializer\n-            if ((v.flags() & HASINIT) != 0) {\n-                log.error(pos, Errors.CantAssignInitializedBeforeCtorCalled(v));\n-                return;\n-            }\n@@ -1255,0 +1238,19 @@\n+                if (isConstructor) {\n+                    ListBuffer<JCTree> prologueCode = new ListBuffer<>();\n+                    for (JCTree stat : tree.body.stats) {\n+                        prologueCode.add(stat);\n+                        \/* gather all the stats in the body until a `super` or `this` constructor invocation is found,\n+                         * including the constructor invocation, that way we don't need to worry in the visitor below if\n+                         * if we are dealing or not with prologue code\n+                         *\/\n+                        if (stat instanceof JCExpressionStatement expStmt &&\n+                                expStmt.expr instanceof JCMethodInvocation mi &&\n+                                TreeInfo.isConstructorCall(mi)) {\n+                            break;\n+                        }\n+                    }\n+                    if (!prologueCode.isEmpty()) {\n+                        CtorPrologueVisitor ctorPrologueVisitor = new CtorPrologueVisitor(localEnv);\n+                        ctorPrologueVisitor.scan(prologueCode.toList());\n+                    }\n+                }\n@@ -1266,0 +1268,226 @@\n+    class CtorPrologueVisitor extends TreeScanner {\n+        Env<AttrContext> localEnv;\n+        CtorPrologueVisitor(Env<AttrContext> localEnv) {\n+            this.localEnv = localEnv;\n+        }\n+\n+        boolean insideLambdaOrClassDef = false;\n+\n+        @Override\n+        public void visitLambda(JCLambda lambda) {\n+            boolean previousInsideLambdaOrClassDef = insideLambdaOrClassDef;\n+            try {\n+                insideLambdaOrClassDef = true;\n+                super.visitLambda(lambda);\n+            } finally {\n+                insideLambdaOrClassDef = previousInsideLambdaOrClassDef;\n+            }\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl classDecl) {\n+            boolean previousInsideLambdaOrClassDef = insideLambdaOrClassDef;\n+            try {\n+                insideLambdaOrClassDef = true;\n+                super.visitClassDef(classDecl);\n+            } finally {\n+                insideLambdaOrClassDef = previousInsideLambdaOrClassDef;\n+            }\n+        }\n+\n+        private void reportPrologueError(JCTree tree, Symbol sym) {\n+            preview.checkSourceLevel(tree, Feature.FLEXIBLE_CONSTRUCTORS);\n+            log.error(tree, Errors.CantRefBeforeCtorCalled(sym));\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation tree) {\n+            super.visitApply(tree);\n+            Name name = TreeInfo.name(tree.meth);\n+            boolean isConstructorCall = name == names._this || name == names._super;\n+            Symbol msym = TreeInfo.symbolFor(tree.meth);\n+            \/\/ is this an instance method call or an illegal constructor invocation like: `this.super()`?\n+            if (msym != null && \/\/ for erroneous invocations msym can be null, ignore those\n+                (!isConstructorCall ||\n+                isConstructorCall && tree.meth.hasTag(SELECT))) {\n+                if (isEarlyReference(localEnv, tree.meth, msym))\n+                    reportPrologueError(tree.meth, msym);\n+            }\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            analyzeSymbol(tree);\n+        }\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            SelectScanner ss = new SelectScanner();\n+            ss.scan(tree);\n+            if (ss.scanLater == null) {\n+                analyzeSymbol(tree);\n+            } else {\n+                boolean prevLhs = isInLHS;\n+                try {\n+                    isInLHS = false;\n+                    scan(ss.scanLater);\n+                } finally {\n+                    isInLHS = prevLhs;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCNewClass tree) {\n+            super.visitNewClass(tree);\n+            checkNewClassAndMethRefs(tree, tree.type);\n+        }\n+\n+        @Override\n+        public void visitReference(JCMemberReference tree) {\n+            super.visitReference(tree);\n+            if (tree.getMode() == JCMemberReference.ReferenceMode.NEW) {\n+                checkNewClassAndMethRefs(tree, tree.expr.type);\n+            }\n+        }\n+\n+        void checkNewClassAndMethRefs(JCTree tree, Type t) {\n+            if (t.tsym.isEnclosedBy(localEnv.enclClass.sym) &&\n+                    !t.tsym.isStatic() &&\n+                    !t.tsym.isDirectlyOrIndirectlyLocal()) {\n+                reportPrologueError(tree, t.getEnclosingType().tsym);\n+            }\n+        }\n+\n+        \/* if a symbol is in the LHS of an assignment expression we won't consider it as a candidate\n+         * for a proxy local variable later on\n+         *\/\n+        boolean isInLHS = false;\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            boolean previousIsInLHS = isInLHS;\n+            try {\n+                isInLHS = true;\n+                scan(tree.lhs);\n+            } finally {\n+                isInLHS = previousIsInLHS;\n+            }\n+            scan(tree.rhs);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            \/\/ ignore any declarative part, mainly to avoid scanning receiver parameters\n+            scan(tree.body);\n+        }\n+\n+        void analyzeSymbol(JCTree tree) {\n+            Symbol sym = TreeInfo.symbolFor(tree);\n+            if (isInLHS && !insideLambdaOrClassDef) {\n+                \/\/ Check instance field assignments that appear in constructor prologues\n+                if (isEarlyReference(localEnv, tree, sym)) {\n+                    \/\/ Field may not be inherited from a superclass\n+                    if (sym.owner != localEnv.enclClass.sym) {\n+                        log.error(tree, Errors.CantRefBeforeCtorCalled(sym));\n+                        return;\n+                    }\n+\n+                    \/\/ Field may not have an initializer\n+                    if ((sym.flags() & HASINIT) != 0) {\n+                        log.error(tree, Errors.CantAssignInitializedBeforeCtorCalled(sym));\n+                        return;\n+                    }\n+                }\n+                return;\n+            }\n+            tree = TreeInfo.skipParens(tree);\n+            if (sym != null) {\n+                if (!sym.isStatic() && sym.kind == VAR && sym.owner.kind == TYP) {\n+                    if (sym.name == names._this || sym.name == names._super) {\n+                        \/\/ are we seeing something like `this` or `CurrentClass.this` or `SuperClass.super::foo`?\n+                        if (TreeInfo.isExplicitThisReference(\n+                                types,\n+                                (ClassType)localEnv.enclClass.sym.type,\n+                                tree)) {\n+                            reportPrologueError(tree, sym);\n+                        }\n+                    } else if (sym.kind == VAR && sym.owner.kind == TYP) { \/\/ now fields only\n+                        if (sym.owner != localEnv.enclClass.sym) {\n+                            if (localEnv.enclClass.sym.isSubClass(sym.owner, types) &&\n+                                    sym.isInheritedIn(localEnv.enclClass.sym, types)) {\n+                                \/* if we are dealing with a field that doesn't belong to the current class, but the\n+                                 * field is inherited, this is an error. Unless, the super class is also an outer\n+                                 * class and the field's qualifier refers to the outer class\n+                                 *\/\n+                                if (tree.hasTag(IDENT) ||\n+                                    TreeInfo.isExplicitThisReference(\n+                                            types,\n+                                            (ClassType)localEnv.enclClass.sym.type,\n+                                            ((JCFieldAccess)tree).selected)) {\n+                                    reportPrologueError(tree, sym);\n+                                }\n+                            }\n+                        } else if (isEarlyReference(localEnv, tree, sym)) {\n+                            \/* now this is a `proper` instance field of the current class\n+                             * references to fields of identity classes which happen to have initializers are\n+                             * not allowed in the prologue\n+                             *\/\n+                            if (insideLambdaOrClassDef ||\n+                                (!localEnv.enclClass.sym.isValueClass() && (sym.flags_field & HASINIT) != 0))\n+                                reportPrologueError(tree, sym);\n+                            \/\/ we will need to generate a proxy for this field later on\n+                            if (!isInLHS) {\n+                                if (allowValueClasses) {\n+                                    localProxyVarsGen.addFieldReadInPrologue(localEnv.enclMethod, sym);\n+                                } else {\n+                                    reportPrologueError(tree, sym);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Determine if the symbol appearance constitutes an early reference to the current class.\n+         *\n+         * <p>\n+         * This means the symbol is an instance field, or method, of the current class and it appears\n+         * in an early initialization context of it (i.e., one of its constructor prologues).\n+         *\n+         * @param env    The current environment\n+         * @param tree   the AST referencing the variable\n+         * @param sym    The symbol\n+         *\/\n+        private boolean isEarlyReference(Env<AttrContext> env, JCTree tree, Symbol sym) {\n+            if ((sym.flags() & STATIC) == 0 &&\n+                    (sym.kind == VAR || sym.kind == MTH) &&\n+                    sym.isMemberOf(env.enclClass.sym, types)) {\n+                \/\/ Allow \"Foo.this.x\" when \"Foo\" is (also) an outer class, as this refers to the outer instance\n+                if (tree instanceof JCFieldAccess fa) {\n+                    return TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, fa.selected);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        \/* scanner for a select expression, anything that is not a select or identifier\n+         * will be stored for further analysis\n+         *\/\n+        class SelectScanner extends DeferredAttr.FilterScanner {\n+            JCTree scanLater;\n+\n+            SelectScanner() {\n+                super(Set.of(IDENT, SELECT, PARENS));\n+            }\n+\n+            @Override\n+            void skip(JCTree tree) {\n+                scanLater = tree;\n+            }\n+        }\n+    }\n+\n@@ -1338,0 +1566,5 @@\n+                        if (v.owner.kind == TYP && !v.isStatic() && v.isStrict()) {\n+                            \/\/ strict field initializers are inlined in constructor's prologues\n+                            CtorPrologueVisitor ctorPrologueVisitor = new CtorPrologueVisitor(initEnv);\n+                            ctorPrologueVisitor.scan(tree.init);\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":253,"deletions":20,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Symtab;\n@@ -45,0 +46,1 @@\n+import com.sun.tools.javac.util.Assert;\n@@ -52,0 +54,1 @@\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n@@ -62,1 +65,1 @@\n-\/** This phase adds local variable proxies for strict fields that are read during the\n+\/** This phase adds local variable proxies for fields that are read during the\n@@ -87,0 +90,1 @@\n+    private final Symtab syms;\n@@ -91,2 +95,2 @@\n-    private java.util.List<JCVariableDecl> strictInstanceFields;\n-    private Map<JCMethodDecl, Set<Symbol>> strictFieldsReadInPrologue = new HashMap<>();\n+    private java.util.List<JCVariableDecl> instanceFields;\n+    private Map<JCMethodDecl, Set<Symbol>> fieldsReadInPrologue = new HashMap<>();\n@@ -102,0 +106,1 @@\n+        syms = Symtab.instance(context);\n@@ -108,2 +113,2 @@\n-    public void addStrictFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n-        Set<Symbol> fieldSet = strictFieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n+    public void addFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n+        Set<Symbol> fieldSet = fieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n@@ -111,1 +116,1 @@\n-        strictFieldsReadInPrologue.put(constructor, fieldSet);\n+        fieldsReadInPrologue.put(constructor, fieldSet);\n@@ -131,1 +136,1 @@\n-        java.util.List<JCVariableDecl> prevStrictInstanceFields = strictInstanceFields;\n+        java.util.List<JCVariableDecl> prevInstanceFields = instanceFields;\n@@ -134,1 +139,1 @@\n-            strictInstanceFields = tree.defs.stream()\n+            instanceFields = tree.defs.stream()\n@@ -137,1 +142,1 @@\n-                    .filter(vd -> vd.sym.isStrict() && !vd.sym.isStatic())\n+                    .filter(vd -> !vd.sym.isStatic())\n@@ -142,1 +147,1 @@\n-            strictInstanceFields = prevStrictInstanceFields;\n+            instanceFields = prevInstanceFields;\n@@ -147,6 +152,6 @@\n-        if (strictFieldsReadInPrologue.get(tree) != null) {\n-            Set<Symbol> fieldSet = strictFieldsReadInPrologue.get(tree);\n-            java.util.List<JCVariableDecl> strictFieldsRead = new ArrayList<>();\n-            for (JCVariableDecl sfield : strictInstanceFields) {\n-                if (fieldSet.contains(sfield.sym)) {\n-                    strictFieldsRead.add(sfield);\n+        if (fieldsReadInPrologue.get(tree) != null) {\n+            Set<Symbol> fieldSet = fieldsReadInPrologue.get(tree);\n+            java.util.List<JCVariableDecl> fieldsRead = new ArrayList<>();\n+            for (JCVariableDecl field : instanceFields) {\n+                if (fieldSet.contains(field.sym)) {\n+                    fieldsRead.add(field);\n@@ -155,2 +160,2 @@\n-            addLocalProxiesFor(tree, strictFieldsRead);\n-            strictFieldsReadInPrologue.remove(tree);\n+            addLocalProxiesFor(tree, fieldsRead);\n+            fieldsReadInPrologue.remove(tree);\n@@ -161,1 +166,1 @@\n-    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> multiAssignedStrictFields) {\n+    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> fields) {\n@@ -165,1 +170,1 @@\n-        for (JCVariableDecl fieldDecl : multiAssignedStrictFields) {\n+        for (JCVariableDecl fieldDecl : fields) {\n@@ -169,1 +174,8 @@\n-            JCVariableDecl localDecl = make.at(constructor.pos).VarDef(proxy, fieldDecl.init);\n+            JCVariableDecl localDecl;\n+            JCExpression initializer = fieldDecl.init;\n+            if (initializer == null && !fieldDecl.sym.isFinal() && !fieldDecl.sym.isStrict()) {\n+                initializer = fieldDecl.vartype.type.isPrimitive() ?\n+                                    make.at(constructor.pos).Literal(0) :\n+                                    make.at(constructor.pos).Literal(BOT, null).setType(syms.botType);\n+            }\n+            localDecl = make.at(constructor.pos).VarDef(proxy, initializer);\n@@ -214,1 +226,1 @@\n-    Name newLocalName(String name) {\n+    private Name newLocalName(String name) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1540,10 +1540,0 @@\n-                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n-                        if (!env.tree.hasTag(ASSIGN) || !TreeInfo.isIdentOrThisDotIdent(((JCAssign)env.tree).lhs)) {\n-                            if (!sym.isStrictInstance()) {\n-                                return new RefBeforeCtorCalledError(sym);\n-                            } else {\n-                                localProxyVarsGen.addStrictFieldReadInPrologue(env.enclMethod, sym);\n-                                return sym;\n-                            }\n-                        }\n-                    }\n@@ -2057,2 +2047,0 @@\n-                        if (env1.info.ctorPrologue && env1 == env)\n-                            return new RefBeforeCtorCalledError(sym);\n@@ -3829,3 +3817,0 @@\n-                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n-                        \/\/ early construction context, stop search\n-                        return new RefBeforeCtorCalledError(sym);\n@@ -3891,4 +3876,0 @@\n-                    else if (env1.info.ctorPrologue &&\n-                            !isReceiverParameter(env, tree) &&\n-                            !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n-                        sym = new RefBeforeCtorCalledError(sym);\n@@ -3908,2 +3889,0 @@\n-                    if (env.info.ctorPrologue)\n-                        log.error(pos, Errors.CantRefBeforeCtorCalled(name));\n@@ -3945,95 +3924,0 @@\n-    private boolean isReceiverParameter(Env<AttrContext> env, JCFieldAccess tree) {\n-        if (env.tree.getTag() != METHODDEF)\n-            return false;\n-        JCMethodDecl method = (JCMethodDecl)env.tree;\n-        return method.recvparam != null && tree == method.recvparam.nameexpr;\n-    }\n-\n-    \/**\n-     * Determine if an early instance field reference may appear in a constructor prologue.\n-     *\n-     * <p>\n-     * This is only allowed when:\n-     *  - The field is being assigned a value (i.e., written but not read)\n-     *  - The field is not inherited from a superclass\n-     *  - The assignment is not within a lambda, because that would require\n-     *    capturing 'this' which is not allowed prior to super().\n-     *\n-     * <p>\n-     * Note, this method doesn't catch all such scenarios, because this method\n-     * is invoked for symbol \"x\" only for \"x = 42\" but not for \"this.x = 42\".\n-     * We also don't verify that the field has no initializer, which is required.\n-     * To catch those cases, we rely on similar logic in Attr.checkAssignable().\n-     *\/\n-    private boolean isAllowedEarlyReference(DiagnosticPosition pos, Env<AttrContext> env, VarSymbol v) {\n-\n-        \/\/ Check assumptions\n-        Assert.check(env.info.ctorPrologue);\n-        Assert.check((v.flags_field & STATIC) == 0);\n-\n-        \/\/ The symbol must appear in the LHS of an assignment statement\n-        if (!(env.tree instanceof JCAssign assign))\n-            return false;\n-\n-        \/\/ The assignment statement must not be within a lambda\n-        if (env.info.isLambda)\n-            return false;\n-\n-        \/\/ Get the symbol's qualifier, if any\n-        JCExpression lhs = TreeInfo.skipParens(assign.lhs);\n-        JCExpression base;\n-        switch (lhs.getTag()) {\n-        case IDENT:\n-            base = null;\n-            break;\n-        case SELECT:\n-            JCFieldAccess select = (JCFieldAccess)lhs;\n-            base = select.selected;\n-            if (!TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))\n-                return false;\n-            break;\n-        default:\n-            return false;\n-        }\n-\n-        \/\/ If an early reference, the field must not be declared in a superclass\n-        if (isEarlyReference(env, base, v) && v.owner != env.enclClass.sym)\n-            return false;\n-\n-        \/\/ The flexible constructors feature must be enabled\n-        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n-\n-        \/\/ OK\n-        return true;\n-    }\n-\n-    \/**\n-     * Determine if the variable appearance constitutes an early reference to the current class.\n-     *\n-     * <p>\n-     * This means the variable is an instance field of the current class and it appears\n-     * in an early initialization context of it (i.e., one of its constructor prologues).\n-     *\n-     * <p>\n-     * Such a reference is only allowed for assignments to non-initialized fields that are\n-     * not inherited from a superclass, though that is not enforced by this method.\n-     *\n-     * @param env    The current environment\n-     * @param base   Variable qualifier, if any, otherwise null\n-     * @param v      The variable\n-     *\/\n-    public boolean isEarlyReference(Env<AttrContext> env, JCTree base, VarSymbol v) {\n-        if (env.info.ctorPrologue &&\n-                (v.flags() & STATIC) == 0 &&\n-                v.isMemberOf(env.enclClass.sym, types)) {\n-\n-            \/\/ Allow \"Foo.this.x\" when \"Foo\" is (also) an outer class, as this refers to the outer instance\n-            if (base != null) {\n-                return TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base);\n-            }\n-\n-            \/\/ It's an early reference to an instance field member of the current instance\n-            return true;\n-        }\n-        return false;\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -1549,2 +1549,0 @@\n-            protected boolean hasValueClasses;\n-            protected boolean hasStrictFields;\n@@ -1562,1 +1560,0 @@\n-                            boolean prevHasStrictFields = hasStrictFields;\n@@ -1575,1 +1572,0 @@\n-                                hasStrictFields = prevHasStrictFields;\n@@ -1582,1 +1578,0 @@\n-                hasValueClasses = node.sym.isValueClass();\n@@ -1622,6 +1617,0 @@\n-\n-            @Override\n-            public void visitVarDef(JCVariableDecl tree) {\n-                hasStrictFields |= tree.sym.isStrict();\n-                super.visitVarDef(tree);\n-            }\n@@ -1713,7 +1702,4 @@\n-            if (scanner.hasValueClasses || scanner.hasStrictFields) {\n-                if (shouldStop(CompileState.STRICT_FIELDS_PROXIES))\n-                    return;\n-                for (JCTree def : cdefs) {\n-                    LocalProxyVarsGen.instance(context).translateTopLevelClass(def, localMake);\n-                }\n-                compileStates.put(env, CompileState.STRICT_FIELDS_PROXIES);\n+            if (shouldStop(CompileState.STRICT_FIELDS_PROXIES))\n+                return;\n+            for (JCTree def : cdefs) {\n+                LocalProxyVarsGen.instance(context).translateTopLevelClass(def, localMake);\n@@ -1721,0 +1707,1 @@\n+            compileStates.put(env, CompileState.STRICT_FIELDS_PROXIES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.tools.javac.comp.AttrContext;\n@@ -199,1 +198,2 @@\n-                return ident.name == names._this || ident.name == names._super;\n+                return ident.name == names._this && tree.type.tsym == currentClass.tsym ||\n+                       ident.name == names._super;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-InvalidThisAndSuperInConstructorArgTest.java:23:29: compiler.err.cant.ref.before.ctor.called: super\n-InvalidThisAndSuperInConstructorArgTest.java:26:28: compiler.err.cant.ref.before.ctor.called: super\n-InvalidThisAndSuperInConstructorArgTest.java:29:29: compiler.err.cant.ref.before.ctor.called: this\n-InvalidThisAndSuperInConstructorArgTest.java:32:28: compiler.err.cant.ref.before.ctor.called: this\n+InvalidThisAndSuperInConstructorArgTest.java:23:35: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:26:34: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:29:34: compiler.err.cant.ref.before.ctor.called: toString()\n+InvalidThisAndSuperInConstructorArgTest.java:32:33: compiler.err.cant.ref.before.ctor.called: toString()\n@@ -9,1 +9,1 @@\n-InvalidThisAndSuperInConstructorArgTest.java:47:38: compiler.err.cant.ref.before.ctor.called: super\n+InvalidThisAndSuperInConstructorArgTest.java:47:44: compiler.err.cant.ref.before.ctor.called: get()\n@@ -12,1 +12,1 @@\n-InvalidThisAndSuperInConstructorArgTest.java:56:39: compiler.err.cant.ref.before.ctor.called: super\n+InvalidThisAndSuperInConstructorArgTest.java:56:45: compiler.err.cant.ref.before.ctor.called: get()\n","filename":"test\/langtools\/tools\/javac\/8278078\/InvalidThisAndSuperInConstructorArgTest.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(r = () -> System.out.println(\"hello\"));\n+        r = () -> System.out.println(\"hello\");\n+        this(r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview1.java:12:14: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview1.java:13:14: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(this.r = () -> System.out.println(\"hello\"));\n+        this.r = () -> System.out.println(\"hello\");\n+        this(this.r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview2.java:12:14: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview2.java:13:18: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n-        this(EarlyAssignmentNoPreview3.this.r = () -> System.out.println(\"hello\"));\n+        EarlyAssignmentNoPreview3.this.r = () -> System.out.println(\"hello\");\n+        this(EarlyAssignmentNoPreview3.this.r);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyAssignmentNoPreview3.java:12:39: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n+EarlyAssignmentNoPreview3.java:13:44: compiler.err.feature.not.supported.in.source: (compiler.misc.feature.flexible.constructors), 24, 25\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @enablePreview\n@@ -20,3 +21,3 @@\n-            y = x;                          \/\/ FAIL - early 'this' reference\n-            y = this.x;                     \/\/ FAIL - early 'this' reference\n-            y = Inner1.this.x;              \/\/ FAIL - early 'this' reference\n+            y = x;                          \/\/ OK - \"x\" belongs to this class\n+            y = this.x;                     \/\/ OK - \"x\" belongs to this class\n+            y = Inner1.this.x;              \/\/ OK - \"x\" belongs to this class\n@@ -97,1 +98,1 @@\n-            x = x + 1;                          \/\/ FAIL - illegal early access\n+            x = x + 1;                          \/\/ OK\n@@ -103,1 +104,1 @@\n-            this.x = this.x + 1;                \/\/ FAIL - illegal early access\n+            this.x = this.x + 1;                \/\/ OK\n@@ -109,1 +110,1 @@\n-            Inner4.this.x = Inner4.this.x + 1;  \/\/ FAIL - illegal early access\n+            Inner4.this.x = Inner4.this.x + 1;  \/\/ OK\n@@ -171,0 +172,9 @@\n+\n+    public static class Inner9 {\n+        int x = 1;\n+        int y;\n+        Inner9() {\n+            y = x; \/\/ FAIL, x has an initializer\n+            super();\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,27 +1,23 @@\n-EarlyAssignments.java:20:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:21:17: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:22:23: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:30:21: compiler.err.cant.ref.before.ctor.called: super\n-EarlyAssignments.java:31:21: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:32:26: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:33:34: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:35:36: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:39:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:43:21: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:47:22: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:65:13: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:66:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:67:25: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:68:31: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:97:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:103:22: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:109:35: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:118:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:123:22: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:128:29: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:133:17: compiler.err.cant.ref.before.ctor.called: super\n-EarlyAssignments.java:138:23: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:147:13: compiler.err.cant.assign.initialized.before.ctor.called: x\n-EarlyAssignments.java:156:13: compiler.err.cant.assign.val.to.var: final, x\n-EarlyAssignments.java:167:13: compiler.err.cant.ref.before.ctor.called: this\n-26 errors\n+EarlyAssignments.java:31:26: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:32:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:33:26: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:34:34: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:36:36: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:40:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:44:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:48:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:66:13: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:67:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:68:25: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:69:31: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:119:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:124:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:129:29: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:134:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:139:28: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:148:13: compiler.err.cant.assign.initialized.before.ctor.called: x\n+EarlyAssignments.java:157:13: compiler.err.cant.assign.val.to.var: final, x\n+EarlyAssignments.java:168:13: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:168:18: compiler.err.cant.ref.before.ctor.called: EarlyAssignments.Inner8\n+EarlyAssignments.java:177:17: compiler.err.cant.ref.before.ctor.called: x\n+22 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":23,"deletions":27,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=EarlyIndirectOuterCapture.out -XDrawDiagnostics EarlyIndirectOuterCapture.java\n+ * @compile EarlyIndirectOuterCapture.java\n@@ -21,1 +21,1 @@\n-                super(\/* which enclosing instance here ? *\/new InnerSuperclass() { });\n+                super(new InnerSuperclass() { }); \/\/ should this be accepted?, InnerSuperclass is not an inner class of InnerInnerOuter\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-EarlyIndirectOuterCapture.java:21:60: compiler.err.cant.ref.before.ctor.called: this\n-1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-EarlyLocalClass.java:11:32: compiler.err.cant.ref.before.ctor.called: this\n+EarlyLocalClass.java:11:37: compiler.err.cant.ref.before.ctor.called: hashCode()\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalClass.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @enablePreview\n@@ -154,1 +155,1 @@\n-        super((Runnable)() -> x);       \/\/ this should FAIL\n+        super((Runnable)() -> System.err.println(x));       \/\/ this should FAIL\n@@ -189,0 +190,11 @@\n+    public int xx;\n+\n+    SuperInitFails(short[][] ignore) {\n+        int i = new SuperInitFails(){\n+            void foo() {\n+                System.err.println(xx);  \/\/ this should fail\n+            }\n+        }.xx;  \/\/ this one is OK though\n+        super(null);\n+    }\n+\n@@ -211,0 +223,23 @@\n+\n+    static class Inner5 {\n+        int x = 4;\n+        static String m1(Runnable r) { return null; }\n+        static String m2(Object r) { return null; }\n+        Inner5() {\n+            m1(() -> System.out.println(x)).toString();\n+            m2(x).toString();\n+            super();\n+        }\n+    }\n+\n+    static class Inner6 {\n+        Inner6() {\n+            class Bar {\n+                Bar() {\n+                    Object o = Bar.this;\n+                    super();\n+                }\n+            }\n+            super();\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1,33 +1,37 @@\n-SuperInitFails.java:56:9: compiler.err.cant.ref.before.ctor.called: hashCode()\n-SuperInitFails.java:61:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:66:9: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:71:23: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:76:23: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:93:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:98:33: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:103:14: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:107:20: compiler.err.not.encl.class: java.lang.Object\n-SuperInitFails.java:111:17: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:118:22: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:124:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:132:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record1\n-SuperInitFails.java:137:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record2\n-SuperInitFails.java:154:31: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:158:15: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:167:13: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:171:17: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:175:24: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:179:18: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:194:25: compiler.err.return.before.superclass.initialized\n-SuperInitFails.java:199:33: compiler.err.ctor.calls.not.allowed.here\n-SuperInitFails.java:204:29: compiler.err.redundant.superclass.init\n-SuperInitFails.java:32:13: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:36:14: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:40:14: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:44:13: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:48:33: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:52:32: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:82:18: compiler.err.ctor.calls.not.allowed.here\n-SuperInitFails.java:88:13: compiler.err.return.before.superclass.initialized\n-SuperInitFails.java:149:18: compiler.err.call.must.only.appear.in.ctor\n-32 errors\n+SuperInitFails.java:57:9: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:62:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:67:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:72:28: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:77:29: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:99:33: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:104:14: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:108:20: compiler.err.not.encl.class: java.lang.Object\n+SuperInitFails.java:112:23: compiler.err.cant.ref.before.ctor.called: spliterator()\n+SuperInitFails.java:119:22: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:125:9: compiler.err.cant.ref.before.ctor.called: SuperInitFails\n+SuperInitFails.java:133:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record1\n+SuperInitFails.java:138:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record2\n+SuperInitFails.java:155:50: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:159:15: compiler.err.cant.ref.before.ctor.called: SuperInitFails\n+SuperInitFails.java:168:13: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:172:17: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:176:24: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:180:18: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:186:32: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:195:36: compiler.err.cant.ref.before.ctor.called: xx\n+SuperInitFails.java:206:25: compiler.err.return.before.superclass.initialized\n+SuperInitFails.java:211:33: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:216:29: compiler.err.redundant.superclass.init\n+SuperInitFails.java:229:41: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:230:16: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:239:35: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:33:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:37:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:41:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:45:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:49:33: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:53:32: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:83:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:89:13: compiler.err.return.before.superclass.initialized\n+SuperInitFails.java:150:18: compiler.err.call.must.only.appear.in.ctor\n+36 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,4 +2,4 @@\n-ValueClassSuperInitFails.java:72:9: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:77:9: compiler.err.cant.ref.before.ctor.called: super\n-ValueClassSuperInitFails.java:82:33: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:87:33: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:72:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:77:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:82:38: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:87:39: compiler.err.cant.ref.before.ctor.called: hashCode()\n@@ -9,1 +9,1 @@\n-ValueClassSuperInitFails.java:122:17: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:122:23: compiler.err.cant.ref.before.ctor.called: spliterator()\n@@ -11,1 +11,1 @@\n-ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:135:9: compiler.err.cant.ref.before.ctor.called: ValueClassSuperInitFails\n@@ -14,2 +14,3 @@\n-ValueClassSuperInitFails.java:161:41: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: this\n+ValueClassSuperInitFails.java:161:46: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:175:49: compiler.err.cant.ref.before.ctor.called: x\n+ValueClassSuperInitFails.java:179:15: compiler.err.cant.ref.before.ctor.called: ValueClassSuperInitFails\n@@ -27,1 +28,1 @@\n-24 errors\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CantReferenceBeforeConstructorTest.java:30:13: compiler.err.cant.ref.before.ctor.called: this\n+CantReferenceBeforeConstructorTest.java:30:17: compiler.err.cant.ref.before.ctor.called: CantReferenceBeforeConstructorTest.BB.CC()\n","filename":"test\/langtools\/tools\/javac\/cantReferenceBeforeCtor\/CantReferenceBeforeConstructorTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    int i;\n@@ -31,2 +32,0 @@\n-    int i;\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefBeforeConstr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-NewBeforeOuterConstructed.java:27:21: compiler.err.cant.ref.before.ctor.called: this\n+NewBeforeOuterConstructed.java:27:21: compiler.err.cant.ref.before.ctor.called: NewBeforeOuterConstructed\n","filename":"test\/langtools\/tools\/javac\/implicitThis\/NewBeforeOuterConstructed.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-NewBeforeOuterConstructed2.java:20:35: compiler.err.cant.ref.before.ctor.called: this\n+NewBeforeOuterConstructed2.java:20:35: compiler.err.cant.ref.before.ctor.called: NewBeforeOuterConstructed2\n","filename":"test\/langtools\/tools\/javac\/implicitThis\/NewBeforeOuterConstructed2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-MethodReferenceNoThisTest.java:22:15: compiler.err.cant.ref.before.ctor.called: this\n+MethodReferenceNoThisTest.java:22:15: compiler.err.cant.ref.before.ctor.called: MethodReferenceNoThisTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReferenceNoThisTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-MethodReferenceInConstructorInvocation.java:24:30: compiler.err.cant.ref.before.ctor.called: super\n+MethodReferenceInConstructorInvocation.java:24:36: compiler.err.cant.ref.before.ctor.called: getString()\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodReferenceInConstructorInvocation.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-        assertOK(\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -926,1 +926,1 @@\n-                    Runnable r = () -> { System.err.println(t); }; \/\/ compiler will generate a local proxy for `t`\n+                    Runnable r = () -> { System.err.println(t); }; \/\/ cant reference `t` from a lambda expression in the prologue\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}