{"files":[{"patch":"@@ -313,0 +313,10 @@\n+#ifdef R18_RESERVED\n+  \/*\n+  Do not modify r18_tls when restoring registers if it is a reserved register. On Windows,\n+  for example, r18_tls is used to store the pointer to the current thread's TEB (where TLS\n+  variables are stored). Therefore, modifying r18_tls would corrupt the TEB pointer.\n+  *\/\n+  __ pop(RegSet::range(r0, r17), sp);\n+  __ ldp(zr, r19, Address(__ post(sp, 2 * wordSize)));\n+  __ pop(RegSet::range(r20, r29), sp);\n+#else\n@@ -314,0 +324,1 @@\n+#endif\n@@ -326,0 +337,11 @@\n+#ifdef R18_RESERVED\n+  \/*\n+  Do not modify r18_tls when restoring registers if it is a reserved register. On Windows,\n+  for example, r18_tls is used to store the pointer to the current thread's TEB (where TLS\n+  variables are stored). Therefore, modifying r18_tls would corrupt the TEB pointer.\n+  *\/\n+  __ ldp(zr, r1, Address(__ post(sp, 2 * wordSize)));\n+  __ pop(RegSet::range(r2, r17), sp);\n+  __ ldp(zr, r19, Address(__ post(sp, 2 * wordSize)));\n+  __ pop(RegSet::range(r20, r29), sp);\n+#else\n@@ -328,0 +350,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1062,2 +1062,2 @@\n-  int imm8 = (opc == Op_MinV || opc == Op_MinReductionV) ? AVX10_MINMAX_MIN_COMPARE_SIGN\n-                                                         : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+  int imm8 = (opc == Op_MinV || opc == Op_MinReductionV) ? AVX10_2_MINMAX_MIN_COMPARE_SIGN\n+                                                         : AVX10_2_MINMAX_MAX_COMPARE_SIGN;\n@@ -5192,1 +5192,1 @@\n-void C2_MacroAssembler::vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+void C2_MacroAssembler::vector_castF2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n@@ -5212,1 +5212,1 @@\n-void C2_MacroAssembler::vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+void C2_MacroAssembler::vector_castF2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n@@ -5232,1 +5232,1 @@\n-void C2_MacroAssembler::vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+void C2_MacroAssembler::vector_castD2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n@@ -5252,1 +5252,1 @@\n-void C2_MacroAssembler::vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+void C2_MacroAssembler::vector_castD2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-  void vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+  void vector_castF2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n@@ -353,1 +353,1 @@\n-  void vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n+  void vector_castF2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n@@ -355,1 +355,1 @@\n-  void vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+  void vector_castD2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n@@ -357,1 +357,1 @@\n-  void vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n+  void vector_castD2X_avx10_2(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -9639,1 +9639,1 @@\n-      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_2_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -9641,1 +9641,1 @@\n-      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_2_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -9658,1 +9658,1 @@\n-      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_2_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n@@ -9660,1 +9660,1 @@\n-      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_2_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n@@ -9677,1 +9677,1 @@\n-      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_2_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -9679,1 +9679,1 @@\n-      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_2_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -9696,1 +9696,1 @@\n-      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_2_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n@@ -9698,1 +9698,1 @@\n-      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_2_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7352,1 +7352,1 @@\n-instruct maxF_avx10_reg(regF dst, regF a, regF b) %{\n+instruct maxF_reg_avx10_2(regF dst, regF a, regF b) %{\n@@ -7357,1 +7357,1 @@\n-    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_2_MINMAX_MAX_COMPARE_SIGN);\n@@ -7388,1 +7388,1 @@\n-instruct maxD_avx10_reg(regD dst, regD a, regD b) %{\n+instruct maxD_reg_avx10_2(regD dst, regD a, regD b) %{\n@@ -7393,1 +7393,1 @@\n-    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_2_MINMAX_MAX_COMPARE_SIGN);\n@@ -7424,1 +7424,1 @@\n-instruct minF_avx10_reg(regF dst, regF a, regF b) %{\n+instruct minF_reg_avx10_2(regF dst, regF a, regF b) %{\n@@ -7429,1 +7429,1 @@\n-    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_2_MINMAX_MIN_COMPARE_SIGN);\n@@ -7460,1 +7460,1 @@\n-instruct minD_avx10_reg(regD dst, regD a, regD b) %{\n+instruct minD_reg_avx10_2(regD dst, regD a, regD b) %{\n@@ -7465,1 +7465,1 @@\n-    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_2_MINMAX_MIN_COMPARE_SIGN);\n@@ -14675,1 +14675,1 @@\n-instruct convF2I_reg_reg_avx10(rRegI dst, regF src)\n+instruct convF2I_reg_reg_avx10_2(rRegI dst, regF src)\n@@ -14686,1 +14686,1 @@\n-instruct convF2I_reg_mem_avx10(rRegI dst, memory src)\n+instruct convF2I_reg_mem_avx10_2(rRegI dst, memory src)\n@@ -14709,1 +14709,1 @@\n-instruct convF2L_reg_reg_avx10(rRegL dst, regF src)\n+instruct convF2L_reg_reg_avx10_2(rRegL dst, regF src)\n@@ -14720,1 +14720,1 @@\n-instruct convF2L_reg_mem_avx10(rRegL dst, memory src)\n+instruct convF2L_reg_mem_avx10_2(rRegL dst, memory src)\n@@ -14743,1 +14743,1 @@\n-instruct convD2I_reg_reg_avx10(rRegI dst, regD src)\n+instruct convD2I_reg_reg_avx10_2(rRegI dst, regD src)\n@@ -14754,1 +14754,1 @@\n-instruct convD2I_reg_mem_avx10(rRegI dst, memory src)\n+instruct convD2I_reg_mem_avx10_2(rRegI dst, memory src)\n@@ -14777,1 +14777,1 @@\n-instruct convD2L_reg_reg_avx10(rRegL dst, regD src)\n+instruct convD2L_reg_reg_avx10_2(rRegL dst, regD src)\n@@ -14788,1 +14788,1 @@\n-instruct convD2L_reg_mem_avx10(rRegL dst, memory src)\n+instruct convD2L_reg_mem_avx10_2(rRegL dst, memory src)\n@@ -19979,1 +19979,1 @@\n-instruct minmax_reduction2F_avx10(regF dst, immF src1, vec src2, vec xtmp1) %{\n+instruct minmax_reduction2F_avx10_2(regF dst, immF src1, vec src2, vec xtmp1) %{\n@@ -19997,1 +19997,1 @@\n-instruct minmax_reductionF_avx10(regF dst, immF src1, vec src2, vec xtmp1, vec xtmp2) %{\n+instruct minmax_reductionF_avx10_2(regF dst, immF src1, vec src2, vec xtmp1, vec xtmp2) %{\n@@ -20015,1 +20015,1 @@\n-instruct minmax_reduction2F_avx10_av(regF dst, vec src, vec xtmp1) %{\n+instruct minmax_reduction2F_av_avx10_2(regF dst, vec src, vec xtmp1) %{\n@@ -20031,1 +20031,1 @@\n-instruct minmax_reductionF_avx10_av(regF dst, vec src, vec xtmp1, vec xtmp2) %{\n+instruct minmax_reductionF_av_avx10_2(regF dst, vec src, vec xtmp1, vec xtmp2) %{\n@@ -20129,1 +20129,1 @@\n-instruct minmax_reduction2D_avx10(regD dst, immD src1, vec src2, vec xtmp1) %{\n+instruct minmax_reduction2D_avx10_2(regD dst, immD src1, vec src2, vec xtmp1) %{\n@@ -20147,1 +20147,1 @@\n-instruct minmax_reductionD_avx10(regD dst, immD src1, vec src2, vec xtmp1, vec xtmp2) %{\n+instruct minmax_reductionD_avx10_2(regD dst, immD src1, vec src2, vec xtmp1, vec xtmp2) %{\n@@ -20166,1 +20166,1 @@\n-instruct minmax_reduction2D_av_avx10(regD dst, vec src, vec xtmp1) %{\n+instruct minmax_reduction2D_av_avx10_2(regD dst, vec src, vec xtmp1) %{\n@@ -20182,1 +20182,1 @@\n-instruct minmax_reductionD_av_avx10(regD dst, vec src, vec xtmp1, vec xtmp2) %{\n+instruct minmax_reductionD_av_avx10_2(regD dst, vec src, vec xtmp1, vec xtmp2) %{\n@@ -21085,1 +21085,1 @@\n-instruct minmaxFP_avx10_reg(vec dst, vec a, vec b) %{\n+instruct minmaxFP_reg_avx10_2(vec dst, vec a, vec b) %{\n@@ -22432,1 +22432,1 @@\n-instruct castFtoX_reg_avx10(vec dst, vec src) %{\n+instruct castFtoX_reg_avx10_2(vec dst, vec src) %{\n@@ -22436,1 +22436,1 @@\n-  format %{ \"vector_cast_f2x_avx10 $dst, $src\\t!\" %}\n+  format %{ \"vector_cast_f2x_avx10_2 $dst, $src\\t!\" %}\n@@ -22440,1 +22440,1 @@\n-    __ vector_castF2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_castF2X_avx10_2(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n@@ -22445,1 +22445,1 @@\n-instruct castFtoX_mem_avx10(vec dst, memory src) %{\n+instruct castFtoX_mem_avx10_2(vec dst, memory src) %{\n@@ -22449,1 +22449,1 @@\n-  format %{ \"vector_cast_f2x_avx10 $dst, $src\\t!\" %}\n+  format %{ \"vector_cast_f2x_avx10_2 $dst, $src\\t!\" %}\n@@ -22454,1 +22454,1 @@\n-    __ vector_castF2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+    __ vector_castF2X_avx10_2(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n@@ -22506,1 +22506,1 @@\n-instruct castDtoX_reg_avx10(vec dst, vec src) %{\n+instruct castDtoX_reg_avx10_2(vec dst, vec src) %{\n@@ -22510,1 +22510,1 @@\n-  format %{ \"vector_cast_d2x_avx10 $dst, $src\\t!\" %}\n+  format %{ \"vector_cast_d2x_avx10_2 $dst, $src\\t!\" %}\n@@ -22514,1 +22514,1 @@\n-    __ vector_castD2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_castD2X_avx10_2(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n@@ -22519,1 +22519,1 @@\n-instruct castDtoX_mem_avx10(vec dst, memory src) %{\n+instruct castDtoX_mem_avx10_2(vec dst, memory src) %{\n@@ -22523,1 +22523,1 @@\n-  format %{ \"vector_cast_d2x_avx10 $dst, $src\\t!\" %}\n+  format %{ \"vector_cast_d2x_avx10_2 $dst, $src\\t!\" %}\n@@ -22528,1 +22528,1 @@\n-    __ vector_castD2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+    __ vector_castD2X_avx10_2(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n@@ -25500,1 +25500,1 @@\n-instruct scalar_minmax_HF_avx10_reg(regF dst, regF src1, regF src2)\n+instruct scalar_minmax_HF_reg_avx10_2(regF dst, regF src1, regF src2)\n@@ -25507,1 +25507,1 @@\n-    int function = this->ideal_Opcode() == Op_MinHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    int function = this->ideal_Opcode() == Op_MinHF ? AVX10_2_MINMAX_MIN_COMPARE_SIGN : AVX10_2_MINMAX_MAX_COMPARE_SIGN;\n@@ -25615,1 +25615,1 @@\n-instruct vector_minmax_HF_avx10_mem(vec dst, vec src1, memory src2)\n+instruct vector_minmax_HF_mem_avx10_2(vec dst, vec src1, memory src2)\n@@ -25623,1 +25623,1 @@\n-    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_2_MINMAX_MIN_COMPARE_SIGN : AVX10_2_MINMAX_MAX_COMPARE_SIGN;\n@@ -25629,1 +25629,1 @@\n-instruct vector_minmax_HF_avx10_reg(vec dst, vec src1, vec src2)\n+instruct vector_minmax_HF_reg_avx10_2(vec dst, vec src1, vec src2)\n@@ -25637,1 +25637,1 @@\n-    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_2_MINMAX_MIN_COMPARE_SIGN : AVX10_2_MINMAX_MAX_COMPARE_SIGN;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1160,1 +1160,1 @@\n-    if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    if (CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -2224,1 +2224,1 @@\n-    if (HeapShared::is_loading_mapping_mode()) {\n+    if (HeapShared::is_loading() && HeapShared::is_loading_mapping_mode()) {\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1050,4 +1050,0 @@\n-bool CDSConfig::is_initing_classes_at_dump_time() {\n-  return is_dumping_heap() && is_dumping_aot_linked_classes();\n-}\n-\n@@ -1060,2 +1056,2 @@\n-\/\/ When we are dumping aot-linked classes and we are able to write archived heap objects, we automatically\n-\/\/ enable the archiving of MethodHandles. This will in turn enable the archiving of MethodTypes and hidden\n+\/\/ When we are dumping aot-linked classes, we automatically enable the archiving of MethodHandles.\n+\/\/ This will in turn enable the archiving of MethodTypes and hidden\n@@ -1066,1 +1062,1 @@\n-  return is_initing_classes_at_dump_time();\n+  return is_dumping_aot_linked_classes();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -198,1 +198,0 @@\n-  static bool is_initing_classes_at_dump_time()              NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\/\/ !!! CDSConfig::is_initing_classes_at_dump_time()==true.\n+\/\/ !!! CDSConfig::is_dumping_aot_linked_classes()==true.\n@@ -66,1 +66,1 @@\n-  assert(!CDSConfig::is_initing_classes_at_dump_time(), \"only for legacy support of enums\");\n+  assert(!CDSConfig::is_dumping_aot_linked_classes(), \"only for legacy support of enums\");\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,2 +212,8 @@\n-  return is_subgraph_root_class_of(archive_subgraph_entry_fields, ik) ||\n-         is_subgraph_root_class_of(fmg_archive_subgraph_entry_fields, ik);\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ Legacy CDS archive support (to be deprecated)\n+    return is_subgraph_root_class_of(archive_subgraph_entry_fields, ik) ||\n+           is_subgraph_root_class_of(fmg_archive_subgraph_entry_fields, ik);\n+  } else {\n+    return false;\n+  }\n@@ -938,2 +944,8 @@\n-  archive_object_subgraphs(archive_subgraph_entry_fields,\n-                           false \/* is_full_module_graph *\/);\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    archive_object_subgraphs(archive_subgraph_entry_fields,\n+                             false \/* is_full_module_graph *\/);\n+    if (CDSConfig::is_dumping_full_module_graph()) {\n+      archive_object_subgraphs(fmg_archive_subgraph_entry_fields,\n+                               true \/* is_full_module_graph *\/);\n+    }\n+  }\n@@ -942,2 +954,0 @@\n-    archive_object_subgraphs(fmg_archive_subgraph_entry_fields,\n-                             true \/* is_full_module_graph *\/);\n@@ -1299,2 +1309,4 @@\n-  resolve_classes_for_subgraphs(current, archive_subgraph_entry_fields);\n-  resolve_classes_for_subgraphs(current, fmg_archive_subgraph_entry_fields);\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    resolve_classes_for_subgraphs(current, archive_subgraph_entry_fields);\n+    resolve_classes_for_subgraphs(current, fmg_archive_subgraph_entry_fields);\n+  }\n@@ -1742,1 +1754,1 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -1748,1 +1760,1 @@\n-    \/\/ Without CDSConfig::is_initing_classes_at_dump_time(), we only allow archived objects to\n+    \/\/ Without CDSConfig::is_dumping_aot_linked_classes(), we only allow archived objects to\n@@ -1816,3 +1828,3 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n-    \/\/ The classes of all archived enum instances have been marked as aot-init,\n-    \/\/ so there's nothing else to be done in the production run.\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ The enum klasses are archived with aot-initialized mirror.\n+    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n@@ -1957,1 +1969,1 @@\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n@@ -2144,3 +2156,5 @@\n-  init_subgraph_entry_fields(archive_subgraph_entry_fields, CHECK);\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    init_subgraph_entry_fields(fmg_archive_subgraph_entry_fields, CHECK);\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    init_subgraph_entry_fields(archive_subgraph_entry_fields, CHECK);\n+    if (CDSConfig::is_dumping_full_module_graph()) {\n+      init_subgraph_entry_fields(fmg_archive_subgraph_entry_fields, CHECK);\n+    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1989,1 +1989,1 @@\n-                                           const char* message) {\n+                                           const stringStream& message) {\n@@ -1998,1 +1998,1 @@\n-      ResolutionErrorTable::add_entry(pool, which, message);\n+      ResolutionErrorTable::add_entry(pool, which, message.as_string(true \/* on C-heap *\/));\n@@ -2003,3 +2003,8 @@\n-      \/\/ the message, and set it again.\n-      assert(entry->nest_host_error() == nullptr || strcmp(entry->nest_host_error(), message) == 0, \"should be the same message\");\n-      entry->set_nest_host_error(message);\n+      \/\/ the message.\n+      const char* nhe = entry->nest_host_error();\n+      if (nhe == nullptr) {\n+        entry->set_nest_host_error(message.as_string(true \/* on C-heap *\/));\n+      } else {\n+        DEBUG_ONLY(const char* msg = message.base();)\n+        assert(strcmp(nhe, msg) == 0, \"New message %s, differs from original %s\", msg, nhe);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                                  const char* message);\n+                                  const stringStream& message);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,0 +218,3 @@\n+  \/* Scoped Values *\/                                                                                           \\\n+  do_klass(ScopedValue_Carrier_klass,                   java_lang_ScopedValue_Carrier                         ) \\\n+                                                                                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -302,2 +302,1 @@\n-        klass->is_refArray_klass() &&\n-        PSChunkLargeArrays) {\n+        klass->is_refArray_klass()) {\n@@ -347,1 +346,0 @@\n-    assert(PSChunkLargeArrays, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -336,2 +336,1 @@\n-      const char* msg = ss.as_string(true \/* on C-heap *\/);\n-      SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);\n+      SystemDictionary::add_nest_host_error(cph, _nest_host_index, ss);\n@@ -341,1 +340,1 @@\n-      log_trace(class, nestmates)(\"%s\", msg);\n+      log_trace(class, nestmates)(\"%s\", ss.base());\n@@ -380,3 +379,2 @@\n-        const char* msg = ss.as_string(true \/* on C-heap *\/);\n-        SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);\n-        log_trace(class, nestmates)(\"%s\", msg);\n+        SystemDictionary::add_nest_host_error(cph, _nest_host_index, ss);\n+        log_trace(class, nestmates)(\"%s\", ss.base());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"opto\/utilities\/xor.hpp\"\n@@ -1026,29 +1026,2 @@\n-const Type *OrINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ If both args are bool, can figure out better types\n-  if ( r0 == TypeInt::BOOL ) {\n-    if ( r1 == TypeInt::ONE) {\n-      return TypeInt::ONE;\n-    } else if ( r1 == TypeInt::BOOL ) {\n-      return TypeInt::BOOL;\n-    }\n-  } else if ( r0 == TypeInt::ONE ) {\n-    if ( r1 == TypeInt::BOOL ) {\n-      return TypeInt::ONE;\n-    }\n-  }\n-\n-  \/\/ If either input is all ones, the output is all ones.\n-  \/\/ x | ~0 == ~0 <==> x | -1 == -1\n-  if (r0 == TypeInt::MINUS_1 || r1 == TypeInt::MINUS_1) {\n-    return TypeInt::MINUS_1;\n-  }\n-\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeInt::INT;        \/\/ Any integer, but still no symbols.\n-\n-  \/\/ Otherwise just OR them bits.\n-  return TypeInt::make( r0->get_con() | r1->get_con() );\n+const Type* OrINode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_or(t1->is_int(), t2->is_int());\n@@ -1102,16 +1075,2 @@\n-const Type *OrLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  \/\/ If either input is all ones, the output is all ones.\n-  \/\/ x | ~0 == ~0 <==> x | -1 == -1\n-  if (r0 == TypeLong::MINUS_1 || r1 == TypeLong::MINUS_1) {\n-    return TypeLong::MINUS_1;\n-  }\n-\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ Any integer, but still no symbols.\n-\n-  \/\/ Otherwise just OR them bits.\n-  return TypeLong::make( r0->get_con() | r1->get_con() );\n+const Type* OrLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_or(t1->is_long(), t2->is_long());\n@@ -1204,18 +1163,2 @@\n-const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  if (r0->is_con() && r1->is_con()) {\n-    \/\/ compute constant result\n-    return TypeInt::make(r0->get_con() ^ r1->get_con());\n-  }\n-\n-  \/\/ At least one of the arguments is not constant\n-\n-  if (r0->_lo >= 0 && r1->_lo >= 0) {\n-      \/\/ Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n-      jint upper_bound = xor_upper_bound_for_ranges<jint, juint>(r0->_hi, r1->_hi);\n-      return TypeInt::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n-  }\n-\n-  return TypeInt::INT;\n+const Type* XorINode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_xor(t1->is_int(), t2->is_int());\n@@ -1226,18 +1169,2 @@\n-const Type *XorLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  if (r0->is_con() && r1->is_con()) {\n-    \/\/ compute constant result\n-    return TypeLong::make(r0->get_con() ^ r1->get_con());\n-  }\n-\n-  \/\/ At least one of the arguments is not constant\n-\n-  if (r0->_lo >= 0 && r1->_lo >= 0) {\n-      \/\/ Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n-      julong upper_bound = xor_upper_bound_for_ranges<jlong, julong>(r0->_hi, r1->_hi);\n-      return TypeLong::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n-  }\n-\n-  return TypeLong::LONG;\n+const Type* XorLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_xor(t1->is_long(), t2->is_long());\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":9,"deletions":82,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -700,1 +700,2 @@\n-          \"Verify Iterative Global Value Numbering =DCBA, with:\"            \\\n+          \"Verify Iterative Global Value Numbering =EDCBA, with:\"           \\\n+          \"  E: verify node specific invariants\"                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -979,3 +979,2 @@\n-  CallLeafPureNode(const TypeFunc* tf, address addr, const char* name,\n-                   const TypePtr* adr_type)\n-      : CallLeafNode(tf, addr, name, adr_type) {\n+  CallLeafPureNode(const TypeFunc* tf, address addr, const char* name)\n+      : CallLeafNode(tf, addr, name, nullptr) {\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -334,2 +334,1 @@\n-\n-bool CastLLNode::is_inner_loop_backedge(ProjNode* proj) {\n+bool CastLLNode::is_inner_loop_backedge(IfProjNode* proj) {\n@@ -354,2 +353,2 @@\n-          ProjNode* true_proj = iff->as_If()->proj_out_or_null(true);\n-          ProjNode* false_proj = iff->as_If()->proj_out_or_null(false);\n+          IfTrueNode* true_proj = iff->as_If()->true_proj_or_null();\n+          IfFalseNode* false_proj = iff->as_If()->false_proj_or_null();\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-  static bool is_inner_loop_backedge(ProjNode* proj);\n+  static bool is_inner_loop_backedge(IfProjNode* proj);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -938,2 +938,2 @@\n-  ProjNode* proj1 = region->in(idx1)->isa_Proj();\n-  ProjNode* proj2 = region->in(idx2)->isa_Proj();\n+  IfProjNode* proj1 = region->in(idx1)->isa_IfProj();\n+  IfProjNode* proj2 = region->in(idx2)->isa_IfProj();\n@@ -1365,0 +1365,19 @@\n+  \/\/ In rare cases, during an IGVN call to `PhiNode::Value`, `_type` and `t` have incompatible opinion on speculative type,\n+  \/\/ resulting into a too small intersection (such as AnyNull), which is removed in cleanup_speculative.\n+  \/\/ From that `ft` has no speculative type (ft->speculative() == nullptr).\n+  \/\/ After the end of the current `PhiNode::Value` call, `ft` (that is returned) is being store into `_type`\n+  \/\/ (see PhaseIterGVN::transform_old -> raise_bottom_type -> set_type).\n+  \/\/\n+  \/\/ It is possible that verification happens immediately after, without any change to the current node, or any of its inputs.\n+  \/\/ In the verification invocation of `PhiNode::Value`, `t` would be the same as the IGVN `t` (union of input types, that are unchanged),\n+  \/\/ but the new `_type` is the value returned by the IGVN invocation of `PhiNode::Value`, the former `ft`, that has no speculative type.\n+  \/\/ Thus, the result of `t->filter_speculative(_type)`, the new `ft`, gets the speculative type of `t`, which is not empty. Since the\n+  \/\/ result of the verification invocation of `PhiNode::Value` has some speculative type, it is not the same as the previously returned type\n+  \/\/ (that had no speculative type), making verification fail.\n+  \/\/\n+  \/\/ In such a case, doing the filtering one time more allows to reach a fixpoint.\n+  if (ft->speculative() == nullptr && t->speculative() != nullptr) {\n+    ft = t->filter_speculative(ft);\n+  }\n+  verify_type_stability(phase, t, ft);\n+\n@@ -1370,0 +1389,45 @@\n+#ifdef ASSERT\n+\/\/ Makes sure that a newly computed type is stable when filtered against the incoming types.\n+\/\/ Otherwise, we may have IGVN verification failures. See PhiNode::Value, and the second\n+\/\/ filtering (enforcing stability), for details.\n+void PhiNode::verify_type_stability(const PhaseGVN* const phase, const Type* const union_of_input_types, const Type* const new_type) const {\n+  const Type* doubly_filtered_type = union_of_input_types->filter_speculative(new_type);\n+  if (Type::equals(new_type, doubly_filtered_type)) {\n+    return;\n+  }\n+\n+  stringStream ss;\n+\n+  ss.print_cr(\"At node:\");\n+  this->dump(\"\\n\", false, &ss);\n+\n+  const Node* region = in(Region);\n+  for (uint i = 1; i < req(); ++i) {\n+    ss.print(\"in(%d): \", i);\n+    if (region->in(i) != nullptr && phase->type(region->in(i)) == Type::CONTROL) {\n+      const Type* ti = phase->type(in(i));\n+      ti->dump_on(&ss);\n+    }\n+    ss.print_cr(\"\");\n+  }\n+\n+  ss.print(\"t: \");\n+  union_of_input_types->dump_on(&ss);\n+  ss.print_cr(\"\");\n+\n+  ss.print(\"_type: \");\n+  _type->dump_on(&ss);\n+  ss.print_cr(\"\");\n+\n+  ss.print(\"Filter once: \");\n+  new_type->dump_on(&ss);\n+  ss.print_cr(\"\");\n+  ss.print(\"Filter twice: \");\n+  doubly_filtered_type->dump_on(&ss);\n+  ss.print_cr(\"\");\n+  tty->print(\"%s\", ss.base());\n+  tty->flush();\n+  assert(false, \"computed type would not pass verification\");\n+}\n+#endif\n+\n@@ -2203,0 +2267,14 @@\n+\/\/ Is one of the inputs a Cast that has not been processed by igvn yet?\n+bool PhiNode::wait_for_cast_input_igvn(const PhaseIterGVN* igvn) const {\n+  for (uint i = 1, cnt = req(); i < cnt; ++i) {\n+    Node* n = in(i);\n+    while (n != nullptr && n->is_ConstraintCast()) {\n+      if (igvn->_worklist.member(n)) {\n+        return true;\n+      }\n+      n = n->in(1);\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -2261,0 +2339,22 @@\n+    \/\/ If one of the inputs is a cast that has yet to be processed by igvn, delay processing of this node to give the\n+    \/\/ inputs a chance to optimize and possibly end up with identical inputs (casts included).\n+    \/\/ Say we have:\n+    \/\/ (Phi region (Cast#1 c uin) (Cast#2 c uin))\n+    \/\/ and Cast#1 and Cast#2 have not had a chance to common yet\n+    \/\/ if the unique_input() transformation below proceeds, then PhiNode::Ideal returns:\n+    \/\/ (Cast#3 region uin) (1)\n+    \/\/ If PhiNode::Ideal is delayed until Cast#1 and Cast#2 common, then it returns:\n+    \/\/ (Cast#1 c uin) (2)\n+    \/\/\n+    \/\/ In (1) the resulting cast is conservatively pinned at a later control and while Cast#3 and Cast#1\/Cast#2 still\n+    \/\/ have a chance to common, that requires proving that c dominates region in ConstraintCastNode::dominating_cast()\n+    \/\/ which may not happen if control flow is too complicated and another pass of loop opts doesn't run. Delaying the\n+    \/\/ transformation here should allow a more optimal result.\n+    \/\/ Beyond the efficiency concern, there is a risk, if the casts are CastPPs, to end up with a chain of AddPs with\n+    \/\/ different base inputs (but a unique uncasted base input). This breaks an invariant in the shape of address\n+    \/\/ subtrees.\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    if (wait_for_cast_input_igvn(igvn)) {\n+      igvn->_worklist.push(this);\n+      return nullptr;\n+    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":102,"deletions":2,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -189,0 +189,3 @@\n+  void verify_type_stability(const PhaseGVN* phase, const Type* union_of_input_types, const Type* new_type) const NOT_DEBUG_RETURN;\n+  bool wait_for_cast_input_igvn(const PhaseIterGVN* igvn) const;\n+\n@@ -354,3 +357,3 @@\n-  bool has_shared_region(ProjNode* proj, ProjNode*& success, ProjNode*& fail);\n-  bool has_only_uncommon_traps(ProjNode* proj, ProjNode*& success, ProjNode*& fail, PhaseIterGVN* igvn);\n-  Node* merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n+  bool has_shared_region(IfProjNode* proj, IfProjNode*& success, IfProjNode*& fail) const;\n+  bool has_only_uncommon_traps(IfProjNode* proj, IfProjNode*& success, IfProjNode*& fail, PhaseIterGVN* igvn) const;\n+  Node* merge_uncommon_traps(IfProjNode* proj, IfProjNode* success, IfProjNode* fail, PhaseIterGVN* igvn);\n@@ -358,5 +361,5 @@\n-  bool is_cmp_with_loadrange(ProjNode* proj);\n-  bool is_null_check(ProjNode* proj, PhaseIterGVN* igvn);\n-  bool is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn);\n-  void reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn);\n-  bool fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);\n+  bool is_cmp_with_loadrange(IfProjNode* proj) const;\n+  bool is_null_check(IfProjNode* proj, PhaseIterGVN* igvn) const;\n+  bool is_side_effect_free_test(IfProjNode* proj, PhaseIterGVN* igvn) const;\n+  static void reroute_side_effect_free_unc(IfProjNode* proj, IfProjNode* dom_proj, PhaseIterGVN* igvn);\n+  bool fold_compares_helper(IfProjNode* proj, IfProjNode* success, IfProjNode* fail, PhaseIterGVN* igvn);\n@@ -366,1 +369,1 @@\n-  ProjNode* range_check_trap_proj(int& flip, Node*& l, Node*& r);\n+  IfProjNode* range_check_trap_proj(int& flip, Node*& l, Node*& r) const;\n@@ -445,0 +448,18 @@\n+  IfTrueNode* true_proj() const {\n+    return proj_out(true)->as_IfTrue();\n+  }\n+\n+  IfTrueNode* true_proj_or_null() const {\n+    ProjNode* true_proj = proj_out_or_null(true);\n+    return true_proj == nullptr ? nullptr : true_proj->as_IfTrue();\n+  }\n+\n+  IfFalseNode* false_proj() const {\n+    return proj_out(false)->as_IfFalse();\n+  }\n+\n+  IfFalseNode* false_proj_or_null() const {\n+    ProjNode* false_proj = proj_out_or_null(false);\n+    return false_proj == nullptr ? nullptr : false_proj->as_IfFalse();\n+  }\n+\n@@ -537,1 +558,1 @@\n-    return proj_out(0)->as_IfFalse();\n+    return false_proj();\n@@ -555,0 +576,5 @@\n+  \/\/ Return the other IfProj node.\n+  IfProjNode* other_if_proj() const {\n+    return in(0)->as_If()->proj_out(1 - _con)->as_IfProj();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":36,"deletions":10,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1079,2 +1079,2 @@\n-        uint vreg = _lrg_map.live_range_id(n->in(k));\n-        if (!vreg) {\n+        uint vreg_in = _lrg_map.live_range_id(n->in(k));\n+        if (!vreg_in) {\n@@ -1102,1 +1102,1 @@\n-        LRG &lrg = lrgs(vreg);\n+        LRG &lrg_in = lrgs(vreg_in);\n@@ -1117,1 +1117,1 @@\n-        const RegMask &rm = n->in_RegMask(k);\n+        const RegMask &rm_in = n->in_RegMask(k);\n@@ -1124,1 +1124,1 @@\n-          lrg.and_with(rm);\n+          lrg_in.and_with(rm_in);\n@@ -1128,1 +1128,1 @@\n-        const RegMask &lrgmask = lrg.mask();\n+        const RegMask &lrgmask_in = lrg_in.mask();\n@@ -1134,2 +1134,2 @@\n-        if (lrgmask.is_bound(kreg))\n-          lrg._is_bound = 1;\n+        if (lrgmask_in.is_bound(kreg))\n+          lrg_in._is_bound = 1;\n@@ -1144,4 +1144,4 @@\n-          if (lrg.num_regs() != 0) {\n-            assert(lrgmask.is_aligned_sets(lrg.num_regs()), \"vector should be aligned\");\n-            assert(!lrg._fat_proj, \"sanity\");\n-            assert(RegMask::num_registers(kreg) == lrg.num_regs(), \"sanity\");\n+          if (lrg_in.num_regs() != 0) {\n+            assert(lrgmask_in.is_aligned_sets(lrg_in.num_regs()), \"vector should be aligned\");\n+            assert(!lrg_in._fat_proj, \"sanity\");\n+            assert(RegMask::num_registers(kreg) == lrg_in.num_regs(), \"sanity\");\n@@ -1153,3 +1153,3 @@\n-        if (!is_vect && lrg.num_regs() == 2 && !lrg._fat_proj && rm.is_misaligned_pair()) {\n-          lrg._fat_proj = 1;\n-          lrg._is_bound = 1;\n+        if (!is_vect && lrg_in.num_regs() == 2 && !lrg_in._fat_proj && rm_in.is_misaligned_pair()) {\n+          lrg_in._fat_proj = 1;\n+          lrg_in._is_bound = 1;\n@@ -1160,3 +1160,3 @@\n-            (lrg._def == nullptr || lrg.is_multidef() || !lrg._def->is_SpillCopy()) &&\n-            lrgmask.is_misaligned_pair()) {\n-          lrg.clear();\n+            (lrg_in._def == nullptr || lrg_in.is_multidef() || !lrg_in._def->is_SpillCopy()) &&\n+            lrgmask_in.is_misaligned_pair()) {\n+          lrg_in.clear();\n@@ -1166,2 +1166,2 @@\n-        if (lrg._maxfreq < block->_freq) {\n-          lrg._maxfreq = block->_freq;\n+        if (lrg_in._maxfreq < block->_freq) {\n+          lrg_in._maxfreq = block->_freq;\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -619,1 +619,3 @@\n-    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\", &ss);\n+    \/\/ It is important that we traverse both inputs and outputs of nodes,\n+    \/\/ so that we reach all nodes that are connected to Root.\n+    root()->dump_bfs(MaxNodeLimit, nullptr, \"-+S$\", &ss);\n@@ -3998,4 +4000,1 @@\n-    assert( !addp->is_AddP() ||\n-            addp->in(AddPNode::Base)->is_top() || \/\/ Top OK for allocation\n-            addp->in(AddPNode::Base) == n->in(AddPNode::Base),\n-            \"Base pointers must match (addp %u)\", addp->_idx );\n+    assert(n->as_AddP()->address_input_has_same_base(), \"Base pointers must match (addp %u)\", addp->_idx );\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1026,1 +1026,2 @@\n-    return should_delay_string_inlining(call_method, jvms) ||\n+    return C->directive()->should_delay_inline(call_method) ||\n+           should_delay_string_inlining(call_method, jvms) ||\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, address addr, const char* name) : CallLeafPureNode(tf, addr, name, TypeRawPtr::BOTTOM) {\n+ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, address addr, const char* name) : CallLeafPureNode(tf, addr, name) {\n@@ -507,0 +507,96 @@\n+template<typename IntegerType>\n+static const IntegerType* compute_signed_div_type(const IntegerType* i1, const IntegerType* i2) {\n+  typedef typename IntegerType::NativeType NativeType;\n+  assert(!i2->is_con() || i2->get_con() != 0, \"Can't handle zero constant divisor\");\n+  int widen = MAX2(i1->_widen, i2->_widen);\n+\n+  \/\/ Case A: divisor range spans zero (i2->_lo < 0 < i2->_hi)\n+  \/\/ We split into two subproblems to avoid division by 0:\n+  \/\/   - negative part: [i2->_lo, −1]\n+  \/\/   - positive part: [1, i2->_hi]\n+  \/\/ Then we union the results by taking the min of all lower‐bounds and\n+  \/\/ the max of all upper‐bounds from the two halves.\n+  if (i2->_lo < 0 && i2->_hi > 0) {\n+    \/\/ Handle negative part of the divisor range\n+    const IntegerType* neg_part = compute_signed_div_type(i1, IntegerType::make(i2->_lo, -1, widen));\n+    \/\/ Handle positive part of the divisor range\n+    const IntegerType* pos_part = compute_signed_div_type(i1, IntegerType::make(1, i2->_hi, widen));\n+    \/\/ Merge results\n+    NativeType new_lo = MIN2(neg_part->_lo, pos_part->_lo);\n+    NativeType new_hi = MAX2(neg_part->_hi, pos_part->_hi);\n+    assert(new_hi >= new_lo, \"sanity\");\n+    return IntegerType::make(new_lo, new_hi, widen);\n+  }\n+\n+  \/\/ Case B: divisor range does NOT span zero.\n+  \/\/ Here i2 is entirely negative or entirely positive.\n+  \/\/ Then i1\/i2 is monotonic in i1 and i2 (when i2 keeps the same sign).\n+  \/\/ Therefore the extrema occur at the four “corners”:\n+  \/\/   (i1->_lo, i2->_hi), (i1->_lo, i2->_lo), (i1->_hi, i2->_lo), (i1->_hi, i2->_hi).\n+  \/\/ We compute all four and take the min and max.\n+  \/\/ A special case handles overflow when dividing the most‐negative value by −1.\n+\n+  \/\/ adjust i2 bounds to not include zero, as zero always throws\n+  NativeType i2_lo = i2->_lo == 0 ? 1 : i2->_lo;\n+  NativeType i2_hi = i2->_hi == 0 ? -1 : i2->_hi;\n+  constexpr NativeType min_val = std::numeric_limits<NativeType>::min();\n+  static_assert(min_val == min_jint || min_val == min_jlong, \"min has to be either min_jint or min_jlong\");\n+  constexpr NativeType max_val = std::numeric_limits<NativeType>::max();\n+  static_assert(max_val == max_jint || max_val == max_jlong, \"max has to be either max_jint or max_jlong\");\n+\n+  \/\/ Special overflow case: min_val \/ (-1) == min_val (cf. JVMS§6.5 idiv\/ldiv)\n+  \/\/ We need to be careful that we never run min_val \/ (-1) in C++ code, as this overflow is UB there\n+  if (i1->_lo == min_val && i2_hi == -1) {\n+    NativeType new_lo = min_val;\n+    NativeType new_hi;\n+    \/\/ compute new_hi depending on whether divisor or dividend is non-constant.\n+    \/\/ i2 is purely in the negative domain here (as i2_hi is -1)\n+    \/\/ which means the maximum value this division can yield is either\n+    if (!i1->is_con()) {\n+      \/\/ a) non-constant dividend: i1 could be min_val + 1.\n+      \/\/ -> i1 \/ i2 = (min_val + 1) \/ -1 = max_val is possible.\n+      new_hi = max_val;\n+      assert((min_val + 1) \/ -1 == new_hi, \"new_hi should be max_val\");\n+    } else if (i2_lo != i2_hi) {\n+      \/\/ b) i1 is constant min_val, i2 is non-constant.\n+      \/\/    if i2 = -1 -> i1 \/ i2 =  min_val \/ -1 = min_val\n+      \/\/    if i2 < -1 -> i1 \/ i2 <= min_val \/ -2 = (max_val \/ 2) + 1\n+      new_hi = (max_val \/ 2) + 1;\n+      assert(min_val \/ -2 == new_hi, \"new_hi should be (max_val \/ 2) + 1)\");\n+    } else {\n+      \/\/ c) i1 is constant min_val, i2 is constant -1.\n+      \/\/    -> i1 \/ i2 = min_val \/ -1 = min_val\n+      new_hi = min_val;\n+    }\n+\n+#ifdef ASSERT\n+    \/\/ validate new_hi for non-constant divisor\n+    if (i2_lo != i2_hi) {\n+      assert(i2_lo != -1, \"Special case not possible here, as i2_lo has to be < i2_hi\");\n+      NativeType result = i1->_lo \/ i2_lo;\n+      assert(new_hi >= result, \"computed wrong value for new_hi\");\n+    }\n+\n+    \/\/ validate new_hi for non-constant dividend\n+    if (!i1->is_con()) {\n+      assert(i2_hi > min_val, \"Special case not possible here, as i1->_hi has to be > min\");\n+      NativeType result1 = i1->_hi \/ i2_lo;\n+      NativeType result2 = i1->_hi \/ i2_hi;\n+      assert(new_hi >= result1 && new_hi >= result2, \"computed wrong value for new_hi\");\n+    }\n+#endif\n+\n+    return IntegerType::make(new_lo, new_hi, widen);\n+  }\n+  assert((i1->_lo != min_val && i1->_hi != min_val) || (i2_hi != -1 && i2_lo != -1), \"should have filtered out before\");\n+\n+  \/\/ Special case not possible here, calculate all corners normally\n+  NativeType corner1 = i1->_lo \/ i2_lo;\n+  NativeType corner2 = i1->_lo \/ i2_hi;\n+  NativeType corner3 = i1->_hi \/ i2_lo;\n+  NativeType corner4 = i1->_hi \/ i2_hi;\n+\n+  NativeType new_lo = MIN4(corner1, corner2, corner3, corner4);\n+  NativeType new_hi = MAX4(corner1, corner2, corner3, corner4);\n+  return IntegerType::make(new_lo, new_hi, widen);\n+}\n@@ -552,4 +648,10 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t2 == TypeInt::ZERO) {\n+    \/\/ this division will always throw an exception\n+    return Type::TOP;\n+  }\n@@ -562,11 +664,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Divide the two numbers.  We approximate.\n-  \/\/ If divisor is a constant and not zero\n-  const TypeInt *i1 = t1->is_int();\n-  const TypeInt *i2 = t2->is_int();\n-  int widen = MAX2(i1->_widen, i2->_widen);\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n@@ -574,37 +667,1 @@\n-  if( i2->is_con() && i2->get_con() != 0 ) {\n-    int32_t d = i2->get_con(); \/\/ Divisor\n-    jint lo, hi;\n-    if( d >= 0 ) {\n-      lo = i1->_lo\/d;\n-      hi = i1->_hi\/d;\n-    } else {\n-      if( d == -1 && i1->_lo == min_jint ) {\n-        \/\/ 'min_jint\/-1' throws arithmetic exception during compilation\n-        lo = min_jint;\n-        \/\/ do not support holes, 'hi' must go to either min_jint or max_jint:\n-        \/\/ [min_jint, -10]\/[-1,-1] ==> [min_jint] UNION [10,max_jint]\n-        hi = i1->_hi == min_jint ? min_jint : max_jint;\n-      } else {\n-        lo = i1->_hi\/d;\n-        hi = i1->_lo\/d;\n-      }\n-    }\n-    return TypeInt::make(lo, hi, widen);\n-  }\n-\n-  \/\/ If the dividend is a constant\n-  if( i1->is_con() ) {\n-    int32_t d = i1->get_con();\n-    if( d < 0 ) {\n-      if( d == min_jint ) {\n-        \/\/  (-min_jint) == min_jint == (min_jint \/ -1)\n-        return TypeInt::make(min_jint, max_jint\/2 + 1, widen);\n-      } else {\n-        return TypeInt::make(d, -d, widen);\n-      }\n-    }\n-    return TypeInt::make(-d, d, widen);\n-  }\n-\n-  \/\/ Otherwise we give up all hope\n-  return TypeInt::INT;\n+  return compute_signed_div_type<TypeInt>(i1, i2);\n@@ -658,4 +715,10 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t2 == TypeLong::ZERO) {\n+    \/\/ this division will always throw an exception\n+    return Type::TOP;\n+  }\n@@ -668,46 +731,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Divide the two numbers.  We approximate.\n-  \/\/ If divisor is a constant and not zero\n-  const TypeLong *i1 = t1->is_long();\n-  const TypeLong *i2 = t2->is_long();\n-  int widen = MAX2(i1->_widen, i2->_widen);\n-\n-  if( i2->is_con() && i2->get_con() != 0 ) {\n-    jlong d = i2->get_con();    \/\/ Divisor\n-    jlong lo, hi;\n-    if( d >= 0 ) {\n-      lo = i1->_lo\/d;\n-      hi = i1->_hi\/d;\n-    } else {\n-      if( d == CONST64(-1) && i1->_lo == min_jlong ) {\n-        \/\/ 'min_jlong\/-1' throws arithmetic exception during compilation\n-        lo = min_jlong;\n-        \/\/ do not support holes, 'hi' must go to either min_jlong or max_jlong:\n-        \/\/ [min_jlong, -10]\/[-1,-1] ==> [min_jlong] UNION [10,max_jlong]\n-        hi = i1->_hi == min_jlong ? min_jlong : max_jlong;\n-      } else {\n-        lo = i1->_hi\/d;\n-        hi = i1->_lo\/d;\n-      }\n-    }\n-    return TypeLong::make(lo, hi, widen);\n-  }\n-\n-  \/\/ If the dividend is a constant\n-  if( i1->is_con() ) {\n-    jlong d = i1->get_con();\n-    if( d < 0 ) {\n-      if( d == min_jlong ) {\n-        \/\/  (-min_jlong) == min_jlong == (min_jlong \/ -1)\n-        return TypeLong::make(min_jlong, max_jlong\/2 + 1, widen);\n-      } else {\n-        return TypeLong::make(d, -d, widen);\n-      }\n-    }\n-    return TypeLong::make(-d, d, widen);\n-  }\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n@@ -715,2 +734,1 @@\n-  \/\/ Otherwise we give up all hope\n-  return TypeLong::LONG;\n+  return compute_signed_div_type<TypeLong>(i1, i2);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":123,"deletions":105,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-      bool should_delay = C->should_delay_inlining();\n+      bool should_delay = C->should_delay_inlining() || C->directive()->should_delay_inline(callee);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2746,1 +2746,2 @@\n-    call = new CallLeafPureNode(call_type, call_addr, call_name, adr_type);\n+    assert(adr_type == nullptr, \"pure call does not touch memory\");\n+    call = new CallLeafPureNode(call_type, call_addr, call_name);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-ProjNode* IfNode::range_check_trap_proj(int& flip_test, Node*& l, Node*& r) {\n+IfProjNode* IfNode::range_check_trap_proj(int& flip_test, Node*& l, Node*& r) const {\n@@ -518,2 +518,4 @@\n-  ProjNode* iftrap = proj_out_or_null(flip_test == 2 ? true : false);\n-  return iftrap;\n+  if (flip_test == 2) {\n+    return true_proj_or_null();\n+  }\n+  return false_proj_or_null();\n@@ -531,1 +533,1 @@\n-  ProjNode* iftrap = range_check_trap_proj(flip_test, l, r);\n+  IfProjNode* iftrap = range_check_trap_proj(flip_test, l, r);\n@@ -772,1 +774,1 @@\n-    ctrl->is_Proj() &&\n+    ctrl->is_IfProj() &&\n@@ -785,2 +787,2 @@\n-bool IfNode::has_shared_region(ProjNode* proj, ProjNode*& success, ProjNode*& fail) {\n-  ProjNode* otherproj = proj->other_if_proj();\n+bool IfNode::has_shared_region(IfProjNode* proj, IfProjNode*& success, IfProjNode*& fail) const {\n+  IfProjNode* otherproj = proj->other_if_proj();\n@@ -794,3 +796,3 @@\n-      ProjNode* proj = proj_out(i);\n-      if (success == nullptr && proj->outcnt() == 1 && proj->unique_out() == region) {\n-        success = proj;\n+      IfProjNode* next_proj = proj_out(i)->as_IfProj();\n+      if (success == nullptr && next_proj->outcnt() == 1 && next_proj->unique_out() == region) {\n+        success = next_proj;\n@@ -798,1 +800,1 @@\n-        fail = proj;\n+        fail = next_proj;\n@@ -800,1 +802,2 @@\n-        success = fail = nullptr;\n+        success = nullptr;\n+        fail = nullptr;\n@@ -851,2 +854,2 @@\n-bool IfNode::has_only_uncommon_traps(ProjNode* proj, ProjNode*& success, ProjNode*& fail, PhaseIterGVN* igvn) {\n-  ProjNode* otherproj = proj->other_if_proj();\n+bool IfNode::has_only_uncommon_traps(IfProjNode* proj, IfProjNode*& success, IfProjNode*& fail, PhaseIterGVN* igvn) const {\n+  IfProjNode* otherproj = proj->other_if_proj();\n@@ -889,2 +892,2 @@\n-        success = unc_proj;\n-        fail = unc_proj->other_if_proj();\n+        success = unc_proj->as_IfProj();\n+        fail = unc_proj->as_IfProj()->other_if_proj();\n@@ -899,1 +902,1 @@\n-bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n+bool IfNode::fold_compares_helper(IfProjNode* proj, IfProjNode* success, IfProjNode* fail, PhaseIterGVN* igvn) {\n@@ -907,1 +910,1 @@\n-  ProjNode* otherproj = proj->other_if_proj();\n+  IfProjNode* otherproj = proj->other_if_proj();\n@@ -1109,1 +1112,1 @@\n-Node* IfNode::merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {\n+Node* IfNode::merge_uncommon_traps(IfProjNode* proj, IfProjNode* success, IfProjNode* fail, PhaseIterGVN* igvn) {\n@@ -1113,1 +1116,1 @@\n-  ProjNode* otherproj = proj->other_if_proj();\n+  IfProjNode* otherproj = proj->other_if_proj();\n@@ -1240,1 +1243,1 @@\n-bool IfNode::is_cmp_with_loadrange(ProjNode* proj) {\n+bool IfNode::is_cmp_with_loadrange(IfProjNode* proj) const {\n@@ -1259,1 +1262,1 @@\n-bool IfNode::is_null_check(ProjNode* proj, PhaseIterGVN* igvn) {\n+bool IfNode::is_null_check(IfProjNode* proj, PhaseIterGVN* igvn) const {\n@@ -1293,1 +1296,1 @@\n-bool IfNode::is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn) {\n+bool IfNode::is_side_effect_free_test(IfProjNode* proj, PhaseIterGVN* igvn) const {\n@@ -1333,1 +1336,1 @@\n-void IfNode::reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn) {\n+void IfNode::reroute_side_effect_free_unc(IfProjNode* proj, IfProjNode* dom_proj, PhaseIterGVN* igvn) {\n@@ -1335,1 +1338,1 @@\n-  ProjNode* otherproj = proj->other_if_proj();\n+  IfProjNode* otherproj = proj->other_if_proj();\n@@ -1366,3 +1369,3 @@\n-      ProjNode* success = nullptr;\n-      ProjNode* fail = nullptr;\n-      ProjNode* dom_cmp = ctrl->as_Proj();\n+      IfProjNode* success = nullptr;\n+      IfProjNode* fail = nullptr;\n+      IfProjNode* dom_cmp = ctrl->as_IfProj();\n@@ -1382,2 +1385,2 @@\n-      ProjNode* success = nullptr;\n-      ProjNode* fail = nullptr;\n+      IfProjNode* success = nullptr;\n+      IfProjNode* fail = nullptr;\n@@ -1385,2 +1388,2 @@\n-      ProjNode* dom_cmp = dom->isa_Proj();\n-      ProjNode* other_cmp = ctrl->isa_Proj();\n+      IfProjNode* dom_cmp = dom->isa_IfProj();\n+      IfProjNode* other_cmp = ctrl->isa_IfProj();\n@@ -1895,2 +1898,2 @@\n-  Node* old_if_f = iff->proj_out(false);\n-  Node* old_if_t = iff->proj_out(true);\n+  IfFalseNode* old_if_f = iff->false_proj();\n+  IfTrueNode* old_if_t = iff->true_proj();\n@@ -2212,1 +2215,1 @@\n-  ParsePredicateUncommonProj* uncommon_proj = proj_out(0)->as_IfFalse();\n+  ParsePredicateUncommonProj* uncommon_proj = false_proj();\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":38,"deletions":35,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -6937,1 +6937,1 @@\n-    Node* other_proj = node->as_IfProj()->other_if_proj();\n+    IfProjNode* other_proj = node->as_IfProj()->other_if_proj();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-  IfFalseNode* multiversion_slow_proj = multiversion_if->proj_out(0)->as_IfFalse();\n+  IfFalseNode* multiversion_slow_proj = multiversion_if->false_proj();\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -613,1 +613,1 @@\n-  IfFalseNode* inner_loop_exit() const { return inner_counted_loop_end()->proj_out(false)->as_IfFalse(); }\n+  IfFalseNode* inner_loop_exit() const { return inner_counted_loop_end()->false_proj(); }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1389,2 +1389,2 @@\n-  Node* proj_true = dom_if->proj_out(1);\n-  Node* proj_false = dom_if->proj_out(0);\n+  IfTrueNode* proj_true = dom_if->true_proj();\n+  IfFalseNode* proj_false = dom_if->false_proj();\n@@ -1760,2 +1760,2 @@\n-    ProjNode* dom_proj_true = dom_if->proj_out(1);\n-    ProjNode* dom_proj_false = dom_if->proj_out(0);\n+    IfTrueNode* dom_proj_true = dom_if->true_proj();\n+    IfFalseNode* dom_proj_false = dom_if->false_proj();\n@@ -1805,1 +1805,1 @@\n-        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n+        dominated_by(dom_proj_true, new_false_region->in(i)->in(0)->as_If());\n@@ -1808,1 +1808,1 @@\n-        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n+        dominated_by(dom_proj_false, new_false_region->in(i)->in(0)->as_If());\n@@ -2577,1 +2577,1 @@\n-    Node* cle_out = cle->proj_out(false);\n+    IfFalseNode* cle_out = cle->false_proj();\n@@ -2874,1 +2874,1 @@\n-            use = le->proj_out(false);\n+            use = le->false_proj();\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2903,2 +2903,2 @@\n-    Node* iftrue = iff->as_If()->proj_out(1);\n-    Node* iffalse = iff->as_If()->proj_out(0);\n+    IfTrueNode* iftrue = iff->as_If()->true_proj();\n+    IfFalseNode* iffalse = iff->as_If()->false_proj();\n@@ -3321,2 +3321,1 @@\n-        CallNode* call = new CallLeafPureNode(mod_macro->tf(), mod_macro->entry_point(),\n-                                              mod_macro->_name, TypeRawPtr::BOTTOM);\n+        CallNode* call = new CallLeafPureNode(mod_macro->tf(), mod_macro->entry_point(), mod_macro->_name);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3378,1 +3378,1 @@\n-  ProjNode* other_proj = ctrl_use->as_IfProj()->other_if_proj();\n+  IfProjNode* other_proj = ctrl_use->as_IfProj()->other_if_proj();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -636,63 +637,0 @@\n-template<typename IntegerType>\n-static const IntegerType* and_value(const IntegerType* r0, const IntegerType* r1) {\n-  typedef typename IntegerType::NativeType NativeType;\n-  static_assert(std::is_signed<NativeType>::value, \"Native type of IntegerType must be signed!\");\n-\n-  int widen = MAX2(r0->_widen, r1->_widen);\n-\n-  \/\/ If both types are constants, we can calculate a constant result.\n-  if (r0->is_con() && r1->is_con()) {\n-    return IntegerType::make(r0->get_con() & r1->get_con());\n-  }\n-\n-  \/\/ If both ranges are positive, the result will range from 0 up to the hi value of the smaller range. The minimum\n-  \/\/ of the two constrains the upper bound because any higher value in the other range will see all zeroes, so it will be masked out.\n-  if (r0->_lo >= 0 && r1->_lo >= 0) {\n-    return IntegerType::make(0, MIN2(r0->_hi, r1->_hi), widen);\n-  }\n-\n-  \/\/ If only one range is positive, the result will range from 0 up to that range's maximum value.\n-  \/\/ For the operation 'x & C' where C is a positive constant, the result will be in the range [0..C]. With that observation,\n-  \/\/ we can say that for any integer c such that 0 <= c <= C will also be in the range [0..C]. Therefore, 'x & [c..C]'\n-  \/\/ where c >= 0 will be in the range [0..C].\n-  if (r0->_lo >= 0) {\n-    return IntegerType::make(0, r0->_hi, widen);\n-  }\n-\n-  if (r1->_lo >= 0) {\n-    return IntegerType::make(0, r1->_hi, widen);\n-  }\n-\n-  \/\/ At this point, all positive ranges will have already been handled, so the only remaining cases will be negative ranges\n-  \/\/ and constants.\n-\n-  assert(r0->_lo < 0 && r1->_lo < 0, \"positive ranges should already be handled!\");\n-\n-  \/\/ As two's complement means that both numbers will start with leading 1s, the lower bound of both ranges will contain\n-  \/\/ the common leading 1s of both minimum values. In order to count them with count_leading_zeros, the bits are inverted.\n-  NativeType sel_val = ~MIN2(r0->_lo, r1->_lo);\n-\n-  NativeType min;\n-  if (sel_val == 0) {\n-    \/\/ Since count_leading_zeros is undefined at 0, we short-circuit the condition where both ranges have a minimum of -1.\n-    min = -1;\n-  } else {\n-    \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n-    int shift_bits = count_leading_zeros(sel_val) - 1;\n-    min = std::numeric_limits<NativeType>::min() >> shift_bits;\n-  }\n-\n-  NativeType max;\n-  if (r0->_hi < 0 && r1->_hi < 0) {\n-    \/\/ If both ranges are negative, then the same optimization as both positive ranges will apply, and the smaller hi\n-    \/\/ value will mask off any bits set by higher values.\n-    max = MIN2(r0->_hi, r1->_hi);\n-  } else {\n-    \/\/ In the case of ranges that cross zero, negative values can cause the higher order bits to be set, so the maximum\n-    \/\/ positive value can be as high as the larger hi value.\n-    max = MAX2(r0->_hi, r1->_hi);\n-  }\n-\n-  return IntegerType::make(min, max, widen);\n-}\n-\n@@ -705,5 +643,2 @@\n-const Type *AndINode::mul_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt* r0 = t0->is_int();\n-  const TypeInt* r1 = t1->is_int();\n-\n-  return and_value<TypeInt>(r0, r1);\n+const Type* AndINode::mul_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_and(t1->is_int(), t2->is_int());\n@@ -838,5 +773,2 @@\n-const Type *AndLNode::mul_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong* r0 = t0->is_long();\n-  const TypeLong* r1 = t1->is_long();\n-\n-  return and_value<TypeLong>(r0, r1);\n+const Type* AndLNode::mul_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_and(t1->is_long(), t2->is_long());\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":5,"deletions":73,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -263,6 +263,1 @@\n-  return other_if_proj()->is_uncommon_trap_proj(reason);\n-}\n-\n-ProjNode* ProjNode::other_if_proj() const {\n-  assert(_con == 0 || _con == 1, \"not an if?\");\n-  return in(0)->as_If()->proj_out(1-_con);\n+  return as_IfProj()->other_if_proj()->is_uncommon_trap_proj(reason);\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -203,3 +203,0 @@\n-\n-  \/\/ Return other proj node when this is a If proj node\n-  ProjNode* other_if_proj() const;\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1012,0 +1012,3 @@\n+  \/\/ If we end up traversing more nodes than we actually have,\n+  \/\/ it is definitely an infinite loop.\n+  uint max_depth = Compile::current()->unique();\n@@ -1018,1 +1021,1 @@\n-    if (depth_count >= K) {\n+    if (depth_count++ >= max_depth) {\n@@ -1020,1 +1023,1 @@\n-      if (p != orig_p)\n+      if (p != orig_p) {\n@@ -1022,0 +1025,2 @@\n+      }\n+      fatal(\"infinite loop in Node::uncast_helper\");\n@@ -1023,1 +1028,0 @@\n-    assert(depth_count++ < K, \"infinite loop in Node::uncast_helper\");\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"opto\/subtypenode.hpp\"\n@@ -2511,0 +2512,76 @@\n+\/\/ Matches exact and inexact type check IR shapes during parsing.\n+\/\/ On successful match, returns type checked object node and its type after successful check\n+\/\/ as out parameters.\n+static bool match_type_check(PhaseGVN& gvn,\n+                             BoolTest::mask btest,\n+                             Node* con, const Type* tcon,\n+                             Node* val, const Type* tval,\n+                             Node** obj, const TypeOopPtr** cast_type) { \/\/ out-parameters\n+  \/\/ Look for opportunities to sharpen the type of a node whose klass is compared with a constant klass.\n+  \/\/ The constant klass being tested against can come from many bytecode instructions (implicitly or explicitly),\n+  \/\/ and also from profile data used by speculative casts.\n+  if (btest == BoolTest::eq && tcon->isa_klassptr()) {\n+    \/\/ Found:\n+    \/\/   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])\n+    \/\/ or the narrowOop equivalent.\n+    (*obj) = extract_obj_from_klass_load(&gvn, val);\n+    (*cast_type) = tcon->isa_klassptr()->as_instance_type();\n+    return true; \/\/ found\n+  }\n+\n+  \/\/ Match an instanceof check.\n+  \/\/ During parsing its IR shape is not canonicalized yet.\n+  \/\/\n+  \/\/             obj superklass\n+  \/\/              |    |\n+  \/\/           SubTypeCheck\n+  \/\/                |\n+  \/\/               Bool [eq] \/ [ne]\n+  \/\/                |\n+  \/\/                If\n+  \/\/               \/ \\\n+  \/\/              T   F\n+  \/\/               \\ \/\n+  \/\/              Region\n+  \/\/                 \\  ConI ConI\n+  \/\/                  \\  |  \/\n+  \/\/          val ->    Phi  ConI  <- con\n+  \/\/                     \\  \/\n+  \/\/                     CmpI\n+  \/\/                      |\n+  \/\/                    Bool [btest]\n+  \/\/                      |\n+  \/\/\n+  if (tval->isa_int() && val->is_Phi() && val->in(0)->as_Region()->is_diamond()) {\n+    RegionNode* diamond = val->in(0)->as_Region();\n+    IfNode* if1 = diamond->in(1)->in(0)->as_If();\n+    BoolNode* b1 = if1->in(1)->isa_Bool();\n+    if (b1 != nullptr && b1->in(1)->isa_SubTypeCheck()) {\n+      assert(b1->_test._test == BoolTest::eq ||\n+             b1->_test._test == BoolTest::ne, \"%d\", b1->_test._test);\n+\n+      ProjNode* success_proj = if1->proj_out(b1->_test._test == BoolTest::eq ? 1 : 0);\n+      int idx = diamond->find_edge(success_proj);\n+      assert(idx == 1 || idx == 2, \"\");\n+      Node* vcon = val->in(idx);\n+\n+      assert(val->find_edge(con) > 0, \"\");\n+      if ((btest == BoolTest::eq && vcon == con) || (btest == BoolTest::ne && vcon != con)) {\n+        SubTypeCheckNode* sub = b1->in(1)->as_SubTypeCheck();\n+        Node* obj_or_subklass = sub->in(SubTypeCheckNode::ObjOrSubKlass);\n+        Node* superklass = sub->in(SubTypeCheckNode::SuperKlass);\n+\n+        if (gvn.type(obj_or_subklass)->isa_oopptr()) {\n+          const TypeKlassPtr* klass_ptr_type = gvn.type(superklass)->is_klassptr();\n+          const TypeKlassPtr* improved_klass_ptr_type = klass_ptr_type->try_improve();\n+\n+          (*obj) = obj_or_subklass;\n+          (*cast_type) = improved_klass_ptr_type->cast_to_exactness(false)->as_instance_type();\n+          return true; \/\/ found\n+        }\n+      }\n+    }\n+  }\n+  return false; \/\/ not found\n+}\n+\n@@ -2514,32 +2591,26 @@\n-  \/\/ Look for opportunities to sharpen the type of a node\n-  \/\/ whose klass is compared with a constant klass.\n-  if (btest == BoolTest::eq && tcon->isa_klassptr()) {\n-    Node* obj = extract_obj_from_klass_load(&_gvn, val);\n-    const TypeOopPtr* con_type = tcon->isa_klassptr()->as_instance_type();\n-    if (obj != nullptr && (con_type->isa_instptr() || con_type->isa_aryptr())) {\n-       \/\/ Found:\n-       \/\/   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])\n-       \/\/ or the narrowOop equivalent.\n-       const Type* obj_type = _gvn.type(obj);\n-       const TypeOopPtr* tboth = obj_type->join_speculative(con_type)->isa_oopptr();\n-       if (tboth != nullptr && tboth->klass_is_exact() && tboth != obj_type &&\n-           tboth->higher_equal(obj_type)) {\n-          \/\/ obj has to be of the exact type Foo if the CmpP succeeds.\n-          int obj_in_map = map()->find_edge(obj);\n-          JVMState* jvms = this->jvms();\n-          if (obj_in_map >= 0 &&\n-              (jvms->is_loc(obj_in_map) || jvms->is_stk(obj_in_map))) {\n-            TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);\n-            const Type* tcc = ccast->as_Type()->type();\n-            assert(tcc != obj_type && tcc->higher_equal(obj_type), \"must improve\");\n-            \/\/ Delay transform() call to allow recovery of pre-cast value\n-            \/\/ at the control merge.\n-            _gvn.set_type_bottom(ccast);\n-            record_for_igvn(ccast);\n-            if (tboth->is_inlinetypeptr()) {\n-              ccast = InlineTypeNode::make_from_oop(this, ccast, tboth->exact_klass(true)->as_inline_klass());\n-            }\n-            \/\/ Here's the payoff.\n-            replace_in_map(obj, ccast);\n-          }\n-       }\n+  Node* obj = nullptr;\n+  const TypeOopPtr* cast_type = nullptr;\n+  \/\/ Insert a cast node with a narrowed type after a successful type check.\n+  if (match_type_check(_gvn, btest, con, tcon, val, tval,\n+                       &obj, &cast_type)) {\n+    assert(obj != nullptr && cast_type != nullptr, \"missing type check info\");\n+    const Type* obj_type = _gvn.type(obj);\n+    const TypeOopPtr* tboth = obj_type->join_speculative(cast_type)->isa_oopptr();\n+    if (tboth != nullptr && tboth != obj_type && tboth->higher_equal(obj_type)) {\n+      int obj_in_map = map()->find_edge(obj);\n+      JVMState* jvms = this->jvms();\n+      if (obj_in_map >= 0 &&\n+          (jvms->is_loc(obj_in_map) || jvms->is_stk(obj_in_map))) {\n+        TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);\n+        const Type* tcc = ccast->as_Type()->type();\n+        assert(tcc != obj_type && tcc->higher_equal(obj_type), \"must improve\");\n+        \/\/ Delay transform() call to allow recovery of pre-cast value\n+        \/\/ at the control merge.\n+        _gvn.set_type_bottom(ccast);\n+        record_for_igvn(ccast);\n+        if (tboth->is_inlinetypeptr()) {\n+          ccast = InlineTypeNode::make_from_oop(this, ccast, tboth->exact_klass(true)->as_inline_klass());\n+        }\n+        \/\/ Here's the payoff.\n+        replace_in_map(obj, ccast);\n+      }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":103,"deletions":32,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -1079,1 +1079,2 @@\n-      is_verify_Identity()) {\n+      is_verify_Identity() ||\n+      is_verify_invariants()) {\n@@ -1091,0 +1092,1 @@\n+      if (is_verify_invariants()) { failure |= verify_node_invariants_for(n); }\n@@ -1105,1 +1107,1 @@\n-    assert(!failure, \"Missed optimization opportunity in PhaseIterGVN\");\n+    assert(!failure, \"Missed optimization opportunity\/broken graph in PhaseIterGVN\");\n@@ -2061,0 +2063,15 @@\n+\n+\/\/ Some other verifications that are not specific to a particular transformation.\n+bool PhaseIterGVN::verify_node_invariants_for(const Node* n) {\n+  if (n->is_AddP()) {\n+    if (!n->as_AddP()->address_input_has_same_base()) {\n+      stringStream ss; \/\/ Print as a block without tty lock.\n+      ss.cr();\n+      ss.print_cr(\"Base pointers must match for AddP chain:\");\n+      n->dump_bfs(2, nullptr, \"\", &ss);\n+      tty->print_cr(\"%s\", ss.as_string());\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -496,0 +496,1 @@\n+  bool verify_node_invariants_for(const Node* n);\n@@ -621,0 +622,4 @@\n+  static bool is_verify_invariants() {\n+    \/\/ '-XX:VerifyIterativeGVN=10000'\n+    return ((VerifyIterativeGVN % 100000) \/ 10000) == 1;\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-      C->gvn_replace_by(n->in(0)->as_If()->proj_out(false), C->top());\n+      C->gvn_replace_by(n->in(0)->as_If()->false_proj(), C->top());\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -828,0 +828,1 @@\n+  static const TypeInt* make(const TypeIntPrototype<jint, juint>& t, int widen) { return make_or_top(t, widen)->is_int(); }\n@@ -909,0 +910,1 @@\n+  static const TypeLong* make(const TypeIntPrototype<jlong, julong>& t, int widen) { return make_or_top(t, widen)->is_long(); }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1376,8 +1376,0 @@\n-class ScopedValueBindingsResolver {\n-public:\n-  InstanceKlass* Carrier_klass;\n-  ScopedValueBindingsResolver(JavaThread* THREAD) {\n-    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ScopedValue_Carrier(), true, THREAD);\n-    Carrier_klass = InstanceKlass::cast(k);\n-  }\n-};\n@@ -1390,2 +1382,0 @@\n-  static ScopedValueBindingsResolver resolver(THREAD);\n-\n@@ -1404,1 +1394,1 @@\n-          || holder == resolver.Carrier_klass) {\n+          || holder == vmClasses::ScopedValue_Carrier_klass()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1544,0 +1544,3 @@\n+      \/\/ The other thread can block for safepoints during event callbacks, so ensure we\n+      \/\/ are safepoint-safe while waiting.\n+      ThreadBlockInVM tbivm(JavaThread::current());\n@@ -1545,1 +1548,0 @@\n-      \/\/ If another thread is posting events, let it finish\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -539,2 +539,0 @@\n-  { \"LockingMode\",                  JDK_Version::jdk(24), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"EnableValhalla\",               JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::undefined() },\n@@ -546,1 +544,0 @@\n-  { \"PSChunkLargeArrays\",           JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n@@ -556,5 +553,0 @@\n-#ifdef LINUX\n-  { \"UseOprofile\",                  JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-#endif\n-  { \"G1UpdateBufferSize\",           JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"ShenandoahPacing\",             JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n@@ -566,19 +558,1 @@\n-  { \"AdaptiveSizeMajorGCDecayTimeScale\",                JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"AdaptiveSizePolicyInitializingSteps\",              JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"AdaptiveSizePolicyOutputInterval\",                 JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"AdaptiveSizeThroughPutPolicy\",                     JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"AdaptiveTimeWeight\",                               JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"PausePadding\",                                     JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"SurvivorPadding\",                                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"TenuredGenerationSizeIncrement\",                   JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"TenuredGenerationSizeSupplement\",                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"TenuredGenerationSizeSupplementDecay\",             JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"UseAdaptiveGenerationSizePolicyAtMajorCollection\", JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"UseAdaptiveGenerationSizePolicyAtMinorCollection\", JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"UseAdaptiveSizeDecayMajorGCCost\",                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"UseAdaptiveSizePolicyFootprintGoal\",               JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"UseAdaptiveSizePolicyWithSystemGC\",                JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"UsePSAdaptiveSurvivorSizePolicy\",                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-\n-  { \"PretenureSizeThreshold\",       JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-  { \"HeapMaximumCompactionInterval\",JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"PSChunkLargeArrays\",           JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n@@ -1123,0 +1097,7 @@\n+void Arguments::set_jvm_flags_file(const char *value) {\n+  if (_jvm_flags_file != nullptr) {\n+    os::free(_jvm_flags_file);\n+  }\n+  _jvm_flags_file = os::strdup_check_oom(value);\n+}\n+\n@@ -2898,0 +2879,4 @@\n+void Arguments::set_ext_dirs(char *value) {\n+  _ext_dirs = os::strdup_check_oom(value);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-#include \"logging\/logLevel.hpp\"\n-#include \"logging\/logTag.hpp\"\n+#include \"jni.h\"\n@@ -32,1 +31,1 @@\n-#include \"runtime\/globals.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -34,3 +33,1 @@\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/vmEnums.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -40,0 +37,2 @@\n+template <typename E>\n+class GrowableArray;\n@@ -416,6 +415,2 @@\n-  static void set_jvm_flags_file(const char *value) {\n-    if (_jvm_flags_file != nullptr) {\n-      os::free(_jvm_flags_file);\n-    }\n-    _jvm_flags_file = os::strdup_check_oom(value);\n-  }\n+  static void set_jvm_flags_file(const char *value);\n+\n@@ -483,1 +478,1 @@\n-  static void set_ext_dirs(char *value)     { _ext_dirs = os::strdup_check_oom(value); }\n+  static void set_ext_dirs(char *value);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/objectMonitorTable.hpp\"\n@@ -1511,285 +1512,0 @@\n-\/\/ -----------------------------------------------------------------------------\n-\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n-class ObjectMonitorTable : AllStatic {\n-  struct Config {\n-    using Value = ObjectMonitor*;\n-    static uintx get_hash(Value const& value, bool* is_dead) {\n-      return (uintx)value->hash();\n-    }\n-    static void* allocate_node(void* context, size_t size, Value const& value) {\n-      ObjectMonitorTable::inc_items_count();\n-      return AllocateHeap(size, mtObjectMonitor);\n-    };\n-    static void free_node(void* context, void* memory, Value const& value) {\n-      ObjectMonitorTable::dec_items_count();\n-      FreeHeap(memory);\n-    }\n-  };\n-  using ConcurrentTable = ConcurrentHashTable<Config, mtObjectMonitor>;\n-\n-  static ConcurrentTable* _table;\n-  static volatile size_t _items_count;\n-  static size_t _table_size;\n-  static volatile bool _resize;\n-\n-  class Lookup : public StackObj {\n-    oop _obj;\n-\n-   public:\n-    explicit Lookup(oop obj) : _obj(obj) {}\n-\n-    uintx get_hash() const {\n-      uintx hash = _obj->mark().hash();\n-      assert(hash != 0, \"should have a hash\");\n-      return hash;\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_refers_to(_obj);\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return false;\n-    }\n-  };\n-\n-  class LookupMonitor : public StackObj {\n-    ObjectMonitor* _monitor;\n-\n-   public:\n-    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n-\n-    uintx get_hash() const {\n-      return _monitor->hash();\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      return (*value) == _monitor;\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_is_dead();\n-    }\n-  };\n-\n-  static void inc_items_count() {\n-    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n-  }\n-\n-  static void dec_items_count() {\n-    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n-  }\n-\n-  static double get_load_factor() {\n-    size_t count = AtomicAccess::load(&_items_count);\n-    return (double)count \/ (double)_table_size;\n-  }\n-\n-  static size_t table_size(Thread* current = Thread::current()) {\n-    return ((size_t)1) << _table->get_size_log2(current);\n-  }\n-\n-  static size_t max_log_size() {\n-    \/\/ TODO[OMTable]: Evaluate the max size.\n-    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n-    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n-    \/\/                are definitely rounding errors (alignment).\n-    const size_t max_capacity = MaxHeapSize;\n-    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n-    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n-    const size_t log_max_objects = log2i_graceful(max_objects);\n-\n-    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n-  }\n-\n-  static size_t min_log_size() {\n-    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n-    return 10;\n-  }\n-\n-  template<typename V>\n-  static size_t clamp_log_size(V log_size) {\n-    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n-  }\n-\n-  static size_t initial_log_size() {\n-    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n-    return clamp_log_size(estimate);\n-  }\n-\n-  static size_t grow_hint () {\n-    return ConcurrentTable::DEFAULT_GROW_HINT;\n-  }\n-\n- public:\n-  static void create() {\n-    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n-    _items_count = 0;\n-    _table_size = table_size();\n-    _resize = false;\n-  }\n-\n-  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n-#ifdef ASSERT\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      bool has_monitor = obj->mark().has_monitor();\n-      assert(has_monitor == (monitor != nullptr),\n-          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n-          BOOL_TO_STR(has_monitor), p2i(monitor));\n-    }\n-#endif\n-  }\n-\n-  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n-    ObjectMonitor* result = nullptr;\n-    Lookup lookup_f(obj);\n-    auto found_f = [&](ObjectMonitor** found) {\n-      assert((*found)->object_peek() == obj, \"must be\");\n-      result = *found;\n-    };\n-    _table->get(current, lookup_f, found_f);\n-    verify_monitor_get_result(obj, result);\n-    return result;\n-  }\n-\n-  static void try_notify_grow() {\n-    if (!_table->is_max_size_reached() && !AtomicAccess::load(&_resize)) {\n-      AtomicAccess::store(&_resize, true);\n-      if (Service_lock->try_lock()) {\n-        Service_lock->notify();\n-        Service_lock->unlock();\n-      }\n-    }\n-  }\n-\n-  static bool should_shrink() {\n-    \/\/ Not implemented;\n-    return false;\n-  }\n-\n-  static constexpr double GROW_LOAD_FACTOR = 0.75;\n-\n-  static bool should_grow() {\n-    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n-  }\n-\n-  static bool should_resize() {\n-    return should_grow() || should_shrink() || AtomicAccess::load(&_resize);\n-  }\n-\n-  template<typename Task, typename... Args>\n-  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n-    if (task.prepare(current)) {\n-      log_trace(monitortable)(\"Started to %s\", task_name);\n-      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n-      while (task.do_task(current, args...)) {\n-        task.pause(current);\n-        {\n-          ThreadBlockInVM tbivm(current);\n-        }\n-        task.cont(current);\n-      }\n-      task.done(current);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool grow(JavaThread* current) {\n-    ConcurrentTable::GrowTask grow_task(_table);\n-    if (run_task(current, grow_task, \"Grow\")) {\n-      _table_size = table_size(current);\n-      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool clean(JavaThread* current) {\n-    ConcurrentTable::BulkDeleteTask clean_task(_table);\n-    auto is_dead = [&](ObjectMonitor** monitor) {\n-      return (*monitor)->object_is_dead();\n-    };\n-    auto do_nothing = [&](ObjectMonitor** monitor) {};\n-    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n-    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n-  }\n-\n-  static bool resize(JavaThread* current) {\n-    LogTarget(Info, monitortable) lt;\n-    bool success = false;\n-\n-    if (should_grow()) {\n-      lt.print(\"Start growing with load factor %f\", get_load_factor());\n-      success = grow(current);\n-    } else {\n-      if (!_table->is_max_size_reached() && AtomicAccess::load(&_resize)) {\n-        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n-      }\n-      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n-      success = clean(current);\n-    }\n-\n-    AtomicAccess::store(&_resize, false);\n-\n-    return success;\n-  }\n-\n-  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n-    \/\/ Enter the monitor into the concurrent hashtable.\n-    ObjectMonitor* result = monitor;\n-    Lookup lookup_f(obj);\n-    auto found_f = [&](ObjectMonitor** found) {\n-      assert((*found)->object_peek() == obj, \"must be\");\n-      result = *found;\n-    };\n-    bool grow;\n-    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n-    verify_monitor_get_result(obj, result);\n-    if (grow) {\n-      try_notify_grow();\n-    }\n-    return result;\n-  }\n-\n-  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n-    LookupMonitor lookup_f(monitor);\n-    return _table->remove(current, lookup_f);\n-  }\n-\n-  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n-    LookupMonitor lookup_f(monitor);\n-    bool result = false;\n-    auto found_f = [&](ObjectMonitor** found) {\n-      result = true;\n-    };\n-    _table->get(current, lookup_f, found_f);\n-    return result;\n-  }\n-\n-  static void print_on(outputStream* st) {\n-    auto printer = [&] (ObjectMonitor** entry) {\n-       ObjectMonitor* om = *entry;\n-       oop obj = om->object_peek();\n-       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n-       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n-       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n-       st->cr();\n-       return true;\n-    };\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      _table->do_safepoint_scan(printer);\n-    } else {\n-      _table->do_scan(Thread::current(), printer);\n-    }\n-  }\n-};\n-\n-ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n-volatile size_t ObjectMonitorTable::_items_count = 0;\n-size_t ObjectMonitorTable::_table_size = 0;\n-volatile bool ObjectMonitorTable::_resize = false;\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":285,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -101,13 +101,13 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<HelpDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VersionDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CommandLineDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintSystemPropertiesDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintVMFlagsDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SetVMFlagDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMDynamicLibrariesDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMUptimeDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMInfoDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemGCDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<RunFinalizationDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<HeapInfoDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<FinalizerInfoDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<HelpDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VersionDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CommandLineDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintSystemPropertiesDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintVMFlagsDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SetVMFlagDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMDynamicLibrariesDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMUptimeDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VMInfoDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemGCDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<RunFinalizationDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<HeapInfoDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<FinalizerInfoDCmd>(full_export));\n@@ -115,10 +115,10 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<HeapDumpDCmd>(DCmd_Source_Internal | DCmd_Source_AttachAPI, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassHistogramDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemDictionaryDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassHierarchyDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassesDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SymboltableDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<StringtableDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<metaspace::MetaspaceDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintClassLayoutDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<EventLogDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<HeapDumpDCmd>(DCmd_Source_Internal | DCmd_Source_AttachAPI));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassHistogramDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemDictionaryDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassHierarchyDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassesDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SymboltableDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<StringtableDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<metaspace::MetaspaceDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PrintClassLayoutDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<EventLogDCmd>(full_export));\n@@ -126,1 +126,1 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JVMTIAgentLoadDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JVMTIAgentLoadDCmd>(full_export));\n@@ -130,1 +130,1 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JVMTIDataDumpDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JVMTIDataDumpDCmd>(full_export));\n@@ -132,1 +132,1 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ThreadDumpDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ThreadDumpDCmd>(full_export));\n@@ -134,1 +134,1 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ThreadDumpToFileDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ThreadDumpToFileDCmd>(full_export));\n@@ -136,7 +136,7 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadSchedulerDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadPollersDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassLoaderStatsDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassLoaderHierarchyDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompileQueueDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CodeListDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CodeCacheDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadSchedulerDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadPollersDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassLoaderStatsDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassLoaderHierarchyDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompileQueueDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CodeListDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CodeCacheDCmd>(full_export));\n@@ -144,3 +144,3 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PerfMapDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<TrimCLibcHeapDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<MallocInfoDcmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PerfMapDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<TrimCLibcHeapDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<MallocInfoDcmd>(full_export));\n@@ -149,2 +149,2 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemMapDCmd>(full_export, true,false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemDumpMapDCmd>(full_export, true,false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemMapDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemDumpMapDCmd>(full_export));\n@@ -152,1 +152,1 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CodeHeapAnalyticsDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CodeHeapAnalyticsDCmd>(full_export));\n@@ -154,5 +154,5 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesPrintDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesAddDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesRemoveDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesClearDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesPrintDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesAddDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesRemoveDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesClearDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export));\n@@ -163,4 +163,4 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStartRemoteDCmd>(jmx_agent_export_flags, true,false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStartLocalDCmd>(jmx_agent_export_flags, true,false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStopRemoteDCmd>(jmx_agent_export_flags, true,false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStatusDCmd>(jmx_agent_export_flags, true,false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStartRemoteDCmd>(jmx_agent_export_flags));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStartLocalDCmd>(jmx_agent_export_flags));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStopRemoteDCmd>(jmx_agent_export_flags));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JMXStatusDCmd>(jmx_agent_export_flags));\n@@ -169,2 +169,2 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<AOTEndRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<AOTEndRecordingDCmd>(full_export));\n@@ -173,1 +173,1 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<NMTDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<NMTDCmd>(full_export));\n@@ -196,2 +196,1 @@\n-      output()->print_cr(\"%s%s\", factory->name(),\n-                         factory->is_enabled() ? \"\" : \" [disabled]\");\n+      output()->print_cr(\"%s\", factory->name());\n@@ -207,2 +206,1 @@\n-      output()->print_cr(\"%s%s\", factory->name(),\n-                         factory->is_enabled() ? \"\" : \" [disabled]\");\n+      output()->print_cr(\"%s\", factory->name());\n@@ -227,2 +225,1 @@\n-      output()->print_cr(\"%s%s\", factory->name(),\n-                         factory->is_enabled() ? \"\" : \" [disabled]\");\n+      output()->print_cr(\"%s\", factory->name());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":55,"deletions":58,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -116,0 +117,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -9392,0 +9393,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -905,0 +907,1 @@\n+    @AOTSafeClassInitializer\n@@ -907,1 +910,1 @@\n-        static final int high;\n+        @Stable static int high;\n@@ -909,2 +912,1 @@\n-        @Stable\n-        static final Integer[] cache;\n+        @Stable static Integer[] cache;\n@@ -914,0 +916,5 @@\n+            runtimeSetup();\n+        }\n+\n+        @AOTRuntimeSetup\n+        private static void runtimeSetup() {\n@@ -929,22 +936,9 @@\n-            \/\/ Load IntegerCache.archivedCache from archive, if possible\n-            CDS.initializeFromArchive(IntegerCache.class);\n-            int size = (high - low) + 1;\n-\n-            \/\/ Use the archived cache if it exists and is large enough\n-            if (archivedCache == null || size > archivedCache.length) {\n-                Integer[] c = new Integer[size];\n-                int j = low;\n-                \/\/ If archive has Integer cache, we must use all instances from it.\n-                \/\/ Otherwise, the identity checks between archived Integers and\n-                \/\/ runtime-cached Integers would fail.\n-                int archivedSize = (archivedCache == null) ? 0 : archivedCache.length;\n-                for (int i = 0; i < archivedSize; i++) {\n-                    c[i] = archivedCache[i];\n-                    assert j == archivedCache[i];\n-                    j++;\n-                }\n-                \/\/ Fill the rest of the cache.\n-                for (int i = archivedSize; i < size; i++) {\n-                    c[i] = new Integer(j++);\n-                }\n-                archivedCache = c;\n+            Integer[] precomputed = null;\n+            if (cache != null) {\n+                \/\/ IntegerCache has been AOT-initialized.\n+                precomputed = cache;\n+            } else {\n+                \/\/ Legacy CDS archive support (to be deprecated):\n+                \/\/ Load IntegerCache.archivedCache from archive, if possible\n+                CDS.initializeFromArchive(IntegerCache.class);\n+                precomputed = archivedCache;\n@@ -952,1 +946,3 @@\n-            cache = archivedCache;\n+\n+            cache = loadOrInitializeCache(precomputed);\n+            archivedCache = cache; \/\/ Legacy CDS archive support (to be deprecated)\n@@ -957,0 +953,27 @@\n+        private static Integer[] loadOrInitializeCache(Integer[] precomputed) {\n+            int size = (high - low) + 1;\n+\n+            \/\/ Use the precomputed cache if it exists and is large enough\n+            if (precomputed != null && size <= precomputed.length) {\n+                return precomputed;\n+            }\n+\n+            Integer[] c = new Integer[size];\n+            int j = low;\n+            \/\/ If we loading a precomputed cache (from AOT cache or CDS archive),\n+            \/\/ we must use all instances from it.\n+            \/\/ Otherwise, the Integers from the AOT cache (or CDS archive) will not\n+            \/\/ have the same object identity as items in IntegerCache.cache[].\n+            int precomputedSize = (precomputed == null) ? 0 : precomputed.length;\n+            for (int i = 0; i < precomputedSize; i++) {\n+                c[i] = precomputed[i];\n+                assert j == precomputed[i];\n+                j++;\n+            }\n+            \/\/ Fill the rest of the cache.\n+            for (int i = precomputedSize; i < size; i++) {\n+                c[i] = new Integer(j++);\n+            }\n+            return c;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -926,0 +927,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -243,0 +244,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3846,0 +3846,2 @@\n+            \/\/ If the local class is defined inside a static method, and the instance creation expression\n+            \/\/ occurs in that same method, the creation occurs (technically) inside a static context, but that's ok.\n@@ -3850,0 +3852,2 @@\n+            } else if (isStatic(env1) || env1.enclClass.sym.isStatic()) {\n+                staticOnly = true;\n@@ -3851,1 +3855,0 @@\n-            if (isStatic(env1)) staticOnly = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+using testing::ContainsRegex;\n@@ -38,3 +39,13 @@\n-  stringStream ss;\n-  ClassPrinter::print_classes(\"java\/lang\/Object\", 0x03, &ss);\n-  const char* output = ss.freeze();\n+  stringStream s1;\n+  ClassPrinter::print_classes(\"java\/lang\/Object\", 0x03, &s1);\n+  const char* o1 = s1.freeze();\n+\n+  ASSERT_THAT(o1, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n+  ASSERT_THAT(o1, HasSubstr(\"method wait : (J)V\")) << \"must find java\/lang\/Object::wait\";\n+  ASSERT_THAT(o1, HasSubstr(\"method finalize : ()V\\n   0 return\")) << \"must find java\/lang\/Object::finalize and disasm\";\n+\n+  \/\/ \".\" should also work as separator in class name\n+  stringStream s2;\n+  ClassPrinter::print_classes(\"java.lang.Object\", 0x03, &s2);\n+  const char* o2 = s2.freeze();\n+  ASSERT_THAT(o2, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n@@ -42,3 +53,13 @@\n-  ASSERT_THAT(output, HasSubstr(\"class java\/lang\/Object loader data:\")) << \"must find java\/lang\/Object\";\n-  ASSERT_THAT(output, HasSubstr(\"method wait : (J)V\")) << \"must find java\/lang\/Object::wait\";\n-  ASSERT_THAT(output, HasSubstr(\"method finalize : ()V\\n   0 return\")) << \"must find java\/lang\/Object::finalize and disasm\";\n+  \/\/ 0x20 is PRINT_CLASS_DETAILS\n+  stringStream s3;\n+  ClassPrinter::print_classes(\"java.lang.Integer\", 0x20, &s3);\n+  const char* o3 = s3.freeze();\n+  ASSERT_THAT(o3, HasSubstr(\"class: java\/lang\/Integer mirror:\")) << \"must find java\/lang\/Integer\";\n+  ASSERT_THAT(o3, HasSubstr(\"InstanceKlass: java.lang.Integer {0x\")) << \"must print InstanceKlass\";\n+  ASSERT_THAT(o3, HasSubstr(\"Java mirror oop for java\/lang\/Integer:\")) << \"must print mirror oop\";\n+#if 0 \/\/ FIX: JDK-8374115\n+#if GTEST_USES_POSIX_RE\n+  \/\/ Complex regex not available on Windows\n+  ASSERT_THAT(o3, ContainsRegex(\"public static final 'MIN_VALUE' 'I'.* -2147483648 [(]0x80000000[)]\")) << \"must print static fields\";\n+#endif\n+#endif\n@@ -55,1 +76,1 @@\n-  ASSERT_THAT(o1, HasSubstr(\"class java\/lang\/Object loader data:\")) << \"must find java\/lang\/Object\";\n+  ASSERT_THAT(o1, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n@@ -63,1 +84,1 @@\n-  ASSERT_THAT(o2, HasSubstr(\"class java\/lang\/Object loader data:\")) << \"must find java\/lang\/Object\";\n+  ASSERT_THAT(o2, HasSubstr(\"class: java\/lang\/Object mirror:\")) << \"must find java\/lang\/Object\";\n@@ -67,0 +88,26 @@\n+\n+  \/\/ 0x02 is PRINT_BYTECODE\n+  \/\/ 0x04 is PRINT_BYTECODE_ADDRESS\n+  \/\/ 0x40 is PRINT_METHOD_DETAILS\n+  stringStream s3;\n+  ClassPrinter::print_methods(\"java.lang.Object\", \"wait:()V\", 0x46, &s3);\n+  const char* o3 = s3.freeze();\n+  ASSERT_THAT(o3, HasSubstr(\"method wait : ()V\")) << \"must find java\/lang\/Object::wait()\";\n+\n+#ifndef PRODUCT\n+  \/\/ PRINT_METHOD_DETAILS -- available only in debug builds\n+  ASSERT_THAT(o3, HasSubstr(\"{method}\")) << \"must print Method metadata\";\n+#if GTEST_USES_POSIX_RE\n+  \/\/ Complex regex not available on Windows\n+  ASSERT_THAT(o3, ContainsRegex(\"method holder:.*'java\/lang\/Object'\")) << \"must print Method metadata details\";\n+  ASSERT_THAT(o3, ContainsRegex(\"name: *'wait'\")) << \"must print Method metadata details\";\n+#endif\n+#endif\n+\n+#if GTEST_USES_POSIX_RE\n+  \/\/ Bytecodes: we should have at least one 'return' bytecide for Object.wait()\n+  \/\/ The print out should look like this:\n+  \/\/ 0x000000004adf73ad    5 return\n+  ASSERT_THAT(o3, ContainsRegex(\"0x[0-9a-f]+ +[0-9]+ +return\")) << \"must print return bytecode\";\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_classPrinter.cpp","additions":55,"deletions":8,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+compiler\/runtime\/Test7196199.java 8365196 windows-x64\n@@ -101,0 +102,1 @@\n+compiler\/c2\/cmove\/TestScalarConditionalMoveCmpObj.java    8374122 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -545,0 +545,1 @@\n+ -runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -731,10 +731,0 @@\n-    public static final String CON_D = PREFIX + \"CON_D\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(CON_D, \"ConD\");\n-    }\n-\n-    public static final String CON_F = PREFIX + \"CON_F\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(CON_F, \"ConF\");\n-    }\n-\n@@ -2856,1 +2846,1 @@\n-    public static final String X86_SCONV_D2I_AVX10 = PREFIX + \"X86_SCONV2_D2I_AVX10\" + POSTFIX;\n+    public static final String X86_SCONV_D2I_AVX10_2 = PREFIX + \"X86_SCONV_D2I_AVX10_2\" + POSTFIX;\n@@ -2858,1 +2848,1 @@\n-        machOnlyNameRegex(X86_SCONV_D2I_AVX10, \"convD2I_(reg_reg|reg_mem)_avx10\");\n+        machOnlyNameRegex(X86_SCONV_D2I_AVX10_2, \"convD2I_(reg_reg|reg_mem)_avx10_2\");\n@@ -2861,1 +2851,1 @@\n-    public static final String X86_SCONV_D2L_AVX10 = PREFIX + \"X86_SCONV_D2L_AVX10\" + POSTFIX;\n+    public static final String X86_SCONV_D2L_AVX10_2 = PREFIX + \"X86_SCONV_D2L_AVX10_2\" + POSTFIX;\n@@ -2863,1 +2853,1 @@\n-        machOnlyNameRegex(X86_SCONV_D2L_AVX10, \"convD2L_(reg_reg|reg_mem)_avx10\");\n+        machOnlyNameRegex(X86_SCONV_D2L_AVX10_2, \"convD2L_(reg_reg|reg_mem)_avx10_2\");\n@@ -2866,1 +2856,1 @@\n-    public static final String X86_SCONV_F2I_AVX10 = PREFIX + \"X86_SCONV_F2I_AVX10\" + POSTFIX;\n+    public static final String X86_SCONV_F2I_AVX10_2 = PREFIX + \"X86_SCONV_F2I_AVX10_2\" + POSTFIX;\n@@ -2868,1 +2858,1 @@\n-        machOnlyNameRegex(X86_SCONV_F2I_AVX10, \"convF2I_(reg_reg|reg_mem)_avx10\");\n+        machOnlyNameRegex(X86_SCONV_F2I_AVX10_2, \"convF2I_(reg_reg|reg_mem)_avx10_2\");\n@@ -2871,1 +2861,1 @@\n-    public static final String X86_SCONV_F2L_AVX10 = PREFIX + \"X86_SCONV_F2L_AVX10\" + POSTFIX;\n+    public static final String X86_SCONV_F2L_AVX10_2 = PREFIX + \"X86_SCONV_F2L_AVX10_2\" + POSTFIX;\n@@ -2873,1 +2863,1 @@\n-        machOnlyNameRegex(X86_SCONV_F2L_AVX10, \"convF2L_(reg_reg|reg_mem)_avx10\");\n+        machOnlyNameRegex(X86_SCONV_F2L_AVX10_2, \"convF2L_(reg_reg|reg_mem)_avx10_2\");\n@@ -2886,1 +2876,1 @@\n-    public static final String X86_VCAST_F2X_AVX10 = PREFIX + \"X86_VCAST_F2X_AVX10\" + POSTFIX;\n+    public static final String X86_VCAST_F2X_AVX10_2 = PREFIX + \"X86_VCAST_F2X_AVX10_2\" + POSTFIX;\n@@ -2888,1 +2878,1 @@\n-        machOnlyNameRegex(X86_VCAST_F2X_AVX10, \"castFtoX_(reg|mem)_avx10\");\n+        machOnlyNameRegex(X86_VCAST_F2X_AVX10_2, \"castFtoX_(reg|mem)_avx10_2\");\n@@ -2891,1 +2881,1 @@\n-    public static final String X86_VCAST_D2X_AVX10 = PREFIX + \"X86_VCAST_D2X_AVX10\" + POSTFIX;\n+    public static final String X86_VCAST_D2X_AVX10_2 = PREFIX + \"X86_VCAST_D2X_AVX10_2\" + POSTFIX;\n@@ -2893,1 +2883,1 @@\n-        machOnlyNameRegex(X86_VCAST_D2X_AVX10, \"castDtoX_(reg|mem)_avx10\");\n+        machOnlyNameRegex(X86_VCAST_D2X_AVX10_2, \"castDtoX_(reg|mem)_avx10_2\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1832,0 +1832,1 @@\n+  \/* FIX: JDK-8374116\n@@ -1861,1 +1862,1 @@\n-\n+  *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+java\/awt\/List\/NoEvents\/ProgrammaticChange.java 8201307 linux-all\n@@ -154,1 +155,0 @@\n-java\/awt\/Mixing\/AWT_Mixing\/HierarchyBoundsListenerMixingTest.java 8049405 macosx-all\n@@ -163,27 +163,1 @@\n-java\/awt\/Mixing\/AWT_Mixing\/JButtonInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JButtonOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JColorChooserOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JEditorPaneInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JEditorPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JLabelInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JLabelOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JListInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JListOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JPanelInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JPanelOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JProgressBarInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JProgressBarOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JScrollBarInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JScrollBarOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSliderInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSliderOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSpinnerInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JSpinnerOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTableInGlassPaneOverlapping.java 8158801,8357360 windows-all,linux-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTableOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextAreaInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextAreaOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextFieldInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JTextFieldOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JToggleButtonInGlassPaneOverlapping.java 8158801 windows-all\n-java\/awt\/Mixing\/AWT_Mixing\/JToggleButtonOverlapping.java 8158801 windows-all\n+java\/awt\/Mixing\/AWT_Mixing\/JTableInGlassPaneOverlapping.java 8357360 windows-all,linux-all\n@@ -651,3 +625,0 @@\n-javax\/sound\/sampled\/DirectAudio\/bug6372428.java                      8055097 generic-all\n-javax\/sound\/sampled\/Clip\/bug5070081.java                             8055097 generic-all\n-javax\/sound\/sampled\/DataLine\/LongFramePosition.java                  8055097 generic-all\n@@ -657,7 +628,0 @@\n-javax\/sound\/sampled\/Mixers\/DisabledAssertionCrash.java 7067310 generic-all\n-\n-javax\/sound\/midi\/Sequencer\/Recording.java 8167580,8265485 linux-all,macosx-aarch64\n-javax\/sound\/midi\/Sequencer\/Looping.java 8136897 generic-all\n-javax\/sound\/sampled\/Clip\/ClipIsRunningAfterStop.java 8307574 linux-x64\n-javax\/sound\/sampled\/Clip\/ClipFlushCrash.java 8308395 linux-x64\n-\n@@ -796,1 +760,0 @@\n-java\/awt\/Modal\/PrintDialogsTest\/PrintDialogsTest.java 8068378 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng BasicRecordSer\n+ * @run junit BasicRecordSer\n@@ -43,2 +43,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -48,4 +46,10 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.expectThrows;\n-import static org.testng.Assert.fail;\n+\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -56,0 +60,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -105,1 +110,0 @@\n-    @DataProvider(name = \"serializable\")\n@@ -125,1 +129,2 @@\n-    @Test(dataProvider = \"serializable\")\n+    @ParameterizedTest\n+    @MethodSource(\"serializable\")\n@@ -131,2 +136,7 @@\n-        assertEquals(objToSerialize, objDeserialized);\n-        assertEquals(objDeserialized, objToSerialize);\n+        if (objToSerialize.getClass().isArray()) {\n+            assertArrayEquals((Object[]) objDeserialized, (Object[]) objToSerialize);\n+            assertArrayEquals((Object[]) objToSerialize, (Object[]) objDeserialized);\n+        } else {\n+            assertEquals(objDeserialized, objToSerialize);\n+            assertEquals(objToSerialize, objDeserialized);\n+        }\n@@ -158,2 +168,2 @@\n-        assertEquals(objToSerialize, objDeserialized);\n-        assertEquals(objDeserialized, objToSerialize);\n+        Assertions.assertArrayEquals(objDeserialized, objToSerialize);\n+        Assertions.assertArrayEquals(objToSerialize, objDeserialized);\n@@ -175,2 +185,2 @@\n-        assertEquals(objToSerialize, objDeserialized);\n-        assertEquals(objDeserialized, objToSerialize);\n+        Assertions.assertArrayEquals(objDeserialized, objToSerialize);\n+        Assertions.assertArrayEquals(objToSerialize, objDeserialized);\n@@ -196,1 +206,0 @@\n-    @DataProvider(name = \"notSerializable\")\n@@ -213,1 +222,2 @@\n-    @Test(dataProvider = \"notSerializable\")\n+    @ParameterizedTest\n+    @MethodSource(\"notSerializable\")\n@@ -217,1 +227,1 @@\n-        NotSerializableException expected = expectThrows(NSE, () -> serialize(objToSerialize));\n+        NotSerializableException expected = Assertions.assertThrows(NSE, () -> serialize(objToSerialize));\n@@ -239,2 +249,2 @@\n-        assertEquals(objToSerialize, objDeserialized);\n-        assertEquals(e_ctrInvocationCount, 1);\n+        assertEquals(objToSerialize, objDeserialized);\n+        assertEquals(1, e_ctrInvocationCount);\n@@ -262,1 +272,1 @@\n-        NotSerializableException expected = expectThrows(NSE, () -> serialize(objToSerialize));\n+        NotSerializableException expected = Assertions.assertThrows(NSE, () -> serialize(objToSerialize));\n@@ -264,1 +274,1 @@\n-        assertEquals(g_ctrInvocationCount, 0);\n+        assertEquals(0, g_ctrInvocationCount);\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BasicRecordSer.java","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng RecordClassTest\n+ * @run junit RecordClassTest\n@@ -42,4 +42,6 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -51,0 +53,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -78,1 +81,0 @@\n-    @DataProvider(name = \"recordClasses\")\n@@ -91,1 +93,2 @@\n-    @Test(dataProvider = \"recordClasses\")\n+    @ParameterizedTest\n+    @MethodSource(\"recordClasses\")\n@@ -99,1 +102,1 @@\n-        assertEquals(recordClass, deserializedClass);\n+        assertEquals(recordClass, deserializedClass);\n@@ -104,1 +107,2 @@\n-    @Test(dataProvider = \"recordClasses\")\n+    @ParameterizedTest\n+    @MethodSource(\"recordClasses\")\n@@ -109,1 +113,1 @@\n-        assertEquals(osc.getSerialVersionUID(), expectedUID);\n+        assertEquals(expectedUID, osc.getSerialVersionUID());\n@@ -113,1 +117,1 @@\n-        assertEquals(osc.getSerialVersionUID(), expectedUID);\n+        assertEquals(expectedUID, osc.getSerialVersionUID());\n@@ -124,1 +128,0 @@\n-    @DataProvider(name = \"notSerRecordClasses\")\n@@ -134,1 +137,2 @@\n-    @Test(dataProvider = \"notSerRecordClasses\")\n+    @ParameterizedTest\n+    @MethodSource(\"notSerRecordClasses\")\n@@ -139,1 +143,1 @@\n-        assertEquals(osc, null);\n+        assertEquals(null, osc);\n@@ -143,1 +147,1 @@\n-        assertEquals(osc.getSerialVersionUID(), 0L);\n+        assertEquals(0L, osc.getSerialVersionUID());\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/RecordClassTest.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+tools\/javac\/preview\/PreviewAutoSuppress.java                                    8374021    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}