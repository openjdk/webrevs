{"files":[{"patch":"@@ -558,1 +558,1 @@\n-                         vmSymbols::isSubstitutable_name(),\n+                         UseAltSubstitutabilityMethod ? vmSymbols::isSubstitutableAlt_name() : vmSymbols::isSubstitutable_name(),\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1386,0 +1386,1 @@\n+  bool is_value_class = !class_access_flags.is_identity_class() && !class_access_flags.is_interface();\n@@ -1397,1 +1398,1 @@\n-  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);\n+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0) + (is_value_class ? 1 : 0);\n@@ -1578,0 +1579,16 @@\n+  if (!access_flags().is_identity_class() && !access_flags().is_interface()\n+      && _class_name != vmSymbols::java_lang_Object()) {\n+    \/\/ Acmp map required for abstract and concrete value classes\n+    FieldInfo::FieldFlags fflags2(0);\n+    fflags2.update_injected(true);\n+    fflags2.update_stable(true);\n+    AccessFlags aflags2(JVM_ACC_STATIC | JVM_ACC_FINAL);\n+    FieldInfo fi3(aflags2,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(acmp_maps_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(int_array_signature)),\n+                 0,\n+                 fflags2);\n+    int idx2 = _temp_field_info->append(fi3);\n+    _temp_field_info->adr_at(idx2)->set_index(idx2);\n+    _static_oop_count++;\n+  }\n@@ -5523,0 +5540,34 @@\n+  if (EnableValhalla && !access_flags().is_identity_class() && !access_flags().is_interface()\n+      && _class_name != vmSymbols::java_lang_Object()) {\n+    \/\/ Both abstract and concrete value classes need a field map for acmp\n+    ik->set_acmp_maps_offset(_layout_info->_acmp_maps_offset);\n+    \/\/ Current format of acmp maps:\n+    \/\/ All maps are stored contiguously in a single int array because it might\n+    \/\/ be too early to instantiate an Object array (to be investigated)\n+    \/\/ Format is:\n+    \/\/ [number_of_nonoop_entries][offset0][size[0][offset1][size1]...[oop_offset0][oop_offset1]...\n+    \/\/                           ^               ^\n+    \/\/                           |               |\n+    \/\/                           --------------------- Pair of integer describing a segment of\n+    \/\/                                                 contiguous non-oop fields\n+    \/\/ First element is the number of segment of contiguous non-oop fields\n+    \/\/ Then, each segment of contiguous non-oop fields is described by two consecutive elements:\n+    \/\/ the offset then the size.\n+    \/\/ After the last segment of contiguous non-oop fields, oop fields are described, one element\n+    \/\/ per oop field, containing the offset of the field.\n+    int nonoop_acmp_map_size = _layout_info->_nonoop_acmp_map->length() * 2;\n+    int oop_acmp_map_size = _layout_info->_oop_acmp_map->length();\n+    typeArrayOop map = oopFactory::new_intArray(nonoop_acmp_map_size + oop_acmp_map_size + 1, CHECK);\n+    typeArrayHandle map_h(THREAD, map);\n+    map_h->int_at_put(0, _layout_info->_nonoop_acmp_map->length());\n+    for (int i = 0; i < _layout_info->_nonoop_acmp_map->length(); i++) {\n+      map_h->int_at_put(i * 2 + 1, _layout_info->_nonoop_acmp_map->at(i).first);\n+      map_h->int_at_put(i * 2 + 2, _layout_info->_nonoop_acmp_map->at(i).second);\n+    }\n+    int oop_map_start = nonoop_acmp_map_size + 1;\n+    for (int i = 0; i < _layout_info->_oop_acmp_map->length(); i++) {\n+      map_h->int_at_put(oop_map_start + i, _layout_info->_oop_acmp_map->at(i));\n+    }\n+    ik->java_mirror()->obj_field_put(ik->acmp_maps_offset(), map_h());\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -74,0 +75,2 @@\n+  GrowableArray<Pair<int,int>>* _nonoop_acmp_map;\n+  GrowableArray<int>* _oop_acmp_map;\n@@ -86,0 +89,1 @@\n+  int _acmp_maps_offset;\n@@ -91,0 +95,8 @@\n+  FieldLayoutInfo() : oop_map_blocks(nullptr), _nonoop_acmp_map(nullptr), _oop_acmp_map(nullptr),\n+                      _instance_size(-1), _nonstatic_field_size(-1), _static_field_size(-1),\n+                      _payload_alignment(-1), _payload_offset(-1), _payload_size_in_bytes(-1),\n+                      _non_atomic_size_in_bytes(-1), _non_atomic_alignment(-1),\n+                      _atomic_layout_size_in_bytes(-1), _nullable_layout_size_in_bytes(-1),\n+                      _null_marker_offset(-1), _null_reset_value_offset(-1), _acmp_maps_offset(-1),\n+                      _has_nonstatic_fields(false), _is_naturally_atomic(false), _must_be_atomic(false),\n+                      _has_inline_fields(false), _is_empty_inline_klass(false) { }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+  _acmp_maps_offset(-1),\n@@ -406,0 +407,3 @@\n+    if (_field_info->adr_at(block->field_index())->name(_cp) == vmSymbols::acmp_maps_name()) {\n+      _acmp_maps_offset = block->offset();\n+    }\n@@ -1252,0 +1256,1 @@\n+  generate_acmp_maps();\n@@ -1291,0 +1296,150 @@\n+static int insert_segment(GrowableArray<Pair<int,int>>* map, int offset, int size, int last_idx) {\n+  if (map->is_empty()) {\n+    return map->append(Pair<int,int>(offset, size));\n+  }\n+  last_idx = last_idx == -1 ? 0 : last_idx;\n+  int start = map->adr_at(last_idx)->first > offset ? 0 : last_idx;\n+  bool inserted = false;\n+  for (int c = start; c < map->length(); c++) {\n+    if (offset == (map->adr_at(c)->first + map->adr_at(c)->second)) {\n+      \/\/contiguous to the last field, can be coalesced\n+      map->adr_at(c)->second = map->adr_at(c)->second + size;\n+      inserted = true;\n+      break;  \/\/ break out of the for loop\n+    }\n+    if (offset < (map->adr_at(c)->first)) {\n+      map->insert_before(c, Pair<int,int>(offset, size));\n+      last_idx = c;\n+      inserted = true;\n+      break;  \/\/ break out of the for loop\n+    }\n+  }\n+  if (!inserted) {\n+    last_idx = map->append(Pair<int,int>(offset, size));\n+  }\n+  return last_idx;\n+}\n+\n+static int insert_map_at_offset(GrowableArray<Pair<int,int>>* nonoop_map, GrowableArray<int>* oop_map,\n+                                const InstanceKlass* ik, int offset, int payload_offset, int last_idx) {\n+  oop mirror = ik->java_mirror();\n+  oop array = mirror->obj_field(ik->acmp_maps_offset());\n+  assert(array != nullptr, \"Sanity check\");\n+  typeArrayOop fmap = (typeArrayOop)array;\n+  typeArrayHandle fmap_h(Thread::current(), fmap);\n+  int nb_nonoop_field = fmap_h->int_at(0);\n+  int field_offset = offset - payload_offset;\n+  for (int i = 0; i < nb_nonoop_field; i++) {\n+    last_idx = insert_segment(nonoop_map,\n+                              field_offset + fmap_h->int_at( i * 2 + 1),\n+                              fmap_h->int_at( i * 2 + 2), last_idx);\n+  }\n+  int len = fmap_h->length();\n+  for (int i = nb_nonoop_field * 2 + 1; i < len; i++) {\n+      oop_map->append(field_offset + fmap_h->int_at(i));\n+  }\n+  return last_idx;\n+}\n+\n+static void split_after(GrowableArray<Pair<int,int>>* map, int idx, int head) {\n+  int offset = map->adr_at(idx)->first;\n+  int size = map->adr_at(idx)->second;\n+  if (size <= head) return;\n+  map->adr_at(idx)->first = offset + head;\n+  map->adr_at(idx)->second = size - head;\n+  map->insert_before(idx, Pair<int,int>(offset, head));\n+\n+}\n+\n+void FieldLayoutBuilder::generate_acmp_maps() {\n+  assert(_is_inline_type || _is_abstract_value, \"Must be done only for value classes (abstract or not)\");\n+\n+  \/\/ create\/initialize current class' maps\n+  \/\/ The Pair<int,int> values in the nonoop_acmp_map represent <offset,size> segments of memory\n+  _nonoop_acmp_map = new GrowableArray<Pair<int,int>>();\n+  _oop_acmp_map = new GrowableArray<int>();\n+  if (_is_empty_inline_class) return;\n+  \/\/ last_idx remembers the position of the last insertion in order to speed up the next insertion.\n+  \/\/ Local fields are processed in ascending offset order, so an insertion is very likely be performed\n+  \/\/ next to the previous insertion. However, in some cases local fields and inherited fields can be\n+  \/\/ interleaved, in which case the search of the insertion position cannot depend on the previous insertion.\n+  int last_idx = -1;\n+  if (_super_klass != nullptr && _super_klass != vmClasses::Object_klass()) {  \/\/ Assumes j.l.Object cannot have fields\n+    last_idx = insert_map_at_offset(_nonoop_acmp_map, _oop_acmp_map, _super_klass, 0, 0, last_idx);\n+  }\n+\n+  \/\/ Processing local fields\n+  LayoutRawBlock* b = _layout->blocks();\n+  while(b != _layout->last_block()) {\n+    switch(b->block_kind()) {\n+      case LayoutRawBlock::RESERVED:\n+      case LayoutRawBlock::EMPTY:\n+      case LayoutRawBlock::PADDING:\n+      case LayoutRawBlock::NULL_MARKER:\n+      case LayoutRawBlock::INHERITED: \/\/ inherited fields are handled during maps creation\/initialization\n+        \/\/ skip\n+        break;\n+\n+      case LayoutRawBlock::REGULAR:\n+        {\n+          FieldInfo* fi = _field_info->adr_at(b->field_index());\n+          if (fi->signature(_constant_pool)->starts_with(\"L\") || fi->signature(_constant_pool)->starts_with(\"[\")) {\n+            _oop_acmp_map->append(b->offset());\n+          } else {\n+            \/\/ Non-oop case\n+            last_idx = insert_segment(_nonoop_acmp_map, b->offset(), b->size(), last_idx);\n+          }\n+          break;\n+       }\n+      case LayoutRawBlock::FLAT:\n+        {\n+          InlineKlass* vk = b->inline_klass();\n+          last_idx = insert_map_at_offset(_nonoop_acmp_map, _oop_acmp_map, vk, b->offset(), vk->payload_offset(), last_idx);\n+          if (b->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n+            int null_marker_offset = b->offset() + vk->null_marker_offset_in_payload();\n+            last_idx = insert_segment(_nonoop_acmp_map, null_marker_offset, 1, last_idx);\n+            \/\/ Important note: the implementation assumes that for nullable flat fields, if the\n+            \/\/ null marker is zero (field is null), then all the fields of the flat field are also\n+            \/\/ zeroed. So, nullable flat field are not encoded different than null-free flat fields,\n+            \/\/ all fields are included in the map, plus the null marker\n+            \/\/ If it happens that the assumption above is wrong, then nullable flat fields would\n+            \/\/ require a dedicated section in the acmp map, and be handled differently: null_marker\n+            \/\/ comparison first, and if null markers are identical and non-zero, then conditional\n+            \/\/ comparison of the other fields\n+          }\n+        }\n+        break;\n+\n+    }\n+    b = b->next_block();\n+  }\n+\n+  \/\/ split segments into well-aligned blocks\n+  int idx = 0;\n+  while (idx < _nonoop_acmp_map->length()) {\n+    int offset = _nonoop_acmp_map->adr_at(idx)->first;\n+    int size = _nonoop_acmp_map->adr_at(idx)->second;\n+    int mod = offset % 8;\n+    switch (mod) {\n+      case 0:\n+        break;\n+      case 4:\n+        split_after(_nonoop_acmp_map, idx, 4);\n+        break;\n+      case 2:\n+      case 6:\n+        split_after(_nonoop_acmp_map, idx, 2);\n+        break;\n+      case 1:\n+      case 3:\n+      case 5:\n+      case 7:\n+        split_after(_nonoop_acmp_map, idx, 1);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+    idx++;\n+  }\n+}\n+\n@@ -1341,0 +1496,7 @@\n+  \/\/ Acmp maps are needed for both concrete and abstract value classes\n+  if (_is_inline_type || _is_abstract_value) {\n+    _info->_acmp_maps_offset = _static_layout->acmp_maps_offset();\n+    _info->_nonoop_acmp_map = _nonoop_acmp_map;\n+    _info->_oop_acmp_map = _oop_acmp_map;\n+  }\n+\n@@ -1414,0 +1576,10 @@\n+      st.print(\"Non-oop acmp map: \");\n+      for (int i = 0 ; i < _nonoop_acmp_map->length(); i++) {\n+        st.print(\"<%d,%d>, \", _nonoop_acmp_map->at(i).first,  _nonoop_acmp_map->at(i).second);\n+      }\n+      st.print_cr(\"\");\n+      st.print(\"oop acmp map: \");\n+      for (int i = 0 ; i < _oop_acmp_map->length(); i++) {\n+        st.print(\"%d, \", _oop_acmp_map->at(i));\n+      }\n+      st.print_cr(\"\");\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+  int _acmp_maps_offset;\n@@ -227,0 +228,4 @@\n+  int acmp_maps_offset() const {\n+    assert(_acmp_maps_offset != -1, \"Must have been set\");\n+    return _acmp_maps_offset;\n+  }\n@@ -284,0 +289,2 @@\n+  GrowableArray<Pair<int,int>>* _nonoop_acmp_map;\n+  GrowableArray<int>* _oop_acmp_map;\n@@ -340,0 +347,1 @@\n+  void generate_acmp_maps();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -532,0 +532,1 @@\n+  template(acmp_maps_name,                            \".acmp_maps\")                               \\\n@@ -778,0 +779,1 @@\n+  template(isSubstitutableAlt_name,                         \"isSubstitutableAlt\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-  methodHandle method(current, Universe::is_substitutable_method());\n+  methodHandle method(current, UseAltSubstitutabilityMethod ?  Universe::is_substitutableAlt_method() : Universe::is_substitutable_method());\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+static LatestMethodCache _is_substitutable_alt_cache;       \/\/ ValueObjectMethods.isSubstitutableAlt()\n@@ -1069,0 +1070,1 @@\n+Method* Universe::is_substitutableAlt_method()    { return _is_substitutable_alt_cache.get_method(); }\n@@ -1109,0 +1111,4 @@\n+  _is_substitutable_alt_cache.init(current,\n+                          vmClasses::ValueObjectMethods_klass(),\n+                          vmSymbols::isSubstitutableAlt_name()->as_C_string(),\n+                          vmSymbols::object_object_boolean_signature(), true);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  static Method*      is_substitutableAlt_method();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -596,0 +596,1 @@\n+  _acmp_maps_offset(0),\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,0 +295,3 @@\n+  int             _acmp_maps_offset;        \/\/ offset to injected static field storing acmp_maps for values classes\n+                                            \/\/ unfortunately, abstract values need one too so it cannot be stored in\n+                                            \/\/ the InlineKlassFixedBlock that only exist for InlineKlass.\n@@ -647,0 +650,6 @@\n+  int acmp_maps_offset() const {\n+    assert(_acmp_maps_offset != 0, \"Not initialized\");\n+    return _acmp_maps_offset;\n+  }\n+  void set_acmp_maps_offset(int offset) { _acmp_maps_offset = offset; }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2302,1 +2302,2 @@\n-  ciMethod* subst_method = ciEnv::current()->ValueObjectMethods_klass()->find_method(ciSymbols::isSubstitutable_name(), ciSymbols::object_object_boolean_signature());\n+  ciSymbol* subst_method_name = UseAltSubstitutabilityMethod ? ciSymbols::isSubstitutableAlt_name() : ciSymbols::isSubstitutable_name();\n+  ciMethod* subst_method = ciEnv::current()->ValueObjectMethods_klass()->find_method(subst_method_name, ciSymbols::object_object_boolean_signature());\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -965,0 +965,13 @@\n+UNSAFE_ENTRY(jarray, Unsafe_GetFieldMap0(JNIEnv* env, jobject unsafe, jclass clazz)) {\n+  oop mirror = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+\n+  if (!k->is_inline_klass()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Argument is not a concrete value class\");\n+  }\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  oop map = mirror->obj_field(vk->acmp_maps_offset());\n+  return (jarray) JNIHandles::make_local(THREAD, map);\n+} UNSAFE_END\n+\n+\n@@ -1242,0 +1255,1 @@\n+    {CC \"getFieldMap0\",       CC \"(Ljava\/lang\/Class;)[I\", FN_PTR(Unsafe_GetFieldMap0)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2053,0 +2053,3 @@\n+  product(bool, UseAltSubstitutabilityMethod, false,                        \\\n+          \"Use alternate version of the isSubstitutable method to \"         \\\n+          \"compare value class instances\")                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1212,1 +1212,2 @@\n-    Method* is_subst = vmClasses::ValueObjectMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n+    Symbol* subst_method_name = UseAltSubstitutabilityMethod ? vmSymbols::isSubstitutableAlt_name() : vmSymbols::isSubstitutable_name();\n+    Method* is_subst = vmClasses::ValueObjectMethods_klass()->find_method(subst_method_name, vmSymbols::object_object_boolean_signature());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -54,0 +55,1 @@\n+\n@@ -75,0 +77,1 @@\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -1405,0 +1408,43 @@\n+    private static boolean isSubstitutableAlt(Object a, Object b) {\n+      \/\/ This method assumes a and b are not null and their are both instances of the same value class\n+      final Unsafe U = UNSAFE;\n+      int[] map = U.getFieldMap(a.getClass());\n+      int nbNonRef = map[0];\n+      for (int i = 0; i < nbNonRef; i++) {\n+        int offset = map[i * 2 + 1];\n+        int size = map[i * 2 + 2];\n+        int nlong = size \/ 8;\n+        for (int j = 0; j < nlong; j++) {\n+          long la = U.getLong(a, offset);\n+          long lb = U.getLong(b, offset);\n+          if (la != lb) return false;\n+        }\n+        size -= nlong * 8;\n+        int nint = size \/ 4;\n+        for (int j = 0; j < nint; j++) {\n+          int ia = U.getInt(a, offset);\n+          int ib = U.getInt(b, offset);\n+          if (ia != ib) return false;\n+        }\n+        size -= nint * 4;\n+        int nshort = size \/ 2;\n+        for (int j = 0; j < nshort; j++) {\n+          short sa = U.getShort(a, offset);\n+          short sb = U.getShort(b, offset);\n+          if (sa != sb) return false;\n+        }\n+        size -= nshort * 2;\n+        for (int j = 0; j < size; j++) {\n+          byte ba = U.getByte(a, offset);\n+          byte bb = U.getByte(b, offset);\n+          if (ba != bb) return false;\n+        }\n+      }\n+      for (int i = nbNonRef * 2 + 1; i < map.length; i++) {\n+        int offset = map[i];\n+        Object oa = U.getReference(a, offset);\n+        Object ob = U.getReference(b, offset);\n+        if (oa != ob) return false;\n+      }\n+      return true;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1520,0 +1520,7 @@\n+    public int[] getFieldMap(Class<? extends Object> c) {\n+      if (c == null) {\n+        throw new NullPointerException();\n+      }\n+      return getFieldMap0(c);\n+    }\n+\n@@ -4452,0 +4459,1 @@\n+    private native int[] getFieldMap0(Class <?> c);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -283,0 +283,2 @@\n+        \/\/ With the alternate isSubstitutable() method, type recursion is handled differently\n+        \/\/ and the line below won't throw a SOE\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}