{"files":[{"patch":"@@ -59,1 +59,0 @@\n-  \/\/ciConstant element_value_impl(arrayOop ary, int index, int offset);\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2132,0 +2132,8 @@\n+      \/\/ Expending a flat load atomically means that we get a chunk of memory spanning multiple fields\n+      \/\/ that we chop with bitwise operations. That is too subtle for some optimizations, especially\n+      \/\/ constant folding when fields are constant. But if the flattened field being accessed is read-only\n+      \/\/ then no concurrent writes can happen and non-atomic loads are fine, allowing better optimizations.\n+      \/\/ A way for fields to be read-only is to be stable and already initialized. Here, we check if the\n+      \/\/ field being accessed is stable, and if the null marker of the field\/array element is non-zero.\n+      \/\/ If so, we know that the stable value was initialized away from the default value (null), and\n+      \/\/ that we can assume it's read-only, so can the load can be performed non-atomically.\n@@ -2134,3 +2142,2 @@\n-        const Type* base_type = igvn.type(loadn->base());\n-        const TypeOopPtr* oopptr = base_type->isa_oopptr();\n-        ciObject* oop = oopptr->const_oop();\n+        const TypeOopPtr* base_type = igvn.type(loadn->base())->isa_oopptr();\n+        ciObject* oop = base_type->const_oop();\n@@ -2147,1 +2154,1 @@\n-          non_atomic_is_fine = FoldStableValues && field->is_stable() && cst.is_valid() && cst.as_boolean();\n+          non_atomic_is_fine = field->is_stable() && cst.is_valid() && cst.as_boolean();\n@@ -2149,1 +2156,1 @@\n-          const TypeAryPtr* aryptr = oopptr->is_aryptr();\n+          const TypeAryPtr* aryptr = base_type->is_aryptr();\n@@ -2151,1 +2158,1 @@\n-          non_atomic_is_fine = FoldStableValues && aryptr->is_stable() && elt.is_valid() && !elt.is_null_or_zero();\n+          non_atomic_is_fine = aryptr->is_stable() && elt.is_valid() && !elt.is_null_or_zero();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-      }\n+  }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-        \/\/ No barriers expected for plain fields.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-        \/\/ No barriers expected for plain fields.\n@@ -116,1 +115,0 @@\n-        \/\/ Reference inits do not have membars.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}