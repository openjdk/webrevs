{"files":[{"patch":"@@ -71,1 +71,1 @@\n-  ciConstant element_value_by_offset(intptr_t element_offset);\n+  virtual ciConstant element_value_by_offset(intptr_t element_offset);\n","filename":"src\/hotspot\/share\/ci\/ciArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-  ciType* element_type();       \/\/ JLS calls this the \"component type\"\n-  ciType* base_element_type();  \/\/ JLS calls this the \"element type\"\n+  ciType* element_type();       \/\/ JLS calls this the \"component type\", (T[] for T[][])\n+  ciType* base_element_type();  \/\/ JLS calls this the \"element type\", (T for T[][])\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class       ciFlatArray;\n@@ -112,0 +113,1 @@\n+friend class ciFlatArray;              \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\/\/ This assumes `this->is_valid()`, otherwise, `as_object` will assert.\n@@ -65,1 +66,1 @@\n-void ciConstant::print() {\n+void ciConstant::print() const {\n","filename":"src\/hotspot\/share\/ci\/ciConstant.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  void print();\n+  void print() const;\n","filename":"src\/hotspot\/share\/ci\/ciConstant.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  _is_constant = declared_field->is_strict() && declared_field->is_final();\n+  _is_constant = (declared_field->is_strict() && declared_field->is_final()) || declared_field->is_constant();\n@@ -268,1 +268,1 @@\n-  _is_constant = declared_field->is_strict() && declared_field->is_final();\n+  _is_constant = (declared_field->is_strict() && declared_field->is_final()) || declared_field->is_constant();\n@@ -507,1 +507,1 @@\n-void ciField::print() {\n+void ciField::print() const {\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  void print();\n+  void print() const;\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"ci\/ciArray.hpp\"\n+#include \"ci\/ciConstant.hpp\"\n+#include \"ci\/ciField.hpp\"\n+#include \"ci\/ciFlatArray.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n+#include \"ci\/ciUtilities.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+ciConstant ciFlatArray::null_marker_of_element_by_offset_impl(arrayOop ary, int index) {\n+  if (ary == nullptr) {\n+    return ciConstant();\n+  }\n+  assert(ary->is_array(), \"\");\n+  if (index < 0 || index >= ary->length()) {\n+    return ciConstant();\n+  }\n+    assert(ary->is_objArray(), \"\");\n+    flatArrayOop objary = (flatArrayOop) ary;\n+    jboolean elem = objary->null_marker_of_obj_at(index);\n+    return ciConstant(T_BOOLEAN, elem);\n+}\n+\n+ciConstant ciFlatArray::check_constant_null_marker_cache(int off) {\n+  if (_constant_null_markers != nullptr) {\n+    for (int i = 0; i < _constant_null_markers->length(); ++i) {\n+      ConstantValue cached_val = _constant_null_markers->at(i);\n+      if (cached_val.off() == off) {\n+        return cached_val.value();\n+      }\n+    }\n+  }\n+  return ciConstant();\n+}\n+\n+void ciFlatArray::add_to_constant_null_marker_cache(int off, ciConstant val) {\n+  assert(val.is_valid(), \"value must be valid\");\n+  assert(!check_constant_value_cache(off, val.basic_type()).is_valid(), \"duplicate\");\n+  if (_constant_null_markers == nullptr) {\n+    Arena* arena = CURRENT_ENV->arena();\n+    _constant_null_markers = new (arena) GrowableArray<ConstantValue>(arena, 1, 0, ConstantValue());\n+  }\n+  _constant_null_markers->append(ConstantValue(off, val));\n+}\n+\n+\/\/ Current value of an element.\n+\/\/ Returns T_ILLEGAL if there is no element at the given index.\n+ciConstant ciFlatArray::null_marker_of_element_by_index(int index) {\n+  ciConstant value = check_constant_null_marker_cache(index);\n+  if (value.is_valid()) {\n+    return value;\n+  }\n+  GUARDED_VM_ENTRY(\n+      value = null_marker_of_element_by_offset_impl(get_arrayOop(), index);)\n+  add_to_constant_null_marker_cache(index, value);\n+  return value;\n+}\n+\n+ciConstant ciFlatArray::null_marker_of_element_by_offset(intptr_t element_offset) {\n+  FlatArrayKlass* faklass;\n+  GUARDED_VM_ENTRY(faklass = FlatArrayKlass::cast(get_arrayOop()->klass());)\n+  int lh = faklass->layout_helper();\n+  int shift = Klass::layout_helper_log2_element_size(lh);\n+  intptr_t header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+  intptr_t index = (element_offset - header) >> shift;\n+  intptr_t offset = header + (index << shift);\n+  if (offset != element_offset || index != (jint) index || index < 0 || index >= length()) {\n+    return ciConstant();\n+  }\n+  return null_marker_of_element_by_index((jint) index);\n+}\n+\n+ciConstant ciFlatArray::element_value_by_offset(intptr_t element_offset) {\n+  FlatArrayKlass* faklass;\n+  GUARDED_VM_ENTRY(faklass = FlatArrayKlass::cast(get_arrayOop()->klass());)\n+  int lh = faklass->layout_helper();\n+  int shift = Klass::layout_helper_log2_element_size(lh);\n+  intptr_t header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+  intptr_t index = (element_offset - header) >> shift;\n+  intptr_t offset = header + (index << shift);\n+  if (offset != element_offset || index != (jint) index || index < 0 || index >= length()) {\n+    return ciConstant();\n+  }\n+  return element_value((jint) index);\n+}\n+\n+ciConstant ciFlatArray::field_value_by_offset(intptr_t field_offset) {\n+  ciInlineKlass* elt_type = element_type()->as_inline_klass();\n+  FlatArrayKlass* faklass;\n+  GUARDED_VM_ENTRY(faklass = FlatArrayKlass::cast(get_arrayOop()->klass());)\n+  int lh = faklass->layout_helper();\n+  int shift = Klass::layout_helper_log2_element_size(lh);\n+  intptr_t header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+  intptr_t index = (field_offset - header) >> shift;\n+  intptr_t element_offset = header + (index << shift);\n+  int field_offset_in_element = (int)(field_offset - element_offset);\n+  ciField* field = elt_type->get_field_by_offset(elt_type->payload_offset() + field_offset_in_element, false);\n+  if (field == nullptr) {\n+    if (field_offset_in_element != elt_type->null_marker_offset_in_payload()) {\n+      return ciConstant();\n+    }\n+  }\n+\n+  if (index != (jint) index || index < 0 || index >= length()) {\n+    return ciConstant();\n+  }\n+  ciConstant elt = field_value((jint) index, field);\n+\n+  return elt;\n+}\n+\n+ciConstant ciFlatArray::field_value(int index, ciField* field) {\n+  BasicType elembt = element_basic_type();\n+  ciConstant value = check_constant_value_cache(index, elembt);\n+  if (value.is_valid()) {\n+    if (field == nullptr) {\n+      return value.as_object()->as_instance()->null_marker_value();\n+    }\n+    return value.as_object()->as_instance()->field_value(field);\n+  }\n+  GUARDED_VM_ENTRY(\n+    value = element_value_impl(T_OBJECT, get_arrayOop(), index);\n+  )\n+\n+  add_to_constant_value_cache(index, value);\n+\n+  if (field == nullptr) {\n+    return value.as_object()->as_instance()->null_marker_value();\n+  }\n+  return value.as_object()->as_instance()->field_value(field);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.cpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-  const char* type_string() { return \"ciFlatArray\"; }\n+  const char* type_string() override { return \"ciFlatArray\"; }\n@@ -44,1 +44,17 @@\n-  bool is_flat()      { return true; }\n+  bool is_flat_array() const override { return true; }\n+  bool is_flat() override { return true; }\n+\n+  \/\/ Current value of an element at the specified offset.\n+  \/\/ Returns T_ILLEGAL if there is no element at the given offset.\n+  ciConstant element_value_by_offset(intptr_t element_offset) override;\n+  ciConstant field_value_by_offset(intptr_t field_offset);\n+  ciConstant field_value(int index, ciField* field);\n+  ciConstant null_marker_of_element_by_offset(intptr_t element_offset);\n+  ciConstant null_marker_of_element_by_index(int index);\n+\n+private:\n+  ciConstant null_marker_of_element_by_offset_impl(arrayOop ary, int index);\n+  ciConstant check_constant_null_marker_cache(int off);\n+  void add_to_constant_null_marker_cache(int off, ciConstant val);\n+\n+  GrowableArray<ConstantValue>* _constant_null_markers = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.hpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -103,0 +104,9 @@\n+\/\/ Constant value of the null marker.\n+ciConstant ciInstance::null_marker_value() {\n+  if (!klass()->is_inlinetype()) {\n+    return ciConstant();\n+  }\n+  ciInlineKlass* ik = klass()->as_inline_klass();\n+  return field_value_impl(T_BOOLEAN, ik->null_marker_offset_in_payload() + ik->payload_offset());\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  ciConstant null_marker_value();\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+protected:\n@@ -76,0 +77,1 @@\n+private:\n@@ -131,0 +133,1 @@\n+  virtual bool is_flat_array()        const { return false; }\n@@ -185,0 +188,4 @@\n+  ciFlatArray* as_flat_array() {\n+    assert(is_flat_array(), \"bad cast\");\n+    return (ciFlatArray*)this;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciObject.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  inline jboolean null_marker_of_obj_at(int index) const;\n+  inline jboolean null_marker_of_obj_at(int index, TRAPS) const;\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,15 @@\n+inline jboolean flatArrayOopDesc::null_marker_of_obj_at(int index) const {\n+  EXCEPTION_MARK;\n+  return null_marker_of_obj_at(index, THREAD);\n+}\n+\n+inline jboolean flatArrayOopDesc::null_marker_of_obj_at(int index, TRAPS) const {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n+  FlatArrayKlass* faklass = FlatArrayKlass::cast(klass());\n+  InlineKlass* vk = InlineKlass::cast(faklass->element_klass());\n+  char* this_oop = (char*) (oopDesc*) this;\n+  char* val = (char*) value_at_addr(index, faklass->layout_helper());\n+  ptrdiff_t offset = val - this_oop + (ptrdiff_t)vk->null_marker_offset_in_payload();\n+  return bool_field(offset);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciFlatArray.hpp\"\n@@ -2097,1 +2098,36 @@\n-      n->as_LoadFlat()->expand_atomic(igvn);\n+      LoadFlatNode* loadn = n->as_LoadFlat();\n+      \/\/ Expending a flat load atomically means that we get a chunk of memory spanning multiple fields\n+      \/\/ that we chop with bitwise operations. That is too subtle for some optimizations, especially\n+      \/\/ constant folding when fields are constant. But if the flattened field being accessed is read-only\n+      \/\/ then no concurrent writes can happen and non-atomic loads are fine, allowing better optimizations.\n+      \/\/ A way for fields to be read-only is to be stable and already initialized. Here, we check if the\n+      \/\/ field being accessed is stable, and if the null marker of the field\/array element is non-zero.\n+      \/\/ If so, we know that the stable value was initialized away from the default value (null), and\n+      \/\/ that we can assume it's read-only, so can the load can be performed non-atomically.\n+      bool non_atomic_is_fine = false;\n+      if (FoldStableValues) {\n+        const TypeOopPtr* base_type = igvn.type(loadn->base())->isa_oopptr();\n+        ciObject* oop = base_type->const_oop();\n+        ciInstance* holder = oop != nullptr && oop->is_instance() ? oop->as_instance() : nullptr;\n+        ciArray* array = oop != nullptr && oop->is_array() ? oop->as_array() : nullptr;\n+        int off = igvn.type(loadn->ptr())->isa_ptr()->offset();\n+\n+        if (holder != nullptr) {\n+          ciKlass* klass = holder->klass();\n+          ciInstanceKlass* iklass = klass->as_instance_klass();\n+          const ciField* field = iklass->get_non_flat_field_by_offset(off);\n+          ciField* nm_field = iklass->get_field_by_offset(field->null_marker_offset(), false);\n+          ciConstant cst = nm_field != nullptr ? holder->field_value(nm_field) : ciConstant() \/* invalid *\/;\n+          non_atomic_is_fine = field->is_stable() && cst.is_valid() && cst.as_boolean();\n+        } else if (array != nullptr) {\n+          const TypeAryPtr* aryptr = base_type->is_aryptr();\n+          ciConstant elt = ((ciFlatArray*)array)->null_marker_of_element_by_offset(off);\n+          non_atomic_is_fine = aryptr->is_stable() && elt.is_valid() && !elt.is_null_or_zero();\n+        }\n+      }\n+\n+      if (non_atomic_is_fine) {\n+        loadn->expand_non_atomic(igvn);\n+      } else {\n+        loadn->expand_atomic(igvn);\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2233,1 +2233,1 @@\n-        const Type* con_type = Type::make_constant_from_array_element(aobj->as_array(), off,\n+        const Type* con_type = Type::make_constant_from_array_element(aobj->as_array(), off, ary->field_offset().get(),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArray.hpp\"\n@@ -380,2 +381,1 @@\n-\/\/ Try to constant-fold a stable array element.\n-const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,\n+static const Type* make_constant_from_non_flat_array_element(ciArray* array, int off, int stable_dimension,\n@@ -401,0 +401,29 @@\n+static const Type* make_constant_from_flat_array_element(ciFlatArray* array, int off, int field_offset, int stable_dimension,\n+                                                         BasicType loadbt, bool is_unsigned_load) {\n+  \/\/ Decode the results of GraphKit::array_element_address.\n+  ciConstant element_value = array->field_value_by_offset(off + field_offset);\n+  if (element_value.basic_type() == T_ILLEGAL) {\n+    return nullptr; \/\/ wrong offset\n+  }\n+  ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);\n+\n+  assert(con.basic_type() != T_ILLEGAL, \"elembt=%s; loadbt=%s; unsigned=%d\",\n+         type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);\n+\n+  if (con.is_valid() &&          \/\/ not a mismatched access\n+      !con.is_null_or_zero()) {  \/\/ not a default value\n+    bool is_narrow_oop = (loadbt == T_NARROWOOP);\n+    return Type::make_from_constant(con, \/*require_constant=*\/true, stable_dimension, is_narrow_oop, \/*is_autobox_cache=*\/false);\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ Try to constant-fold a stable array element.\n+const Type* Type::make_constant_from_array_element(ciArray* array, int off, int field_offset, int stable_dimension,\n+                                                   BasicType loadbt, bool is_unsigned_load) {\n+  if (array->is_flat()) {\n+    return make_constant_from_flat_array_element(array->as_flat_array(), off, field_offset, stable_dimension, loadbt, is_unsigned_load);\n+  }\n+  return make_constant_from_non_flat_array_element(array, off, stable_dimension, loadbt, is_unsigned_load);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+                                                      int field_offset,\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-compiler\/c2\/irTests\/stable\/StableRefArrayTest.java                                               8372700 generic-all\n-compiler\/c2\/irTests\/stable\/StableRefFinalTest.java                                               8372700 generic-all\n-compiler\/c2\/irTests\/stable\/StableRefPlainTest.java                                               8372700 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-enable-preview.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8372700\n+ * @summary Check stable flat array field folding\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.stable.StableFlatArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.valhalla.inlinetypes.*;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.test.lib.Asserts;\n+\n+public class StableFlatArrayTest {\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+                tf.addFlags(\n+                        \"--enable-preview\",\n+                        \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"\n+                )\n+                .start();\n+    }\n+\n+    static final Integer[] NULL_RESTRICTED_NON_ATOMIC_ARRAY = (Integer[]) ValueClass.newNullRestrictedNonAtomicArray(Integer.class, 1, 42);\n+    static final Integer[] NULL_RESTRICTED_ATOMIC_ARRAY = (Integer[]) ValueClass.newNullRestrictedAtomicArray(Integer.class, 1, 43);\n+    static final Integer[] NULLABLE_ATOMIC_ARRAY = (Integer[]) ValueClass.newNullableAtomicArray(Integer.class, 1);\n+    static {\n+        NULLABLE_ATOMIC_ARRAY[0] = 44;\n+    }\n+\n+    static final int NULL_RESTRICTED_NON_ATOMIC_CASE = 1;\n+    static final int NULL_RESTRICTED_ATOMIC_CASE = 2;\n+    static final int NULLABLE_ATOMIC_CASE = 3;\n+\n+    static class Carrier {\n+        @Stable\n+        Integer[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case NULL_RESTRICTED_NON_ATOMIC_CASE:\n+                    field = NULL_RESTRICTED_NON_ATOMIC_ARRAY;\n+                    break;\n+                case NULL_RESTRICTED_ATOMIC_CASE:\n+                    field = NULL_RESTRICTED_ATOMIC_ARRAY;\n+                    break;\n+                case NULLABLE_ATOMIC_CASE:\n+                    field = NULLABLE_ATOMIC_ARRAY;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+    }\n+\n+    static final Carrier NULL_RESTRICTED_NON_ATOMIC_CARRIER = new Carrier(NULL_RESTRICTED_NON_ATOMIC_CASE);\n+    static final Carrier NULL_RESTRICTED_ATOMIC_CARRIER = new Carrier(NULL_RESTRICTED_ATOMIC_CASE);\n+    static final Carrier NULLABLE_ATOMIC_CARRIER = new Carrier(NULLABLE_ATOMIC_CASE);\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.MEMBAR})\n+    static int testNullRestrictedNonAtomic() {\n+        Integer[] is = NULL_RESTRICTED_NON_ATOMIC_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"testNullRestrictedNonAtomic\")\n+    public void testNullRestrictedNonAtomic_verifier() {\n+        int result = testNullRestrictedNonAtomic();\n+        Asserts.assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.MEMBAR})\n+    static int testNullRestrictedAtomic() {\n+        Integer[] is = NULL_RESTRICTED_ATOMIC_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"testNullRestrictedAtomic\")\n+    public void testNullRestrictedAtomic_verifier() {\n+        int result = testNullRestrictedAtomic();\n+        Asserts.assertEquals(result, 43);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.MEMBAR})\n+    static int testNullableAtomic() {\n+        Integer[] is = NULLABLE_ATOMIC_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"testNullableAtomic\")\n+    public void testNullableAtomic_verifier() {\n+        int result = testNullableAtomic();\n+        Asserts.assertEquals(result, 44);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableFlatArrayTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -115,1 +115,6 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    \/\/ We have barriers with valhalla from the atomic expansion of the LoadFlatNode\n+    \/\/ Indeed, since the array element is not initialized, it is not known to be constant yet,\n+    \/\/ and so, the LoadFlat cannot be expanded non-atomically. We need barriers to synchronize\n+    \/\/ the LoadFlat and potential updates to field of the flatten array element.\n+    @IR(applyIfAnd = {\"UseArrayFlattening\", \"true\", \"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \"> 0\" })\n@@ -118,1 +123,0 @@\n-        \/\/ No barriers expected for plain fields.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,1 +74,6 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    \/\/ We have barriers with valhalla from the atomic expansion of the LoadFlatNode\n+    \/\/ Indeed, since the field is not initialized, it is not known to be constant yet,\n+    \/\/ and so, the LoadFlat cannot be expanded non-atomically. We need barriers to synchronize\n+    \/\/ the LoadFlat and potential updates to sub-field of the flatten field.\n+    @IR(applyIfAnd = {\"UseFieldFlattening\", \"true\", \"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \">0\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefFinalTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -81,1 +81,6 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    \/\/ We have barriers with valhalla from the atomic expansion of the LoadFlatNode\n+    \/\/ Indeed, since the field is not initialized, it is not known to be constant yet,\n+    \/\/ and so, the LoadFlat cannot be expanded non-atomically. We need barriers to synchronize\n+    \/\/ the LoadFlat and potential updates to sub-field of the flatten field.\n+    @IR(applyIfAnd = {\"UseFieldFlattening\", \"true\", \"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \">0\" })\n@@ -84,1 +89,0 @@\n-        \/\/ No barriers expected for plain fields.\n@@ -112,1 +116,4 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    \/\/ We have barriers from the atomic expansion of the StoreFlatNode. Store is not eliminated with\n+    \/\/ or without Valhalla, but Valhalla's StoreFlat require barriers.\n+    @IR(applyIfAnd = {\"UseFieldFlattening\", \"true\", \"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \">0\" })\n@@ -114,1 +121,0 @@\n-        \/\/ Reference inits do not have membars.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}