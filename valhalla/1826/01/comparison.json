{"files":[{"patch":"@@ -71,1 +71,1 @@\n-  ciConstant element_value_by_offset(intptr_t element_offset);\n+  virtual ciConstant element_value_by_offset(intptr_t element_offset);\n","filename":"src\/hotspot\/share\/ci\/ciArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-  ciType* element_type();       \/\/ JLS calls this the \"component type\"\n-  ciType* base_element_type();  \/\/ JLS calls this the \"element type\"\n+  ciType* element_type();       \/\/ JLS calls this the \"component type\", (T[] for T[][])\n+  ciType* base_element_type();  \/\/ JLS calls this the \"element type\", (T for T[][])\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class       ciFlatArray;\n@@ -111,0 +112,1 @@\n+friend class ciFlatArray;              \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\/\/ This assumes `this->is_valid()`, otherwise, `as_object` will assert.\n","filename":"src\/hotspot\/share\/ci\/ciConstant.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  _is_constant = declared_field->is_strict() && declared_field->is_final();\n+  _is_constant = (declared_field->is_strict() && declared_field->is_final()) || declared_field->is_constant();\n@@ -268,1 +268,1 @@\n-  _is_constant = declared_field->is_strict() && declared_field->is_final();\n+  _is_constant = (declared_field->is_strict() && declared_field->is_final()) || declared_field->is_constant();\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"ci\/ciArray.hpp\"\n+#include \"ci\/ciConstant.hpp\"\n+#include \"ci\/ciField.hpp\"\n+#include \"ci\/ciFlatArray.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n+#include \"ci\/ciUtilities.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+ciConstant ciFlatArray::null_marker_of_element_by_offset_impl(arrayOop ary, int index) {\n+  if (ary == nullptr) {\n+    return ciConstant();\n+  }\n+  assert(ary->is_array(), \"\");\n+  if (index < 0 || index >= ary->length()) {\n+    return ciConstant();\n+  }\n+    assert(ary->is_objArray(), \"\");\n+    flatArrayOop objary = (flatArrayOop) ary;\n+    jboolean elem = objary->null_marker_of_obj_at(index);\n+    return ciConstant(T_BOOLEAN, elem);\n+}\n+\n+ciConstant ciFlatArray::check_constant_null_marker_cache(int off) {\n+  if (_constant_null_markers != nullptr) {\n+    for (int i = 0; i < _constant_null_markers->length(); ++i) {\n+      ConstantValue cached_val = _constant_null_markers->at(i);\n+      if (cached_val.off() == off) {\n+        return cached_val.value();\n+      }\n+    }\n+  }\n+  return ciConstant();\n+}\n+\n+void ciFlatArray::add_to_constant_null_marker_cache(int off, ciConstant val) {\n+  assert(val.is_valid(), \"value must be valid\");\n+  assert(!check_constant_value_cache(off, val.basic_type()).is_valid(), \"duplicate\");\n+  if (_constant_null_markers == nullptr) {\n+    Arena* arena = CURRENT_ENV->arena();\n+    _constant_null_markers = new (arena) GrowableArray<ConstantValue>(arena, 1, 0, ConstantValue());\n+  }\n+  _constant_null_markers->append(ConstantValue(off, val));\n+}\n+\n+\/\/ Current value of an element.\n+\/\/ Returns T_ILLEGAL if there is no element at the given index.\n+ciConstant ciFlatArray::null_marker_of_element_by_index(int index) {\n+  ciConstant value = check_constant_null_marker_cache(index);\n+  if (value.is_valid()) {\n+    return value;\n+  }\n+  GUARDED_VM_ENTRY(\n+      value = null_marker_of_element_by_offset_impl(get_arrayOop(), index);)\n+  add_to_constant_null_marker_cache(index, value);\n+  return value;\n+}\n+\n+ciConstant ciFlatArray::null_marker_of_element_by_offset(intptr_t element_offset) {\n+  FlatArrayKlass* faklass;\n+  GUARDED_VM_ENTRY(faklass = FlatArrayKlass::cast(get_arrayOop()->klass());)\n+  int lh = faklass->layout_helper();\n+  int shift = Klass::layout_helper_log2_element_size(lh);\n+  intptr_t header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+  intptr_t index = (element_offset - header) >> shift;\n+  intptr_t offset = header + (index << shift);\n+  if (offset != element_offset || index != (jint) index || index < 0 || index >= length()) {\n+    return ciConstant();\n+  }\n+  return null_marker_of_element_by_index((jint) index);\n+}\n+\n+ciConstant ciFlatArray::element_value_by_offset(intptr_t element_offset) {\n+  FlatArrayKlass* faklass;\n+  GUARDED_VM_ENTRY(faklass = FlatArrayKlass::cast(get_arrayOop()->klass());)\n+  int lh = faklass->layout_helper();\n+  int shift = Klass::layout_helper_log2_element_size(lh);\n+  intptr_t header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+  intptr_t index = (element_offset - header) >> shift;\n+  intptr_t offset = header + (index << shift);\n+  if (offset != element_offset || index != (jint) index || index < 0 || index >= length()) {\n+    return ciConstant();\n+  }\n+  return element_value((jint) index);\n+}\n+\n+ciConstant ciFlatArray::field_value_by_offset(intptr_t field_offset) {\n+  ciInlineKlass* elt_type = element_type()->as_inline_klass();\n+  FlatArrayKlass* faklass;\n+  GUARDED_VM_ENTRY(faklass = FlatArrayKlass::cast(get_arrayOop()->klass());)\n+  int lh = faklass->layout_helper();\n+  int shift = Klass::layout_helper_log2_element_size(lh);\n+  intptr_t header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+  intptr_t index = (field_offset - header) >> shift;\n+  intptr_t element_offset = header + (index << shift);\n+  int field_offset_in_element = (int)(field_offset - element_offset);\n+  ciField* field = elt_type->get_field_by_offset(elt_type->payload_offset() + field_offset_in_element, false);\n+  if (field == nullptr) {\n+    if (field_offset_in_element != elt_type->null_marker_offset_in_payload()) {\n+      return ciConstant();\n+    }\n+  }\n+\n+  if (index != (jint) index || index < 0 || index >= length()) {\n+    return ciConstant();\n+  }\n+  ciConstant elt = field_value((jint) index, field);\n+\n+  return elt;\n+}\n+\n+ciConstant ciFlatArray::field_value(int index, ciField* field) {\n+  BasicType elembt = element_basic_type();\n+  ciConstant value = check_constant_value_cache(index, elembt);\n+  if (value.is_valid()) {\n+    if (field == nullptr) {\n+      return value.as_object()->as_instance()->null_marker_value();\n+    }\n+    return value.as_object()->as_instance()->field_value(field);\n+  }\n+  GUARDED_VM_ENTRY(\n+    value = element_value_impl(T_OBJECT, get_arrayOop(), index);\n+  )\n+\n+  add_to_constant_value_cache(index, value);\n+\n+  if (field == nullptr) {\n+    return value.as_object()->as_instance()->null_marker_value();\n+  }\n+  return value.as_object()->as_instance()->field_value(field);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.cpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-  const char* type_string() { return \"ciFlatArray\"; }\n+  const char* type_string() override { return \"ciFlatArray\"; }\n@@ -44,1 +44,17 @@\n-  bool is_flat()      { return true; }\n+  bool is_flat_array() const override { return true; }\n+  bool is_flat() override { return true; }\n+\n+  \/\/ Current value of an element at the specified offset.\n+  \/\/ Returns T_ILLEGAL if there is no element at the given offset.\n+  ciConstant element_value_by_offset(intptr_t element_offset) override;\n+  ciConstant field_value_by_offset(intptr_t field_offset);\n+  ciConstant field_value(int index, ciField* field);\n+  ciConstant null_marker_of_element_by_offset(intptr_t element_offset);\n+  ciConstant null_marker_of_element_by_index(int index);\n+\n+private:\n+  ciConstant null_marker_of_element_by_offset_impl(arrayOop ary, int index);\n+  ciConstant check_constant_null_marker_cache(int off);\n+  void add_to_constant_null_marker_cache(int off, ciConstant val);\n+\n+  GrowableArray<ConstantValue>* _constant_null_markers = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.hpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -103,0 +104,9 @@\n+\/\/ Constant value of the null marker.\n+ciConstant ciInstance::null_marker_value() {\n+  if (!klass()->is_inlinetype()) {\n+    return ciConstant();\n+  }\n+  ciInlineKlass* ik = klass()->as_inline_klass();\n+  return field_value_impl(T_BOOLEAN, ik->null_marker_offset_in_payload() + ik->payload_offset());\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  ciConstant null_marker_value();\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+protected:\n@@ -76,0 +77,1 @@\n+private:\n@@ -131,0 +133,1 @@\n+  virtual bool is_flat_array()        const { return false; }\n@@ -185,0 +188,4 @@\n+  ciFlatArray* as_flat_array() {\n+    assert(is_flat_array(), \"bad cast\");\n+    return (ciFlatArray*)this;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciObject.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  inline jboolean null_marker_of_obj_at(int index) const;\n+  inline jboolean null_marker_of_obj_at(int index, TRAPS) const;\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,15 @@\n+inline jboolean flatArrayOopDesc::null_marker_of_obj_at(int index) const {\n+  EXCEPTION_MARK;\n+  return null_marker_of_obj_at(index, THREAD);\n+}\n+\n+inline jboolean flatArrayOopDesc::null_marker_of_obj_at(int index, TRAPS) const {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n+  FlatArrayKlass* faklass = FlatArrayKlass::cast(klass());\n+  InlineKlass* vk = InlineKlass::cast(faklass->element_klass());\n+  char* this_oop = (char*) (oopDesc*) this;\n+  char* val = (char*) value_at_addr(index, faklass->layout_helper());\n+  ptrdiff_t offset = val - this_oop + (ptrdiff_t)vk->null_marker_offset_in_payload();\n+  return bool_field(offset);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciFlatArray.hpp\"\n@@ -2130,1 +2131,36 @@\n-      n->as_LoadFlat()->expand_atomic(igvn);\n+      LoadFlatNode* loadn = n->as_LoadFlat();\n+      \/\/ Expending a flat load atomically means that we get a chunk of memory spanning multiple fields\n+      \/\/ that we chop with bitwise operations. That is too subtle for some optimizations, especially\n+      \/\/ constant folding when fields are constant. But if the flattened field being accessed is read-only\n+      \/\/ then no concurrent writes can happen and non-atomic loads are fine, allowing better optimizations.\n+      \/\/ A way for fields to be read-only is to be stable and already initialized. Here, we check if the\n+      \/\/ field being accessed is stable, and if the null marker of the field\/array element is non-zero.\n+      \/\/ If so, we know that the stable value was initialized away from the default value (null), and\n+      \/\/ that we can assume it's read-only, so can the load can be performed non-atomically.\n+      bool non_atomic_is_fine = false;\n+      if (FoldStableValues) {\n+        const TypeOopPtr* base_type = igvn.type(loadn->base())->isa_oopptr();\n+        ciObject* oop = base_type->const_oop();\n+        ciInstance* holder = oop != nullptr && oop->is_instance() ? oop->as_instance() : nullptr;\n+        ciArray* array = oop != nullptr && oop->is_array() ? oop->as_array() : nullptr;\n+        int off = igvn.type(loadn->ptr())->isa_ptr()->offset();\n+\n+        if (holder != nullptr) {\n+          ciKlass* klass = holder->klass();\n+          ciInstanceKlass* iklass = klass->as_instance_klass();\n+          const ciField* field = iklass->get_non_flat_field_by_offset(off);\n+          ciField* nm_field = iklass->get_field_by_offset(field->null_marker_offset(), false);\n+          ciConstant cst = nm_field != nullptr ? holder->field_value(nm_field) : ciConstant() \/* invalid *\/;\n+          non_atomic_is_fine = field->is_stable() && cst.is_valid() && cst.as_boolean();\n+        } else if (array != nullptr) {\n+          const TypeAryPtr* aryptr = base_type->is_aryptr();\n+          ciConstant elt = ((ciFlatArray*)array)->null_marker_of_element_by_offset(off);\n+          non_atomic_is_fine = aryptr->is_stable() && elt.is_valid() && !elt.is_null_or_zero();\n+        }\n+      }\n+\n+      if (non_atomic_is_fine) {\n+        loadn->expand_non_atomic(igvn);\n+      } else {\n+        loadn->expand_atomic(igvn);\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2197,1 +2197,1 @@\n-        const Type* con_type = Type::make_constant_from_array_element(aobj->as_array(), off,\n+        const Type* con_type = Type::make_constant_from_array_element(aobj->as_array(), off, ary->field_offset().get(),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciFlatArray.hpp\"\n@@ -378,2 +379,1 @@\n-\/\/ Try to constant-fold a stable array element.\n-const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,\n+static const Type* make_constant_from_non_flat_array_element(ciArray* array, int off, int stable_dimension,\n@@ -399,0 +399,29 @@\n+static const Type* make_constant_from_flat_array_element(ciFlatArray* array, int off, int field_offset, int stable_dimension,\n+                                                         BasicType loadbt, bool is_unsigned_load) {\n+  \/\/ Decode the results of GraphKit::array_element_address.\n+  ciConstant element_value = array->field_value_by_offset(off + field_offset);\n+  if (element_value.basic_type() == T_ILLEGAL) {\n+    return nullptr; \/\/ wrong offset\n+  }\n+  ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);\n+\n+  assert(con.basic_type() != T_ILLEGAL, \"elembt=%s; loadbt=%s; unsigned=%d\",\n+         type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);\n+\n+  if (con.is_valid() &&          \/\/ not a mismatched access\n+      !con.is_null_or_zero()) {  \/\/ not a default value\n+    bool is_narrow_oop = (loadbt == T_NARROWOOP);\n+    return Type::make_from_constant(con, \/*require_constant=*\/true, stable_dimension, is_narrow_oop, \/*is_autobox_cache=*\/false);\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ Try to constant-fold a stable array element.\n+const Type* Type::make_constant_from_array_element(ciArray* array, int off, int field_offset, int stable_dimension,\n+                                                   BasicType loadbt, bool is_unsigned_load) {\n+  if (array->is_flat()) {\n+    return make_constant_from_flat_array_element(array->as_flat_array(), off, field_offset, stable_dimension, loadbt, is_unsigned_load);\n+  }\n+  return make_constant_from_non_flat_array_element(array, off, stable_dimension, loadbt, is_unsigned_load);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+                                                      int field_offset,\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-compiler\/c2\/irTests\/stable\/StableRefArrayTest.java                                               8372700 generic-all\n-compiler\/c2\/irTests\/stable\/StableRefFinalTest.java                                               8372700 generic-all\n-compiler\/c2\/irTests\/stable\/StableRefPlainTest.java                                               8372700 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-enable-preview.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,2 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \"> 0\" })\n@@ -118,1 +119,0 @@\n-        \/\/ No barriers expected for plain fields.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \">0\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefFinalTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \">0\" })\n@@ -84,1 +85,0 @@\n-        \/\/ No barriers expected for plain fields.\n@@ -112,1 +112,2 @@\n-    @IR(failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"false\"}, failOn = { IRNode.MEMBAR })\n+    @IR(applyIf = {\"enable-valhalla\", \"true\"}, counts = { IRNode.MEMBAR, \">0\" })\n@@ -114,1 +115,0 @@\n-        \/\/ Reference inits do not have membars.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}