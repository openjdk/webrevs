{"files":[{"patch":"@@ -161,0 +161,1 @@\n+JVM_IsNullRestrictedArray\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -626,2 +626,2 @@\n-  do_intrinsic(_isFlattenedArray,         jdk_internal_misc_Unsafe,     isFlattenedArray_name, class_boolean_signature, F_RN)    \\\n-   do_name(     isFlattenedArray_name,                                  \"isFlattenedArray\")                                      \\\n+  do_intrinsic(_isFlatArray,              jdk_internal_misc_Unsafe,     isFlatArray_name, class_boolean_signature, F_RN)         \\\n+   do_name(     isFlatArray_name,                                       \"isFlatArray\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1143,0 +1143,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsNullRestrictedArray(JNIEnv *env, jobject obj);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -738,1 +738,1 @@\n-  case vmIntrinsics::_isFlattenedArray:\n+  case vmIntrinsics::_isFlatArray:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-  case vmIntrinsics::_isFlattenedArray:         return inline_unsafe_isFlattenedArray();\n+  case vmIntrinsics::_isFlatArray:              return inline_unsafe_isFlatArray();\n@@ -5224,2 +5224,2 @@\n-\/\/----------------------inline_unsafe_isFlattenedArray-------------------\n-\/\/ public native boolean Unsafe.isFlattenedArray(Class<?> arrayClass);\n+\/\/----------------------inline_unsafe_isFlatArray------------------------\n+\/\/ public native boolean Unsafe.isFlatArray(Class<?> arrayClass);\n@@ -5228,1 +5228,1 @@\n-bool LibraryCallKit::inline_unsafe_isFlattenedArray() {\n+bool LibraryCallKit::inline_unsafe_isFlatArray() {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-  bool inline_unsafe_isFlattenedArray();\n+  bool inline_unsafe_isFlatArray();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -446,0 +446,6 @@\n+\n+JVM_ENTRY(jboolean, JVM_IsNullRestrictedArray(JNIEnv *env, jobject obj))\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  return oop->is_null_free_array();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedField(JNIEnv *env, jobject unsafe, jobject o)) {\n+UNSAFE_ENTRY(jboolean, Unsafe_IsFlatField(JNIEnv *env, jobject unsafe, jobject o)) {\n@@ -342,1 +342,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedArray(JNIEnv *env, jobject unsafe, jclass c)) {\n+UNSAFE_ENTRY(jboolean, Unsafe_IsFlatArray(JNIEnv *env, jobject unsafe, jclass c)) {\n@@ -1003,8 +1003,8 @@\n-    {CC \"isFlattenedArray\", CC \"(\" CLS \")Z\",                     FN_PTR(Unsafe_IsFlattenedArray)},\n-    {CC \"isFlattenedField0\", CC \"(\" OBJ \")Z\",                    FN_PTR(Unsafe_IsFlattenedField)},\n-    {CC \"getValue\",         CC \"(\" OBJ \"J\" CLS \")\" OBJ,          FN_PTR(Unsafe_GetValue)},\n-    {CC \"putValue\",         CC \"(\" OBJ \"J\" CLS OBJ \")V\",         FN_PTR(Unsafe_PutValue)},\n-    {CC \"uninitializedDefaultValue\", CC \"(\" CLS \")\" OBJ,         FN_PTR(Unsafe_UninitializedDefaultValue)},\n-    {CC \"makePrivateBuffer\",     CC \"(\" OBJ \")\" OBJ,             FN_PTR(Unsafe_MakePrivateBuffer)},\n-    {CC \"finishPrivateBuffer\",   CC \"(\" OBJ \")\" OBJ,             FN_PTR(Unsafe_FinishPrivateBuffer)},\n-    {CC \"valueHeaderSize\",       CC \"(\" CLS \")J\",                FN_PTR(Unsafe_ValueHeaderSize)},\n+    {CC \"isFlatArray\", CC \"(\" CLS \")Z\",                   FN_PTR(Unsafe_IsFlatArray)},\n+    {CC \"isFlatField0\", CC \"(\" OBJ \")Z\",                  FN_PTR(Unsafe_IsFlatField)},\n+    {CC \"getValue\",         CC \"(\" OBJ \"J\" CLS \")\" OBJ,   FN_PTR(Unsafe_GetValue)},\n+    {CC \"putValue\",         CC \"(\" OBJ \"J\" CLS OBJ \")V\",  FN_PTR(Unsafe_PutValue)},\n+    {CC \"uninitializedDefaultValue\", CC \"(\" CLS \")\" OBJ,  FN_PTR(Unsafe_UninitializedDefaultValue)},\n+    {CC \"makePrivateBuffer\",     CC \"(\" OBJ \")\" OBJ,      FN_PTR(Unsafe_MakePrivateBuffer)},\n+    {CC \"finishPrivateBuffer\",   CC \"(\" OBJ \")\" OBJ,      FN_PTR(Unsafe_FinishPrivateBuffer)},\n+    {CC \"valueHeaderSize\",       CC \"(\" CLS \")J\",         FN_PTR(Unsafe_ValueHeaderSize)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import jdk.internal.value.ValueClass;\n@@ -2109,1 +2108,1 @@\n-                            UNSAFE.isFlattened(f)\n+                            UNSAFE.isFlatField(f)\n@@ -2162,1 +2161,1 @@\n-                            if (UNSAFE.isFlattened(f)) {\n+                            if (UNSAFE.isFlatField(f)) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -635,1 +635,1 @@\n-            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flattened and non-flattened and null-restricted\n+            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flat vs non-flat x null value vs null-restricted value\n@@ -654,1 +654,0 @@\n-            \/\/ null check for value type in addition to check cast\n@@ -701,3 +700,1 @@\n-    private static Kind getFieldKind(boolean isGetter, boolean isVolatile,\n-                                     boolean isFlat,\n-                                     Wrapper wrapper) {\n+    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlat, Wrapper wrapper) {\n@@ -766,2 +763,1 @@\n-                                                          boolean isFlat,\n-                                                          boolean isNullRestricted, int ftypeKind) {\n+                                                          boolean isFlat, boolean isNullRestricted, int ftypeKind) {\n@@ -772,1 +768,0 @@\n-        boolean needsZeroInstance = isNullRestricted && !isFlat;\n@@ -781,1 +776,0 @@\n-        boolean hasValueTypeArg = isGetter ? ftypeKind == FT_CHECKED_VALUE : isFlat;\n@@ -783,2 +777,3 @@\n-            linkerType = hasValueTypeArg ? MethodType.methodType(ft, Object.class, long.class, Class.class)\n-                                         : MethodType.methodType(ft, Object.class, long.class);\n+            linkerType = isFlat\n+                            ? MethodType.methodType(ft, Object.class, long.class, Class.class)\n+                            : MethodType.methodType(ft, Object.class, long.class);\n@@ -786,2 +781,3 @@\n-            linkerType = isFlat ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)\n-                                : MethodType.methodType(void.class, Object.class, long.class, ft);\n+            linkerType = isFlat\n+                            ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)\n+                            : MethodType.methodType(void.class, Object.class, long.class, ft);\n@@ -819,1 +815,1 @@\n-        final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);\n+        final int VALUE_TYPE = (isFlat ? nameCursor++ : -1);\n@@ -823,2 +819,2 @@\n-        final int FIELD_TYPE = (needsZeroInstance && isGetter ? nameCursor++ : -1);\n-        final int ZERO_INSTANCE = (needsZeroInstance && isGetter ? nameCursor++ : -1);\n+        final int FIELD_TYPE = (isNullRestricted && isGetter ? nameCursor++ : -1);\n+        final int ZERO_INSTANCE = (isNullRestricted && isGetter ? nameCursor++ : -1);\n@@ -837,1 +833,1 @@\n-        assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));\n+        assert (outArgs.length == (isGetter ? 3 : 4) + (isFlat ? 1 : 0));\n@@ -847,1 +843,1 @@\n-        if (hasValueTypeArg) {\n+        if (isFlat) {\n@@ -858,1 +854,1 @@\n-            if (needsZeroInstance) {\n+            if (isNullRestricted) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.value.CheckedType;\n+import jdk.internal.value.NormalCheckedType;\n+import jdk.internal.value.NullRestrictedCheckedType;\n@@ -227,0 +230,8 @@\n+    \/**\n+     * Return {@code CheckedType} representing the type of this member.\n+     *\/\n+    public CheckedType getCheckedFieldType() {\n+        return isNullRestricted() ? NullRestrictedCheckedType.of(getFieldType())\n+                                  : NormalCheckedType.of(getFieldType());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5193,1 +5193,0 @@\n-        \/\/ TODO: implicitly constructible value class\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-                        ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted())\n-                        : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted()));\n+                        ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n+                        : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n@@ -68,2 +68,2 @@\n-                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.isNullRestricted())\n-                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.isNullRestricted()));\n+                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n+                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n@@ -132,2 +132,2 @@\n-                        ? new VarHandleValues.FieldStaticReadOnly(decl, base, foffset, type, f.isNullRestricted())\n-                        : new VarHandleValues.FieldStaticReadWrite(decl, base, foffset, type, f.isNullRestricted()));\n+                        ? new VarHandleValues.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n+                        : new VarHandleValues.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType()));\n@@ -136,2 +136,2 @@\n-                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.isNullRestricted())\n-                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.isNullRestricted());\n+                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n+                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType());\n@@ -226,1 +226,1 @@\n-            return maybeAdapt(UNSAFE.isFlattenedArray(arrayClass)\n+            return maybeAdapt(UNSAFE.isFlatArray(arrayClass)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-#if[Reference]\n+#if[Object]\n+import jdk.internal.value.CheckedType;\n+import jdk.internal.value.NullRestrictedCheckedType;\n@@ -29,1 +31,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -48,0 +50,1 @@\n+        final CheckedType checkedFieldType;\n@@ -49,3 +52,0 @@\n-#if[Reference]\n-        final boolean nullRestricted;\n-#end[Reference]\n@@ -53,2 +53,2 @@\n-        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldInstanceReadOnly.FORM, false);\n+        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, FieldInstanceReadOnly.FORM, false);\n@@ -57,1 +57,1 @@\n-        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n+        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType},\n@@ -64,0 +64,1 @@\n+            this.checkedFieldType = checkedFieldType;\n@@ -65,3 +66,0 @@\n-#if[Reference]\n-            this.nullRestricted = nullRestricted;\n-#end[Reference]\n@@ -74,1 +72,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, vform, true);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, vform, true);\n@@ -81,1 +79,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, vform, false);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, vform, false);\n@@ -107,2 +105,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -111,1 +109,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -120,2 +118,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -124,1 +122,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -133,2 +131,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -137,1 +135,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -146,2 +144,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -150,1 +148,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -158,2 +156,2 @@\n-        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}, false);\n+        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, false);\n@@ -162,1 +160,1 @@\n-        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n+        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType},\n@@ -164,1 +162,1 @@\n-            super(receiverType, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldInstanceReadWrite.FORM, exact);\n+            super(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, FieldInstanceReadWrite.FORM, exact);\n@@ -171,1 +169,1 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, true);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, true);\n@@ -178,1 +176,1 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Reference]?, fieldType, nullRestricted}{#if[Value]?, fieldType, true}, false);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, false);\n@@ -184,5 +182,1 @@\n-#if[Reference]\n-            if (value == null && handle.nullRestricted)\n-                throw new NullPointerException(\"null-restricted field\");\n-#end[Reference]\n-            return handle.fieldType.cast(value);\n+            return handle.checkedFieldType.cast(value);\n@@ -433,1 +427,1 @@\n-        final boolean nullRestricted;\n+        final CheckedType checkedFieldType;\n@@ -436,2 +430,2 @@\n-        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldStaticReadOnly.FORM, false);\n+        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, FieldStaticReadOnly.FORM, false);\n@@ -440,1 +434,1 @@\n-        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n+        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType},\n@@ -448,1 +442,1 @@\n-            this.nullRestricted = nullRestricted;\n+            this.checkedFieldType = checkedFieldType;\n@@ -456,1 +450,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, vform, true);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, vform, true);\n@@ -463,1 +457,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, vform, false);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, vform, false);\n@@ -491,2 +485,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -495,1 +489,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -504,2 +498,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -508,1 +502,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -517,2 +511,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -521,1 +515,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -530,2 +524,2 @@\n-#if[Reference]\n-            if (handle.nullRestricted && value == null) {\n+#if[Object]\n+            if (value == null && handle.checkedFieldType instanceof NullRestrictedCheckedType) {\n@@ -534,1 +528,1 @@\n-#end[Reference]\n+#end[Object]\n@@ -543,2 +537,2 @@\n-        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, false);\n+        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, false);\n@@ -547,1 +541,1 @@\n-        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, boolean nullRestricted},\n+        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType},\n@@ -549,1 +543,1 @@\n-            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType, nullRestricted}, FieldStaticReadWrite.FORM, exact);\n+            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, FieldStaticReadWrite.FORM, exact);\n@@ -556,1 +550,1 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}{#if[Reference]?, nullRestricted}, true);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, true);\n@@ -563,1 +557,1 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}{#if[Reference]?, nullRestricted}, false);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}, false);\n@@ -567,0 +561,1 @@\n+        @ForceInline\n@@ -568,1 +563,1 @@\n-            return handle.fieldType.cast(value);\n+            return handle.checkedFieldType.cast(value);\n@@ -806,9 +801,0 @@\n-#if[Reference]\n-    static VarHandle makeVarHandleValuesArray(Class<?> arrayClass) {\n-        Class<?> componentType = arrayClass.getComponentType();\n-        assert UNSAFE.isFlattenedArray(arrayClass);\n-        \/\/ should cache these VarHandle for performance\n-        return VarHandles.makeArrayElementHandle(arrayClass);\n-    }\n-#end[Reference]\n-\n@@ -862,1 +848,1 @@\n-            return at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?arrayType.getComponentType():$type$.class}, int.class);\n+            return at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?componentType:$type$.class}, int.class);\n@@ -870,1 +856,1 @@\n-                return handle.componentType.cast(value);\n+                return {#if[Value]?ValueClass.componentCheckedType(oarray):handle.componentType}.cast(value);\n@@ -872,1 +858,1 @@\n-                \/\/ Slow path: check value against argument array component type\n+                \/\/ Slow path: check value against argument array component checked type\n@@ -880,1 +866,1 @@\n-                return oarray.getClass().getComponentType().cast(value);\n+                return ValueClass.componentCheckedType(oarray).cast(value);\n@@ -907,4 +893,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                vh.set(oarray, index, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                vh.set(oarray, index, value);\n@@ -926,3 +913,4 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n@@ -945,4 +933,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                vh.setVolatile(oarray, index, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                vh.setVolatile(oarray, index, value);\n@@ -966,3 +955,4 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n@@ -985,4 +975,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                vh.setOpaque(oarray, index, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                vh.setOpaque(oarray, index, value);\n@@ -1006,3 +997,4 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n@@ -1025,4 +1017,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                vh.setRelease(oarray, index, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                vh.setRelease(oarray, index, value);\n@@ -1047,4 +1040,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.compareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndSet(oarray, index, expected, value);\n@@ -1068,4 +1062,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.compareAndExchange(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndExchange(oarray, index, expected, value);\n@@ -1089,4 +1084,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.compareAndExchangeAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndExchangeAcquire(oarray, index, expected, value);\n@@ -1110,4 +1106,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.compareAndExchangeRelease(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndExchangeRelease(oarray, index, expected, value);\n@@ -1131,4 +1128,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.weakCompareAndSetPlain(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSetPlain(oarray, index, expected, value);\n@@ -1152,4 +1150,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.weakCompareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSet(oarray, index, expected, value);\n@@ -1173,4 +1172,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.weakCompareAndSetAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSetAcquire(oarray, index, expected, value);\n@@ -1194,4 +1194,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.weakCompareAndSetRelease(oarray, index, expected, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSetRelease(oarray, index, expected, value);\n@@ -1215,4 +1216,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.getAndSet(oarray, index, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.getAndSet(oarray, index, value);\n@@ -1235,4 +1237,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.getAndSetAcquire(oarray, index, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.getAndSetAcquire(oarray, index, value);\n@@ -1255,4 +1258,5 @@\n-            if (UNSAFE.isFlattenedArray(oarray.getClass())) {\n-                \/\/ for flattened array, delegate to VarHandle of the inline type array\n-                VarHandle vh = makeVarHandleValuesArray(oarray.getClass());\n-                return vh.getAndSetRelease(oarray, index, reflectiveTypeCheck(array, value));\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleValues.flatArrayVarHandle(arrayType);\n+                return vh.getAndSetRelease(oarray, index, value);\n@@ -1378,1 +1382,0 @@\n-\n@@ -1381,0 +1384,14 @@\n+#if[Value]\n+    static final ClassValue<Array> flatArrayVarHandles = new ClassValue<>() {\n+        @Override protected Array computeValue(Class<?> arrayClass) {\n+            assert UNSAFE.isFlatArray(arrayClass);\n+            int aoffset = UNSAFE.arrayBaseOffset(arrayClass);\n+            int ascale = UNSAFE.arrayIndexScale(arrayClass);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            return new Array(aoffset, ashift, arrayClass);\n+        }\n+    };\n+    static VarHandle flatArrayVarHandle(Class<?> arrayClass) {\n+        return flatArrayVarHandles.get(arrayClass);\n+    }\n+#end[Value]\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":162,"deletions":145,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Objects;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,0 +129,4 @@\n+    public boolean isNullRestrictedField(Field f) {\n+        return f.isNullRestricted();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+\n+    \/** Tests if this is a null-restricted field *\/\n+    public boolean isNullRestrictedField(Field f);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.ValueClass;\n@@ -185,1 +184,1 @@\n-    public boolean isFlattened(Field f) {\n+    public boolean isFlatField(Field f) {\n@@ -189,1 +188,1 @@\n-        return isFlattenedField0(f);\n+        return isFlatField0(f);\n@@ -192,1 +191,1 @@\n-    private native boolean isFlattenedField0(Object o);\n+    private native boolean isFlatField0(Object o);\n@@ -198,1 +197,1 @@\n-    public native boolean isFlattenedArray(Class<?> arrayClass);\n+    public native boolean isFlatArray(Class<?> arrayClass);\n@@ -265,14 +264,0 @@\n-    \/**\n-     * Fetches a reference value of the given type from a given Java variable.\n-     * This method can return a reference to a value if it is non-null.\n-     *\n-     * @param type type\n-     *\/\n-    public Object getReference(Object o, long offset, Class<?> type) {\n-        return getReference(o, offset);\n-    }\n-\n-    public Object getReferenceVolatile(Object o, long offset, Class<?> type) {\n-        return getReferenceVolatile(o, offset);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.value;\n+\n+public sealed interface CheckedType permits NormalCheckedType, NullRestrictedCheckedType {\n+    Object cast(Object obj);\n+    boolean canCast(Object obj);\n+    Class<?> boundingClass();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/CheckedType.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.value;\n+\n+public final class NormalCheckedType implements CheckedType {\n+    private final Class<?> type;\n+    NormalCheckedType(Class<?> cls) {\n+        this.type = cls;\n+    }\n+\n+    @Override\n+    public Object cast(Object obj) {\n+        return type.cast(obj);\n+    }\n+\n+    @Override\n+    public boolean canCast(Object obj) {\n+        return type.isAssignableFrom(obj.getClass());\n+    }\n+\n+    @Override\n+    public Class<?> boundingClass() {\n+        return type;\n+    }\n+\n+    public static NormalCheckedType of(Class<?> cls) {\n+        return new NormalCheckedType(cls);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/NormalCheckedType.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.value;\n+\n+public final class NullRestrictedCheckedType implements CheckedType {\n+    private final Class<?> type;\n+    NullRestrictedCheckedType(Class<?> cls) {\n+        this.type = cls;\n+    }\n+\n+    @Override\n+    public Object cast(Object obj) {\n+        if (obj == null) {\n+            throw new NullPointerException(\"null not allowed for null-restricted type \" + type.getName());\n+        }\n+        return type.cast(obj);\n+    }\n+\n+    @Override\n+    public boolean canCast(Object obj) {\n+        if (obj == null) return false;\n+        return type.isAssignableFrom(obj.getClass());\n+    }\n+\n+    @Override\n+    public Class<?> boundingClass() {\n+        return type;\n+    }\n+\n+    public static NullRestrictedCheckedType of(Class<?> cls) {\n+        if (!cls.isValue()) {\n+            throw new IllegalArgumentException(cls.getName() + \" not a value class\");\n+        }\n+        return new NullRestrictedCheckedType(cls);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/NullRestrictedCheckedType.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangReflectAccess;\n@@ -33,0 +33,3 @@\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+\n@@ -38,0 +41,1 @@\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n@@ -62,0 +66,39 @@\n+    \/**\n+     * Returns {@code CheckedType} representing the type of the given field.\n+     *\/\n+    public static CheckedType checkedType(Field f) {\n+        return JLRA.isNullRestrictedField(f) ? NullRestrictedCheckedType.of(f.getType())\n+                                             : NormalCheckedType.of(f.getType());\n+    }\n+\n+    \/**\n+     * Returns {@code CheckedType} representing the component type of the given array.\n+     *\/\n+    public static CheckedType componentCheckedType(Object array) {\n+        Class<?> componentType = array.getClass().getComponentType();\n+        return isNullRestrictedArray(array) ? NullRestrictedCheckedType.of(componentType)\n+                                            : NormalCheckedType.of(componentType);\n+    }\n+\n+    \/**\n+     * Allocate an array of a value class type with components that behave in\n+     * the same way as a {@link jdk.internal.vm.annotation.NullRestricted}\n+     * field.\n+     * <p>\n+     * Because these behaviors are not specified by Java SE, arrays created with\n+     * this method should only be used by internal JDK code for experimental\n+     * purposes and should not affect user-observable outcomes.\n+     *\n+     * @throws IllegalArgumentException if {@code componentType} is not a\n+     *         value class type or is not annotated with\n+     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static Object[] newArrayInstance(CheckedType componentType, int length) {\n+        if (componentType instanceof NullRestrictedCheckedType) {\n+            return newNullRestrictedArray(componentType.boundingClass(), length);\n+        } else {\n+            return (Object[]) Array.newInstance(componentType.boundingClass(), length);\n+        }\n+    }\n+\n@@ -78,0 +121,2 @@\n+\n+    public static native boolean isNullRestrictedArray(Object array);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,0 +41,7 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_value_ValueClass_isNullRestrictedArray(JNIEnv *env, jclass cls, jobject obj)\n+{\n+    return JVM_IsNullRestrictedArray(env, obj);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/ValueClass.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-            V1_FLATTENED = U.isFlattened(v1Field);\n+            V1_FLATTENED = U.isFlatField(v1Field);\n@@ -591,1 +591,1 @@\n-            TEST31_VT_FLATTENED = U.isFlattened(test31_vt_Field);\n+            TEST31_VT_FLATTENED = U.isFlatField(test31_vt_Field);\n@@ -642,1 +642,1 @@\n-            TEST33_FLATTENED_ARRAY = U.isFlattenedArray(TEST33_ARRAY.getClass());\n+            TEST33_FLATTENED_ARRAY = U.isFlatArray(TEST33_ARRAY.getClass());\n@@ -1615,1 +1615,1 @@\n-        Asserts.assertEQ(test80(v, U.isFlattened(field), U.objectFieldOffset(field)), v.v);\n+        Asserts.assertEQ(test80(v, U.isFlatField(field), U.objectFieldOffset(field)), v.v);\n@@ -1618,1 +1618,1 @@\n-    \/\/ Test correctness of the Unsafe::isFlattenedArray intrinsic\n+    \/\/ Test correctness of the Unsafe::isFlatArray intrinsic\n@@ -1621,1 +1621,1 @@\n-        return U.isFlattenedArray(cls);\n+        return U.isFlatArray(cls);\n@@ -1632,1 +1632,1 @@\n-    \/\/ Verify that Unsafe::isFlattenedArray checks with statically known classes\n+    \/\/ Verify that Unsafe::isFlatArray checks with statically known classes\n@@ -1637,1 +1637,1 @@\n-        boolean check1 = U.isFlattenedArray(TEST33_ARRAY.getClass());\n+        boolean check1 = U.isFlatArray(TEST33_ARRAY.getClass());\n@@ -1641,3 +1641,3 @@\n-        boolean check2 = !U.isFlattenedArray(String[].class);\n-        boolean check3 = !U.isFlattenedArray(String.class);\n-        boolean check4 = !U.isFlattenedArray(int[].class);\n+        boolean check2 = !U.isFlatArray(String[].class);\n+        boolean check3 = !U.isFlatArray(String.class);\n+        boolean check4 = !U.isFlatArray(int[].class);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-            Asserts.assertFalse(UNSAFE.isFlattened(f0), \"Unexpected flat field\");\n+            Asserts.assertFalse(UNSAFE.isFlatField(f0), \"Unexpected flat field\");\n@@ -183,1 +183,1 @@\n-            Asserts.assertTrue(UNSAFE.isFlattened(f1), \"Flat field expected, but field is not flat\");\n+            Asserts.assertTrue(UNSAFE.isFlatField(f1), \"Flat field expected, but field is not flat\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/AnnotationsTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-        Asserts.assertTrue(UNSAFE.isFlattenedArray(array.getClass()), \"Expecting flat array but array is not flat\");\n+        Asserts.assertTrue(UNSAFE.isFlatArray(array.getClass()), \"Expecting flat array but array is not flat\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullRestrictedArrayTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-                              U.isFlattened(f) ? \"flattened \" : \"\", f.getType(),\n+                              U.isFlatField(f) ? \"flattened \" : \"\", f.getType(),\n@@ -161,1 +161,1 @@\n-            if (U.isFlattened(f)) {\n+            if (U.isFlatField(f)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            TFIELD_FLAT = UNSAFE.isFlattened(TPB_field);\n+            TFIELD_FLAT = UNSAFE.isFlatField(TPB_field);\n@@ -90,1 +90,1 @@\n-            NTFIELD_FLAT = UNSAFE.isFlattened(NTPB_field);\n+            NTFIELD_FLAT = UNSAFE.isFlatField(NTPB_field);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueTearing.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-        Asserts.assertTrue(U.isFlattened(f0), \"mv0 should be flattened\");\n-        Asserts.assertFalse(U.isFlattened(f1), \"mv1 should not be flattened\");\n+        Asserts.assertTrue(U.isFlatField(f0), \"mv0 should be flattened\");\n+        Asserts.assertFalse(U.isFlatField(f1), \"mv1 should not be flattened\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/VolatileTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,0 +203,1 @@\n+            assertTrue(vh.get(array, 1) != null);\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run junit\/othervm NullRestrictedArraysTest\n+ * @run junit\/othervm -XX:FlatArrayElementMaxSize=0 NullRestrictedArraysTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.value.CheckedType;\n+import jdk.internal.value.NullRestrictedCheckedType;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class NullRestrictedArraysTest {\n+    interface I {\n+        int getValue();\n+    }\n+    @ImplicitlyConstructible\n+    static value class Value implements I {\n+        int v;\n+        Value() {\n+            this(0);\n+        }\n+        Value(int v) {\n+            this.v = v;\n+        }\n+        public int getValue() {\n+            return v;\n+        }\n+    }\n+\n+    static class T {\n+        String s;\n+        Value obj;  \/\/ can be null\n+        @NullRestricted\n+        Value value;\n+    }\n+\n+    static Stream<Arguments> checkedTypes() throws ReflectiveOperationException {\n+        return Stream.of(\n+                Arguments.of(T.class.getDeclaredField(\"s\"), String.class, false),\n+                Arguments.of(T.class.getDeclaredField(\"obj\"), Value.class, false),\n+                Arguments.of(T.class.getDeclaredField(\"value\"), Value.class, true)\n+        );\n+    }\n+\n+    \/*\n+     * Test creating null-restricted arrays with CheckedType\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"checkedTypes\")\n+    public void testCheckedTypeArrays(Field field, Class<?> type, boolean nullRestricted) throws ReflectiveOperationException {\n+        CheckedType checkedType = ValueClass.checkedType(field);\n+        assertTrue(field.getType() == type);\n+        assertTrue(checkedType.boundingClass() == type);\n+        Object[] array = ValueClass.newArrayInstance(checkedType, 4);\n+        assertTrue(ValueClass.isNullRestrictedArray(array) == nullRestricted);\n+        assertTrue(checkedType instanceof NullRestrictedCheckedType == nullRestricted);\n+        for (int i=0; i < array.length; i++) {\n+            array[i] = type.newInstance();\n+        }\n+        if (nullRestricted) {\n+            \/\/ NPE thrown if elements in a null-restricted array set to null\n+            assertThrows(NullPointerException.class, () -> array[0] = null);\n+        } else {\n+            array[0] = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testVarHandle() {\n+        int len = 4;\n+        Object[] array = (Object[]) Array.newInstance(Value.class, len);\n+        Object[] nullRestrictedArray = ValueClass.newNullRestrictedArray(Value.class, len);\n+\n+        \/\/ Test var handles\n+        testVarHandleArray(array, Value[].class);\n+        testVarHandleArray(array, I[].class);\n+        testVarHandleNullRestrictedArray(nullRestrictedArray, Value[].class);\n+        testVarHandleNullRestrictedArray(nullRestrictedArray, I[].class);\n+    }\n+\n+    private void testVarHandleArray(Object[] array, Class<?> arrayClass) {\n+        for (int i=0; i < array.length; i++) {\n+            array[i] = new Value(i);\n+        }\n+\n+        VarHandle vh = MethodHandles.arrayElementVarHandle(arrayClass);\n+        Value value = new Value(0);\n+        Value value1 =  new Value(1);\n+\n+        assertTrue(vh.get(array, 0) == value);\n+        assertTrue(vh.getVolatile(array, 0) == value);\n+        assertTrue(vh.getOpaque(array, 0) == value);\n+        assertTrue(vh.getAcquire(array, 0) == value);\n+        vh.set(array, 0, null);\n+        vh.setVolatile(array, 0, null);\n+        vh.setOpaque(array, 0, null);\n+        vh.setRelease(array, 0, null);\n+\n+        vh.compareAndSet(array, 1, value1, null);             vh.set(array, 1, value1);\n+        vh.compareAndExchange(array, 1, value1, null);        vh.set(array, 1, value1);\n+        vh.compareAndExchangeAcquire(array, 1, value1, null); vh.set(array, 1, value1);\n+        vh.compareAndExchangeRelease(array, 1, value1, null); vh.set(array, 1, value1);\n+        vh.weakCompareAndSet(array, 1, value1, null);         vh.set(array, 1, value1);\n+        vh.weakCompareAndSetAcquire(array, 1, value1, null);  vh.set(array, 1, value1);\n+        vh.weakCompareAndSetPlain(array, 1, value1, null);    vh.set(array, 1, value1);\n+        vh.weakCompareAndSetRelease(array, 1, value1, null);  vh.set(array, 1, value1);\n+    }\n+\n+    private void testVarHandleNullRestrictedArray(Object[] array, Class<?> arrayClass) {\n+        for (int i=0; i < array.length; i++) {\n+            array[i] = new Value(i);\n+        }\n+\n+        VarHandle vh = MethodHandles.arrayElementVarHandle(arrayClass);\n+        Value value = new Value(0);\n+        Value value1 =  new Value(1);\n+        assertTrue(vh.get(array, 0) == value);\n+        assertTrue(vh.getVolatile(array, 0) == value);\n+        assertTrue(vh.getOpaque(array, 0) == value);\n+        assertTrue(vh.getAcquire(array, 0) == value);\n+        assertThrows(NullPointerException.class, () -> vh.set(array, 0, null));\n+        assertThrows(NullPointerException.class, () -> vh.setVolatile(array, 0, null));\n+        assertThrows(NullPointerException.class, () -> vh.setOpaque(array, 0, null));\n+        assertThrows(NullPointerException.class, () -> vh.setRelease(array, 0, null));\n+\n+        assertThrows(NullPointerException.class, () -> vh.compareAndSet(array, 1, value1, null));\n+        assertThrows(NullPointerException.class, () -> vh.compareAndExchange(array, 1, value1, null));\n+        assertThrows(NullPointerException.class, () -> vh.compareAndExchangeAcquire(array, 1, value1, null));\n+        assertThrows(NullPointerException.class, () -> vh.compareAndExchangeRelease(array, 1, value1, null));\n+        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSet(array, 1, value1, null));\n+        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetAcquire(array, 1, value1, null));\n+        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetPlain(array, 1, value1, null));\n+        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetRelease(array, 1, value1, null));\n+    }\n+\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedArraysTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.valhalla.intrinsics;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+import jdk.internal.misc.Unsafe;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 1,\n+      jvmArgsAppend = {\"--add-opens\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                       \"--enable-preview\"})\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+public class IsFlatArray {\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final VarHandle objectArrayVarHandle =\n+        MethodHandles.arrayElementVarHandle(Object[].class);\n+\n+    @State(Scope.Benchmark)\n+    public static class ClassState {\n+        public Class flatArrayClass = Point[].class;\n+        public Class nonFlatArrayClass = String[].class;\n+\n+        public Object[] objectArray = new Object[10];\n+        public Object objectElement = new Object();\n+        public int arrayIndex = 0;\n+    }\n+\n+    @Benchmark\n+    public boolean testKnownFlatClass() {\n+        return U.isFlatArray(Point[].class);\n+    }\n+\n+    @Benchmark\n+    public boolean testKnownNonFlatClass() {\n+        return U.isFlatArray(String[].class);\n+    }\n+\n+    @Benchmark\n+    public boolean testUnknownFlatClass(ClassState state) {\n+        return U.isFlatArray(state.flatArrayClass);\n+    }\n+\n+    @Benchmark\n+    public boolean testUnknownNonFlatClass(ClassState state) {\n+        return U.isFlatArray(state.nonFlatArrayClass);\n+    }\n+\n+    @Benchmark\n+    public void setArrayElement(ClassState state) {\n+        objectArrayVarHandle.set(state.objectArray, state.arrayIndex, state.objectElement);\n+    }\n+\n+    @Benchmark\n+    public VarHandle makeArrayVarHandle() {\n+        return MethodHandles.arrayElementVarHandle(Object[].class);\n+    }\n+\n+}\n+\n+value class Point {\n+    int x;\n+    int y;\n+    public Point(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/intrinsics\/IsFlatArray.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.valhalla.intrinsics;\n-\n-import org.openjdk.jmh.annotations.*;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.util.concurrent.TimeUnit;\n-import jdk.internal.misc.Unsafe;\n-\n-@BenchmarkMode(Mode.Throughput)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Fork(value = 1,\n-      jvmArgsAppend = {\"--add-opens\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                       \"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-public class IsFlattenedArray {\n-\n-    private static final Unsafe U = Unsafe.getUnsafe();\n-    private static final VarHandle objectArrayVarHandle =\n-        MethodHandles.arrayElementVarHandle(Object[].class);\n-\n-    @State(Scope.Benchmark)\n-    public static class ClassState {\n-        public Class flattenedArrayClass = Point[].class;\n-        public Class nonFlattenedArrayClass = String[].class;\n-\n-        public Object[] objectArray = new Object[10];\n-        public Object objectElement = new Object();\n-        public int arrayIndex = 0;\n-    }\n-\n-    @Benchmark\n-    public boolean testKnownFlattenedClass() {\n-        return U.isFlattenedArray(Point[].class);\n-    }\n-\n-    @Benchmark\n-    public boolean testKnownNonFlattenedClass() {\n-        return U.isFlattenedArray(String[].class);\n-    }\n-\n-    @Benchmark\n-    public boolean testUnknownFlattenedClass(ClassState state) {\n-        return U.isFlattenedArray(state.flattenedArrayClass);\n-    }\n-\n-    @Benchmark\n-    public boolean testUnknownNonFlattenedClass(ClassState state) {\n-        return U.isFlattenedArray(state.nonFlattenedArrayClass);\n-    }\n-\n-    @Benchmark\n-    public void setArrayElement(ClassState state) {\n-        objectArrayVarHandle.set(state.objectArray, state.arrayIndex, state.objectElement);\n-    }\n-\n-    @Benchmark\n-    public VarHandle makeArrayVarHandle() {\n-        return MethodHandles.arrayElementVarHandle(Object[].class);\n-    }\n-\n-}\n-\n-value class Point {\n-    int x;\n-    int y;\n-    public Point(int x, int y) {\n-        this.x = x;\n-        this.y = y;\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/intrinsics\/IsFlattenedArray.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"}]}