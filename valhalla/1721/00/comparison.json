{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.util.NoSuchElementException;\n@@ -41,0 +42,1 @@\n+import java.util.function.Predicate;\n@@ -42,0 +44,2 @@\n+import java.util.stream.Stream;\n+\n@@ -329,0 +333,81 @@\n+    \/**\n+     * Returns the \"raw\" API for accessing underlying jimage resource entries.\n+     *\n+     * <p>This is only meaningful for use by code dealing directly with jimage\n+     * files, and cannot be used to reliably lookup resources used at runtime.\n+     *\n+     * <p>This API remains valid until the image reader from which it was\n+     * obtained is closed.\n+     *\/\n+    \/\/ Package visible for use by ImageReader.\n+    ResourceEntries getResourceEntries() {\n+        return new ResourceEntries() {\n+            @Override\n+            public Stream<String> entryNamesIn(String module) {\n+                if (module.isEmpty() || module.equals(\"modules\") || module.equals(\"packages\")) {\n+                    throw new IllegalArgumentException(\"Invalid module name: \" + module);\n+                }\n+                return IntStream.range(0, offsets.capacity())\n+                        .map(offsets::get)\n+                        .filter(offset -> offset != 0)\n+                        \/\/ Reusing a location instance or getting the module\n+                        \/\/ offset directly would save a lot of allocations here.\n+                        .mapToObj(offset -> ImageLocation.readFrom(BasicImageReader.this, offset))\n+                        \/\/ Reverse lookup of module offset would be faster here.\n+                        .filter(loc -> module.equals(loc.getModule()))\n+                        .map(ImageLocation::getFullName);\n+            }\n+\n+            private ImageLocation getResourceLocation(String name) {\n+                \/\/ Other types of invalid name just result in no entry being found.\n+                if (name.startsWith(\"\/modules\/\") || name.startsWith(\"\/packages\/\")) {\n+                    throw new IllegalArgumentException(\"Invalid entry name: \" + name);\n+                }\n+                ImageLocation location = BasicImageReader.this.findLocation(name);\n+                if (location == null) {\n+                    throw new NoSuchElementException(\"No such resource entry: \" + name);\n+                }\n+                return location;\n+            }\n+\n+            @Override\n+            public long sizeOf(String name) {\n+                return getResourceLocation(name).getUncompressedSize();\n+            }\n+\n+            @Override\n+            public InputStream open(String name) {\n+                return BasicImageReader.this.getResourceStream(getResourceLocation(name));\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns a sorted array of all matching entry names in the jimage file.\n+     *\n+     * <p>Entry names are of one of the following forms:\n+     * <ul>\n+     *     <li>{@code \"\/modules\/<mod-name>\/path\/to\/class-or-resource\"}\n+     *     <li>{@code \"\/<mod-name>\/path\/to\/directory\"}\n+     *     <li>{@code \"\/packages\/<package-name>\"}\n+     * <\/ul>\n+     *\n+     * <p>Note that the module names {@code \"modules\"} or {@code \"packages\"} are\n+     * not representable in a jimage file, so can never exist.\n+     *\n+     * <p>The resulting array is sorted lexicographically, and the resulting\n+     * order need not match that of a breadth or depth first search.\n+     *\n+     * @param matcher a predicate for entry names to be returned.\n+     *\/\n+    public String[] getEntryNames(Predicate<String> matcher) {\n+        int[] attributeOffsets = new int[offsets.capacity()];\n+        offsets.get(attributeOffsets);\n+        return IntStream.of(attributeOffsets)\n+                .filter(o -> o != 0)\n+                .mapToObj(o -> ImageLocation.readFrom(this, o).getFullName())\n+                .filter(matcher)\n+                .sorted()\n+                .toArray(String[]::new);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -233,0 +233,13 @@\n+    \/**\n+     * Returns the \"raw\" API for accessing underlying jimage resource entries.\n+     *\n+     * <p>This is only meaningful for use by code dealing directly with jimage\n+     * files, and cannot be used to reliably lookup resources used at runtime.\n+     *\n+     * <p>This API remains valid until the image reader from which it was\n+     * obtained is closed.\n+     *\/\n+    public ResourceEntries getResourceEntries() {\n+        return reader.getResourceEntries();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+package jdk.internal.jimage;\n+\n+import java.io.InputStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Accesses the underlying resource entries in a jimage file.\n+ *\n+ * <p>This API is designed only for use by the jlink classes, which manipulate\n+ * jimage files directly. For inspection of runtime resources, it is vital that\n+ * {@code previewMode} is correctly observed, making this API unsuitable.\n+ *\n+ * <p>This API ignores the {@code previewMode} of the {@link ImageReader} from\n+ * which it is obtained, and returns an unmapped view of entries (e.g. allowing\n+ * for direct access of resources in the {@code META-INF\/preview\/...} namespace).\n+ *\n+ * <p>It disallows access to resource directories (i.e. {@code \"\/modules\/...\"}\n+ * or packages (i.e. {@code \"\/packages\/...\"}.\n+ *\/\n+public interface ResourceEntries {\n+    \/**\n+     * Returns the full entry names for all resources in the given module, in\n+     * random order. Entry names will always be prefixed by the given module\n+     * name (e.g. \"\/<module-name\/...\").\n+     *\/\n+    Stream<String> entryNamesIn(String module);\n+\n+    \/**\n+     * Returns the (uncompressed) size of a resource given its full entry name.\n+     *\n+     * @throws java.util.NoSuchElementException if the resource does not exist.\n+     *\/\n+    long sizeOf(String name);\n+\n+    \/**\n+     * Returns an {@link InputStream} for a resource given its full entry name.\n+     *\n+     * @throws java.util.NoSuchElementException if the resource does not exist.\n+     *\/\n+    InputStream open(String name);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ResourceEntries.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.Closeable;\n@@ -37,1 +38,1 @@\n-public interface Archive {\n+public interface Archive extends Closeable {\n@@ -62,5 +63,6 @@\n-         * Constructs an entry of the given archive\n-         * @param archive archive\n-         * @param path\n-         * @param name an entry name that does not contain the module name\n-         * @param type\n+         * Constructs an entry of the given archive.\n+         *\n+         * @param archive the archive in which this entry exists.\n+         * @param path the complete path of the entry, including the module.\n+         * @param name an entry name relative to its containing module.\n+         * @param type the entry type.\n@@ -75,4 +77,0 @@\n-        public final Archive archive() {\n-            return archive;\n-        }\n-\n@@ -90,0 +88,5 @@\n+        \/**\n+         * Returns the path of this entry.\n+         *\/\n+        public final String path() {return path;}\n+\n@@ -137,0 +140,1 @@\n+    @Override\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Archive.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+import jdk.internal.jimage.ResourceEntries;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -66,1 +68,0 @@\n-\n@@ -69,1 +70,1 @@\n-    private final ModuleReference ref;\n+    private final ResourceEntries imageResources;\n@@ -102,6 +103,5 @@\n-        this.ref = ModuleFinder.ofSystem()\n-                               .find(module)\n-                               .orElseThrow(() ->\n-                                    new IllegalArgumentException(\n-                                            \"Module \" + module +\n-                                            \" not part of the JDK install\"));\n+        ModuleFinder.ofSystem()\n+                .find(module)\n+                .orElseThrow(() -> new IllegalArgumentException(\n+                        \"Module \" + module + \" not part of the JDK install\"));\n+        this.imageResources = SystemImageReader.get().getResourceEntries();\n@@ -162,0 +162,11 @@\n+    private boolean isNormalOrModifiedDiff(String name) {\n+        ResourceDiff rd = resDiff.get(name);\n+        \/\/ Filter all resources with a resource diff of kind MODIFIED.\n+        \/\/ Note that REMOVED won't happen since in that case the module listing\n+        \/\/ won't have the resource anyway.\n+        \/\/ Note as well that filter removes files of kind ADDED. Those files are\n+        \/\/ not in the packaged modules, so ought not to get returned from the\n+        \/\/ pipeline.\n+        return (rd == null || rd.getKind() == ResourceDiff.Kind.MODIFIED);\n+    }\n+\n@@ -165,0 +176,1 @@\n+\n@@ -167,25 +179,6 @@\n-            files.addAll(ref.open().list()\n-                                   .filter(i -> {\n-                                           String lookupKey = String.format(\"\/%s\/%s\", module, i);\n-                                           ResourceDiff rd = resDiff.get(lookupKey);\n-                                           \/\/ Filter all resources with a resource diff\n-                                           \/\/ that are of kind MODIFIED.\n-                                           \/\/ Note that REMOVED won't happen since in\n-                                           \/\/ that case the module listing won't have\n-                                           \/\/ the resource anyway.\n-                                           \/\/ Note as well that filter removes files\n-                                           \/\/ of kind ADDED. Those files are not in\n-                                           \/\/ the packaged modules, so ought not to\n-                                           \/\/ get returned from the pipeline.\n-                                           return (rd == null ||\n-                                                   rd.getKind() == ResourceDiff.Kind.MODIFIED);\n-                                   })\n-                                   .map(s -> {\n-                                           String lookupKey = String.format(\"\/%s\/%s\", module, s);\n-                                           return new JRTArchiveFile(JRTArchive.this, s,\n-                                                           EntryType.CLASS_OR_RESOURCE,\n-                                                           null \/* hashOrTarget *\/,\n-                                                           false \/* symlink *\/,\n-                                                           resDiff.get(lookupKey));\n-                                   })\n-                                   .toList());\n+            imageResources.entryNamesIn(module)\n+                    .filter(this::isNormalOrModifiedDiff)\n+                    .sorted()\n+                    .map(name -> new JrtModuleFile(this, name, resDiff.get(name)))\n+                    .forEach(files::add);\n+\n@@ -195,13 +188,3 @@\n-                                         .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n-                                         .map(s -> {\n-                                                 int secondSlash = s.getName().indexOf(\"\/\", 1);\n-                                                 assert secondSlash != -1;\n-                                                 String pathWithoutModule = s.getName().substring(secondSlash + 1);\n-                                                 return new JRTArchiveFile(JRTArchive.this,\n-                                                         pathWithoutModule,\n-                                                         EntryType.CLASS_OR_RESOURCE,\n-                                                         null  \/* hashOrTarget *\/,\n-                                                         false \/* symlink *\/,\n-                                                         s);\n-                                         })\n-                                         .toList());\n+                    .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n+                    .map(rd -> new JrtModuleFile(this, rd.getName(), rd))\n+                    .toList());\n@@ -237,9 +220,4 @@\n-                        return new JRTArchiveFile(JRTArchive.this,\n-                                                  m.resPath,\n-                                                  toEntryType(m.resType),\n-                                                  m.hashOrTarget,\n-                                                  m.symlink,\n-                                                  \/* diff only for resources *\/\n-                                                  null);\n-                 })\n-                 .toList());\n+                        return new JrtOtherFile(\n+                                this, m.resPath, toEntryType(m.resType), m.hashOrTarget, m.symlink);\n+                    })\n+                    .toList());\n@@ -327,1 +305,1 @@\n-         *  line: <int>|<int>|<hashOrTarget>|<path>\n+         *  line: {@code <int>|<int>|<hashOrTarget>|<path>}\n@@ -329,1 +307,1 @@\n-         *  Take the integer before '|' convert it to a Type. The second\n+         *  <p>Take the integer before {@code '|'} convert it to a Type. The second\n@@ -440,6 +418,55 @@\n-    record JRTArchiveFile(Archive archive,\n-                          String resPath,\n-                          EntryType resType,\n-                          String sha,\n-                          boolean symlink,\n-                          ResourceDiff diff) implements JRTFile {\n+    record JrtModuleFile(\n+            JRTArchive archive,\n+            String resPath,\n+            ResourceDiff diff) implements JRTFile {\n+        @Override\n+        public Entry toEntry() {\n+            assert resPath.startsWith(\"\/\" + archive.moduleName() + \"\/\");\n+            String resName = resPath.substring(archive.moduleName().length() + 2);\n+\n+            \/\/ If the resource has a diff to the packaged modules, use the diff.\n+            \/\/ Diffs of kind ADDED have been filtered out in collectFiles();\n+            if (diff != null) {\n+                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                assert diff.getName().equals(resPath);\n+\n+                return new Entry(archive, resPath, resName, EntryType.CLASS_OR_RESOURCE) {\n+                    @Override\n+                    public long size() {\n+                        return diff.getResourceBytes().length;\n+                    }\n+                    @Override\n+                    public InputStream stream() {\n+                        return new ByteArrayInputStream(diff.getResourceBytes());\n+                    }\n+                };\n+            } else {\n+                return new Entry(archive, resPath, resName, EntryType.CLASS_OR_RESOURCE) {\n+                    @Override\n+                    public long size() {\n+                        return archive.imageResources.sizeOf(path());\n+                    }\n+\n+                    @Override\n+                    public InputStream stream() {\n+                        return archive.imageResources.open(path());\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n+    record JrtOtherFile(\n+            JRTArchive archive,\n+            String resPath,\n+            EntryType resType,\n+            String sha,\n+            boolean symlink) implements JRTFile {\n+\n+        \/\/ Read from the base JDK image, special casing\n+        \/\/ symlinks, which have the link target in the\n+        \/\/ hashOrTarget field.\n+        Path targetPath() {\n+            return BASE.resolve(symlink ? sha : resPath);\n+        }\n+\n@@ -447,6 +474,8 @@\n-            return new Entry(archive,\n-                             String.format(\"\/%s\/%s\",\n-                                           archive.moduleName(),\n-                                           resPath),\n-                             resPath,\n-                             resType) {\n+            assert resType != EntryType.CLASS_OR_RESOURCE;\n+\n+            return new Entry(\n+                    archive,\n+                    String.format(\"\/%s\/%s\", archive.moduleName(), resPath),\n+                    resPath,\n+                    resType) {\n+\n@@ -456,25 +485,1 @@\n-                        if (resType != EntryType.CLASS_OR_RESOURCE) {\n-                            \/\/ Read from the base JDK image, special casing\n-                            \/\/ symlinks, which have the link target in the\n-                            \/\/ hashOrTarget field\n-                            if (symlink) {\n-                                return Files.size(BASE.resolve(sha));\n-                            }\n-                            return Files.size(BASE.resolve(resPath));\n-                        } else {\n-                            if (diff != null) {\n-                                \/\/ If the resource has a diff to the\n-                                \/\/ packaged modules, use the diff. Diffs of kind\n-                                \/\/ ADDED have been filtered out in collectFiles();\n-                                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n-                                assert diff.getName().equals(String.format(\"\/%s\/%s\",\n-                                                                           archive.moduleName(),\n-                                                                           resPath));\n-                                return diff.getResourceBytes().length;\n-                            }\n-                            \/\/ Read from the module image. This works, because\n-                            \/\/ the underlying base path is a JrtPath with the\n-                            \/\/ JrtFileSystem underneath which is able to handle\n-                            \/\/ this size query.\n-                            return Files.size(archive.getPath().resolve(resPath));\n-                        }\n+                        return Files.size(targetPath());\n@@ -488,20 +493,1 @@\n-                    if (resType != EntryType.CLASS_OR_RESOURCE) {\n-                        \/\/ Read from the base JDK image.\n-                        Path path = symlink ? BASE.resolve(sha) : BASE.resolve(resPath);\n-                        return Files.newInputStream(path);\n-                    } else {\n-                        \/\/ Read from the module image. Use the diff to the\n-                        \/\/ packaged modules if we have one. Diffs of kind\n-                        \/\/ ADDED have been filtered out in collectFiles();\n-                        if (diff != null) {\n-                            assert diff.getKind() != ResourceDiff.Kind.ADDED;\n-                            assert diff.getName().equals(String.format(\"\/%s\/%s\",\n-                                                                       archive.moduleName(),\n-                                                                       resPath));\n-                            return new ByteArrayInputStream(diff.getResourceBytes());\n-                        }\n-                        String module = archive.moduleName();\n-                        ModuleReference mRef = ModuleFinder.ofSystem()\n-                                                    .find(module).orElseThrow();\n-                        return mRef.open().open(resPath).orElseThrow();\n-                    }\n+                    return Files.newInputStream(targetPath());\n@@ -509,1 +495,0 @@\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":100,"deletions":115,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -352,15 +352,16 @@\n-        ImageProvider imageProvider =\n-                createImageProvider(config,\n-                                    null,\n-                                    IGNORE_SIGNING_DEFAULT,\n-                                    false,\n-                                    null,\n-                                    false,\n-                                    new OptionsValues(),\n-                                    null);\n-\n-        \/\/ Then create the Plugin Stack\n-        ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(plugins);\n-\n-        \/\/Ask the stack to proceed;\n-        stack.operate(imageProvider);\n+        try (ImageHelper imageProvider =\n+                     createImageProvider(config,\n+                             null,\n+                             IGNORE_SIGNING_DEFAULT,\n+                             false,\n+                             null,\n+                             false,\n+                             new OptionsValues(),\n+                             null)) {\n+\n+            \/\/ Then create the Plugin Stack\n+            ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(plugins);\n+\n+            \/\/Ask the stack to proceed;\n+            stack.operate(imageProvider);\n+        }\n@@ -489,16 +490,19 @@\n-        ImageHelper imageProvider = createImageProvider(config,\n-                                                        options.packagedModulesPath,\n-                                                        options.ignoreSigning,\n-                                                        options.bindServices,\n-                                                        options.endian,\n-                                                        options.verbose,\n-                                                        options,\n-                                                        log);\n-\n-        \/\/ Then create the Plugin Stack\n-        ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(\n-            taskHelper.getPluginsConfig(options.output, options.launchers,\n-                    imageProvider.targetPlatform));\n-\n-        \/\/Ask the stack to proceed\n-        stack.operate(imageProvider);\n+        try (ImageHelper imageProvider = createImageProvider(config,\n+                options.packagedModulesPath,\n+                options.ignoreSigning,\n+                options.bindServices,\n+                options.endian,\n+                options.verbose,\n+                options,\n+                log)) {\n+            \/\/ Then create the Plugin Stack\n+            ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(\n+                    taskHelper.getPluginsConfig(\n+                            options.output,\n+                            options.launchers,\n+                            imageProvider.targetPlatform));\n+\n+            \/\/Ask the stack to proceed\n+            stack.operate(imageProvider);\n+        }\n+\n@@ -1030,4 +1034,5 @@\n-    private static record ImageHelper(Set<Archive> archives,\n-                                      Platform targetPlatform,\n-                                      Path packagedModulesPath,\n-                                      boolean generateRuntimeImage) implements ImageProvider {\n+    private record ImageHelper(Set<Archive> archives,\n+                               Platform targetPlatform,\n+                               Path packagedModulesPath,\n+                               boolean generateRuntimeImage)\n+            implements ImageProvider, AutoCloseable {\n@@ -1049,0 +1054,7 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            for (Archive archive : archives) {\n+                archive.close();\n+            }\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.stream.Collectors;\n@@ -50,0 +51,1 @@\n+ *          jdk.jlink\n@@ -52,1 +54,1 @@\n- * @run main\/othervm\/timeout=1200 -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n+ * @run main\/othervm\/timeout=1200 -ea -esa -DDISABLE_PREVIEW_PATCHING=false -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n@@ -73,1 +75,0 @@\n-\n@@ -123,3 +124,2 @@\n-        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n-            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n-        }\n+        assertSameContent(\"jmod-less\", jimageContentJmodLess, \"jmod-full\", jimageContentJmodFull);\n+        \/\/ Both lists are same size, with same names, so enumerate either.\n@@ -148,0 +148,41 @@\n+    \/\/ Helper to assert the content of two jimage files are the same and provide\n+    \/\/ useful debug information otherwise.\n+    private static void assertSameContent(\n+            String lhsLabel, List<String> lhsNames, String rhsLabel, List<String> rhsNames) {\n+        int lhsSize = lhsNames.size();\n+        int rhsSize = rhsNames.size();\n+        \/\/ Both input lists are sorted, enumerate the differences for debugging.\n+        List<String> lhsOnly = new ArrayList<>();\n+        List<String> rhsOnly = new ArrayList<>();\n+        int i = 0;\n+        int j = 0;\n+        while (i < lhsSize && j < rhsSize) {\n+            String lhsName = lhsNames.get(i);\n+            String rhsName = rhsNames.get(j);\n+            int signum = lhsName.compareTo(rhsName);\n+            if (signum == 0) {\n+                i += 1;\n+                j += 1;\n+            } else if (signum < 0) {\n+                lhsOnly.add(lhsName);\n+                i += 1;\n+            } else {\n+                rhsOnly.add(rhsName);\n+                j += 1;\n+            }\n+        }\n+        lhsOnly.addAll(lhsNames.subList(i, lhsSize));\n+        rhsOnly.addAll(rhsNames.subList(j, rhsSize));\n+        if (!lhsOnly.isEmpty() || !rhsOnly.isEmpty()) {\n+            String message = String.format(\n+                    \"jimage content differs for %s (%d) v. %s (%d)\", lhsLabel, lhsSize, rhsLabel, rhsSize);\n+            if (!lhsOnly.isEmpty()) {\n+                message += \"\\nOnly in \" + lhsLabel + \":\\n\\t\" + String.join(\"\\n\\t\", lhsOnly);\n+            }\n+            if (!rhsOnly.isEmpty()) {\n+                message += \"\\nOnly in \" + rhsLabel + \":\\n\\t\" + String.join(\"\\n\\t\", rhsOnly);\n+            }\n+            throw new AssertionError(message);\n+        }\n+    }\n+\n@@ -149,1 +190,7 @@\n-        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+        return pathStartsWith(path, \"\/packages\") || pathStartsWith(path, \"\/modules\");\n+    }\n+\n+    \/\/ Handle both \"<prefix>\" and \"<prefix>\/...\".\n+    private static boolean pathStartsWith(String path, String prefix) {\n+        int plen = prefix.length();\n+        return path.startsWith(prefix) && (path.length() == plen || path.charAt(plen) == '\/');\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"}]}