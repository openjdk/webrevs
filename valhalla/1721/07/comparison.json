{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.util.NoSuchElementException;\n@@ -41,0 +42,1 @@\n+import java.util.Random;\n@@ -42,0 +44,2 @@\n+import java.util.stream.Stream;\n+\n@@ -329,0 +333,50 @@\n+    \/**\n+     * Returns the \"raw\" API for accessing underlying jimage resource entries.\n+     *\n+     * <p>This is only meaningful for use by code dealing directly with jimage\n+     * files, and cannot be used to reliably lookup resources used at runtime.\n+     *\n+     * <p>This API remains valid until the image reader from which it was\n+     * obtained is closed.\n+     *\/\n+    \/\/ Package visible for use by ImageReader.\n+    ResourceEntries getResourceEntries() {\n+        return new ResourceEntries() {\n+            @Override\n+            public Stream<String> getEntryNames(String module) {\n+                if (module.isEmpty() || module.equals(\"modules\") || module.equals(\"packages\")) {\n+                    throw new IllegalArgumentException(\"Invalid module name: \" + module);\n+                }\n+                return IntStream.range(0, offsets.capacity())\n+                        .map(offsets::get)\n+                        .filter(offset -> offset != 0)\n+                        \/\/ Reusing a location instance or getting the module\n+                        \/\/ offset directly would save a lot of allocations here.\n+                        .mapToObj(offset -> ImageLocation.readFrom(BasicImageReader.this, offset))\n+                        \/\/ Reverse lookup of module offset would be faster here.\n+                        .filter(loc -> module.equals(loc.getModule()))\n+                        .map(ImageLocation::getFullName);\n+            }\n+\n+            private ImageLocation getResourceLocation(String name) {\n+                if (!name.startsWith(\"\/modules\/\") && !name.startsWith(\"\/packages\/\")) {\n+                    ImageLocation location = BasicImageReader.this.findLocation(name);\n+                    if (location != null) {\n+                        return location;\n+                    }\n+                }\n+                throw new NoSuchElementException(\"No such resource entry: \" + name);\n+            }\n+\n+            @Override\n+            public long getSize(String name) {\n+                return getResourceLocation(name).getUncompressedSize();\n+            }\n+\n+            @Override\n+            public InputStream open(String name) {\n+                return BasicImageReader.this.getResourceStream(getResourceLocation(name));\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -233,0 +233,5 @@\n+    \/\/ Package protected for use only by SystemImageReader.\n+    ResourceEntries getResourceEntries() {\n+        return reader.getResourceEntries();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jimage;\n+\n+import java.io.InputStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Accesses the underlying resource entries in a jimage file.\n+ *\n+ * <p>This API is designed only for use by the jlink classes, which read the raw\n+ * jimage files. Use the {@link ImageReader} API to read jimage contents at\n+ * runtime to correctly account for preview mode.\n+ *\n+ * <p>This API ignores the {@code previewMode} of the {@link ImageReader} from\n+ * which it is obtained, and returns an unmapped view of entries (e.g. allowing\n+ * for direct access of resources in the {@code META-INF\/preview\/...} namespace).\n+ *\n+ * <p>It disallows access to resource directories (i.e. {@code \"\/modules\/...\"})\n+ * or packages entries (i.e. {@code \"\/packages\/...\"}).\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ *\/\n+public interface ResourceEntries {\n+    \/**\n+     * Returns the jimage names for all resources in the given module, in\n+     * random order. Entry names will always be prefixed by the given module\n+     * name (e.g. {@code \"\/<module-name>\/...\"}).\n+     *\/\n+    Stream<String> getEntryNames(String module);\n+\n+    \/**\n+     * Returns the (uncompressed) size of a resource given its jimage name.\n+     *\n+     * @throws java.util.NoSuchElementException if the resource does not exist.\n+     *\/\n+    long getSize(String name);\n+\n+    \/**\n+     * Returns an {@link InputStream} for a resource given its jimage name.\n+     *\n+     * @throws java.util.NoSuchElementException if the resource does not exist.\n+     *\/\n+    InputStream open(String name);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ResourceEntries.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -76,0 +76,10 @@\n+    \/**\n+     * Returns the \"raw\" API for accessing underlying jimage resource entries.\n+     *\n+     * <p>This is only meaningful for use by code dealing directly with jimage\n+     * files, and cannot be used to reliably lookup resources used at runtime.\n+     *\/\n+    public static ResourceEntries getResourceEntries() {\n+        return get().getResourceEntries();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/SystemImageReader.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.Closeable;\n@@ -37,1 +38,1 @@\n-public interface Archive {\n+public interface Archive extends Closeable {\n@@ -62,5 +63,6 @@\n-         * Constructs an entry of the given archive\n-         * @param archive archive\n-         * @param path\n-         * @param name an entry name that does not contain the module name\n-         * @param type\n+         * Constructs an entry of the given archive.\n+         *\n+         * @param archive the archive in which this entry exists.\n+         * @param path the complete path of the entry, including the module.\n+         * @param name an entry name relative to its containing module.\n+         * @param type the entry type.\n@@ -75,4 +77,0 @@\n-        public final Archive archive() {\n-            return archive;\n-        }\n-\n@@ -137,0 +135,1 @@\n+    @Override\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Archive.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Red Hat, Inc.\n+ * Copyright (c) 2024, 2025 Red Hat, Inc.\n@@ -35,1 +35,0 @@\n-import java.lang.module.ModuleReference;\n@@ -54,0 +53,2 @@\n+import jdk.internal.jimage.ResourceEntries;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -66,1 +67,0 @@\n-\n@@ -69,1 +69,1 @@\n-    private final ModuleReference ref;\n+    private final ResourceEntries imageResources;\n@@ -102,6 +102,5 @@\n-        this.ref = ModuleFinder.ofSystem()\n-                               .find(module)\n-                               .orElseThrow(() ->\n-                                    new IllegalArgumentException(\n-                                            \"Module \" + module +\n-                                            \" not part of the JDK install\"));\n+        ModuleFinder.ofSystem()\n+                .find(module)\n+                .orElseThrow(() -> new IllegalArgumentException(\n+                        \"Module \" + module + \" not part of the JDK install\"));\n+        this.imageResources = SystemImageReader.getResourceEntries();\n@@ -162,0 +161,11 @@\n+    private boolean isNormalOrModifiedDiff(String name) {\n+        ResourceDiff rd = resDiff.get(name);\n+        \/\/ Filter all resources with a resource diff of kind MODIFIED.\n+        \/\/ Note that REMOVED won't happen since in that case the module listing\n+        \/\/ won't have the resource anyway.\n+        \/\/ Note as well that filter removes files of kind ADDED. Those files are\n+        \/\/ not in the packaged modules, so ought not to get returned from the\n+        \/\/ pipeline.\n+        return (rd == null || rd.getKind() == ResourceDiff.Kind.MODIFIED);\n+    }\n+\n@@ -165,0 +175,1 @@\n+\n@@ -167,25 +178,6 @@\n-            files.addAll(ref.open().list()\n-                                   .filter(i -> {\n-                                           String lookupKey = String.format(\"\/%s\/%s\", module, i);\n-                                           ResourceDiff rd = resDiff.get(lookupKey);\n-                                           \/\/ Filter all resources with a resource diff\n-                                           \/\/ that are of kind MODIFIED.\n-                                           \/\/ Note that REMOVED won't happen since in\n-                                           \/\/ that case the module listing won't have\n-                                           \/\/ the resource anyway.\n-                                           \/\/ Note as well that filter removes files\n-                                           \/\/ of kind ADDED. Those files are not in\n-                                           \/\/ the packaged modules, so ought not to\n-                                           \/\/ get returned from the pipeline.\n-                                           return (rd == null ||\n-                                                   rd.getKind() == ResourceDiff.Kind.MODIFIED);\n-                                   })\n-                                   .map(s -> {\n-                                           String lookupKey = String.format(\"\/%s\/%s\", module, s);\n-                                           return new JRTArchiveFile(JRTArchive.this, s,\n-                                                           EntryType.CLASS_OR_RESOURCE,\n-                                                           null \/* hashOrTarget *\/,\n-                                                           false \/* symlink *\/,\n-                                                           resDiff.get(lookupKey));\n-                                   })\n-                                   .toList());\n+            imageResources.getEntryNames(module)\n+                    .filter(this::isNormalOrModifiedDiff)\n+                    .sorted()\n+                    .map(name -> new JrtModuleFile(this, name, resDiff.get(name)))\n+                    .forEach(files::add);\n+\n@@ -195,13 +187,3 @@\n-                                         .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n-                                         .map(s -> {\n-                                                 int secondSlash = s.getName().indexOf(\"\/\", 1);\n-                                                 assert secondSlash != -1;\n-                                                 String pathWithoutModule = s.getName().substring(secondSlash + 1);\n-                                                 return new JRTArchiveFile(JRTArchive.this,\n-                                                         pathWithoutModule,\n-                                                         EntryType.CLASS_OR_RESOURCE,\n-                                                         null  \/* hashOrTarget *\/,\n-                                                         false \/* symlink *\/,\n-                                                         s);\n-                                         })\n-                                         .toList());\n+                    .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n+                    .map(rd -> new JrtModuleFile(this, rd.getName(), rd))\n+                    .toList());\n@@ -237,9 +219,4 @@\n-                        return new JRTArchiveFile(JRTArchive.this,\n-                                                  m.resPath,\n-                                                  toEntryType(m.resType),\n-                                                  m.hashOrTarget,\n-                                                  m.symlink,\n-                                                  \/* diff only for resources *\/\n-                                                  null);\n-                 })\n-                 .toList());\n+                        return new JrtOtherFile(\n+                                this, m.resPath, toEntryType(m.resType), m.hashOrTarget, m.symlink);\n+                    })\n+                    .toList());\n@@ -326,1 +303,1 @@\n-        \/**\n+        \/*\n@@ -329,2 +306,2 @@\n-         *  Take the integer before '|' convert it to a Type. The second\n-         *  token is an integer representing symlinks (or not). The third token is\n+         *  Take the integer before '|' convert it to a Type. The second token\n+         *  is an integer representing symlinks (or not). The third token is\n@@ -440,6 +417,55 @@\n-    record JRTArchiveFile(Archive archive,\n-                          String resPath,\n-                          EntryType resType,\n-                          String sha,\n-                          boolean symlink,\n-                          ResourceDiff diff) implements JRTFile {\n+    record JrtModuleFile(\n+            JRTArchive archive,\n+            String resPath,\n+            ResourceDiff diff) implements JRTFile {\n+        @Override\n+        public Entry toEntry() {\n+            assert resPath.startsWith(\"\/\" + archive.moduleName() + \"\/\");\n+            String resName = resPath.substring(archive.moduleName().length() + 2);\n+\n+            \/\/ If the resource has a diff to the packaged modules, use the diff.\n+            \/\/ Diffs of kind ADDED have been filtered out in collectFiles();\n+            if (diff != null) {\n+                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                assert diff.getName().equals(resPath);\n+\n+                return new Entry(archive, resPath, resName, EntryType.CLASS_OR_RESOURCE) {\n+                    @Override\n+                    public long size() {\n+                        return diff.getResourceBytes().length;\n+                    }\n+                    @Override\n+                    public InputStream stream() {\n+                        return new ByteArrayInputStream(diff.getResourceBytes());\n+                    }\n+                };\n+            } else {\n+                return new Entry(archive, resPath, resName, EntryType.CLASS_OR_RESOURCE) {\n+                    @Override\n+                    public long size() {\n+                        return archive.imageResources.getSize(resPath);\n+                    }\n+\n+                    @Override\n+                    public InputStream stream() {\n+                        return archive.imageResources.open(resPath);\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n+    record JrtOtherFile(\n+            JRTArchive archive,\n+            String resPath,\n+            EntryType resType,\n+            String sha,\n+            boolean symlink) implements JRTFile {\n+\n+        \/\/ Read from the base JDK image, special casing\n+        \/\/ symlinks, which have the link target in the\n+        \/\/ hashOrTarget field.\n+        Path targetPath() {\n+            return BASE.resolve(symlink ? sha : resPath);\n+        }\n+\n@@ -447,6 +473,8 @@\n-            return new Entry(archive,\n-                             String.format(\"\/%s\/%s\",\n-                                           archive.moduleName(),\n-                                           resPath),\n-                             resPath,\n-                             resType) {\n+            assert resType != EntryType.CLASS_OR_RESOURCE;\n+\n+            return new Entry(\n+                    archive,\n+                    String.format(\"\/%s\/%s\", archive.moduleName(), resPath),\n+                    resPath,\n+                    resType) {\n+\n@@ -456,25 +484,1 @@\n-                        if (resType != EntryType.CLASS_OR_RESOURCE) {\n-                            \/\/ Read from the base JDK image, special casing\n-                            \/\/ symlinks, which have the link target in the\n-                            \/\/ hashOrTarget field\n-                            if (symlink) {\n-                                return Files.size(BASE.resolve(sha));\n-                            }\n-                            return Files.size(BASE.resolve(resPath));\n-                        } else {\n-                            if (diff != null) {\n-                                \/\/ If the resource has a diff to the\n-                                \/\/ packaged modules, use the diff. Diffs of kind\n-                                \/\/ ADDED have been filtered out in collectFiles();\n-                                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n-                                assert diff.getName().equals(String.format(\"\/%s\/%s\",\n-                                                                           archive.moduleName(),\n-                                                                           resPath));\n-                                return diff.getResourceBytes().length;\n-                            }\n-                            \/\/ Read from the module image. This works, because\n-                            \/\/ the underlying base path is a JrtPath with the\n-                            \/\/ JrtFileSystem underneath which is able to handle\n-                            \/\/ this size query.\n-                            return Files.size(archive.getPath().resolve(resPath));\n-                        }\n+                        return Files.size(targetPath());\n@@ -488,20 +492,1 @@\n-                    if (resType != EntryType.CLASS_OR_RESOURCE) {\n-                        \/\/ Read from the base JDK image.\n-                        Path path = symlink ? BASE.resolve(sha) : BASE.resolve(resPath);\n-                        return Files.newInputStream(path);\n-                    } else {\n-                        \/\/ Read from the module image. Use the diff to the\n-                        \/\/ packaged modules if we have one. Diffs of kind\n-                        \/\/ ADDED have been filtered out in collectFiles();\n-                        if (diff != null) {\n-                            assert diff.getKind() != ResourceDiff.Kind.ADDED;\n-                            assert diff.getName().equals(String.format(\"\/%s\/%s\",\n-                                                                       archive.moduleName(),\n-                                                                       resPath));\n-                            return new ByteArrayInputStream(diff.getResourceBytes());\n-                        }\n-                        String module = archive.moduleName();\n-                        ModuleReference mRef = ModuleFinder.ofSystem()\n-                                                    .find(module).orElseThrow();\n-                        return mRef.open().open(resPath).orElseThrow();\n-                    }\n+                    return Files.newInputStream(targetPath());\n@@ -509,1 +494,0 @@\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":102,"deletions":118,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -352,15 +352,16 @@\n-        ImageProvider imageProvider =\n-                createImageProvider(config,\n-                                    null,\n-                                    IGNORE_SIGNING_DEFAULT,\n-                                    false,\n-                                    null,\n-                                    false,\n-                                    new OptionsValues(),\n-                                    null);\n-\n-        \/\/ Then create the Plugin Stack\n-        ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(plugins);\n-\n-        \/\/Ask the stack to proceed;\n-        stack.operate(imageProvider);\n+        try (ImageHelper imageProvider =\n+                     createImageProvider(config,\n+                             null,\n+                             IGNORE_SIGNING_DEFAULT,\n+                             false,\n+                             null,\n+                             false,\n+                             new OptionsValues(),\n+                             null)) {\n+\n+            \/\/ Then create the Plugin Stack\n+            ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(plugins);\n+\n+            \/\/ Ask the stack to proceed;\n+            stack.operate(imageProvider);\n+        }\n@@ -489,16 +490,18 @@\n-        ImageHelper imageProvider = createImageProvider(config,\n-                                                        options.packagedModulesPath,\n-                                                        options.ignoreSigning,\n-                                                        options.bindServices,\n-                                                        options.endian,\n-                                                        options.verbose,\n-                                                        options,\n-                                                        log);\n-\n-        \/\/ Then create the Plugin Stack\n-        ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(\n-            taskHelper.getPluginsConfig(options.output, options.launchers,\n-                    imageProvider.targetPlatform));\n-\n-        \/\/Ask the stack to proceed\n-        stack.operate(imageProvider);\n+        try (ImageHelper imageProvider = createImageProvider(config,\n+                options.packagedModulesPath,\n+                options.ignoreSigning,\n+                options.bindServices,\n+                options.endian,\n+                options.verbose,\n+                options,\n+                log)) {\n+            \/\/ Then create the Plugin Stack\n+            ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(\n+                    taskHelper.getPluginsConfig(\n+                            options.output,\n+                            options.launchers,\n+                            imageProvider.targetPlatform));\n+\n+            \/\/Ask the stack to proceed\n+            stack.operate(imageProvider);\n+        }\n@@ -1030,4 +1033,5 @@\n-    private static record ImageHelper(Set<Archive> archives,\n-                                      Platform targetPlatform,\n-                                      Path packagedModulesPath,\n-                                      boolean generateRuntimeImage) implements ImageProvider {\n+    private record ImageHelper(Set<Archive> archives,\n+                               Platform targetPlatform,\n+                               Path packagedModulesPath,\n+                               boolean generateRuntimeImage)\n+            implements ImageProvider, AutoCloseable {\n@@ -1049,0 +1053,20 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            List<IOException> thrown = null;\n+            for (Archive archive : archives) {\n+                try {\n+                    archive.close();\n+                } catch (IOException ex) {\n+                    if (thrown == null) {\n+                        thrown = new ArrayList<>();\n+                    }\n+                    thrown.add(ex);\n+                }\n+            }\n+            if (thrown != null) {\n+                IOException ex = new IOException(\"Archives could not be closed\", thrown.getFirst());\n+                thrown.subList(1, thrown.size()).forEach(ex::addSuppressed);\n+                throw ex;\n+            }\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":60,"deletions":36,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Red Hat, Inc.\n+ * Copyright (c) 2024, 2025, Red Hat, Inc.\n@@ -34,0 +34,4 @@\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n@@ -50,0 +54,1 @@\n+ *          jdk.jlink\n@@ -52,1 +57,1 @@\n- * @run main\/othervm\/timeout=1200 -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n+ * @run main\/othervm\/timeout=1200 -ea -esa -DDISABLE_PREVIEW_PATCHING=false -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n@@ -73,1 +78,0 @@\n-\n@@ -123,3 +127,2 @@\n-        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n-            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n-        }\n+        assertSameContent(\"jmod-less\", jimageContentJmodLess, \"jmod-full\", jimageContentJmodFull);\n+        \/\/ Both lists are same size, with same names, so enumerate either.\n@@ -148,0 +151,23 @@\n+    \/\/ Helper to assert the content of two jimage files are the same and provide\n+    \/\/ useful debug information otherwise.\n+    private static void assertSameContent(\n+            String lhsLabel, List<String> lhsNames, String rhsLabel, List<String> rhsNames) {\n+\n+        List<String> lhsOnly =\n+                lhsNames.stream().filter(Predicate.not(Set.copyOf(rhsNames)::contains)).toList();\n+        List<String> rhsOnly =\n+                rhsNames.stream().filter(Predicate.not(Set.copyOf(lhsNames)::contains)).toList();\n+        if (!lhsOnly.isEmpty() || !rhsOnly.isEmpty()) {\n+            String message = String.format(\n+                    \"jimage content differs for %s (%d) v. %s (%d)\",\n+                    lhsLabel, lhsNames.size(), rhsLabel, rhsNames.size());\n+            if (!lhsOnly.isEmpty()) {\n+                message += \"\\nOnly in \" + lhsLabel + \":\\n\\t\" + String.join(\"\\n\\t\", lhsOnly);\n+            }\n+            if (!rhsOnly.isEmpty()) {\n+                message += \"\\nOnly in \" + rhsLabel + \":\\n\\t\" + String.join(\"\\n\\t\", rhsOnly);\n+            }\n+            throw new AssertionError(message);\n+        }\n+    }\n+\n@@ -149,1 +175,7 @@\n-        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+        return pathStartsWith(path, \"\/packages\") || pathStartsWith(path, \"\/modules\");\n+    }\n+\n+    \/\/ Handle both \"<prefix>\" and \"<prefix>\/...\".\n+    private static boolean pathStartsWith(String path, String prefix) {\n+        int plen = prefix.length();\n+        return path.startsWith(prefix) && (path.length() == plen || path.charAt(plen) == '\/');\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"}]}