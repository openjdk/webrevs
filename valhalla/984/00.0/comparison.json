{"files":[{"patch":"@@ -65,2 +65,2 @@\n-  MODULES_FILTER += jdk.internal.vm.compiler\n-  MODULES_FILTER += jdk.internal.vm.compiler.management\n+  MODULES_FILTER += jdk.graal.compiler\n+  MODULES_FILTER += jdk.graal.compiler.management\n","filename":"make\/common\/Modules.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+        --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+          \/*release*\/ true, \/*weak*\/ false, tmp3Reg); \/\/ Sets flags for result\n@@ -160,1 +160,1 @@\n-  cmp(rscratch1, rthread);\n+  cmp(tmp3Reg, rthread);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"prims\/upcallLinker.hpp\"\n@@ -7355,0 +7356,15 @@\n+  \/\/ exception handler for upcall stubs\n+  address generate_upcall_stub_exception_handler() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+    address start = __ pc();\n+\n+    \/\/ Native caller has no idea how to handle exceptions,\n+    \/\/ so we just crash here. Up to callee to catch exceptions.\n+    __ verify_oop(r0);\n+    __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception));\n+    __ blr(rscratch1);\n+    __ should_not_reach_here();\n+\n+    return start;\n+  }\n+\n@@ -8541,0 +8557,2 @@\n+    StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3885,2 +3885,0 @@\n-    Register tmp3_aliased = len;\n-\n@@ -3890,2 +3888,2 @@\n-    andl(tmp1, 64 - 1);   \/\/ tail count (in chars) 0x3F\n-    andl(len, ~(64 - 1));    \/\/ vector count (in chars)\n+    andl(tmp1, 0x0000003f); \/\/ tail count (in chars) 0x3F\n+    andl(len,  0xffffffc0); \/\/ vector count (in chars)\n@@ -3911,0 +3909,2 @@\n+\n+    \/\/ check the tail for absense of negatives\n@@ -3913,4 +3913,7 @@\n-    mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);\n-    shlxq(tmp3_aliased, tmp3_aliased, tmp1);\n-    notq(tmp3_aliased);\n-    kmovql(mask2, tmp3_aliased);\n+    {\n+      Register tmp3_aliased = len;\n+      mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);\n+      shlxq(tmp3_aliased, tmp3_aliased, tmp1);\n+      notq(tmp3_aliased);\n+      kmovql(mask2, tmp3_aliased);\n+    }\n@@ -3948,0 +3951,5 @@\n+    \/\/ do a full check for negative registers in the tail\n+    movl(len, tmp1); \/\/ tmp1 holds low 6-bit from original len;\n+                     \/\/ ary1 already pointing to the right place\n+    jmpb(TAIL_START);\n+\n@@ -3949,1 +3957,1 @@\n-    \/\/ At least one byte in the last 64 bytes is negative.\n+    \/\/ At least one byte in the last 64 byte block was negative.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -10054,0 +10054,11 @@\n+  }\n+}\n+\n+void MacroAssembler::vpshufb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    vpshufb(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    vpshufb(dst, nds, Address(rscratch, 0), vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1858,0 +1858,3 @@\n+  using Assembler::vpshufb;\n+  void vpshufb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"prims\/upcallLinker.hpp\"\n@@ -3908,0 +3909,18 @@\n+\/\/ exception handler for upcall stubs\n+address StubGenerator::generate_upcall_stub_exception_handler() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"upcall stub exception handler\");\n+  address start = __ pc();\n+\n+  \/\/ native caller has no idea how to handle exceptions\n+  \/\/ we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(rax);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, rax);\n+  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n+  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, UpcallLinker::handle_uncaught_exception)));\n+  __ should_not_reach_here();\n+\n+  return start;\n+}\n+\n@@ -4214,0 +4233,2 @@\n+\n+  StubRoutines::_upcall_stub_exception_handler = generate_upcall_stub_exception_handler();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -330,0 +330,4 @@\n+  \/\/ AVX2 AES Galois Counter Mode implementation\n+  address generate_avx2_galoisCounterMode_AESCrypt();\n+  void aesgcm_avx2(Register in, Register len, Register ct, Register out, Register key,\n+                   Register state, Register subkeyHtbl, Register counter);\n@@ -356,0 +360,11 @@\n+  \/\/ AVX2 AES-GCM related functions\n+  void initial_blocks_avx2(XMMRegister ctr, Register rounds, Register key, Register len,\n+                           Register in, Register out, Register ct, XMMRegister aad_hashx, Register pos);\n+  void gfmul_avx2(XMMRegister GH, XMMRegister HK);\n+  void generateHtbl_8_block_avx2(Register htbl);\n+  void ghash8_encrypt8_parallel_avx2(Register key, Register subkeyHtbl, XMMRegister ctr_blockx, Register in,\n+                                     Register out, Register ct, Register pos, bool out_order, Register rounds,\n+                                     XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                     XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, XMMRegister xmm8);\n+  void ghash_last_8_avx2(Register subkeyHtbl);\n+\n@@ -553,0 +568,3 @@\n+  \/\/ shared exception handler for FFM upcall stubs\n+  address generate_upcall_stub_exception_handler();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -141,1 +142,1 @@\n-  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(CDSConfig::is_dumping_heap(), \"dump-time only\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -249,1 +250,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -100,1 +101,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -271,1 +272,1 @@\n-  if (DumpSharedSpaces && HeapShared::can_write()) {\n+  if (CDSConfig::is_dumping_heap()) {\n@@ -372,1 +373,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -532,1 +533,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -579,1 +580,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -606,1 +607,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -615,1 +616,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -756,1 +757,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -1582,1 +1583,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -645,1 +646,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -672,1 +673,1 @@\n-  if (!DumpSharedSpaces || UseCompressedOops) {\n+  if (!CDSConfig::is_dumping_heap() || UseCompressedOops) {\n@@ -779,4 +780,6 @@\n-  StringTable::allocate_shared_strings_array(CHECK);\n-  ArchiveHeapWriter::init();\n-  if (use_full_module_graph()) {\n-    HeapShared::reset_archived_object_states(CHECK);\n+  if (CDSConfig::is_dumping_heap()) {\n+    StringTable::allocate_shared_strings_array(CHECK);\n+    ArchiveHeapWriter::init();\n+    if (use_full_module_graph()) {\n+      HeapShared::reset_archived_object_states(CHECK);\n+    }\n@@ -794,1 +797,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -3050,1 +3051,1 @@\n-  if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {\n+  if (JvmtiExport::can_maintain_original_method_order() || CDSConfig::is_dumping_archive()) {\n@@ -3064,1 +3065,1 @@\n-  if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {\n+  if (JvmtiExport::can_maintain_original_method_order() || CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -449,1 +450,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -519,1 +520,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -534,1 +535,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -548,1 +549,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -636,1 +637,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -1252,1 +1253,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -1446,1 +1447,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -1452,1 +1453,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -1461,1 +1462,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1091,1 +1092,1 @@\n-    if (DumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_heap()) {\n@@ -1446,1 +1447,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1866,1 +1867,1 @@\n-    if (Arguments::is_dumping_archive() && klass_being_linked != nullptr &&\n+    if (CDSConfig::is_dumping_archive() && klass_being_linked != nullptr &&\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -119,1 +119,1 @@\n-    if (Arguments::is_dumping_archive()) {\n+    if (CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -770,3 +770,1 @@\n-UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size,\n-                       intptr_t exception_handler_offset,\n-                       jobject receiver, ByteSize frame_data_offset) :\n+UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset) :\n@@ -775,1 +773,0 @@\n-  _exception_handler_offset(exception_handler_offset),\n@@ -785,3 +782,1 @@\n-UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb,\n-                               intptr_t exception_handler_offset,\n-                               jobject receiver, ByteSize frame_data_offset) {\n+UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset) {\n@@ -794,2 +789,1 @@\n-    blob = new (size) UpcallStub(name, cb, size,\n-                                         exception_handler_offset, receiver, frame_data_offset);\n+    blob = new (size) UpcallStub(name, cb, size, receiver, frame_data_offset);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -767,1 +767,0 @@\n-  intptr_t _exception_handler_offset;\n@@ -771,3 +770,1 @@\n-  UpcallStub(const char* name, CodeBuffer* cb, int size,\n-                     intptr_t exception_handler_offset,\n-                     jobject receiver, ByteSize frame_data_offset);\n+  UpcallStub(const char* name, CodeBuffer* cb, int size, jobject receiver, ByteSize frame_data_offset);\n@@ -788,3 +785,1 @@\n-  static UpcallStub* create(const char* name, CodeBuffer* cb,\n-                            intptr_t exception_handler_offset,\n-                            jobject receiver, ByteSize frame_data_offset);\n+  static UpcallStub* create(const char* name, CodeBuffer* cb, jobject receiver, ByteSize frame_data_offset);\n@@ -794,1 +789,0 @@\n-  address exception_handler() { return code_begin() + _exception_handler_offset; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2214,1 +2214,3 @@\n-        failure_reason = os::strdup(err_msg(\"Error attaching to libjvmci (err: %d)\", env.init_error()), mtJVMCI);\n+        const char* msg = env.init_error_msg();\n+        failure_reason = os::strdup(err_msg(\"Error attaching to libjvmci (err: %d, %s)\",\n+                                    env.init_error(), msg == nullptr ? \"unknown\" : msg), mtJVMCI);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2056,3 +2056,10 @@\n-    CodeCache::UnloadingScope scope(is_alive_closure());\n-    \/\/ Follow system dictionary roots and unload classes.\n-    bool purged_class = SystemDictionary::do_unloading(&_gc_timer);\n+    bool unloading_occurred;\n+    {\n+      CodeCache::UnlinkingScope scope(is_alive_closure());\n+\n+      \/\/ Follow system dictionary roots and unload classes.\n+      unloading_occurred = SystemDictionary::do_unloading(&_gc_timer);\n+\n+      \/\/ Unload nmethods.\n+      CodeCache::do_unloading(unloading_occurred);\n+    }\n@@ -2061,2 +2068,2 @@\n-    \/\/ Unload nmethods.\n-    CodeCache::do_unloading(purged_class);\n+    \/\/ Release unloaded nmethods's memory.\n+    CodeCache::flush_unlinked_nmethods();\n@@ -2065,1 +2072,1 @@\n-    Klass::clean_weak_klass_links(purged_class);\n+    Klass::clean_weak_klass_links(unloading_occurred);\n@@ -2068,1 +2075,1 @@\n-    JVMCI_ONLY(JVMCI::do_unloading(purged_class));\n+    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -121,1 +121,1 @@\n-  if (!HAS_PENDING_EXCEPTION && Arguments::is_dumping_archive()) {\n+  if (!HAS_PENDING_EXCEPTION && CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -833,1 +834,1 @@\n-  if (Arguments::is_dumping_archive()) {\n+  if (CDSConfig::is_dumping_archive()) {\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -223,1 +224,1 @@\n-    if (DumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_heap()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -713,1 +714,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -747,1 +748,1 @@\n-    Arguments::assert_is_dumping_archive();\n+    assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\/\/ HierarchicalFieldStream allows to also iterate over fields of supertypes.\n@@ -147,1 +148,1 @@\n-\/\/ Iterate over only the internal fields\n+\/\/ Iterate over only the Java fields\n@@ -191,0 +192,100 @@\n+\/\/ Iterate over fields including the ones declared in supertypes\n+template<typename FieldStreamType>\n+class HierarchicalFieldStream : public StackObj  {\n+ private:\n+  const Array<InstanceKlass*>* _interfaces;\n+  InstanceKlass* _next_klass; \/\/ null indicates no more type to visit\n+  FieldStreamType _current_stream;\n+  int _interface_index;\n+\n+  void prepare() {\n+    _next_klass = next_klass_with_fields();\n+    \/\/ special case: the initial klass has no fields. If any supertype has any fields, use that directly.\n+    \/\/ if no such supertype exists, done() will return false already.\n+    next_stream_if_done();\n+  }\n+\n+  InstanceKlass* next_klass_with_fields() {\n+    assert(_next_klass != nullptr, \"reached end of types already\");\n+    InstanceKlass* result = _next_klass;\n+    do  {\n+      if (!result->is_interface() && result->super() != nullptr) {\n+        result = result->java_super();\n+      } else if (_interface_index > 0) {\n+        result = _interfaces->at(--_interface_index);\n+      } else {\n+        return nullptr; \/\/ we did not find any more supertypes with fields\n+      }\n+    } while (FieldStreamType(result).done());\n+    return result;\n+  }\n+\n+  \/\/ sets _current_stream to the next if the current is done and any more is available\n+  void next_stream_if_done() {\n+    if (_next_klass != nullptr && _current_stream.done()) {\n+      _current_stream = FieldStreamType(_next_klass);\n+      assert(!_current_stream.done(), \"created empty stream\");\n+      _next_klass = next_klass_with_fields();\n+    }\n+  }\n+\n+ public:\n+  HierarchicalFieldStream(InstanceKlass* klass) :\n+    _interfaces(klass->transitive_interfaces()),\n+    _next_klass(klass),\n+    _current_stream(FieldStreamType(klass)),\n+    _interface_index(_interfaces->length()) {\n+      prepare();\n+  }\n+\n+  void next() {\n+    _current_stream.next();\n+    next_stream_if_done();\n+  }\n+\n+  bool done() const { return _next_klass == nullptr && _current_stream.done(); }\n+\n+  \/\/ bridge functions from FieldStreamBase\n+\n+  AccessFlags access_flags() const {\n+    return _current_stream.access_flags();\n+  }\n+\n+  FieldInfo::FieldFlags field_flags() const {\n+    return _current_stream.field_flags();\n+  }\n+\n+  Symbol* name() const {\n+    return _current_stream.name();\n+  }\n+\n+  Symbol* signature() const {\n+    return _current_stream.signature();\n+  }\n+\n+  Symbol* generic_signature() const {\n+    return _current_stream.generic_signature();\n+  }\n+\n+  int offset() const {\n+    return _current_stream.offset();\n+  }\n+\n+  bool is_contended() const {\n+    return _current_stream.is_contended();\n+  }\n+\n+  int contended_group() const {\n+    return _current_stream.contended_group();\n+  }\n+\n+  FieldInfo to_FieldInfo() {\n+    return _current_stream.to_FieldInfo();\n+  }\n+\n+  fieldDescriptor& field_descriptor() const {\n+    return _current_stream.field_descriptor();\n+  }\n+\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -760,1 +761,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n@@ -4366,1 +4367,1 @@\n-        ((UseSharedSpaces || Arguments::is_dumping_archive()) && length != 0)) {\n+        ((UseSharedSpaces || CDSConfig::is_dumping_archive()) && length != 0)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -88,1 +88,1 @@\n-  if (Arguments::is_dumping_archive() && is_instance_klass()) {\n+  if (CDSConfig::is_dumping_archive() && is_instance_klass()) {\n@@ -524,1 +524,1 @@\n-  if (!Arguments::is_dumping_archive()) {\n+  if (!CDSConfig::is_dumping_archive()) {\n@@ -541,1 +541,1 @@\n-  assert (Arguments::is_dumping_archive(),\n+  assert(CDSConfig::is_dumping_archive(),\n@@ -559,1 +559,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n@@ -649,1 +649,1 @@\n-  assert(DumpSharedSpaces, \"called only during dumptime\");\n+  assert(CDSConfig::is_dumping_heap(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -63,1 +64,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -69,0 +69,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -1212,1 +1213,1 @@\n-  Arguments::assert_is_dumping_archive();\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -167,1 +168,1 @@\n-  assert(DumpSharedSpaces, \"Used by CDS only. Do not abuse!\");\n+  assert(CDSConfig::is_dumping_heap(), \"Used by CDS only. Do not abuse!\");\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1927,0 +1927,1 @@\n+    if (failing()) return;\n@@ -2554,0 +2555,1 @@\n+    if (failing()) return;\n@@ -2790,0 +2792,1 @@\n+    if (failing()) return;\n@@ -2824,1 +2827,1 @@\n-      if (failing())  return;\n+      if (failing()) return;\n@@ -2834,0 +2837,2 @@\n+        if (failing()) return;\n+\n@@ -2955,0 +2960,1 @@\n+    if (failing()) return;\n@@ -4888,0 +4894,1 @@\n+  if (_compile->failing()) return;\n@@ -5634,0 +5641,1 @@\n+  if (failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5742,2 +5742,0 @@\n-  const char *stubName = \"array_partition_stub\";\n-\n@@ -5752,15 +5750,6 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType bt = elem_type->basic_type();\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_array_partition_function();\n-  \/\/ stub not loaded\n-  if (stubAddr == nullptr) {\n-    return false;\n-  }\n-  \/\/ get the address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n-  }\n-  Node* obj_adr = make_unsafe_address(obj, offset);\n+  Node* pivotIndices = nullptr;\n+\n+  \/\/ Set the original stack and the reexecute bit for the interpreter to reexecute\n+  \/\/ the bytecode that invokes DualPivotQuicksort.partition() if deoptimization happens.\n+  { PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n@@ -5768,7 +5757,15 @@\n-  \/\/ create the pivotIndices array of type int and size = 2\n-  Node* size = intcon(2);\n-  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n-  Node* pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n-  guarantee(alloc != nullptr, \"created above\");\n-  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+    BasicType bt = elem_type->basic_type();\n+    address stubAddr = nullptr;\n+    stubAddr = StubRoutines::select_array_partition_function();\n+    \/\/ stub not loaded\n+    if (stubAddr == nullptr) {\n+      return false;\n+    }\n+    \/\/ get the address of the array\n+    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+      return false; \/\/ failed input validation\n+    }\n+    Node* obj_adr = make_unsafe_address(obj, offset);\n@@ -5776,2 +5773,7 @@\n-  \/\/ pass the basic type enum to the stub\n-  Node* elemType = intcon(bt);\n+    \/\/ create the pivotIndices array of type int and size = 2\n+    Node* size = intcon(2);\n+    Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+    pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+    AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+    guarantee(alloc != nullptr, \"created above\");\n+    Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n@@ -5779,5 +5781,11 @@\n-  \/\/ Call the stub\n-  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n-                    stubAddr, stubName, TypePtr::BOTTOM,\n-                    obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n-                    indexPivot1, indexPivot2);\n+    \/\/ pass the basic type enum to the stub\n+    Node* elemType = intcon(bt);\n+\n+    \/\/ Call the stub\n+    const char *stubName = \"array_partition_stub\";\n+    make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                      stubAddr, stubName, TypePtr::BOTTOM,\n+                      obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n+                      indexPivot1, indexPivot2);\n+\n+  } \/\/ original reexecute is set back here\n@@ -5796,3 +5804,0 @@\n-  const char *stubName;\n-  stubName = \"arraysort_stub\";\n-\n@@ -5826,0 +5831,1 @@\n+  const char *stubName = \"arraysort_stub\";\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":40,"deletions":34,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -3869,0 +3869,1 @@\n+            if (C->failing()) return false;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+    if (C->failing()) return;\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1619,1 +1619,1 @@\n-    \/\/ If changed Cast input, notify down for Phi and Sub - both do \"uncast\"\n+    \/\/ If changed Cast input, notify down for Phi, Sub, and Xor - all do \"uncast\"\n@@ -1623,0 +1623,1 @@\n+    \/\/ ConstraintCast+ -> Xor\n@@ -1624,2 +1625,2 @@\n-      auto push_phi_or_sub_uses_to_worklist = [&](Node* n){\n-        if (n->is_Phi() || n->is_Sub()) {\n+      auto push_the_uses_to_worklist = [&](Node* n){\n+        if (n->is_Phi() || n->is_Sub() || n->Opcode() == Op_XorI || n->Opcode() == Op_XorL) {\n@@ -1629,1 +1630,1 @@\n-      ConstraintCastNode::visit_uncasted_uses(use, push_phi_or_sub_uses_to_worklist);\n+      ConstraintCastNode::visit_uncasted_uses(use, push_the_uses_to_worklist);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -109,14 +109,0 @@\n-static void enqueue_use(Node* n, Node* use, Unique_Node_List& work) {\n-  if (use->is_Phi()) {\n-    Node* r = use->in(0);\n-    assert(r->is_Region(), \"Phi should have Region\");\n-    for (uint i = 1; i < use->req(); i++) {\n-      if (use->in(i) == n) {\n-        work.push(r->in(i));\n-      }\n-    }\n-  } else {\n-    work.push(use);\n-  }\n-}\n-\n@@ -129,0 +115,6 @@\n+  ResourceMark rm;\n+  Node_Stack stack(0);\n+  Unique_Node_List to_fix; \/\/ nodes to clone + uses at the end of the chain that need to updated\n+  VectorSet seen;\n+  VectorSet valid_control;\n+\n@@ -135,5 +127,3 @@\n-    ResourceMark rm;\n-    Unique_Node_List work;\n-    \/\/ Go over all the uses of the node that is considered for replacement...\n-    for (DUIterator j = initial->outs(); initial->has_out(j); j++) {\n-      Node* use = initial->out(j);\n+    if (initial->outcnt() == 0) {\n+      continue;\n+    }\n@@ -141,12 +131,19 @@\n-      if (use == improved || use->outcnt() == 0) {\n-        continue;\n-      }\n-      work.clear();\n-      enqueue_use(initial, use, work);\n-      bool replace = true;\n-      \/\/ Check that this use is dominated by ctl. Go ahead with the replacement if it is.\n-      DEBUG_ONLY(uint loop_count = 0);\n-      while (work.size() != 0 && replace) {\n-        Node* n = work.pop();\n-        if (use->outcnt() == 0) {\n-          continue;\n+    \/\/ Find uses of initial that are dominated by ctl so, initial can be replaced by improved.\n+    \/\/ Proving domination here is not straightforward. To do so, we follow uses of initial, and uses of uses until we\n+    \/\/ encounter a node which is a control node or is pinned at some control. Then, we try to prove this control is\n+    \/\/ dominated by ctl. If that's the case, it's legal to replace initial by improved but for this chain of uses only.\n+    \/\/ It may not be the case for some other chain of uses, so we clone that chain and perform the replacement only for\n+    \/\/ these uses.\n+    assert(stack.is_empty(), \"\");\n+    stack.push(initial, 1);\n+    Node* use = initial->raw_out(0);\n+    stack.push(use, 0);\n+    while (!stack.is_empty()) {\n+      assert(stack.size() > 1, \"at least initial + one use\");\n+      Node* n = stack.node();\n+\n+      uint current_size = stack.size();\n+\n+      if (seen.test_set(n->_idx)) {\n+        if (to_fix.member(n)) {\n+          collect_nodes_to_clone(stack, to_fix);\n@@ -154,4 +151,14 @@\n-        if (n->is_CFG() || (n->in(0) != nullptr && !n->in(0)->is_top())) {\n-          \/\/ Skip projections, since some of the multi nodes aren't CFG (e.g., LoadStore and SCMemProj).\n-          if (n->is_Proj()) {\n-            n = n->in(0);\n+      } else if (n->outcnt() != 0 && n != improved) {\n+        if (n->is_Phi()) {\n+          Node* region = n->in(0);\n+          Node* prev = stack.node_at(stack.size() - 2);\n+          for (uint j = 1; j < region->req(); ++j) {\n+            if (n->in(j) == prev) {\n+              Node* in = region->in(j);\n+              if (in != nullptr && !in->is_top()) {\n+                if (is_dominator(ctl, in)) {\n+                  valid_control.set(in->_idx);\n+                  collect_nodes_to_clone(stack, to_fix);\n+                }\n+              }\n+            }\n@@ -159,2 +166,3 @@\n-          if (!n->is_CFG()) {\n-            n = n->in(0);\n+        } else if (n->is_CFG()) {\n+          if (is_dominator(ctl, n)) {\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -162,10 +170,4 @@\n-          assert(n->is_CFG(), \"should be CFG now\");\n-          int depth = 0;\n-          while(n != ctl) {\n-            n = IfNode::up_one_dom(n);\n-            depth++;\n-            \/\/ limit search depth\n-            if (depth >= 100 || n == nullptr) {\n-              replace = false;\n-              break;\n-            }\n+        } else if (n->in(0) != nullptr && n->in(0)->is_CFG()) {\n+          Node* c = n->in(0);\n+          if (is_dominator(ctl, c)) {\n+            collect_nodes_to_clone(stack, to_fix);\n@@ -174,2 +176,4 @@\n-          for (DUIterator k = n->outs(); n->has_out(k); k++) {\n-            enqueue_use(n, n->out(k), work);\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n@@ -178,6 +182,13 @@\n-        assert(loop_count++ < K, \"infinite loop in ReplacedNodes::apply\");\n-      if (replace) {\n-        bool is_in_table = C->initial_gvn()->hash_delete(use);\n-        int replaced = use->replace_edge(initial, improved);\n-        if (is_in_table) {\n-          C->initial_gvn()->hash_find_insert(use);\n+      if (stack.size() == current_size) {\n+        for (;;) {\n+          stack.pop();\n+          if (stack.is_empty()) {\n+            break;\n+          }\n+          n = stack.node();\n+          uint idx = stack.index();\n+          if (idx < n->outcnt()) {\n+            stack.set_index(idx + 1);\n+            stack.push(n->raw_out(idx), 0);\n+            break;\n+          }\n@@ -186,1 +197,25 @@\n-        C->record_for_igvn(use);\n+      }\n+    }\n+  }\n+  if (to_fix.size() > 0) {\n+    uint hash_table_size = _replaced_nodes->length();\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain is not cloned\n+        continue;\n+      }\n+      hash_table_size++;\n+    }\n+    \/\/ Map from current node to cloned\/replaced node\n+    ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> clones(hash_table_size, hash_table_size);\n+    \/\/ Record mapping from initial to improved nodes\n+    for (int i = 0; i < _replaced_nodes->length(); i++) {\n+      ReplacedNode replaced = _replaced_nodes->at(i);\n+      Node* initial = replaced.initial();\n+      Node* improved = replaced.improved();\n+      clones.put(initial, improved);\n+      \/\/ If initial needs to be cloned but is also improved then there's no need to clone it.\n+      if (to_fix.member(initial)) {\n+        to_fix.remove(initial);\n+      }\n+    }\n@@ -188,2 +223,5 @@\n-        assert(replaced > 0, \"inconsistent\");\n-        --j;\n+    \/\/ Clone nodes and record mapping from current to cloned nodes\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      if (n->is_CFG() || n->in(0) != nullptr) { \/\/ End of a chain\n+        continue;\n@@ -191,0 +229,45 @@\n+      Node* clone = n->clone();\n+      bool added = clones.put(n, clone);\n+      assert(added, \"clone node must be added to mapping\");\n+      C->initial_gvn()->set_type_bottom(clone);\n+      to_fix.map(i, clone); \/\/ Update list of nodes with cloned node\n+    }\n+\n+    \/\/ Fix edges in cloned nodes and use at the end of the chain\n+    for (uint i = 0; i < to_fix.size(); ++i) {\n+      Node* n = to_fix.at(i);\n+      bool is_in_table = C->initial_gvn()->hash_delete(n);\n+      uint updates = 0;\n+      for (uint j = 0; j < n->req(); ++j) {\n+        Node* in = n->in(j);\n+        if (in == nullptr || (n->is_Phi() && n->in(0)->in(j) == nullptr)) {\n+          continue;\n+        }\n+        if (n->is_Phi() && !valid_control.test(n->in(0)->in(j)->_idx)) {\n+          continue;\n+        }\n+        Node** clone_ptr = clones.get(in);\n+        if (clone_ptr != nullptr) {\n+          Node* clone = *clone_ptr;\n+          n->set_req(j, clone);\n+          updates++;\n+        }\n+      }\n+      assert(updates > 0, \"\");\n+      C->record_for_igvn(n);\n+      if (is_in_table) {\n+        C->initial_gvn()->hash_find_insert(n);\n+      }\n+    }\n+  }\n+}\n+\n+bool ReplacedNodes::is_dominator(const Node* ctl, Node* n) const {\n+  assert(n->is_CFG(), \"should be CFG now\");\n+  int depth = 0;\n+  while (n != ctl) {\n+    n = IfNode::up_one_dom(n);\n+    depth++;\n+    \/\/ limit search depth\n+    if (depth >= 100 || n == nullptr) {\n+      return false;\n@@ -193,0 +276,1 @@\n+  return true;\n@@ -229,0 +313,7 @@\n+\n+void ReplacedNodes::collect_nodes_to_clone(const Node_Stack& stack, Unique_Node_List& to_fix) {\n+  for (uint i = stack.size() - 1; i >= 1; i--) {\n+    Node* n = stack.node_at(i);\n+    to_fix.push(n);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":149,"deletions":58,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -3716,1 +3717,1 @@\n-  if (!Arguments::is_dumping_archive()) {\n+  if (!CDSConfig::is_dumping_archive()) {\n@@ -3804,1 +3805,1 @@\n-  return Arguments::is_dumping_archive();\n+  return CDSConfig::is_dumping_archive();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-    return jvmciEnv.runtime()->is_gc_supported(&jvmciEnv, (CollectedHeap::Name)name);\n+    return jvmciEnv.init_error() == JNI_OK && jvmciEnv.runtime()->is_gc_supported(&jvmciEnv, (CollectedHeap::Name)name);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -134,0 +135,3 @@\n+\/\/ True if -Xint\/-Xmixed\/-Xcomp were specified\n+static bool mode_flag_cmd_line = false;\n+\n@@ -1336,1 +1340,1 @@\n-  assert(is_dumping_archive(),\n+  assert(CDSConfig::is_dumping_archive(),\n@@ -2675,0 +2679,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2678,0 +2683,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2682,0 +2688,1 @@\n+          mode_flag_cmd_line = true;\n@@ -3128,8 +3135,12 @@\n-    \/\/ Compiler threads may concurrently update the class metadata (such as method entries), so it's\n-    \/\/ unsafe with -Xshare:dump (which modifies the class metadata in place). Let's disable\n-    \/\/ compiler just to be safe.\n-    \/\/\n-    \/\/ Note: this is not a concern for dynamically dumping shared spaces, which makes a copy of the\n-    \/\/ class metadata instead of modifying them in place. The copy is inaccessible to the compiler.\n-    \/\/ TODO: revisit the following for the static archive case.\n-    set_mode_flags(_int);\n+    if (!mode_flag_cmd_line) {\n+      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n+      \/\/\n+      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n+      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n+      set_mode_flags(_int);\n+    } else if (_mode == _comp) {\n+      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n+      \/\/ Java code, so there's not much benefit in running -Xcomp.\n+      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n+      set_mode_flags(_mixed);\n+    }\n@@ -3549,1 +3560,1 @@\n-    if (is_dumping_archive() && archives > 1) {\n+    if (CDSConfig::is_dumping_archive() && archives > 1) {\n@@ -4123,1 +4134,1 @@\n-  if (!EnableValhalla || (is_interpreter_only() && !is_dumping_archive() && !UseSharedSpaces)) {\n+  if (!EnableValhalla || (is_interpreter_only() && !CDSConfig::is_dumping_archive() && !UseSharedSpaces)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -531,6 +531,0 @@\n-  static bool is_dumping_archive() { return DumpSharedSpaces || DynamicDumpSharedSpaces; }\n-\n-  static void assert_is_dumping_archive() {\n-    assert(Arguments::is_dumping_archive(), \"dump time only\");\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -526,1 +526,1 @@\n-    return ((UpcallStub*)blob)->exception_handler();\n+    return StubRoutines::upcall_stub_exception_handler();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,0 +194,2 @@\n+address StubRoutines::_upcall_stub_exception_handler = nullptr;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,0 +275,2 @@\n+  static address _upcall_stub_exception_handler;\n+\n@@ -471,0 +473,5 @@\n+  static address upcall_stub_exception_handler() {\n+    assert(_upcall_stub_exception_handler != nullptr, \"not implemented\");\n+    return _upcall_stub_exception_handler;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -56,1 +57,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -898,2 +898,2 @@\n-  static bool is_inlined_field(const FieldStream& fld) {\n-    return fld.field_descriptor().is_flat();\n+  static bool is_inlined_field(const fieldDescriptor& fld) {\n+    return fld.is_flat();\n@@ -901,1 +901,1 @@\n-  static InlineKlass* get_inlined_field_klass(const FieldStream &fld) {\n+  static InlineKlass* get_inlined_field_klass(const fieldDescriptor& fld) {\n@@ -903,1 +903,1 @@\n-    InstanceKlass* holder_klass = fld.field_descriptor().field_holder();\n+    InstanceKlass* holder_klass = fld.field_holder();\n@@ -1059,1 +1059,1 @@\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -1061,2 +1061,2 @@\n-      if (is_inlined_field(fld)) {\n-        size += instance_size(get_inlined_field_klass(fld));\n+      if (is_inlined_field(fld.field_descriptor())) {\n+        size += instance_size(get_inlined_field_klass(fld.field_descriptor()));\n@@ -1075,1 +1075,1 @@\n-  for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {\n+  for (JavaFieldStream fldc(ik); !fldc.done(); fldc.next()) {\n@@ -1077,1 +1077,1 @@\n-      assert(!is_inlined_field(fldc), \"static fields cannot be inlined\");\n+      assert(!is_inlined_field(fldc.field_descriptor()), \"static fields cannot be inlined\");\n@@ -1111,1 +1111,1 @@\n-  for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next()) {\n@@ -1113,1 +1113,1 @@\n-      assert(!is_inlined_field(fld), \"static fields cannot be inlined\");\n+      assert(!is_inlined_field(fld.field_descriptor()), \"static fields cannot be inlined\");\n@@ -1146,2 +1146,2 @@\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass *klass) {\n-  for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, InstanceKlass *ik) {\n+  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -1149,2 +1149,2 @@\n-      if (is_inlined_field(fld)) {\n-        InlineKlass* field_klass = get_inlined_field_klass(fld);\n+      if (is_inlined_field(fld.field_descriptor())) {\n+        InlineKlass* field_klass = get_inlined_field_klass(fld.field_descriptor());\n@@ -1171,1 +1171,1 @@\n-  for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {\n+  for (JavaFieldStream fldc(ik); !fldc.done(); fldc.next()) {\n@@ -1173,1 +1173,1 @@\n-      if (is_inlined_field(fldc)) {\n+      if (is_inlined_field(fldc.field_descriptor())) {\n@@ -1175,1 +1175,1 @@\n-        field_count += get_instance_fields_count(get_inlined_field_klass(fldc));\n+        field_count += get_instance_fields_count(get_inlined_field_klass(fldc.field_descriptor()));\n@@ -1196,1 +1196,1 @@\n-  for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next()) {\n@@ -1198,1 +1198,1 @@\n-      if (is_inlined_field(fld)) {\n+      if (is_inlined_field(fld.field_descriptor())) {\n@@ -1204,1 +1204,1 @@\n-        dump_instance_field_descriptors(writer, get_inlined_field_klass(fld), this_klass_inlined_fields_id);\n+        dump_instance_field_descriptors(writer, get_inlined_field_klass(fld.field_descriptor()), this_klass_inlined_fields_id);\n@@ -1579,1 +1579,1 @@\n-    for (FieldStream fld(klass, false, false); !fld.eos(); fld.next()) {\n+    for (HierarchicalFieldStream<JavaFieldStream> fld(klass); !fld.done(); fld.next()) {\n@@ -1581,2 +1581,2 @@\n-        if (DumperSupport::is_inlined_field(fld)) {\n-          dump_inlined_field_names(super_names, fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n+          dump_inlined_field_names(super_names, fld.name(), DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n@@ -1637,1 +1637,1 @@\n-    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -1639,2 +1639,2 @@\n-        if (DumperSupport::is_inlined_field(fld)) {\n-          dump_inlined_field_names(fld.name(), DumperSupport::get_inlined_field_klass(fld));\n+        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n+          dump_inlined_field_names(fld.name(), DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n@@ -1675,1 +1675,1 @@\n-    for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -1677,1 +1677,1 @@\n-        if (DumperSupport::is_inlined_field(fld)) {\n+        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n@@ -1690,1 +1690,1 @@\n-      for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+      for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -1692,1 +1692,1 @@\n-          if (DumperSupport::is_inlined_field(fld)) {\n+          if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n@@ -1696,1 +1696,1 @@\n-            u2 field_count = DumperSupport::get_instance_fields_count(DumperSupport::get_inlined_field_klass(fld));\n+            u2 field_count = DumperSupport::get_instance_fields_count(DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n@@ -1701,1 +1701,1 @@\n-            _writer->write_classID(DumperSupport::get_inlined_field_klass(fld));\n+            _writer->write_classID(DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+        jdk.jfr,\n@@ -194,0 +195,1 @@\n+        jdk.jfr,\n@@ -195,0 +197,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -198,0 +202,1 @@\n+        jdk.jfr,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5510,31 +5510,31 @@\n-            if (c.isSealed() &&\n-                    !c.isEnum() &&\n-                    !c.isPermittedExplicit &&\n-                    c.permitted.isEmpty()) {\n-                log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n-            }\n-\n-            if (c.isSealed()) {\n-                Set<Symbol> permittedTypes = new HashSet<>();\n-                boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n-                for (Symbol subTypeSym : c.permitted) {\n-                    boolean isTypeVar = false;\n-                    if (subTypeSym.type.getTag() == TYPEVAR) {\n-                        isTypeVar = true; \/\/error recovery\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n-                    }\n-                    if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n-                    }\n-                    if (permittedTypes.contains(subTypeSym)) {\n-                        DiagnosticPosition pos =\n-                                env.enclClass.permitting.stream()\n-                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n-                                        .limit(2).collect(List.collector()).get(1);\n-                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n-                    } else {\n-                        permittedTypes.add(subTypeSym);\n-                    }\n-                    if (sealedInUnnamed) {\n-                        if (subTypeSym.packge() != c.packge()) {\n+            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n+            \/\/ because the annotations were not available at the time the env was created. Therefore,\n+            \/\/ we look up the environment chain for the first enclosing environment for which the\n+            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n+            \/\/ are any envs created as a result of TypeParameter nodes.\n+            Env<AttrContext> lintEnv = env;\n+            while (lintEnv.info.lint == null)\n+                lintEnv = lintEnv.next;\n+\n+            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n+            env.info.lint = lintEnv.info.lint.augment(c);\n+\n+            Lint prevLint = chk.setLint(env.info.lint);\n+            JavaFileObject prev = log.useSource(c.sourcefile);\n+            ResultInfo prevReturnRes = env.info.returnResult;\n+\n+            try {\n+                if (c.isSealed() &&\n+                        !c.isEnum() &&\n+                        !c.isPermittedExplicit &&\n+                        c.permitted.isEmpty()) {\n+                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n+                }\n+\n+                if (c.isSealed()) {\n+                    Set<Symbol> permittedTypes = new HashSet<>();\n+                    boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n+                    for (Symbol subTypeSym : c.permitted) {\n+                        boolean isTypeVar = false;\n+                        if (subTypeSym.type.getTag() == TYPEVAR) {\n+                            isTypeVar = true; \/\/error recovery\n@@ -5542,2 +5542,1 @@\n-                                    Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n-                            );\n+                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n@@ -5545,18 +5544,19 @@\n-                    } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n-                        );\n-                    }\n-                    if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n-                                Errors.InvalidPermitsClause(\n-                                        subTypeSym == c.type.tsym ?\n-                                                Fragments.MustNotBeSameClass :\n-                                                Fragments.MustNotBeSupertype(subTypeSym.type)\n-                                )\n-                        );\n-                    } else if (!isTypeVar) {\n-                        boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n-                                                    .stream()\n-                                                    .anyMatch(d -> d.tsym == c);\n-                        if (!thisIsASuper) {\n+                        if (subTypeSym.isAnonymous() && !c.isEnum()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                        }\n+                        if (permittedTypes.contains(subTypeSym)) {\n+                            DiagnosticPosition pos =\n+                                    env.enclClass.permitting.stream()\n+                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                            .limit(2).collect(List.collector()).get(1);\n+                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                        } else {\n+                            permittedTypes.add(subTypeSym);\n+                        }\n+                        if (sealedInUnnamed) {\n+                            if (subTypeSym.packge() != c.packge()) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n+                                );\n+                            }\n+                        } else if (subTypeSym.packge().modle != c.packge().modle) {\n@@ -5564,1 +5564,19 @@\n-                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                                    Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n+                            );\n+                        }\n+                        if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                                    Errors.InvalidPermitsClause(\n+                                            subTypeSym == c.type.tsym ?\n+                                                    Fragments.MustNotBeSameClass :\n+                                                    Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                    )\n+                            );\n+                        } else if (!isTypeVar) {\n+                            boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                                                        .stream()\n+                                                        .anyMatch(d -> d.tsym == c);\n+                            if (!thisIsASuper) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                            }\n@@ -5568,6 +5586,5 @@\n-            }\n-            List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n-                                                  .stream()\n-                                                  .filter(s -> s.tsym.isSealed())\n-                                                  .map(s -> (ClassSymbol) s.tsym)\n-                                                  .collect(List.collector());\n+                List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n+                                                      .stream()\n+                                                      .filter(s -> s.tsym.isSealed())\n+                                                      .map(s -> (ClassSymbol) s.tsym)\n+                                                      .collect(List.collector());\n@@ -5576,3 +5593,3 @@\n-            if (sealedSupers.isEmpty()) {\n-                if ((c.flags_field & Flags.NON_SEALED) != 0) {\n-                    boolean hasErrorSuper = false;\n+                if (sealedSupers.isEmpty()) {\n+                    if ((c.flags_field & Flags.NON_SEALED) != 0) {\n+                        boolean hasErrorSuper = false;\n@@ -5580,3 +5597,3 @@\n-                    hasErrorSuper |= types.directSupertypes(c.type)\n-                                          .stream()\n-                                          .anyMatch(s -> s.tsym.kind == Kind.ERR);\n+                        hasErrorSuper |= types.directSupertypes(c.type)\n+                                              .stream()\n+                                              .anyMatch(s -> s.tsym.kind == Kind.ERR);\n@@ -5584,1 +5601,1 @@\n-                    ClassType ct = (ClassType) c.type;\n+                        ClassType ct = (ClassType) c.type;\n@@ -5586,1 +5603,1 @@\n-                    hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n+                        hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n@@ -5588,2 +5605,7 @@\n-                    if (!hasErrorSuper) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        if (!hasErrorSuper) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        }\n+                    }\n+                } else if ((c.flags_field & Flags.COMPOUND) == 0) {\n+                    if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n+                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n@@ -5591,9 +5613,11 @@\n-                }\n-            } else if ((c.flags_field & Flags.COMPOUND) == 0) {\n-                if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n-                }\n-                if (!c.type.isCompound()) {\n-                    for (ClassSymbol supertypeSym : sealedSupers) {\n-                        if (!supertypeSym.permitted.contains(c.type.tsym)) {\n-                            log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                    if (!c.type.isCompound()) {\n+                        for (ClassSymbol supertypeSym : sealedSupers) {\n+                            if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                                log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                            }\n+                        }\n+                        if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n+                                    c.isInterface() ?\n+                                            Errors.NonSealedOrSealedExpected :\n+                                            Errors.NonSealedSealedOrFinalExpected);\n@@ -5602,6 +5626,0 @@\n-                    }\n-                    if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n-                                c.isInterface() ?\n-                                        Errors.NonSealedOrSealedExpected :\n-                                        Errors.NonSealedSealedOrFinalExpected);\n@@ -5610,18 +5628,0 @@\n-            }\n-\n-            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n-            \/\/ because the annotations were not available at the time the env was created. Therefore,\n-            \/\/ we look up the environment chain for the first enclosing environment for which the\n-            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n-            \/\/ are any envs created as a result of TypeParameter nodes.\n-            Env<AttrContext> lintEnv = env;\n-            while (lintEnv.info.lint == null)\n-                lintEnv = lintEnv.next;\n-            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n-            env.info.lint = lintEnv.info.lint.augment(c);\n-\n-            Lint prevLint = chk.setLint(env.info.lint);\n-            JavaFileObject prev = log.useSource(c.sourcefile);\n-            ResultInfo prevReturnRes = env.info.returnResult;\n-\n-            try {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":101,"deletions":101,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -3665,0 +3665,12 @@\n+\n+        @Override\n+        Symbol access(Env<AttrContext> env, DiagnosticPosition pos, Symbol location, Symbol sym) {\n+            if (originalSite.hasTag(TYPEVAR) && sym.kind == MTH) {\n+                sym = (sym.flags() & Flags.PRIVATE) != 0 ?\n+                        new AccessError(env, site, sym) :\n+                        sym;\n+                return accessBase(sym, pos, location, originalSite, name, true);\n+            } else {\n+                return super.access(env, pos, location, sym);\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1341,9 +1341,0 @@\n-    public static JCModuleDecl getModule(JCCompilationUnit t) {\n-        if (t.defs.nonEmpty()) {\n-            JCTree def = t.defs.head;\n-            if (def.hasTag(MODULEDEF))\n-                return (JCModuleDecl) def;\n-        }\n-        return null;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import static jdk.jfr.internal.util.Bytecode.invokespecial;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -31,8 +37,6 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.GeneratorAdapter;\n-import jdk.internal.org.objectweb.asm.commons.Method;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.misc.ValhallaFeatures;\n@@ -42,1 +46,2 @@\n-\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n@@ -46,5 +51,4 @@\n-\n-    private static final Type TYPE_EVENT = Type.getType(Event.class);\n-    private static final Type TYPE_IOBE = Type.getType(IndexOutOfBoundsException.class);\n-    private static final Method DEFAULT_CONSTRUCTOR = Method.getMethod(\"void <init> ()\");\n-    private static final Method SET_METHOD = Method.getMethod(\"void set (int, java.lang.Object)\");\n+    private static final ClassDesc TYPE_EVENT = Bytecode.classDesc(Event.class);\n+    private static final ClassDesc TYPE_IOBE = Bytecode.classDesc(IndexOutOfBoundsException.class);\n+    private static final MethodDesc DEFAULT_CONSTRUCTOR = MethodDesc.of(\"<init>\", \"()V\");\n+    private static final MethodDesc SET_METHOD = MethodDesc.of(\"set\", \"(ILjava\/lang\/Object;)V\");\n@@ -52,1 +56,1 @@\n-    private final ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n+\n@@ -54,1 +58,1 @@\n-    private final Type type;\n+    private final ClassDesc type;\n@@ -60,1 +64,1 @@\n-        this.type = Type.getType(\"L\" + fullClassName.replace(\".\", \"\/\") + \";\");\n+        this.type = ClassDesc.of(fullClassName);\n@@ -66,7 +70,2 @@\n-        buildClassInfo();\n-        buildConstructor();\n-        buildFields();\n-        buildSetMethod();\n-        endClass();\n-        byte[] bytes = classWriter.toByteArray();\n-        ASMToolkit.logASM(fullClassName, bytes);\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(fullClassName), cb -> build(cb));\n+        Bytecode.log(fullClassName, bytes);\n@@ -76,2 +75,5 @@\n-    private void endClass() {\n-        classWriter.visitEnd();\n+    void build(ClassBuilder builder) {\n+        buildClassInfo(builder);\n+        buildConstructor(builder);\n+        buildFields(builder);\n+        buildSetMethod(builder);\n@@ -80,19 +82,20 @@\n-    private void buildSetMethod() {\n-        GeneratorAdapter ga = new GeneratorAdapter(Opcodes.ACC_PUBLIC, SET_METHOD, null, null, classWriter);\n-        int index = 0;\n-        for (ValueDescriptor v : fields) {\n-            ga.loadArg(0);\n-            ga.visitLdcInsn(index);\n-            Label notEqual = new Label();\n-            ga.ifICmp(GeneratorAdapter.NE, notEqual);\n-            ga.loadThis();\n-            ga.loadArg(1);\n-            Type fieldType = ASMToolkit.toType(v);\n-            ga.unbox(ASMToolkit.toType(v));\n-            ga.putField(type, v.getName(), fieldType);\n-            ga.visitInsn(Opcodes.RETURN);\n-            ga.visitLabel(notEqual);\n-            index++;\n-        }\n-        ga.throwException(TYPE_IOBE, \"Index must between 0 and \" + fields.size());\n-        ga.endMethod();\n+    private void buildSetMethod(ClassBuilder builder) {\n+        \/\/ void Event::set(int index, Object value);\n+        builder.withMethod(SET_METHOD.name(), SET_METHOD.descriptor(), Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+            int index = 0;\n+            for (ValueDescriptor v : fields) {\n+                codeBuilder.iload(1);\n+                codeBuilder.ldc(index);\n+                Label notEqual = codeBuilder.newLabel();\n+                codeBuilder.if_icmpne(notEqual);\n+                codeBuilder.aload(0); \/\/ this\n+                codeBuilder.aload(2); \/\/ value\n+                ClassDesc cd = Bytecode.classDesc(v);\n+                Bytecode.unbox(codeBuilder, cd);\n+                codeBuilder.putfield(type, v.getName(), cd);\n+                codeBuilder.return_();\n+                codeBuilder.labelBinding(notEqual);\n+                index++;\n+            }\n+            Bytecode.throwException(codeBuilder, TYPE_IOBE, \"Index must between 0 and \" + fields.size());\n+        }));\n@@ -101,6 +104,6 @@\n-    private void buildConstructor() {\n-        MethodVisitor mv = classWriter.visitMethod(Opcodes.ACC_PUBLIC, DEFAULT_CONSTRUCTOR.getName(), DEFAULT_CONSTRUCTOR.getDescriptor(), null, null);\n-        mv.visitIntInsn(Opcodes.ALOAD, 0);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, TYPE_EVENT.getInternalName(), DEFAULT_CONSTRUCTOR.getName(), DEFAULT_CONSTRUCTOR.getDescriptor(), false);\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n+    private void buildConstructor(ClassBuilder builder) {\n+        builder.withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+            codeBuilder.aload(0);\n+            invokespecial(codeBuilder, TYPE_EVENT, DEFAULT_CONSTRUCTOR);\n+            codeBuilder.return_();\n+        }));\n@@ -109,8 +112,6 @@\n-    private void buildClassInfo() {\n-        String internalSuperName = ASMToolkit.getInternalName(Event.class.getName());\n-        String internalClassName = type.getInternalName();\n-        classWriter.visit(52, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, internalClassName, null, internalSuperName, null);\n-\n-        for (AnnotationElement a : annotationElements) {\n-            String descriptor = ASMToolkit.getDescriptor(a.getTypeName());\n-            AnnotationVisitor av = classWriter.visitAnnotation(descriptor, true);\n+    private void buildClassInfo(ClassBuilder builder) {\n+        builder.withSuperclass(Bytecode.classDesc(Event.class));\n+        builder.withFlags(AccessFlag.FINAL, AccessFlag.PUBLIC, ValhallaFeatures.isEnabled() ? AccessFlag.IDENTITY : AccessFlag.SUPER);\n+        List<jdk.internal.classfile.Annotation> annotations = new ArrayList<>();\n+        for (jdk.jfr.AnnotationElement a : annotationElements) {\n+            List<jdk.internal.classfile.AnnotationElement> list = new ArrayList<>();\n@@ -118,12 +119,6 @@\n-                Object value = a.getValue(v.getName());\n-                String name = v.getName();\n-                if (v.isArray()) {\n-                    AnnotationVisitor arrayVisitor = av.visitArray(name);\n-                    Object[] array = (Object[]) value;\n-                    for (int i = 0; i < array.length; i++) {\n-                        arrayVisitor.visit(null, array[i]);\n-                    }\n-                    arrayVisitor.visitEnd();\n-                } else {\n-                    av.visit(name, value);\n-                }\n+                \/\/ ValueDescriptor can only hold primitive\n+                \/\/ No need to care about classes\/enums\n+                var value = a.getValue(v.getName());\n+                var av = AnnotationValue.of(value);\n+                var ae = jdk.internal.classfile.AnnotationElement.of(v.getName(), av);\n+                list.add(ae);\n@@ -131,1 +126,2 @@\n-            av.visitEnd();\n+            ClassDesc cd = ClassDesc.of(a.getTypeName());\n+            annotations.add(jdk.internal.classfile.Annotation.of(cd, list));\n@@ -133,0 +129,1 @@\n+        builder.with(RuntimeVisibleAnnotationsAttribute.of(annotations));\n@@ -135,1 +132,1 @@\n-    private void buildFields() {\n+    private void buildFields(ClassBuilder builder) {\n@@ -137,2 +134,1 @@\n-            String internal = ASMToolkit.getDescriptor(v.getTypeName());\n-            classWriter.visitField(Opcodes.ACC_PRIVATE, v.getName(), internal, null, null);\n+            builder.withField(v.getName(), Bytecode.classDesc(v), Classfile.ACC_PRIVATE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":72,"deletions":76,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+compiler\/codecache\/CheckLargePages.java 8317831 linux-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-java\/awt\/PopupMenu\/PopupMenuLocation.java 8238720,8315878 windows-all,macosx-aarch64\n+java\/awt\/PopupMenu\/PopupMenuLocation.java 8259913,8315878 windows-all,macosx-aarch64\n@@ -731,2 +731,0 @@\n-java\/util\/Locale\/LocaleProvidersRun.java                        8268379 macosx-x64\n-sun\/util\/locale\/provider\/CalendarDataRegression.java            8268379 macosx-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-            redirectOutputToLogFile(\"checkDockerSupport(): which <container-engine>\",\n+            redirectOutputToLogFile(\"checkDockerSupport(): which \" + Container.ENGINE_COMMAND,\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}