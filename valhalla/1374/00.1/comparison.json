{"files":[{"patch":"@@ -83,0 +83,4 @@\n+GENERATED_VALUE_CLASS_SUBDIRS += \\\n+    $(SUPPORT_OUTPUTDIR)\/gensrc-valueclasses \\\n+    #\n+\n@@ -149,0 +153,6 @@\n+# Find value class source dirs for a particular module  (only generated)\n+# $1 - Module to find source dirs for\n+FindModuleValueClassSrcDirs = \\\n+    $(strip $(wildcard \\\n+        $(addsuffix \/$(strip $1), $(GENERATED_VALUE_CLASS_SUBDIRS))))\n+\n@@ -167,0 +177,6 @@\n+# Construct the complete module source path for value classes\n+GetModuleValueClassSrcPath = \\\n+    $(call PathList, \\\n+        $(addsuffix \/*, $(GENERATED_VALUE_CLASS_SUBDIRS) $(GENERATED_SRC_DIRS) $(IMPORT_MODULES_SRC)) \\\n+        $(foreach sub, $(SRC_SUBDIRS), $(addsuffix \/*\/$(sub), $(TOP_SRC_DIRS))))\n+\n","filename":"make\/common\/Modules.gmk","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -331,4 +331,11 @@\n-    __ ldr(j_rarg2, result);\n-    Label is_long, is_float, is_double, exit;\n-    __ ldr(j_rarg1, result_type);\n-    __ cmp(j_rarg1, (u1)T_OBJECT);\n+    \/\/ All of j_rargN may be used to return inline type fields so be careful\n+    \/\/ not to clobber those.\n+    \/\/ SharedRuntime::generate_buffered_inline_type_adapter() knows the register\n+    \/\/ assignment of Rresult below.\n+    Register Rresult = r14, Rresult_type = r15;\n+    __ ldr(Rresult, result);\n+    Label is_long, is_float, is_double, check_prim, exit;\n+    __ ldr(Rresult_type, result_type);\n+    __ cmp(Rresult_type, (u1)T_OBJECT);\n+    __ br(Assembler::EQ, check_prim);\n+    __ cmp(Rresult_type, (u1)T_LONG);\n@@ -336,3 +343,1 @@\n-    __ cmp(j_rarg1, (u1)T_LONG);\n-    __ br(Assembler::EQ, is_long);\n-    __ cmp(j_rarg1, (u1)T_FLOAT);\n+    __ cmp(Rresult_type, (u1)T_FLOAT);\n@@ -340,1 +345,1 @@\n-    __ cmp(j_rarg1, (u1)T_DOUBLE);\n+    __ cmp(Rresult_type, (u1)T_DOUBLE);\n@@ -344,1 +349,1 @@\n-    __ strw(r0, Address(j_rarg2));\n+    __ strw(r0, Address(Rresult));\n@@ -396,0 +401,11 @@\n+    __ BIND(check_prim);\n+    if (InlineTypeReturnedAsFields) {\n+      \/\/ Check for scalarized return value\n+      __ tbz(r0, 0, is_long);\n+      \/\/ Load pack handler address\n+      __ andr(rscratch1, r0, -2);\n+      __ ldr(rscratch1, Address(rscratch1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      __ ldr(rscratch1, Address(rscratch1, InlineKlass::pack_handler_jobject_offset()));\n+      __ blr(rscratch1);\n+      __ b(exit);\n+    }\n@@ -398,1 +414,1 @@\n-    __ str(r0, Address(j_rarg2, 0));\n+    __ str(r0, Address(Rresult, 0));\n@@ -402,1 +418,1 @@\n-    __ strs(j_farg0, Address(j_rarg2, 0));\n+    __ strs(j_farg0, Address(Rresult, 0));\n@@ -406,1 +422,1 @@\n-    __ strd(j_farg0, Address(j_rarg2, 0));\n+    __ strd(j_farg0, Address(Rresult, 0));\n@@ -2227,0 +2243,6 @@\n+    \/\/ Check for flat inline type array -> return -1\n+    __ test_flat_array_oop(src, rscratch2, L_failed);\n+\n+    \/\/ Check for null-free (non-flat) inline type array -> handle as object array\n+    __ test_null_free_array_oop(src, rscratch2, L_objArray);\n+\n@@ -8778,0 +8800,128 @@\n+  \/\/ Call here from the interpreter or compiled code to either load\n+  \/\/ multiple returned values from the inline type instance being\n+  \/\/ returned to registers or to store returned values to a newly\n+  \/\/ allocated inline type instance.\n+  address generate_return_value_stub(address destination, const char* name, bool has_res) {\n+    \/\/ We need to save all registers the calling convention may use so\n+    \/\/ the runtime calls read or update those registers. This needs to\n+    \/\/ be in sync with SharedRuntime::java_return_convention().\n+    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+    enum layout {\n+      j_rarg7_off = 0, j_rarg7_2,    \/\/ j_rarg7 is r0\n+      j_rarg6_off, j_rarg6_2,\n+      j_rarg5_off, j_rarg5_2,\n+      j_rarg4_off, j_rarg4_2,\n+      j_rarg3_off, j_rarg3_2,\n+      j_rarg2_off, j_rarg2_2,\n+      j_rarg1_off, j_rarg1_2,\n+      j_rarg0_off, j_rarg0_2,\n+\n+      j_farg7_off, j_farg7_2,\n+      j_farg6_off, j_farg6_2,\n+      j_farg5_off, j_farg5_2,\n+      j_farg4_off, j_farg4_2,\n+      j_farg3_off, j_farg3_2,\n+      j_farg2_off, j_farg2_2,\n+      j_farg1_off, j_farg1_2,\n+      j_farg0_off, j_farg0_2,\n+\n+      rfp_off, rfp_off2,\n+      return_off, return_off2,\n+\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    CodeBuffer code(name, 512, 64);\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+\n+    int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+    assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+    int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+    int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg7_off), j_rarg7->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg6_off), j_rarg6->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+    map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+    address start = __ pc();\n+\n+    __ enter(); \/\/ Save FP and LR before call\n+\n+    __ stpd(j_farg1, j_farg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg3, j_farg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg5, j_farg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg7, j_farg6, Address(__ pre(sp, -2 * wordSize)));\n+\n+    __ stp(j_rarg1, j_rarg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg3, j_rarg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg5, j_rarg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg7, j_rarg6, Address(__ pre(sp, -2 * wordSize)));\n+\n+    int frame_complete = __ offset();\n+\n+    \/\/ Set up last_Java_sp and last_Java_fp\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);\n+\n+    \/\/ Call runtime\n+    __ mov(c_rarg1, r0);\n+    __ mov(c_rarg0, rthread);\n+\n+    __ mov(rscratch1, destination);\n+    __ blr(rscratch1);\n+\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    __ reset_last_Java_frame(false);\n+\n+    __ ldp(j_rarg7, j_rarg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg5, j_rarg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg3, j_rarg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg1, j_rarg0, Address(__ post(sp, 2 * wordSize)));\n+\n+    __ ldpd(j_farg7, j_farg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg5, j_farg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg3, j_farg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg1, j_farg0, Address(__ post(sp, 2 * wordSize)));\n+\n+    __ leave();\n+\n+    \/\/ check for pending exceptions\n+    Label pending;\n+    __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    __ cbnz(rscratch1, pending);\n+\n+    if (has_res) {\n+      __ get_vm_result(r0, rthread);\n+    }\n+\n+    __ ret(lr);\n+\n+    __ bind(pending);\n+    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+    \/\/ -------------\n+    \/\/ make sure all code is generated\n+    masm->flush();\n+\n+    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, frame_size_in_words, oop_maps, false);\n+    return stub->entry_point();\n+  }\n+\n@@ -8824,0 +8974,8 @@\n+\n+    if (InlineTypeReturnedAsFields) {\n+      StubRoutines::_load_inline_type_fields_in_regs =\n+         generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs), \"load_inline_type_fields_in_regs\", false);\n+      StubRoutines::_store_inline_type_fields_to_buf =\n+         generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf), \"store_inline_type_fields_to_buf\", true);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":170,"deletions":12,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -3197,0 +3197,3 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1835,1 +1835,1 @@\n-        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n+        assert(SingleTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),\n@@ -1876,1 +1876,1 @@\n-    profile_obj_type(ret, R28_mdx, -in_bytes(ReturnTypeEntry::size()), tmp1, tmp2);\n+    profile_obj_type(ret, R28_mdx, -in_bytes(SingleTypeEntry::size()), tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -55,0 +57,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n@@ -58,0 +61,4 @@\n+#include \"vmreg_x86.inline.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/output.hpp\"\n+#endif\n@@ -1731,0 +1738,4 @@\n+void MacroAssembler::super_call_VM_leaf(address entry_point) {\n+  MacroAssembler::call_VM_leaf_base(entry_point, 1);\n+}\n+\n@@ -2915,0 +2926,125 @@\n+void MacroAssembler::test_markword_is_inline_type(Register markword, Label& is_inline_type) {\n+  andptr(markword, markWord::inline_type_mask_in_place);\n+  cmpptr(markword, markWord::inline_type_pattern);\n+  jcc(Assembler::equal, is_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type) {\n+  load_unsigned_short(temp_reg, Address(klass, Klass::access_flags_offset()));\n+  testl(temp_reg, JVM_ACC_IDENTITY);\n+  jcc(Assembler::zero, is_inline_type);\n+}\n+\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n+  testptr(object, object);\n+  jcc(Assembler::zero, not_inline_type);\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  movptr(tmp, Address(object, oopDesc::mark_offset_in_bytes()));\n+  andptr(tmp, is_inline_type_mask);\n+  cmpptr(tmp, is_inline_type_mask);\n+  jcc(Assembler::notEqual, not_inline_type);\n+}\n+\n+void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(klass, temp_reg, done_check);\n+    stop(\"test_klass_is_empty_inline_type with non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n+  testl(temp_reg, InstanceKlassFlags::is_empty_inline_type_value());\n+  jcc(Assembler::notZero, is_empty_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n+  movl(temp_reg, flags);\n+  testl(temp_reg, 1 << ResolvedFieldEntry::is_null_free_inline_type_shift);\n+  jcc(Assembler::notEqual, is_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n+  movl(temp_reg, flags);\n+  testl(temp_reg, 1 << ResolvedFieldEntry::is_null_free_inline_type_shift);\n+  jcc(Assembler::equal, not_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_flat(Register flags, Register temp_reg, Label& is_flat) {\n+  movl(temp_reg, flags);\n+  testl(temp_reg, 1 << ResolvedFieldEntry::is_flat_shift);\n+  jcc(Assembler::notEqual, is_flat);\n+}\n+\n+void MacroAssembler::test_field_has_null_marker(Register flags, Register temp_reg, Label& has_null_marker) {\n+  movl(temp_reg, flags);\n+  testl(temp_reg, 1 << ResolvedFieldEntry::has_null_marker_shift);\n+  jcc(Assembler::notEqual, has_null_marker);\n+}\n+\n+void MacroAssembler::test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label) {\n+  Label test_mark_word;\n+  \/\/ load mark word\n+  movptr(temp_reg, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  \/\/ check displaced\n+  testl(temp_reg, markWord::unlocked_value);\n+  jccb(Assembler::notZero, test_mark_word);\n+  \/\/ slow path use klass prototype\n+  push(rscratch1);\n+  load_prototype_header(temp_reg, oop, rscratch1);\n+  pop(rscratch1);\n+\n+  bind(test_mark_word);\n+  testl(temp_reg, test_bit);\n+  jcc((jmp_set) ? Assembler::notZero : Assembler::zero, jmp_label);\n+}\n+\n+void MacroAssembler::test_flat_array_oop(Register oop, Register temp_reg,\n+                                         Label& is_flat_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flat_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_flat_array_layout(temp_reg, is_flat_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_non_flat_array_oop(Register oop, Register temp_reg,\n+                                             Label& is_non_flat_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flat_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n+  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n+  test_non_flat_array_layout(temp_reg, is_non_flat_array);\n+#endif\n+}\n+\n+void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&is_null_free_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n+#else\n+  Unimplemented();\n+#endif\n+}\n+\n+void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array) {\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n+#else\n+  Unimplemented();\n+#endif\n+}\n+\n+void MacroAssembler::test_flat_array_layout(Register lh, Label& is_flat_array) {\n+  testl(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  jcc(Assembler::notZero, is_flat_array);\n+}\n+\n+void MacroAssembler::test_non_flat_array_layout(Register lh, Label& is_non_flat_array) {\n+  testl(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  jcc(Assembler::zero, is_non_flat_array);\n+}\n+\n@@ -4102,0 +4238,128 @@\n+\/\/ Object \/ value buffer allocation...\n+\/\/\n+\/\/ Kills klass and rsi on LP64\n+void MacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                       Register t1, Register t2,\n+                                       bool clear_fields, Label& alloc_failed)\n+{\n+  Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;\n+  Register layout_size = t1;\n+  assert(new_obj == rax, \"needs to be rax\");\n+  assert_different_registers(klass, new_obj, t1, t2);\n+\n+  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n+  movl(layout_size, Address(klass, Klass::layout_helper_offset()));\n+  \/\/ test to see if it is malformed in some way\n+  testl(layout_size, Klass::_lh_instance_slow_path_bit);\n+  jcc(Assembler::notZero, slow_case_no_pop);\n+\n+  \/\/ Allocate the instance:\n+  \/\/  If TLAB is enabled:\n+  \/\/    Try to allocate in the TLAB.\n+  \/\/    If fails, go to the slow path.\n+  \/\/  Else If inline contiguous allocations are enabled:\n+  \/\/    Try to allocate in eden.\n+  \/\/    If fails due to heap end, go to slow path.\n+  \/\/\n+  \/\/  If TLAB is enabled OR inline contiguous is enabled:\n+  \/\/    Initialize the allocation.\n+  \/\/    Exit.\n+  \/\/\n+  \/\/  Go to slow path.\n+\n+  push(klass);\n+  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(klass);\n+#ifndef _LP64\n+  if (UseTLAB) {\n+    get_thread(thread);\n+  }\n+#endif \/\/ _LP64\n+\n+  if (UseTLAB) {\n+    tlab_allocate(thread, new_obj, layout_size, 0, klass, t2, slow_case);\n+    if (ZeroTLAB || (!clear_fields)) {\n+      \/\/ the fields have been already cleared\n+      jmp(initialize_header);\n+    } else {\n+      \/\/ initialize both the header and fields\n+      jmp(initialize_object);\n+    }\n+  } else {\n+    jmp(slow_case);\n+  }\n+\n+  \/\/ If UseTLAB is true, the object is created above and there is an initialize need.\n+  \/\/ Otherwise, skip and go to the slow path.\n+  if (UseTLAB) {\n+    if (clear_fields) {\n+      \/\/ The object is initialized before the header.  If the object size is\n+      \/\/ zero, go directly to the header initialization.\n+      bind(initialize_object);\n+      if (UseCompactObjectHeaders) {\n+        assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n+        decrement(layout_size, oopDesc::base_offset_in_bytes());\n+      } else {\n+        decrement(layout_size, sizeof(oopDesc));\n+      }\n+      jcc(Assembler::zero, initialize_header);\n+\n+      \/\/ Initialize topmost object field, divide size by 8, check if odd and\n+      \/\/ test if zero.\n+      Register zero = klass;\n+      xorl(zero, zero);    \/\/ use zero reg to clear memory (shorter code)\n+      shrl(layout_size, LogBytesPerLong); \/\/ divide by 2*oopSize and set carry flag if odd\n+\n+  #ifdef ASSERT\n+      \/\/ make sure instance_size was multiple of 8\n+      Label L;\n+      \/\/ Ignore partial flag stall after shrl() since it is debug VM\n+      jcc(Assembler::carryClear, L);\n+      stop(\"object size is not multiple of 2 - adjust this code\");\n+      bind(L);\n+      \/\/ must be > 0, no extra check needed here\n+  #endif\n+\n+      \/\/ initialize remaining object fields: instance_size was a multiple of 8\n+      {\n+        Label loop;\n+        bind(loop);\n+        int header_size_bytes = oopDesc::header_size() * HeapWordSize;\n+        assert(is_aligned(header_size_bytes, BytesPerLong), \"oop header size must be 8-byte-aligned\");\n+        movptr(Address(new_obj, layout_size, Address::times_8, header_size_bytes - 1*oopSize), zero);\n+        NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, header_size_bytes - 2*oopSize), zero));\n+        decrement(layout_size);\n+        jcc(Assembler::notZero, loop);\n+      }\n+    } \/\/ clear_fields\n+\n+    \/\/ initialize object header only.\n+    bind(initialize_header);\n+    if (UseCompactObjectHeaders || EnableValhalla) {\n+      pop(klass);\n+      Register mark_word = t2;\n+      movptr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+      movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);\n+    } else {\n+     movptr(Address(new_obj, oopDesc::mark_offset_in_bytes()),\n+            (intptr_t)markWord::prototype().value()); \/\/ header\n+     pop(klass);   \/\/ get saved klass back in the register.\n+    }\n+    if (!UseCompactObjectHeaders) {\n+#ifdef _LP64\n+      xorl(rsi, rsi);                 \/\/ use zero reg to clear memory (shorter code)\n+      store_klass_gap(new_obj, rsi);  \/\/ zero klass gap for compressed oops\n+#endif\n+      movptr(t2, klass);         \/\/ preserve klass\n+      store_klass(new_obj, t2, rscratch1);  \/\/ src klass reg is potentially compressed\n+    }\n+    jmp(done);\n+  }\n+\n+  bind(slow_case);\n+  pop(klass);\n+  bind(slow_case_no_pop);\n+  jmp(alloc_failed);\n+\n+  bind(done);\n+}\n+\n@@ -4360,0 +4624,63 @@\n+void MacroAssembler::get_inline_type_field_klass(Register holder_klass, Register index, Register inline_klass) {\n+  inline_layout_info(holder_klass, index, inline_klass);\n+  movptr(inline_klass, Address(inline_klass, InlineLayoutInfo::klass_offset()));\n+}\n+\n+void MacroAssembler::inline_layout_info(Register holder_klass, Register index, Register layout_info) {\n+  movptr(layout_info, Address(holder_klass, InstanceKlass::inline_layout_info_array_offset()));\n+#ifdef ASSERT\n+  {\n+    Label done;\n+    cmpptr(layout_info, 0);\n+    jcc(Assembler::notEqual, done);\n+    stop(\"inline_layout_info_array is null\");\n+    bind(done);\n+  }\n+#endif\n+\n+  InlineLayoutInfo array[2];\n+  int size = (char*)&array[1] - (char*)&array[0]; \/\/ computing size of array elements\n+  if (is_power_of_2(size)) {\n+    shll(index, log2i_exact(size)); \/\/ Scale index by power of 2\n+  } else {\n+    imull(index, index, size); \/\/ Scale the index to be the entry index * array_element_size\n+  }\n+  lea(layout_info, Address(layout_info, index, Address::times_1, Array<InlineLayoutInfo>::base_offset_in_bytes()));\n+}\n+\n+void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_default_value_oop from non inline type klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  Register offset = temp_reg;\n+  \/\/ Getting the offset of the pre-allocated default value\n+  movptr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));\n+  movl(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())));\n+\n+  \/\/ Getting the mirror\n+  movptr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));\n+  resolve_oop_handle(obj, inline_klass);\n+\n+  \/\/ Getting the pre-allocated default value from the mirror\n+  Address field(obj, offset, Address::times_1);\n+  load_heap_oop(obj, field);\n+}\n+\n+void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {\n+#ifdef ASSERT\n+  {\n+    Label done_check;\n+    test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);\n+    stop(\"get_empty_value from non-empty inline klass\");\n+    bind(done_check);\n+  }\n+#endif\n+  get_default_value_oop(inline_klass, temp_reg, obj);\n+}\n+\n+\n@@ -5429,1 +5756,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -5490,1 +5821,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -5977,0 +6312,13 @@\n+void MacroAssembler::load_metadata(Register dst, Register src) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(dst, src);\n+  } else if (UseCompressedClassPointers) {\n+    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  } else\n+#endif\n+  {\n+    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n@@ -6002,0 +6350,5 @@\n+void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {\n+  load_klass(dst, src, tmp);\n+  movptr(dst, Address(dst, Klass::prototype_header_offset()));\n+}\n+\n@@ -6074,0 +6427,40 @@\n+void MacroAssembler::flat_field_copy(DecoratorSet decorators, Register src, Register dst,\n+                                     Register inline_layout_info) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->flat_field_copy(this, decorators, src, dst, inline_layout_info);\n+}\n+\n+void MacroAssembler::payload_offset(Register inline_klass, Register offset) {\n+  movptr(offset, Address(inline_klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+  movl(offset, Address(offset, InlineKlass::payload_offset_offset()));\n+}\n+\n+void MacroAssembler::payload_addr(Register oop, Register data, Register inline_klass) {\n+  \/\/ ((address) (void*) o) + vk->payload_offset();\n+  Register offset = (data == oop) ? rscratch1 : data;\n+  payload_offset(inline_klass, offset);\n+  if (data == oop) {\n+    addptr(data, offset);\n+  } else {\n+    lea(data, Address(oop, offset));\n+  }\n+}\n+\n+void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,\n+                                                Register index, Register data) {\n+  assert(index != rcx, \"index needs to shift by rcx\");\n+  assert_different_registers(array, array_klass, index);\n+  assert_different_registers(rcx, array, index);\n+\n+  \/\/ array->base() + (index << Klass::layout_helper_log2_element_size(lh));\n+  movl(rcx, Address(array_klass, Klass::layout_helper_offset()));\n+\n+  \/\/ Klass::layout_helper_log2_element_size(lh)\n+  \/\/ (lh >> _lh_log2_element_size_shift) & _lh_log2_element_size_mask;\n+  shrl(rcx, Klass::_lh_log2_element_size_shift);\n+  andl(rcx, Klass::_lh_log2_element_size_mask);\n+  shlptr(index); \/\/ index << rcx\n+\n+  lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT)));\n+}\n+\n@@ -6422,1 +6815,1 @@\n-void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, KRegister mask) {\n+void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, KRegister mask) {\n@@ -6428,1 +6821,1 @@\n-    vpxor(xtmp, xtmp, xtmp, AVX_512bit);\n+    evpbroadcastq(xtmp, val, AVX_512bit);\n@@ -6430,1 +6823,3 @@\n-    vpxor(xtmp, xtmp, xtmp, AVX_256bit);\n+    movdq(xtmp, val);\n+    punpcklqdq(xtmp, xtmp);\n+    vinserti128_high(xtmp, xtmp);\n@@ -6432,1 +6827,2 @@\n-    pxor(xtmp, xtmp);\n+    movdq(xtmp, val);\n+    punpcklqdq(xtmp, xtmp);\n@@ -6455,1 +6851,1 @@\n-    fill64_masked(3, base, 0, xtmp, mask, cnt, rtmp, true);\n+    fill64_masked(3, base, 0, xtmp, mask, cnt, val, true);\n@@ -6474,1 +6870,1 @@\n-    fill32_masked(3, base, 0, xtmp, mask, cnt, rtmp);\n+    fill32_masked(3, base, 0, xtmp, mask, cnt, val);\n@@ -6487,0 +6883,400 @@\n+int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  \/\/ An inline type might be returned. If fields are in registers we\n+  \/\/ need to allocate an inline type instance and initialize it with\n+  \/\/ the value of the fields.\n+  Label skip;\n+  \/\/ We only need a new buffered inline type if a new one is not returned\n+  testptr(rax, 1);\n+  jcc(Assembler::zero, skip);\n+  int call_offset = -1;\n+\n+#ifdef _LP64\n+  \/\/ The following code is similar to allocate_instance but has some slight differences,\n+  \/\/ e.g. object size is always not zero, sometimes it's constant; storing klass ptr after\n+  \/\/ allocating is not necessary if vk != nullptr, etc. allocate_instance is not aware of these.\n+  Label slow_case;\n+  \/\/ 1. Try to allocate a new buffered inline instance either from TLAB or eden space\n+  mov(rscratch1, rax); \/\/ save rax for slow_case since *_allocate may corrupt it when allocation failed\n+  if (vk != nullptr) {\n+    \/\/ Called from C1, where the return type is statically known.\n+    movptr(rbx, (intptr_t)vk->get_InlineKlass());\n+    jint lh = vk->layout_helper();\n+    assert(lh != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n+    if (UseTLAB && !Klass::layout_helper_needs_slow_path(lh)) {\n+      tlab_allocate(r15_thread, rax, noreg, lh, r13, r14, slow_case);\n+    } else {\n+      jmp(slow_case);\n+    }\n+  } else {\n+    \/\/ Call from interpreter. RAX contains ((the InlineKlass* of the return type) | 0x01)\n+    mov(rbx, rax);\n+    andptr(rbx, -2);\n+    if (UseTLAB) {\n+      movl(r14, Address(rbx, Klass::layout_helper_offset()));\n+      testl(r14, Klass::_lh_instance_slow_path_bit);\n+      jcc(Assembler::notZero, slow_case);\n+      tlab_allocate(r15_thread, rax, r14, 0, r13, r14, slow_case);\n+    } else {\n+      jmp(slow_case);\n+    }\n+  }\n+  if (UseTLAB) {\n+    \/\/ 2. Initialize buffered inline instance header\n+    Register buffer_obj = rax;\n+    movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::inline_type_prototype().value());\n+    xorl(r13, r13);\n+    store_klass_gap(buffer_obj, r13);\n+    if (vk == nullptr) {\n+      \/\/ store_klass corrupts rbx(klass), so save it in r13 for later use (interpreter case only).\n+      mov(r13, rbx);\n+    }\n+    store_klass(buffer_obj, rbx, rscratch1);\n+    \/\/ 3. Initialize its fields with an inline class specific handler\n+    if (vk != nullptr) {\n+      call(RuntimeAddress(vk->pack_handler())); \/\/ no need for call info as this will not safepoint.\n+    } else {\n+      movptr(rbx, Address(r13, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      movptr(rbx, Address(rbx, InlineKlass::pack_handler_offset()));\n+      call(rbx);\n+    }\n+    jmp(skip);\n+  }\n+  bind(slow_case);\n+  \/\/ We failed to allocate a new inline type, fall back to a runtime\n+  \/\/ call. Some oop field may be live in some registers but we can't\n+  \/\/ tell. That runtime call will take care of preserving them\n+  \/\/ across a GC if there's one.\n+  mov(rax, rscratch1);\n+#endif\n+\n+  if (from_interpreter) {\n+    super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());\n+  } else {\n+    call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n+    call_offset = offset();\n+  }\n+\n+  bind(skip);\n+  return call_offset;\n+}\n+\n+\/\/ Move a value between registers\/stack slots and update the reg_state\n+bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]) {\n+  assert(from->is_valid() && to->is_valid(), \"source and destination must be valid\");\n+  if (reg_state[to->value()] == reg_written) {\n+    return true; \/\/ Already written\n+  }\n+  if (from != to && bt != T_VOID) {\n+    if (reg_state[to->value()] == reg_readonly) {\n+      return false; \/\/ Not yet writable\n+    }\n+    if (from->is_reg()) {\n+      if (to->is_reg()) {\n+        if (from->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to->as_XMMRegister(), from->as_XMMRegister());\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to->as_XMMRegister(), from->as_XMMRegister());\n+          }\n+        } else {\n+          movq(to->as_Register(), from->as_Register());\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        Address to_addr = Address(rsp, st_off);\n+        if (from->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to_addr, from->as_XMMRegister());\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to_addr, from->as_XMMRegister());\n+          }\n+        } else {\n+          movq(to_addr, from->as_Register());\n+        }\n+      }\n+    } else {\n+      Address from_addr = Address(rsp, from->reg2stack() * VMRegImpl::stack_slot_size + wordSize);\n+      if (to->is_reg()) {\n+        if (to->is_XMMRegister()) {\n+          if (bt == T_DOUBLE) {\n+            movdbl(to->as_XMMRegister(), from_addr);\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            movflt(to->as_XMMRegister(), from_addr);\n+          }\n+        } else {\n+          movq(to->as_Register(), from_addr);\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(r13, from_addr);\n+        movq(Address(rsp, st_off), r13);\n+      }\n+    }\n+  }\n+  \/\/ Update register states\n+  reg_state[from->value()] = reg_writable;\n+  reg_state[to->value()] = reg_written;\n+  return true;\n+}\n+\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  \/\/ Two additional slots to account for return address\n+  int sp_inc = (args_on_stack + 2) * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  \/\/ Save the return address, adjust the stack (make sure it is properly\n+  \/\/ 16-byte aligned) and copy the return address to the new top of the stack.\n+  \/\/ The stack will be repaired on return (see MacroAssembler::remove_frame).\n+  assert(sp_inc > 0, \"sanity\");\n+  pop(r13);\n+  subptr(rsp, sp_inc);\n+  push(r13);\n+  return sp_inc;\n+}\n+\n+\/\/ Read all fields from an inline type buffer and store the field values in registers\/stack slots.\n+bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                                          VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                                          RegState reg_state[]) {\n+  assert(sig->at(sig_index)._bt == T_VOID, \"should be at end delimiter\");\n+  assert(from->is_valid(), \"source must be valid\");\n+  bool progress = false;\n+#ifdef ASSERT\n+  const int start_offset = offset();\n+#endif\n+\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  Register tmp1 = r10;\n+  Register tmp2 = r13;\n+  Register fromReg = noreg;\n+  ScalarizedInlineArgsStream stream(sig, sig_index, to, to_count, to_index, -1);\n+  bool done = true;\n+  bool mark_done = true;\n+  VMReg toReg;\n+  BasicType bt;\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n+  while (stream.next(toReg, bt)) {\n+    assert(toReg->is_valid(), \"destination must be valid\");\n+    int idx = (int)toReg->value();\n+    if (reg_state[idx] == reg_readonly) {\n+      if (idx != from->value()) {\n+        mark_done = false;\n+      }\n+      done = false;\n+      continue;\n+    } else if (reg_state[idx] == reg_written) {\n+      continue;\n+    }\n+    assert(reg_state[idx] == reg_writable, \"must be writable\");\n+    reg_state[idx] = reg_written;\n+    progress = true;\n+\n+    if (fromReg == noreg) {\n+      if (from->is_reg()) {\n+        fromReg = from->as_Register();\n+      } else {\n+        int st_off = from->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(tmp1, Address(rsp, st_off));\n+        fromReg = tmp1;\n+      }\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        testptr(fromReg, fromReg);\n+        jcc(Assembler::zero, L_null);\n+      }\n+    }\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(Address(rsp, st_off), 1);\n+      } else {\n+        movq(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n+    Address fromAddr = Address(fromReg, off);\n+    if (!toReg->is_XMMRegister()) {\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n+      if (is_reference_type(bt)) {\n+        load_heap_oop(dst, fromAddr);\n+      } else {\n+        bool is_signed = (bt != T_CHAR) && (bt != T_BOOLEAN);\n+        load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);\n+      }\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(Address(rsp, st_off), dst);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      movdbl(toReg->as_XMMRegister(), fromAddr);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      movflt(toReg->as_XMMRegister(), fromAddr);\n+    }\n+  }\n+  if (progress && null_check) {\n+    if (done) {\n+      jmp(L_notNull);\n+      bind(L_null);\n+      \/\/ Set IsInit field to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+            movq(Address(rsp, st_off), 0);\n+          } else {\n+            xorq(toReg->as_Register(), toReg->as_Register());\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n+  sig_index = stream.sig_index();\n+  to_index = stream.regs_index();\n+\n+  if (mark_done && reg_state[from->value()] != reg_written) {\n+    \/\/ This is okay because no one else will write to that slot\n+    reg_state[from->value()] = reg_writable;\n+  }\n+  from_index--;\n+  assert(progress || (start_offset == offset()), \"should not emit code\");\n+  return done;\n+}\n+\n+bool MacroAssembler::pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                                        VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                                        RegState reg_state[], Register val_array) {\n+  assert(sig->at(sig_index)._bt == T_METADATA, \"should be at delimiter\");\n+  assert(to->is_valid(), \"destination must be valid\");\n+\n+  if (reg_state[to->value()] == reg_written) {\n+    skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+    return true; \/\/ Already written\n+  }\n+\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n+  Register val_obj_tmp = r11;\n+  Register from_reg_tmp = r14;\n+  Register tmp1 = r10;\n+  Register tmp2 = r13;\n+  Register tmp3 = rbx;\n+  Register val_obj = to->is_stack() ? val_obj_tmp : to->as_Register();\n+\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n+  if (reg_state[to->value()] == reg_readonly) {\n+    if (!is_reg_in_unpacked_fields(sig, sig_index, to, from, from_count, from_index)) {\n+      skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+      return false; \/\/ Not yet writable\n+    }\n+    val_obj = val_obj_tmp;\n+  }\n+\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_OBJECT);\n+  load_heap_oop(val_obj, Address(val_array, index));\n+\n+  ScalarizedInlineArgsStream stream(sig, sig_index, from, from_count, from_index);\n+  VMReg fromReg;\n+  BasicType bt;\n+  Label L_null;\n+  while (stream.next(fromReg, bt)) {\n+    assert(fromReg->is_valid(), \"source must be valid\");\n+    reg_state[fromReg->value()] = reg_writable;\n+\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        testb(Address(rsp, ld_off), 1);\n+      } else {\n+        testb(fromReg->as_Register(), 1);\n+      }\n+      jcc(Assembler::notZero, L_notNull);\n+      movptr(val_obj, 0);\n+      jmp(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n+    assert(off > 0, \"offset in object should be positive\");\n+    size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+\n+    Address dst(val_obj, off);\n+    if (!fromReg->is_XMMRegister()) {\n+      Register src;\n+      if (fromReg->is_stack()) {\n+        src = from_reg_tmp;\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        load_sized_value(src, Address(rsp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+      } else {\n+        src = fromReg->as_Register();\n+      }\n+      assert_different_registers(dst.base(), src, tmp1, tmp2, tmp3, val_array);\n+      if (is_reference_type(bt)) {\n+        store_heap_oop(dst, src, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        store_sized_value(dst, src, size_in_bytes);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      movdbl(dst, fromReg->as_XMMRegister());\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      movflt(dst, fromReg->as_XMMRegister());\n+    }\n+  }\n+  bind(L_null);\n+  sig_index = stream.sig_index();\n+  from_index = stream.regs_index();\n+\n+  assert(reg_state[to->value()] == reg_writable, \"must have already been read\");\n+  bool success = move_helper(val_obj->as_VMReg(), to, T_OBJECT, reg_state);\n+  assert(success, \"to register must be writeable\");\n+  return true;\n+}\n+\n+VMReg MacroAssembler::spill_reg_for(VMReg reg) {\n+  return reg->is_XMMRegister() ? xmm8->as_VMReg() : r14->as_VMReg();\n+}\n+\n+void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair) {\n+  assert((initial_framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+  if (needs_stack_repair) {\n+    movq(rbp, Address(rsp, initial_framesize));\n+    \/\/ The stack increment resides just below the saved rbp\n+    addq(rsp, Address(rsp, initial_framesize - wordSize));\n+  } else {\n+    if (initial_framesize > 0) {\n+      addq(rsp, initial_framesize);\n+    }\n+    pop(rbp);\n+  }\n+}\n+\n@@ -6576,2 +7372,2 @@\n-void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp,\n-                               bool is_large, KRegister mask) {\n+void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp,\n+                               bool is_large, bool word_copy_only, KRegister mask) {\n@@ -6582,1 +7378,1 @@\n-  assert(tmp==rax,   \"tmp register must be eax for rep stos\");\n+  assert(val==rax,   \"val register must be eax for rep stos\");\n@@ -6588,3 +7384,0 @@\n-  if (!is_large || !UseXMMForObjInit) {\n-    xorptr(tmp, tmp);\n-  }\n@@ -6604,1 +7397,1 @@\n-    movptr(Address(base, cnt, Address::times_ptr), tmp);\n+    movptr(Address(base, cnt, Address::times_ptr), val);\n@@ -6613,1 +7406,1 @@\n-  if (UseFastStosb) {\n+  if (UseFastStosb && !word_copy_only) {\n@@ -6617,1 +7410,1 @@\n-    xmm_clear_mem(base, cnt, tmp, xtmp, mask);\n+    xmm_clear_mem(base, cnt, val, xtmp, mask);\n@@ -10738,0 +11531,4 @@\n+  if (EnableValhalla) {\n+    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+    andptr(reg_rax, ~((int) markWord::inline_type_bit_in_place));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":814,"deletions":17,"binary":false,"changes":831,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"asm\/assembler.hpp\"\n@@ -41,0 +42,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include \"vmreg_x86.inline.hpp\"\n@@ -307,4 +310,6 @@\n-  __ movptr(c_rarg0, result);\n-  Label is_long, is_float, is_double, exit;\n-  __ movl(c_rarg1, result_type);\n-  __ cmpl(c_rarg1, T_OBJECT);\n+  __ movptr(r13, result);\n+  Label is_long, is_float, is_double, check_prim, exit;\n+  __ movl(rbx, result_type);\n+  __ cmpl(rbx, T_OBJECT);\n+  __ jcc(Assembler::equal, check_prim);\n+  __ cmpl(rbx, T_LONG);\n@@ -312,3 +317,1 @@\n-  __ cmpl(c_rarg1, T_LONG);\n-  __ jcc(Assembler::equal, is_long);\n-  __ cmpl(c_rarg1, T_FLOAT);\n+  __ cmpl(rbx, T_FLOAT);\n@@ -316,1 +319,1 @@\n-  __ cmpl(c_rarg1, T_DOUBLE);\n+  __ cmpl(rbx, T_DOUBLE);\n@@ -322,1 +325,1 @@\n-    __ cmpl(c_rarg1, T_INT);\n+    __ cmpl(rbx, T_INT);\n@@ -330,1 +333,1 @@\n-  __ movl(Address(c_rarg0, 0), rax);\n+  __ movl(Address(r13, 0), rax);\n@@ -388,0 +391,13 @@\n+  __ BIND(check_prim);\n+  if (InlineTypeReturnedAsFields) {\n+    \/\/ Check for scalarized return value\n+    __ testptr(rax, 1);\n+    __ jcc(Assembler::zero, is_long);\n+    \/\/ Load pack handler address\n+    __ andptr(rax, -2);\n+    __ movptr(rax, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    __ movptr(rbx, Address(rax, InlineKlass::pack_handler_jobject_offset()));\n+    \/\/ Call pack handler to initialize the buffer\n+    __ call(rbx);\n+    __ jmp(exit);\n+  }\n@@ -389,1 +405,1 @@\n-  __ movq(Address(c_rarg0, 0), rax);\n+  __ movq(Address(r13, 0), rax);\n@@ -393,1 +409,1 @@\n-  __ movflt(Address(c_rarg0, 0), xmm0);\n+  __ movflt(Address(r13, 0), xmm0);\n@@ -397,1 +413,1 @@\n-  __ movdbl(Address(c_rarg0, 0), xmm0);\n+  __ movdbl(Address(r13, 0), xmm0);\n@@ -4074,0 +4090,10 @@\n+  \/\/ Generate these first because they are called from other stubs\n+  if (InlineTypeReturnedAsFields) {\n+    StubRoutines::_load_inline_type_fields_in_regs =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs),\n+                                 \"load_inline_type_fields_in_regs\", false);\n+    StubRoutines::_store_inline_type_fields_to_buf =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf),\n+                                 \"store_inline_type_fields_to_buf\", true);\n+  }\n+\n@@ -4126,0 +4152,144 @@\n+\/\/ Call here from the interpreter or compiled code to either load\n+\/\/ multiple returned values from the inline type instance being\n+\/\/ returned to registers or to store returned values to a newly\n+\/\/ allocated inline type instance.\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n+address StubGenerator::generate_return_value_stub(address destination, const char* name, bool has_res) {\n+  \/\/ We need to save all registers the calling convention may use so\n+  \/\/ the runtime calls read or update those registers. This needs to\n+  \/\/ be in sync with SharedRuntime::java_return_convention().\n+  enum layout {\n+    pad_off = frame::arg_reg_save_area_bytes\/BytesPerInt, pad_off_2,\n+    rax_off, rax_off_2,\n+    j_rarg5_off, j_rarg5_2,\n+    j_rarg4_off, j_rarg4_2,\n+    j_rarg3_off, j_rarg3_2,\n+    j_rarg2_off, j_rarg2_2,\n+    j_rarg1_off, j_rarg1_2,\n+    j_rarg0_off, j_rarg0_2,\n+    j_farg0_off, j_farg0_2,\n+    j_farg1_off, j_farg1_2,\n+    j_farg2_off, j_farg2_2,\n+    j_farg3_off, j_farg3_2,\n+    j_farg4_off, j_farg4_2,\n+    j_farg5_off, j_farg5_2,\n+    j_farg6_off, j_farg6_2,\n+    j_farg7_off, j_farg7_2,\n+    rbp_off, rbp_off_2,\n+    return_off, return_off_2,\n+\n+    framesize\n+  };\n+\n+  CodeBuffer buffer(name, 1000, 512);\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+\n+  int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+  assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+  int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+  int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+  OopMapSet *oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+  map->set_callee_saved(VMRegImpl::stack2reg(rax_off), rax->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+  int start = __ offset();\n+\n+  __ subptr(rsp, frame_size_in_bytes - 8 \/* return address*\/);\n+\n+  __ movptr(Address(rsp, rbp_off * BytesPerInt), rbp);\n+  __ movdbl(Address(rsp, j_farg7_off * BytesPerInt), j_farg7);\n+  __ movdbl(Address(rsp, j_farg6_off * BytesPerInt), j_farg6);\n+  __ movdbl(Address(rsp, j_farg5_off * BytesPerInt), j_farg5);\n+  __ movdbl(Address(rsp, j_farg4_off * BytesPerInt), j_farg4);\n+  __ movdbl(Address(rsp, j_farg3_off * BytesPerInt), j_farg3);\n+  __ movdbl(Address(rsp, j_farg2_off * BytesPerInt), j_farg2);\n+  __ movdbl(Address(rsp, j_farg1_off * BytesPerInt), j_farg1);\n+  __ movdbl(Address(rsp, j_farg0_off * BytesPerInt), j_farg0);\n+\n+  __ movptr(Address(rsp, j_rarg0_off * BytesPerInt), j_rarg0);\n+  __ movptr(Address(rsp, j_rarg1_off * BytesPerInt), j_rarg1);\n+  __ movptr(Address(rsp, j_rarg2_off * BytesPerInt), j_rarg2);\n+  __ movptr(Address(rsp, j_rarg3_off * BytesPerInt), j_rarg3);\n+  __ movptr(Address(rsp, j_rarg4_off * BytesPerInt), j_rarg4);\n+  __ movptr(Address(rsp, j_rarg5_off * BytesPerInt), j_rarg5);\n+  __ movptr(Address(rsp, rax_off * BytesPerInt), rax);\n+\n+  int frame_complete = __ offset();\n+\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n+\n+  __ mov(c_rarg0, r15_thread);\n+  __ mov(c_rarg1, rax);\n+\n+  __ call(RuntimeAddress(destination));\n+\n+  \/\/ Set an oopmap for the call site.\n+\n+  oop_maps->add_gc_map( __ offset() - start, map);\n+\n+  \/\/ clear last_Java_sp\n+  __ reset_last_Java_frame(false);\n+\n+  __ movptr(rbp, Address(rsp, rbp_off * BytesPerInt));\n+  __ movdbl(j_farg7, Address(rsp, j_farg7_off * BytesPerInt));\n+  __ movdbl(j_farg6, Address(rsp, j_farg6_off * BytesPerInt));\n+  __ movdbl(j_farg5, Address(rsp, j_farg5_off * BytesPerInt));\n+  __ movdbl(j_farg4, Address(rsp, j_farg4_off * BytesPerInt));\n+  __ movdbl(j_farg3, Address(rsp, j_farg3_off * BytesPerInt));\n+  __ movdbl(j_farg2, Address(rsp, j_farg2_off * BytesPerInt));\n+  __ movdbl(j_farg1, Address(rsp, j_farg1_off * BytesPerInt));\n+  __ movdbl(j_farg0, Address(rsp, j_farg0_off * BytesPerInt));\n+\n+  __ movptr(j_rarg0, Address(rsp, j_rarg0_off * BytesPerInt));\n+  __ movptr(j_rarg1, Address(rsp, j_rarg1_off * BytesPerInt));\n+  __ movptr(j_rarg2, Address(rsp, j_rarg2_off * BytesPerInt));\n+  __ movptr(j_rarg3, Address(rsp, j_rarg3_off * BytesPerInt));\n+  __ movptr(j_rarg4, Address(rsp, j_rarg4_off * BytesPerInt));\n+  __ movptr(j_rarg5, Address(rsp, j_rarg5_off * BytesPerInt));\n+  __ movptr(rax, Address(rsp, rax_off * BytesPerInt));\n+\n+  __ addptr(rsp, frame_size_in_bytes-8);\n+\n+  \/\/ check for pending exceptions\n+  Label pending;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, pending);\n+\n+  if (has_res) {\n+    __ get_vm_result(rax, r15_thread);\n+  }\n+\n+  __ ret(0);\n+\n+  __ bind(pending);\n+\n+  __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ -------------\n+  \/\/ make sure all code is generated\n+  _masm->flush();\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, false);\n+  return stub->entry_point();\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":183,"deletions":13,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -623,0 +623,3 @@\n+  \/\/ interpreter or compiled code marshalling registers to\/from inline type instance\n+  address generate_return_value_stub(address destination, const char* name, bool has_res);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3039,0 +3039,6 @@\n+  \/\/ Check for flat inline type array -> return -1\n+  __ test_flat_array_oop(src, rax, L_failed);\n+\n+  \/\/ Check for null-free (non-flat) inline type array -> handle as object array\n+  __ test_null_free_array_oop(src, rax, L_objArray);\n+\n@@ -3042,0 +3048,4 @@\n+  \/\/ Check for flat inline type array -> return -1\n+  __ testl(rax_lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  __ jcc(Assembler::notZero, L_failed);\n+\n@@ -3051,2 +3061,4 @@\n-    __ cmpl(rax_lh, (Klass::_lh_array_tag_type_value << Klass::_lh_array_tag_shift));\n-    __ jcc(Assembler::greaterEqual, L);\n+    __ movl(rklass_tmp, rax_lh);\n+    __ sarl(rklass_tmp, Klass::_lh_array_tag_shift);\n+    __ cmpl(rklass_tmp, Klass::_lh_array_tag_type_value);\n+    __ jcc(Assembler::equal, L);\n@@ -3160,0 +3172,1 @@\n+    \/\/ This check also fails for flat arrays which are not supported.\n@@ -3163,0 +3176,11 @@\n+#ifdef ASSERT\n+    {\n+      BLOCK_COMMENT(\"assert not null-free array {\");\n+      Label L;\n+      __ test_non_null_free_array_oop(dst, rklass_tmp, L);\n+      __ stop(\"unexpected null-free array\");\n+      __ bind(L);\n+      BLOCK_COMMENT(\"} assert not null-free array\");\n+    }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-  if (!src_obj->fast_no_hash_check()) {\n+  if (!src_obj->fast_no_hash_check() && (!(EnableValhalla && src_obj->mark().is_inline_type()))) {\n@@ -594,0 +594,2 @@\n+    } else if (EnableValhalla) {\n+      fake_oop->set_mark(src_klass->prototype_header().copy_set_hash(src_hash));\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -51,0 +52,8 @@\n+bool CDSConfig::_module_patching_disables_cds = false;\n+bool CDSConfig::_java_base_module_patching_disables_cds = false;\n+\n+bool CDSConfig::is_valhalla_preview() {\n+  return Arguments::enable_preview() && EnableValhalla;\n+}\n+\n+\n@@ -104,0 +113,3 @@\n+    if (is_valhalla_preview()) {\n+      tmp.print_raw(\"_valhalla\");\n+    }\n@@ -286,2 +298,1 @@\n-    \"jdk.module.upgrade.path\",\n-    \"jdk.module.patch.0\"\n+    \"jdk.module.upgrade.path\"\n@@ -291,2 +302,1 @@\n-    \"--upgrade-module-path\",\n-    \"--patch-module\"\n+    \"--upgrade-module-path\"\n@@ -315,0 +325,6 @@\n+\n+  if (module_patching_disables_cds()) {\n+    vm_exit_during_initialization(\n+            \"Cannot use the following option when dumping the shared archive\", \"--patch-module\");\n+  }\n+\n@@ -339,0 +355,10 @@\n+\n+  if (module_patching_disables_cds()) {\n+    if (RequireSharedSpaces) {\n+      warning(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    } else {\n+      log_info(cds)(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    }\n+    return true;\n+  }\n+\n@@ -420,1 +446,1 @@\n-bool CDSConfig::check_vm_args_consistency(bool patch_mod_javabase, bool mode_flag_cmd_line) {\n+bool CDSConfig::check_vm_args_consistency(bool mode_flag_cmd_line) {\n@@ -483,1 +509,1 @@\n-  if (is_using_archive() && patch_mod_javabase) {\n+  if (is_using_archive() && java_base_module_patching_disables_cds() && module_patching_disables_cds()) {\n@@ -576,0 +602,4 @@\n+  if (is_valhalla_preview()) {\n+    \/\/ Not working yet -- e.g., HeapShared::oop_hash() needs to be implemented for value oops\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+  static bool _module_patching_disables_cds;\n+  static bool _java_base_module_patching_disables_cds;\n+\n@@ -78,1 +81,6 @@\n-  static bool check_vm_args_consistency(bool patch_mod_javabase, bool mode_flag_cmd_line) NOT_CDS_RETURN_(true);\n+  static bool check_vm_args_consistency(bool mode_flag_cmd_line) NOT_CDS_RETURN_(true);\n+\n+  static bool module_patching_disables_cds() { return _module_patching_disables_cds; }\n+  static void set_module_patching_disables_cds() { _module_patching_disables_cds = true; }\n+  static bool java_base_module_patching_disables_cds() { return _java_base_module_patching_disables_cds; }\n+  static void set_java_base_module_patching_disables_cds() { _java_base_module_patching_disables_cds = true; }\n@@ -138,0 +146,3 @@\n+  static bool is_valhalla_preview();\n+\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -87,0 +87,65 @@\n+inline void CDSMustMatchFlags::do_print(outputStream* st, bool v) {\n+  st->print(\"%s\", v ? \"true\" : \"false\");\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, intx v) {\n+  st->print(\"%zd\", v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, uintx v) {\n+  st->print(\"%zu\", v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, double v) {\n+  st->print(\"%f\", v);\n+}\n+\n+void CDSMustMatchFlags::init() {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+  _max_name_width = 0;\n+\n+#define INIT_CDS_MUST_MATCH_FLAG(n) \\\n+  _v_##n = n; \\\n+  _max_name_width = MAX2(_max_name_width,strlen(#n));\n+  CDS_MUST_MATCH_FLAGS_DO(INIT_CDS_MUST_MATCH_FLAG);\n+#undef INIT_CDS_MUST_MATCH_FLAG\n+}\n+\n+bool CDSMustMatchFlags::runtime_check() const {\n+#define CHECK_CDS_MUST_MATCH_FLAG(n) \\\n+  if (_v_##n != n) { \\\n+    ResourceMark rm; \\\n+    stringStream ss; \\\n+    ss.print(\"VM option %s is different between dumptime (\", #n);  \\\n+    do_print(&ss, _v_ ## n); \\\n+    ss.print(\") and runtime (\"); \\\n+    do_print(&ss, n); \\\n+    ss.print(\")\"); \\\n+    log_info(cds)(\"%s\", ss.as_string()); \\\n+    return false; \\\n+  }\n+  CDS_MUST_MATCH_FLAGS_DO(CHECK_CDS_MUST_MATCH_FLAG);\n+#undef CHECK_CDS_MUST_MATCH_FLAG\n+\n+  return true;\n+}\n+\n+void CDSMustMatchFlags::print_info() const {\n+  LogTarget(Info, cds) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Recorded VM flags during dumptime:\");\n+    print(&ls);\n+  }\n+}\n+\n+void CDSMustMatchFlags::print(outputStream* st) const {\n+#define PRINT_CDS_MUST_MATCH_FLAG(n) \\\n+  st->print(\"- %-s \", #n);                   \\\n+  st->sp(int(_max_name_width - strlen(#n))); \\\n+  do_print(st, _v_##n);                      \\\n+  st->cr();\n+  CDS_MUST_MATCH_FLAGS_DO(PRINT_CDS_MUST_MATCH_FLAG);\n+#undef PRINT_CDS_MUST_MATCH_FLAG\n+}\n+\n@@ -230,0 +295,1 @@\n+  _has_valhalla_patched_classes = CDSConfig::is_valhalla_preview();\n@@ -251,0 +317,1 @@\n+  _must_match.init();\n@@ -320,0 +387,2 @@\n+  st->print_cr(\"- has_valhalla_patched_classes    %d\", _has_valhalla_patched_classes);\n+  _must_match.print(st);\n@@ -1417,0 +1486,4 @@\n+  if (!header()->check_must_match_flags()) {\n+    return false;\n+  }\n+\n@@ -2644,0 +2717,18 @@\n+  if (is_static()) {\n+    const char* err = nullptr;\n+    if (CDSConfig::is_valhalla_preview()) {\n+      if (!_has_valhalla_patched_classes) {\n+        err = \"not created\";\n+      }\n+    } else {\n+      if (_has_valhalla_patched_classes) {\n+        err = \"created\";\n+      }\n+    }\n+    if (err != nullptr) {\n+      log_warning(cds)(\"This archive was %s with --enable-preview -XX:+EnableValhalla. It is \"\n+                         \"incompatible with the current JVM setting\", err);\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1986,0 +1986,7 @@\n+\n+    if (CDSConfig::is_valhalla_preview() && strcmp(klass_name, \"jdk\/internal\/module\/ArchivedModuleGraph\") == 0) {\n+      \/\/ FIXME -- ArchivedModuleGraph doesn't work when java.base is patched with valhalla classes.\n+      i++;\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -116,1 +118,1 @@\n-\/\/ [0] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are\n+\/\/ [0] All classes are loaded in MetaspaceShared::loadable_descriptors(). All metadata are\n@@ -877,1 +879,1 @@\n-void MetaspaceShared::preload_classes(TRAPS) {\n+void MetaspaceShared::loadable_descriptors(TRAPS) {\n@@ -922,1 +924,1 @@\n-  preload_classes(CHECK);\n+  loadable_descriptors(CHECK);\n@@ -1047,0 +1049,5 @@\n+  if (CDSConfig::is_valhalla_preview()) {\n+    log_info(cds)(\"Archived java heap is not yet supported with Valhalla preview\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -56,1 +58,1 @@\n-#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/instanceMirrorKlass.inline.hpp\"\n@@ -1070,1 +1072,9 @@\n-    if (k->is_typeArray_klass()) {\n+    if (k->is_flatArray_klass()) {\n+      Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)->element_klass();\n+      assert(element_klass->is_inline_klass(), \"Must be inline type component\");\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(element_klass));\n+      } else {\n+        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+      }\n+    } else if (k->is_typeArray_klass()) {\n@@ -1081,0 +1091,1 @@\n+      oop comp_oop = element_klass->java_mirror();\n@@ -1084,1 +1095,1 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1140,0 +1151,1 @@\n+\n@@ -1162,3 +1174,3 @@\n-  if (k->class_loader() != nullptr &&\n-      k->class_loader() != SystemDictionary::java_platform_loader() &&\n-      k->class_loader() != SystemDictionary::java_system_loader()) {\n+  if ((k->class_loader() != nullptr &&\n+       k->class_loader() != SystemDictionary::java_platform_loader() &&\n+       k->class_loader() != SystemDictionary::java_system_loader())) {\n@@ -1382,1 +1394,3 @@\n-  if (is_instance)  st->print(\"L\");\n+  if (is_instance)  {\n+    st->print(\"L\");\n+  }\n@@ -1441,0 +1455,4 @@\n+  if (klass->is_flatArray_klass() || (klass->is_objArray_klass() && ObjArrayKlass::cast(klass)->is_null_free_array_klass())) {\n+    \/\/ TODO 8336006 Ignore flat \/ null-free arrays\n+    return;\n+  }\n@@ -2813,1 +2831,1 @@\n-      if (method->name() == vmSymbols::object_initializer_name() &&\n+      if (method->is_object_constructor() &&\n@@ -3172,2 +3190,2 @@\n-  if (m->is_object_initializer()) {\n-    flags |= java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR;\n+  if (m->is_object_constructor()) {\n+    flags |= java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR;\n@@ -3564,1 +3582,1 @@\n-int java_lang_reflect_Field::_trusted_final_offset;\n+int java_lang_reflect_Field::_flags_offset;\n@@ -3574,1 +3592,1 @@\n-  macro(_trusted_final_offset,    k, vmSymbols::trusted_final_name(),    bool_signature,       false); \\\n+  macro(_flags_offset,     k, vmSymbols::flags_name(),     int_signature,    false); \\\n@@ -3639,2 +3657,2 @@\n-void java_lang_reflect_Field::set_trusted_final(oop field) {\n-  field->bool_field_put(_trusted_final_offset, true);\n+void java_lang_reflect_Field::set_flags(oop field, int value) {\n+  field->int_field_put(_flags_offset, value);\n@@ -3947,1 +3965,1 @@\n-  macro(_value_offset,      integerKlass, \"value\", int_signature, false); \\\n+  macro(_value_offset,      byteKlass, \"value\", byte_signature, false); \\\n@@ -3951,1 +3969,1 @@\n-  InstanceKlass* integerKlass = vmClasses::Integer_klass();\n+  InstanceKlass* byteKlass = vmClasses::Byte_klass();\n@@ -4472,1 +4490,0 @@\n-\n@@ -4482,1 +4499,1 @@\n-  return (flags(mname) & (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) > 0;\n+  return (flags(mname) & (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) > 0;\n@@ -5487,1 +5504,5 @@\n-  CHECK_OFFSET(\"java\/lang\/Float\",     java_lang_boxing_object, value, \"F\");\n+  if (Arguments::enable_preview() && UseNullableValueFlattening && UseFieldFlattening) {\n+    CHECK_LONG_OFFSET(\"java\/lang\/Float\",     java_lang_boxing_object, value, \"F\");\n+  } else {\n+    CHECK_OFFSET(\"java\/lang\/Float\",     java_lang_boxing_object, value, \"F\");\n+  }\n@@ -5491,1 +5512,5 @@\n-  CHECK_OFFSET(\"java\/lang\/Integer\",   java_lang_boxing_object, value, \"I\");\n+  if (Arguments::enable_preview() && UseNullableValueFlattening && UseFieldFlattening) {\n+    CHECK_LONG_OFFSET(\"java\/lang\/Integer\",   java_lang_boxing_object, value, \"I\");\n+  } else {\n+    CHECK_OFFSET(\"java\/lang\/Integer\",   java_lang_boxing_object, value, \"I\");\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":45,"deletions":20,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+\n@@ -270,0 +271,1 @@\n+\n@@ -313,0 +315,1 @@\n+\n@@ -821,1 +824,1 @@\n-  static int _trusted_final_offset;\n+  static int _flags_offset;\n@@ -849,1 +852,1 @@\n-  static void set_trusted_final(oop field);\n+  static void set_flags(oop field, int value);\n@@ -1348,1 +1351,1 @@\n-    MN_IS_CONSTRUCTOR        = 0x00020000, \/\/ constructor\n+    MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, \/\/ constructor\n@@ -1354,0 +1357,1 @@\n+    MN_NULL_RESTRICTED_FIELD = 0x00800000, \/\/ null-restricted field\n@@ -1355,1 +1359,3 @@\n-    MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n+    MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT, \/\/ 4 bits\n+    MN_LAYOUT_SHIFT          = 28, \/\/ field layout\n+    MN_LAYOUT_MASK           = 0x70000000 >> MN_LAYOUT_SHIFT, \/\/ 3 bits\n@@ -1859,1 +1865,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -68,0 +69,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -76,0 +78,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -351,1 +354,1 @@\n-      \/\/ Ignore wrapping L and ;.\n+      \/\/ Ignore wrapping L and ; (and Q and ; for value types).\n@@ -920,2 +923,1 @@\n-  assert(!ModuleEntryTable::javabase_moduleEntry()->is_patched(),\n-         \"Cannot use sharing if java.base is patched\");\n+  assert(!CDSConfig::module_patching_disables_cds(), \"Cannot use CDS\");\n@@ -997,1 +999,1 @@\n-        assert(!mod_entry->is_patched(), \"cannot load archived classes for patched module\");\n+        assert(!CDSConfig::module_patching_disables_cds(), \"Cannot use CDS\");\n@@ -1129,0 +1131,32 @@\n+  if (ik->has_inline_type_fields()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) continue;\n+      Symbol* sig = fs.signature();\n+      if (fs.is_null_free_inline_type()) {\n+        \/\/ Pre-load inline class\n+        TempNewSymbol name = Signature::strip_envelope(sig);\n+        Klass* real_k = SystemDictionary::resolve_with_circularity_detection_or_fail(ik->name(), name,\n+          class_loader, false, CHECK_NULL);\n+        Klass* k = ik->get_inline_type_field_klass_or_null(fs.index());\n+        if (real_k != k) {\n+          \/\/ oops, the app has substituted a different version of k!\n+          return nullptr;\n+        }\n+      } else if (Signature::has_envelope(sig)) {\n+        TempNewSymbol name = Signature::strip_envelope(sig);\n+        if (name != ik->name() && ik->is_class_in_loadable_descriptors_attribute(name)) {\n+          Klass* real_k = SystemDictionary::resolve_with_circularity_detection_or_fail(ik->name(), name,\n+            class_loader, false, THREAD);\n+          if (HAS_PENDING_EXCEPTION) {\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+          Klass* k = ik->get_inline_type_field_klass_or_null(fs.index());\n+          if (real_k != k) {\n+            \/\/ oops, the app has substituted a different version of k!\n+            return nullptr;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1164,0 +1198,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+class AllFieldStream;\n@@ -115,1 +116,2 @@\n-  static InstanceKlass* resolve_super_or_fail(Symbol* class_name, Symbol* super_name,\n+  static InstanceKlass* resolve_with_circularity_detection_or_fail(Symbol* class_name,\n+                                              Symbol* super_name,\n@@ -142,0 +144,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+  do_klass(ValueObjectMethods_klass,                    java_lang_runtime_ValueObjectMethods                  ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+  template(tag_loadable_descriptors,                  \"LoadableDescriptors\")                      \\\n@@ -205,0 +206,1 @@\n+  template(java_lang_IdentityException,               \"java\/lang\/IdentityException\")              \\\n@@ -252,0 +254,3 @@\n+  template(jdk_internal_vm_annotation_ImplicitlyConstructible_signature,     \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\") \\\n+  template(jdk_internal_vm_annotation_LooselyConsistentValue_signature,      \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\") \\\n+  template(jdk_internal_vm_annotation_NullRestricted_signature,              \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\") \\\n@@ -281,1 +286,0 @@\n-  template(trusted_final_name,                        \"trustedFinal\")                             \\\n@@ -502,0 +506,3 @@\n+  template(default_value_name,                        \".default\")                                 \\\n+  template(null_reset_value_name,                     \".null_reset\")                              \\\n+  template(empty_marker_name,                         \".empty\")                                   \\\n@@ -576,0 +583,1 @@\n+  template(class_class_signature,                     \"(Ljava\/lang\/Class;)Ljava\/lang\/Class;\")     \\\n@@ -585,0 +593,1 @@\n+  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\")                  \\\n@@ -712,0 +721,2 @@\n+  template(primaryType_name,                           \"primaryType\")                                             \\\n+  template(secondaryType_name,                         \"secondaryType\")                                           \\\n@@ -740,0 +751,6 @@\n+  template(java_lang_runtime_ValueObjectMethods,            \"java\/lang\/runtime\/ValueObjectMethods\")               \\\n+  template(isSubstitutable_name,                            \"isSubstitutable\")                                    \\\n+  template(valueObjectHashCode_name,                        \"valueObjectHashCode\")                                \\\n+  template(jdk_internal_value_PrimitiveClass,               \"jdk\/internal\/value\/PrimitiveClass\")                  \\\n+  template(jdk_internal_value_ValueClass,                   \"jdk\/internal\/value\/ValueClass\")                      \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -784,0 +784,6 @@\n+  product(bool, UseArrayLoadStoreProfile, true,                             \\\n+          \"Take advantage of profiling at array load\/store\")                \\\n+                                                                            \\\n+  product(bool, UseACmpProfile, true,                                       \\\n+          \"Take advantage of profiling at acmp\")                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -523,0 +524,1 @@\n+\n@@ -969,1 +971,2 @@\n-             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck()) {\n+             cmp1->is_SubTypeCheck() || cmp2->is_SubTypeCheck() ||\n+             cmp1->is_FlatArrayCheck() || cmp2->is_FlatArrayCheck()) {\n@@ -1048,1 +1051,1 @@\n-\/\/ note that these functions assume that the _adr_type field is flattened\n+\/\/ note that these functions assume that the _adr_type field is flat\n@@ -1066,1 +1069,1 @@\n-  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at), \"flatten at\");\n+  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES && Compile::current()->flat_accesses_share_alias()), \"flatten at\");\n@@ -1194,0 +1197,8 @@\n+  \/\/ Flat array element shouldn't get their own memory slice until flat_accesses_share_alias is cleared.\n+  \/\/ It could be the graph has no loads\/stores and flat_accesses_share_alias is never cleared. EA could still\n+  \/\/ creates per element Phis but that wouldn't be a problem as there are no memory accesses for that array.\n+  assert(_adr_type == nullptr || _adr_type->isa_aryptr() == nullptr ||\n+         _adr_type->is_aryptr()->is_known_instance() ||\n+         !_adr_type->is_aryptr()->is_flat() ||\n+         !Compile::current()->flat_accesses_share_alias() ||\n+         _adr_type == TypeAryPtr::INLINES, \"flat array element shouldn't get its own slice yet\");\n@@ -1412,0 +1423,1 @@\n+\n@@ -2032,0 +2044,46 @@\n+\/\/ Push inline type input nodes (and null) down through the phi recursively (can handle data loops).\n+InlineTypeNode* PhiNode::push_inline_types_down(PhaseGVN* phase, bool can_reshape, ciInlineKlass* inline_klass) {\n+  assert(inline_klass != nullptr, \"must be\");\n+  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, inline_klass, \/* transform = *\/ false)->clone_with_phis(phase, in(0), nullptr, !_type->maybe_null());\n+  if (can_reshape) {\n+    \/\/ Replace phi right away to be able to use the inline\n+    \/\/ type node when reaching the phi again through data loops.\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* u = fast_out(i);\n+      igvn->rehash_node_delayed(u);\n+      imax -= u->replace_edge(this, vt);\n+      --i;\n+    }\n+    igvn->rehash_node_delayed(this);\n+    assert(outcnt() == 0, \"should be dead now\");\n+  }\n+  ResourceMark rm;\n+  Node_List casts;\n+  for (uint i = 1; i < req(); ++i) {\n+    Node* n = in(i);\n+    while (n->is_ConstraintCast()) {\n+      casts.push(n);\n+      n = n->in(1);\n+    }\n+    if (phase->type(n)->is_zero_type()) {\n+      n = InlineTypeNode::make_null(*phase, inline_klass);\n+    } else if (n->is_Phi()) {\n+      assert(can_reshape, \"can only handle phis during IGVN\");\n+      n = phase->transform(n->as_Phi()->push_inline_types_down(phase, can_reshape, inline_klass));\n+    }\n+    while (casts.size() != 0) {\n+      \/\/ Push the cast(s) through the InlineTypeNode\n+      \/\/ TODO 8302217 Can we avoid cloning? See InlineTypeNode::clone_if_required\n+      Node* cast = casts.pop()->clone();\n+      cast->set_req_X(1, n->as_InlineType()->get_oop(), phase);\n+      n = n->clone();\n+      n->as_InlineType()->set_oop(*phase, phase->transform(cast));\n+      n = phase->transform(n);\n+    }\n+    bool transform = !can_reshape && (i == (req()-1)); \/\/ Transform phis on last merge\n+    vt->merge_with(phase, n->as_InlineType(), i, transform);\n+  }\n+  return vt;\n+}\n+\n@@ -2364,0 +2422,2 @@\n+    \/\/ TODO revisit this with JDK-8247216\n+    bool mergemem_only = true;\n@@ -2376,0 +2436,2 @@\n+      } else {\n+        mergemem_only = false;\n@@ -2380,1 +2442,1 @@\n-    if (!saw_self && adr_type() == TypePtr::BOTTOM)  merge_width = 0;\n+    if (!mergemem_only && !saw_self && adr_type() == TypePtr::BOTTOM)  merge_width = 0;\n@@ -2451,0 +2513,5 @@\n+            if (igvn) {\n+              \/\/ TODO revisit this with JDK-8247216\n+              \/\/ Put 'n' on the worklist because it might be modified by MergeMemStream::iteration_setup\n+              igvn->_worklist.push(n);\n+            }\n@@ -2569,0 +2636,5 @@\n+  Node* inline_type = try_push_inline_types_down(phase, can_reshape);\n+  if (inline_type != this) {\n+    return inline_type;\n+  }\n+\n@@ -2612,0 +2684,95 @@\n+\/\/ Check recursively if inputs are either an inline type, constant null\n+\/\/ or another Phi (including self references through data loops). If so,\n+\/\/ push the inline types down through the phis to enable folding of loads.\n+Node* PhiNode::try_push_inline_types_down(PhaseGVN* phase, const bool can_reshape) {\n+  if (!can_be_inline_type()) {\n+    return this;\n+  }\n+\n+  ciInlineKlass* inline_klass;\n+  if (can_push_inline_types_down(phase, can_reshape, inline_klass)) {\n+    assert(inline_klass != nullptr, \"must be\");\n+    return push_inline_types_down(phase, can_reshape, inline_klass);\n+  }\n+  return this;\n+}\n+\n+bool PhiNode::can_push_inline_types_down(PhaseGVN* phase, const bool can_reshape, ciInlineKlass*& inline_klass) {\n+  if (req() <= 2) {\n+    \/\/ Dead phi.\n+    return false;\n+  }\n+  inline_klass = nullptr;\n+\n+  \/\/ TODO 8302217 We need to prevent endless pushing through\n+  bool only_phi = (outcnt() != 0);\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* n = fast_out(i);\n+    if (n->is_InlineType() && n->in(1) == this) {\n+      return false;\n+    }\n+    if (!n->is_Phi()) {\n+      only_phi = false;\n+    }\n+  }\n+  if (only_phi) {\n+    return false;\n+  }\n+\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(this);\n+  Node_List casts;\n+\n+  for (uint next = 0; next < worklist.size(); next++) {\n+    Node* phi = worklist.at(next);\n+    for (uint i = 1; i < phi->req(); i++) {\n+      Node* n = phi->in(i);\n+      if (n == nullptr) {\n+        return false;\n+      }\n+      while (n->is_ConstraintCast()) {\n+        if (n->in(0) != nullptr && n->in(0)->is_top()) {\n+          \/\/ Will die, don't optimize\n+          return false;\n+        }\n+        casts.push(n);\n+        n = n->in(1);\n+      }\n+      const Type* type = phase->type(n);\n+      if (n->is_InlineType() && (inline_klass == nullptr || inline_klass == type->inline_klass())) {\n+        inline_klass = type->inline_klass();\n+      } else if (n->is_Phi() && can_reshape && n->bottom_type()->isa_ptr()) {\n+        worklist.push(n);\n+      } else if (!type->is_zero_type()) {\n+        return false;\n+      }\n+    }\n+  }\n+  if (inline_klass == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ Check if cast nodes can be pushed through\n+  const Type* t = Type::get_const_type(inline_klass);\n+  while (casts.size() != 0 && t != nullptr) {\n+    Node* cast = casts.pop();\n+    if (t->filter(cast->bottom_type()) == Type::TOP) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+#ifdef ASSERT\n+bool PhiNode::can_push_inline_types_down(PhaseGVN* phase) {\n+  if (!can_be_inline_type()) {\n+    return false;\n+  }\n+\n+  ciInlineKlass* inline_klass;\n+  return can_push_inline_types_down(phase, true, inline_klass);\n+}\n+#endif \/\/ ASSERT\n+\n@@ -2994,0 +3161,6 @@\n+\n+  \/\/ CheckCastPPNode::Ideal() for inline types reuses the exception\n+  \/\/ paths of a call to perform an allocation: we can see a Phi here.\n+  if (in(1)->is_Phi()) {\n+    return this;\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":177,"deletions":4,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -185,0 +185,3 @@\n+  bool can_push_inline_types_down(PhaseGVN* phase, bool can_reshape, ciInlineKlass*& inline_klass);\n+  InlineTypeNode* push_inline_types_down(PhaseGVN* phase, bool can_reshape, ciInlineKlass* inline_klass);\n+\n@@ -258,0 +261,7 @@\n+  bool can_be_inline_type() const {\n+    return EnableValhalla && _type->isa_instptr() && _type->is_instptr()->can_be_inline_type();\n+  }\n+\n+  Node* try_push_inline_types_down(PhaseGVN* phase, bool can_reshape);\n+  DEBUG_ONLY(bool can_push_inline_types_down(PhaseGVN* phase);)\n+\n@@ -451,0 +461,2 @@\n+  bool is_flat_array_check(PhaseTransform* phase, Node** array = nullptr);\n+\n@@ -724,0 +736,1 @@\n+    init_class_id(Class_Blackhole);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -414,0 +415,75 @@\n+static void validate_array_arguments(Klass* elmClass, jint len, TRAPS) {\n+  if (len < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Array length is negative\");\n+  }\n+  elmClass->initialize(CHECK);\n+  if (elmClass->is_identity_class()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not a value class\");\n+  }\n+  if (elmClass->is_abstract()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is abstract\");\n+  }\n+}\n+\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedArray(JNIEnv *env, jclass elmClass, jint len))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  if (!vk->is_implicitly_constructible()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n+  }\n+  oop array = nullptr;\n+  if (vk->flat_array()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::NON_ATOMIC_FLAT, CHECK_NULL);\n+  } else {\n+    array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  if (!vk->is_implicitly_constructible()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n+  }\n+  oop array = nullptr;\n+  if (UseArrayFlattening && vk->has_atomic_layout()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::ATOMIC_FLAT, CHECK_NULL);\n+  } else if (UseArrayFlattening && vk->is_naturally_atomic()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::NON_ATOMIC_FLAT, CHECK_NULL);\n+  } else {\n+    array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullableAtomicArray(JNIEnv *env, jclass elmClass, jint len))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  oop array = nullptr;\n+  if (UseArrayFlattening && vk->has_nullable_atomic_layout()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::NULLABLE_ATOMIC_FLAT, CHECK_NULL);\n+  } else {\n+    array = oopFactory::new_objArray(vk, len, CHECK_NULL);\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsFlatArray(JNIEnv *env, jobject obj))\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  return oop->is_flatArray();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsNullRestrictedArray(JNIEnv *env, jobject obj))\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  return oop->is_null_free_array();\n+JVM_END\n@@ -622,2 +698,22 @@\n-  return handle == nullptr ? 0 :\n-         checked_cast<jint>(ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)));\n+  if (handle == nullptr) {\n+    return 0;\n+  }\n+  oop obj = JNIHandles::resolve_non_null(handle);\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+      JavaValue result(T_INT);\n+      JavaCallArguments args;\n+      Handle ho(THREAD, obj);\n+      args.push_oop(ho);\n+      methodHandle method(THREAD, Universe::value_object_hash_code_method());\n+      JavaCalls::call(&result, method, &args, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in hashCode\", e, false);\n+        }\n+      }\n+      return result.get_jint();\n+  } else {\n+    return checked_cast<jint>(ObjectSynchronizer::FastHashCode(THREAD, obj));\n+  }\n@@ -671,0 +767,6 @@\n+  if (klass->is_inline_klass()) {\n+    \/\/ Value instances have no identity, so return the current instance instead of allocating a new one\n+    \/\/ Value classes cannot have finalizers, so the method can return immediately\n+    return JNIHandles::make_local(THREAD, obj());\n+  }\n+\n@@ -1165,1 +1267,2 @@\n-    size = InstanceKlass::cast(klass)->local_interfaces()->length();\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    size = ik->local_interfaces()->length();\n@@ -1167,1 +1270,1 @@\n-    assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), \"Illegal mirror klass\");\n+    assert(klass->is_objArray_klass() || klass->is_typeArray_klass() || klass->is_flatArray_klass(), \"Illegal mirror klass\");\n@@ -1178,1 +1281,2 @@\n-      Klass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n+      InstanceKlass* ik = InstanceKlass::cast(klass);\n+      Klass* k = ik->local_interfaces()->at(index);\n@@ -1213,0 +1317,19 @@\n+JVM_ENTRY(jboolean, JVM_IsIdentityClass(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    return JNI_FALSE;\n+  }\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  if (EnableValhalla) {\n+    return k->is_array_klass() || k->is_identity_class();\n+  } else {\n+    return k->is_interface() ? JNI_FALSE : JNI_TRUE;\n+  }\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsImplicitlyConstructibleClass(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  return ik->is_implicitly_constructible();\n+JVM_END\n+\n@@ -1741,1 +1864,1 @@\n-    if (want_constructor && !method->is_object_initializer()) {\n+    if (want_constructor && !method->is_object_constructor()) {\n@@ -1745,1 +1868,1 @@\n-        (method->is_object_initializer() || method->is_static_initializer() ||\n+        (method->is_object_constructor() || method->is_class_initializer() ||\n@@ -1773,0 +1896,1 @@\n+        assert(method->is_object_constructor(), \"must be\");\n@@ -2055,1 +2179,1 @@\n-  if (m->is_object_initializer()) {\n+  if (m->is_object_constructor()) {\n@@ -2058,1 +2182,0 @@\n-    \/\/ new_method accepts <clinit> as Method here\n@@ -2330,0 +2453,37 @@\n+\/\/ Arrays support \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == nullptr) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  return ArrayKlass::cast(k)->element_access_must_be_atomic();\n+JVM_END\n+\n+JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))\n+  oop o = JNIHandles::resolve(array);\n+  Klass* k = o->klass();\n+  if ((o == nullptr) || (!k->is_array_klass())) {\n+    THROW_0(vmSymbols::java_lang_IllegalArgumentException());\n+  }\n+  if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vk = FlatArrayKlass::cast(k);\n+    if (!vk->element_access_must_be_atomic()) {\n+      \/**\n+       * Need to decide how to implement:\n+       *\n+       * 1) Change to objArrayOop layout, therefore oop->klass() differs so\n+       * then \"<atomic>[Qfoo;\" klass needs to subclass \"[Qfoo;\" to pass through\n+       * \"checkcast\" & \"instanceof\"\n+       *\n+       * 2) Use extra header in the flatArrayOop to flag atomicity required and\n+       * possibly per instance lock structure. Said info, could be placed in\n+       * \"trailer\" rather than disturb the current arrayOop\n+       *\/\n+      Unimplemented();\n+    }\n+  }\n+  return array;\n+JVM_END\n+\n@@ -2492,1 +2652,1 @@\n-  return method->name() == vmSymbols::object_initializer_name();\n+  return method->is_object_constructor();\n@@ -3283,0 +3443,4 @@\n+JVM_LEAF(jboolean, JVM_IsValhallaEnabled(void))\n+  return EnableValhalla ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n@@ -3362,1 +3526,1 @@\n-    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n+    objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3382,0 +3546,1 @@\n+  objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);\n@@ -3383,1 +3548,0 @@\n-  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":176,"deletions":12,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -132,13 +132,16 @@\n-  IS_METHOD            = java_lang_invoke_MemberName::MN_IS_METHOD,\n-  IS_CONSTRUCTOR       = java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR,\n-  IS_FIELD             = java_lang_invoke_MemberName::MN_IS_FIELD,\n-  IS_TYPE              = java_lang_invoke_MemberName::MN_IS_TYPE,\n-  CALLER_SENSITIVE     = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,\n-  TRUSTED_FINAL        = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,\n-  HIDDEN_MEMBER        = java_lang_invoke_MemberName::MN_HIDDEN_MEMBER,\n-  REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,\n-  REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,\n-  LM_UNCONDITIONAL     = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n-  LM_MODULE            = java_lang_invoke_MemberName::MN_MODULE_MODE,\n-  LM_TRUSTED           = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n-  ALL_KINDS      = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE\n+  IS_METHOD             = java_lang_invoke_MemberName::MN_IS_METHOD,\n+  IS_OBJECT_CONSTRUCTOR = java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR,\n+  IS_FIELD              = java_lang_invoke_MemberName::MN_IS_FIELD,\n+  IS_TYPE               = java_lang_invoke_MemberName::MN_IS_TYPE,\n+  CALLER_SENSITIVE      = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,\n+  TRUSTED_FINAL         = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,\n+  HIDDEN_MEMBER         = java_lang_invoke_MemberName::MN_HIDDEN_MEMBER,\n+  NULL_RESTRICTED       = java_lang_invoke_MemberName::MN_NULL_RESTRICTED_FIELD,\n+  REFERENCE_KIND_SHIFT  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,\n+  REFERENCE_KIND_MASK   = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,\n+  LAYOUT_SHIFT          = java_lang_invoke_MemberName::MN_LAYOUT_SHIFT,\n+  LAYOUT_MASK           = java_lang_invoke_MemberName::MN_LAYOUT_MASK,\n+  LM_UNCONDITIONAL      = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n+  LM_MODULE             = java_lang_invoke_MemberName::MN_MODULE_MODE,\n+  LM_TRUSTED            = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n+  ALL_KINDS      = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE\n@@ -155,1 +158,1 @@\n-    flags |= IS_CONSTRUCTOR;\n+    flags |= IS_OBJECT_CONSTRUCTOR;\n@@ -174,1 +177,1 @@\n-    case IS_CONSTRUCTOR:\n+    case IS_OBJECT_CONSTRUCTOR:\n@@ -315,1 +318,1 @@\n-      assert(!m->is_static_initializer(), \"Cannot be static initializer\");\n+      assert(!m->is_class_initializer(), \"Cannot be static initializer\");\n@@ -317,2 +320,2 @@\n-    } else if (m->is_object_initializer()) {\n-      flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial << REFERENCE_KIND_SHIFT);\n+    } else if (m->is_object_constructor()) {\n+      flags |= IS_OBJECT_CONSTRUCTOR | (JVM_REF_invokeSpecial << REFERENCE_KIND_SHIFT);\n@@ -357,0 +360,6 @@\n+  if (fd.is_flat()) {\n+    int layout_kind = fd.layout_kind();\n+    assert((layout_kind & LAYOUT_MASK) == layout_kind, \"Layout information loss\");\n+    flags |= layout_kind << LAYOUT_SHIFT;\n+  }\n+  if (fd.is_null_free_inline_type()) flags |= NULL_RESTRICTED;\n@@ -807,1 +816,1 @@\n-  case IS_CONSTRUCTOR:\n+  case IS_OBJECT_CONSTRUCTOR:\n@@ -813,1 +822,1 @@\n-        if (name == vmSymbols::object_initializer_name()) {\n+        if (name == vmSymbols::object_initializer_name() && type->is_void_method_signature()) {\n@@ -876,1 +885,1 @@\n-  case IS_CONSTRUCTOR:\n+  case IS_OBJECT_CONSTRUCTOR:\n@@ -990,1 +999,1 @@\n-    template(java_lang_invoke_MemberName,MN_IS_CONSTRUCTOR) \\\n+    template(java_lang_invoke_MemberName,MN_IS_OBJECT_CONSTRUCTOR) \\\n@@ -998,0 +1007,2 @@\n+    template(java_lang_invoke_MemberName,MN_LAYOUT_SHIFT) \\\n+    template(java_lang_invoke_MemberName,MN_LAYOUT_MASK) \\\n@@ -1133,1 +1144,1 @@\n-               (flags & ALL_KINDS) == IS_CONSTRUCTOR) {\n+               (flags & ALL_KINDS) == IS_OBJECT_CONSTRUCTOR) {\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"oops\/access.hpp\"\n@@ -63,0 +65,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -70,0 +73,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -88,0 +92,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1934,0 +1939,103 @@\n+WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))\n+  oop aoop = JNIHandles::resolve(thing);\n+  if (!aoop->is_instance()) {\n+    return nullptr;\n+  }\n+  instanceHandle ih(THREAD, (instanceOop) aoop);\n+  InstanceKlass* klass = InstanceKlass::cast(ih->klass());\n+  if (klass->nonstatic_oop_map_count() == 0) {\n+    return nullptr;\n+  }\n+  const OopMapBlock* map = klass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* const end = map + klass->nonstatic_oop_map_count();\n+  int oop_count = 0;\n+  while (map < end) {\n+    oop_count += map->count();\n+    map++;\n+  }\n+\n+  objArrayHandle result_array =\n+      oopFactory::new_objArray_handle(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n+  map = klass->start_of_nonstatic_oop_maps();\n+  int index = 0;\n+  while (map < end) {\n+    int offset = map->offset();\n+    for (unsigned int j = 0; j < map->count(); j++) {\n+      result_array->obj_at_put(index++, ih->obj_field(offset));\n+      offset += heapOopSize;\n+    }\n+    map++;\n+  }\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+WB_END\n+\n+\/\/ Collect Object oops but not value objects...loaded from heap\n+class CollectObjectOops : public BasicOopIterateClosure {\n+  public:\n+  GrowableArray<Handle>* _array;\n+\n+  CollectObjectOops() {\n+      _array = new GrowableArray<Handle>(128);\n+  }\n+\n+  void add_oop(oop o) {\n+    Handle oh = Handle(Thread::current(), o);\n+    if (oh != nullptr && oh->is_inline_type()) {\n+      oh->oop_iterate(this);\n+    } else {\n+      _array->append(oh);\n+    }\n+  }\n+\n+  template <class T> inline void add_oop(T* p) { add_oop(HeapAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    objArrayHandle result_array =\n+        oopFactory::new_objArray_handle(vmClasses::Object_klass(), _array->length(), CHECK_NULL);\n+    for (int i = 0 ; i < _array->length(); i++) {\n+      result_array->obj_at_put(i, _array->at(i)());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+  }\n+};\n+\n+\/\/ Collect Object oops but not value objects...loaded from frames\n+class CollectFrameObjectOops : public BasicOopIterateClosure {\n+ public:\n+  CollectObjectOops _collect;\n+\n+  template <class T> inline void add_oop(T* p) { _collect.add_oop(RawAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    return _collect.create_jni_result(env, THREAD);\n+  }\n+};\n+\n+\/\/ Collect Object oops for the given oop, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))\n+  ResourceMark rm(thread);\n+  Handle objh(thread, JNIHandles::resolve(thing));\n+  CollectObjectOops collectOops;\n+  objh->oop_iterate(&collectOops);\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+\/\/ Collect Object oops for the given frame deep, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))\n+  KeepStackGCProcessedMark ksgcpm(THREAD);\n+  ResourceMark rm(THREAD);\n+  CollectFrameObjectOops collectOops;\n+  StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n+  while (depth > 0) { \/\/ Skip the native WB API frame\n+    sfs.next();\n+    frame* f = sfs.current();\n+    f->oops_do(&collectOops, nullptr, sfs.register_map());\n+    depth--;\n+  }\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n@@ -2903,0 +3011,6 @@\n+  {CC\"getObjectsViaKlassOopMaps0\",\n+      CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",    (void*)&WB_getObjectsViaKlassOopMaps},\n+  {CC\"getObjectsViaOopIterator0\",\n+          CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",(void*)&WB_getObjectsViaOopIterator},\n+  {CC\"getObjectsViaFrameOopIterator\",\n+      CC\"(I)[Ljava\/lang\/Object;\",                     (void*)&WB_getObjectsViaFrameOopIterator},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include <string.h>\n@@ -1768,1 +1769,0 @@\n-static unsigned int patch_mod_count = 0;\n@@ -1775,1 +1775,1 @@\n-  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n+  if (!CDSConfig::check_vm_args_consistency(mode_flag_cmd_line)) {\n@@ -2074,1 +2074,1 @@\n-      add_patch_mod_prefix(module_name, module_equal + 1);\n+      add_patch_mod_prefix(module_name, module_equal + 1, false \/* no append *\/, false \/* no cds *\/);\n@@ -2076,3 +2076,0 @@\n-      if (!create_numbered_module_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n-        return JNI_ENOMEM;\n-      }\n@@ -2086,0 +2083,64 @@\n+\/\/ VALUECLASS_STR must match string used in the build\n+#define VALUECLASS_STR \"valueclasses\"\n+#define VALUECLASS_JAR \"-\" VALUECLASS_STR \".jar\"\n+\n+\/\/ Finalize --patch-module args and --enable-preview related to value class module patches.\n+\/\/ Create all numbered properties passing module patches.\n+int Arguments::finalize_patch_module() {\n+  \/\/ If --enable-preview and EnableValhalla is true, each module may have value classes that\n+  \/\/ are to be patched into the module.\n+  \/\/ For each <module>-valueclasses.jar in <JAVA_HOME>\/lib\/valueclasses\/\n+  \/\/ appends the equivalent of --patch-module <module>=<JAVA_HOME>\/lib\/valueclasses\/<module>-valueclasses.jar\n+  if (enable_preview() && EnableValhalla) {\n+    char * valueclasses_dir = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+    const char * fileSep = os::file_separator();\n+\n+    jio_snprintf(valueclasses_dir, JVM_MAXPATHLEN, \"%s%slib%s\" VALUECLASS_STR \"%s\",\n+                 Arguments::get_java_home(), fileSep, fileSep, fileSep);\n+    DIR* dir = os::opendir(valueclasses_dir);\n+    if (dir != nullptr) {\n+      char * module_name = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+      char * path = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+\n+      for (dirent * entry = os::readdir(dir); entry != nullptr; entry = os::readdir(dir)) {\n+        \/\/ Test if file ends-with \"-valueclasses.jar\"\n+        int len = (int)strlen(entry->d_name) - (sizeof(VALUECLASS_JAR) - 1);\n+        if (len <= 0 || strcmp(&entry->d_name[len], VALUECLASS_JAR) != 0) {\n+          continue;         \/\/ too short or not the expected suffix\n+        }\n+\n+        strcpy(module_name, entry->d_name);\n+        module_name[len] = '\\0';     \/\/ truncate to just module-name\n+\n+        jio_snprintf(path, JVM_MAXPATHLEN, \"%s%s\", valueclasses_dir, &entry->d_name);\n+        add_patch_mod_prefix(module_name, path, true \/* append *\/, true \/* cds OK*\/);\n+        log_info(class)(\"--enable-preview appending value classes for module %s: %s\", module_name, entry->d_name);\n+      }\n+      FreeHeap(module_name);\n+      FreeHeap(path);\n+      os::closedir(dir);\n+    }\n+    FreeHeap(valueclasses_dir);\n+  }\n+\n+  \/\/ Create numbered properties for each module that has been patched either\n+  \/\/ by --patch-module or --enable-preview\n+  \/\/ Format is \"jdk.module.patch.<n>=<module_name>=<path>\"\n+  if (_patch_mod_prefix != nullptr) {\n+    char * prop_value = AllocateHeap(JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, mtArguments);\n+    unsigned int patch_mod_count = 0;\n+\n+    for (GrowableArrayIterator<ModulePatchPath *> it = _patch_mod_prefix->begin();\n+            it != _patch_mod_prefix->end(); ++it) {\n+      jio_snprintf(prop_value, JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, \"%s=%s\",\n+                   (*it)->module_name(), (*it)->path_string());\n+      if (!create_numbered_module_property(\"jdk.module.patch\", prop_value, patch_mod_count++)) {\n+        FreeHeap(prop_value);\n+        return JNI_ENOMEM;\n+      }\n+    }\n+    FreeHeap(prop_value);\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -2341,0 +2402,4 @@\n+      \/\/ --enable-preview enables Valhalla, EnableValhalla VM option will eventually be removed before integration\n+      if (FLAG_SET_CMDLINE(EnableValhalla, true) != JVMFlag::SUCCESS) {\n+        return JNI_EINVAL;\n+      }\n@@ -2820,10 +2885,5 @@\n-void Arguments::add_patch_mod_prefix(const char* module_name, const char* path) {\n-  \/\/ For java.base check for duplicate --patch-module options being specified on the command line.\n-  \/\/ This check is only required for java.base, all other duplicate module specifications\n-  \/\/ will be checked during module system initialization.  The module system initialization\n-  \/\/ will throw an ExceptionInInitializerError if this situation occurs.\n-  if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n-    if (patch_mod_javabase) {\n-      vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n-    } else {\n-      patch_mod_javabase = true;\n+void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool allow_append, bool allow_cds) {\n+  if (!allow_cds) {\n+    CDSConfig::set_module_patching_disables_cds();\n+    if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+      CDSConfig::set_java_base_module_patching_disables_cds();\n@@ -2838,1 +2898,18 @@\n-  _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  \/\/ Scan patches for matching module\n+  int i = _patch_mod_prefix->find_if([&](ModulePatchPath* patch) {\n+    return (strcmp(module_name, patch->module_name()) == 0);\n+  });\n+  if (i == -1) {\n+    _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  } else {\n+    if (allow_append) {\n+      \/\/ append path to existing module entry\n+      _patch_mod_prefix->at(i)->append_path(path);\n+    } else {\n+      if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+        vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n+      } else {\n+        vm_exit_during_initialization(\"Cannot specify a module more than once to --patch-module\", module_name);\n+      }\n+    }\n+  }\n@@ -2951,1 +3028,2 @@\n-  if (!check_vm_args_consistency()) {\n+  \/\/ finalize --module-patch and related --enable-preview\n+  if (finalize_patch_module() != JNI_OK) {\n@@ -2955,0 +3033,3 @@\n+  if (!check_vm_args_consistency()) {\n+    return JNI_ERR;\n+  }\n@@ -3756,0 +3837,7 @@\n+  if (!EnableValhalla || (is_interpreter_only() && !CDSConfig::is_dumping_archive() && !UseSharedSpaces)) {\n+    \/\/ Disable calling convention optimizations if inline types are not supported.\n+    \/\/ Also these aren't useful in -Xint. However, don't disable them when dumping or using\n+    \/\/ the CDS archive, as the values must match between dumptime and runtime.\n+    InlineTypePassFieldsAsArgs = false;\n+    InlineTypeReturnedAsFields = false;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":106,"deletions":18,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  inline void append_path(const char* path) { _path->append_value(path); }\n@@ -479,1 +480,2 @@\n-  static void add_patch_mod_prefix(const char *module_name, const char *path);\n+  static void add_patch_mod_prefix(const char *module_name, const char *path, bool allow_append, bool allow_cds);\n+  static int finalize_patch_module();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+  do_blob(new_null_free_array)                                         \\\n@@ -96,0 +97,5 @@\n+  do_blob(load_flat_array)                                             \\\n+  do_blob(store_flat_array)                                            \\\n+  do_blob(substitutability_check)                                      \\\n+  do_blob(buffer_inline_args)                                          \\\n+  do_blob(buffer_inline_args_no_receiver)                              \\\n@@ -102,0 +108,2 @@\n+  do_blob(throw_illegal_monitor_state_exception)                       \\\n+  do_blob(throw_identity_exception)                                    \\\n@@ -169,0 +177,2 @@\n+  do_stub(load_unknown_inline, 0, true, false)                         \\\n+  do_stub(store_unknown_inline, 0, true, false)                        \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -184,0 +184,5 @@\n+\/\/ TODO: update with 8343767\n+address StubRoutines::_load_inline_type_fields_in_regs = nullptr;\n+address StubRoutines::_store_inline_type_fields_to_buf = nullptr;\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -277,0 +277,3 @@\n+  static address _load_inline_type_fields_in_regs;\n+  static address _store_inline_type_fields_to_buf;\n+\n@@ -413,0 +416,3 @@\n+  static address load_inline_type_fields_in_regs() { return _load_inline_type_fields_in_regs; }\n+  static address store_inline_type_fields_to_buf() { return _store_inline_type_fields_to_buf; }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -315,0 +315,16 @@\n+\/\/ These checks are required for wait, notify and exit to avoid inflating the monitor to\n+\/\/ find out this inline type object cannot be locked.\n+#define CHECK_THROW_NOSYNC_IMSE(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;           \\\n+    ResourceMark rm(THREAD);                \\\n+    THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n+#define CHECK_THROW_NOSYNC_IMSE_0(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;             \\\n+    ResourceMark rm(THREAD);                  \\\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n@@ -341,0 +357,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -405,0 +422,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -524,0 +542,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"JITed code should never have locked an instance of a value class\");\n@@ -546,0 +565,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"This method should never be called on an instance of an inline class\");\n@@ -565,0 +585,1 @@\n+  guarantee(!EnableValhalla || !obj->klass()->is_inline_klass(), \"Attempt to inflate inline type\");\n@@ -612,0 +633,3 @@\n+    if (EnableValhalla && mark.is_inline_type()) {\n+      return;\n+    }\n@@ -668,0 +692,1 @@\n+  JavaThread* THREAD = current;\n@@ -676,0 +701,10 @@\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    const char* desc = \"Cannot synchronize on an instance of value class \";\n+    const char* className = obj->klass()->external_name();\n+    size_t msglen = strlen(desc) + strlen(className) + 1;\n+    char* message = NEW_RESOURCE_ARRAY(char, msglen);\n+    assert(message != nullptr, \"NEW_RESOURCE_ARRAY should have called vm_exit_out_of_memory and not return nullptr\");\n+    THROW_MSG(vmSymbols::java_lang_IdentityException(), className);\n+  }\n+\n@@ -702,0 +737,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -746,0 +782,1 @@\n+  CHECK_THROW_NOSYNC_IMSE_0(obj);\n@@ -788,0 +825,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -816,0 +854,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -997,0 +1036,4 @@\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+    \/\/ VM should be calling bootstrap method\n+    ShouldNotReachHere();\n+  }\n@@ -1123,0 +1166,3 @@\n+  if (EnableValhalla && h_obj->mark().is_inline_type()) {\n+    return false;\n+  }\n@@ -1454,0 +1500,3 @@\n+  if (EnableValhalla) {\n+    guarantee(!object->klass()->is_inline_klass(), \"Attempt to inflate inline type\");\n+  }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -88,9 +88,12 @@\n-            MN_IS_METHOD           = 0x00010000, \/\/ method (not constructor)\n-            MN_IS_CONSTRUCTOR      = 0x00020000, \/\/ constructor\n-            MN_IS_FIELD            = 0x00040000, \/\/ field\n-            MN_IS_TYPE             = 0x00080000, \/\/ nested type\n-            MN_CALLER_SENSITIVE    = 0x00100000, \/\/ @CallerSensitive annotation detected\n-            MN_TRUSTED_FINAL       = 0x00200000, \/\/ trusted final field\n-            MN_HIDDEN_MEMBER       = 0x00400000, \/\/ members defined in a hidden class or with @Hidden\n-            MN_REFERENCE_KIND_SHIFT = 24, \/\/ refKind\n-            MN_REFERENCE_KIND_MASK = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT;\n+            MN_IS_METHOD             = 0x00010000, \/\/ method (not object constructor)\n+            MN_IS_CONSTRUCTOR        = 0x00020000, \/\/ object constructor\n+            MN_IS_FIELD              = 0x00040000, \/\/ field\n+            MN_IS_TYPE               = 0x00080000, \/\/ nested type\n+            MN_CALLER_SENSITIVE      = 0x00100000, \/\/ @CallerSensitive annotation detected\n+            MN_TRUSTED_FINAL         = 0x00200000, \/\/ trusted final field\n+            MN_HIDDEN_MEMBER         = 0x00400000, \/\/ members defined in a hidden class or with @Hidden\n+            MN_NULL_RESTRICTED       = 0x00800000, \/\/ null-restricted field\n+            MN_REFERENCE_KIND_SHIFT  = 24, \/\/ refKind\n+            MN_REFERENCE_KIND_MASK   = 0x0F000000 >>> MN_REFERENCE_KIND_SHIFT, \/\/ 4 bits\n+            MN_LAYOUT_SHIFT          = 28, \/\/ field layout\n+            MN_LAYOUT_MASK           = 0x70000000 >>> MN_LAYOUT_SHIFT;  \/\/ 3 bits\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -52,3 +52,10 @@\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)\n-                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type));\n+                if (f.isFlat()) {\n+                    int layout = f.getLayout();\n+                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                        ? new VarHandleFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType(), layout)\n+                        : new VarHandleFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType(), layout));\n+                } else {\n+                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                       ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n+                       : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n+                }\n@@ -114,3 +121,11 @@\n-            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                    ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n-                    : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type));\n+            if (f.isFlat()) {\n+                assert false : (\"static field is flat in \" + decl + \".\" + f.getName());\n+                int layout = f.getLayout();\n+                return f.isFinal() && !isWriteAllowedOnFinalFields\n+                        ? new VarHandleFlatValues.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType(), layout)\n+                        : new VarHandleFlatValues.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType(), layout);\n+            } else {\n+                return f.isFinal() && !isWriteAllowedOnFinalFields\n+                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n+                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType());\n+            }\n@@ -204,1 +219,8 @@\n-            return maybeAdapt(new VarHandleReferences.Array(aoffset, ashift, arrayClass));\n+            VarHandle vh;\n+            if (UNSAFE.isFlatArray(arrayClass)) {\n+                int layout = UNSAFE.arrayLayout(arrayClass);\n+                vh = new VarHandleFlatValues.Array(aoffset, ashift, arrayClass, layout);\n+            } else {\n+                vh = new VarHandleReferences.Array(aoffset, ashift, arrayClass);\n+            }\n+            return maybeAdapt(vh);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,5 @@\n+#if[Object]\n+import jdk.internal.value.CheckedType;\n+import jdk.internal.value.NullRestrictedCheckedType;\n+import jdk.internal.value.ValueClass;\n+#end[Object]\n@@ -45,0 +50,1 @@\n+        final CheckedType checkedFieldType;\n@@ -46,0 +52,3 @@\n+#if[FlatValue]\n+        final int layout; \/\/ Unsafe.fieldLayout\n+#end[FlatValue]\n@@ -47,2 +56,2 @@\n-        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM, false);\n+        FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldInstanceReadOnly.FORM, false);\n@@ -51,1 +60,1 @@\n-        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        protected FieldInstanceReadOnly(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n@@ -58,0 +67,1 @@\n+            this.checkedFieldType = checkedFieldType;\n@@ -59,0 +69,3 @@\n+#if[FlatValue]\n+            this.layout = layout;\n+#end[FlatValue]\n@@ -65,1 +78,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, true);\n@@ -72,1 +85,1 @@\n-                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+                : new FieldInstanceReadOnly(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, false);\n@@ -96,2 +109,3 @@\n-            return UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -103,2 +117,3 @@\n-            return UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -110,2 +125,3 @@\n-            return UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -117,2 +133,3 @@\n-            return UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -125,3 +142,2 @@\n-\n-        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n+        FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n+            this(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n@@ -130,1 +146,1 @@\n-        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        private FieldInstanceReadWrite(Class<?> receiverType, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n@@ -132,1 +148,1 @@\n-            super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM, exact);\n+            super(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldInstanceReadWrite.FORM, exact);\n@@ -139,1 +155,1 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, true);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, true);\n@@ -146,1 +162,7 @@\n-                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType}, false);\n+                : new FieldInstanceReadWrite(receiverType, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n+        }\n+\n+#if[Object]\n+        @ForceInline\n+        static Object checkCast(FieldInstanceReadWrite handle, $type$ value) {\n+            return handle.checkedFieldType.cast(value);\n@@ -148,0 +170,1 @@\n+#end[Object]\n@@ -153,2 +176,2 @@\n-                             handle.fieldOffset,\n-                             {#if[Object]?handle.fieldType.cast(value):value});\n+                             handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                             {#if[Object]?checkCast(handle, value):value});\n@@ -161,2 +184,2 @@\n-                                     handle.fieldOffset,\n-                                     {#if[Object]?handle.fieldType.cast(value):value});\n+                                     handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                     {#if[Object]?checkCast(handle, value):value});\n@@ -169,2 +192,2 @@\n-                                   handle.fieldOffset,\n-                                   {#if[Object]?handle.fieldType.cast(value):value});\n+                                   handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                   {#if[Object]?checkCast(handle, value):value});\n@@ -177,2 +200,2 @@\n-                                    handle.fieldOffset,\n-                                    {#if[Object]?handle.fieldType.cast(value):value});\n+                                    handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                    {#if[Object]?checkCast(handle, value):value});\n@@ -186,3 +209,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -195,3 +218,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -204,3 +227,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -213,3 +236,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -222,3 +245,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -231,3 +254,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -240,3 +263,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -249,3 +272,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -258,2 +281,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -266,2 +289,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -274,2 +297,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -390,0 +413,1 @@\n+        final CheckedType checkedFieldType;\n@@ -391,0 +415,3 @@\n+#if[FlatValue]\n+        final int layout;\n+#end[FlatValue]\n@@ -392,2 +419,2 @@\n-        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n+        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldStaticReadOnly.FORM, false);\n@@ -396,1 +423,1 @@\n-        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n@@ -404,0 +431,1 @@\n+            this.checkedFieldType = checkedFieldType;\n@@ -405,0 +433,3 @@\n+#if[FlatValue]\n+            this.layout = layout;\n+#end[FlatValue]\n@@ -411,1 +442,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, true);\n@@ -418,1 +449,1 @@\n-                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, vform, false);\n@@ -444,2 +475,3 @@\n-            return UNSAFE.get$Type$(handle.base,\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$(handle.base,\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -451,2 +483,3 @@\n-            return UNSAFE.get$Type$Volatile(handle.base,\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$Volatile(handle.base,\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -458,2 +491,3 @@\n-            return UNSAFE.get$Type$Opaque(handle.base,\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$Opaque(handle.base,\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -465,2 +499,3 @@\n-            return UNSAFE.get$Type$Acquire(handle.base,\n-                                 handle.fieldOffset);\n+            $type$ value = UNSAFE.get$Type$Acquire(handle.base,\n+                                 handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType});\n+            return value;\n@@ -474,2 +509,2 @@\n-        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n+        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n@@ -478,1 +513,1 @@\n-        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType, CheckedType checkedFieldType}{#if[FlatValue]?, int layout},\n@@ -480,1 +515,1 @@\n-            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n+            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, FieldStaticReadWrite.FORM, exact);\n@@ -487,1 +522,1 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, true);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, true);\n@@ -494,1 +529,7 @@\n-                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType, checkedFieldType}{#if[FlatValue]?, layout}, false);\n+        }\n+\n+#if[Object]\n+        @ForceInline\n+        static Object checkCast(FieldStaticReadWrite handle, $type$ value) {\n+            return handle.checkedFieldType.cast(value);\n@@ -496,0 +537,1 @@\n+#end[Object]\n@@ -501,2 +543,2 @@\n-                             handle.fieldOffset,\n-                             {#if[Object]?handle.fieldType.cast(value):value});\n+                             handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                             {#if[Object]?checkCast(handle, value):value});\n@@ -509,2 +551,2 @@\n-                                     handle.fieldOffset,\n-                                     {#if[Object]?handle.fieldType.cast(value):value});\n+                                     handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                     {#if[Object]?checkCast(handle, value):value});\n@@ -517,2 +559,2 @@\n-                                   handle.fieldOffset,\n-                                   {#if[Object]?handle.fieldType.cast(value):value});\n+                                   handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                   {#if[Object]?checkCast(handle, value):value});\n@@ -525,2 +567,2 @@\n-                                    handle.fieldOffset,\n-                                    {#if[Object]?handle.fieldType.cast(value):value});\n+                                    handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                    {#if[Object]?checkCast(handle, value):value});\n@@ -534,3 +576,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -544,3 +586,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -553,3 +595,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -562,3 +604,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -571,3 +613,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -580,3 +622,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -589,3 +631,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -598,3 +640,3 @@\n-                                               handle.fieldOffset,\n-                                               {#if[Object]?handle.fieldType.cast(expected):expected},\n-                                               {#if[Object]?handle.fieldType.cast(value):value});\n+                                               handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n+                                               {#if[Object]?checkCast(handle, expected):expected},\n+                                               {#if[Object]?checkCast(handle, value):value});\n@@ -607,2 +649,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -615,2 +657,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -623,2 +665,2 @@\n-                                          handle.fieldOffset,\n-                                          {#if[Object]?handle.fieldType.cast(value):value});\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          {#if[Object]?checkCast(handle, value):value});\n@@ -731,1 +773,0 @@\n-\n@@ -739,0 +780,3 @@\n+#if[FlatValue]\n+        final int layout;\n+#end[FlatValue]\n@@ -740,2 +784,2 @@\n-        Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}) {\n-            this(abase, ashift{#if[Object]?, arrayType}, false);\n+        Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}{#if[FlatValue]?, int layout}) {\n+            this(abase, ashift{#if[Object]?, arrayType}{#if[FlatValue]?, layout}, false);\n@@ -744,1 +788,1 @@\n-        private Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}, boolean exact) {\n+        private Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}{#if[FlatValue]?, int layout}, boolean exact) {\n@@ -752,0 +796,3 @@\n+#if[FlatValue]\n+            this.layout = layout;\n+#end[FlatValue]\n@@ -758,1 +805,1 @@\n-                : new Array(abase, ashift{#if[Object]?, arrayType}, true);\n+                : new Array(abase, ashift{#if[Object]?, arrayType}{#if[FlatValue]?, layout}, true);\n@@ -765,1 +812,1 @@\n-                : new Array(abase, ashift{#if[Object]?, arrayType}, false);\n+                : new Array(abase, ashift{#if[Object]?, arrayType}{#if[FlatValue]?, layout}, false);\n@@ -779,1 +826,1 @@\n-            return at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?arrayType.getComponentType():$type$.class}, int.class);\n+            return at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?componentType:$type$.class}, int.class);\n@@ -787,1 +834,1 @@\n-                return handle.componentType.cast(value);\n+                return {#if[FlatValue]?ValueClass.componentCheckedType(oarray):handle.componentType}.cast(value);\n@@ -789,1 +836,1 @@\n-                \/\/ Slow path: check value against argument array component type\n+                \/\/ Slow path: check value against argument array component checked type\n@@ -797,1 +844,1 @@\n-                return oarray.getClass().getComponentType().cast(value);\n+                return ValueClass.componentCheckedType(oarray).cast(value);\n@@ -823,1 +870,10 @@\n-            array[index] = {#if[Object]?handle.componentType.cast(value):value};\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                vh.set(oarray, index, value);\n+                return;\n+            }\n+#end[Reference]\n+            array[index] = {#if[Object]?runtimeTypeCheck(handle, array, value):value};\n@@ -834,0 +890,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.getVolatile(oarray, index);\n+            }\n+#end[Reference]\n@@ -835,1 +899,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType});\n@@ -846,0 +910,9 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                vh.setVolatile(oarray, index, value);\n+                return;\n+            }\n+#end[Reference]\n@@ -847,1 +920,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n@@ -859,0 +932,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.getOpaque(oarray, index);\n+            }\n+#end[Reference]\n@@ -860,1 +941,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType});\n@@ -871,0 +952,9 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                vh.setOpaque(oarray, index, value);\n+                return;\n+            }\n+#end[Reference]\n@@ -872,1 +962,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n@@ -884,0 +974,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.getAcquire(oarray, index);\n+            }\n+#end[Reference]\n@@ -885,1 +983,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType});\n@@ -896,0 +994,9 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                vh.setRelease(oarray, index, value);\n+                return;\n+            }\n+#end[Reference]\n@@ -897,1 +1004,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n@@ -910,0 +1017,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndSet(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -911,1 +1026,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -924,0 +1039,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndExchange(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -925,1 +1048,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -938,0 +1061,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndExchangeAcquire(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -939,1 +1070,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -952,0 +1083,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.compareAndExchangeRelease(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -953,1 +1092,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -966,0 +1105,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSetPlain(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -967,1 +1114,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -980,0 +1127,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSet(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -981,1 +1136,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -994,0 +1149,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSetAcquire(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -995,1 +1158,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -1008,0 +1171,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.weakCompareAndSetRelease(oarray, index, expected, value);\n+            }\n+#end[Reference]\n@@ -1009,1 +1180,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n@@ -1022,0 +1193,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.getAndSet(oarray, index, value);\n+            }\n+#end[Reference]\n@@ -1023,1 +1202,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n@@ -1035,0 +1214,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.getAndSetAcquire(oarray, index, value);\n+            }\n+#end[Reference]\n@@ -1036,1 +1223,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n@@ -1048,0 +1235,8 @@\n+#if[Reference]\n+            Class<?> arrayType = oarray.getClass();\n+            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n+                \/\/ delegate to VarHandle of flat array\n+                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n+                return vh.getAndSetRelease(oarray, index, value);\n+            }\n+#end[Reference]\n@@ -1049,1 +1244,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n@@ -1165,1 +1360,0 @@\n-\n@@ -1168,0 +1362,15 @@\n+#if[FlatValue]\n+    static final ClassValue<Array> flatArrayVarHandles = new ClassValue<>() {\n+        @Override protected Array computeValue(Class<?> arrayClass) {\n+            assert UNSAFE.isFlatArray(arrayClass);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(arrayClass);\n+            int ascale = UNSAFE.arrayIndexScale(arrayClass);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(arrayClass);\n+            return new Array(aoffset, ashift, arrayClass, layout);\n+        }\n+    };\n+    static VarHandle flatArrayVarHandle(Class<?> arrayClass) {\n+        return flatArrayVarHandles.get(arrayClass);\n+    }\n+#end[FlatValue]\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":354,"deletions":145,"binary":false,"changes":499,"status":"modified"},{"patch":"@@ -185,0 +185,83 @@\n+\n+    \/**\n+     * Returns true if the given field is flattened.\n+     *\/\n+    public boolean isFlatField(Field f) {\n+        if (f == null) {\n+            throw new NullPointerException();\n+        }\n+        return isFlatField0(f);\n+    }\n+\n+    private native boolean isFlatField0(Object o);\n+\n+    \/* Returns true if the given field has a null marker\n+     * <p>\n+     * Nullable flat fields are stored in a flattened representation\n+     * and have an associated null marker to indicate if the the field value is\n+     * null or the one stored with the flat representation\n+     *\/\n+\n+    public boolean hasNullMarker(Field f) {\n+        if (f == null) {\n+            throw new NullPointerException();\n+        }\n+        return hasNullMarker0(f);\n+    }\n+\n+    private native boolean hasNullMarker0(Object o);\n+\n+    \/* Returns the offset of the null marker of the field,\n+    * or -1 if the field doesn't have a null marker\n+    *\/\n+\n+    public int nullMarkerOffset(Field f) {\n+        if (f == null) {\n+            throw new NullPointerException();\n+        }\n+        return nullMarkerOffset0(f);\n+    }\n+\n+    private native int nullMarkerOffset0(Object o);\n+\n+    public static final int NON_FLAT_LAYOUT = 0;\n+\n+    \/* Reports the kind of layout used for an element in the storage\n+     * allocation of the given array. Do not expect to perform any logic\n+     * or layout control with this value, it is just an opaque token\n+     * used for performance reasons.\n+     *\n+     * A layout of 0 indicates this array is not flat.\n+     *\/\n+    public int arrayLayout(Class<?> arrayClass) {\n+        if (arrayClass == null) {\n+            throw new NullPointerException();\n+        }\n+        return arrayLayout0(arrayClass);\n+    }\n+\n+    private native int arrayLayout0(Object o);\n+\n+\n+    \/* Reports the kind of layout used for a given field in the storage\n+     * allocation of its class.  Do not expect to perform any logic\n+     * or layout control with this value, it is just an opaque token\n+     * used for performance reasons.\n+     *\n+     * A layout of 0 indicates this field is not flat.\n+     *\/\n+    public int fieldLayout(Field f) {\n+        if (f == null) {\n+            throw new NullPointerException();\n+        }\n+        return fieldLayout0(f);\n+    }\n+\n+    private native int fieldLayout0(Object o);\n+\n+    \/**\n+     * Returns true if the given class is a flattened array.\n+     *\/\n+    @IntrinsicCandidate\n+    public native boolean isFlatArray(Class<?> arrayClass);\n+\n@@ -187,0 +270,3 @@\n+     * This method can return a reference to either an object or value\n+     * or a null reference.\n+     *\n@@ -194,0 +280,2 @@\n+     * This method can store a reference to either an object or value\n+     * or a null reference.\n@@ -205,0 +293,113 @@\n+    \/**\n+     * Fetches a value of type {@code <V>} from a given Java variable.\n+     * More specifically, fetches a field or array element within the given\n+     * {@code o} object at the given offset, or (if {@code o} is null)\n+     * from the memory address whose numerical value is the given offset.\n+     *\n+     * @param o Java heap object in which the variable resides, if any, else\n+     *        null\n+     * @param offset indication of where the variable resides in a Java heap\n+     *        object, if any, else a memory address locating the variable\n+     *        statically\n+     * @param valueType value type\n+     * @param <V> the type of a value\n+     * @return the value fetched from the indicated Java variable\n+     * @throws RuntimeException No defined exceptions are thrown, not even\n+     *         {@link NullPointerException}\n+     *\/\n+    @IntrinsicCandidate\n+    public native <V> V getValue(Object o, long offset, Class<?> valueType);\n+\n+    \/**\n+     * Fetches a value of type {@code <V>} from a given Java variable.\n+     * More specifically, fetches a field or array element within the given\n+     * {@code o} object at the given offset, or (if {@code o} is null)\n+     * from the memory address whose numerical value is the given offset.\n+     *\n+     * @param o Java heap object in which the variable resides, if any, else\n+     *        null\n+     * @param offset indication of where the variable resides in a Java heap\n+     *        object, if any, else a memory address locating the variable\n+     *        statically\n+     * @param layoutKind opaque value used by the VM to know the layout\n+     *        the field or array element. This value must be retrieved with\n+     *        {@link #fieldLayout} or {@link #arrayLayout}.\n+     * @param valueType value type\n+     * @param <V> the type of a value\n+     * @return the value fetched from the indicated Java variable\n+     * @throws RuntimeException No defined exceptions are thrown, not even\n+     *         {@link NullPointerException}\n+     *\/\n+    public native <V> V getFlatValue(Object o, long offset, int layoutKind, Class<?> valueType);\n+\n+\n+    \/**\n+     * Stores the given value into a given Java variable.\n+     *\n+     * Unless the reference {@code o} being stored is either null\n+     * or matches the field type, the results are undefined.\n+     *\n+     * @param o Java heap object in which the variable resides, if any, else\n+     *        null\n+     * @param offset indication of where the variable resides in a Java heap\n+     *        object, if any, else a memory address locating the variable\n+     *        statically\n+     * @param valueType value type\n+     * @param v the value to store into the indicated Java variable\n+     * @param <V> the type of a value\n+     * @throws RuntimeException No defined exceptions are thrown, not even\n+     *         {@link NullPointerException}\n+     *\/\n+    @IntrinsicCandidate\n+    public native <V> void putValue(Object o, long offset, Class<?> valueType, V v);\n+\n+    \/**\n+     * Stores the given value into a given Java variable.\n+     *\n+     * Unless the reference {@code o} being stored is either null\n+     * or matches the field type, the results are undefined.\n+     *\n+     * @param o Java heap object in which the variable resides, if any, else\n+     *        null\n+     * @param offset indication of where the variable resides in a Java heap\n+     *        object, if any, else a memory address locating the variable\n+     *        statically\n+     * @param layoutKind opaque value used by the VM to know the layout\n+     *        the field or array element. This value must be retrieved with\n+     *        {@link #fieldLayout} or {@link #arrayLayout}.\n+     * @param valueType value type\n+     * @param v the value to store into the indicated Java variable\n+     * @param <V> the type of a value\n+     * @throws RuntimeException No defined exceptions are thrown, not even\n+     *         {@link NullPointerException}\n+     *\/\n+    public native <V> void putFlatValue(Object o, long offset, int layoutKind, Class<?> valueType, V v);\n+\n+    \/**\n+     * Returns an object instance with a private buffered value whose layout\n+     * and contents is exactly the given value instance.  The return object\n+     * is in the larval state that can be updated using the unsafe put operation.\n+     *\n+     * @param value a value instance\n+     * @param <V> the type of the given value instance\n+     *\/\n+    @IntrinsicCandidate\n+    public native <V> V makePrivateBuffer(V value);\n+\n+    \/**\n+     * Exits the larval state and returns a value instance.\n+     *\n+     * @param value a value instance\n+     * @param <V> the type of the given value instance\n+     *\/\n+    @IntrinsicCandidate\n+    public native <V> V finishPrivateBuffer(V value);\n+\n+    \/**\n+     * Returns the header size of the given value type.\n+     *\n+     * @param valueType value type\n+     * @return the header size of the value type\n+     *\/\n+    public native <V> long valueHeaderSize(Class<V> valueType);\n+\n@@ -1253,0 +1454,11 @@\n+    \/**\n+     * Return the size of the object in the heap.\n+     * @param o an object\n+     * @return the objects's size\n+     * @since Valhalla\n+     *\/\n+    public long getObjectSize(Object o) {\n+        if (o == null)\n+            throw new NullPointerException();\n+        return getObjectSize0(o);\n+    }\n@@ -1431,0 +1643,48 @@\n+    private final boolean isValueObject(Object o) {\n+        return o != null && o.getClass().isValue();\n+    }\n+\n+    \/*\n+     * For value type, CAS should do substitutability test as opposed\n+     * to two pointers comparison.\n+     *\n+     * TODO: replace global lock workaround with the proper support for\n+     * atomic access to value objects and loosely consistent values.\n+     *\/\n+    public final <V> boolean compareAndSetReference(Object o, long offset,\n+                                                    Class<?> type,\n+                                                    V expected,\n+                                                    V x) {\n+        if (type.isValue() || isValueObject(expected)) {\n+            synchronized (valueLock) {\n+                Object witness = getReference(o, offset);\n+                if (witness == expected) {\n+                    putReference(o, offset, x);\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+        } else {\n+            return compareAndSetReference(o, offset, expected, x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public final <V> boolean compareAndSetFlatValue(Object o, long offset,\n+                                                int layout,\n+                                                Class<?> valueType,\n+                                                V expected,\n+                                                V x) {\n+        synchronized (valueLock) {\n+            Object witness = getFlatValue(o, offset, layout, valueType);\n+            if (witness == expected) {\n+                putFlatValue(o, offset, layout, valueType, x);\n+                return true;\n+            }\n+            else {\n+                return false;\n+            }\n+        }\n+    }\n+\n@@ -1436,0 +1696,32 @@\n+    public final <V> Object compareAndExchangeReference(Object o, long offset,\n+                                                        Class<?> valueType,\n+                                                        V expected,\n+                                                        V x) {\n+        if (valueType.isValue() || isValueObject(expected)) {\n+            synchronized (valueLock) {\n+                Object witness = getReference(o, offset);\n+                if (witness == expected) {\n+                    putReference(o, offset, x);\n+                }\n+                return witness;\n+            }\n+        } else {\n+            return compareAndExchangeReference(o, offset, expected, x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public final <V> Object compareAndExchangeFlatValue(Object o, long offset,\n+                                                    int layout,\n+                                                    Class<?> valueType,\n+                                                    V expected,\n+                                                    V x) {\n+        synchronized (valueLock) {\n+            Object witness = getFlatValue(o, offset, layout, valueType);\n+            if (witness == expected) {\n+                putFlatValue(o, offset, layout, valueType, x);\n+            }\n+            return witness;\n+        }\n+    }\n+\n@@ -1443,0 +1735,16 @@\n+    public final <V> Object compareAndExchangeReferenceAcquire(Object o, long offset,\n+                                                               Class<?> valueType,\n+                                                               V expected,\n+                                                               V x) {\n+        return compareAndExchangeReference(o, offset, valueType, expected, x);\n+    }\n+\n+    @ForceInline\n+    public final <V> Object compareAndExchangeFlatValueAcquire(Object o, long offset,\n+                                                           int layout,\n+                                                           Class<?> valueType,\n+                                                           V expected,\n+                                                           V x) {\n+        return compareAndExchangeFlatValue(o, offset, layout, valueType, expected, x);\n+    }\n+\n@@ -1450,0 +1758,16 @@\n+    public final <V> Object compareAndExchangeReferenceRelease(Object o, long offset,\n+                                                               Class<?> valueType,\n+                                                               V expected,\n+                                                               V x) {\n+        return compareAndExchangeReference(o, offset, valueType, expected, x);\n+    }\n+\n+    @ForceInline\n+    public final <V> Object compareAndExchangeFlatValueRelease(Object o, long offset,\n+                                                           int layout,\n+                                                           Class<?> valueType,\n+                                                           V expected,\n+                                                           V x) {\n+        return compareAndExchangeFlatValue(o, offset, layout, valueType, expected, x);\n+    }\n+\n@@ -1457,0 +1781,20 @@\n+    public final <V> boolean weakCompareAndSetReferencePlain(Object o, long offset,\n+                                                             Class<?> valueType,\n+                                                             V expected,\n+                                                             V x) {\n+        if (valueType.isValue() || isValueObject(expected)) {\n+            return compareAndSetReference(o, offset, valueType, expected, x);\n+        } else {\n+            return weakCompareAndSetReferencePlain(o, offset, expected, x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public final <V> boolean weakCompareAndSetFlatValuePlain(Object o, long offset,\n+                                                         int layout,\n+                                                         Class<?> valueType,\n+                                                         V expected,\n+                                                         V x) {\n+        return compareAndSetFlatValue(o, offset, layout, valueType, expected, x);\n+    }\n+\n@@ -1464,0 +1808,20 @@\n+    public final <V> boolean weakCompareAndSetReferenceAcquire(Object o, long offset,\n+                                                               Class<?> valueType,\n+                                                               V expected,\n+                                                               V x) {\n+        if (valueType.isValue() || isValueObject(expected)) {\n+            return compareAndSetReference(o, offset, valueType, expected, x);\n+        } else {\n+            return weakCompareAndSetReferencePlain(o, offset, expected, x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public final <V> boolean weakCompareAndSetFlatValueAcquire(Object o, long offset,\n+                                                           int layout,\n+                                                           Class<?> valueType,\n+                                                           V expected,\n+                                                           V x) {\n+        return compareAndSetFlatValue(o, offset, layout, valueType, expected, x);\n+    }\n+\n@@ -1471,0 +1835,20 @@\n+    public final <V> boolean weakCompareAndSetReferenceRelease(Object o, long offset,\n+                                                               Class<?> valueType,\n+                                                               V expected,\n+                                                               V x) {\n+        if (valueType.isValue() || isValueObject(expected)) {\n+            return compareAndSetReference(o, offset, valueType, expected, x);\n+        } else {\n+            return weakCompareAndSetReferencePlain(o, offset, expected, x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public final <V> boolean weakCompareAndSetFlatValueRelease(Object o, long offset,\n+                                                           int layout,\n+                                                           Class<?> valueType,\n+                                                           V expected,\n+                                                           V x) {\n+        return compareAndSetFlatValue(o, offset, layout, valueType, expected, x);\n+    }\n+\n@@ -1478,0 +1862,20 @@\n+    public final <V> boolean weakCompareAndSetReference(Object o, long offset,\n+                                                        Class<?> valueType,\n+                                                        V expected,\n+                                                        V x) {\n+        if (valueType.isValue() || isValueObject(expected)) {\n+            return compareAndSetReference(o, offset, valueType, expected, x);\n+        } else {\n+            return weakCompareAndSetReferencePlain(o, offset, expected, x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public final <V> boolean weakCompareAndSetFlatValue(Object o, long offset,\n+                                                    int layout,\n+                                                    Class<?> valueType,\n+                                                    V expected,\n+                                                    V x) {\n+        return compareAndSetFlatValue(o, offset, layout, valueType, expected, x);\n+    }\n+\n@@ -2093,0 +2497,13 @@\n+    \/**\n+     * Global lock for atomic and volatile strength access to any value of\n+     * a value type.  This is a temporary workaround until better localized\n+     * atomic access mechanisms are supported for value class and primitive class.\n+     *\/\n+    private static final Object valueLock = new Object();\n+\n+    public final <V> Object getFlatValueVolatile(Object base, long offset, int layout, Class<?> valueType) {\n+        synchronized (valueLock) {\n+            return getFlatValue(base, offset, layout, valueType);\n+        }\n+    }\n+\n@@ -2100,0 +2517,6 @@\n+    public final <V> void putFlatValueVolatile(Object o, long offset, int layout, Class<?> valueType, V x) {\n+        synchronized (valueLock) {\n+            putFlatValue(o, offset, layout, valueType, x);\n+        }\n+    }\n+\n@@ -2172,0 +2595,4 @@\n+    public final <V> Object getFlatValueAcquire(Object base, long offset, int layout, Class<?> valueType) {\n+        return getFlatValueVolatile(base, offset, layout, valueType);\n+    }\n+\n@@ -2236,0 +2663,4 @@\n+    public final <V> void putFlatValueRelease(Object o, long offset, int layout, Class<?> valueType, V x) {\n+        putFlatValueVolatile(o, offset, layout, valueType, x);\n+    }\n+\n@@ -2292,0 +2723,4 @@\n+    public final <V> Object getFlatValueOpaque(Object base, long offset, int layout, Class<?> valueType) {\n+        return getFlatValueVolatile(base, offset, layout, valueType);\n+    }\n+\n@@ -2346,0 +2781,4 @@\n+    public final <V> void putFlatValueOpaque(Object o, long offset, int layout, Class<?> valueType, V x) {\n+        putFlatValueVolatile(o, offset, layout, valueType, x);\n+    }\n+\n@@ -2780,0 +3219,9 @@\n+    @SuppressWarnings(\"unchecked\")\n+    public final <V> Object getAndSetFlatValue(Object o, long offset, int layout, Class<?> valueType, V newValue) {\n+        synchronized (valueLock) {\n+            Object oldValue = getFlatValue(o, offset, layout, valueType);\n+            putFlatValue(o, offset, layout, valueType, newValue);\n+            return oldValue;\n+        }\n+    }\n+\n@@ -2789,0 +3237,5 @@\n+    @ForceInline\n+    public final <V> Object getAndSetFlatValueRelease(Object o, long offset, int layout, Class<?> valueType, V newValue) {\n+        return getAndSetFlatValue(o, offset, layout, valueType, newValue);\n+    }\n+\n@@ -2798,0 +3251,5 @@\n+    @ForceInline\n+    public final <V> Object getAndSetFlatValueAcquire(Object o, long offset, int layout, Class<?> valueType, V newValue) {\n+        return getAndSetFlatValue(o, offset, layout, valueType, newValue);\n+    }\n+\n@@ -3855,0 +4313,1 @@\n+    private native long getObjectSize0(Object o);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":459,"deletions":0,"binary":false,"changes":459,"status":"modified"},{"patch":"@@ -281,0 +281,5 @@\n+        \/**\n+         * Warn about issues related to migration of JDK classes.\n+         *\/\n+        MIGRATION(\"migration\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -329,0 +329,10 @@\n+\n+        if (!env.info.ctorPrologue &&\n+                v.owner.isValueClass() &&\n+                v.owner.kind == TYP &&\n+                v.owner == env.enclClass.sym &&\n+                (v.flags() & STATIC) == 0 &&\n+                (base == null ||\n+                        TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))) {\n+            log.error(pos, Errors.CantRefAfterCtorCalled(v));\n+        }\n@@ -1208,1 +1218,5 @@\n-                        tree.body.stats = tree.body.stats.prepend(supCall);\n+                        if (owner.isValueClass() || owner.hasStrict()) {\n+                            tree.body.stats = tree.body.stats.append(supCall);\n+                        } else {\n+                            tree.body.stats = tree.body.stats.prepend(supCall);\n+                        }\n@@ -1318,4 +1332,13 @@\n-                    attribExpr(tree.init, initEnv, v.type);\n-                    if (tree.isImplicitlyTyped()) {\n-                        \/\/fixup local variable type\n-                        v.type = chk.checkLocalVarType(tree, tree.init.type, tree.name);\n+                    boolean previousCtorPrologue = initEnv.info.ctorPrologue;\n+                    try {\n+                        if (v.owner.kind == TYP && !v.isStatic() && v.isStrict()) {\n+                            \/\/ strict instance initializer in a value class\n+                            initEnv.info.ctorPrologue = true;\n+                        }\n+                        attribExpr(tree.init, initEnv, v.type);\n+                        if (tree.isImplicitlyTyped()) {\n+                            \/\/fixup local variable type\n+                            v.type = chk.checkLocalVarType(tree, tree.init.type, tree.name);\n+                        }\n+                    } finally {\n+                        initEnv.info.ctorPrologue = previousCtorPrologue;\n@@ -1441,1 +1464,5 @@\n-            if ((tree.flags & STATIC) != 0) localEnv.info.staticLevel++;\n+            if ((tree.flags & STATIC) != 0) {\n+                localEnv.info.staticLevel++;\n+            } else {\n+                localEnv.info.instanceInitializerBlock = true;\n+            }\n@@ -1950,2 +1977,2 @@\n-        chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));\n-        if (isValueBased(tree.lock.type)) {\n+        boolean identityType = chk.checkIdentityType(tree.pos(), attribExpr(tree.lock, env));\n+        if (identityType && isValueBased(tree.lock.type)) {\n@@ -1962,1 +1989,0 @@\n-\n@@ -4396,0 +4422,1 @@\n+        Assert.check(site == tree.selected.type);\n@@ -5494,1 +5521,1 @@\n-                } else {\n+                } else if ((c.flags_field & Flags.COMPOUND) == 0) {\n@@ -5532,0 +5559,5 @@\n+                if (c.isValueClass()) {\n+                    Assert.check(env.tree.hasTag(CLASSDEF));\n+                    chk.checkConstraintsOfValueClass((JCClassDecl) env.tree, c);\n+                }\n+\n@@ -5674,1 +5706,1 @@\n-            chk.checkSerialStructure(tree, c);\n+            chk.checkSerialStructure(env, tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":43,"deletions":11,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -184,0 +184,2 @@\n+        allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -227,0 +229,4 @@\n+    \/** Are value classes allowed\n+     *\/\n+    private final boolean allowValueClasses;\n+\n@@ -736,0 +742,25 @@\n+    void checkConstraintsOfValueClass(JCClassDecl tree, ClassSymbol c) {\n+        DiagnosticPosition pos = tree.pos();\n+        for (Type st : types.closure(c.type)) {\n+            if (st == null || st.tsym == null || st.tsym.kind == ERR)\n+                continue;\n+            if  (st.tsym == syms.objectType.tsym || st.tsym == syms.recordType.tsym || st.isInterface())\n+                continue;\n+            if (!st.tsym.isAbstract()) {\n+                if (c != st.tsym) {\n+                    log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n+                }\n+                continue;\n+            }\n+            \/\/ dealing with an abstract value or value super class below.\n+            for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                if (s.kind == MTH) {\n+                    if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n+                        log.error(pos, Errors.SuperClassMethodCannotBeSynchronized(s, c, st));\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -793,0 +824,26 @@\n+    \/** Check that type is an identity type, i.e. not a value type.\n+     *  When not discernible statically, give it the benefit of doubt\n+     *  and defer to runtime.\n+     *\n+     *  @param pos           Position to be used for error reporting.\n+     *  @param t             The type to be checked.\n+     *\/\n+    boolean checkIdentityType(DiagnosticPosition pos, Type t) {\n+        if (t.hasTag(TYPEVAR)) {\n+            t = types.skipTypeVars(t, false);\n+        }\n+        if (t.isIntersection()) {\n+            IntersectionClassType ict = (IntersectionClassType)t;\n+            boolean result = true;\n+            for (Type component : ict.getExplicitComponents()) {\n+                result &= checkIdentityType(pos, component);\n+            }\n+            return result;\n+        }\n+        if (t.isPrimitive() || (t.isValueClass() && !t.tsym.isAbstract())) {\n+            typeTagError(pos, diags.fragment(Fragments.TypeReqIdentity), t);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n@@ -1183,2 +1240,7 @@\n-            else\n-                mask = VarFlags;\n+            else {\n+                boolean isInstanceFieldOfValueClass = sym.owner.type.isValueClass() && (flags & STATIC) == 0;\n+                mask = !isInstanceFieldOfValueClass ? VarFlags : ValueFieldFlags;\n+                if (isInstanceFieldOfValueClass) {\n+                    implicit |= FINAL | STRICT;\n+                }\n+            }\n@@ -1210,1 +1272,2 @@\n-                mask = RecordMethodFlags;\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        RecordMethodFlags & ~SYNCHRONIZED : RecordMethodFlags;\n@@ -1212,1 +1275,3 @@\n-                mask = MethodFlags;\n+                \/\/ value objects do not have an associated monitor\/lock\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                        MethodFlags & ~SYNCHRONIZED : MethodFlags;\n@@ -1229,1 +1294,1 @@\n-                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? StaticLocalFlags : LocalClassFlags;\n+                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? ExtendedStaticLocalClassFlags : ExtendedLocalClassFlags;\n@@ -1245,0 +1310,4 @@\n+            if ((flags & (VALUE_CLASS | SEALED | ABSTRACT)) == (VALUE_CLASS | SEALED) ||\n+                (flags & (VALUE_CLASS | NON_SEALED | ABSTRACT)) == (VALUE_CLASS | NON_SEALED)) {\n+                log.error(pos, Errors.NonAbstractValueClassCantBeSealedOrNonSealed);\n+            }\n@@ -1248,0 +1317,4 @@\n+            if ((flags & (INTERFACE | VALUE_CLASS)) == 0) {\n+                implicit |= IDENTITY_TYPE;\n+            }\n+\n@@ -1249,2 +1322,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE_CLASS);\n@@ -1263,0 +1336,5 @@\n+\n+            \/\/ concrete value classes are implicitly final\n+            if ((flags & (ABSTRACT | INTERFACE | VALUE_CLASS)) == VALUE_CLASS) {\n+                implicit |= FINAL;\n+            }\n@@ -1277,2 +1355,1 @@\n-        }\n-        else if ((sym.kind == TYP ||\n+        } else if ((sym.kind == TYP ||\n@@ -1301,1 +1378,2 @@\n-                 checkDisjoint(pos, flags,\n+                 \/\/ we are using `implicit` here as instance fields of value classes are implicitly final\n+                 checkDisjoint(pos, flags | implicit,\n@@ -1317,1 +1395,7 @@\n-                                ANNOTATION)) {\n+                                ANNOTATION)\n+                && checkDisjoint(pos, flags,\n+                                VALUE_CLASS,\n+                                ANNOTATION)\n+                && checkDisjoint(pos, flags,\n+                                VALUE_CLASS,\n+                                INTERFACE) ) {\n@@ -2129,0 +2213,5 @@\n+        if (allowValueClasses && origin.isValueClass() && names.finalize.equals(m.name)) {\n+            if (m.overrides(syms.objectFinalize, origin, types, false)) {\n+                log.warning(tree.pos(), Warnings.ValueFinalize);\n+            }\n+        }\n@@ -2557,0 +2646,12 @@\n+\n+        Type identitySuper = null;\n+        for (Type t : types.closure(c)) {\n+            if (t != c) {\n+                if (t.isIdentityClass() && (t.tsym.flags() & VALUE_BASED) == 0)\n+                    identitySuper = t;\n+                if (c.isValueClass() && identitySuper != null && identitySuper.tsym != syms.objectType.tsym) { \/\/ Object is special\n+                    log.error(pos, Errors.ValueTypeHasIdentitySuperType(c, identitySuper));\n+                    break;\n+                }\n+            }\n+        }\n@@ -4909,2 +5010,2 @@\n-    public void checkSerialStructure(JCClassDecl tree, ClassSymbol c) {\n-        (new SerialTypeVisitor()).visit(c, tree);\n+    public void checkSerialStructure(Env<AttrContext> env, JCClassDecl tree, ClassSymbol c) {\n+        (new SerialTypeVisitor(env)).visit(c, tree);\n@@ -4941,1 +5042,2 @@\n-        SerialTypeVisitor() {\n+        Env<AttrContext> env;\n+        SerialTypeVisitor(Env<AttrContext> env) {\n@@ -4943,0 +5045,1 @@\n+            this.env = env;\n@@ -5002,0 +5105,1 @@\n+            final boolean[] hasWriteReplace = {false};\n@@ -5076,1 +5180,1 @@\n-                            case \"writeReplace\"     -> checkWriteReplace(tree,e, method);\n+                            case \"writeReplace\"     -> {hasWriteReplace[0] = true; hasAppropriateWriteReplace(tree, method, true);}\n@@ -5087,1 +5191,20 @@\n-\n+            if (!hasWriteReplace[0] &&\n+                    (c.isValueClass() || hasAbstractValueSuperClass(c, Set.of(syms.numberType.tsym))) &&\n+                    !c.isAbstract() && !c.isRecord() &&\n+                    types.unboxedType(c.type) == Type.noType) {\n+                \/\/ we need to check if the class is inheriting an appropriate writeReplace method\n+                MethodSymbol ms = null;\n+                Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);\n+                try {\n+                    ms = rs.resolveInternalMethod(env.tree, env, c.type, names.writeReplace, List.nil(), List.nil());\n+                } catch (FatalError fe) {\n+                    \/\/ ignore no method was found\n+                } finally {\n+                    log.popDiagnosticHandler(discardHandler);\n+                }\n+                if (ms == null || !hasAppropriateWriteReplace(p, ms, false)) {\n+                    log.warning(p.pos(),\n+                            c.isValueClass() ? LintWarnings.SerializableValueClassWithoutWriteReplace1 :\n+                                    LintWarnings.SerializableValueClassWithoutWriteReplace2);\n+                }\n+            }\n@@ -5095,0 +5218,16 @@\n+        private boolean hasAbstractValueSuperClass(Symbol c, Set<Symbol> excluding) {\n+            while (c.getKind() == ElementKind.CLASS) {\n+                Type sup = ((ClassSymbol)c).getSuperclass();\n+                if (!sup.hasTag(CLASS) || sup.isErroneous() ||\n+                        sup.tsym == syms.objectType.tsym) {\n+                    return false;\n+                }\n+                \/\/ if it is a value super class it has to be abstract\n+                if (sup.isValueClass() && !excluding.contains(sup.tsym)) {\n+                    return true;\n+                }\n+                c = sup.tsym;\n+            }\n+            return false;\n+        }\n+\n@@ -5218,1 +5357,1 @@\n-            checkReturnType(tree, e, method, syms.voidType);\n+            isExpectedReturnType(tree, method, syms.voidType, true);\n@@ -5220,1 +5359,1 @@\n-            checkExceptions(tree, e, method, syms.ioExceptionType);\n+            hasExpectedExceptions(tree, method, true, syms.ioExceptionType);\n@@ -5224,1 +5363,1 @@\n-        private void checkWriteReplace(JCClassDecl tree, Element e, MethodSymbol method) {\n+        private boolean hasAppropriateWriteReplace(JCClassDecl tree, MethodSymbol method, boolean warn) {\n@@ -5230,4 +5369,4 @@\n-            checkConcreteInstanceMethod(tree, e, method);\n-            checkReturnType(tree, e, method, syms.objectType);\n-            checkNoArgs(tree, e, method);\n-            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            return isConcreteInstanceMethod(tree, method, warn) &&\n+                    isExpectedReturnType(tree, method, syms.objectType, warn) &&\n+                    hasNoArgs(tree, method, warn) &&\n+                    hasExpectedExceptions(tree, method, warn, syms.objectStreamExceptionType);\n@@ -5244,1 +5383,1 @@\n-            checkReturnType(tree, e, method, syms.voidType);\n+            isExpectedReturnType(tree, method, syms.voidType, true);\n@@ -5246,1 +5385,1 @@\n-            checkExceptions(tree, e, method, syms.ioExceptionType, syms.classNotFoundExceptionType);\n+            hasExpectedExceptions(tree, method, true, syms.ioExceptionType, syms.classNotFoundExceptionType);\n@@ -5253,3 +5392,3 @@\n-            checkReturnType(tree, e, method, syms.voidType);\n-            checkNoArgs(tree, e, method);\n-            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            isExpectedReturnType(tree, method, syms.voidType, true);\n+            hasNoArgs(tree, method, true);\n+            hasExpectedExceptions(tree, method, true, syms.objectStreamExceptionType);\n@@ -5265,4 +5404,4 @@\n-            checkConcreteInstanceMethod(tree, e, method);\n-            checkReturnType(tree,e, method, syms.objectType);\n-            checkNoArgs(tree, e, method);\n-            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            isConcreteInstanceMethod(tree, method, true);\n+            isExpectedReturnType(tree, method, syms.objectType, true);\n+            hasNoArgs(tree, method, true);\n+            hasExpectedExceptions(tree, method, true, syms.objectStreamExceptionType);\n@@ -5518,1 +5657,1 @@\n-                        case \"writeReplace\" -> checkWriteReplace(tree, e, method);\n+                        case \"writeReplace\" -> hasAppropriateWriteReplace(tree, method, true);\n@@ -5536,3 +5675,3 @@\n-        void checkConcreteInstanceMethod(JCClassDecl tree,\n-                                         Element enclosing,\n-                                         MethodSymbol method) {\n+        boolean isConcreteInstanceMethod(JCClassDecl tree,\n+                                         MethodSymbol method,\n+                                         boolean warn) {\n@@ -5540,0 +5679,1 @@\n+                if (warn) {\n@@ -5543,0 +5683,2 @@\n+                }\n+                return false;\n@@ -5544,0 +5686,1 @@\n+            return true;\n@@ -5546,4 +5689,4 @@\n-        private void checkReturnType(JCClassDecl tree,\n-                                     Element enclosing,\n-                                     MethodSymbol method,\n-                                     Type expectedReturnType) {\n+        private boolean isExpectedReturnType(JCClassDecl tree,\n+                                          MethodSymbol method,\n+                                          Type expectedReturnType,\n+                                          boolean warn) {\n@@ -5557,2 +5700,3 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n+                if (warn) {\n+                    log.warning(\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n@@ -5561,0 +5705,2 @@\n+                }\n+                return false;\n@@ -5562,0 +5708,1 @@\n+            return true;\n@@ -5599,1 +5746,1 @@\n-        private void checkNoArgs(JCClassDecl tree, Element enclosing, MethodSymbol method) {\n+        boolean hasNoArgs(JCClassDecl tree, MethodSymbol method, boolean warn) {\n@@ -5602,2 +5749,3 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n+                if (warn) {\n+                    log.warning(\n+                            TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n@@ -5605,0 +5753,2 @@\n+                }\n+                return false;\n@@ -5606,0 +5756,1 @@\n+            return true;\n@@ -5618,4 +5769,4 @@\n-        private void checkExceptions(JCClassDecl tree,\n-                                     Element enclosing,\n-                                     MethodSymbol method,\n-                                     Type... declaredExceptions) {\n+        private boolean hasExpectedExceptions(JCClassDecl tree,\n+                                              MethodSymbol method,\n+                                              boolean warn,\n+                                              Type... declaredExceptions) {\n@@ -5640,2 +5791,3 @@\n-                        log.warning(\n-                                TreeInfo.diagnosticPositionFor(method, tree),\n+                        if (warn) {\n+                            log.warning(\n+                                    TreeInfo.diagnosticPositionFor(method, tree),\n@@ -5644,0 +5796,2 @@\n+                        }\n+                        return false;\n@@ -5647,1 +5801,1 @@\n-            return;\n+            return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":206,"deletions":52,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-        \/\/ Do something with all static or non-static field initializers and initialization blocks.\n+        \/\/ Do something with static or non-static field initializers and initialization blocks.\n@@ -483,0 +483,10 @@\n+            forEachInitializer(classDef, isStatic, false, handler);\n+        }\n+\n+        \/* Do something with static or non-static field initializers and initialization blocks.\n+         * the `earlyOnly` argument will determine if we will deal or not with early variable instance\n+         * initializers we want to process only those before a super() invocation and ignore them after\n+         * it.\n+         *\/\n+        protected void forEachInitializer(JCClassDecl classDef, boolean isStatic, boolean earlyOnly,\n+                                          Consumer<? super JCTree> handler) {\n@@ -500,2 +510,12 @@\n-                    if (!def.hasTag(METHODDEF) && (isDefStatic == isStatic))\n-                        handler.accept(def);\n+                    if (!def.hasTag(METHODDEF) && (isDefStatic == isStatic)) {\n+                        if (def instanceof JCVariableDecl varDecl) {\n+                            boolean isEarly = varDecl.init != null &&\n+                                    varDecl.sym.isStrict() &&\n+                                    !varDecl.sym.isStatic();\n+                            if (isEarly == earlyOnly) {\n+                                handler.accept(def);\n+                            }\n+                        } else if (!earlyOnly) {\n+                            handler.accept(def);\n+                        }\n+                    }\n@@ -2293,1 +2313,1 @@\n-                    log.error(pos, errkey);\n+                log.error(pos, errkey);\n@@ -3027,0 +3047,8 @@\n+            Name name = TreeInfo.name(tree.meth);\n+            \/\/ let's process early initializers\n+            if (name == names._super) {\n+                forEachInitializer(classDef, false, true, def -> {\n+                    scan(def);\n+                    clearPendingExits(false);\n+                });\n+            }\n@@ -3034,1 +3062,1 @@\n-                Name name = TreeInfo.name(tree.meth);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -69,0 +70,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -79,0 +81,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n@@ -114,0 +117,4 @@\n+    \/** Switch: allow value classes.\n+     *\/\n+    boolean allowValueClasses;\n+\n@@ -296,0 +303,2 @@\n+        allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -590,3 +599,5 @@\n-                    return (outer == Type.noType) ?\n-                            t.erasure(types) :\n-                        new ClassType(outer, List.nil(), t);\n+                    if (outer == Type.noType) {\n+                        ClassType et = (ClassType) t.erasure(types);\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n+                    }\n+                    return new ClassType(outer, List.nil(), t, List.nil());\n@@ -614,1 +625,1 @@\n-                outer = new ClassType(outer, actuals, t) {\n+                outer = new ClassType(outer, actuals, t, List.nil()) {\n@@ -698,1 +709,1 @@\n-                    outer = new ClassType(outer, List.nil(), t);\n+                    outer = new ClassType(outer, List.nil(), t, List.nil());\n@@ -1561,0 +1572,7 @@\n+            } else if (proxy.type.tsym.flatName() == syms.migratedValueClassInternalType.tsym.flatName()) {\n+                Assert.check(sym.kind == TYP);\n+                sym.flags_field |= MIGRATED_VALUE_CLASS;\n+                if (needsValueFlag(sym, sym.flags_field)) {\n+                    sym.flags_field |= VALUE_CLASS;\n+                    sym.flags_field &= ~IDENTITY_TYPE;\n+                }\n@@ -1577,0 +1595,6 @@\n+                }  else if (proxy.type.tsym == syms.migratedValueClassType.tsym && sym.kind == TYP) {\n+                    sym.flags_field |= MIGRATED_VALUE_CLASS;\n+                    if (needsValueFlag(sym, sym.flags_field)) {\n+                        sym.flags_field |= VALUE_CLASS;\n+                        sym.flags_field &= ~IDENTITY_TYPE;\n+                    }\n@@ -3065,1 +3089,1 @@\n-        long flags = adjustClassFlags(f);\n+        long flags = adjustClassFlags(c, f);\n@@ -3157,1 +3181,1 @@\n-            long flags = adjustClassFlags(nextChar());\n+            long flags = adjustClassFlags(c, nextChar());\n@@ -3299,0 +3323,5 @@\n+        boolean previewClassFile = minorVersion == ClassFile.PREVIEW_MINOR_VERSION;\n+        if (allowValueClasses && previewClassFile && (flags & ACC_STRICT) != 0) {\n+            flags &= ~ACC_STRICT;\n+            flags |= STRICT;\n+        }\n@@ -3314,1 +3343,1 @@\n-    long adjustClassFlags(long flags) {\n+    long adjustClassFlags(ClassSymbol c, long flags) {\n@@ -3319,1 +3348,23 @@\n-        return flags & ~ACC_SUPER; \/\/ SUPER and SYNCHRONIZED bits overloaded\n+        if (((flags & ACC_IDENTITY) != 0 && !isMigratedValueClass(flags)) || (majorVersion < V67.major && (flags & INTERFACE) == 0)) {\n+            flags |= IDENTITY_TYPE;\n+        } else if (needsValueFlag(c, flags)) {\n+            flags |= VALUE_CLASS;\n+            flags &= ~IDENTITY_TYPE;\n+        }\n+        flags &= ~ACC_IDENTITY; \/\/ ACC_IDENTITY and SYNCHRONIZED bits overloaded\n+        return flags;\n+    }\n+\n+    private boolean needsValueFlag(Symbol c, long flags) {\n+        boolean previewClassFile = minorVersion == ClassFile.PREVIEW_MINOR_VERSION;\n+        if (allowValueClasses) {\n+            if (previewClassFile && majorVersion >= V67.major && (flags & INTERFACE) == 0 ||\n+                    majorVersion >= V67.major && isMigratedValueClass(flags)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isMigratedValueClass(long flags) {\n+        return allowValueClasses && ((flags & MIGRATED_VALUE_CLASS) != 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":60,"deletions":9,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1275,1 +1275,1 @@\n-                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs);\n+                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -894,0 +894,1 @@\n+    @SuppressWarnings(\"preview\")\n@@ -905,0 +906,3 @@\n+        if (declaringClass.isValue()) {\n+            throw new UnsupportedOperationException(\"can't get field offset on a value class: \" + f);\n+        }\n@@ -934,0 +938,1 @@\n+    @SuppressWarnings(\"preview\")\n@@ -945,0 +950,3 @@\n+        if (declaringClass.isValue()) {\n+            throw new UnsupportedOperationException(\"can't get field offset on a value class: \" + f);\n+        }\n@@ -966,0 +974,1 @@\n+    @SuppressWarnings(\"preview\")\n@@ -977,0 +986,3 @@\n+        if (declaringClass.isValue()) {\n+            throw new UnsupportedOperationException(\"can't get field offset on a value class: \" + f);\n+        }\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,0 +80,3 @@\n+compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementWithGCBarrierTests.java 8342488 generic-all\n+compiler\/c2\/TestMergeStores.java#id1 8348959 generic-all\n+\n@@ -109,0 +112,1 @@\n+runtime\/cds\/appcds\/redefineClass\/RedefineRunningMethods_Shared.java  8304168 generic-all\n@@ -130,0 +134,40 @@\n+\n+# Valhalla\n+runtime\/AccModule\/ConstModule.java 8294051 generic-all\n+runtime\/valhalla\/inlinetypes\/CircularityTest.java 8349037 generic-all\n+runtime\/valhalla\/inlinetypes\/PreloadCircularityTest.java 8349631 linux-aarch64-debug\n+runtime\/valhalla\/inlinetypes\/ValuePreloadTest.java 8349630 linux-aarch64-debug\n+compiler\/gcbarriers\/TestG1BarrierGeneration.java 8343420 generic-all\n+\n+# Valhalla + COH\n+compiler\/c2\/autovectorization\/TestIndexOverflowIR.java                          8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorConditionalMove.java                              8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java                      8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorizationNotRun.java                                8348568 generic-all\n+compiler\/c2\/TestCastX2NotProcessedIGVN.java                                     8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java                                8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java#NoAlignVector-COH              8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java#VerifyAlignVector-COH          8348568 generic-all\n+compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java       8348568 generic-all\n+compiler\/loopopts\/superword\/TestMulAddS2I.java                                  8348568 generic-all\n+compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java               8348568 generic-all\n+compiler\/loopopts\/superword\/TestSplitPacks.java                                 8348568 generic-all\n+compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java     8348568 generic-all\n+compiler\/vectorization\/TestFloatConversionsVector.java                          8348568 generic-all\n+compiler\/vectorization\/runner\/ArrayTypeConvertTest.java                         8348568 generic-all\n+compiler\/vectorization\/runner\/LoopCombinedOpTest.java                           8348568 generic-all\n+compiler\/vectorization\/runner\/VectorizationTestRunner.java                      8348568 generic-all\n+\n+gc\/stress\/gcbasher\/TestGCBasherWithParallel.java                                8348568 generic-all\n+\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh                     8348568 generic-all\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh-large-class-space   8348568 generic-all\n+gtest\/MetaspaceGtests.java#UseCompactObjectHeaders                              8348568 generic-all\n+\n+runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java               8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#no-coops-with-coh                          8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#with-coop--with-coh                        8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_coh                            8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_coh                          8348568 generic-all\n+runtime\/cds\/appcds\/TestZGCWithCDS.java                                          8348568 generic-all\n+\n@@ -153,0 +197,31 @@\n+# Valhalla TODO:\n+serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java 8317416 generic-all\n+\n+serviceability\/sa\/ClhsdbCDSCore.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbFindPC.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbInspect.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbLongConstant.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJdis.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJstack.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAs.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintStatics.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSource.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSymbol.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbWhere.java 8190936 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8190936 generic-all\n+serviceability\/sa\/TestClassDump.java 8190936 generic-all\n+serviceability\/sa\/TestClhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestCpoolForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForLargeArray.java 8190936 generic-all\n+serviceability\/sa\/TestIntConstant.java 8190936 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCore.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8190936 generic-all\n+serviceability\/sa\/TestPrintMdo.java 8190936 generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbDumpclass.java 8190936 generic-all\n+\n+\n@@ -191,0 +266,2 @@\n+vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/byteMutation\/Test.java 8317172 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  runtime\n+  runtime \\\n@@ -65,0 +65,8 @@\n+hotspot_valhalla = \\\n+  runtime\/valhalla \\\n+  compiler\/valhalla \\\n+  serviceability\/jvmti\/valhalla\n+\n+hotspot_valhalla_runtime = \\\n+  runtime\/valhalla\n+\n@@ -161,1 +169,1 @@\n-  compiler\/codegen\/aes \\\n+  compiler\/codegen\/aes \\\n@@ -217,0 +225,1 @@\n+  compiler\/valhalla\/ \\\n@@ -259,0 +268,7 @@\n+\n+tier1_compiler_no_valhalla = \\\n+  :tier1_compiler_1 \\\n+  :tier1_compiler_2 \\\n+  :tier1_compiler_3 \\\n+  -compiler\/valhalla\n+\n@@ -410,0 +426,4 @@\n+tier1_runtime_no_valhalla = \\\n+  :tier1_runtime \\\n+  -runtime\/valhalla\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,1713 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestIntrinsics\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestIntrinsics {\n+\n+    public static void main(String[] args) {\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:+UseArrayFlattening\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:PerMethodSpecTrapLimit=0\", \"-XX:PerMethodTrapLimit=0\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addFlags(\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                             \/\/ Disable FlatValue intrinsics check until JDK-8349110 is fixed\n+                             \"-DExclude=test30,test31,test32,test33,test34,test35,test36,test37,\" +\n+                             \"test38,test55,test71,test72,test73,test80\",\n+                             \/\/ Don't run with DeoptimizeALot until JDK-8239003 is fixed\n+                             \"-XX:-DeoptimizeALot\")\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Test correctness of the Class::isAssignableFrom intrinsic\n+    @Test\n+    public boolean test1(Class<?> supercls, Class<?> subcls) {\n+        return supercls.isAssignableFrom(subcls);\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        Asserts.assertTrue(test1(java.util.AbstractList.class, java.util.ArrayList.class), \"test1_1 failed\");\n+        Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), \"test1_2 failed\");\n+        Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), \"test1_3 failed\");\n+        Asserts.assertTrue(test1(Object.class, MyValue1.class), \"test1_4 failed\");\n+        Asserts.assertTrue(!test1(MyValue1.class, Object.class), \"test1_5 failed\");\n+    }\n+\n+    \/\/ Verify that Class::isAssignableFrom checks with statically known classes are folded\n+    @Test\n+    @IR(failOn = {LOADK})\n+    public boolean test2() {\n+        boolean check1 = java.util.AbstractList.class.isAssignableFrom(java.util.ArrayList.class);\n+        boolean check2 = MyValue1.class.isAssignableFrom(MyValue1.class);\n+        boolean check3 = Object.class.isAssignableFrom(java.util.ArrayList.class);\n+        boolean check4 = Object.class.isAssignableFrom(MyValue1.class);\n+        boolean check5 = !MyValue1.class.isAssignableFrom(Object.class);\n+        return check1 && check2 && check3 && check4 && check5;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        Asserts.assertTrue(test2(), \"test2 failed\");\n+    }\n+\n+    \/\/ Test correctness of the Class::getSuperclass intrinsic\n+    @Test\n+    public Class<?> test3(Class<?> cls) {\n+        return cls.getSuperclass();\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        Asserts.assertTrue(test3(Object.class) == null, \"test3_1 failed\");\n+        Asserts.assertTrue(test3(MyValue1.class) == MyAbstract.class, \"test3_2 failed\");\n+        Asserts.assertTrue(test3(MyValue1.class) == MyAbstract.class, \"test3_3 failed\");\n+        Asserts.assertTrue(test3(Class.class) == Object.class, \"test3_4 failed\");\n+    }\n+\n+    \/\/ Verify that Class::getSuperclass checks with statically known classes are folded\n+    @Test\n+    @IR(failOn = {LOADK})\n+    public boolean test4() {\n+        boolean check1 = Object.class.getSuperclass() == null;\n+        boolean check2 = MyValue1.class.getSuperclass() == MyAbstract.class;\n+        boolean check3 = MyValue1.class.getSuperclass() == MyAbstract.class;\n+        boolean check4 = Class.class.getSuperclass() == Object.class;\n+        return check1 && check2 && check3 && check4;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        Asserts.assertTrue(test4(), \"test4 failed\");\n+    }\n+\n+    \/\/ Test toString() method\n+    @Test\n+    public String test5(MyValue1 v) {\n+        return v.toString();\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue1 v = MyValue1.createDefaultInline();\n+        test5(v);\n+    }\n+\n+    \/\/ Test hashCode() method\n+    @Test\n+    public int test6(MyValue1 v) {\n+        return v.hashCode();\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test6(v);\n+        Asserts.assertEQ(res, v.hashCode());\n+    }\n+\n+    \/\/ Test default value class array creation via reflection\n+    @Test\n+    public Object[] test7(Class<?> componentType, int len) {\n+        Object[] va = ValueClass.newNullRestrictedArray(componentType, len);\n+        return va;\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        long hash = MyValue1.createDefaultDontInline().hashPrimitive();\n+        Object[] va = test7(MyValue1.class, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);\n+        }\n+    }\n+\n+    \/\/ Class.isInstance\n+    @Test\n+    public boolean test8(Class c, MyValue1 vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test8(MyValue1.class, vt);\n+        Asserts.assertTrue(result);\n+        result = test8(MyValue1.class, vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    public boolean test9(Class c, MyValue1 vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test9(MyValue2.class, vt);\n+        Asserts.assertFalse(result);\n+        result = test9(MyValue2.class, vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Class.cast\n+    @Test\n+    public Object test10(Class c, MyValue1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test10(MyValue1.class, vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public Object test11(Class c, MyValue1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            test11(MyValue2.class, vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test12(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test12(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public Object test13(MyValue1 vt) {\n+        return MyValue2.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            test13(vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    \/\/ Value class array creation via reflection\n+    @Test\n+    public void test14(int len, long hash) {\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);\n+        }\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        long hash = MyValue1.createDefaultDontInline().hashPrimitive();\n+        test14(len, hash);\n+    }\n+\n+    \/\/ Test hashCode() method\n+    @Test\n+    public int test15(Object v) {\n+        return v.hashCode();\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test15(v);\n+        Asserts.assertEQ(res, v.hashCode());\n+    }\n+\n+    @Test\n+    public int test16(Object v) {\n+        return System.identityHashCode(v);\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test16(v);\n+        Asserts.assertEQ(res, System.identityHashCode((Object)v));\n+    }\n+\n+    @Test\n+    public int test17(Object v) {\n+        return System.identityHashCode(v);\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        Integer v = Integer.valueOf(rI);\n+        int res = test17(v);\n+        Asserts.assertEQ(res, System.identityHashCode(v));\n+    }\n+\n+    @Test\n+    public int test18(Object v) {\n+        return System.identityHashCode(v);\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        Object v = null;\n+        int res = test18(v);\n+        Asserts.assertEQ(res, System.identityHashCode(v));\n+    }\n+\n+    \/\/ hashCode() and toString() with different value objects\n+    @Test\n+    public int test19(MyValue1 vt1, MyValue1 vt2, boolean b) {\n+        MyValue1 res = b ? vt1 : vt2;\n+        return res.hashCode();\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test19(vt, vt, true);\n+        Asserts.assertEQ(res, vt.hashCode());\n+        res = test19(vt, vt, false);\n+        Asserts.assertEQ(res, vt.hashCode());\n+    }\n+\n+    @Test\n+    public String test20(MyValue1 vt1, MyValue1 vt2, boolean b) {\n+        MyValue1 res = b ? vt1 : vt2;\n+        return res.toString();\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        String res = test20(vt, vt, true);\n+        Asserts.assertEQ(res, vt.toString());\n+        res = test20(vt, vt, false);\n+        Asserts.assertEQ(res, vt.toString());\n+    }\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final long X_OFFSET;\n+    private static final long Y_OFFSET;\n+    private static final long V1_OFFSET;\n+    private static final boolean V1_FLATTENED;\n+    private static final int V1_LAYOUT;\n+\n+    static {\n+        try {\n+            Field xField = MyValue1.class.getDeclaredField(\"x\");\n+            X_OFFSET = U.objectFieldOffset(xField);\n+            Field yField = MyValue1.class.getDeclaredField(\"y\");\n+            Y_OFFSET = U.objectFieldOffset(yField);\n+            Field v1Field = MyValue1.class.getDeclaredField(\"v1\");\n+            V1_OFFSET = U.objectFieldOffset(v1Field);\n+            V1_FLATTENED = U.isFlatField(v1Field);\n+            V1_LAYOUT = U.fieldLayout(v1Field);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test21(MyValue1 v) {\n+       return U.getInt(v, X_OFFSET);\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test21(v);\n+        Asserts.assertEQ(res, v.x);\n+    }\n+\n+    @NullRestricted\n+    MyValue1 test22_vt;\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    public void test22(MyValue1 v) {\n+        v = U.makePrivateBuffer(v);\n+        U.putInt(v, X_OFFSET, rI);\n+        v = U.finishPrivateBuffer(v);\n+        test22_vt = v;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        test22(v.setX(v, 0));\n+        Asserts.assertEQ(test22_vt.hash(), v.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test23(MyValue1 v, long offset) {\n+        return U.getInt(v, offset);\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test23(v, X_OFFSET);\n+        Asserts.assertEQ(res, v.x);\n+    }\n+\n+    @NullRestricted\n+    MyValue1 test24_vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test24(long offset) {\n+        return U.getInt(test24_vt, offset);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int res = test24(X_OFFSET);\n+        Asserts.assertEQ(res, test24_vt.x);\n+    }\n+\n+    \/\/ Test copyOf intrinsic with allocated value object in it's debug information\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test25Value {\n+        int x;\n+\n+        public Test25Value() {\n+            this.x = 42;\n+        }\n+    }\n+\n+    final Test25Value[] test25Array = (Test25Value[])ValueClass.newNullRestrictedArray(Test25Value.class, 10);\n+\n+    @Test\n+    public Test25Value[] test25(Test25Value element) {\n+        Object[] newArray = Arrays.copyOf(test25Array, test25Array.length + 1);\n+        newArray[test25Array.length] = element;\n+        return (Test25Value[]) newArray;\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        Test25Value vt = new Test25Value();\n+        test25(vt);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD_I) \/\/ Load of the default value should be folded\n+    public Object test26() {\n+        Class<?>[] ca = new Class<?>[1];\n+        for (int i = 0; i < 1; ++i) {\n+          \/\/ Folds during loop opts\n+          ca[i] = MyValue1.class;\n+        }\n+        return ValueClass.newNullRestrictedArray(ca[0], 1);\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        Object[] res = (Object[])test26();\n+        Asserts.assertEQ(((MyValue1)res[0]).hashPrimitive(), MyValue1.createDefaultInline().hashPrimitive());\n+    }\n+\n+    \/\/ Load non-flattenable value class field with unsafe\n+    MyValue1 test27_vt;\n+    private static final long TEST27_OFFSET;\n+    static {\n+        try {\n+            Field field = TestIntrinsics.class.getDeclaredField(\"test27_vt\");\n+            TEST27_OFFSET = U.objectFieldOffset(field);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test27() {\n+        return (MyValue1)U.getReference(this, TEST27_OFFSET);\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        test27_vt = null;\n+        MyValue1 res = test27();\n+        Asserts.assertEQ(res, null);\n+        test27_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        res = test27();\n+        Asserts.assertEQ(res.hash(), test24_vt.hash());\n+    }\n+\n+    \/\/ Mismatched type\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test28(MyValue1 v) {\n+        return U.getByte(v, X_OFFSET);\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        int res = test28(v);\n+        if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {\n+            Asserts.assertEQ(res, (int)((byte)v.x));\n+        } else {\n+            Asserts.assertEQ(res, (int)((byte)Integer.reverseBytes(v.x)));\n+        }\n+    }\n+\n+    \/\/ Wrong alignment\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public long test29(MyValue1 v) {\n+        \/\/ Read the field that's guaranteed to not be last in the\n+        \/\/ value class so we don't read out of bounds.\n+        if (X_OFFSET < Y_OFFSET) {\n+            return U.getInt(v, X_OFFSET+1);\n+        }\n+        return U.getLong(v, Y_OFFSET+1);\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        long res = test29(v);\n+        if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {\n+            if (X_OFFSET < Y_OFFSET) {\n+                Asserts.assertEQ(((int)res) << 8, (v.x >> 8) << 8);\n+            } else {\n+                Asserts.assertEQ(res << 8, (v.y >> 8) << 8);\n+            }\n+        } else {\n+            if (X_OFFSET < Y_OFFSET) {\n+                Asserts.assertEQ(((int)res), v.x >>> 8);\n+            } else {\n+                Asserts.assertEQ(res, v.y >>> 8);\n+            }\n+        }\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from value object\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test30(MyValue1 v) {\n+        if (V1_FLATTENED) {\n+            return U.getFlatValue(v, V1_OFFSET, V1_LAYOUT, MyValue2.class);\n+        }\n+        return (MyValue2)U.getReference(v, V1_OFFSET);\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier(RunInfo info) {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue2 res = test30(v);\n+        Asserts.assertEQ(res.hash(), v.v1.hash());\n+    }\n+\n+    @NullRestricted\n+    MyValue1 test31_vt;\n+    private static final long TEST31_VT_OFFSET;\n+    private static final boolean TEST31_VT_FLATTENED;\n+    private static final int TEST31_VT_LAYOUT;\n+    static {\n+        try {\n+            Field test31_vt_Field = TestIntrinsics.class.getDeclaredField(\"test31_vt\");\n+            TEST31_VT_OFFSET = U.objectFieldOffset(test31_vt_Field);\n+            TEST31_VT_FLATTENED = U.isFlatField(test31_vt_Field);\n+            TEST31_VT_LAYOUT = U.fieldLayout(test31_vt_Field);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from object\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test31() {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.getFlatValue(this, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class);\n+        }\n+        return (MyValue1)U.getReference(this, TEST31_VT_OFFSET);\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier() {\n+        test31_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test31();\n+        Asserts.assertEQ(res.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in object\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public void test32(MyValue1 vt) {\n+        if (TEST31_VT_FLATTENED) {\n+            U.putFlatValue(this, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, vt);\n+        } else {\n+            U.putReference(this, TEST31_VT_OFFSET, vt);\n+        }\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+        test32(vt);\n+        Asserts.assertEQ(vt.hash(), test31_vt.hash());\n+    }\n+\n+    private static final long TEST33_BASE_OFFSET;\n+    private static final int TEST33_INDEX_SCALE;\n+    private static final MyValue1[] TEST33_ARRAY;\n+    private static final boolean TEST33_FLATTENED_ARRAY;\n+    private static final int TEST33_LAYOUT;\n+    static {\n+        try {\n+            TEST33_ARRAY = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+            TEST33_BASE_OFFSET = U.arrayBaseOffset(TEST33_ARRAY.getClass());\n+            TEST33_INDEX_SCALE = U.arrayIndexScale(TEST33_ARRAY.getClass());\n+            TEST33_FLATTENED_ARRAY = U.isFlatArray(TEST33_ARRAY.getClass());\n+            TEST33_LAYOUT = U.arrayLayout(TEST33_ARRAY.getClass());\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    \/\/ getValue to retrieve flattened field from array\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test33() {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.getFlatValue(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, TEST33_LAYOUT, MyValue1.class);\n+        }\n+        return (MyValue1)U.getReference(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        TEST33_ARRAY[1] = vt;\n+        MyValue1 res = test33();\n+        Asserts.assertEQ(res.hash(), vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in array\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public void test34(MyValue1 vt) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            U.putFlatValue(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, TEST33_LAYOUT, MyValue1.class, vt);\n+        } else {\n+            U.putReference(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);\n+        }\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test34(vt);\n+        Asserts.assertEQ(TEST33_ARRAY[1].hash(), vt.hash());\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from object with unknown\n+    \/\/ container type\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test35(Object o) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.getFlatValue(o, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class);\n+        }\n+        return (MyValue1)U.getReference(o, TEST31_VT_OFFSET);\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier() {\n+        test31_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test35(this);\n+        Asserts.assertEQ(res.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from object at unknown\n+    \/\/ offset\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test36(long offset) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.getFlatValue(this, offset, TEST31_VT_LAYOUT, MyValue1.class);\n+        }\n+        return (MyValue1)U.getReference(this, offset);\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier() {\n+        test31_vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test36(TEST31_VT_OFFSET);\n+        Asserts.assertEQ(res.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in object with unknown\n+    \/\/ container\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public void test37(Object o, MyValue1 vt) {\n+        if (TEST31_VT_FLATTENED) {\n+            U.putFlatValue(o, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, vt);\n+        } else {\n+            U.putReference(o, TEST31_VT_OFFSET, vt);\n+        }\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+        test37(this, vt);\n+        Asserts.assertEQ(vt.hash(), test31_vt.hash());\n+    }\n+\n+    \/\/ putValue to set flattened field in object, non inline argument\n+    \/\/ to store\n+    @Test\n+    @IR(counts = {CALL_UNSAFE, \"= 1\"})\n+    public void test38(Object o) {\n+        if (TEST31_VT_FLATTENED) {\n+            U.putFlatValue(this, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, o);\n+        } else {\n+            U.putReference(this, TEST31_VT_OFFSET, o);\n+        }\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+        test38(vt);\n+        Asserts.assertEQ(vt.hash(), test31_vt.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue1 test39(MyValue1 v) {\n+        v = U.makePrivateBuffer(v);\n+        U.putInt(v, X_OFFSET, rI);\n+        v = U.finishPrivateBuffer(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test39(v.setX(v, 0));\n+        Asserts.assertEQ(res.hash(), v.hash());\n+    }\n+\n+    \/\/ Test default value class array creation via reflection\n+    @Test\n+    public Object[] test40(Class<?> componentType, int len) {\n+        Object[] va = (Object[])Array.newInstance(componentType, len);\n+        return va;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        Object[] va = test40(MyValue1.class, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Class.isInstance\n+    @Test\n+    public boolean test41(Class c, MyValue1 vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test41(MyValue1.class, vt);\n+        Asserts.assertTrue(result);\n+        result = test41(MyValue1.class, null);\n+        Asserts.assertFalse(result);\n+        result = test41(MyValue1.class, vt);\n+        Asserts.assertTrue(result);\n+        result = test41(MyValue1.class, null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    public boolean test42(Class c, MyValue1 vt) {\n+        return c.isInstance(vt);\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test42(MyValue2.class, vt);\n+        Asserts.assertFalse(result);\n+        result = test42(MyValue2.class, null);\n+        Asserts.assertFalse(result);\n+        result = test42(MyValue2.class, vt);\n+        Asserts.assertFalse(result);\n+        result = test42(MyValue2.class, null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Class.cast\n+    @Test\n+    public Object test43(Class c, MyValue1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test43(MyValue1.class, vt);\n+        Asserts.assertEQ(result, vt);\n+        result = test43(MyValue1.class, null);\n+        Asserts.assertEQ(result, null);\n+        result = test43(MyValue1.class, vt);\n+        Asserts.assertEQ(result, vt);\n+        result = test43(NonValueClass.class, null);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    @Test\n+    public Object test44(Class c, MyValue1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            test44(MyValue2.class, vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+        Object res = test44(MyValue2.class, null);\n+        Asserts.assertEQ(res, null);\n+        try {\n+            test44(MyValue2.class, vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test45(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test45(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test45(null);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    @Test\n+    public Object test46(MyValue1 vt) {\n+        return MyValue2.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test46(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test46(vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    @Test\n+    public Object test47(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test47(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test47(null);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    @Test\n+    public Object test48(Class c, MyValue1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test48(MyValue1.class, vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test48(MyValue1.class, null);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    @Test\n+    public Object test49(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test49(vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public Object test50(Class c, Object obj) {\n+        return c.cast(obj);\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1[] va  = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] vba = new MyValue1[42];\n+        Object result = test50(MyValue1.class, vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test50(MyValue1.class, vt);\n+        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        result = test50(MyValue1[].class, va);\n+        Asserts.assertEQ(result, va);\n+        result = test50(MyValue1[].class, vba);\n+        Asserts.assertEQ(result, vba);\n+        result = test50(MyValue1[].class, va);\n+        Asserts.assertEQ(result, va);\n+        result = test50(MyValue1.class, null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test50(va.getClass(), vba);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    \/\/ Value class array creation via reflection\n+    @Test\n+    public void test51(int len) {\n+        Object[] va = (Object[])Array.newInstance(MyValue1.class, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        test51(len);\n+    }\n+\n+    \/\/ multidimensional value class array creation via reflection\n+    @Test\n+    public Object[][] test52(int len, int val) {\n+        MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n+        MyValue1[][] va2 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n+        Object[][] result;\n+        if (val == 1) {\n+            va1[0] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            result = va1;\n+        } else {\n+            va2[0] = new MyValue1[1];\n+            result = va2;\n+        }\n+        if (val == 1) {\n+            Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());\n+        } else {\n+            Asserts.assertEQ(result[0][0], null);\n+            result[0][0] = null;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        test52(1, 1);\n+        test52(1, 2);\n+    }\n+\n+    @Test\n+    public Object[][] test53(Class<?> c1, Class<?> c2, int len, int val) {\n+        MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n+        MyValue1[][] va2 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n+        Object[][] va3 = (Object[][])Array.newInstance(c1, len);\n+        Object[][] va4 = (Object[][])Array.newInstance(c2, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va1[i], null);\n+            Asserts.assertEQ(va2[i], null);\n+            Asserts.assertEQ(va3[i], null);\n+            Asserts.assertEQ(va4[i], null);\n+            va1[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va2[i] = new MyValue1[1];\n+            va3[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va4[i] = new MyValue1[1];\n+            Asserts.assertEQ(va1[i][0].hash(), ((MyValue1)va3[i][0]).hash());\n+            Asserts.assertEQ(va2[i][0], null);\n+            Asserts.assertEQ(va4[i][0], null);\n+        }\n+        Object[][] result;\n+        if (val == 1) {\n+            result = va1;\n+        } else if (val == 2) {\n+            result = va2;\n+        } else if (val == 3) {\n+            result = va3;\n+        } else {\n+            result = va4;\n+        }\n+        if ((val == 1 || val == 3) && len > 0) {\n+            Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());\n+        } else if (len > 0) {\n+            Asserts.assertEQ(result[0][0], null);\n+            result[0][0] = null;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        int len = Math.abs(rI) % 42;\n+        test53(MyValue1[].class, MyValue1[].class, len, 1);\n+        test53(MyValue1[].class, MyValue1[].class, len, 2);\n+        test53(MyValue1[].class, MyValue1[].class, len, 3);\n+        test53(MyValue1[].class, MyValue1[].class, len, 4);\n+    }\n+\n+    \/\/ TODO 8239003 Re-enable\n+    \/*\n+    \/\/ Same as test39 but Unsafe.putInt to buffer is not intrinsified\/compiled\n+    @DontCompile\n+    public void test54_callee(Object v) { \/\/ Use Object here to make sure the argument is not scalarized (otherwise larval information is lost)\n+        U.putInt(v, X_OFFSET, rI);\n+    }\n+\n+    @Test\n+    public MyValue1 test54(MyValue1 v) {\n+        v = U.makePrivateBuffer(v);\n+        test54_callee(v);\n+        v = U.finishPrivateBuffer(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test54\")\n+    @Warmup(10000) \/\/ Fill up the TLAB to trigger slow path allocation\n+    public void test54_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 res = test54(v.setX(v, 0));\n+        Asserts.assertEQ(res.hash(), v.hash());\n+    }\n+    *\/\n+\n+    @NullRestricted\n+    static final MyValue1 test55_vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    \/\/ Same as test30 but with constant field holder\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test55() {\n+        if (V1_FLATTENED) {\n+            return U.getFlatValue(test55_vt, V1_OFFSET, V1_LAYOUT, MyValue2.class);\n+        }\n+        return (MyValue2)U.getReference(test55_vt, V1_OFFSET);\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        MyValue2 res = test55();\n+        Asserts.assertEQ(res.hash(), test55_vt.v1.hash());\n+    }\n+\n+    \/\/ Test OptimizePtrCompare part of Escape Analysis\n+    @Test\n+    public void test56(int idx) {\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        if (va[idx] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        test56(0);\n+    }\n+\n+    \/\/ Same as test56 but with load from known array index\n+    @Test\n+    public void test57() {\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        if (va[0] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        test57();\n+    }\n+\n+    \/\/ Test unsafe allocation\n+    @Test\n+    public boolean test58(Class<?> c1, Class<?> c2) throws Exception {\n+        Object obj1 = U.allocateInstance(c1);\n+        Object obj2 = U.allocateInstance(c2);\n+        return obj1 == obj2;\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier() throws Exception {\n+        boolean res = test58(MyValue1.class, MyValue1.class);\n+        Asserts.assertTrue(res);\n+        res = test58(Object.class, MyValue1.class);\n+        Asserts.assertFalse(res);\n+        res = test58(MyValue1.class, Object.class);\n+        Asserts.assertFalse(res);\n+    }\n+\n+    \/\/ Test synchronization on unsafe value object allocation\n+    @Test\n+    public void test59(Class<?> c) throws Exception {\n+        Object obj = U.allocateInstance(c);\n+        synchronized (obj) {\n+\n+        }\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() throws Exception {\n+        test59(Object.class);\n+        try {\n+            test59(MyValue1.class);\n+            throw new RuntimeException(\"test59 failed: synchronization on value object should not succeed\");\n+        } catch (IdentityException e) {\n+\n+        }\n+    }\n+\n+    \/\/ Test mark word load optimization on unsafe value object allocation\n+    @Test\n+    public boolean test60(Class<?> c1, Class<?> c2, boolean b1, boolean b2) throws Exception {\n+        Object obj1 = b1 ? new Object() : U.allocateInstance(c1);\n+        Object obj2 = b2 ? new Object() : U.allocateInstance(c2);\n+        return obj1 == obj2;\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() throws Exception {\n+        Asserts.assertTrue(test60(MyValue1.class, MyValue1.class, false, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue2.class, false, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, false, true));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, true));\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object\n+    @Test\n+    public boolean test63(MyValue1 oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetFlatValue(this, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+\n+        boolean res = test63(test31_vt, vt);\n+        \/\/ Checks are disabled for non-flattened field because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertTrue(res);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+\n+        res = test63(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertFalse(res);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+    }\n+\n+    \/\/ compareAndSet to flattened field in array\n+    @Test\n+    public boolean test64(MyValue1[] arr, MyValue1 oldVal, Object newVal) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.compareAndSetFlatValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, TEST33_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        boolean res = test64(arr, arr[1], vt);\n+        \/\/ Checks are disabled for non-flattened array because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertTrue(res);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+\n+        res = test64(arr, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertFalse(res);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object with unknown container\n+    @Test\n+    public boolean test65(Object o, Object oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetFlatValue(o, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(o, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+\n+        boolean res = test65(this, test31_vt, vt);\n+        Asserts.assertTrue(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test65(this, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        Asserts.assertFalse(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndSet to flattened field in object, non-inline arguments to compare and set\n+    @Test\n+    public boolean test66(Object oldVal, Object newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndSetFlatValue(this, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndSetReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test31_vt = MyValue1.createDefaultInline();\n+\n+        boolean res = test66(test31_vt, vt);\n+        Asserts.assertTrue(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test66(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        Asserts.assertFalse(res);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object\n+    @Test\n+    public Object test67(MyValue1 oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeFlatValue(this, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n+        test31_vt = oldVal;\n+\n+        Object res = test67(test31_vt, vt);\n+        \/\/ Checks are disabled for non-flattened field because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertEQ(res, oldVal);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+\n+        res = test67(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        if (TEST31_VT_FLATTENED) {\n+            Asserts.assertEQ(res, vt);\n+            Asserts.assertEQ(test31_vt, vt);\n+        }\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in array\n+    @Test\n+    public Object test68(MyValue1[] arr, MyValue1 oldVal, Object newVal) {\n+        if (TEST33_FLATTENED_ARRAY) {\n+            return U.compareAndExchangeFlatValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, TEST33_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        Object res = test68(arr, arr[1], vt);\n+        \/\/ Checks are disabled for non-flattened array because reference comparison\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertEQ(res, MyValue1.createDefaultInline());\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+\n+        res = test68(arr, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        if (TEST33_FLATTENED_ARRAY) {\n+            Asserts.assertEQ(res, vt);\n+            Asserts.assertEQ(arr[1], vt);\n+        }\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object with unknown container\n+    @Test\n+    public Object test69(Object o, Object oldVal, MyValue1 newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeFlatValue(o, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(o, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n+        test31_vt = oldVal;\n+\n+        Object res = test69(this, test31_vt, vt);\n+        Asserts.assertEQ(res, oldVal);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test69(this, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        Asserts.assertEQ(res, vt);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ compareAndExchange to flattened field in object, non-inline arguments to compare and set\n+    @Test\n+    public Object test70(Object oldVal, Object newVal) {\n+        if (TEST31_VT_FLATTENED) {\n+            return U.compareAndExchangeFlatValue(this, TEST31_VT_OFFSET, TEST31_VT_LAYOUT, MyValue1.class, oldVal, newVal);\n+        } else {\n+            return U.compareAndExchangeReference(this, TEST31_VT_OFFSET, oldVal, newVal);\n+        }\n+    }\n+\n+    @Run(test = \"test70\")\n+    public void test70_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n+        test31_vt = oldVal;\n+\n+        Object res = test70(test31_vt, vt);\n+        Asserts.assertEQ(res, oldVal);\n+        Asserts.assertEQ(test31_vt, vt);\n+\n+        res = test70(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n+        Asserts.assertEQ(res, vt);\n+        Asserts.assertEQ(test31_vt, vt);\n+    }\n+\n+    \/\/ getValue to retrieve flattened field from (nullable) value class\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test71(boolean b, MyValue1 v1, MyValue1 v2) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getFlatValue(v1, V1_OFFSET, V1_LAYOUT, MyValue2.class);\n+            }\n+            return (MyValue2)U.getReference(v1, V1_OFFSET);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getFlatValue(v2, V1_OFFSET, V1_LAYOUT, MyValue2.class);\n+            }\n+            return (MyValue2)U.getReference(v2, V1_OFFSET);\n+        }\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEQ(test71(true, v, v), v.v1);\n+        Asserts.assertEQ(test71(false, v, v), v.v1);\n+    }\n+\n+    \/\/ Same as test71 but with non-constant offset\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test72(boolean b, MyValue1 v1, MyValue1 v2, long offset) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getFlatValue(v1, offset, V1_LAYOUT, MyValue2.class);\n+            }\n+            return (MyValue2)U.getReference(v1, offset);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getFlatValue(v2, offset, V1_LAYOUT, MyValue2.class);\n+            }\n+            return (MyValue2)U.getReference(v2, offset);\n+        }\n+    }\n+\n+    @Run(test = \"test72\")\n+    public void test72_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEQ(test72(true, v, v, V1_OFFSET), v.v1);\n+        Asserts.assertEQ(test72(false, v, v, V1_OFFSET), v.v1);\n+    }\n+\n+    @NullRestricted\n+    static final MyValue1 test73_value1 = MyValue1.createWithFieldsInline(rI, rL);\n+    static final MyValue1 test73_value2 = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+\n+    \/\/ Same as test72 but with constant base\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public MyValue2 test73(boolean b, long offset) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getFlatValue(test73_value1, offset, V1_LAYOUT, MyValue2.class);\n+            }\n+            return (MyValue2)U.getReference(test73_value1, offset);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getFlatValue(test73_value2, offset, V1_LAYOUT, MyValue2.class);\n+            }\n+            return (MyValue2)U.getReference(test73_value2, offset);\n+        }\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        Asserts.assertEQ(test73(true, V1_OFFSET), test73_value1.v1);\n+        Asserts.assertEQ(test73(false, V1_OFFSET), test73_value2.v1);\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyInline {\n+\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ByteInline {\n+        byte x = 0;\n+    }\n+\n+    @Test\n+    public void test74(EmptyInline[] emptyArray) {\n+        System.arraycopy(emptyArray, 0, emptyArray, 10, 10);\n+        System.arraycopy(emptyArray, 0, emptyArray, 20, 10);\n+    }\n+\n+    @Run(test = \"test74\")\n+    public void test74_verifier() {\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n+        test74(emptyArray);\n+        for (EmptyInline empty : emptyArray) {\n+            Asserts.assertEQ(empty, new EmptyInline());\n+        }\n+    }\n+\n+    @Test\n+    public void test75(EmptyInline[] emptyArray) {\n+        System.arraycopy(emptyArray, 0, emptyArray, 10, 10);\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n+        test75(emptyArray);\n+        for (EmptyInline empty : emptyArray) {\n+            Asserts.assertEQ(empty, new EmptyInline());\n+        }\n+    }\n+\n+    @Test\n+    public void test76(ByteInline[] byteArray) {\n+        System.arraycopy(byteArray, 0, byteArray, 10, 10);\n+        System.arraycopy(byteArray, 0, byteArray, 20, 10);\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier() {\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n+        test76(byteArray);\n+        for (ByteInline b : byteArray) {\n+            Asserts.assertEQ(b, new ByteInline());\n+        }\n+    }\n+\n+    @Test\n+    public void test77(ByteInline[] byteArray) {\n+        System.arraycopy(byteArray, 0, byteArray, 10, 10);\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() {\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n+        test77(byteArray);\n+        for (ByteInline b : byteArray) {\n+            Asserts.assertEQ(b, new ByteInline());\n+        }\n+    }\n+\n+    @Test\n+    public Object test78(MyValue1 vt) {\n+        return NonValueClass.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() {\n+        Object result = test78(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test78(MyValue1.createWithFieldsInline(rI, rL));\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    \/\/ TODO 8284443 Fix this in GraphKit::gen_checkcast\n+    \/*\n+    @Test\n+    public Object test79(MyValue1 vt) {\n+        Object tmp = vt;\n+        return (NonValueClass)tmp;\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() {\n+        Object result = test79(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test79(MyValue1.createWithFieldsInline(rI, rL));\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+    *\/\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test80Value1 {\n+        @NullRestricted\n+        Test80Value2 v = new Test80Value2();\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test80Value2 {\n+        long l = rL;\n+        NonValueClass obj = new NonValueClass(rI);\n+    }\n+\n+    \/\/ Test that unsafe access is not incorrectly classified as mismatched\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public Test80Value2 test80(Test80Value1 v, boolean flat, int layout, long offset) {\n+        if (flat) {\n+            return U.getFlatValue(v, offset, layout, Test80Value2.class);\n+        } else {\n+            return (Test80Value2)U.getReference(v, offset);\n+        }\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() throws Exception {\n+        Test80Value1 v = new Test80Value1();\n+        Field field = Test80Value1.class.getDeclaredField(\"v\");\n+        Asserts.assertEQ(test80(v, U.isFlatField(field), U.fieldLayout(field), U.objectFieldOffset(field)), v.v);\n+    }\n+\n+    \/\/ Test correctness of the Unsafe::isFlatArray intrinsic\n+    @Test\n+    public boolean test81(Class<?> cls) {\n+        return U.isFlatArray(cls);\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        Asserts.assertEQ(test81(TEST33_ARRAY.getClass()), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n+        Asserts.assertFalse(test81(String[].class), \"test81_2 failed\");\n+        Asserts.assertFalse(test81(String.class), \"test81_3 failed\");\n+        Asserts.assertFalse(test81(int[].class), \"test81_4 failed\");\n+    }\n+\n+    \/\/ Verify that Unsafe::isFlatArray checks with statically known classes\n+    \/\/ are folded\n+    @Test\n+    @IR(failOn = {LOADK})\n+    public boolean test82() {\n+        boolean check1 = U.isFlatArray(TEST33_ARRAY.getClass());\n+        if (!TEST33_FLATTENED_ARRAY) {\n+            check1 = !check1;\n+        }\n+        boolean check2 = !U.isFlatArray(String[].class);\n+        boolean check3 = !U.isFlatArray(String.class);\n+        boolean check4 = !U.isFlatArray(int[].class);\n+        return check1 && check2 && check3 && check4;\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        Asserts.assertTrue(test82(), \"test82 failed\");\n+    }\n+\n+    \/\/ Test that LibraryCallKit::arraycopy_move_allocation_here works as expected\n+    @Test\n+    public MyValue1 test83(Object[] src) {\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+            Asserts.assertEQ(test83(src), src[0]);\n+        } else {\n+            \/\/ Trigger deoptimization to verify that re-execution works\n+            try {\n+                test83(new NonValueClass[10]);\n+                throw new RuntimeException(\"No NullPointerException thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    static value class MyValueClonable implements Cloneable {\n+        int x;\n+\n+        MyValueClonable(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public Object clone() throws CloneNotSupportedException {\n+            return super.clone();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC, \"1\"})\n+    public Object testClone() throws CloneNotSupportedException {\n+        MyValueClonable obj = new MyValueClonable(3);\n+        return obj.clone();\n+    }\n+\n+    @Run(test = \"testClone\")\n+    public void testClone_verifier() {\n+        try {\n+            testClone();\n+        } catch (Exception e) {\n+            Asserts.fail(\"testClone() failed\", e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":1713,"deletions":0,"binary":false,"changes":1713,"status":"added"},{"patch":"@@ -523,0 +523,5 @@\n+java\/lang\/ModuleLayer\/LayerControllerTest.java                  8337048 generic-all\n+java\/lang\/ModuleLayer\/BasicLayerTest.java                       8337048 generic-all\n+\n+java\/lang\/Thread\/virtual\/stress\/Skynet.java#default             8342977 generic-all\n+\n@@ -729,0 +734,4 @@\n+com\/sun\/jdi\/cds\/CDSBreakpointTest.java                          8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSDeleteAllBkptsTest.java                      8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSFieldWatchpoints.java                        8304168 generic-all\n+\n@@ -773,0 +782,6 @@\n+jdk\/classfile\/SwapTest.java                                     8308778 generic-all\n+jdk\/classfile\/LowAdaptTest.java                                 8308778 generic-all\n+jdk\/classfile\/BuilderBlockTest.java                             8308778 generic-all\n+jdk\/classfile\/BuilderTryCatchTest.java                          8308778 generic-all\n+jdk\/classfile\/PrimitiveClassConstantTest.java                   8310649 generic-all\n+\n@@ -819,0 +834,3 @@\n+\n+# valhalla\n+jdk\/jfr\/event\/runtime\/TestSyncOnValueBasedClassEvent.java 8328777 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+        vmOptFinalFlag(map, \"TieredCompilation\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}