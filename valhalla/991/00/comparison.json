{"files":[{"patch":"@@ -1953,0 +1953,3 @@\n+      if (field->is_null_free()) {\n+        null_check(val);\n+      }\n@@ -2130,0 +2133,1 @@\n+        null_check(val);\n@@ -2131,0 +2135,3 @@\n+        if (field->is_null_free()) {\n+          null_check(val);\n+        }\n@@ -2212,0 +2219,3 @@\n+  if (field_modify->is_null_free()) {\n+    null_check(val);\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2082,3 +2082,0 @@\n-  if (!field->is_null_free()) {\n-    return true; \/\/ Not an inline type field\n-  }\n@@ -2088,1 +2085,2 @@\n-  bool could_be_flat = !x->is_static() && x->needs_patching();\n+  bool could_be_flat = field->type()->is_inlinetype() && InlineFieldMaxFlatSize >= 0 &&\n+                       !x->is_static() && x->needs_patching();\n@@ -2091,1 +2089,2 @@\n-  bool not_initialized = x->is_static() && x->as_LoadField() != nullptr &&\n+  \/\/ TODO 8325106 It seems that this fix for JDK-8273594 is not needed anymore or our tests don't trigger the issue anymore\n+  bool not_initialized = false && x->is_static() && x->as_LoadField() != nullptr &&\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  case vmIntrinsics::_newNullRestrictedArray:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -338,0 +338,3 @@\n+  do_intrinsic(_newNullRestrictedArray,   jdk_internal_value_ValueClass, newNullRestrictedArray_name, newNullRestrictedArray_signature, F_SN) \\\n+   do_signature(newNullRestrictedArray_signature,                 \"(Ljava\/lang\/Class;I)[Ljava\/lang\/Object;\")            \\\n+   do_name(     newNullRestrictedArray_name,                      \"newNullRestrictedArray\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -808,0 +808,1 @@\n+  template(jdk_internal_value_ValueClass,                   \"jdk\/internal\/value\/ValueClass\")                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-      if (!entry->is_flat() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n+      if (!entry->is_null_free_inline_type() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n@@ -368,0 +368,3 @@\n+          if (ref_h() == nullptr) {\n+            THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n+          }\n@@ -369,3 +372,0 @@\n-            if (ref_h() == nullptr) {\n-              THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n-            }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -739,0 +739,1 @@\n+  case vmIntrinsics::_newNullRestrictedArray:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2400,0 +2400,4 @@\n+      \/\/ TODO 8325106 TestLWorld::test118 will fail with -DWarmup=10000 -DVerifyIR=false\n+      \/\/ because Parse::do_acmp uses Parse::do_if with custom ctrl_taken which puts uncommon traps on some paths and sets the next_bci incorrectly\n+      \/\/ It also seems that TestOptimizeUnstableIf is not working. It still passes, even if this optimization is turned off.\n+      if (jvms->should_reexecute()) continue;\n@@ -2424,1 +2428,1 @@\n-        if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+        if (!live_locals.at(i) && !local->is_top() && local != lhs && local != rhs) {\n@@ -2439,1 +2443,1 @@\n-    \/\/ keep the mondified trap for late query\n+    \/\/ keep the modified trap for late query\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -302,2 +302,26 @@\n-  bool use_oop = allow_oop && is_allocated(igvn) &&\n-                 (oop->is_Con() || oop->is_Parm() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n+  \/\/ TODO 8325106\n+  \/\/ TestBasicFunctionality::test3 fails without this. Add more tests?\n+  \/\/ Add proj nodes here? Recursive handling of phis required? We need a test that fails without.\n+  bool use_oop = false;\n+  if (allow_oop && is_allocated(igvn) && oop->is_Phi()) {\n+    Unique_Node_List worklist;\n+    worklist.push(oop);\n+    use_oop = true;\n+    while (worklist.size() > 0 && use_oop) {\n+      Node* n = worklist.pop();\n+      for (uint i = 1; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in->is_Phi()) {\n+          worklist.push(in);\n+        \/\/ TestNullableArrays.test123 fails when enabling this, probably we should make sure that we don't load from a just allocated object\n+        \/\/} else if (!(in->is_Con() || in->is_Parm() || in->is_Load() || (in->isa_DecodeN() && in->in(1)->is_Load()))) {\n+        } else if (!(in->is_Con() || in->is_Parm())) {\n+          use_oop = false;\n+          break;\n+        }\n+      }\n+    }\n+  } else {\n+    use_oop = allow_oop && is_allocated(igvn) &&\n+              (oop->is_Con() || oop->is_Parm() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n+  }\n@@ -743,1 +767,2 @@\n-  Node* oop = (vk->is_empty() && vk->is_initialized()) ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n+  bool use_default_oop = vk->is_empty() && vk->is_initialized() && null_free;\n+  Node* oop = use_default_oop ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n@@ -745,1 +770,1 @@\n-  vt->set_is_buffered(gvn, vk->is_empty() && vk->is_initialized());\n+  vt->set_is_buffered(gvn, use_default_oop);\n@@ -1230,7 +1255,0 @@\n-Node* InlineTypeNode::Identity(PhaseGVN* phase) {\n-  if (get_oop()->is_InlineType()) {\n-    return get_oop();\n-  }\n-  return this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,2 +156,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n-\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -527,0 +527,1 @@\n+  case vmIntrinsics::_newNullRestrictedArray:   return inline_newNullRestrictedArray();\n@@ -4421,0 +4422,27 @@\n+\/\/-----------------------inline_newNullRestrictedArray--------------------------\n+\/\/ public static native Object[] newNullRestrictedArray(Class<?> componentType, int length);\n+bool LibraryCallKit::inline_newNullRestrictedArray() {\n+  \/\/ TODO 8325106\n+  \/\/ Improve this and add required runtime checks\n+  Node* componentType = argument(0);\n+  Node* length = argument(1);\n+\n+  const TypeInstPtr* tp = _gvn.type(componentType)->isa_instptr();\n+  if (tp != nullptr) {\n+    ciInstanceKlass* ik = tp->instance_klass();\n+    if (ik == C->env()->Class_klass()) {\n+      bool null_free;\n+      ciType* t = tp->java_mirror_type(&null_free);\n+      if (t != nullptr && t->is_inlinetype()) {\n+        ciArrayKlass* array_klass = ciArrayKlass::make(t, true);\n+        if (array_klass->is_loaded() && array_klass->element_klass()->as_inline_klass()->is_initialized()) {\n+          const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n+          Node* obj = new_array(makecon(array_klass_type), length, 0);  \/\/ no arguments to push\n+          set_result(obj);\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -5552,0 +5580,6 @@\n+        \/\/ TODO 8325106\n+        \/\/ TestArrays::test94 hits an assert because we create a wrong JVMState for before the newNullRestrictedArray intrinsic because above code does not account for the class argument on stack in addition to the size\n+        \/\/ See https:\/\/github.com\/openjdk\/jdk\/commit\/5a478ef7759e64da6d17426673700ff0d9c66b33\n+        \/\/ Check why this isn't optimized for Array.newInstance(MyValue.class, 10);\n+        \/\/ Re-enable IR matching in TestArrays::test29 and TestNullableArrays::test29 and deopt checks in TestArrayCopyNoInitDeopt\n+        return nullptr;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+  bool inline_newNullRestrictedArray();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2124,0 +2124,1 @@\n+      jvms()->set_should_reexecute(true);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -235,0 +235,6 @@\n+  if (field->is_null_free()) {\n+    PreserveReexecuteState preexecs(this);\n+    inc_sp(1);\n+    jvms()->set_should_reexecute(true);\n+    val = null_check(val);\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -350,0 +350,10 @@\n+  if (field->is_null_free()) {\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    int nargs = 1 + field->type()->size();\n+    inc_sp(nargs);\n+    val = null_check(val);\n+    if (stopped()) {\n+      return;\n+    }\n+  }\n@@ -352,1 +362,0 @@\n-    assert(!field->is_null_free() || !gvn().type(val)->maybe_null(), \"Null store to null-free field\");\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2183,0 +2183,1 @@\n+    \/\/ TODO 8325106 The field could be null free, right? Shouldn't we set the type to null-free here?\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -74,0 +75,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-                throw new RuntimeException(\"m1 not deoptimized\");\n+                \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n+                \/\/ throw new RuntimeException(\"m1 not deoptimized\");\n@@ -144,1 +145,2 @@\n-                    throw new RuntimeException(\"m2 not deoptimized\");\n+                    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n+                    \/\/ throw new RuntimeException(\"m2 not deoptimized\");\n@@ -155,1 +157,2 @@\n-                    throw new RuntimeException(\"m2 not deoptimized\");\n+                    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n+                    \/\/ throw new RuntimeException(\"m2 not deoptimized\");\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyNoInitDeopt.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2024, Red Hat, Inc. All rights reserved.\n@@ -26,0 +26,4 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -29,4 +33,6 @@\n- * @compile -XDenablePrimitiveClasses BlackholeTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n- *      -Xbatch\n- *      -XX:+UnlockExperimentalVMOptions\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED BlackholeTest.java\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *      --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *      --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *      -Xbatch -XX:+UnlockExperimentalVMOptions\n@@ -38,1 +44,3 @@\n-    static primitive class MyValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue {\n@@ -42,0 +50,1 @@\n+    @NullRestricted\n@@ -43,0 +52,1 @@\n+    @NullRestricted\n@@ -48,1 +58,0 @@\n-            testDefault();\n@@ -55,1 +64,1 @@\n-        for (int c = 0; c < 100000; c++) {\n+        for (int c = 0; c < 100_000; c++) {\n@@ -60,6 +69,0 @@\n-    private static void testDefault() {\n-        for (int c = 0; c < 100000; c++) {\n-            blackhole(MyValue.default);\n-        }\n-    }\n-\n@@ -67,1 +70,1 @@\n-        for (int c = 0; c < 100000; c++) {\n+        for (int c = 0; c < 100_000; c++) {\n@@ -73,1 +76,1 @@\n-        for (int c = 0; c < 100000; c++) {\n+        for (int c = 0; c < 100_000; c++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/BlackholeTest.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated from the following class files with PointN.x removed and RectangleP.p1 made private\n+\/\/ java org.openjdk.asmtools.Main jdec NamedRectangleN.class NamedRectangleP.class PointN.class RectangleN.class RectangleP.class\n+\n+\/*\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class PointN {\n+    int x = 4; \/\/ Removed\n+    int y = 7;\n+}\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class RectangleN {\n+    @NullRestricted\n+    PointN p1 = new PointN();\n+}\n+\n+class NamedRectangleN {\n+    @NullRestricted\n+    RectangleN rect = new RectangleN();\n+    String name = \"\";\n+\n+    static int getP1X(NamedRectangleN nr) {\n+        return nr.rect.p1.x;\n+    }\n+}\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class RectangleP {\n+    @NullRestricted\n+    PointN p1 = new PointN(); \/\/ Made private\n+}\n+\n+class NamedRectangleP {\n+    @NullRestricted\n+    RectangleP rect = new RectangleP();\n+    String name = \"\";\n+\n+    static int getP1Y(NamedRectangleP nr) {\n+        return nr.rect.p1.y;\n+    }\n+}\n+*\/\n+\n@@ -15,1 +90,1 @@\n-    NameAndType #42 #11; \/\/ #9\n+    NameAndType #11 #12; \/\/ #9\n@@ -17,32 +92,33 @@\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #11\n-    Field #13 #14; \/\/ #12\n-    class #15; \/\/ #13\n-    NameAndType #16 #17; \/\/ #14\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #15\n-    Utf8 \"rect\"; \/\/ #16\n-    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #17\n-    String #19; \/\/ #18\n-    Utf8 \"\"; \/\/ #19\n-    Field #13 #21; \/\/ #20\n-    NameAndType #22 #23; \/\/ #21\n-    Utf8 \"name\"; \/\/ #22\n-    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n-    Field #8 #25; \/\/ #24\n-    NameAndType #26 #27; \/\/ #25\n-    Utf8 \"p1\"; \/\/ #26\n-    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #27\n-    Field #29 #30; \/\/ #28\n-    class #31; \/\/ #29\n-    NameAndType #32 #33; \/\/ #30\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #31\n-    Utf8 \"x\"; \/\/ #32\n-    Utf8 \"I\"; \/\/ #33\n-    Utf8 \"Code\"; \/\/ #34\n-    Utf8 \"LineNumberTable\"; \/\/ #35\n-    Utf8 \"getP1X\"; \/\/ #36\n-    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #37\n-    Utf8 \"getP1\"; \/\/ #38\n-    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #39\n-    Utf8 \"SourceFile\"; \/\/ #40\n-    Utf8 \"NamedRectangleN.java\"; \/\/ #41\n-    Utf8 \"<vnew>\"; \/\/ #42\n+    Utf8 \"<vnew>\"; \/\/ #11\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #12\n+    Field #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #17 #18; \/\/ #15\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #16\n+    Utf8 \"rect\"; \/\/ #17\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #18\n+    String #20; \/\/ #19\n+    Utf8 \"\"; \/\/ #20\n+    Field #14 #22; \/\/ #21\n+    NameAndType #23 #24; \/\/ #22\n+    Utf8 \"name\"; \/\/ #23\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #24\n+    Field #8 #26; \/\/ #25\n+    NameAndType #27 #28; \/\/ #26\n+    Utf8 \"p1\"; \/\/ #27\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #28\n+    Field #30 #31; \/\/ #29\n+    class #32; \/\/ #30\n+    NameAndType #33 #34; \/\/ #31\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #32\n+    Utf8 \"x\"; \/\/ #33\n+    Utf8 \"I\"; \/\/ #34\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #35\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #36\n+    Utf8 \"Code\"; \/\/ #37\n+    Utf8 \"LineNumberTable\"; \/\/ #38\n+    Utf8 \"getP1X\"; \/\/ #39\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #40\n+    Utf8 \"SourceFile\"; \/\/ #41\n+    Utf8 \"Test.java\"; \/\/ #42\n+    Utf8 \"Preload\"; \/\/ #43\n@@ -51,2 +127,2 @@\n-  0x0021; \/\/ access\n-  #13;\/\/ this_cpx\n+  0x0020; \/\/ access\n+  #14;\/\/ this_cpx\n@@ -61,2 +137,2 @@\n-      #16; \/\/ name_index\n-      #17; \/\/ descriptor_index\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n@@ -64,0 +140,9 @@\n+        Attr(#35) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #36;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n@@ -69,2 +154,2 @@\n-      #22; \/\/ name_index\n-      #23; \/\/ descriptor_index\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n@@ -78,1 +163,1 @@\n-      0x0001; \/\/ access\n+      0x0000; \/\/ access\n@@ -82,1 +167,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#37) { \/\/ Code\n@@ -87,2 +172,2 @@\n-            0xB5000C2A1212B500;\n-            0x14B1;\n+            0xB5000D2A1213B500;\n+            0x15B1;\n@@ -93,1 +178,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#38) { \/\/ LineNumberTable\n@@ -95,3 +180,4 @@\n-                0  26;\n-                4  27;\n-                11  28;\n+                0  21;\n+                4  22;\n+                5  23;\n+                11  24;\n@@ -107,2 +193,2 @@\n-      #36; \/\/ name_index\n-      #37; \/\/ descriptor_index\n+      #39; \/\/ name_index\n+      #40; \/\/ descriptor_index\n@@ -110,1 +196,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#37) { \/\/ Code\n@@ -114,2 +200,2 @@\n-            0x2AB4000CB40018B4;\n-            0x001CAC;\n+            0x2AB4000DB40019B4;\n+            0x001DAC;\n@@ -120,1 +206,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#38) { \/\/ LineNumberTable\n@@ -122,25 +208,1 @@\n-                0  31;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method\n-      0x0008; \/\/ access\n-      #38; \/\/ name_index\n-      #39; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#34) { \/\/ Code\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[]{\n-            0x2AB4000CB40018B0;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#35) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  37;\n+                0  27;\n@@ -156,2 +218,2 @@\n-    Attr(#40) { \/\/ SourceFile\n-      #41;\n+    Attr(#41) { \/\/ SourceFile\n+      #42;\n@@ -159,0 +221,6 @@\n+    ;\n+    Attr(#43) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n@@ -161,1 +229,0 @@\n-\n@@ -176,1 +243,1 @@\n-    NameAndType #42 #11; \/\/ #9\n+    NameAndType #11 #12; \/\/ #9\n@@ -178,32 +245,33 @@\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #11\n-    Field #13 #14; \/\/ #12\n-    class #15; \/\/ #13\n-    NameAndType #16 #17; \/\/ #14\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #15\n-    Utf8 \"rect\"; \/\/ #16\n-    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #17\n-    String #19; \/\/ #18\n-    Utf8 \"\"; \/\/ #19\n-    Field #13 #21; \/\/ #20\n-    NameAndType #22 #23; \/\/ #21\n-    Utf8 \"name\"; \/\/ #22\n-    Utf8 \"Ljava\/lang\/String;\"; \/\/ #23\n-    Field #8 #25; \/\/ #24\n-    NameAndType #26 #27; \/\/ #25\n-    Utf8 \"p1\"; \/\/ #26\n-    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #27\n-    Field #29 #30; \/\/ #28\n-    class #31; \/\/ #29\n-    NameAndType #32 #33; \/\/ #30\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #31\n-    Utf8 \"x\"; \/\/ #32\n-    Utf8 \"I\"; \/\/ #33\n-    Utf8 \"Code\"; \/\/ #34\n-    Utf8 \"LineNumberTable\"; \/\/ #35\n-    Utf8 \"getP1X\"; \/\/ #36\n-    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #37\n-    Utf8 \"getP1\"; \/\/ #38\n-    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #39\n-    Utf8 \"SourceFile\"; \/\/ #40\n-    Utf8 \"NamedRectangleP.java\"; \/\/ #41\n-    Utf8 \"<vnew>\"; \/\/ #42\n+    Utf8 \"<vnew>\"; \/\/ #11\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #12\n+    Field #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #17 #18; \/\/ #15\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #16\n+    Utf8 \"rect\"; \/\/ #17\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #18\n+    String #20; \/\/ #19\n+    Utf8 \"\"; \/\/ #20\n+    Field #14 #22; \/\/ #21\n+    NameAndType #23 #24; \/\/ #22\n+    Utf8 \"name\"; \/\/ #23\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #24\n+    Field #8 #26; \/\/ #25\n+    NameAndType #27 #28; \/\/ #26\n+    Utf8 \"p1\"; \/\/ #27\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #28\n+    Field #30 #31; \/\/ #29\n+    class #32; \/\/ #30\n+    NameAndType #33 #34; \/\/ #31\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #32\n+    Utf8 \"y\"; \/\/ #33\n+    Utf8 \"I\"; \/\/ #34\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #35\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #36\n+    Utf8 \"Code\"; \/\/ #37\n+    Utf8 \"LineNumberTable\"; \/\/ #38\n+    Utf8 \"getP1Y\"; \/\/ #39\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #40\n+    Utf8 \"SourceFile\"; \/\/ #41\n+    Utf8 \"Test.java\"; \/\/ #42\n+    Utf8 \"Preload\"; \/\/ #43\n@@ -212,2 +280,2 @@\n-  0x0021; \/\/ access\n-  #13;\/\/ this_cpx\n+  0x0020; \/\/ access\n+  #14;\/\/ this_cpx\n@@ -222,2 +290,2 @@\n-      #16; \/\/ name_index\n-      #17; \/\/ descriptor_index\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n@@ -225,0 +293,9 @@\n+        Attr(#35) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #36;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n@@ -230,2 +307,2 @@\n-      #22; \/\/ name_index\n-      #23; \/\/ descriptor_index\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n@@ -239,1 +316,1 @@\n-      0x0001; \/\/ access\n+      0x0000; \/\/ access\n@@ -243,1 +320,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#37) { \/\/ Code\n@@ -248,29 +325,2 @@\n-            0xB5000C2A1212B500;\n-            0x14B1;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#35) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  26;\n-                4  27;\n-                11  28;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method\n-      0x0008; \/\/ access\n-      #36; \/\/ name_index\n-      #37; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#34) { \/\/ Code\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[]{\n-            0x2AB4000CB40018B4;\n-            0x001CAC;\n+            0xB5000D2A1213B500;\n+            0x15B1;\n@@ -281,1 +331,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#38) { \/\/ LineNumberTable\n@@ -283,1 +333,4 @@\n-                0  31;\n+                0  38;\n+                4  39;\n+                5  40;\n+                11  41;\n@@ -293,2 +346,2 @@\n-      #38; \/\/ name_index\n-      #39; \/\/ descriptor_index\n+      #39; \/\/ name_index\n+      #40; \/\/ descriptor_index\n@@ -296,1 +349,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#37) { \/\/ Code\n@@ -300,1 +353,2 @@\n-            0x2AB4000CB40018B0;\n+            0x2AB4000DB40019B4;\n+            0x001DAC;\n@@ -305,1 +359,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#38) { \/\/ LineNumberTable\n@@ -307,1 +361,1 @@\n-                0  37;\n+                0  44;\n@@ -317,2 +371,2 @@\n-    Attr(#40) { \/\/ SourceFile\n-      #41;\n+    Attr(#41) { \/\/ SourceFile\n+      #42;\n@@ -320,0 +374,6 @@\n+    ;\n+    Attr(#43) { \/\/ Preload\n+      [] { \/\/ classes\n+        #8;\n+      }\n+    } \/\/ end Preload\n@@ -322,1 +382,0 @@\n-\n@@ -333,1 +392,1 @@\n-    Utf8 \"x1\"; \/\/ #5                \/\/ field name changed from x to x1\n+    Utf8 \"y\"; \/\/ #5\n@@ -335,31 +394,11 @@\n-    Field #1 #8; \/\/ #7\n-    NameAndType #9 #6; \/\/ #8\n-    Utf8 \"y\"; \/\/ #9\n-    InvokeDynamic 0s #11; \/\/ #10\n-    NameAndType #12 #13; \/\/ #11\n-    Utf8 \"toString\"; \/\/ #12\n-    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/PointN;)Ljava\/lang\/String;\"; \/\/ #13\n-    class #15; \/\/ #14\n-    Utf8 \"java\/lang\/Object\"; \/\/ #15\n-    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #16\n-    Utf8 \"Code\"; \/\/ #17\n-    Utf8 \"LineNumberTable\"; \/\/ #18\n-    Utf8 \"<vnew>\"; \/\/ #19\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #20\n-    Utf8 \"SourceFile\"; \/\/ #21\n-    Utf8 \"PointN.java\"; \/\/ #22\n-    Utf8 \"NestHost\"; \/\/ #23\n-    Utf8 \"BootstrapMethods\"; \/\/ #24\n-    MethodHandle 6b #26; \/\/ #25\n-    Method #27 #28; \/\/ #26\n-    class #29; \/\/ #27\n-    NameAndType #30 #31; \/\/ #28\n-    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #29\n-    Utf8 \"makeBootstrapMethod\"; \/\/ #30\n-    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #31\n-    Utf8 \"InnerClasses\"; \/\/ #32\n-    class #34; \/\/ #33\n-    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #34\n-    class #36; \/\/ #35\n-    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #36\n-    Utf8 \"Lookup\"; \/\/ #37\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8\n+    Utf8 \"<vnew>\"; \/\/ #9\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"Test.java\"; \/\/ #14\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #15\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\"; \/\/ #16\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #17\n@@ -368,1 +407,1 @@\n-  0x0851; \/\/ access\n+  0x0050; \/\/ access\n@@ -370,1 +409,1 @@\n-  #14;\/\/ super_cpx\n+  #7;\/\/ super_cpx\n@@ -383,8 +422,0 @@\n-    ;\n-    {  \/\/ field\n-      0x0010; \/\/ access\n-      #9; \/\/ name_index\n-      #6; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-      } \/\/ Attributes\n-    }\n@@ -395,27 +426,3 @@\n-      0x0011; \/\/ access\n-      #12; \/\/ name_index\n-      #16; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#17) { \/\/ Code\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[]{\n-            0x2ABA000A0000B0;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#18) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  26;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method\n-      0x0009; \/\/ access\n-      #19; \/\/ name_index\n-      #20; \/\/ descriptor_index\n+      0x0008; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n@@ -423,1 +430,1 @@\n-        Attr(#17) { \/\/ Code\n+        Attr(#11) { \/\/ Code\n@@ -427,3 +434,2 @@\n-            0xCB00014B072A5FCC;\n-            0x00034B10072A5FCC;\n-            0x00074B2AB0;\n+            0xCB00014B10072A5F;\n+            0xCC00034B2AB0;\n@@ -434,1 +440,1 @@\n-            Attr(#18) { \/\/ LineNumberTable\n+            Attr(#12) { \/\/ LineNumberTable\n@@ -436,3 +442,2 @@\n-                0  26;\n-                4  27;\n-                11  28;\n+                0  9;\n+                4  11;\n@@ -448,5 +453,1 @@\n-    Attr(#21) { \/\/ SourceFile\n-      #22;\n-    } \/\/ end SourceFile\n-    ;\n-    Attr(#23) { \/\/ NestHost\n+    Attr(#13) { \/\/ SourceFile\n@@ -454,11 +455,1 @@\n-    } \/\/ end NestHost\n-    ;\n-    Attr(#24) { \/\/ BootstrapMethods\n-      [] { \/\/ bootstrap_methods\n-        {  \/\/  bootstrap_method\n-          #25; \/\/ bootstrap_method_ref\n-          [] { \/\/ bootstrap_arguments\n-          }  \/\/  bootstrap_arguments\n-        }  \/\/  bootstrap_method\n-      }\n-    } \/\/ end BootstrapMethods\n+    } \/\/ end SourceFile\n@@ -466,3 +457,13 @@\n-    Attr(#32) { \/\/ InnerClasses\n-      [] { \/\/ classes\n-        #33 #35 #37 25;\n+    Attr(#15) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #16;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+        ;\n+        {  \/\/  annotation\n+          #17;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n@@ -470,1 +471,1 @@\n-    } \/\/ end InnerClasses\n+    } \/\/ end RuntimeVisibleAnnotations\n@@ -473,1 +474,0 @@\n-\n@@ -487,1 +487,1 @@\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #8\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #8\n@@ -490,32 +490,14 @@\n-    Utf8 \"p0\"; \/\/ #11\n-    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n-    Field #1 #14; \/\/ #13\n-    NameAndType #15 #12; \/\/ #14\n-    Utf8 \"p1\"; \/\/ #15\n-    InvokeDynamic 0s #17; \/\/ #16\n-    NameAndType #18 #19; \/\/ #17\n-    Utf8 \"toString\"; \/\/ #18\n-    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleN;)Ljava\/lang\/String;\"; \/\/ #19\n-    class #21; \/\/ #20\n-    Utf8 \"java\/lang\/Object\"; \/\/ #21\n-    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n-    Utf8 \"Code\"; \/\/ #23\n-    Utf8 \"LineNumberTable\"; \/\/ #24\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #25\n-    Utf8 \"SourceFile\"; \/\/ #26\n-    Utf8 \"RectangleN.java\"; \/\/ #27\n-    Utf8 \"NestHost\"; \/\/ #28\n-    Utf8 \"BootstrapMethods\"; \/\/ #29\n-    MethodHandle 6b #31; \/\/ #30\n-    Method #32 #33; \/\/ #31\n-    class #34; \/\/ #32\n-    NameAndType #35 #36; \/\/ #33\n-    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n-    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n-    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n-    Utf8 \"InnerClasses\"; \/\/ #37\n-    class #39; \/\/ #38\n-    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n-    class #41; \/\/ #40\n-    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n-    Utf8 \"Lookup\"; \/\/ #42\n+    Utf8 \"p1\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/Object\"; \/\/ #14\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #15\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #16\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"Test.java\"; \/\/ #21\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\"; \/\/ #22\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #23\n+    Utf8 \"Preload\"; \/\/ #24\n@@ -524,1 +506,1 @@\n-  0x0851; \/\/ access\n+  0x0050; \/\/ access\n@@ -526,1 +508,1 @@\n-  #20;\/\/ super_cpx\n+  #13;\/\/ super_cpx\n@@ -537,8 +519,9 @@\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ field\n-      0x0010; \/\/ access\n-      #15; \/\/ name_index\n-      #12; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #16;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n@@ -551,25 +534,1 @@\n-      0x0011; \/\/ access\n-      #18; \/\/ name_index\n-      #22; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#23) { \/\/ Code\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[]{\n-            0x2ABA00100000B0;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#24) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  26;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method\n-      0x0009; \/\/ access\n+      0x0008; \/\/ access\n@@ -577,1 +536,1 @@\n-      #25; \/\/ descriptor_index\n+      #17; \/\/ descriptor_index\n@@ -579,1 +538,1 @@\n-        Attr(#23) { \/\/ Code\n+        Attr(#18) { \/\/ Code\n@@ -584,2 +543,1 @@\n-            0x5FCC00094BB80003;\n-            0x2A5FCC000D4B2AB0;\n+            0x5FCC00094B2AB0;\n@@ -590,1 +548,1 @@\n-            Attr(#24) { \/\/ LineNumberTable\n+            Attr(#19) { \/\/ LineNumberTable\n@@ -592,3 +550,3 @@\n-                0  26;\n-                4  27;\n-                13  28;\n+                0  16;\n+                4  18;\n+                13  17;\n@@ -604,2 +562,2 @@\n-    Attr(#26) { \/\/ SourceFile\n-      #27;\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n@@ -608,11 +566,13 @@\n-    Attr(#28) { \/\/ NestHost\n-      #20;\n-    } \/\/ end NestHost\n-    ;\n-    Attr(#29) { \/\/ BootstrapMethods\n-      [] { \/\/ bootstrap_methods\n-        {  \/\/  bootstrap_method\n-          #30; \/\/ bootstrap_method_ref\n-          [] { \/\/ bootstrap_arguments\n-          }  \/\/  bootstrap_arguments\n-        }  \/\/  bootstrap_method\n+    Attr(#15) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #22;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+        ;\n+        {  \/\/  annotation\n+          #23;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n@@ -620,1 +580,1 @@\n-    } \/\/ end BootstrapMethods\n+    } \/\/ end RuntimeVisibleAnnotations\n@@ -622,1 +582,1 @@\n-    Attr(#37) { \/\/ InnerClasses\n+    Attr(#24) { \/\/ Preload\n@@ -624,1 +584,1 @@\n-        #38 #40 #42 25;\n+        #4;\n@@ -626,1 +586,1 @@\n-    } \/\/ end InnerClasses\n+    } \/\/ end Preload\n@@ -629,1 +589,0 @@\n-\n@@ -641,1 +600,1 @@\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/Point\"; \/\/ #6\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #6\n@@ -643,1 +602,1 @@\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #8\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #8\n@@ -646,32 +605,14 @@\n-    Utf8 \"p0\"; \/\/ #11\n-    Utf8 \"Qcompiler\/valhalla\/inlinetypes\/Point;\"; \/\/ #12\n-    Field #1 #14; \/\/ #13\n-    NameAndType #15 #12; \/\/ #14\n-    Utf8 \"p1\"; \/\/ #15\n-    InvokeDynamic 0s #17; \/\/ #16\n-    NameAndType #18 #19; \/\/ #17\n-    Utf8 \"toString\"; \/\/ #18\n-    Utf8 \"(Qcompiler\/valhalla\/inlinetypes\/RectangleP;)Ljava\/lang\/String;\"; \/\/ #19\n-    class #21; \/\/ #20\n-    Utf8 \"java\/lang\/Object\"; \/\/ #21\n-    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #22\n-    Utf8 \"Code\"; \/\/ #23\n-    Utf8 \"LineNumberTable\"; \/\/ #24\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #25\n-    Utf8 \"SourceFile\"; \/\/ #26\n-    Utf8 \"RectangleP.java\"; \/\/ #27\n-    Utf8 \"NestHost\"; \/\/ #28\n-    Utf8 \"BootstrapMethods\"; \/\/ #29\n-    MethodHandle 6b #31; \/\/ #30\n-    Method #32 #33; \/\/ #31\n-    class #34; \/\/ #32\n-    NameAndType #35 #36; \/\/ #33\n-    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #34\n-    Utf8 \"makeBootstrapMethod\"; \/\/ #35\n-    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #36\n-    Utf8 \"InnerClasses\"; \/\/ #37\n-    class #39; \/\/ #38\n-    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #39\n-    class #41; \/\/ #40\n-    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #41\n-    Utf8 \"Lookup\"; \/\/ #42\n+    Utf8 \"p1\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/Object\"; \/\/ #14\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #15\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #16\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"Test.java\"; \/\/ #21\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\"; \/\/ #22\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #23\n+    Utf8 \"Preload\"; \/\/ #24\n@@ -680,1 +621,1 @@\n-  0x0851; \/\/ access\n+  0x0050; \/\/ access\n@@ -682,1 +623,1 @@\n-  #20;\/\/ super_cpx\n+  #13;\/\/ super_cpx\n@@ -689,1 +630,1 @@\n-      0x0010; \/\/ access\n+      0x0012; \/\/ access\n@@ -693,8 +634,9 @@\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ field\n-      0x0012; \/\/ access  \/\/ Access flags have been modified to make field p1 private\n-      #15; \/\/ name_index\n-      #12; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #16;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n@@ -707,25 +649,1 @@\n-      0x0011; \/\/ access\n-      #18; \/\/ name_index\n-      #22; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#23) { \/\/ Code\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[]{\n-            0x2ABA00100000B0;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#24) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  26;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method\n-      0x0009; \/\/ access\n+      0x0008; \/\/ access\n@@ -733,1 +651,1 @@\n-      #25; \/\/ descriptor_index\n+      #17; \/\/ descriptor_index\n@@ -735,1 +653,1 @@\n-        Attr(#23) { \/\/ Code\n+        Attr(#18) { \/\/ Code\n@@ -740,2 +658,1 @@\n-            0x5FCC00094BB80003;\n-            0x2A5FCC000D4B2AB0;\n+            0x5FCC00094B2AB0;\n@@ -746,1 +663,1 @@\n-            Attr(#24) { \/\/ LineNumberTable\n+            Attr(#19) { \/\/ LineNumberTable\n@@ -748,3 +665,3 @@\n-                0  26;\n-                4  27;\n-                13  28;\n+                0  33;\n+                4  35;\n+                13  34;\n@@ -760,2 +677,2 @@\n-    Attr(#26) { \/\/ SourceFile\n-      #27;\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n@@ -764,11 +681,13 @@\n-    Attr(#28) { \/\/ NestHost\n-      #20;\n-    } \/\/ end NestHost\n-    ;\n-    Attr(#29) { \/\/ BootstrapMethods\n-      [] { \/\/ bootstrap_methods\n-        {  \/\/  bootstrap_method\n-          #30; \/\/ bootstrap_method_ref\n-          [] { \/\/ bootstrap_arguments\n-          }  \/\/  bootstrap_arguments\n-        }  \/\/  bootstrap_method\n+    Attr(#15) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #22;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+        ;\n+        {  \/\/  annotation\n+          #23;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n@@ -776,1 +695,1 @@\n-    } \/\/ end BootstrapMethods\n+    } \/\/ end RuntimeVisibleAnnotations\n@@ -778,1 +697,1 @@\n-    Attr(#37) { \/\/ InnerClasses\n+    Attr(#24) { \/\/ Preload\n@@ -780,1 +699,1 @@\n-        #38 #40 #42 25;\n+        #4;\n@@ -782,1 +701,1 @@\n-    } \/\/ end InnerClasses\n+    } \/\/ end Preload\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":368,"deletions":449,"binary":false,"changes":817,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeIRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-                         \"-XX:+EnablePrimitiveClasses\",\n@@ -40,0 +39,2 @@\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n@@ -52,1 +53,0 @@\n-                         \"-XX:+EnablePrimitiveClasses\",\n@@ -54,0 +54,2 @@\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n@@ -66,1 +68,0 @@\n-                         \"-XX:+EnablePrimitiveClasses\",\n@@ -68,0 +69,2 @@\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n@@ -81,1 +84,0 @@\n-                         \"-XX:+EnablePrimitiveClasses\",\n@@ -83,0 +85,2 @@\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n@@ -94,1 +98,0 @@\n-                         \"-XX:+EnablePrimitiveClasses\",\n@@ -96,0 +99,2 @@\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n@@ -107,1 +112,0 @@\n-                         \"-XX:+EnablePrimitiveClasses\",\n@@ -109,0 +113,2 @@\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,6 @@\n-public abstract class MyAbstract implements MyInterface {\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public abstract value class MyAbstract implements MyInterface {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyAbstract.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyInterface.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,6 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n@@ -32,1 +38,1 @@\n-public final primitive class MyValue1 extends MyAbstract {\n+public value class MyValue1 extends MyAbstract {\n@@ -35,7 +41,10 @@\n-    final int x;\n-    final long y;\n-    final short z;\n-    final Integer o;\n-    final int[] oa;\n-    final MyValue2 v1;\n-    final MyValue2 v2;\n+    int x;\n+    long y;\n+    short z;\n+    Integer o;\n+    int[] oa;\n+    @NullRestricted\n+    MyValue2 v1;\n+    @NullRestricted\n+    MyValue2 v2;\n+    @NullRestricted\n@@ -43,3 +52,4 @@\n-    final MyValue2.ref v4;\n-    final MyValue2 v5;\n-    final int c;\n+    MyValue2 v4;\n+    @NullRestricted\n+    MyValue2 v5;\n+    int c;\n@@ -48,1 +58,1 @@\n-    public MyValue1(int x, long y, short z, Integer o, int[] oa, MyValue2 v1, MyValue2 v2, MyValue2.ref v4, MyValue2.ref v5, int c) {\n+    public MyValue1(int x, long y, short z, Integer o, int[] oa, MyValue2 v1, MyValue2 v2, MyValue2 v4, MyValue2 v5, int c) {\n@@ -69,1 +79,1 @@\n-        return MyValue1.default;\n+        return new MyValue1(0, 0, (short)0, null, null, MyValue2.createDefaultInline(), MyValue2.createDefaultInline(), null, MyValue2.createDefaultInline(), 0);\n@@ -177,1 +187,1 @@\n-    static MyValue1 setV4(MyValue1 v, MyValue2.ref v4) {\n+    static MyValue1 setV4(MyValue1 v, MyValue2 v4) {\n@@ -182,1 +192,1 @@\n-    static MyValue1 setV5(MyValue1 v, MyValue2.ref v5) {\n+    static MyValue1 setV5(MyValue1 v, MyValue2 v5) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue1.java","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,9 @@\n-final primitive class MyValue2Inline {\n-    final double d;\n-    final long l;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue2Inline {\n+    double d;\n+    long l;\n@@ -51,1 +57,1 @@\n-        return MyValue2Inline.default;\n+        return new MyValue2Inline(0, 0);\n@@ -63,4 +69,7 @@\n-public final primitive class MyValue2 extends MyAbstract {\n-    final int x;\n-    final byte y;\n-    final MyValue2Inline v;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public value class MyValue2 extends MyAbstract {\n+    int x;\n+    byte y;\n+    @NullRestricted\n+    MyValue2Inline v;\n@@ -77,1 +86,1 @@\n-        return MyValue2.default;\n+        return new MyValue2(0, (byte)0, MyValue2Inline.createDefault());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue2.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,9 @@\n-final primitive class MyValue3Inline {\n-    final float f7;\n-    final double f8;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue3Inline {\n+    float f7;\n+    double f8;\n@@ -53,1 +59,1 @@\n-        return MyValue3Inline.default;\n+        return new MyValue3Inline(0, 0);\n@@ -67,14 +73,17 @@\n-public final primitive class MyValue3 extends MyAbstract {\n-    final char c;\n-    final byte bb;\n-    final short s;\n-    final int i;\n-    final long l;\n-    final Object o;\n-    final float f1;\n-    final double f2;\n-    final float f3;\n-    final double f4;\n-    final float f5;\n-    final double f6;\n-    final MyValue3Inline v1;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public value class MyValue3 extends MyAbstract {\n+    char c;\n+    byte bb;\n+    short s;\n+    int i;\n+    long l;\n+    Object o;\n+    float f1;\n+    double f2;\n+    float f3;\n+    double f4;\n+    float f5;\n+    double f6;\n+    @NullRestricted\n+    MyValue3Inline v1;\n@@ -168,1 +177,1 @@\n-        return MyValue3.default;\n+        return new MyValue3((char)0, (byte)0, (short)0, 0, 0, null, 0, 0, 0, 0, 0, 0, MyValue3Inline.createDefault());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue3.java","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -29,3 +33,7 @@\n-final primitive class MyValue4 extends MyAbstract {\n-    final MyValue3 v1;\n-    final MyValue3 v2;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue4 extends MyAbstract {\n+    @NullRestricted\n+    MyValue3 v1;\n+    @NullRestricted\n+    MyValue3 v2;\n@@ -51,1 +59,1 @@\n-        return MyValue4.default;\n+        return new MyValue4(MyValue3.createDefault(), MyValue3.createDefault());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue4.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,166 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/\/ GENERATED FROM THE FOLLOWING JAVA FILE:\n-\/*\n-package compiler.valhalla.inlinetypes;\n-\n-primitive class MyValue5 {\n-    public int x = 42;\n-\n-    public MyValue5 withField(int x) {\n-        return __WithField(this.x, x);\n-    }\n-\n-    public static MyValue5.ref withField(MyValue5.ref val, int x) {\n-        return __WithField(val.x, x);\n-    }\n-}\n-*\/\n-\n-class compiler\/valhalla\/inlinetypes\/MyValue5 {\n-  0xCAFEBABE;\n-  0; \/\/ minor version\n-  66; \/\/ version\n-  [] { \/\/ Constant Pool\n-    ; \/\/ first element is empty\n-    class #2; \/\/ #1\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue5\"; \/\/ #2\n-    Field #1 #4; \/\/ #3\n-    NameAndType #5 #6; \/\/ #4\n-    Utf8 \"x\"; \/\/ #5\n-    Utf8 \"I\"; \/\/ #6\n-    class #8; \/\/ #7\n-    Utf8 \"java\/lang\/Object\"; \/\/ #8\n-    Utf8 \"withField\"; \/\/ #9\n-    Utf8 \"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #10\n-    Utf8 \"Code\"; \/\/ #11\n-    Utf8 \"LineNumberTable\"; \/\/ #12\n-    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue5;I)Lcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #13\n-    Utf8 \"<vnew>\"; \/\/ #14\n-    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #15\n-    Utf8 \"SourceFile\"; \/\/ #16\n-    Utf8 \"MyValue5.java\"; \/\/ #17\n-  } \/\/ Constant Pool\n-\n-  0x0850; \/\/ access\n-  #1;\/\/ this_cpx\n-  #7;\/\/ super_cpx\n-\n-  [] { \/\/ Interfaces\n-  } \/\/ Interfaces\n-\n-  [] { \/\/ Fields\n-    {  \/\/ field\n-      0x0011; \/\/ access\n-      #5; \/\/ name_index\n-      #6; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-      } \/\/ Attributes\n-    }\n-  } \/\/ Fields\n-\n-  [] { \/\/ Methods\n-    {  \/\/ method\n-      0x0001; \/\/ access\n-      #9; \/\/ name_index\n-      #10; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#11) { \/\/ Code\n-          2; \/\/ max_stack\n-          2; \/\/ max_locals\n-          Bytes[]{\n-            0x1B2A5FCC0003B0;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#12) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  7;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method\n-      0x0009; \/\/ access\n-      #9; \/\/ name_index\n-      #13; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#11) { \/\/ Code\n-          2; \/\/ max_stack\n-          2; \/\/ max_locals\n-          Bytes[]{\n-            0x1B2A5FCC0003B0;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#12) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  11;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-    ;\n-    {  \/\/ method\n-      0x0008; \/\/ access\n-      #14; \/\/ name_index\n-      #15; \/\/ descriptor_index\n-      [] { \/\/ Attributes\n-        Attr(#11) { \/\/ Code\n-          2; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[]{\n-            0xCB00014B102A2A5F;\n-            0xCC00034B2AB0;\n-          }\n-          [] { \/\/ Traps\n-          } \/\/ end Traps\n-          [] { \/\/ Attributes\n-            Attr(#12) { \/\/ LineNumberTable\n-              [] { \/\/ line_number_table\n-                0  3;\n-                4  4;\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    }\n-  } \/\/ Methods\n-\n-  [] { \/\/ Attributes\n-    Attr(#16) { \/\/ SourceFile\n-      #17;\n-    } \/\/ end SourceFile\n-  } \/\/ Attributes\n-} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue5\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":0,"deletions":166,"binary":false,"changes":166,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-        return MyValueClass1.default;\n+        return new MyValueClass1(0, 0, (short)0, null, null, null, null, null, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        return MyValueClass2Inline.default;\n+        return new MyValueClass2Inline(0, 0);\n@@ -77,1 +77,1 @@\n-        return MyValueClass2.default;\n+        return new MyValueClass2(0, (byte)0, null);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass2.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,6 @@\n-public final primitive class MyValueEmpty extends MyAbstract {\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public value class MyValueEmpty extends MyAbstract {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueEmpty.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.valhalla.inlinetypes;\n-\n-public class NamedRectangle {\n-    Rectangle rect = new Rectangle();\n-    String name = \"\";\n-\n-    static int getP1X(NamedRectangle nr) {\n-        return nr.rect\n-            .p1\n-            .x;\n-    }\n-\n-    static Point getP1(NamedRectangle nr) {\n-        return nr.rect\n-            .p1;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/NamedRectangle.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.valhalla.inlinetypes;\n-\n-public primitive class Point {\n-    int x = 4;\n-    int y = 7;\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/Point.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.valhalla.inlinetypes;\n-\n-public primitive class Rectangle {\n-    Point p0 = new Point();\n-    Point p1 = new Point();\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/Rectangle.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-final primitive class SimpleInlineType {\n-    final int x;\n+value class SimpleInlineType {\n+    int x;\n@@ -32,1 +32,1 @@\n-        return SimpleInlineType.default;\n+        return new SimpleInlineType();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/SimpleInlineType.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+\/\/ TODO 8325106 Investigate why this suddenly started to throw java.lang.OutOfMemoryError without -Xmx200m\n+\/\/ and -XX:-UseCompressedOops -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent=0 -Xmx20m -Xmn1m -XX:G1HeapRegionSize=1m -XX:-ReduceInitialCardMarks\n+\n@@ -28,2 +31,7 @@\n- * @compile -XDenablePrimitiveClasses TestArrayAccessDeopt.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses TestArrayAccessDeopt\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *          TestArrayAccessDeopt.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xmx200m\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   TestArrayAccessDeopt\n@@ -37,2 +45,9 @@\n-final primitive class MyValue1 {\n-    public final int x = 0;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue1 {\n+    public int x = 0;\n@@ -47,1 +62,1 @@\n-    public static void test2(Object[] va, MyValue1.ref vt) {\n+    public static void test2(Object[] va, MyValue1 vt) {\n@@ -51,2 +66,2 @@\n-    public static void test3(MyValue1.ref[] va, Object vt) {\n-        va[0] = (MyValue1.ref)vt;\n+    public static void test3(MyValue1[] va, Object vt) {\n+        va[0] = (MyValue1)vt;\n@@ -55,1 +70,1 @@\n-    public static void test4(MyValue1.ref[] va, MyValue1.ref vt) {\n+    public static void test4(MyValue1[] va, MyValue1 vt) {\n@@ -71,1 +86,1 @@\n-    public static void test8(MyValue1.ref[] va, MyValue1 vt) {\n+    public static void test8(MyValue1[] va, MyValue1 vt) {\n@@ -75,1 +90,1 @@\n-    public static void test9(MyValue1[] va, MyValue1.ref vt) {\n+    public static void test9(MyValue1[] va, MyValue1 vt) {\n@@ -83,1 +98,1 @@\n-    public static void test11(MyValue1.ref[] va) {\n+    public static void test11(MyValue1[] va) {\n@@ -90,1 +105,1 @@\n-            String[] arg = {\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+            String[] arg = {\"-XX:+EnableValhalla\", \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n@@ -97,2 +112,2 @@\n-            MyValue1[] va = new MyValue1[1];\n-            MyValue1.ref[] vaB = new MyValue1.ref[1];\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] vaB = new MyValue1[1];\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayAccessDeopt.java","additions":30,"deletions":15,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Verify that arraycopy intrinsics properly handle flat inline type arrays with oop fields.\n+ * @summary Verify that arraycopy intrinsics properly handle flat value class arrays with oop fields.\n@@ -29,2 +29,5 @@\n- * @compile -XDenablePrimitiveClasses TestArrayCopyWithOops.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestArrayCopyWithOops.java\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -35,1 +38,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -40,0 +45,4 @@\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   compiler.valhalla.inlinetypes.TestArrayCopyWithOops\n@@ -48,0 +57,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -55,1 +69,3 @@\n-    static primitive class ManyOops {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ManyOops {\n@@ -66,2 +82,2 @@\n-    static ManyOops[] createArrayInline() {\n-        ManyOops[] array = new ManyOops[LEN];\n+    static ManyOops[] createValueClassArray() {\n+        ManyOops[] array = (ManyOops[])ValueClass.newNullRestrictedArray(ManyOops.class, LEN);\n@@ -74,2 +90,2 @@\n-    static Object[] createArrayObject() {\n-        return createArrayInline();\n+    static Object[] createObjectArray() {\n+        return createValueClassArray();\n@@ -79,1 +95,1 @@\n-        return createArrayInline();\n+        return createValueClassArray();\n@@ -85,1 +101,1 @@\n-        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+        System.arraycopy(createValueClassArray(), 0, dst, 0, LEN);\n@@ -89,1 +105,1 @@\n-        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+        System.arraycopy(createObjectArray(), 0, dst, 0, LEN);\n@@ -93,1 +109,1 @@\n-        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+        System.arraycopy(createObjectArray(), 0, dst, 0, LEN);\n@@ -97,1 +113,1 @@\n-        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+        System.arraycopy(createValueClassArray(), 0, dst, 0, LEN);\n@@ -103,2 +119,2 @@\n-        ManyOops[] dst = new ManyOops[LEN];\n-        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+        ManyOops[] dst = (ManyOops[])ValueClass.newNullRestrictedArray(ManyOops.class, LEN);\n+        System.arraycopy(createValueClassArray(), 0, dst, 0, LEN);\n@@ -110,1 +126,1 @@\n-        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+        System.arraycopy(createObjectArray(), 0, dst, 0, LEN);\n@@ -115,2 +131,2 @@\n-        ManyOops[] dst = new ManyOops[LEN];\n-        System.arraycopy(createArrayObject(), 0, dst, 0, LEN);\n+        ManyOops[] dst = (ManyOops[])ValueClass.newNullRestrictedArray(ManyOops.class, LEN);\n+        System.arraycopy(createObjectArray(), 0, dst, 0, LEN);\n@@ -122,1 +138,1 @@\n-        System.arraycopy(createArrayInline(), 0, dst, 0, LEN);\n+        System.arraycopy(createValueClassArray(), 0, dst, 0, LEN);\n@@ -128,0 +144,2 @@\n+    \/\/ TODO 8325106 test9\/test11 and test10\/test12 are equivalent\n+    \/\/ Using ManyOops[].class in both test9\/11 and running with -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation -XX:-DoEscapeAnalysis -XX:+AlwaysIncrementalInline triggers an exception\n@@ -129,1 +147,2 @@\n-        return Arrays.copyOf(createArrayInline(), LEN, ManyOops[].class);\n+        ManyOops[] src = createValueClassArray();\n+        return Arrays.copyOf(src, LEN, src.getClass());\n@@ -133,1 +152,1 @@\n-        return Arrays.copyOf(createArrayObject(), LEN, Object[].class);\n+        return Arrays.copyOf(createObjectArray(), LEN, Object[].class);\n@@ -137,1 +156,2 @@\n-        return Arrays.copyOf(createArrayInline(), LEN, ManyOops[].class);\n+        ManyOops[] src = createValueClassArray();\n+        return Arrays.copyOf(src, LEN, src.getClass());\n@@ -141,1 +161,1 @@\n-        return Arrays.copyOf(createArrayObject(), LEN, Object[].class);\n+        return Arrays.copyOf(createObjectArray(), LEN, Object[].class);\n@@ -161,5 +181,5 @@\n-        ManyOops[] dst1 = createArrayInline();\n-        ManyOops[] dst2 = createArrayInline();\n-        ManyOops[] dst3 = createArrayInline();\n-        ManyOops[] dst4 = createArrayInline();\n-        ManyOops[] dst13 = createArrayInline();\n+        ManyOops[] dst1 = createValueClassArray();\n+        ManyOops[] dst2 = createValueClassArray();\n+        ManyOops[] dst3 = createValueClassArray();\n+        ManyOops[] dst4 = createValueClassArray();\n+        ManyOops[] dst13 = createValueClassArray();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java","additions":50,"deletions":30,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -41,1 +46,2 @@\n- * @summary Test inline type arrays\n+ * @summary Test value class arrays.\n+ * @modules java.base\/jdk.internal.value\n@@ -44,2 +50,3 @@\n- * @compile -XDenablePrimitiveClasses TestArrays.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestArrays\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestArrays.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestArrays\n@@ -53,4 +60,4 @@\n-        scenarios[2].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n-        scenarios[3].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\", \"-XX:-UncommonNullCast\");\n-        scenarios[4].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\");\n-        scenarios[5].addFlags(\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+        scenarios[2].addFlags(\"-XX:+EnableValhalla\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+        scenarios[3].addFlags(\"-XX:+EnableValhalla\", \"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\", \"-XX:-UncommonNullCast\");\n+        scenarios[4].addFlags(\"-XX:+EnableValhalla\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\");\n+        scenarios[5].addFlags(\"-XX:+EnableValhalla\", \"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n@@ -125,1 +132,3 @@\n-    primitive static class NotFlattenable {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class NotFlattenable {\n@@ -134,1 +143,1 @@\n-    \/\/ Test inline type array creation and initialization\n+    \/\/ Test value class array creation and initialization\n@@ -142,1 +151,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -158,1 +167,1 @@\n-    \/\/ Test creation of an inline type array and element access\n+    \/\/ Test creation of a value class array and element access\n@@ -162,1 +171,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -173,1 +182,1 @@\n-    \/\/ Test receiving an inline type array from the interpreter,\n+    \/\/ Test receiving a value class array from the interpreter,\n@@ -188,1 +197,1 @@\n-        MyValue1[] va = new MyValue1[10];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n@@ -203,1 +212,1 @@\n-    \/\/ Test returning an inline type array received from the interpreter\n+    \/\/ Test returning a value class array received from the interpreter\n@@ -212,1 +221,1 @@\n-        MyValue1[] va = new MyValue1[10];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n@@ -222,1 +231,1 @@\n-    \/\/ Merge inline type arrays created from two branches\n+    \/\/ Merge value class arrays created from two branches\n@@ -227,1 +236,1 @@\n-            va = new MyValue1[5];\n+            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 5);\n@@ -232,1 +241,1 @@\n-            va = new MyValue1[10];\n+            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n@@ -262,1 +271,1 @@\n-    \/\/ Test creation of inline type array with single element\n+    \/\/ Test creation of value class array with single element\n@@ -266,1 +275,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -272,1 +281,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -277,1 +286,1 @@\n-    \/\/ Test default initialization of inline type arrays\n+    \/\/ Test default initialization of value class arrays\n@@ -281,1 +290,1 @@\n-        return new MyValue1[len];\n+        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -287,1 +296,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -294,1 +303,1 @@\n-    \/\/ Test creation of inline type array with zero length\n+    \/\/ Test creation of value class array with zero length\n@@ -298,1 +307,1 @@\n-        return new MyValue1[0];\n+        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0);\n@@ -309,1 +318,1 @@\n-    \/\/ Test that inline type array loaded from field has correct type\n+    \/\/ Test that value class array loaded from field has correct type\n@@ -318,1 +327,1 @@\n-        test9_va = new MyValue1[1];\n+        test9_va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -388,1 +397,1 @@\n-        MyValue1[] va = new MyValue1[arraySize];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n@@ -410,1 +419,1 @@\n-        MyValue1[] va = new MyValue1[arraySize];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n@@ -437,1 +446,1 @@\n-        MyValue1[] va = new MyValue1[arraySize];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n@@ -458,1 +467,1 @@\n-        MyValue1[] va = new MyValue1[arraySize];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n@@ -479,1 +488,1 @@\n-        MyValue1[] va = new MyValue1[arraySize];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n@@ -506,1 +515,1 @@\n-        MyValue1[] va = new MyValue1[arraySize];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n@@ -537,1 +546,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -552,1 +561,1 @@\n-        MyValue1[] va = new MyValue1[8];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -569,1 +578,1 @@\n-    \/\/ arraycopy() of inline type array with oop fields\n+    \/\/ arraycopy() of value class array with oop fields\n@@ -578,2 +587,2 @@\n-        MyValue1[] src = new MyValue1[len];\n-        MyValue1[] dst = new MyValue1[len];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -589,1 +598,1 @@\n-    \/\/ arraycopy() of inline type array with no oop field\n+    \/\/ arraycopy() of value class array with no oop field\n@@ -598,2 +607,2 @@\n-        MyValue2[] src = new MyValue2[len];\n-        MyValue2[] dst = new MyValue2[len];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -609,1 +618,1 @@\n-    \/\/ arraycopy() of inline type array with oop field and tightly\n+    \/\/ arraycopy() of value class array with oop field and tightly\n@@ -613,1 +622,1 @@\n-        MyValue1[] dst = new MyValue1[src.length];\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, src.length);\n@@ -621,1 +630,1 @@\n-        MyValue1[] src = new MyValue1[len];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -631,1 +640,1 @@\n-    \/\/ arraycopy() of inline type array with oop fields and tightly\n+    \/\/ arraycopy() of value class array with oop fields and tightly\n@@ -635,1 +644,1 @@\n-        MyValue1[] dst = new MyValue1[src.length + 10];\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, src.length + 10);\n@@ -643,1 +652,1 @@\n-        MyValue1[] src = new MyValue1[len];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -653,1 +662,1 @@\n-    \/\/ arraycopy() of inline type array passed as Object\n+    \/\/ arraycopy() of value class array passed as Object\n@@ -662,2 +671,2 @@\n-        MyValue1[] src = new MyValue1[len];\n-        MyValue1[] dst1 = new MyValue1[len];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] dst1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -686,2 +695,2 @@\n-        MyValue2[] src = new MyValue2[8];\n-        MyValue2[] dst = new MyValue2[8];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -705,2 +714,2 @@\n-        MyValue1[] src = new MyValue1[8];\n-        MyValue1[] dst = new MyValue1[8];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -724,2 +733,2 @@\n-        MyValue1[] src = new MyValue1[8];\n-        MyValue1[] dst = new MyValue1[8];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -741,1 +750,1 @@\n-        MyValue2[] src = new MyValue2[10];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -758,0 +767,2 @@\n+    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n+    \/*\n@@ -762,0 +773,1 @@\n+    *\/\n@@ -763,1 +775,1 @@\n-        MyValue2[] dst = new MyValue2[10];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -770,1 +782,1 @@\n-        MyValue2[] src = new MyValue2[10];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -779,1 +791,1 @@\n-    \/\/ eliminated inline type array element as debug info\n+    \/\/ eliminated value class array element as debug info\n@@ -782,1 +794,1 @@\n-        MyValue2[] dst = new MyValue2[10];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -791,1 +803,1 @@\n-        MyValue2[] src = new MyValue2[10];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -804,1 +816,1 @@\n-        MyValue2[] src = new MyValue2[1];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n@@ -837,1 +849,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -874,1 +886,1 @@\n-            va = new MyValue1[8];\n+            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -918,1 +930,1 @@\n-    \/\/ arraycopy() of inline type array of unknown size\n+    \/\/ arraycopy() of value class array of unknown size\n@@ -927,2 +939,2 @@\n-        MyValue1[] src = new MyValue1[len];\n-        MyValue1[] dst1 = new MyValue1[len];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] dst1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -951,2 +963,2 @@\n-        MyValue2[] src = new MyValue2[len];\n-        MyValue2[] dst = new MyValue2[len];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -972,2 +984,2 @@\n-        MyValue2[] src = new MyValue2[len];\n-        MyValue2[] dst = new MyValue2[len];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -995,1 +1007,1 @@\n-        MyValue2[] dst = new MyValue2[len];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -1019,1 +1031,1 @@\n-        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -1042,1 +1054,1 @@\n-        MyValue2[] dst = new MyValue2[len];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -1066,1 +1078,1 @@\n-        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -1107,2 +1119,2 @@\n-        MyValue1[] src = new MyValue1[8];\n-        MyValue1[] dst = new MyValue1[8];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -1127,2 +1139,2 @@\n-        MyValue2[] src = new MyValue2[8];\n-        MyValue2[] dst = new MyValue2[8];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -1147,2 +1159,2 @@\n-        MyValue2[] src = new MyValue2[8];\n-        MyValue2[] dst = new MyValue2[8];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -1169,1 +1181,1 @@\n-        MyValue2[] dst = new MyValue2[8];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -1192,1 +1204,1 @@\n-        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -1214,1 +1226,1 @@\n-        MyValue2[] dst = new MyValue2[8];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -1237,1 +1249,1 @@\n-        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -1279,1 +1291,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1287,1 +1299,1 @@\n-    static final MyValue1[] test52_va = new MyValue1[8];\n+    static final MyValue1[] test52_va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -1313,1 +1325,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1329,1 +1341,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1345,1 +1357,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1378,1 +1390,1 @@\n-        Object[] va = new MyValue1[len];\n+        Object[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1394,1 +1406,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1410,1 +1422,1 @@\n-        return Arrays.copyOf(va, va.length+1, MyValue1[].class);\n+        return Arrays.copyOf(va, va.length+1, va.getClass());\n@@ -1416,2 +1428,2 @@\n-        MyValue1[] va = new MyValue1[len];\n-        MyValue1[] verif = new MyValue1[len+1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len + 1);\n@@ -1434,2 +1446,2 @@\n-        MyValue1[] va = new MyValue1[len];\n-        MyValue1[] verif = new MyValue1[len+1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len + 1);\n@@ -1440,1 +1452,1 @@\n-        Object[] result = test60(va, MyValue1[].class);\n+        Object[] result = test60(va, va.getClass());\n@@ -1486,1 +1498,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1522,2 +1534,2 @@\n-        MyValue1[] va = new MyValue1[len];\n-        MyValue1[] verif = new MyValue1[len+1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len + 1);\n@@ -1534,1 +1546,1 @@\n-    \/\/ Test default initialization of inline type arrays: small array\n+    \/\/ Test default initialization of value class arrays: small array\n@@ -1537,1 +1549,1 @@\n-        return new MyValue1[8];\n+        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -1542,1 +1554,1 @@\n-        MyValue1[] va = new MyValue1[8];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -1549,1 +1561,1 @@\n-    \/\/ Test default initialization of inline type arrays: large array\n+    \/\/ Test default initialization of value class arrays: large array\n@@ -1552,1 +1564,1 @@\n-        return new MyValue1[32];\n+        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 32);\n@@ -1557,1 +1569,1 @@\n-        MyValue1[] va = new MyValue1[32];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 32);\n@@ -1568,1 +1580,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1583,1 +1595,1 @@\n-        MyValue1[] dst = new MyValue1[16];\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 16);\n@@ -1590,1 +1602,1 @@\n-        MyValue1[] va = new MyValue1[16];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 16);\n@@ -1600,1 +1612,1 @@\n-        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1607,1 +1619,1 @@\n-        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1617,1 +1629,1 @@\n-        MyValue1[] va = new MyValue1[4];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 4);\n@@ -1626,1 +1638,1 @@\n-        MyValue1[] va = new MyValue1[4];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 4);\n@@ -1640,1 +1652,1 @@\n-        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1648,1 +1660,1 @@\n-        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1659,2 +1671,2 @@\n-        MyValue2[] src = new MyValue2[len];\n-        MyValue2[] dst = new MyValue2[len];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -1710,1 +1722,1 @@\n-        MyValue1[] arr = new MyValue1[3];\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n@@ -1724,1 +1736,1 @@\n-    \/\/ Tests invoking unloaded method with inline type array in signature\n+    \/\/ Tests invoking unloaded method with value class array in signature\n@@ -1734,1 +1746,1 @@\n-        MyValue1[] va = new MyValue1[0];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0);\n@@ -1762,1 +1774,1 @@\n-        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1800,2 +1812,2 @@\n-        MyValue1[] va = new MyValue1[len];\n-        MyValue1[] verif = new MyValue1[len];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -1825,1 +1837,1 @@\n-        MyValue1[] arr = new MyValue1[1];\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1845,1 +1857,1 @@\n-        for (int i = 0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -1848,1 +1860,1 @@\n-        MyValue1[] a = new MyValue1[n];\n+        MyValue1[] a = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, n);\n@@ -1884,1 +1896,1 @@\n-    \/\/ Same as test79 but with not-flattenable inline type\n+    \/\/ Same as test79 but with not-flattenable value class\n@@ -1899,1 +1911,1 @@\n-        NotFlattenable[] array = new NotFlattenable[2];\n+        NotFlattenable[] array = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n@@ -1935,1 +1947,1 @@\n-    \/\/ Verify that writing an object of a non-flattenable inline type to an array marks the array as not-flat\n+    \/\/ Verify that writing an object of a non-flattenable value class to an array marks the array as not-flat\n@@ -1951,1 +1963,1 @@\n-        NotFlattenable[] array1 = new NotFlattenable[3];\n+        NotFlattenable[] array1 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 3);\n@@ -1965,1 +1977,1 @@\n-    \/\/ Verify that casting an array element to a non-inline type type marks the array as not-null-free and not-flat\n+    \/\/ Verify that casting an array element to a non-value class type type marks the array as not-null-free and not-flat\n@@ -2000,1 +2012,1 @@\n-        NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];\n+        NotFlattenable[] array1 = new NotFlattenable[2];\n@@ -2009,1 +2021,1 @@\n-            NotFlattenable[] array3 = new NotFlattenable[2];\n+            NotFlattenable[] array3 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n@@ -2046,1 +2058,1 @@\n-            NotFlattenable[] array3 = new NotFlattenable[2];\n+            NotFlattenable[] array3 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n@@ -2056,1 +2068,1 @@\n-    \/\/ Same as test85 but with not-flattenable inline type array\n+    \/\/ Same as test85 but with not-flattenable value class array\n@@ -2064,1 +2076,1 @@\n-    public void test86(NotFlattenable.ref[] array, NotFlattenable.ref o, boolean b) {\n+    public void test86(NotFlattenable[] array, NotFlattenable o, boolean b) {\n@@ -2076,1 +2088,1 @@\n-        NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];\n+        NotFlattenable[] array1 = new NotFlattenable[2];\n@@ -2082,1 +2094,1 @@\n-            NotFlattenable[] array2 = new NotFlattenable[2];\n+            NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n@@ -2092,1 +2104,1 @@\n-    \/\/ Same as test85 but with inline type array\n+    \/\/ Same as test85 but with value class array\n@@ -2100,1 +2112,1 @@\n-    public void test87(MyValue1.ref[] array, MyValue1.ref o, boolean b) {\n+    public void test87(MyValue1[] array, MyValue1 o, boolean b) {\n@@ -2112,1 +2124,1 @@\n-        MyValue1.ref[] array1 = new MyValue1.ref[2];\n+        MyValue1[] array1 = new MyValue1[2];\n@@ -2118,1 +2130,1 @@\n-            MyValue1[] array2 = new MyValue1[2];\n+            MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -2143,1 +2155,1 @@\n-            MyValue1[] array3 = new MyValue1[1];\n+            MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2154,1 +2166,1 @@\n-    public void test89(MyValue1.ref[] array, Integer v) {\n+    public void test89(MyValue1[] array, Integer v) {\n@@ -2156,1 +2168,1 @@\n-        array[0] = (MyValue1.ref)o;\n+        array[0] = (MyValue1)o;\n@@ -2161,1 +2173,1 @@\n-        MyValue1.ref[] array1 = new MyValue1.ref[1];\n+        MyValue1[] array1 = new MyValue1[1];\n@@ -2165,1 +2177,1 @@\n-            MyValue1[] array2 = new MyValue1[1];\n+            MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2179,2 +2191,2 @@\n-        MyValue1[] qArray = new MyValue1[0];\n-        MyValue1.ref[] lArray = new MyValue1.ref[0];\n+        MyValue1[] qArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0);\n+        MyValue1[] lArray = new MyValue1[0];\n@@ -2183,1 +2195,1 @@\n-        b = b && (lArray instanceof MyValue1.ref[]);\n+        b = b && (lArray instanceof MyValue1[]);\n@@ -2185,2 +2197,2 @@\n-        MyValue1[][] qArray2 = new MyValue1[0][0];\n-        MyValue1.ref[][] lArray2 = new MyValue1.ref[0][0];\n+        MyValue1[][] qArray2 = { (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0) };\n+        MyValue1[][] lArray2 = new MyValue1[0][0];\n@@ -2189,1 +2201,1 @@\n-        b = b && (lArray2 instanceof MyValue1.ref[][]);\n+        b = b && (lArray2 instanceof MyValue1[][]);\n@@ -2199,7 +2211,9 @@\n-    primitive static final class Test91Value {\n-        public final int f0;\n-        public final int f1;\n-        public final int f2;\n-        public final int f3;\n-        public final int f4;\n-        public final int f5;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test91Value {\n+        public int f0;\n+        public int f1;\n+        public int f2;\n+        public int f3;\n+        public int f4;\n+        public int f5;\n@@ -2238,1 +2252,1 @@\n-        Test91Value[] array = new Test91Value[5];\n+        Test91Value[] array = (Test91Value[])ValueClass.newNullRestrictedArray(Test91Value.class, 5);\n@@ -2256,2 +2270,2 @@\n-        MyValue1[] a = new MyValue1[1];\n-        MyValue1[] b = new MyValue1[1];\n+        MyValue1[] a = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] b = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2276,1 +2290,1 @@\n-        MyValue2[] dst = new MyValue2[10];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -2286,1 +2300,1 @@\n-        MyValue2[] src = new MyValue2[10];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -2301,1 +2315,1 @@\n-        MyValue2[] dst = new MyValue2[10];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -2311,1 +2325,1 @@\n-        MyValue2[] src = new MyValue2[10];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -2317,1 +2331,1 @@\n-            long expected = src[i].hash() + 9*MyValue2.default.hash();\n+            long expected = src[i].hash() + 9*MyValue2.createDefaultInline().hash();\n@@ -2328,1 +2342,1 @@\n-        \/\/ stored null and therefore the array can't be an inline type array.\n+        \/\/ stored null and therefore the array can't be an value class array.\n@@ -2334,1 +2348,1 @@\n-        MyValue1[] array1 = new MyValue1[1];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2356,1 +2370,1 @@\n-        \/\/ stored null and therefore the array can't be an inline type array.\n+        \/\/ stored null and therefore the array can't be an value class array.\n@@ -2363,1 +2377,1 @@\n-        MyValue1[] array1 = new MyValue1[1];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2385,1 +2399,1 @@\n-        \/\/ a non-inline value and therefore the array can't be an inline type array.\n+        \/\/ a non-value type value and therefore the array can't be a value class array.\n@@ -2391,1 +2405,1 @@\n-        MyValue1[] array1 = new MyValue1[1];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2408,1 +2422,1 @@\n-        array[0] = NotFlattenable.default;\n+        array[0] = new NotFlattenable();\n@@ -2416,2 +2430,2 @@\n-        MyValue1[] array1 = new MyValue1[1];\n-        NotFlattenable[] array2 = new NotFlattenable[1];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n@@ -2437,1 +2451,1 @@\n-        array[0] = NotFlattenable.default;\n+        array[0] = new NotFlattenable();\n@@ -2446,2 +2460,2 @@\n-        MyValue1[] array1 = new MyValue1[1];\n-        NotFlattenable[] array2 = new NotFlattenable[1];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n@@ -2467,1 +2481,1 @@\n-        array[0] = NotFlattenable.default;\n+        array[0] = new NotFlattenable();\n@@ -2475,2 +2489,2 @@\n-        MyValue1[] array1 = new MyValue1[1];\n-        NotFlattenable[] array2 = new NotFlattenable[1];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n@@ -2489,1 +2503,2 @@\n-    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n+    \/\/ TODO 8325106 This fails to detect the \"movq    R10, precise [compiler\/valhalla\/inlinetypes\/MyValue1\" shape, also affects mainline\n+    \/\/ @IR(counts = { IRNode.CHECKCAST_ARRAY, \"= 1\" })\n@@ -2497,1 +2512,1 @@\n-        NotFlattenable[] array2 = new NotFlattenable[1];\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n@@ -2502,2 +2517,2 @@\n-    static final MyValue2[] val_src = new MyValue2[8];\n-    static final MyValue2[] val_dst = new MyValue2[8];\n+    static final MyValue2[] val_src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+    static final MyValue2[] val_dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -2508,0 +2523,1 @@\n+    @ForceInline\n@@ -2509,0 +2525,1 @@\n+    @ForceInline\n@@ -2510,1 +2527,3 @@\n-    static Class get_val_class() { return MyValue2[].class; }\n+    @ForceInline\n+    static Class get_val_class() { return val_src.getClass(); }\n+    @ForceInline\n@@ -2512,0 +2531,1 @@\n+    @ForceInline\n@@ -2513,0 +2533,1 @@\n+    @ForceInline\n@@ -2514,0 +2535,1 @@\n+    @ForceInline\n@@ -2515,0 +2537,1 @@\n+    @ForceInline\n@@ -2690,1 +2713,1 @@\n-        return Arrays.copyOf(val_src, 8, MyValue2[].class);\n+        return Arrays.copyOf(val_src, 8, val_src.getClass());\n@@ -2729,1 +2752,1 @@\n-        return Arrays.copyOf(obj_null_src, 8, MyValue2[].class);\n+        return Arrays.copyOf(obj_null_src, 8, val_src.getClass());\n@@ -2821,1 +2844,1 @@\n-        return Arrays.copyOf(src, 8, MyValue2[].class);\n+        return Arrays.copyOf(src, 8, val_src.getClass());\n@@ -2876,1 +2899,1 @@\n-        return Arrays.copyOf(src, 8, MyValue2[].class);\n+        return Arrays.copyOf(src, 8, val_src.getClass());\n@@ -2893,1 +2916,0 @@\n-\n@@ -2972,1 +2994,1 @@\n-        res = test125(val_src, MyValue2[].class);\n+        res = test125(val_src, val_src.getClass());\n@@ -2974,1 +2996,1 @@\n-        res = test125(obj_src, MyValue2[].class);\n+        res = test125(obj_src, val_src.getClass());\n@@ -2977,1 +2999,1 @@\n-            test125(obj_null_src, MyValue2[].class);\n+            test125(obj_null_src, val_src.getClass());\n@@ -2983,1 +3005,1 @@\n-            test125(arr, MyValue2[].class);\n+            test125(arr, val_src.getClass());\n@@ -2996,2 +3018,1 @@\n-\n-    \/\/ Verify that clone from (flat) inline type array not containing oops is always optimized.\n+    \/\/ Verify that clone from (flat) value class array not containing oops is always optimized.\n@@ -3004,2 +3025,2 @@\n-    public Object[] test126(MyValue2[] src) {\n-        return src.clone();\n+    public Object[] test126() {\n+        return val_src.clone();\n@@ -3010,1 +3031,1 @@\n-        Object[] res = test126(val_src);\n+        Object[] res = test126();\n@@ -3041,2 +3062,2 @@\n-    public Object[] test128(MyValue2[] src, Class klass) {\n-        return Arrays.copyOf(src, 8, klass);\n+    public Object[] test128(Class klass) {\n+        return Arrays.copyOf(val_src, 8, klass);\n@@ -3047,1 +3068,1 @@\n-        Object[] res = test128(val_src, MyValue2[].class);\n+        Object[] res = test128(MyValue2[].class);\n@@ -3049,1 +3070,1 @@\n-        res = test128(val_src, Object[].class);\n+        res = test128(Object[].class);\n@@ -3052,1 +3073,1 @@\n-            test128(val_src, MyValue1[].class);\n+            test128(MyValue1[].class);\n@@ -3081,1 +3102,4 @@\n-    \/\/ Empty inline type array access\n+    @NullRestricted\n+    static final MyValueEmpty empty = new MyValueEmpty();\n+\n+    \/\/ Empty value class array access\n@@ -3083,1 +3107,2 @@\n-    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n+    \/\/ TODO 8325106 Shouldn't profiling determine that the array is null restricted?\n+    \/\/@IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n@@ -3091,4 +3116,4 @@\n-        MyValueEmpty[] array = new MyValueEmpty[2];\n-        MyValueEmpty empty = test130(array);\n-        Asserts.assertEquals(array[0], MyValueEmpty.default);\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        MyValueEmpty[] array = (MyValueEmpty[])ValueClass.newNullRestrictedArray(MyValueEmpty.class, 2);\n+        MyValueEmpty res = test130(array);\n+        Asserts.assertEquals(array[0], empty);\n+        Asserts.assertEquals(res, empty);\n@@ -3097,2 +3122,5 @@\n-    static primitive class EmptyContainer {\n-        MyValueEmpty empty = MyValueEmpty.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyContainer {\n+        @NullRestricted\n+        MyValueEmpty empty = new MyValueEmpty();\n@@ -3101,1 +3129,1 @@\n-    \/\/ Empty inline type container array access\n+    \/\/ Empty value class container array access\n@@ -3103,1 +3131,2 @@\n-    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n+    \/\/ TODO 8325106 Shouldn't profiling determine that the array is null restricted?\n+    \/\/@IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n@@ -3111,4 +3140,4 @@\n-        EmptyContainer[] array = new EmptyContainer[2];\n-        MyValueEmpty empty = test131(array);\n-        Asserts.assertEquals(array[0], EmptyContainer.default);\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        EmptyContainer[] array = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 2);\n+        MyValueEmpty res = test131(array);\n+        Asserts.assertEquals(array[0], new EmptyContainer());\n+        Asserts.assertEquals(res, new MyValueEmpty());\n@@ -3117,1 +3146,1 @@\n-    \/\/ Empty inline type array access with unknown array type\n+    \/\/ Empty value class array access with unknown array type\n@@ -3126,4 +3155,4 @@\n-        Object[] array = new MyValueEmpty[2];\n-        Object empty = test132(array);\n-        Asserts.assertEquals(array[0], MyValueEmpty.default);\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        Object[] array = (MyValueEmpty[])ValueClass.newNullRestrictedArray(MyValueEmpty.class, 2);\n+        Object res = test132(array);\n+        Asserts.assertEquals(array[0], empty);\n+        Asserts.assertEquals(res, empty);\n@@ -3131,3 +3160,3 @@\n-        empty = test132(array);\n-        Asserts.assertEquals(array[0], MyValueEmpty.default);\n-        Asserts.assertEquals(empty, null);\n+        res = test132(array);\n+        Asserts.assertEquals(array[0], empty);\n+        Asserts.assertEquals(res, null);\n@@ -3136,1 +3165,1 @@\n-    \/\/ Empty inline type container array access with unknown array type\n+    \/\/ Empty value class container array access with unknown array type\n@@ -3145,4 +3174,5 @@\n-        Object[] array = new EmptyContainer[2];\n-        Object empty = test133(array);\n-        Asserts.assertEquals(array[0], EmptyContainer.default);\n-        Asserts.assertEquals(empty, EmptyContainer.default);\n+        EmptyContainer empty = new EmptyContainer();\n+        Object[] array = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 2);\n+        Object res = test133(array);\n+        Asserts.assertEquals(array[0], empty);\n+        Asserts.assertEquals(res, empty);\n@@ -3150,3 +3180,3 @@\n-        empty = test133(array);\n-        Asserts.assertEquals(array[0], EmptyContainer.default);\n-        Asserts.assertEquals(empty, null);\n+        res = test133(array);\n+        Asserts.assertEquals(array[0], empty);\n+        Asserts.assertEquals(res, null);\n@@ -3155,1 +3185,1 @@\n-    \/\/ Non-escaping empty inline type array access\n+    \/\/ Non-escaping empty value class array access\n@@ -3158,1 +3188,1 @@\n-    public static MyValueEmpty test134(MyValueEmpty val) {\n+    public static MyValueEmpty test134() {\n@@ -3160,1 +3190,1 @@\n-        array[0] = val;\n+        array[0] = empty;\n@@ -3166,2 +3196,2 @@\n-        MyValueEmpty empty = test134(MyValueEmpty.default);\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        MyValueEmpty res = test134();\n+        Asserts.assertEquals(res, empty);\n@@ -3170,1 +3200,1 @@\n-    \/\/ Test accessing a locked (inline type) array\n+    \/\/ Test accessing a locked (value class) array\n@@ -3179,1 +3209,1 @@\n-        MyValue1[] array1 = new MyValue1[2];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -3208,1 +3238,1 @@\n-        MyValue1[] array1 = new MyValue1[2];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -3222,1 +3252,1 @@\n-    \/\/ Test loop unwswitching with locked (inline type) array accesses\n+    \/\/ Test loop unwswitching with locked (value class) array accesses\n@@ -3233,1 +3263,1 @@\n-        MyValue1[] array1 = new MyValue1[100];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 100);\n@@ -3276,1 +3306,1 @@\n-        MyValue1[] array1 = new MyValue1[100];\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 100);\n@@ -3295,1 +3325,1 @@\n-    \/\/ Test load from array that is only known to be non-inline after parsing\n+    \/\/ Test load from array that is only known to be not a value class array after parsing\n@@ -3302,1 +3332,1 @@\n-        Object[] varray = new MyValue1[1];\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -3316,1 +3346,1 @@\n-    \/\/ Test store to array that is only known to be non-inline after parsing\n+    \/\/ Test store to array that is only known to be not a value class array after parsing\n@@ -3323,1 +3353,1 @@\n-        Object[] varray = new MyValue1[1];\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -3340,1 +3370,1 @@\n-    \/\/ Test load from array that is only known to be inline after parsing\n+    \/\/ Test load from array that is only known to be not a value class array after parsing\n@@ -3347,1 +3377,1 @@\n-        Object[] varray = new MyValue1[1];\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -3358,1 +3388,1 @@\n-        Asserts.assertEquals(res, MyValue1.default);\n+        Asserts.assertEquals(res, MyValue1.createDefaultInline());\n@@ -3361,1 +3391,1 @@\n-    \/\/ Test store to array that is only known to be inline after parsing\n+    \/\/ Test store to array that is only known to be not a value class array after parsing\n@@ -3368,1 +3398,1 @@\n-        Object[] varray = new MyValue1[1];\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -3379,2 +3409,2 @@\n-        Object[] res = test142(MyValue1.default);\n-        Asserts.assertEquals(res[0], MyValue1.default);\n+        Object[] res = test142(MyValue1.createDefaultInline());\n+        Asserts.assertEquals(res[0], MyValue1.createDefaultInline());\n@@ -3442,1 +3472,1 @@\n-    \/\/ Test that array load slow path correctly initializes non-flattened field of empty inline type\n+    \/\/ Test that array load slow path correctly initializes non-flattened field of empty value class\n@@ -3450,1 +3480,1 @@\n-        Object[] array = new EmptyContainer[1];\n+        Object[] array = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 1);\n@@ -3452,1 +3482,1 @@\n-        Asserts.assertEquals(empty, EmptyContainer.default);\n+        Asserts.assertEquals(empty, new EmptyContainer());\n@@ -3455,1 +3485,1 @@\n-    \/\/ Test that non-flattened array does not block inline type scalarization\n+    \/\/ Test that non-flattened array does not block scalarization\n@@ -3476,1 +3506,1 @@\n-    \/\/ Test that non-flattened array does not block inline type scalarization\n+    \/\/ Test that non-flattened array does not block scalarization\n@@ -3482,1 +3512,1 @@\n-        MyValue2[] array = new MyValue2[1];\n+        MyValue2[] array = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n@@ -3513,2 +3543,2 @@\n-        MyValue1[] src = new MyValue1[1];\n-        MyValue1[] dst = new MyValue1[1];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -3527,1 +3557,1 @@\n-    \/\/ Abstract class without any primitive class implementers\n+    \/\/ Abstract class without any value class implementers\n@@ -3562,1 +3592,3 @@\n-    static primitive class Test150Value {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test150Value {\n@@ -3569,1 +3601,2 @@\n-        Test150Value[] array = { new Test150Value() };\n+        Test150Value[] array = (Test150Value[])ValueClass.newNullRestrictedArray(Test150Value.class, 1);\n+        array[0] = new Test150Value();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":308,"deletions":275,"binary":false,"changes":583,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -37,2 +42,1 @@\n- * @summary Test the basic inline type implementation in C2\n- *\n+ * @summary Test the basic value class implementation in C2.\n@@ -40,0 +44,1 @@\n+ * @modules java.base\/jdk.internal.value\n@@ -41,3 +46,3 @@\n- * @compile InlineTypes.java\n- * @compile -XDenablePrimitiveClasses TestBasicFunctionality.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestBasicFunctionality\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestBasicFunctionality.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestBasicFunctionality\n@@ -68,2 +73,1 @@\n-\n-    \/\/ Receive inline type through call to interpreter\n+    \/\/ Receive value class through call to interpreter\n@@ -83,2 +87,1 @@\n-\n-    \/\/ Receive inline type from interpreter via parameter\n+    \/\/ Receive value object from interpreter via parameter\n@@ -98,2 +101,1 @@\n-\n-    \/\/ Return incoming inline type without accessing fields\n+    \/\/ Return incoming value object without accessing fields\n@@ -118,2 +120,2 @@\n-    \/\/ Create an inline type in compiled code and only use fields.\n-    \/\/ Allocation should go away because inline type does not escape.\n+    \/\/ Create a value object in compiled code and only use fields.\n+    \/\/ Allocation should go away because value object does not escape.\n@@ -133,1 +135,1 @@\n-    \/\/ Create an inline type in compiled code and pass it to\n+    \/\/ Create a value object in compiled code and pass it to\n@@ -153,1 +155,1 @@\n-    \/\/ Create an inline type in compiled code and pass it to\n+    \/\/ Create a value object in compiled code and pass it to\n@@ -174,1 +176,1 @@\n-    \/\/ Create an inline type in compiled code and pass it to\n+    \/\/ Create a value object in compiled code and pass it to\n@@ -189,1 +191,1 @@\n-    \/\/ Merge inline types created from two branches\n+    \/\/ Merge value objects created from two branches\n@@ -208,1 +210,1 @@\n-    \/\/ Merge inline types created from two branches\n+    \/\/ Merge value objects created from two branches\n@@ -214,3 +216,4 @@\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n-        counts = {ALLOC, \"= 2\", STORE, \"= 19\"},\n-        failOn = {LOAD, TRAP})\n+    \/\/ TODO 8325106\n+    \/\/ @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+    \/\/     counts = {ALLOC, \"= 2\", STORE, \"= 19\"},\n+    \/\/     failOn = {LOAD, TRAP})\n@@ -220,1 +223,1 @@\n-            \/\/ Inline type is not allocated\n+            \/\/ Value object is not allocated\n@@ -226,1 +229,1 @@\n-            \/\/ Inline type is allocated by the callee\n+            \/\/ Value object is allocated by the callee\n@@ -229,1 +232,1 @@\n-        \/\/ Need to allocate inline type if 'b' is true\n+        \/\/ Need to allocate value object if 'b' is true\n@@ -236,1 +239,1 @@\n-        \/\/ Don't need to allocate inline type because both branches allocate\n+        \/\/ Don't need to allocate value object because both branches allocate\n@@ -250,1 +253,1 @@\n-    \/\/ Merge inline types created in a loop (not inlined)\n+    \/\/ Merge value objects created in a loop (not inlined)\n@@ -267,1 +270,1 @@\n-    \/\/ Merge inline types created in a loop (inlined)\n+    \/\/ Merge value objects created in a loop (inlined)\n@@ -284,1 +287,1 @@\n-    \/\/ Test loop with uncommon trap referencing an inline type\n+    \/\/ Test loop with uncommon trap referencing a value object\n@@ -290,1 +293,1 @@\n-        MyValue1[] va = new MyValue1[Math.abs(rI) % 10];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, Math.abs(rI) % 10);\n@@ -316,1 +319,1 @@\n-    \/\/ Test loop with uncommon trap referencing an inline type\n+    \/\/ Test loop with uncommon trap referencing a value object\n@@ -320,1 +323,1 @@\n-        MyValue1[] va = new MyValue1[Math.abs(rI) % 10];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, Math.abs(rI) % 10);\n@@ -346,2 +349,2 @@\n-    \/\/ Create an inline type in a non-inlined method and then call a\n-    \/\/ non-inlined method on that inline type.\n+    \/\/ Create a value object in a non-inlined method and then call a\n+    \/\/ non-inlined method on that value object.\n@@ -365,2 +368,2 @@\n-    \/\/ Create an inline type in an inlined method and then call a\n-    \/\/ non-inlined method on that inline type.\n+    \/\/ Create a value object in an inlined method and then call a\n+    \/\/ non-inlined method on that value object.\n@@ -385,2 +388,2 @@\n-    \/\/ Create an inline type in a non-inlined method and then call an\n-    \/\/ inlined method on that inline type.\n+    \/\/ Create a value object in a non-inlined method and then call an\n+    \/\/ inlined method on that value object.\n@@ -400,2 +403,2 @@\n-    \/\/ Create an inline type in an inlined method and then call an\n-    \/\/ inlined method on that inline type.\n+    \/\/ Create a value object in an inlined method and then call an\n+    \/\/ inlined method on that value object.\n@@ -415,2 +418,2 @@\n-    \/\/ Create an inline type in compiled code and pass it to the\n-    \/\/ interpreter via a call. The inline type is live at the first call so\n+    \/\/ Create a value object in compiled code and pass it to the\n+    \/\/ interpreter via a call. The value object is live at the first call so\n@@ -437,2 +440,2 @@\n-    \/\/ Create an inline type in compiled code and pass it to the\n-    \/\/ interpreter via a call. The inline type is passed twice but\n+    \/\/ Create a value object in compiled code and pass it to the\n+    \/\/ interpreter via a call. The value object is passed twice but\n@@ -463,3 +466,3 @@\n-    \/\/ Create an inline type (array) in compiled code and pass it to the\n-    \/\/ interpreter via a call. The inline type is live at the uncommon\n-    \/\/ trap: verify that deoptimization causes the inline type to be\n+    \/\/ Create a value type (array) in compiled code and pass it to the\n+    \/\/ interpreter via a call. The value object is live at the uncommon\n+    \/\/ trap: verify that deoptimization causes the value object to be\n@@ -476,1 +479,1 @@\n-        MyValue2[] va = new MyValue2[3];\n+        MyValue2[] va = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 3);\n@@ -488,1 +491,1 @@\n-        MyValue2[] va = new MyValue2[42];\n+        MyValue2[] va = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 42);\n@@ -493,1 +496,2 @@\n-    \/\/ Inline type fields in regular object\n+    \/\/ Value class fields in regular object\n+    @NullRestricted\n@@ -495,0 +499,1 @@\n+    @NullRestricted\n@@ -496,0 +501,1 @@\n+    @NullRestricted\n@@ -497,0 +503,1 @@\n+    @NullRestricted\n@@ -498,0 +505,1 @@\n+    @NullRestricted\n@@ -500,1 +508,1 @@\n-    \/\/ Test inline type fields in objects\n+    \/\/ Test value class fields in objects\n@@ -505,1 +513,1 @@\n-        \/\/ Compute hash of inline type fields\n+        \/\/ Compute hash of value class fields\n@@ -525,1 +533,1 @@\n-        \/\/ Check if inline type fields were updated\n+        \/\/ Check if value class fields were updated\n@@ -531,1 +539,1 @@\n-    \/\/ Test folding of constant inline type fields\n+    \/\/ Test folding of constant value class fields\n@@ -574,1 +582,1 @@\n-    \/\/ Test withfield\n+    \/\/ Test field initialization\n@@ -588,1 +596,1 @@\n-    \/\/ Test withfield\n+    \/\/ Test field initialization\n@@ -604,0 +612,1 @@\n+        @NullRestricted\n@@ -607,1 +616,1 @@\n-    \/\/ Test allocation elimination of unused object with initialized inline type field\n+    \/\/ Test allocation elimination of unused object with initialized value class field\n@@ -625,0 +634,1 @@\n+    @NullRestricted\n@@ -626,0 +636,1 @@\n+    @NullRestricted\n@@ -628,1 +639,1 @@\n-    \/\/ Check elimination of redundant inline type allocations\n+    \/\/ Check elimination of redundant value class allocations\n@@ -632,1 +643,1 @@\n-        \/\/ Create inline type and force allocation\n+        \/\/ Create value object and force allocation\n@@ -638,1 +649,1 @@\n-        \/\/ Inline type is now allocated, make a copy and force allocation.\n+        \/\/ Value object is now allocated, make a copy and force allocation.\n@@ -649,1 +660,1 @@\n-        MyValue3[] va = new MyValue3[1];\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n@@ -680,1 +691,1 @@\n-    \/\/ Verify that C2 recognizes inline type loads and re-uses the oop to avoid allocations\n+    \/\/ Verify that C2 recognizes value class loads and re-uses the oop to avoid allocations\n@@ -684,1 +695,1 @@\n-    public MyValue3 test30(MyValue3[] va) {\n+    public MyValue3 test30() {\n@@ -686,0 +697,1 @@\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n@@ -688,0 +700,1 @@\n+        copy.verify(va[0]);\n@@ -696,2 +709,1 @@\n-        MyValue3[] va = new MyValue3[1];\n-        MyValue3 vt = test30(va);\n+        MyValue3 vt = test30();\n@@ -699,1 +711,0 @@\n-        staticVal3.verify(va[0]);\n@@ -702,1 +713,1 @@\n-    \/\/ Verify that C2 recognizes inline type loads and re-uses the oop to avoid allocations\n+    \/\/ Verify that C2 recognizes value class loads and re-uses the oop to avoid allocations\n@@ -706,1 +717,1 @@\n-    public MyValue3 test31(MyValue3[] va) {\n+    public MyValue3 test31() {\n@@ -708,1 +719,2 @@\n-        \/\/ because the corresponding inline type is equal to 'copy'.\n+        \/\/ because the corresponding value object is equal to 'copy'.\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n@@ -711,0 +723,1 @@\n+        copy.verify(va[0]);\n@@ -718,2 +731,1 @@\n-        MyValue3[] va = new MyValue3[1];\n-        MyValue3 vt = test31(va);\n+        MyValue3 vt = test31();\n@@ -721,1 +733,0 @@\n-        staticVal3.verify(va[0]);\n@@ -724,1 +735,1 @@\n-    \/\/ Verify that C2 recognizes inline type loads and re-uses the oop to avoid allocations\n+    \/\/ Verify that C2 recognizes value class loads and re-uses the oop to avoid allocations\n@@ -728,1 +739,1 @@\n-    public MyValue3 test32(MyValue3 vt, MyValue3[] va) {\n+    public MyValue3 test32(MyValue3 vt) {\n@@ -730,0 +741,1 @@\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n@@ -732,0 +744,1 @@\n+        copy.verify(vt);\n@@ -740,2 +753,1 @@\n-        MyValue3[] va = new MyValue3[1];\n-        MyValue3 result = test32(vt, va);\n+        MyValue3 result = test32(vt);\n@@ -743,1 +755,0 @@\n-        va[0].verify(vt);\n@@ -747,1 +758,1 @@\n-    \/\/ Test correct identification of inline type copies\n+    \/\/ Test correct identification of value object copies\n@@ -749,1 +760,2 @@\n-    public MyValue3 test33(MyValue3[] va) {\n+    public MyValue3 test33() {\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n@@ -754,0 +766,1 @@\n+        Asserts.assertEQ(va[0].i, (int)vt.c);\n@@ -762,2 +775,1 @@\n-        MyValue3[] va = new MyValue3[1];\n-        MyValue3 vt = test33(va);\n+        MyValue3 vt = test33();\n@@ -765,1 +777,0 @@\n-        Asserts.assertEQ(va[0].i, (int)staticVal3.c);\n@@ -769,1 +780,3 @@\n-    \/\/ Verify that the default inline type is never allocated.\n+    static final MyValue3[] test34Array = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 2);\n+\n+    \/\/ Verify that the default value class is never allocated.\n@@ -774,1 +787,1 @@\n-    public MyValue3 test34(MyValue3[] va) {\n+    public MyValue3 test34() {\n@@ -777,1 +790,1 @@\n-        va[0] = vt;\n+        test34Array[0] = vt;\n@@ -781,2 +794,2 @@\n-        \/\/ Load default value from uninitialized inline type array\n-        MyValue3[] dva = new MyValue3[1];\n+        \/\/ Load default value from uninitialized value class array\n+        MyValue3[] dva = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n@@ -784,1 +797,1 @@\n-        va[1] = dva[0];\n+        test34Array[1] = dva[0];\n@@ -792,4 +805,3 @@\n-        MyValue3[] va = new MyValue3[2];\n-        va[0] = MyValue3.create();\n-        va[1] = MyValue3.create();\n-        MyValue3 res = test34(va);\n+        test34Array[0] = MyValue3.create();\n+        test34Array[1] = MyValue3.create();\n+        MyValue3 res = test34();\n@@ -799,2 +811,2 @@\n-        va[0].verify(vt);\n-        va[1].verify(vt);\n+        test34Array[0].verify(vt);\n+        test34Array[1].verify(vt);\n@@ -803,1 +815,3 @@\n-    \/\/ Same as above but manually initialize inline type fields to default.\n+    static final MyValue3[] test35Array = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+\n+    \/\/ Same as above but manually initialize value class fields to default.\n@@ -807,1 +821,1 @@\n-    public MyValue3 test35(MyValue3 vt, MyValue3[] va) {\n+    public MyValue3 test35(MyValue3 vt) {\n@@ -821,1 +835,1 @@\n-        va[0] = vt;\n+        test35Array[0] = vt;\n@@ -830,3 +844,2 @@\n-        MyValue3[] va = new MyValue3[1];\n-        va[0] = MyValue3.create();\n-        MyValue3 res = test35(va[0], va);\n+        test35Array[0] = MyValue3.create();\n+        MyValue3 res = test35(test35Array[0]);\n@@ -835,1 +848,1 @@\n-        va[0].verify(vt);\n+        test35Array[0].verify(vt);\n@@ -838,1 +851,1 @@\n-    \/\/ Merge inline types created from two branches\n+    \/\/ Merge value objects created from two branches\n@@ -864,3 +877,5 @@\n-    primitive class Test37Value2 {\n-        final int x = 0;\n-        final int y = 0;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test37Value2 {\n+        int x = 0;\n+        int y = 0;\n@@ -869,4 +884,7 @@\n-    primitive class Test37Value1 {\n-        final double d = 0;\n-        final float f = 0;\n-        final Test37Value2 v = new Test37Value2();\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test37Value1 {\n+        double d = 0;\n+        float f = 0;\n+        @NullRestricted\n+        Test37Value2 v = new Test37Value2();\n@@ -886,2 +904,4 @@\n-    \/\/ Test elimination of inline type allocations without a unique CheckCastPP\n-    primitive class Test38Value {\n+    \/\/ Test elimination of value class allocations without a unique CheckCastPP\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test38Value {\n@@ -892,0 +912,1 @@\n+    @NullRestricted\n@@ -908,1 +929,1 @@\n-        test38Field = Test38Value.default;\n+        test38Field = new Test38Value(0);\n@@ -913,2 +934,4 @@\n-    \/\/ Tests split if with inline type Phi users\n-    static primitive class Test39Value {\n+    \/\/ Tests split if with value class Phi users\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test39Value {\n@@ -923,1 +946,2 @@\n-    static Test39Value test39Val = Test39Value.default;\n+    @NullRestricted\n+    static Test39Value test39Val = new Test39Value(0, 0);\n@@ -967,1 +991,1 @@\n-    \/\/ Test scalar replacement of inline type array containing inline type with oop fields\n+    \/\/ Test scalar replacement of value class array containing value class with oop fields\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":140,"deletions":116,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @summary Test bimorphic inlining with inline type receivers.\n+ * @summary Test bimorphic inlining with value object receivers.\n@@ -35,2 +35,1 @@\n- * @compile -XDenablePrimitiveClasses TestBimorphicInlining.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch -XX:TypeProfileLevel=222\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:TypeProfileLevel=222\n@@ -40,1 +39,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch -XX:TypeProfileLevel=222\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:TypeProfileLevel=222\n@@ -51,2 +50,2 @@\n-primitive final class TestValue1 implements MyInterface {\n-    final int x;\n+value class TestValue1 implements MyInterface {\n+    int x;\n@@ -63,2 +62,2 @@\n-primitive final class TestValue2 implements MyInterface {\n-    final int x;\n+value class TestValue2 implements MyInterface {\n+    int x;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBimorphicInlining.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -38,1 +41,1 @@\n- * @summary Detect tearing on inline type buffer writes due to missing barriers.\n+ * @summary Detect tearing on value class buffer writes due to missing barriers.\n@@ -40,3 +43,6 @@\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.value\n- * @compile -XDenablePrimitiveClasses TestBufferTearing.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @modules java.base\/jdk.internal.misc\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestBufferTearing.java\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -46,1 +52,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -51,1 +59,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -56,1 +66,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -64,1 +76,3 @@\n-primitive class MyValue {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue {\n@@ -102,1 +116,1 @@\n-\n+    @NullRestricted\n@@ -104,0 +118,1 @@\n+    @NullRestricted\n@@ -105,1 +120,1 @@\n-    MyValue[] vtField3 = new MyValue[1];\n+    MyValue[] vtField3 = (MyValue[])ValueClass.newNullRestrictedArray(MyValue.class, 1);\n@@ -111,1 +126,1 @@\n-            Class<?> clazz = PrimitiveClass.asValueType(MyValue.class);\n+            Class<?> clazz = MyValue.class;\n@@ -114,1 +129,1 @@\n-            MethodType mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue.class));\n+            MethodType mt = MethodType.methodType(MyValue.class);\n@@ -151,2 +166,2 @@\n-        \/\/ Create threads that concurrently update some inline type (array) fields\n-        \/\/ and check the fields of the inline types for consistency to detect tearing.\n+        \/\/ Create threads that concurrently update some value class (array) fields\n+        \/\/ and check the fields of the value classes for consistency to detect tearing.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearing.java","additions":31,"deletions":16,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,6 @@\n- * @summary Additional tests for C1 missing barriers when buffering inline types.\n- * @compile -XDenablePrimitiveClasses TestBufferTearingC1.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @summary Tests for C1 missing barriers when buffering value classes.\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestBufferTearingC1.java\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -38,2 +41,9 @@\n-primitive class Point {\n-    public final int x, y;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Point {\n+    public int x, y;\n@@ -47,2 +57,4 @@\n-primitive class Rect {\n-    public final Point a, b;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Rect {\n+    public Point a, b;\n@@ -58,1 +70,1 @@\n-    public static Point[] points = new Point[] { new Point(1, 1) };\n+    public static Point[] points = (Point[])ValueClass.newNullRestrictedArray(Point.class, 1);\n@@ -60,1 +72,6 @@\n-    public static Rect[] rects = new Rect[] { rect };\n+    public static Rect[] rects = (Rect[])ValueClass.newNullRestrictedArray(Rect.class, 1);\n+\n+    static {\n+        points[0] = new Point(1, 1);\n+        rects[0] = rect;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearingC1.java","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -38,1 +43,1 @@\n- * @summary Various tests that are specific for C1.\n+ * @summary Various tests that are specific to C1.\n@@ -41,2 +46,3 @@\n- * @compile -XDenablePrimitiveClasses TestC1.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestC1\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestC1.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestC1\n@@ -49,3 +55,1 @@\n-                new Scenario(0,\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                             \"-XX:TieredStopAtLevel=1\", \"-XX:+TieredCompilation\"),\n+                new Scenario(0, \"-XX:TieredStopAtLevel=1\", \"-XX:+TieredCompilation\"),\n@@ -53,3 +57,1 @@\n-                new Scenario(1,\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                             \"-XX:TieredStopAtLevel=4\", \"-XX:-TieredCompilation\"),\n+                new Scenario(1, \"-XX:TieredStopAtLevel=4\", \"-XX:-TieredCompilation\"),\n@@ -57,3 +59,1 @@\n-                new Scenario(2,\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                             \"-Xint\"),\n+                new Scenario(2, \"-Xint\"),\n@@ -61,3 +61,1 @@\n-                new Scenario(3,\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                             \"-XX:TieredStopAtLevel=1\", \"-XX:+TieredCompilation\", \"-Xcomp\"),\n+                new Scenario(3, \"-XX:TieredStopAtLevel=1\", \"-XX:+TieredCompilation\", \"-Xcomp\"),\n@@ -65,3 +63,1 @@\n-                new Scenario(4,\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                             \"-XX:TieredStopAtLevel=4\", \"-XX:-TieredCompilation\", \"-Xcomp\")\n+                new Scenario(4, \"-XX:TieredStopAtLevel=4\", \"-XX:-TieredCompilation\", \"-Xcomp\")\n@@ -72,0 +68,3 @@\n+                   .addFlags(\"-XX:+EnableValhalla\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\")\n@@ -99,2 +98,5 @@\n-    static primitive class SimpleValue2 {\n-        final int value;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class SimpleValue2 {\n+        int value;\n+\n@@ -116,1 +118,1 @@\n-        SimpleValue2[] array = new SimpleValue2[1];\n+        SimpleValue2[] array = (SimpleValue2[])ValueClass.newNullRestrictedArray(SimpleValue2.class, 1);\n@@ -200,1 +202,3 @@\n-    static primitive class Big {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Big {\n@@ -233,1 +237,3 @@\n-    static primitive class TestValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TestValue {\n@@ -235,0 +241,1 @@\n+        @NullRestricted\n@@ -250,1 +257,1 @@\n-        TestValue[] array = new TestValue[7];\n+        TestValue[] array = (TestValue[])ValueClass.newNullRestrictedArray(TestValue.class, 7);\n@@ -281,1 +288,3 @@\n-    static primitive class EmptyType {}\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyType {}\n@@ -285,1 +294,1 @@\n-        EmptyType[] array = new EmptyType[10];\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 10);\n@@ -292,1 +301,1 @@\n-        Asserts.assertEQ(et, EmptyType.default);\n+        Asserts.assertEQ(et, new EmptyType());\n@@ -302,1 +311,1 @@\n-        EmptyType[] array = new EmptyType[16];\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 16);\n@@ -304,1 +313,1 @@\n-        Asserts.assertEQ(et, EmptyType.default);\n+        Asserts.assertEQ(et, new EmptyType());\n@@ -315,1 +324,1 @@\n-        EmptyType[] array = new EmptyType[10];\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 10);\n@@ -345,2 +354,3 @@\n-        EmptyType[] array = new EmptyType[16];\n-        test12(array, 2, EmptyType.default);\n+        EmptyType empty = new EmptyType();\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 16);\n+        test12(array, 2, empty);\n@@ -349,1 +359,1 @@\n-            test12(null, 2, EmptyType.default);\n+            test12(null, 2, empty);\n@@ -356,1 +366,1 @@\n-            test12(array, 17, EmptyType.default);\n+            test12(array, 17, empty);\n@@ -363,1 +373,1 @@\n-            test12(array, -8, EmptyType.default);\n+            test12(array, -8, empty);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @summary Test value numbering behaves correctly with flattened fields\n+ * @summary Test value numbering behaves correctly with flat fields.\n@@ -33,2 +33,5 @@\n- * @compile -XDenablePrimitiveClasses TestC1ValueNumbering.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xcomp -XX:TieredStopAtLevel=1 -ea\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestC1ValueNumbering.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xcomp -XX:TieredStopAtLevel=1 -ea\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -39,0 +42,4 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -40,2 +47,6 @@\n-    static primitive class Point {\n-        int x,y;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Point {\n+        int x;\n+        int y;\n+\n@@ -43,1 +54,2 @@\n-            x = 0; y = 0;\n+            x = 0;\n+            y = 0;\n@@ -45,0 +57,1 @@\n+\n@@ -46,1 +59,2 @@\n-            this.x = x; this.y = y;\n+            this.x = x;\n+            this.y = y;\n@@ -50,0 +64,1 @@\n+    @NullRestricted\n@@ -72,1 +87,1 @@\n-  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1ValueNumbering.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Test inline type calling convention with compiled to compiled calls.\n+ * @summary Test value class calling convention with compiled to compiled calls.\n@@ -29,1 +29,1 @@\n- * @compile -XDenablePrimitiveClasses TestC2CCalls.java\n+ * @compile TestC2CCalls.java\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -40,1 +40,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -52,1 +52,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -74,2 +74,2 @@\n-    static primitive class OtherVal {\n-        public final int x;\n+    static value class OtherVal {\n+        public int x;\n@@ -84,4 +84,4 @@\n-        public MyInterface1 test2(OtherVal other1, OtherVal.ref other2, int y);\n-        public MyInterface1 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt);\n-        public MyInterface1 test4(OtherVal other1, OtherVal.ref other2, int y);\n-        public MyInterface1 test5(OtherVal other1, OtherVal.ref other2, int y);\n+        public MyInterface1 test2(OtherVal other1, OtherVal other2, int y);\n+        public MyInterface1 test3(OtherVal other1, OtherVal other2, int y, boolean deopt);\n+        public MyInterface1 test4(OtherVal other1, OtherVal other2, int y);\n+        public MyInterface1 test5(OtherVal other1, OtherVal other2, int y);\n@@ -97,2 +97,2 @@\n-    static primitive class MyValue1 implements MyInterface1 {\n-        public final int x;\n+    static value class MyValue1 implements MyInterface1 {\n+        public int x;\n@@ -115,1 +115,1 @@\n-        public MyValue1 test2(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyValue1 test2(OtherVal other1, OtherVal other2, int y) {\n@@ -120,1 +120,1 @@\n-        public MyValue1 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {\n+        public MyValue1 test3(OtherVal other1, OtherVal other2, int y, boolean deopt) {\n@@ -130,1 +130,1 @@\n-        public MyValue1 test4(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyValue1 test4(OtherVal other1, OtherVal other2, int y) {\n@@ -135,1 +135,1 @@\n-        public MyValue1 test5(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyValue1 test5(OtherVal other1, OtherVal other2, int y) {\n@@ -163,2 +163,2 @@\n-    static primitive class MyValue2 implements MyInterface1 {\n-        public final int x;\n+    static value class MyValue2 implements MyInterface1 {\n+        public int x;\n@@ -181,1 +181,1 @@\n-        public MyValue2 test2(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyValue2 test2(OtherVal other1, OtherVal other2, int y) {\n@@ -186,1 +186,1 @@\n-        public MyValue2 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {\n+        public MyValue2 test3(OtherVal other1, OtherVal other2, int y, boolean deopt) {\n@@ -196,1 +196,1 @@\n-        public MyValue2 test4(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyValue2 test4(OtherVal other1, OtherVal other2, int y) {\n@@ -201,1 +201,1 @@\n-        public MyValue2 test5(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyValue2 test5(OtherVal other1, OtherVal other2, int y) {\n@@ -229,5 +229,5 @@\n-    static primitive class MyValue3 implements MyInterface1 {\n-        public final double d1;\n-        public final double d2;\n-        public final double d3;\n-        public final double d4;\n+    static value class MyValue3 implements MyInterface1 {\n+        public double d1;\n+        public double d2;\n+        public double d3;\n+        public double d4;\n@@ -248,1 +248,1 @@\n-        public MyValue3 test1(OtherVal other, int y) { return MyValue3.default; }\n+        public MyValue3 test1(OtherVal other, int y) { return new MyValue3(0); }\n@@ -250,1 +250,1 @@\n-        public MyValue3 test2(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }\n+        public MyValue3 test2(OtherVal other1, OtherVal other2, int y)  { return new MyValue3(0); }\n@@ -252,1 +252,1 @@\n-        public MyValue3 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt)  { return MyValue3.default; }\n+        public MyValue3 test3(OtherVal other1, OtherVal other2, int y, boolean deopt)  { return new MyValue3(0); }\n@@ -254,1 +254,1 @@\n-        public MyValue3 test4(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }\n+        public MyValue3 test4(OtherVal other1, OtherVal other2, int y)  { return new MyValue3(0); }\n@@ -256,1 +256,1 @@\n-        public MyValue3 test5(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }\n+        public MyValue3 test5(OtherVal other1, OtherVal other2, int y)  { return new MyValue3(0); }\n@@ -258,1 +258,1 @@\n-        public MyValue3 test6()  { return MyValue3.default; }\n+        public MyValue3 test6()  { return new MyValue3(0); }\n@@ -279,5 +279,5 @@\n-    static primitive class MyValue4 implements MyInterface1 {\n-        public final int x1;\n-        public final int x2;\n-        public final int x3;\n-        public final int x4;\n+    static value class MyValue4 implements MyInterface1 {\n+        public int x1;\n+        public int x2;\n+        public int x3;\n+        public int x4;\n@@ -298,1 +298,1 @@\n-        public MyValue4 test1(OtherVal other, int y) { return MyValue4.default; }\n+        public MyValue4 test1(OtherVal other, int y) { return new MyValue4(0); }\n@@ -300,1 +300,1 @@\n-        public MyValue4 test2(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }\n+        public MyValue4 test2(OtherVal other1, OtherVal other2, int y)  { return new MyValue4(0); }\n@@ -302,1 +302,1 @@\n-        public MyValue4 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt)  { return MyValue4.default; }\n+        public MyValue4 test3(OtherVal other1, OtherVal other2, int y, boolean deopt)  { return new MyValue4(0); }\n@@ -304,1 +304,1 @@\n-        public MyValue4 test4(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }\n+        public MyValue4 test4(OtherVal other1, OtherVal other2, int y)  { return new MyValue4(0); }\n@@ -306,1 +306,1 @@\n-        public MyValue4 test5(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }\n+        public MyValue4 test5(OtherVal other1, OtherVal other2, int y)  { return new MyValue4(0); }\n@@ -308,1 +308,1 @@\n-        public MyValue4 test6()  { return MyValue4.default; }\n+        public MyValue4 test6()  { return new MyValue4(0); }\n@@ -347,1 +347,1 @@\n-        public MyObject test2(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyObject test2(OtherVal other1, OtherVal other2, int y) {\n@@ -352,1 +352,1 @@\n-        public MyObject test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {\n+        public MyObject test3(OtherVal other1, OtherVal other2, int y, boolean deopt) {\n@@ -362,1 +362,1 @@\n-        public MyObject test4(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyObject test4(OtherVal other1, OtherVal other2, int y) {\n@@ -367,1 +367,1 @@\n-        public MyObject test5(OtherVal other1, OtherVal.ref other2, int y) {\n+        public MyObject test5(OtherVal other1, OtherVal other2, int y) {\n@@ -395,1 +395,1 @@\n-    \/\/ Test calling methods with inline type arguments through an interface\n+    \/\/ Test calling methods with value class arguments through an interface\n@@ -404,1 +404,1 @@\n-    \/\/ Test mixing null-tolerant and null-free inline type arguments\n+    \/\/ Test mixing null-tolerant and null-free value class arguments\n@@ -413,1 +413,1 @@\n-    \/\/ Optimized interface call with inline type receiver\n+    \/\/ Optimized interface call with value class receiver\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC2CCalls.java","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -42,1 +45,1 @@\n- * @summary Test inline type calling convention optimizations\n+ * @summary Test value class calling convention optimizations.\n@@ -46,2 +49,3 @@\n- * @compile -XDenablePrimitiveClasses TestCallingConvention.java\n- * @run main\/othervm\/timeout=450 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestCallingConvention\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestCallingConvention.java\n+ * @run main\/othervm\/timeout=450 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestCallingConvention\n@@ -58,1 +62,1 @@\n-            MethodType mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class), boolean.class);\n+            MethodType mt = MethodType.methodType(MyValue2.class, boolean.class);\n@@ -65,1 +69,1 @@\n-            test37_mh = lookup.findVirtual(PrimitiveClass.asValueType(Test37Value.class), \"test\", mt);\n+            test37_mh = lookup.findVirtual(Test37Value.class, \"test\", mt);\n@@ -303,1 +307,1 @@\n-            deoptimize(\"test13\", PrimitiveClass.asValueType(MyValue2.class), MyValue1[].class, boolean.class, long.class);\n+            deoptimize(\"test13\", MyValue2.class, MyValue1[].class, boolean.class, long.class);\n@@ -317,1 +321,1 @@\n-        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -324,1 +328,1 @@\n-    \/\/ Test deoptimization at call return with inline type returned in registers\n+    \/\/ Test deoptimization at call return with value object returned in registers\n@@ -346,1 +350,2 @@\n-    \/\/ Return inline types in registers from interpreter -> compiled\n+    \/\/ Return value objects in registers from interpreter -> compiled\n+    @NullRestricted\n@@ -348,0 +353,1 @@\n+\n@@ -353,0 +359,1 @@\n+    @NullRestricted\n@@ -354,0 +361,1 @@\n+\n@@ -367,1 +375,2 @@\n-    \/\/ Return inline types in registers from compiled -> interpreter\n+    \/\/ Return value objects in registers from compiled -> interpreter\n+    @NullRestricted\n@@ -369,0 +378,1 @@\n+\n@@ -382,1 +392,2 @@\n-    \/\/ Return inline types in registers from compiled -> compiled\n+    \/\/ Return value objects in registers from compiled -> compiled\n+    @NullRestricted\n@@ -384,0 +395,1 @@\n+\n@@ -389,0 +401,1 @@\n+    @NullRestricted\n@@ -390,0 +403,1 @@\n+\n@@ -409,1 +423,1 @@\n-    \/\/ Same tests as above but with an inline type that cannot be returned in registers\n+    \/\/ Same tests as above but with a value class that cannot be returned in registers\n@@ -411,1 +425,2 @@\n-    \/\/ Return inline types in registers from interpreter -> compiled\n+    \/\/ Return value objects in registers from interpreter -> compiled\n+    @NullRestricted\n@@ -413,0 +428,1 @@\n+\n@@ -418,0 +434,1 @@\n+    @NullRestricted\n@@ -419,0 +436,1 @@\n+\n@@ -430,1 +448,2 @@\n-    \/\/ Return inline types in registers from compiled -> interpreter\n+    \/\/ Return value objects in registers from compiled -> interpreter\n+    @NullRestricted\n@@ -432,0 +451,1 @@\n+\n@@ -443,1 +463,2 @@\n-    \/\/ Return inline types in registers from compiled -> compiled\n+    \/\/ Return value objects in registers from compiled -> compiled\n+    @NullRestricted\n@@ -445,0 +466,1 @@\n+\n@@ -450,0 +472,1 @@\n+    @NullRestricted\n@@ -451,0 +474,1 @@\n+\n@@ -468,0 +492,1 @@\n+    @NullRestricted\n@@ -469,0 +494,1 @@\n+\n@@ -488,2 +514,2 @@\n-    \/\/ Test returning a non-flattened inline type as fields\n-    MyValue3.ref test22_vt = MyValue3.create();\n+    \/\/ Test returning a non-flattened value object as fields\n+    MyValue3 test22_vt = MyValue3.create();\n@@ -502,3 +528,6 @@\n-    \/\/ Test calling a method that has circular register\/stack dependencies when unpacking inline type arguments\n-    primitive class TestValue23 {\n-        final double f1;\n+    \/\/ Test calling a method that has circular register\/stack dependencies when unpacking value class arguments\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class TestValue23 {\n+        double f1;\n+\n@@ -539,1 +568,1 @@\n-    \/\/ Should not return a nullable inline type as fields\n+    \/\/ Should not return a nullable value object as fields\n@@ -541,1 +570,1 @@\n-    public MyValue2.ref test24() {\n+    public MyValue2 test24() {\n@@ -547,1 +576,1 @@\n-        MyValue2.ref vt = test24();\n+        MyValue2 vt = test24();\n@@ -553,1 +582,1 @@\n-    public MyValue2.ref test26_callee(boolean b) {\n+    public MyValue2 test26_callee(boolean b) {\n@@ -562,1 +591,1 @@\n-    public MyValue2.ref test26(boolean b) {\n+    public MyValue2 test26(boolean b) {\n@@ -568,1 +597,1 @@\n-        MyValue2.ref vt = test26(true);\n+        MyValue2 vt = test26(true);\n@@ -575,2 +604,4 @@\n-    final primitive class Test27Value1 {\n-        final Test27Value2 valueField;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test27Value1 {\n+        Test27Value2 valueField;\n@@ -588,2 +619,4 @@\n-    final primitive class Test27Value2 {\n-        final Test27Value3 valueField;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test27Value2 {\n+        Test27Value3 valueField;\n@@ -601,2 +634,4 @@\n-    final primitive class Test27Value3 {\n-        final int x;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test27Value3 {\n+        int x;\n@@ -628,1 +663,1 @@\n-    static final MyValue1.ref test28Val = MyValue1.createWithFieldsDontInline(rI, rL);\n+    static final MyValue1 test28Val = MyValue1.createWithFieldsDontInline(rI, rL);\n@@ -641,1 +676,2 @@\n-    \/\/ Test calling a method returning an inline type as fields via reflection\n+    \/\/ Test calling a method returning a value object as fields via reflection\n+    @NullRestricted\n@@ -664,1 +700,1 @@\n-        MyValue3[] array = new MyValue3[1];\n+        MyValue3[] array = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n@@ -669,0 +705,1 @@\n+    @NullRestricted\n@@ -684,1 +721,1 @@\n-    \/\/ Test deoptimization at call return with inline type returned in registers.\n+    \/\/ Test deoptimization at call return with value object returned in registers.\n@@ -794,1 +831,2 @@\n-    \/\/ pre-allocated buffer for the returned inline type remains valid.\n+    \/\/ pre-allocated buffer for the returned value object remains valid.\n+    @NullRestricted\n@@ -811,1 +849,1 @@\n-    \/\/ Test method resolution with scalarized inline type receiver at invokespecial\n+    \/\/ Test method resolution with scalarized value object receiver at invokespecial\n@@ -814,1 +852,3 @@\n-    primitive class Test37Value {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test37Value {\n@@ -836,1 +876,1 @@\n-    \/\/ Test passing\/returning an empty inline type\n+    \/\/ Test passing\/returning an empty value object\n@@ -850,1 +890,3 @@\n-    static primitive class LargeValueWithOops {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class LargeValueWithOops {\n@@ -883,1 +925,3 @@\n-    static primitive class LargeValueWithoutOops {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class LargeValueWithoutOops {\n@@ -925,1 +969,1 @@\n-    \/\/ Test passing\/returning a large inline type with oop fields\n+    \/\/ Test passing\/returning a large value object with oop fields\n@@ -938,1 +982,1 @@\n-    \/\/ Test passing\/returning a large inline type with only int\/float fields\n+    \/\/ Test passing\/returning a large value object with only int\/float fields\n@@ -951,2 +995,2 @@\n-    \/\/ Test passing\/returning an empty inline type together with non-empty\n-    \/\/ inline types such that only some inline type arguments are scalarized.\n+    \/\/ Test passing\/returning an empty value object together with non-empty\n+    \/\/ value objects such that only some value class arguments are scalarized.\n@@ -961,2 +1005,2 @@\n-        MyValueEmpty res = test41(MyValue1.default, MyValueEmpty.default, MyValue1.default);\n-        Asserts.assertEQ(res, MyValueEmpty.default);\n+        MyValueEmpty res = test41(MyValue1.createDefaultInline(), new MyValueEmpty(), MyValue1.createDefaultInline());\n+        Asserts.assertEQ(res, new MyValueEmpty());\n@@ -965,1 +1009,1 @@\n-    \/\/ More empty inline type tests with containers\n+    \/\/ More empty value class tests with containers\n@@ -967,1 +1011,4 @@\n-    static primitive class EmptyContainer {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyContainer {\n+        @NullRestricted\n@@ -982,1 +1029,3 @@\n-    static primitive class MixedContainer {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MixedContainer {\n@@ -984,0 +1033,1 @@\n+        @NullRestricted\n@@ -999,1 +1049,1 @@\n-    \/\/ Empty inline type return\n+    \/\/ Empty value object return\n@@ -1003,1 +1053,1 @@\n-        EmptyContainer c = new EmptyContainer(MyValueEmpty.default);\n+        EmptyContainer c = new EmptyContainer(new MyValueEmpty());\n@@ -1010,1 +1060,1 @@\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        Asserts.assertEquals(empty, new MyValueEmpty());\n@@ -1013,1 +1063,1 @@\n-    \/\/ Empty inline type container return\n+    \/\/ Empty value class container return\n@@ -1022,2 +1072,3 @@\n-        EmptyContainer c = test43(EmptyContainer. default);\n-        Asserts.assertEquals(c, EmptyContainer.default);\n+        EmptyContainer empty = new EmptyContainer(new MyValueEmpty());\n+        EmptyContainer c = test43(empty);\n+        Asserts.assertEquals(c, empty);\n@@ -1026,1 +1077,1 @@\n-    \/\/ Empty inline type container (mixed) return\n+    \/\/ Empty value class container (mixed) return\n@@ -1030,1 +1081,1 @@\n-        MixedContainer c = new MixedContainer(rI, EmptyContainer.default);\n+        MixedContainer c = new MixedContainer(rI, new EmptyContainer(new MyValueEmpty()));\n@@ -1038,1 +1089,1 @@\n-        Asserts.assertEquals(c, new MixedContainer(rI, EmptyContainer.default));\n+        Asserts.assertEquals(c, new MixedContainer(rI, new EmptyContainer(new MyValueEmpty())));\n@@ -1041,1 +1092,1 @@\n-    \/\/ Empty inline type container argument\n+    \/\/ Empty value class container argument\n@@ -1050,2 +1101,3 @@\n-        EmptyContainer empty = test45(EmptyContainer.default);\n-        Asserts.assertEquals(empty, EmptyContainer.default);\n+        EmptyContainer empty = new EmptyContainer(new MyValueEmpty());\n+        EmptyContainer c = test45(empty);\n+        Asserts.assertEquals(c, empty);\n@@ -1054,1 +1106,1 @@\n-    \/\/ Empty inline type container and mixed container arguments\n+    \/\/ Empty value class container and mixed container arguments\n@@ -1056,1 +1108,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n@@ -1064,2 +1116,2 @@\n-        MyValueEmpty empty = test46(EmptyContainer.default, MixedContainer.default, MyValueEmpty.default);\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        MyValueEmpty empty = test46(new EmptyContainer(new MyValueEmpty()), new MixedContainer(0, new EmptyContainer(new MyValueEmpty())), new MyValueEmpty());\n+        Asserts.assertEquals(empty, new MyValueEmpty());\n@@ -1077,2 +1129,2 @@\n-        MyValueEmpty empty = test47(MyValueEmpty.default);\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        MyValueEmpty empty = test47(new MyValueEmpty());\n+        Asserts.assertEquals(empty,new MyValueEmpty());\n@@ -1090,2 +1142,2 @@\n-        MyValueEmpty empty = test48(EmptyContainer.default);\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        MyValueEmpty empty = test48(new EmptyContainer(new MyValueEmpty()));\n+        Asserts.assertEquals(empty, new MyValueEmpty());\n@@ -1094,1 +1146,1 @@\n-    \/\/ Test conditional inline type return with incremental inlining\n+    \/\/ Test conditional value class return with incremental inlining\n@@ -1119,0 +1171,1 @@\n+    @NullRestricted\n@@ -1120,0 +1173,1 @@\n+    @NullRestricted\n@@ -1208,1 +1262,1 @@\n-    public MyValue2.ref test54_callee() {\n+    public MyValue2 test54_callee() {\n@@ -1218,1 +1272,1 @@\n-            obj = (MyValue2.ref)test54_mh.invokeExact(this);\n+            obj = (MyValue2)test54_mh.invokeExact(this);\n@@ -1240,1 +1294,1 @@\n-    public MyValue2.ref test55_callee() {\n+    public MyValue2 test55_callee() {\n@@ -1258,1 +1312,1 @@\n-    public MyValue2.ref test56_callee(boolean b) {\n+    public MyValue2 test56_callee(boolean b) {\n@@ -1264,2 +1318,2 @@\n-    public MyValue2.ref test56(boolean b) throws Throwable {\n-        return (MyValue2.ref)test56_mh.invokeExact(this, b);\n+    public MyValue2 test56(boolean b) throws Throwable {\n+        return (MyValue2)test56_mh.invokeExact(this, b);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":134,"deletions":80,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -39,2 +44,3 @@\n- * @compile -XDenablePrimitiveClasses TestCallingConventionC1.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestCallingConventionC1\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestCallingConventionC1.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestCallingConventionC1\n@@ -50,1 +56,1 @@\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                             \"-XX:+EnableValhalla\",\n@@ -56,1 +62,1 @@\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                             \"-XX:+EnableValhalla\",\n@@ -65,1 +71,1 @@\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                             \"-XX:+EnableValhalla\",\n@@ -72,1 +78,1 @@\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                             \"-XX:+EnableValhalla\",\n@@ -79,1 +85,1 @@\n-                             \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                             \"-XX:+EnableValhalla\",\n@@ -92,4 +98,5 @@\n-\n-    static primitive class Point {\n-        final int x;\n-        final int y;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Point {\n+        int x;\n+        int y;\n@@ -165,0 +172,1 @@\n+    @NullRestricted\n@@ -166,0 +174,1 @@\n+    @NullRestricted\n@@ -167,0 +176,1 @@\n+    @NullRestricted\n@@ -214,2 +224,4 @@\n-    static primitive class MyImplVal1 implements Intf {\n-        final int field;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyImplVal1 implements Intf {\n+        int field;\n@@ -229,2 +241,4 @@\n-    static primitive class MyImplVal2 implements Intf {\n-        final int field;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyImplVal2 implements Intf {\n+        int field;\n@@ -244,2 +258,4 @@\n-    static primitive class MyImplVal1X implements Intf {\n-        final int field;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyImplVal1X implements Intf {\n+        int field;\n@@ -257,2 +273,4 @@\n-    static primitive class MyImplVal2X implements Intf {\n-        final int field;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyImplVal2X implements Intf {\n+        int field;\n@@ -282,8 +300,10 @@\n-    static primitive class FixedPoints {\n-        final boolean Z0 = false;\n-        final boolean Z1 = true;\n-        final byte    B  = (byte)2;\n-        final char    C  = (char)34;\n-        final short   S  = (short)456;\n-        final int     I  = 5678;\n-        final long    J  = 0x1234567800abcdefL;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class FixedPoints {\n+        boolean Z0 = false;\n+        boolean Z1 = true;\n+        byte    B  = (byte)2;\n+        char    C  = (char)34;\n+        short   S  = (short)456;\n+        int     I  = 5678;\n+        long    J  = 0x1234567800abcdefL;\n@@ -291,0 +311,1 @@\n+    @NullRestricted\n@@ -293,3 +314,5 @@\n-    static primitive class FloatPoint {\n-        final float x;\n-        final float y;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class FloatPoint {\n+        float x;\n+        float y;\n@@ -302,3 +325,5 @@\n-    static primitive class DoublePoint {\n-        final double x;\n-        final double y;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class DoublePoint {\n+        double x;\n+        double y;\n@@ -310,0 +335,1 @@\n+    @NullRestricted\n@@ -311,0 +337,1 @@\n+    @NullRestricted\n@@ -313,1 +340,3 @@\n-    static primitive class EightFloats {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EightFloats {\n@@ -326,0 +355,1 @@\n+\n@@ -343,3 +373,5 @@\n-    static primitive class RefPoint implements RefPoint_Access {\n-        final Number x;\n-        final Number y;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class RefPoint implements RefPoint_Access {\n+        Number x;\n+        Number y;\n@@ -428,0 +460,1 @@\n+    @NullRestricted\n@@ -429,0 +462,1 @@\n+    @NullRestricted\n@@ -431,1 +465,1 @@\n-    \/\/ This inline class has too many fields to fit in registers on x64 for\n+    \/\/ This value class has too many fields to fit in registers on x64 for\n@@ -433,1 +467,3 @@\n-    static primitive class TooBigToReturnAsFields {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TooBigToReturnAsFields {\n@@ -446,0 +482,1 @@\n+    @NullRestricted\n@@ -452,1 +489,1 @@\n-    \/\/** C1 passes inline type to interpreter (static)\n+    \/\/** C1 passes value object to interpreter (static)\n@@ -466,1 +503,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -472,1 +509,1 @@\n-    \/\/** C1 passes inline type to interpreter (monomorphic)\n+    \/\/** C1 passes value object to interpreter (monomorphic)\n@@ -486,1 +523,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -492,1 +529,1 @@\n-    \/\/ C1 passes inline type to interpreter (megamorphic: vtable)\n+    \/\/ C1 passes value object to interpreter (megamorphic: vtable)\n@@ -501,1 +538,1 @@\n-        for (int i=0; i<count; i++) {  \/\/ need a loop to test inline cache and vtable indexing\n+        for (int i = 0; i < count; i++) {  \/\/ need a loop to test inline cache and vtable indexing\n@@ -517,1 +554,1 @@\n-        for (int i=0; i<count; i++) {  \/\/ need a loop to test inline cache and vtable indexing\n+        for (int i = 0; i < count; i++) {  \/\/ need a loop to test inline cache and vtable indexing\n@@ -524,1 +561,1 @@\n-    \/\/ C1 passes inline type to interpreter (megamorphic: itable)\n+    \/\/ C1 passes value object to interpreter (megamorphic: itable)\n@@ -533,1 +570,1 @@\n-        for (int i=0; i<count; i++) {  \/\/ need a loop to test inline cache and itable indexing\n+        for (int i = 0; i < count; i++) {  \/\/ need a loop to test inline cache and itable indexing\n@@ -544,1 +581,1 @@\n-    \/\/ Interpreter passes inline type to C1 (static)\n+    \/\/ Interpreter passes value object to C1 (static)\n@@ -557,1 +594,1 @@\n-    \/\/ Interpreter passes inline type to C1 (instance method in inline class)\n+    \/\/ Interpreter passes value object to C1 (instance method in value class)\n@@ -595,1 +632,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -617,1 +654,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -639,1 +676,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -655,1 +692,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -671,1 +708,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -693,1 +730,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -715,1 +752,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -737,1 +774,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -763,1 +800,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -770,1 +807,1 @@\n-    \/\/ C2->C1 invokestatic, packing an inline type with all types of fixed point primitive fields.\n+    \/\/ C2->C1 invokestatic, packing a value object with all types of fixed point primitive fields.\n@@ -789,1 +826,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -811,1 +848,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -833,1 +870,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -863,1 +900,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -888,1 +925,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -916,1 +953,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -943,1 +980,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -972,1 +1009,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -987,1 +1024,1 @@\n-        for (int i=0; i<methodNames.length; i++) {\n+        for (int i = 0; i < methodNames.length; i++) {\n@@ -1029,1 +1066,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1036,1 +1073,1 @@\n-    \/\/ C2->C1 invokestatic, make sure stack walking works (with returned inline type)\n+    \/\/ C2->C1 invokestatic, make sure stack walking works (with returned value object)\n@@ -1065,1 +1102,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1101,1 +1138,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1136,1 +1173,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1143,1 +1180,1 @@\n-    \/\/ C2->C1 invokestatic, inline class with ref fields (RefPoint)\n+    \/\/ C2->C1 invokestatic, value class with ref fields (RefPoint)\n@@ -1158,1 +1195,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1165,1 +1202,1 @@\n-    \/\/ C2->C1 invokestatic, inline class with ref fields (Point, RefPoint)\n+    \/\/ C2->C1 invokestatic, value class with ref fields (Point, RefPoint)\n@@ -1180,1 +1217,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1187,1 +1224,1 @@\n-    \/\/ C2->C1 invokestatic, inline class with ref fields (RefPoint, RefPoint, RefPoint, RefPoint)\n+    \/\/ C2->C1 invokestatic, value class with ref fields (RefPoint, RefPoint, RefPoint, RefPoint)\n@@ -1205,1 +1242,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1212,1 +1249,1 @@\n-    \/\/ C2->C1 invokestatic, inline class with ref fields (RefPoint, RefPoint, float, int, RefPoint, RefPoint)\n+    \/\/ C2->C1 invokestatic, value class with ref fields (RefPoint, RefPoint, float, int, RefPoint, RefPoint)\n@@ -1231,1 +1268,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1276,1 +1313,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1302,1 +1339,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1327,1 +1364,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1358,1 +1395,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1393,1 +1430,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1424,1 +1461,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1442,1 +1479,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1460,1 +1497,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1481,1 +1518,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1513,1 +1550,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1539,1 +1576,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1558,1 +1595,1 @@\n-        for (int i=0; i<count; i++) { \/\/ need a loop to test inline cache\n+        for (int i = 0; i < count; i++) { \/\/ need a loop to test inline cache\n@@ -1669,1 +1706,1 @@\n-    \/\/ Tests for InlineTypeReturnedAsFields vs the inline class TooBigToReturnAsFields\n+    \/\/ Tests for InlineTypeReturnedAsFields vs the value class TooBigToReturnAsFields\n@@ -1745,1 +1782,1 @@\n-    \/\/ Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns (RefPoint.ref)\n+    \/\/ Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns\n@@ -1748,1 +1785,1 @@\n-    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)\n+    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint)\n@@ -1750,1 +1787,1 @@\n-    public RefPoint.ref test87(RefPoint.ref p) {\n+    public RefPoint test87(RefPoint p) {\n@@ -1756,1 +1793,1 @@\n-    private static RefPoint.ref test87_helper(RefPoint.ref p) {\n+    private static RefPoint test87_helper(RefPoint p) {\n@@ -1766,1 +1803,1 @@\n-    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref with constant null)\n+    \/\/ C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint with constant null)\n@@ -1768,1 +1805,1 @@\n-    public RefPoint.ref test88() {\n+    public RefPoint test88() {\n@@ -1774,1 +1811,1 @@\n-    private static RefPoint.ref test88_helper() {\n+    private static RefPoint test88_helper() {\n@@ -1783,1 +1820,1 @@\n-    \/\/ C1->C2 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)\n+    \/\/ C1->C2 invokestatic with InlineTypeReturnedAsFields (RefPoint)\n@@ -1785,1 +1822,1 @@\n-    public RefPoint.ref test89(RefPoint.ref p) {\n+    public RefPoint test89(RefPoint p) {\n@@ -1791,1 +1828,1 @@\n-    private static RefPoint.ref test89_helper(RefPoint.ref p) {\n+    private static RefPoint test89_helper(RefPoint p) {\n@@ -1805,4 +1842,4 @@\n-    \/\/ C2 -> Unverified Entry compiled by C1 (target is NOT an inline type)\n-    \/\/ C2 -> Unverified Entry compiled by C2 (target is NOT an inline type)\n-    \/\/ C2 -> Unverified Entry compiled by C1 (target IS an inline type, i.e., has VVEP_RO)\n-    \/\/ C2 -> Unverified Entry compiled by C2 (target IS an inline type, i.e., has VVEP_RO)\n+    \/\/ C2 -> Unverified Entry compiled by C1 (target is NOT a value class)\n+    \/\/ C2 -> Unverified Entry compiled by C2 (target is NOT a value class)\n+    \/\/ C2 -> Unverified Entry compiled by C1 (target IS a value class, i.e., has VVEP_RO)\n+    \/\/ C2 -> Unverified Entry compiled by C2 (target IS a value class, i.e., has VVEP_RO)\n@@ -1825,1 +1862,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -1846,1 +1883,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -1867,1 +1904,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -1888,1 +1925,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -1909,1 +1946,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -1930,1 +1967,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -1957,1 +1994,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -1985,1 +2022,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2011,1 +2048,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2037,1 +2074,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2085,1 +2122,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2114,1 +2151,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2149,1 +2186,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2170,1 +2207,3 @@\n-    static primitive class Test103Value {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test103Value {\n@@ -2188,1 +2227,1 @@\n-    \/\/ Same as test103, but with an inline class that's too big to return as fields.\n+    \/\/ Same as test103, but with a value class that's too big to return as fields.\n@@ -2195,1 +2234,3 @@\n-    static primitive class Test104Value {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test104Value {\n@@ -2242,1 +2283,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2264,1 +2305,1 @@\n-        for (int i=0; i<count; i++) {\n+        for (int i = 0; i < count; i++) {\n@@ -2284,1 +2325,1 @@\n-        for (int i=0; i<1000; i++) {\n+        for (int i = 0; i < 1000; i++) {\n@@ -2287,1 +2328,1 @@\n-        for (int i=0; i<500_000; i++) {\n+        for (int i = 0; i < 500_000; i++) {\n@@ -2319,1 +2360,1 @@\n-        for (int i=0; i<1000; i++) {\n+        for (int i = 0; i < 1000; i++) {\n@@ -2322,1 +2363,1 @@\n-        for (int i=0; i<500_000; i++) {\n+        for (int i = 0; i < 500_000; i++) {\n@@ -2354,1 +2395,1 @@\n-        for (int i=0; i<1000; i++) {\n+        for (int i = 0; i < 1000; i++) {\n@@ -2357,1 +2398,1 @@\n-        for (int i=0; i<500_000; i++) {\n+        for (int i = 0; i < 500_000; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConventionC1.java","additions":175,"deletions":134,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * Copyright (c) 2023, 2024, Arm Limited. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCastMismatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,6 @@\n- * @compile -XDenablePrimitiveClasses TestDeadAllocationRemoval.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch TestDeadAllocationRemoval\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestDeadAllocationRemoval.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   TestDeadAllocationRemoval\n@@ -32,0 +36,4 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -42,1 +50,3 @@\n-primitive class MyValue {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue {\n@@ -58,0 +68,1 @@\n+    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeadAllocationRemoval.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -42,2 +45,2 @@\n- * @run driver org.openjdk.asmtools.JtregDriver jasm -strict TestDeoptimizationWhenBufferingClasses.jasm\n- * @compile -XDenablePrimitiveClasses TestDeoptimizationWhenBuffering.java\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestDeoptimizationWhenBuffering.java\n@@ -45,1 +48,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -49,1 +54,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -53,1 +60,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -59,1 +68,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -65,1 +76,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -71,1 +84,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -77,1 +92,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -83,1 +100,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -95,0 +114,55 @@\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue1 {\n+        static int cnt = 0;\n+        int x;\n+        @NullRestricted\n+        MyValue2 vtField1;\n+        MyValue2 vtField2;\n+\n+        public MyValue1() {\n+            cnt++;\n+            x = cnt;\n+            vtField1 = new MyValue2();\n+            vtField2 = new MyValue2();\n+        }\n+\n+        public MyValue1(int x, MyValue2 vtField1, MyValue2 vtField2) {\n+            this.x = x;\n+            this.vtField1 = vtField1;\n+            this.vtField2 = vtField2;\n+        }\n+\n+        public int hash() {\n+            return x + vtField1.x + vtField2.x;\n+        }\n+\n+        public MyValue1 testWithField(int x) {\n+            return new MyValue1(x, vtField1, vtField2);\n+        }\n+\n+        public static MyValue1 makeDefault() {\n+            return new MyValue1(0, MyValue2.makeDefault(), null);\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue2 {\n+        static int cnt = 0;\n+        int x;\n+\n+        public MyValue2() {\n+            cnt++;\n+            x = cnt;\n+        }\n+\n+        public MyValue2(int x) {\n+            this.x = x;\n+        }\n+\n+        public static MyValue2 makeDefault() {\n+            return new MyValue2(0);\n+        }\n+    }\n+\n@@ -100,1 +174,1 @@\n-            MethodType mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue1.class));\n+            MethodType mt = MethodType.methodType(MyValue1.class);\n@@ -113,0 +187,1 @@\n+    @NullRestricted\n@@ -129,1 +204,1 @@\n-    static MyValue1[] vtArray = new MyValue1[1];\n+    static MyValue1[] vtArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -150,1 +225,1 @@\n-    MyValue1.ref test8(MyValue1.ref[] obj) {\n+    MyValue1 test8(MyValue1[] obj) {\n@@ -165,0 +240,1 @@\n+    @NullRestricted\n@@ -194,1 +270,1 @@\n-            m = TestDeoptimizationWhenBuffering.class.getMethod(\"test3Callee\", PrimitiveClass.asValueType(MyValue1.class));\n+            m = TestDeoptimizationWhenBuffering.class.getMethod(\"test3Callee\", MyValue1.class);\n@@ -202,1 +278,1 @@\n-        MyValue1[] va = new MyValue1[3];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n@@ -211,1 +287,1 @@\n-            vtField1 = MyValue1.default;\n+            vtField1 = MyValue1.makeDefault();\n@@ -226,1 +302,1 @@\n-            t.vtField2 = MyValue1.default;\n+            t.vtField2 = MyValue1.makeDefault();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBuffering.java","additions":95,"deletions":19,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue1\n-    version 66:0\n-{\n-    static Field cnt:I;\n-    final Field x:I;\n-    final Field vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-    final Field vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-\n-    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n-        getstatic cnt:I;\n-        iconst_1;\n-        iadd;\n-        putstatic cnt:I;\n-\n-        aconst_init compiler\/valhalla\/inlinetypes\/MyValue1;\n-\n-        getstatic cnt:I;\n-        withfield x:I;\n-\n-        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-        withfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-\n-        invokestatic compiler\/valhalla\/inlinetypes\/MyValue2.<vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-        withfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-\n-        areturn;\n-    }\n-\n-    public Method hash:\"()I\" stack 2 {\n-        aload_0;\n-        getfield x:I;\n-\n-        aload_0;\n-        getfield vtField1:\"Qcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n-        iadd;\n-\n-        aload_0;\n-        getfield vtField2:\"Lcompiler\/valhalla\/inlinetypes\/MyValue2;\";\n-        getfield compiler\/valhalla\/inlinetypes\/MyValue2.x:I;\n-        iadd;\n-\n-        ireturn;\n-    }\n-\n-    public Method testWithField:\"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue1;\" stack 2 {\n-        aload_0;\n-        iload_1;\n-        withfield x:I;\n-        areturn;\n-    }\n-\n-}\n-\n-public final primitive value class compiler\/valhalla\/inlinetypes\/MyValue2\n-    version 66:0\n-{\n-    static Field cnt:I;\n-    final Field x:I;\n-\n-    public static Method <vnew>:\"()Qcompiler\/valhalla\/inlinetypes\/MyValue2;\" stack 2 {\n-        getstatic cnt:I;\n-        iconst_1;\n-        iadd;\n-        putstatic cnt:I;\n-\n-        aconst_init compiler\/valhalla\/inlinetypes\/MyValue2;\n-\n-        getstatic cnt:I;\n-        withfield x:I;\n-\n-        areturn;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBufferingClasses.jasm","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,5 +28,7 @@\n- * @summary [lworld] C2 compilation fails with assert(n->Opcode() != Op_Phi) failed: cannot match\n- *\n- * @compile -XDenablePrimitiveClasses TestFlatArrayAliasesCardMark.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:-BackgroundCompilation TestFlatArrayAliasesCardMark\n- *\n+ * @summary C2 compilation fails with assert(n->Opcode() != Op_Phi) failed: cannot match\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestFlatArrayAliasesCardMark.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:-BackgroundCompilation\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   TestFlatArrayAliasesCardMark\n@@ -34,0 +37,4 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -35,1 +42,3 @@\n-primitive class Test0 {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Test0 {\n@@ -56,2 +65,4 @@\n-        Test0[] array = new Test0[] {new Test0()};\n-        for (int l1 = 0; l1 < 10000; ++l1) {\n+        Test0[] array = (Test0[])ValueClass.newNullRestrictedArray(Test0.class, 1);\n+        array[0] = new Test0();\n+\n+        for (int l1 = 0; l1 < 10_000; ++l1) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatArrayAliasesCardMark.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Test accessing inline type arrays that exceed the flattening threshold.\n+ * @summary Test accessing value class arrays that exceed the flattening threshold.\n@@ -28,4 +28,15 @@\n- * @compile -XDenablePrimitiveClasses TestFlatArrayThreshold.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch TestFlatArrayThreshold\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxOops=1 -Xbatch TestFlatArrayThreshold\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=1 -Xbatch TestFlatArrayThreshold\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestFlatArrayThreshold.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   TestFlatArrayThreshold\n+ * @run main\/othervm -XX:+EnableValhalla -XX:FlatArrayElementMaxOops=1 -Xbatch\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   TestFlatArrayThreshold\n+ * @run main\/othervm -XX:+EnableValhalla -XX:FlatArrayElementMaxSize=1 -Xbatch\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                   TestFlatArrayThreshold\n+\n@@ -36,3 +47,10 @@\n-final primitive class MyValue1 {\n-    final Object o1;\n-    final Object o2;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue1 {\n+    Object o1;\n+    Object o2;\n@@ -53,1 +71,1 @@\n-    public static MyValue1.ref test2(MyValue1.ref[] va, MyValue1.ref vt) {\n+    public static MyValue1 test2(MyValue1[] va, MyValue1 vt) {\n@@ -63,1 +81,1 @@\n-    public static Object test4(Object[] va, MyValue1.ref vt) {\n+    public static Object test4(Object[] va, MyValue1 vt) {\n@@ -73,2 +91,2 @@\n-    public static MyValue1.ref test6(MyValue1.ref[] va, Object vt) {\n-        va[0] = (MyValue1.ref)vt;\n+    public static MyValue1 test6(MyValue1[] va, Object vt) {\n+        va[0] = (MyValue1)vt;\n@@ -85,2 +103,2 @@\n-        MyValue1[] va = new MyValue1[2];\n-        MyValue1.ref[] vaB = new MyValue1.ref[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vaB = new MyValue1[2];\n@@ -93,1 +111,1 @@\n-            MyValue1.ref result2 = test2(va, vt);\n+            MyValue1 result2 = test2(va, vt);\n@@ -99,1 +117,1 @@\n-            MyValue1.ref result3 = (MyValue1.ref)test3(va, vt);\n+            MyValue1 result3 = (MyValue1)test3(va, vt);\n@@ -102,1 +120,1 @@\n-            result3 = (MyValue1.ref)test3(vaB, vt);\n+            result3 = (MyValue1)test3(vaB, vt);\n@@ -105,1 +123,1 @@\n-            MyValue1.ref result4 = (MyValue1.ref)test4(va, vt);\n+            MyValue1 result4 = (MyValue1)test4(va, vt);\n@@ -108,1 +126,1 @@\n-            result4 = (MyValue1.ref)test4(vaB, null);\n+            result4 = (MyValue1)test4(vaB, null);\n@@ -115,1 +133,1 @@\n-            MyValue1.ref result6 = test6(va, vt);\n+            MyValue1 result6 = test6(va, vt);\n@@ -121,1 +139,1 @@\n-            MyValue1.ref result7 = (MyValue1.ref)test7(va, vt);\n+            MyValue1 result7 = (MyValue1)test7(va, vt);\n@@ -124,1 +142,1 @@\n-            result7 = (MyValue1.ref)test7(vaB, null);\n+            result7 = (MyValue1)test7(vaB, null);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatArrayThreshold.java","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,6 @@\n- * @compile -XDenablePrimitiveClasses TestGenerated.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *          TestGenerated.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -31,1 +35,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch -XX:FlatArrayElementMaxSize=0\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:FlatArrayElementMaxSize=0\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -37,1 +43,8 @@\n-primitive class EmptyPrimitive {\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class EmptyPrimitive {\n@@ -45,1 +58,3 @@\n-primitive class MyValue1 {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue1 {\n@@ -50,1 +65,3 @@\n-primitive class MyValue2 {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue2 {\n@@ -56,1 +73,3 @@\n-primitive class MyValue3 {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue3 {\n@@ -61,1 +80,3 @@\n-primitive class MyValue4 {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue4 {\n@@ -67,1 +88,1 @@\n-    public MyValue4.ref val;\n+    public MyValue4 val;\n@@ -74,1 +95,3 @@\n-primitive class MyValue5 {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue5 {\n@@ -83,0 +106,1 @@\n+    @NullRestricted\n@@ -84,0 +108,1 @@\n+    @NullRestricted\n@@ -94,1 +119,1 @@\n-        MyValue1 res = MyValue1.default;\n+        MyValue1 res = new MyValue1();\n@@ -106,1 +131,1 @@\n-            array[i] = MyValue1.default;\n+            array[i] = new MyValue1();\n@@ -122,0 +147,1 @@\n+    @NullRestricted\n@@ -132,0 +158,1 @@\n+    @NullRestricted\n@@ -135,2 +162,8 @@\n-        MyValue2[] array1 = {new MyValue2(), new MyValue2(), new MyValue2(),\n-                             new MyValue2(), new MyValue2(), new MyValue2()};\n+        MyValue2[] array1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 6);\n+        array1[0] = new MyValue2();\n+        array1[1] = new MyValue2();\n+        array1[2] = new MyValue2();\n+        array1[3] = new MyValue2();\n+        array1[4] = new MyValue2();\n+        array1[5] = new MyValue2();\n+\n@@ -160,1 +193,1 @@\n-        MyValue1[] array = { new MyValue1() };\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -186,1 +219,2 @@\n-    MyValue4[] d = {new MyValue4()};\n+    MyValue4[] d = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 1);\n+    @NullRestricted\n@@ -189,0 +223,1 @@\n+\n@@ -192,1 +227,1 @@\n-            MyValue4[] k = {};\n+            MyValue4[] k = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 0);\n@@ -209,0 +244,1 @@\n+    @NullRestricted\n@@ -210,0 +246,1 @@\n+    @NullRestricted\n@@ -220,1 +257,1 @@\n-            MyValue5[] array2 = {new MyValue5()};\n+            MyValue5[] array2 = (MyValue5[])ValueClass.newNullRestrictedArray(MyValue5.class, 1);\n@@ -229,1 +266,1 @@\n-                val = MyValue4.default;\n+                val = new MyValue4();\n@@ -231,1 +268,1 @@\n-            MyValue4[] array = new MyValue4[1];\n+            MyValue4[] array = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 1);\n@@ -245,1 +282,1 @@\n-                MyValue4[] array = new MyValue4[1];\n+                MyValue4[] array = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 1);\n@@ -255,1 +292,1 @@\n-        MyValue4 val = MyValue4.default;\n+        MyValue4 val = new MyValue4();\n@@ -284,0 +321,1 @@\n+    @NullRestricted\n@@ -296,5 +334,8 @@\n-        EmptyPrimitive[] array1 = { new EmptyPrimitive() };\n-        MyValue1[] array2 = new MyValue1[10];\n-        MyValue1[] array3 = { new MyValue1() };\n-        MyValue3[] array4 = { new MyValue3() };\n-        MyValue5[] array5 = { new MyValue5() };\n+        EmptyPrimitive[] array1 = (EmptyPrimitive[])ValueClass.newNullRestrictedArray(EmptyPrimitive.class, 1);\n+        MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        array3[0] = new MyValue1();\n+        MyValue3[] array4 = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        array4[0] = new MyValue3();\n+        MyValue5[] array5 = (MyValue5[])ValueClass.newNullRestrictedArray(MyValue5.class, 1);\n+        array5[0] = new MyValue5();\n@@ -317,1 +358,1 @@\n-            t.test14(false, MyValue4.default);\n+            t.test14(false, new MyValue4());\n@@ -319,1 +360,2 @@\n-            t.test16();\n+            \/\/ TODO 8325106 Triggers \"nothing between inner and outer loop\" assert\n+            \/\/ t.test16();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":72,"deletions":30,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.test.lib.Asserts;\n@@ -32,0 +31,6 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import jdk.test.lib.Asserts;\n@@ -36,1 +41,1 @@\n- * @summary Verify that chains of getfields on flattened fields are correctly optimized\n+ * @summary Verify that chains of getfields on flat fields are correctly optimized.\n@@ -40,2 +45,6 @@\n- * @compile -XDenablePrimitiveClasses TestGetfieldChains.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestGetfieldChains\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestGetfieldChains.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla\n+ *                               --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                               --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                               compiler.valhalla.inlinetypes.TestGetfieldChains\n@@ -44,0 +53,33 @@\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Point {\n+    int x = 4;\n+    int y = 7;\n+}\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Rectangle {\n+    @NullRestricted\n+    Point p0 = new Point();\n+    @NullRestricted\n+    Point p1 = new Point();\n+}\n+\n+class NamedRectangle {\n+    @NullRestricted\n+    Rectangle rect = new Rectangle();\n+    String name = \"\";\n+\n+    static int getP1X(NamedRectangle nr) {\n+        return nr.rect\n+            .p1\n+            .x;\n+    }\n+\n+    static Point getP1(NamedRectangle nr) {\n+        return nr.rect\n+            .p1;\n+    }\n+}\n+\n@@ -51,1 +93,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -56,1 +97,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -62,1 +102,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -65,2 +104,1 @@\n-                        \/\/ Xcomp Only C1.\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \/\/ Xcomp Only C1\n@@ -71,2 +109,1 @@\n-                        \/\/ Xcomp Only C2.\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n+                        \/\/ Xcomp Only C2\n@@ -81,0 +118,3 @@\n+                   .addFlags(\"-XX:+EnableValhalla\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\")\n@@ -85,1 +125,1 @@\n-    \/\/ Simple chain of getfields ending with primitive field\n+    \/\/ Simple chain of getfields ending with value type field\n@@ -97,1 +137,1 @@\n-    \/\/ Simple chain of getfields ending with a flattened field\n+    \/\/ Simple chain of getfields ending with a flat field\n@@ -116,1 +156,2 @@\n-        } catch(NullPointerException e) {\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException e) {\n@@ -128,1 +169,0 @@\n-        Asserts.assertEQ(st.getLineNumber(), 31);       \/\/ line number depends on file NamedRectangle.java\n@@ -131,1 +171,1 @@\n-    \/\/ Chain of getfields but one getfield in the middle of the chain trigger an illegal access\n+    \/\/ Chain of getfields but one getfield in the middle of the chain triggers an illegal access\n@@ -136,2 +176,3 @@\n-            int i = NamedRectangleP.getP1X(new NamedRectangleP());\n-        } catch(IllegalAccessError e) {\n+            int i = NamedRectangleP.getP1Y(new NamedRectangleP());\n+            throw new RuntimeException(\"No IllegalAccessError thrown\");\n+        } catch (IllegalAccessError e) {\n@@ -148,2 +189,1 @@\n-        Asserts.assertEQ(st.getMethodName(), \"getP1X\");\n-        Asserts.assertEQ(st.getLineNumber(), 31);       \/\/ line number depends on jcod file generated from NamedRectangle.java\n+        Asserts.assertEQ(st.getMethodName(), \"getP1Y\");\n@@ -153,1 +193,1 @@\n-    \/\/ Chain of getfields but the last getfield trigger a NoSuchFieldError\n+    \/\/ Chain of getfields but the last getfield triggers a NoSuchFieldError\n@@ -159,1 +199,2 @@\n-        } catch(NoSuchFieldError e) {\n+            throw new RuntimeException(\"No NoSuchFieldError thrown\");\n+        } catch (NoSuchFieldError e) {\n@@ -171,1 +212,0 @@\n-        Asserts.assertEQ(st.getLineNumber(), 31);       \/\/ line number depends on jcod file generated from NamedRectangle.java\n@@ -175,2 +215,7 @@\n-    static primitive class EmptyType { }\n-    static primitive class EmptyContainer {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyType1 { }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyContainer1 {\n@@ -178,1 +223,2 @@\n-        EmptyType et = new EmptyType();\n+        @NullRestricted\n+        EmptyType1 et = new EmptyType1();\n@@ -180,3 +226,8 @@\n-    static primitive class Container {\n-        EmptyContainer container0 = new EmptyContainer();\n-        EmptyContainer container1 = new EmptyContainer();\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Container1 {\n+        @NullRestricted\n+        EmptyContainer1 container0 = new EmptyContainer1();\n+        @NullRestricted\n+        EmptyContainer1 container1 = new EmptyContainer1();\n@@ -186,2 +237,2 @@\n-    public EmptyType test6() {\n-        Container c = new Container();\n+    public EmptyType1 test6() {\n+        Container1 c = new Container1();\n@@ -193,2 +244,2 @@\n-        EmptyType et = test6();\n-        Asserts.assertEQ(et, EmptyType.default);\n+        EmptyType1 et = test6();\n+        Asserts.assertEQ(et, new EmptyType1());\n@@ -198,2 +249,2 @@\n-    public EmptyType test7() {\n-        Container[] ca = new Container[10];\n+    public EmptyType1 test7() {\n+        Container1[] ca = (Container1[])ValueClass.newNullRestrictedArray(Container1.class, 10);\n@@ -205,2 +256,40 @@\n-        EmptyType et = test7();\n-        Asserts.assertEQ(et, EmptyType.default);\n+        EmptyType1 et = test7();\n+        Asserts.assertEQ(et, new EmptyType1());\n+    }\n+\n+    \/\/ Same as test6\/test7 but not null-free and EmptyContainer2 with only one field\n+\n+    static value class EmptyType2 { }\n+\n+    static value class EmptyContainer2 {\n+        EmptyType2 et = null;\n+    }\n+\n+    static value class Container2 {\n+        EmptyContainer2 container0 = new EmptyContainer2();\n+        EmptyContainer2 container1 = new EmptyContainer2();\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public EmptyType2 test8() {\n+        Container2 c = new Container2();\n+        return c.container1.et;\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        EmptyType2 et = test8();\n+        Asserts.assertEQ(et, null);\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public EmptyType2 test9() {\n+        Container2[] ca = new Container2[10];\n+        ca[3] = new Container2();\n+        return ca[3].container0.et;\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        EmptyType2 et = test9();\n+        Asserts.assertEQ(et, null);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":127,"deletions":38,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,4 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -35,1 +39,1 @@\n- * @summary VM option \"InlineFieldMaxFlatSize\" cannot work well\n+ * @summary VM option \"InlineFieldMaxFlatSize\" does not work well.\n@@ -37,1 +41,2 @@\n- * @compile -XDenablePrimitiveClasses -source 21\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -39,1 +44,0 @@\n- *\n@@ -41,1 +45,2 @@\n- *                   -XX:+EnablePrimitiveClasses\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -49,0 +54,1 @@\n+        @NullRestricted\n@@ -58,1 +64,3 @@\n-    static primitive class MyValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue {\n@@ -92,1 +100,2 @@\n-                               \"-XX:+EnablePrimitiveClasses\",\n+                               \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                               \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n@@ -97,1 +106,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestInlineFieldNonFlattened.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -43,1 +46,1 @@\n- * @summary Test intrinsic support for inline types\n+ * @summary Test intrinsic support for value classes.\n@@ -47,2 +50,3 @@\n- * @compile -XDenablePrimitiveClasses TestIntrinsics.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestIntrinsics\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestIntrinsics.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestIntrinsics\n@@ -57,6 +61,0 @@\n-        for (Scenario scenario: scenarios) {\n-            scenario.addFlags(\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                    \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\");\n-            \/\/ Don't run with DeoptimizeALot until JDK-8239003 is fixed\n-            scenario.addFlags(\"-XX:-DeoptimizeALot\");\n-        }\n@@ -68,0 +66,4 @@\n+                   .addFlags(\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                             \/\/ Don't run with DeoptimizeALot until JDK-8239003 is fixed\n+                             \"-XX:-DeoptimizeALot\")\n@@ -88,9 +90,4 @@\n-        Asserts.assertTrue(test1(PrimitiveClass.asPrimaryType(MyValue1.class), PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_2 failed\");\n-        Asserts.assertTrue(test1(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class)), \"test1_3 failed\");\n-        Asserts.assertTrue(test1(PrimitiveClass.asPrimaryType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class)), \"test1_4 failed\");\n-        Asserts.assertFalse(test1(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_5 failed\");\n-        Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), \"test1_6 failed\");\n-        Asserts.assertTrue(test1(Object.class, PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_7 failed\");\n-        Asserts.assertTrue(test1(Object.class, PrimitiveClass.asValueType(MyValue1.class)), \"test1_8 failed\");\n-        Asserts.assertTrue(!test1(PrimitiveClass.asPrimaryType(MyValue1.class), Object.class), \"test1_9 failed\");\n-        Asserts.assertTrue(!test1(PrimitiveClass.asValueType(MyValue1.class), Object.class), \"test1_10 failed\");\n+        Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), \"test1_2 failed\");\n+        Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), \"test1_3 failed\");\n+        Asserts.assertTrue(test1(Object.class, MyValue1.class), \"test1_4 failed\");\n+        Asserts.assertTrue(!test1(MyValue1.class, Object.class), \"test1_5 failed\");\n@@ -104,10 +101,5 @@\n-        boolean check2 = PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n-        boolean check3 = PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n-        boolean check4 = PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n-        boolean check5 = !PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n-        boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);\n-        boolean check7 = Object.class.isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n-        boolean check8 = Object.class.isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n-        boolean check9 = !PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(Object.class);\n-        boolean check10 = !PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(Object.class);\n-        return check1 && check2 && check3 && check4 && check5 && check6 && check7 && check8 && check9 && check10;\n+        boolean check2 = MyValue1.class.isAssignableFrom(MyValue1.class);\n+        boolean check3 = Object.class.isAssignableFrom(java.util.ArrayList.class);\n+        boolean check4 = Object.class.isAssignableFrom(MyValue1.class);\n+        boolean check5 = !MyValue1.class.isAssignableFrom(Object.class);\n+        return check1 && check2 && check3 && check4 && check5;\n@@ -130,2 +122,2 @@\n-        Asserts.assertTrue(test3(PrimitiveClass.asPrimaryType(MyValue1.class)) == MyAbstract.class, \"test3_2 failed\");\n-        Asserts.assertTrue(test3(PrimitiveClass.asValueType(MyValue1.class)) == MyAbstract.class, \"test3_3 failed\");\n+        Asserts.assertTrue(test3(MyValue1.class) == MyAbstract.class, \"test3_2 failed\");\n+        Asserts.assertTrue(test3(MyValue1.class) == MyAbstract.class, \"test3_3 failed\");\n@@ -140,2 +132,2 @@\n-        boolean check2 = PrimitiveClass.asPrimaryType(MyValue1.class).getSuperclass() == MyAbstract.class;\n-        boolean check3 = PrimitiveClass.asValueType(MyValue1.class).getSuperclass() == MyAbstract.class;\n+        boolean check2 = MyValue1.class.getSuperclass() == MyAbstract.class;\n+        boolean check3 = MyValue1.class.getSuperclass() == MyAbstract.class;\n@@ -176,1 +168,1 @@\n-    \/\/ Test default inline type array creation via reflection\n+    \/\/ Test default value class array creation via reflection\n@@ -179,1 +171,1 @@\n-        Object[] va = (Object[])Array.newInstance(componentType, len);\n+        Object[] va = ValueClass.newNullRestrictedArray(componentType, len);\n@@ -187,1 +179,1 @@\n-        Object[] va = test7(PrimitiveClass.asValueType(MyValue1.class), len);\n+        Object[] va = test7(MyValue1.class, len);\n@@ -202,1 +194,1 @@\n-        boolean result = test8(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        boolean result = test8(MyValue1.class, vt);\n@@ -204,1 +196,1 @@\n-        result = test8(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        result = test8(MyValue1.class, vt);\n@@ -218,1 +210,1 @@\n-        result = test9(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+        result = test9(MyValue2.class, vt);\n@@ -231,1 +223,1 @@\n-        Object result = test10(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Object result = test10(MyValue1.class, vt);\n@@ -252,1 +244,1 @@\n-        return PrimitiveClass.asValueType(MyValue1.class).cast(vt);\n+        return MyValue1.class.cast(vt);\n@@ -277,1 +269,1 @@\n-    \/\/ inline type array creation via reflection\n+    \/\/ Value class array creation via reflection\n@@ -280,1 +272,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), len);\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -342,1 +334,1 @@\n-    \/\/ hashCode() and toString() with different inline types\n+    \/\/ hashCode() and toString() with different value objects\n@@ -381,1 +373,1 @@\n-            Field xField = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"x\");\n+            Field xField = MyValue1.class.getDeclaredField(\"x\");\n@@ -383,1 +375,1 @@\n-            Field yField = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"y\");\n+            Field yField = MyValue1.class.getDeclaredField(\"y\");\n@@ -385,1 +377,1 @@\n-            Field v1Field = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"v1\");\n+            Field v1Field = MyValue1.class.getDeclaredField(\"v1\");\n@@ -406,0 +398,1 @@\n+    @NullRestricted\n@@ -407,0 +400,1 @@\n+\n@@ -436,0 +430,1 @@\n+    @NullRestricted\n@@ -450,3 +445,6 @@\n-    \/\/ Test copyOf intrinsic with allocated inline type in it's debug information\n-    final primitive class Test25Value {\n-        final int x;\n+    \/\/ Test copyOf intrinsic with allocated value object in it's debug information\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test25Value {\n+        int x;\n+\n@@ -458,1 +456,1 @@\n-    final Test25Value[] test25Array = new Test25Value[10];\n+    final Test25Value[] test25Array = (Test25Value[])ValueClass.newNullRestrictedArray(Test25Value.class, 10);\n@@ -479,1 +477,1 @@\n-          ca[i] = PrimitiveClass.asValueType(MyValue1.class);\n+          ca[i] = MyValue1.class;\n@@ -481,1 +479,1 @@\n-        return Array.newInstance(ca[0], 1);\n+        return ValueClass.newNullRestrictedArray(ca[0], 1);\n@@ -490,2 +488,2 @@\n-    \/\/ Load non-flattenable inline type field with unsafe\n-    MyValue1.ref test27_vt;\n+    \/\/ Load non-flattenable value class field with unsafe\n+    MyValue1 test27_vt;\n@@ -504,2 +502,2 @@\n-    public MyValue1.ref test27() {\n-        return (MyValue1.ref)U.getReference(this, TEST27_OFFSET);\n+    public MyValue1 test27() {\n+        return (MyValue1)U.getReference(this, TEST27_OFFSET);\n@@ -511,1 +509,1 @@\n-        MyValue1.ref res = test27();\n+        MyValue1 res = test27();\n@@ -541,1 +539,1 @@\n-        \/\/ inline type so we don't read out of bounds.\n+        \/\/ value class so we don't read out of bounds.\n@@ -567,1 +565,1 @@\n-    \/\/ getValue to retrieve flattened field from inline type\n+    \/\/ getValue to retrieve flattened field from value object\n@@ -572,1 +570,1 @@\n-            return U.getValue(v, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+            return U.getValue(v, V1_OFFSET, MyValue2.class);\n@@ -584,0 +582,1 @@\n+    @NullRestricted\n@@ -602,1 +601,1 @@\n-            return U.getValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(this, TEST31_VT_OFFSET, MyValue1.class);\n@@ -619,1 +618,1 @@\n-            U.putValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), vt);\n+            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class, vt);\n@@ -635,0 +634,1 @@\n+    private static final MyValue1[] TEST33_ARRAY;\n@@ -638,3 +638,4 @@\n-            TEST33_BASE_OFFSET = U.arrayBaseOffset(MyValue1[].class);\n-            TEST33_INDEX_SCALE = U.arrayIndexScale(MyValue1[].class);\n-            TEST33_FLATTENED_ARRAY = U.isFlattenedArray(MyValue1[].class);\n+            TEST33_ARRAY = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+            TEST33_BASE_OFFSET = U.arrayBaseOffset(TEST33_ARRAY.getClass());\n+            TEST33_INDEX_SCALE = U.arrayIndexScale(TEST33_ARRAY.getClass());\n+            TEST33_FLATTENED_ARRAY = U.isFlattenedArray(TEST33_ARRAY.getClass());\n@@ -648,1 +649,1 @@\n-    public MyValue1 test33(MyValue1[] arr) {\n+    public MyValue1 test33() {\n@@ -650,1 +651,1 @@\n-            return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class);\n@@ -652,1 +653,1 @@\n-        return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);\n+        return (MyValue1)U.getReference(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);\n@@ -657,1 +658,0 @@\n-        MyValue1[] arr = new MyValue1[2];\n@@ -659,2 +659,2 @@\n-        arr[1] = vt;\n-        MyValue1 res = test33(arr);\n+        TEST33_ARRAY[1] = vt;\n+        MyValue1 res = test33();\n@@ -667,1 +667,1 @@\n-    public void test34(MyValue1[] arr, MyValue1 vt) {\n+    public void test34(MyValue1 vt) {\n@@ -669,1 +669,1 @@\n-            U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), vt);\n+            U.putValue(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class, vt);\n@@ -671,1 +671,1 @@\n-            U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);\n+            U.putReference(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);\n@@ -677,1 +677,0 @@\n-        MyValue1[] arr = new MyValue1[2];\n@@ -679,2 +678,2 @@\n-        test34(arr, vt);\n-        Asserts.assertEQ(arr[1].hash(), vt.hash());\n+        test34(vt);\n+        Asserts.assertEQ(TEST33_ARRAY[1].hash(), vt.hash());\n@@ -689,1 +688,1 @@\n-            return U.getValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(o, TEST31_VT_OFFSET, MyValue1.class);\n@@ -707,1 +706,1 @@\n-            return U.getValue(this, offset, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(this, offset, MyValue1.class);\n@@ -725,1 +724,1 @@\n-            U.putValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), vt);\n+            U.putValue(o, TEST31_VT_OFFSET, MyValue1.class, vt);\n@@ -745,1 +744,1 @@\n-            U.putValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), o);\n+            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class, o);\n@@ -775,1 +774,1 @@\n-    \/\/ Test default inline type array creation via reflection\n+    \/\/ Test default value class array creation via reflection\n@@ -785,1 +784,1 @@\n-        Object[] va = test40(PrimitiveClass.asPrimaryType(MyValue1.class), len);\n+        Object[] va = test40(MyValue1.class, len);\n@@ -793,1 +792,1 @@\n-    public boolean test41(Class c, MyValue1.ref vt) {\n+    public boolean test41(Class c, MyValue1 vt) {\n@@ -799,2 +798,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        boolean result = test41(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test41(MyValue1.class, vt);\n@@ -802,1 +801,1 @@\n-        result = test41(PrimitiveClass.asPrimaryType(MyValue1.class), null);\n+        result = test41(MyValue1.class, null);\n@@ -804,1 +803,1 @@\n-        result = test41(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        result = test41(MyValue1.class, vt);\n@@ -806,1 +805,1 @@\n-        result = test41(PrimitiveClass.asValueType(MyValue1.class), null);\n+        result = test41(MyValue1.class, null);\n@@ -811,1 +810,1 @@\n-    public boolean test42(Class c, MyValue1.ref vt) {\n+    public boolean test42(Class c, MyValue1 vt) {\n@@ -817,2 +816,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        boolean result = test42(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test42(MyValue2.class, vt);\n@@ -820,1 +819,1 @@\n-        result = test42(PrimitiveClass.asPrimaryType(MyValue2.class), null);\n+        result = test42(MyValue2.class, null);\n@@ -822,1 +821,1 @@\n-        result = test42(PrimitiveClass.asValueType(MyValue2.class), vt);\n+        result = test42(MyValue2.class, vt);\n@@ -824,1 +823,1 @@\n-        result = test42(PrimitiveClass.asValueType(MyValue2.class), null);\n+        result = test42(MyValue2.class, null);\n@@ -830,1 +829,1 @@\n-    public Object test43(Class c, MyValue1.ref vt) {\n+    public Object test43(Class c, MyValue1 vt) {\n@@ -836,2 +835,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        Object result = test43(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test43(MyValue1.class, vt);\n@@ -839,1 +838,1 @@\n-        result = test43(PrimitiveClass.asPrimaryType(MyValue1.class), null);\n+        result = test43(MyValue1.class, null);\n@@ -841,1 +840,1 @@\n-        result = test43(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        result = test43(MyValue1.class, vt);\n@@ -843,5 +842,0 @@\n-        try {\n-            test43(PrimitiveClass.asValueType(MyValue1.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n@@ -853,1 +847,1 @@\n-    public Object test44(Class c, MyValue1.ref vt) {\n+    public Object test44(Class c, MyValue1 vt) {\n@@ -859,1 +853,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -861,1 +855,1 @@\n-            test44(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+            test44(MyValue2.class, vt);\n@@ -865,1 +859,1 @@\n-        Object res = test44(PrimitiveClass.asPrimaryType(MyValue2.class), null);\n+        Object res = test44(MyValue2.class, null);\n@@ -868,1 +862,1 @@\n-            test44(PrimitiveClass.asValueType(MyValue2.class), vt);\n+            test44(MyValue2.class, vt);\n@@ -872,5 +866,0 @@\n-        try {\n-            test44(PrimitiveClass.asValueType(MyValue2.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n@@ -880,2 +869,2 @@\n-    public Object test45(MyValue1.ref vt) {\n-        return PrimitiveClass.asPrimaryType(MyValue1.class).cast(vt);\n+    public Object test45(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n@@ -886,1 +875,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -894,2 +883,2 @@\n-    public Object test46(MyValue1.ref vt) {\n-        return PrimitiveClass.asPrimaryType(MyValue2.class).cast(vt);\n+    public Object test46(MyValue1 vt) {\n+        return MyValue2.class.cast(vt);\n@@ -900,1 +889,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -911,2 +900,2 @@\n-    public Object test47(MyValue1.ref vt) {\n-        return PrimitiveClass.asValueType(MyValue1.class).cast(vt);\n+    public Object test47(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n@@ -917,1 +906,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -920,5 +909,2 @@\n-        try {\n-            test47(null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n+        result = test47(null);\n+        Asserts.assertEQ(result, null);\n@@ -928,1 +914,1 @@\n-    public Object test48(Class c, MyValue1.ref vt) {\n+    public Object test48(Class c, MyValue1 vt) {\n@@ -934,2 +920,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        Object result = test48(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test48(MyValue1.class, vt);\n@@ -937,5 +923,2 @@\n-        try {\n-            test48(PrimitiveClass.asValueType(MyValue1.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n+        result = test48(MyValue1.class, null);\n+        Asserts.assertEQ(result, null);\n@@ -946,1 +929,1 @@\n-        return PrimitiveClass.asPrimaryType(MyValue1.class).cast(vt);\n+        return MyValue1.class.cast(vt);\n@@ -964,3 +947,3 @@\n-        MyValue1[] va  = new MyValue1[42];\n-        MyValue1.ref[] vba = new MyValue1.ref[42];\n-        Object result = test50(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        MyValue1[] va  = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] vba = new MyValue1[42];\n+        Object result = test50(MyValue1.class, vt);\n@@ -968,1 +951,1 @@\n-        result = test50(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        result = test50(MyValue1.class, vt);\n@@ -972,1 +955,1 @@\n-        result = test50(MyValue1.ref[].class, vba);\n+        result = test50(MyValue1[].class, vba);\n@@ -974,1 +957,1 @@\n-        result = test50(MyValue1.ref[].class, va);\n+        result = test50(MyValue1[].class, va);\n@@ -976,0 +959,2 @@\n+        result = test50(MyValue1.class, null);\n+        Asserts.assertEQ(result, null);\n@@ -977,6 +962,1 @@\n-            test50(PrimitiveClass.asValueType(MyValue1.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n-        try {\n-            test50(MyValue1[].class, vba);\n+            test50(va.getClass(), vba);\n@@ -988,1 +968,1 @@\n-    \/\/ inline type array creation via reflection\n+    \/\/ Value class array creation via reflection\n@@ -991,1 +971,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asPrimaryType(MyValue1.class), len);\n+        Object[] va = (Object[])Array.newInstance(MyValue1.class, len);\n@@ -1003,1 +983,1 @@\n-    \/\/ multidimensional inline type array creation via reflection\n+    \/\/ multidimensional value class array creation via reflection\n@@ -1007,1 +987,1 @@\n-        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);\n+        MyValue1[][] va2 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n@@ -1010,1 +990,1 @@\n-            va1[0] = new MyValue1[1];\n+            va1[0] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1013,1 +993,1 @@\n-            va2[0] = new MyValue1.ref[1];\n+            va2[0] = new MyValue1[1];\n@@ -1034,1 +1014,1 @@\n-        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);\n+        MyValue1[][] va2 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n@@ -1042,4 +1022,4 @@\n-            va1[i] = new MyValue1[1];\n-            va2[i] = new MyValue1.ref[1];\n-            va3[i] = new MyValue1[1];\n-            va4[i] = new MyValue1.ref[1];\n+            va1[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va2[i] = new MyValue1[1];\n+            va3[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va4[i] = new MyValue1[1];\n@@ -1072,4 +1052,4 @@\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 1);\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 2);\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 3);\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 4);\n+        test53(MyValue1[].class, MyValue1[].class, len, 1);\n+        test53(MyValue1[].class, MyValue1[].class, len, 2);\n+        test53(MyValue1[].class, MyValue1[].class, len, 3);\n+        test53(MyValue1[].class, MyValue1[].class, len, 4);\n@@ -1103,0 +1083,1 @@\n+    @NullRestricted\n@@ -1110,1 +1091,1 @@\n-            return U.getValue(test55_vt, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+            return U.getValue(test55_vt, V1_OFFSET, MyValue2.class);\n@@ -1124,1 +1105,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), 1);\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1138,1 +1119,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), 1);\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1159,1 +1140,1 @@\n-        boolean res = test58(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class));\n+        boolean res = test58(MyValue1.class, MyValue1.class);\n@@ -1161,1 +1142,1 @@\n-        res = test58(Object.class, PrimitiveClass.asValueType(MyValue1.class));\n+        res = test58(Object.class, MyValue1.class);\n@@ -1163,1 +1144,1 @@\n-        res = test58(PrimitiveClass.asValueType(MyValue1.class), Object.class);\n+        res = test58(MyValue1.class, Object.class);\n@@ -1167,1 +1148,1 @@\n-    \/\/ Test synchronization on unsafe inline type allocation\n+    \/\/ Test synchronization on unsafe value object allocation\n@@ -1180,2 +1161,2 @@\n-            test59(PrimitiveClass.asValueType(MyValue1.class));\n-            throw new RuntimeException(\"test59 failed: synchronization on inline type should not succeed\");\n+            test59(MyValue1.class);\n+            throw new RuntimeException(\"test59 failed: synchronization on value object should not succeed\");\n@@ -1187,1 +1168,1 @@\n-    \/\/ Test mark word load optimization on unsafe inline type allocation\n+    \/\/ Test mark word load optimization on unsafe value object allocation\n@@ -1197,42 +1178,5 @@\n-        Asserts.assertTrue(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), false, false));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), MyValue2.class, false, false));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), false, true));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), true, false));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), true, true));\n-    }\n-\n-    \/\/ Test asPrimaryType intrinsic with non-value mirror\n-    @Test\n-    public Class<?> test61(Class<?> c) {\n-        if (PrimitiveClass.asPrimaryType(c) != Integer.class) {\n-            throw new RuntimeException(\"Unexpected class\");\n-        }\n-        return PrimitiveClass.asPrimaryType(Integer.class);\n-    }\n-\n-    @Run(test = \"test61\")\n-    public void test61_verifier() {\n-        Class<?> result = test61(Integer.class);\n-        Asserts.assertEQ(result, Integer.class);\n-    }\n-\n-    \/\/ Test asValueType intrinsic with non-value mirror\n-    @Test\n-    public Class<?> test62(Class<?> c) {\n-        try {\n-            PrimitiveClass.asValueType(c);\n-            throw new RuntimeException(\"No exception thrown\");\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ Expected\n-        }\n-        return PrimitiveClass.asValueType(Integer.class);\n-    }\n-\n-    @Run(test = \"test62\")\n-    public void test62_verifier() {\n-        try {\n-            test62(Integer.class);\n-            throw new RuntimeException(\"No exception thrown\");\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ Expected\n-        }\n+        Asserts.assertTrue(test60(MyValue1.class, MyValue1.class, false, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue2.class, false, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, false, true));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, true));\n@@ -1245,1 +1189,1 @@\n-            return U.compareAndSetValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1254,1 +1198,1 @@\n-        test31_vt = MyValue1.default;\n+        test31_vt = MyValue1.createDefaultInline();\n@@ -1258,1 +1202,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1264,1 +1208,1 @@\n-        res = test63(MyValue1.default, MyValue1.default);\n+        res = test63(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1275,1 +1219,1 @@\n-            return U.compareAndSetValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class, oldVal, newVal);\n@@ -1283,1 +1227,1 @@\n-        MyValue1[] arr = new MyValue1[2];\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1288,1 +1232,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1294,1 +1238,1 @@\n-        res = test64(arr, MyValue1.default, MyValue1.default);\n+        res = test64(arr, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1305,1 +1249,1 @@\n-            return U.compareAndSetValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(o, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1314,1 +1258,1 @@\n-        test31_vt = MyValue1.default;\n+        test31_vt = MyValue1.createDefaultInline();\n@@ -1320,1 +1264,1 @@\n-        res = test65(this, MyValue1.default, MyValue1.default);\n+        res = test65(this, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1329,1 +1273,1 @@\n-            return U.compareAndSetValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1338,1 +1282,1 @@\n-        test31_vt = MyValue1.default;\n+        test31_vt = MyValue1.createDefaultInline();\n@@ -1344,1 +1288,1 @@\n-        res = test66(MyValue1.default, MyValue1.default);\n+        res = test66(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1353,1 +1297,1 @@\n-            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1362,1 +1306,1 @@\n-        MyValue1 oldVal = MyValue1.default;\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n@@ -1367,1 +1311,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1373,1 +1317,1 @@\n-        res = test67(MyValue1.default, MyValue1.default);\n+        res = test67(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1384,1 +1328,1 @@\n-            return U.compareAndExchangeValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class, oldVal, newVal);\n@@ -1392,1 +1336,1 @@\n-        MyValue1[] arr = new MyValue1[2];\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1397,1 +1341,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1399,1 +1343,1 @@\n-            Asserts.assertEQ(res, MyValue1.default);\n+            Asserts.assertEQ(res, MyValue1.createDefaultInline());\n@@ -1403,1 +1347,1 @@\n-        res = test68(arr, MyValue1.default, MyValue1.default);\n+        res = test68(arr, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1414,1 +1358,1 @@\n-            return U.compareAndExchangeValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(o, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1423,1 +1367,1 @@\n-        MyValue1 oldVal = MyValue1.default;\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n@@ -1430,1 +1374,1 @@\n-        res = test69(this, MyValue1.default, MyValue1.default);\n+        res = test69(this, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1439,1 +1383,1 @@\n-            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1448,1 +1392,1 @@\n-        MyValue1 oldVal = MyValue1.default;\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n@@ -1455,1 +1399,1 @@\n-        res = test70(MyValue1.default, MyValue1.default);\n+        res = test70(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1460,1 +1404,1 @@\n-    \/\/ getValue to retrieve flattened field from (nullable) inline type\n+    \/\/ getValue to retrieve flattened field from (nullable) value class\n@@ -1463,1 +1407,1 @@\n-    public MyValue2 test71(boolean b, MyValue1.val v1, MyValue1.ref v2) {\n+    public MyValue2 test71(boolean b, MyValue1 v1, MyValue1 v2) {\n@@ -1466,1 +1410,1 @@\n-                return U.getValue(v1, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v1, V1_OFFSET, MyValue2.class);\n@@ -1471,1 +1415,1 @@\n-                return U.getValue(v2, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v2, V1_OFFSET, MyValue2.class);\n@@ -1487,1 +1431,1 @@\n-    public MyValue2 test72(boolean b, MyValue1.val v1, MyValue1.ref v2, long offset) {\n+    public MyValue2 test72(boolean b, MyValue1 v1, MyValue1 v2, long offset) {\n@@ -1490,1 +1434,1 @@\n-                return U.getValue(v1, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v1, offset, MyValue2.class);\n@@ -1495,1 +1439,1 @@\n-                return U.getValue(v2, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v2, offset, MyValue2.class);\n@@ -1508,2 +1452,3 @@\n-    static final MyValue1.val test73_value1 = MyValue1.createWithFieldsInline(rI, rL);\n-    static final MyValue1.ref test73_value2 = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+    @NullRestricted\n+    static final MyValue1 test73_value1 = MyValue1.createWithFieldsInline(rI, rL);\n+    static final MyValue1 test73_value2 = MyValue1.createWithFieldsInline(rI+1, rL+1);\n@@ -1517,1 +1462,1 @@\n-                return U.getValue(test73_value1, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(test73_value1, offset, MyValue2.class);\n@@ -1522,1 +1467,1 @@\n-                return U.getValue(test73_value2, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(test73_value2, offset, MyValue2.class);\n@@ -1534,1 +1479,3 @@\n-    static primitive class EmptyInline {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyInline {\n@@ -1538,1 +1485,3 @@\n-    static primitive class ByteInline {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ByteInline {\n@@ -1550,1 +1499,1 @@\n-        EmptyInline[] emptyArray = new EmptyInline[100];\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n@@ -1553,1 +1502,1 @@\n-            Asserts.assertEQ(empty, EmptyInline.default);\n+            Asserts.assertEQ(empty, new EmptyInline());\n@@ -1564,1 +1513,1 @@\n-        EmptyInline[] emptyArray = new EmptyInline[100];\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n@@ -1567,1 +1516,1 @@\n-            Asserts.assertEQ(empty, EmptyInline.default);\n+            Asserts.assertEQ(empty, new EmptyInline());\n@@ -1579,1 +1528,1 @@\n-        ByteInline[] byteArray = new ByteInline[100];\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n@@ -1582,1 +1531,1 @@\n-            Asserts.assertEQ(b, ByteInline.default);\n+            Asserts.assertEQ(b, new ByteInline());\n@@ -1593,1 +1542,1 @@\n-        ByteInline[] byteArray = new ByteInline[100];\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n@@ -1596,1 +1545,1 @@\n-            Asserts.assertEQ(b, ByteInline.default);\n+            Asserts.assertEQ(b, new ByteInline());\n@@ -1601,1 +1550,1 @@\n-    public Object test78(MyValue1.ref vt) {\n+    public Object test78(MyValue1 vt) {\n@@ -1619,1 +1568,1 @@\n-    public Object test79(MyValue1.ref vt) {\n+    public Object test79(MyValue1 vt) {\n@@ -1636,2 +1585,5 @@\n-    public static final primitive class Test80Value1 {\n-        final Test80Value2 v = new Test80Value2();\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test80Value1 {\n+        @NullRestricted\n+        Test80Value2 v = new Test80Value2();\n@@ -1640,3 +1592,5 @@\n-    public static final primitive class Test80Value2 {\n-        final long l = rL;\n-        final Integer i = rI;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test80Value2 {\n+        long l = rL;\n+        Integer i = rI;\n@@ -1648,1 +1602,1 @@\n-    public Test80Value2 test80(Test80Value1.ref v, boolean flat, long offset) {\n+    public Test80Value2 test80(Test80Value1 v, boolean flat, long offset) {\n@@ -1650,1 +1604,1 @@\n-            return U.getValue(v, offset, PrimitiveClass.asValueType(Test80Value2.class));\n+            return U.getValue(v, offset, Test80Value2.class);\n@@ -1659,1 +1613,1 @@\n-        Field field = PrimitiveClass.asValueType(Test80Value1.class).getDeclaredField(\"v\");\n+        Field field = Test80Value1.class.getDeclaredField(\"v\");\n@@ -1671,1 +1625,1 @@\n-        Asserts.assertEQ(test81(MyValue1[].class), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n+        Asserts.assertEQ(test81(TEST33_ARRAY.getClass()), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n@@ -1682,1 +1636,1 @@\n-        boolean check1 = U.isFlattenedArray(MyValue1[].class);\n+        boolean check1 = U.isFlattenedArray(TEST33_ARRAY.getClass());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":235,"deletions":281,"binary":false,"changes":516,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -32,2 +33,1 @@\n- * @compile -XDenablePrimitiveClasses TestIsSubstitutableReresolution.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -37,2 +37,3 @@\n-final primitive class MyValue {\n-    final int x;\n+\n+value class MyValue {\n+    int x;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIsSubstitutableReresolution.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @summary Test calling native methods with inline type arguments from compiled code.\n+ * @summary Test calling native methods with value class arguments from compiled code.\n@@ -38,2 +38,3 @@\n- * @compile -XDenablePrimitiveClasses TestJNICalls.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestJNICalls\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestJNICalls.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestJNICalls\n@@ -63,1 +64,1 @@\n-    \/\/ Pass an inline type to a native method that calls back into Java code and returns an inline type\n+    \/\/ Pass a value object to a native method that calls back into Java code and returns a value object\n@@ -83,1 +84,1 @@\n-    \/\/ Pass an inline type to a native method that calls the hash method and returns the result\n+    \/\/ Pass a value object to a native method that calls the hash method and returns the result\n@@ -97,2 +98,2 @@\n-    static primitive class MyValueWithNative {\n-        public final int x;\n+    static value class MyValueWithNative {\n+        public int x;\n@@ -107,1 +108,1 @@\n-    \/\/ Call a native method with an inline type receiver\n+    \/\/ Call a native method with a value class receiver\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestJNICalls.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+\n@@ -36,0 +37,1 @@\n+import java.util.Objects;\n@@ -37,1 +39,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -50,3 +55,3 @@\n- * @compile -XDenablePrimitiveClasses MyValue5.jcod\n- * @compile -XDenablePrimitiveClasses TestLWorld.java\n- * @run main\/othervm\/timeout=450 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestLWorld\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestLWorld.java\n+ * @run main\/othervm\/timeout=450 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestLWorld\n@@ -86,0 +91,1 @@\n+    @NullRestricted\n@@ -87,0 +93,1 @@\n+    @NullRestricted\n@@ -138,0 +145,1 @@\n+    @NullRestricted\n@@ -139,0 +147,1 @@\n+    @NullRestricted\n@@ -140,1 +149,2 @@\n-    MyValue1.ref valueField3 = testValue1;\n+    MyValue1 valueField3 = testValue1;\n+    @NullRestricted\n@@ -142,1 +152,1 @@\n-    MyValue1.ref valueField5;\n+    MyValue1 valueField5;\n@@ -144,1 +154,2 @@\n-    static MyValue1.ref staticValueField1 = testValue1;\n+    static MyValue1 staticValueField1 = testValue1;\n+    @NullRestricted\n@@ -146,0 +157,1 @@\n+    @NullRestricted\n@@ -147,1 +159,1 @@\n-    static MyValue1.ref staticValueField4;\n+    static MyValue1 staticValueField4;\n@@ -613,0 +625,3 @@\n+        if (vt == null) {\n+            return;\n+        }\n@@ -630,0 +645,3 @@\n+        if (vt == null) {\n+            return;\n+        }\n@@ -646,3 +664,6 @@\n-    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,\n-                                                                      testValue1,\n-                                                                      testValue1};\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n+    static {\n+        for (int i = 0; i < 3; ++i) {\n+            testValue1Array[i] = testValue1;\n+        }\n+    }\n@@ -654,3 +675,6 @@\n-    private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,\n-                                                                      testValue2,\n-                                                                      testValue2};\n+    private static final MyValue2[] testValue2Array = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 3);\n+    static {\n+        for (int i = 0; i < 3; ++i) {\n+            testValue2Array[i] = testValue2;\n+        }\n+    }\n@@ -1108,2 +1132,0 @@\n-    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n-        failOn = {ALLOC_G})\n@@ -1157,1 +1179,1 @@\n-        return new MyValue1[42];\n+        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -1195,1 +1217,1 @@\n-        MyValue1[] va = new MyValue1[42];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -1229,1 +1251,1 @@\n-        return new MyValue1[42];\n+        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -1281,1 +1303,1 @@\n-        MyValue1[] va = new MyValue1[42];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -1364,1 +1386,2 @@\n-        MyValue1[] vals = new MyValue1[] {testValue1};\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        vals[0] = testValue1;\n@@ -1375,2 +1398,2 @@\n-    private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);\n-    private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+    private static final MyValue1 test42VT1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue1 test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n@@ -1381,1 +1404,3 @@\n-        MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        vals[0] = test42VT1;\n+        vals[1] = test42VT2;\n@@ -1395,1 +1420,3 @@\n-        MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        vals[0] = test42VT1;\n+        vals[1] = test42VT2;\n@@ -1415,1 +1442,1 @@\n-        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, PrimitiveClass.asValueType(MyValue2.class)),\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),\n@@ -1450,1 +1477,0 @@\n-    @IR(failOn = {ALLOC_G})\n@@ -1535,13 +1561,18 @@\n-    final primitive class Test51Value {\n-        final Object objectField1;\n-        final Object objectField2;\n-        final Object objectField3;\n-        final Object objectField4;\n-        final Object objectField5;\n-        final Object objectField6;\n-\n-        final MyValue1 valueField1;\n-        final MyValue1 valueField2;\n-        final MyValue1.ref valueField3;\n-        final MyValue1 valueField4;\n-        final MyValue1.ref valueField5;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test51Value {\n+        Object objectField1;\n+        Object objectField2;\n+        Object objectField3;\n+        Object objectField4;\n+        Object objectField5;\n+        Object objectField6;\n+\n+        @NullRestricted\n+        MyValue1 valueField1;\n+        @NullRestricted\n+        MyValue1 valueField2;\n+        MyValue1 valueField3;\n+        @NullRestricted\n+        MyValue1 valueField4;\n+        MyValue1 valueField5;\n@@ -1564,1 +1595,1 @@\n-                           MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {\n+                           MyValue1 vt1, MyValue1 vt2, MyValue1 vt3, MyValue1 vt4, MyValue1 vt5) {\n@@ -1613,0 +1644,1 @@\n+    @NullRestricted\n@@ -1614,0 +1646,1 @@\n+    @NullRestricted\n@@ -1648,1 +1681,2 @@\n-        Test51Value vt = Test51Value.default;\n+        Test51Value vt = new Test51Value(null, null, null, null, null, null,\n+                                         MyValue1.createDefaultInline(), MyValue1.createDefaultInline(), null, MyValue1.createDefaultInline(), null);\n@@ -1913,1 +1947,1 @@\n-        MyValue1[] array = new MyValue1[1];\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1925,1 +1959,1 @@\n-        MyValue1[] array = new MyValue1[1];\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2015,1 +2049,1 @@\n-            vt = (MyValue1)obj;\n+            vt = (MyValue1)Objects.requireNonNull(obj);\n@@ -2036,2 +2070,5 @@\n-    final primitive class Test72Value {\n-        final int x = 42;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test72Value {\n+        int x = 0;\n+\n@@ -2049,1 +2086,1 @@\n-        Test72Value vt = Test72Value.default;\n+        Test72Value vt = new Test72Value();\n@@ -2079,1 +2116,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2089,1 +2126,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2104,24 +2141,0 @@\n-    \/\/ Casting a null Integer to a (non-nullable) inline type should throw a NullPointerException\n-    @ForceInline\n-    public MyValue1 test76_helper(Object o) {\n-        return (MyValue1)o;\n-    }\n-\n-    @Test\n-    @IR(failOn = {ALLOC_G})\n-    public MyValue1 test76(Integer i) throws Throwable {\n-        return test76_helper(i);\n-    }\n-\n-    @Run(test = \"test76\")\n-    public void test76_verifier() throws Throwable {\n-        try {\n-            test76(null);\n-            throw new RuntimeException(\"NullPointerException expected\");\n-        } catch (NullPointerException e) {\n-            \/\/ Expected\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"test76 failed: unexpected exception\", e);\n-        }\n-    }\n-\n@@ -2154,2 +2167,2 @@\n-    public MyValue1.ref test78_helper(Object o) {\n-        return (MyValue1.ref)o;\n+    public MyValue1 test78_helper(Object o) {\n+        return (MyValue1)o;\n@@ -2160,1 +2173,1 @@\n-    public MyValue1.ref test78(Integer i) throws Throwable {\n+    public MyValue1 test78(Integer i) throws Throwable {\n@@ -2175,2 +2188,2 @@\n-    public MyValue1.ref test79_helper(Object o) {\n-        return (MyValue1.ref)o;\n+    public MyValue1 test79_helper(Object o) {\n+        return (MyValue1)o;\n@@ -2181,1 +2194,1 @@\n-    public MyValue1.ref test79(Integer i) throws Throwable {\n+    public MyValue1 test79(Integer i) throws Throwable {\n@@ -2198,3 +2211,6 @@\n-    static primitive class Small {\n-        final int i;\n-        final Big big; \/\/ Too big to be flattened\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Small {\n+        int i;\n+        @NullRestricted\n+        Big big; \/\/ Too big to be flattened\n@@ -2208,1 +2224,3 @@\n-    static primitive class Big {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Big {\n@@ -2220,0 +2238,1 @@\n+    @NullRestricted\n@@ -2221,0 +2240,1 @@\n+    @NullRestricted\n@@ -2222,0 +2242,1 @@\n+    @NullRestricted\n@@ -2223,0 +2244,1 @@\n+    @NullRestricted\n@@ -2270,1 +2292,1 @@\n-        MyValue2[] dst = new MyValue2[1];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n@@ -2291,1 +2313,1 @@\n-            dst = new MyValue2[1]; \/\/ constant null free property\n+            dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1); \/\/ constant null free property\n@@ -2299,1 +2321,1 @@\n-        MyValue2[] dst = new MyValue2[1];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n@@ -2338,1 +2360,1 @@\n-        MyValue2[] src = new MyValue2[100];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -2340,1 +2362,1 @@\n-        MyValue2[] dst = new MyValue2[100];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -2383,1 +2405,1 @@\n-        MyValue2[] src = new MyValue2[100];\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -2407,1 +2429,1 @@\n-        MyValue2[] dst = new MyValue2[100];\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -2429,1 +2451,1 @@\n-        MyValue2[] src1 = new MyValue2[100];\n+        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -2431,1 +2453,1 @@\n-        MyValue2[] dst1 = new MyValue2[100];\n+        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -2476,0 +2498,1 @@\n+        Asserts.assertFalse(test91((MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1)));\n@@ -2477,1 +2500,0 @@\n-        Asserts.assertFalse(test91(new MyValue2.ref[1]));\n@@ -2481,2 +2503,5 @@\n-    static primitive class Test92Value {\n-        final int field;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test92Value {\n+        int field;\n+\n@@ -2536,1 +2561,1 @@\n-            Object[] array = new Test92Value[1];\n+            Object[] array = (Test92Value[])ValueClass.newNullRestrictedArray(Test92Value.class, 1);\n@@ -2702,1 +2727,1 @@\n-    class MyObject2 extends MyAbstract {\n+    value class MyObject2 extends MyAbstract {\n@@ -2962,1 +2987,1 @@\n-        MyValue2[] src1 = new MyValue2[100];\n+        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -2993,1 +3018,1 @@\n-        MyValue2[] dst1 = new MyValue2[100];\n+        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n@@ -3023,1 +3048,4 @@\n-    static primitive class LongWrapper implements WrapperInterface {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class LongWrapper implements WrapperInterface {\n+        @NullRestricted\n@@ -3082,1 +3110,1 @@\n-        LongWrapper.ref content;\n+        LongWrapper content;\n@@ -3085,1 +3113,1 @@\n-        RefBox(LongWrapper.ref content) {\n+        RefBox(LongWrapper content) {\n@@ -3096,1 +3124,1 @@\n-            return new RefBox((LongWrapper.ref)WrapperInterface.wrap(val));\n+            return new RefBox((LongWrapper)WrapperInterface.wrap(val));\n@@ -3101,0 +3129,1 @@\n+        @NullRestricted\n@@ -3118,2 +3147,2 @@\n-        static GenericBox<LongWrapper.ref> box_sharp(long val) {\n-            GenericBox<LongWrapper.ref> res = new GenericBox<>();\n+        static GenericBox<LongWrapper> box_sharp(long val) {\n+            GenericBox<LongWrapper> res = new GenericBox<>();\n@@ -3305,1 +3334,1 @@\n-        static final InlineWrapper.ref ZERO = new InlineWrapper(0);\n+        static final InlineWrapper ZERO = new InlineWrapper(0);\n@@ -3314,1 +3343,1 @@\n-            return (val == 0) ? LongWrapper2.default : new LongWrapper2(val);\n+            return (val == 0) ? new LongWrapper2(0) : new LongWrapper2(val);\n@@ -3318,1 +3347,3 @@\n-    static primitive class LongWrapper2 implements WrapperInterface2 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class LongWrapper2 implements WrapperInterface2 {\n@@ -3332,1 +3363,3 @@\n-    static primitive class InlineWrapper {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class InlineWrapper {\n@@ -3379,1 +3412,1 @@\n-    \/\/ Same as test114 but with .default instead of ZERO field\n+    \/\/ Same as test114 but with default instead of ZERO field\n@@ -3398,4 +3431,6 @@\n-    static MyValueEmpty     fEmpty1;\n-    static MyValueEmpty.ref fEmpty2 = MyValueEmpty.default;\n-           MyValueEmpty     fEmpty3;\n-           MyValueEmpty.ref fEmpty4 = MyValueEmpty.default;\n+    @NullRestricted\n+    static MyValueEmpty fEmpty1;\n+    static MyValueEmpty fEmpty2 = new MyValueEmpty();\n+    @NullRestricted\n+           MyValueEmpty fEmpty3;\n+           MyValueEmpty fEmpty4 = new MyValueEmpty();\n@@ -3424,1 +3459,1 @@\n-    public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty.ref[] arr2) {\n+    public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty[] arr2) {\n@@ -3432,1 +3467,1 @@\n-        MyValueEmpty[] arr1 = new MyValueEmpty[]{MyValueEmpty.default};\n+        MyValueEmpty[] arr1 = new MyValueEmpty[] { new MyValueEmpty() };\n@@ -3434,2 +3469,2 @@\n-        Asserts.assertEquals(res, MyValueEmpty.default);\n-        Asserts.assertEquals(arr1[0], MyValueEmpty.default);\n+        Asserts.assertEquals(res, new MyValueEmpty());\n+        Asserts.assertEquals(arr1[0], new MyValueEmpty());\n@@ -3440,2 +3475,1 @@\n-    @IR(failOn = {ALLOC_G})\n-    public boolean test118(MyValueEmpty v1, MyValueEmpty.ref v2, Object o1) {\n+    public boolean test118(MyValueEmpty v1, MyValueEmpty v2, Object o1) {\n@@ -3447,1 +3481,1 @@\n-        boolean res = test118(MyValueEmpty.default, MyValueEmpty.default, new MyValueEmpty());\n+        boolean res = test118(new MyValueEmpty(), new MyValueEmpty(), new MyValueEmpty());\n@@ -3451,2 +3485,5 @@\n-    static primitive class EmptyContainer {\n-        private MyValueEmpty empty = MyValueEmpty.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyContainer {\n+        @NullRestricted\n+        private MyValueEmpty empty = new MyValueEmpty();\n@@ -3455,3 +3492,6 @@\n-    static primitive class MixedContainer {\n-        public int val = rI;\n-        private EmptyContainer empty = EmptyContainer.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MixedContainer {\n+        public int val = 0;\n+        @NullRestricted\n+        private EmptyContainer empty = new EmptyContainer();\n@@ -3460,0 +3500,9 @@\n+    @NullRestricted\n+    static final MyValueEmpty empty = new MyValueEmpty();\n+\n+    @NullRestricted\n+    static final EmptyContainer emptyC = new EmptyContainer();\n+\n+    @NullRestricted\n+    static final MixedContainer mixedContainer = new MixedContainer();\n+\n@@ -3464,3 +3513,5 @@\n-        MyValueEmpty[]   array1 = new MyValueEmpty[]{MyValueEmpty.default};\n-        EmptyContainer[] array2 = new EmptyContainer[]{EmptyContainer.default};\n-        MixedContainer[] array3 = new MixedContainer[]{MixedContainer.default};\n+        MyValueEmpty[]   array1 = new MyValueEmpty[] { empty };\n+        EmptyContainer[] array2 = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 1);\n+        array2[0] = emptyC;\n+        MixedContainer[] array3 = (MixedContainer[])ValueClass.newNullRestrictedArray(MixedContainer.class, 1);\n+        array3[0] = mixedContainer;\n@@ -3471,3 +3522,3 @@\n-        Asserts.assertEquals(array1[0], MyValueEmpty.default);\n-        Asserts.assertEquals(array2[0], EmptyContainer.default);\n-        Asserts.assertEquals(array3[0], MixedContainer.default);\n+        Asserts.assertEquals(array1[0], empty);\n+        Asserts.assertEquals(array2[0], emptyC);\n+        Asserts.assertEquals(array3[0], mixedContainer);\n@@ -3484,1 +3535,1 @@\n-    public void test120(MyValueEmpty empty) {\n+    public void test120() {\n@@ -3492,3 +3543,3 @@\n-        test120(MyValueEmpty.default);\n-        Asserts.assertEquals(fEmpty1, MyValueEmpty.default);\n-        Asserts.assertEquals(fEmpty2, MyValueEmpty.default);\n+        test120();\n+        Asserts.assertEquals(fEmpty1, empty);\n+        Asserts.assertEquals(fEmpty2, empty);\n@@ -3521,1 +3572,1 @@\n-        Asserts.assertEquals(res, MyValueEmpty.default);\n+        Asserts.assertEquals(res, new MyValueEmpty());\n@@ -3534,1 +3585,1 @@\n-        t.fEmpty3 = MyValueEmpty.default;\n+        t.fEmpty3 = new MyValueEmpty();\n@@ -3540,1 +3591,1 @@\n-        Asserts.assertEquals(fEmpty3, MyValueEmpty.default);\n+        Asserts.assertEquals(fEmpty3, new MyValueEmpty());\n@@ -3582,1 +3633,1 @@\n-        MyValue2.ref val = null;\n+        MyValue2 val = null;\n@@ -3644,1 +3695,1 @@\n-        MyValue2.ref val = null;\n+        MyValue2 val = null;\n@@ -3841,1 +3892,1 @@\n-    \/\/ Same as test135 but with .ref\n+    \/\/ Same as test135 but with null\n@@ -3845,1 +3896,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -3873,1 +3924,1 @@\n-    \/\/ Same as test137 but with .ref\n+    \/\/ Same as test137 but with null\n@@ -3878,2 +3929,2 @@\n-        MyValue2.ref val1 = MyValue2.createWithFieldsInline(i, rD);\n-        MyValue2.ref val2 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(i, rD);\n@@ -3893,1 +3944,3 @@\n-    static primitive class Test139Value {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test139Value {\n@@ -3895,1 +3948,2 @@\n-        MyValueEmpty empty = MyValueEmpty.default;\n+        @NullRestricted\n+        MyValueEmpty empty = new MyValueEmpty();\n@@ -3898,2 +3952,5 @@\n-    static primitive class Test139Wrapper {\n-        Test139Value value = Test139Value.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test139Wrapper {\n+        @NullRestricted\n+        Test139Value value = new Test139Value();\n@@ -3912,1 +3969,1 @@\n-        Asserts.assertEquals(empty, MyValueEmpty.default);\n+        Asserts.assertEquals(empty, new MyValueEmpty());\n@@ -3916,2 +3973,5 @@\n-    final primitive class Test140Value {\n-        final int x = 42;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test140Value {\n+        int x = 0;\n+\n@@ -3926,1 +3986,1 @@\n-        Test140Value vt = Test140Value.default;\n+        Test140Value vt = new Test140Value();\n@@ -3938,2 +3998,5 @@\n-    final primitive class Test141Value {\n-        final int x = 42;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test141Value {\n+        int x = 0;\n+\n@@ -3948,1 +4011,1 @@\n-        Test141Value vt = Test141Value.default;\n+        Test141Value vt = new Test141Value();\n@@ -3980,30 +4043,0 @@\n-    public int intField;\n-\n-    private static final MethodHandle withfieldWithInvalidHolder = InstructionHelper.loadCode(MethodHandles.lookup(),\n-        \"withfieldWithInvalidHolder\",\n-        MethodType.methodType(void.class, TestLWorld.class, int.class),\n-        CODE -> {\n-            CODE.\n-            aload_0().\n-            iload_1().\n-            withfield(TestLWorld.class, \"intField\", \"I\").\n-            return_();\n-        });\n-\n-    \/\/ Test withfield on identity class\n-    @Test\n-    public void test143() throws Throwable {\n-        withfieldWithInvalidHolder.invoke(this, 0);\n-    }\n-\n-    @Run(test = \"test143\")\n-    @Warmup(10000)\n-    public void test143_verifier() throws Throwable {\n-        try {\n-            test143();\n-            throw new RuntimeException(\"IncompatibleClassChangeError expected\");\n-        } catch (IncompatibleClassChangeError e) {\n-            \/\/ Expected\n-        }\n-    }\n-\n@@ -4015,1 +4048,1 @@\n-            return MyValue1.default;\n+            return MyValue1.createDefaultInline();\n@@ -4019,1 +4052,1 @@\n-            return MyValue1.default;\n+            return MyValue1.createDefaultInline();\n@@ -4025,1 +4058,1 @@\n-        Asserts.assertEquals(test144(0), MyValue1.default);\n+        Asserts.assertEquals(test144(0), MyValue1.createDefaultInline());\n@@ -4027,1 +4060,1 @@\n-        Asserts.assertEquals(test144(2), MyValue1.default);\n+        Asserts.assertEquals(test144(2), MyValue1.createDefaultInline());\n@@ -4033,1 +4066,1 @@\n-        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, PrimitiveClass.asPrimaryType(MyValue2.class)),\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),\n@@ -4043,19 +4076,0 @@\n-    \/\/ Same as test44 but with .ref store to array\n-    @Test\n-    public void test145(MyValue1[] va, int index, MyValue2.ref v) throws Throwable {\n-        setArrayElementIncompatibleRef.invoke(this, va, index, v);\n-    }\n-\n-    @Run(test = \"test145\")\n-    @Warmup(10000)\n-    public void test145_verifier() throws Throwable {\n-        int index = Math.abs(rI) % 3;\n-        try {\n-            test145(testValue1Array, index, testValue2);\n-            throw new RuntimeException(\"No ArrayStoreException thrown\");\n-        } catch (ArrayStoreException e) {\n-            \/\/ Expected\n-        }\n-        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n-    }\n-\n@@ -4075,14 +4089,0 @@\n-    \/\/ Same as test146 but with .ref cast\n-    @Test\n-    @IR(failOn = {ALLOC_G})\n-    public MyValue1.ref test147(Object obj) {\n-        return (MyValue1.ref)obj;\n-    }\n-\n-    @Run(test = \"test147\")\n-    @Warmup(10000)\n-    public void test147_verifier() {\n-        Asserts.assertEQ(test147(testValue1), testValue1);\n-        Asserts.assertEQ(test147(null), null);\n-    }\n-\n@@ -4108,1 +4108,1 @@\n-        return (MyValue1.ref)obj;\n+        return (MyValue1)obj;\n@@ -4149,0 +4149,2 @@\n+\/\/ TODO 8325106 This triggers #  assert(false) failed: Should have been buffered\n+\/*\n@@ -4171,0 +4173,1 @@\n+*\/\n@@ -4194,1 +4197,3 @@\n-    static primitive class MyValue152 extends MyAbstract2 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue152 extends MyAbstract2 {\n@@ -4209,1 +4214,3 @@\n-    static primitive class MyWrapper152 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyWrapper152 {\n@@ -4211,0 +4218,1 @@\n+        @NullRestricted\n@@ -4311,12 +4319,1 @@\n-    \/\/ Test withfield directly operating on inline type arg (instead of on defaultvalue)\n-    @Test\n-    public MyValue5 test156(MyValue5 vt) {\n-        return vt.withField(rI);\n-    }\n-\n-    @Run(test = \"test156\")\n-    @Warmup(10000)\n-    public void test156_verifier() {\n-        Asserts.assertEquals(test156(new MyValue5()).x, rI);\n-    }\n-\n+    @NullRestricted\n@@ -4337,0 +4334,1 @@\n+    @NullRestricted\n@@ -4351,20 +4349,0 @@\n-    \/\/ Test null check on withfield receiver\n-    @Test\n-    public MyValue5.ref test159(MyValue5.ref vt) {\n-        return MyValue5.withField(vt, rI);\n-    }\n-\n-    @Run(test = \"test159\")\n-    @Warmup(10000)\n-    public void test159_verifier(RunInfo info) {\n-        Asserts.assertEquals(test159(new MyValue5()).x, rI);\n-        if (!info.isWarmUp()) {\n-            try {\n-                test159(null);\n-                throw new RuntimeException(\"No NPE thrown\");\n-            } catch (NullPointerException e) {\n-                \/\/ Expected\n-            }\n-        }\n-    }\n-\n@@ -4387,6 +4365,1 @@\n-        try {\n-            test160(null);\n-            throw new RuntimeException(\"No NPE thrown\");\n-        } catch (NullPointerException e) {\n-            \/\/ Expected\n-        }\n+        test160(null);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":241,"deletions":268,"binary":false,"changes":509,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -38,1 +43,1 @@\n- * @summary Test inline type specific profiling\n+ * @summary Test value class specific type profiling.\n@@ -41,2 +46,7 @@\n- * @compile -XDenablePrimitiveClasses TestLWorldProfiling.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestLWorldProfiling\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *          TestLWorldProfiling.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla\n+ *                               --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                               --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                               compiler.valhalla.inlinetypes.TestLWorldProfiling\n@@ -51,1 +61,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -58,1 +67,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -64,1 +72,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -71,1 +78,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -80,1 +86,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -88,1 +93,0 @@\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n@@ -100,1 +104,3 @@\n-                   .addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\")\n+                   .addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+EnableValhalla\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\")\n@@ -106,0 +112,1 @@\n+    @NullRestricted\n@@ -107,0 +114,1 @@\n+    @NullRestricted\n@@ -108,7 +116,13 @@\n-    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1};\n-    private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2};\n-    private static final Integer[] testIntegerArray = new Integer[] {42};\n-    private static final Long[] testLongArray = new Long[] {42L};\n-    private static final Double[] testDoubleArray = new Double[] {42.0D};\n-    private static final MyValue1.ref[] testValue1NotFlatArray = new MyValue1.ref[] {testValue1};\n-    private static final MyValue1[][] testValue1ArrayArray = new MyValue1[][] {testValue1Array};\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+    static {\n+        testValue1Array[0] = testValue1;\n+    }\n+    private static final MyValue2[] testValue2Array = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n+    static {\n+        testValue2Array[0] = testValue2;\n+    }\n+    private static final Integer[] testIntegerArray = new Integer[] { 42 };\n+    private static final Long[] testLongArray = new Long[] { 42L };\n+    private static final Double[] testDoubleArray = new Double[] { 42.0D };\n+    private static final MyValue1[] testValue1NotFlatArray = new MyValue1[] { testValue1 };\n+    private static final MyValue1[][] testValue1ArrayArray = new MyValue1[][] { testValue1Array };\n@@ -430,7 +444,9 @@\n-    primitive static class NotFlattenable {\n-        private final Object o1 = null;\n-        private final Object o2 = null;\n-        private final Object o3 = null;\n-        private final Object o4 = null;\n-        private final Object o5 = null;\n-        private final Object o6 = null;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class NotFlattenable {\n+        private Object o1 = null;\n+        private Object o2 = null;\n+        private Object o3 = null;\n+        private Object o4 = null;\n+        private Object o5 = null;\n+        private Object o6 = null;\n@@ -439,0 +455,1 @@\n+    @NullRestricted\n@@ -440,1 +457,1 @@\n-    private static final NotFlattenable[] testNotFlattenableArray = new NotFlattenable[] { notFlattenable };\n+    private static final NotFlattenable[] testNotFlattenableArray = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n@@ -685,1 +702,1 @@\n-    \/\/ Input profiled not inline type with known type\n+    \/\/ Input profiled not value class with known type\n@@ -849,1 +866,1 @@\n-    \/\/ Input profiled not inline type with unknown type\n+    \/\/ Input profiled not value class with unknown type\n@@ -1079,1 +1096,4 @@\n-    static primitive class Test40Inline extends Test40Abstract { }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test40Inline extends Test40Abstract { }\n@@ -1128,1 +1148,2 @@\n-            test41(new Test40Inline[1], new Test40Inline());\n+            Test40Inline[] array = (Test40Inline[])ValueClass.newNullRestrictedArray(Test40Inline.class, 1);\n+            test41(array, new Test40Inline());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":51,"deletions":30,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- * @compile -XDenablePrimitiveClasses\n- *          --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ * @compile --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n@@ -33,1 +32,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -81,1 +80,1 @@\n-    primitive static class Value {\n+    static value class Value {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLarvalState.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xcomp -XX:CompileCommand=compileonly,TestLoopUnswitchingWithFlatArrayCheck::test TestLoopUnswitchingWithFlatArrayCheck\n+ * @run main\/othervm -XX:+EnableValhalla -Xcomp -XX:CompileCommand=compileonly,TestLoopUnswitchingWithFlatArrayCheck::test TestLoopUnswitchingWithFlatArrayCheck\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLoopUnswitchingWithFlatArrayCheck.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -47,2 +50,7 @@\n- * @compile -XDenablePrimitiveClasses TestMethodHandles.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestMethodHandles\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *          TestMethodHandles.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla\n+ *                               --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                               --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                               compiler.valhalla.inlinetypes.TestMethodHandles\n@@ -59,1 +67,1 @@\n-            MethodType mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue3.class));\n+            MethodType mt = MethodType.methodType(MyValue3.class);\n@@ -64,2 +72,2 @@\n-            MethodType test4_mt1 = MethodType.methodType(int.class, PrimitiveClass.asValueType(MyValue1.class));\n-            MethodType test4_mt2 = MethodType.methodType(PrimitiveClass.asValueType(MyValue1.class));\n+            MethodType test4_mt1 = MethodType.methodType(int.class, MyValue1.class);\n+            MethodType test4_mt2 = MethodType.methodType(MyValue1.class);\n@@ -70,1 +78,1 @@\n-            MethodType test5_mt = MethodType.methodType(int.class, PrimitiveClass.asValueType(MyValue1.class));\n+            MethodType test5_mt = MethodType.methodType(int.class, MyValue1.class);\n@@ -73,1 +81,1 @@\n-            MethodType test6_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue3.class));\n+            MethodType test6_mt = MethodType.methodType(MyValue3.class);\n@@ -80,1 +88,1 @@\n-            MethodType myvalue2_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class));\n+            MethodType myvalue2_mt = MethodType.methodType(MyValue2.class);\n@@ -95,1 +103,1 @@\n-            MethodType test9_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue3.class));\n+            MethodType test9_mt = MethodType.methodType(MyValue3.class);\n@@ -106,1 +114,1 @@\n-            MethodType test10_mt = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class));\n+            MethodType test10_mt = MethodType.methodType(MyValue2.class);\n@@ -111,1 +119,1 @@\n-            MethodType test10_mt3 = MethodType.methodType(PrimitiveClass.asValueType(MyValue2.class));\n+            MethodType test10_mt3 = MethodType.methodType(MyValue2.class);\n@@ -152,0 +160,1 @@\n+    @NullRestricted\n@@ -178,0 +187,1 @@\n+    @NullRestricted\n@@ -179,0 +189,1 @@\n+\n@@ -204,0 +215,1 @@\n+    @NullRestricted\n@@ -205,0 +217,1 @@\n+\n@@ -235,0 +248,1 @@\n+    @NullRestricted\n@@ -236,0 +250,1 @@\n+\n@@ -259,0 +274,2 @@\n+\n+    @NullRestricted\n@@ -274,0 +291,1 @@\n+    @NullRestricted\n@@ -275,0 +293,1 @@\n+\n@@ -280,0 +299,1 @@\n+    @NullRestricted\n@@ -281,0 +301,1 @@\n+\n@@ -376,0 +397,1 @@\n+    @NullRestricted\n@@ -377,0 +399,1 @@\n+\n@@ -382,0 +405,1 @@\n+    @NullRestricted\n@@ -383,0 +407,1 @@\n+\n@@ -388,0 +413,1 @@\n+    @NullRestricted\n@@ -389,0 +415,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses TestMismatchHandling.jcod TestMismatchHandling.java\n+ * @compile TestMismatchHandling.jcod TestMismatchHandling.java\n@@ -32,1 +32,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -Xbatch\n@@ -37,1 +37,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -Xbatch\n@@ -42,1 +42,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -Xbatch\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -Xbatch\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -Xbatch\n@@ -56,1 +56,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -Xbatch\n@@ -60,1 +60,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+EnableValhalla -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMismatchHandling.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMismatchHandling.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMismatchHandlingGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Verify that the native clone intrinsic handles inline types.\n+ * @summary Verify that the native clone intrinsic handles value objects.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch -XX:-UseTypeProfile\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:-UseTypeProfile\n@@ -46,2 +46,2 @@\n-primitive class MyValue {\n-    public final int x;\n+value class MyValue {\n+    public int x;\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNativeClone.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -27,0 +28,6 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+\n@@ -32,2 +39,3 @@\n- * @compile -XDenablePrimitiveClasses TestNestmateAccess.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xcomp\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestNestmateAccess.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xcomp\n@@ -36,1 +44,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xcomp -XX:TieredStopAtLevel=1\n+ * @run main\/othervm -XX:+EnableValhalla -Xcomp -XX:TieredStopAtLevel=1\n@@ -39,0 +47,2 @@\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   compiler.valhalla.inlinetypes.TestNestmateAccess\n@@ -45,1 +55,3 @@\n-primitive class MyValue implements MyInterface {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue implements MyInterface {\n@@ -55,0 +67,1 @@\n+    @NullRestricted\n@@ -72,2 +85,5 @@\n-\/\/ Same as Test1 but outer class is an inline type\n-primitive class Test2 {\n+\/\/ Same as Test1 but outer class is a value class\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Test2 {\n+    @NullRestricted\n@@ -94,0 +110,1 @@\n+    @NullRestricted\n@@ -109,0 +126,1 @@\n+    @NullRestricted\n@@ -127,1 +145,4 @@\n-primitive class Test5 {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Test5 {\n+    @NullRestricted\n@@ -148,0 +169,1 @@\n+    @NullRestricted\n@@ -161,2 +183,5 @@\n-\/\/ Same as Test6 but outer class is an inline type\n-primitive class Test7 {\n+\/\/ Same as Test6 but outer class is a value class\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class Test7 {\n+    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNestmateAccess.java","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n- * @summary Verifies correctness of the new acmp bytecode.\n- * @modules java.base\/jdk.internal.value\n+ * @summary Verifies correctness of the acmp bytecode with value object operands.\n@@ -29,1 +28,1 @@\n- * @compile -XDenablePrimitiveClasses TestNewAcmp.java\n+ * @compile TestNewAcmp.java\n@@ -31,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla\n@@ -54,2 +53,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n@@ -65,2 +62,2 @@\n-primitive class MyValue1 extends MyAbstract {\n-    final int x;\n+value class MyValue1 extends MyAbstract {\n+    int x;\n@@ -73,1 +70,1 @@\n-        return MyValue1.default;\n+        return new MyValue1(0);\n@@ -81,2 +78,2 @@\n-primitive class MyValue2 extends MyAbstract {\n-    final int x;\n+value class MyValue2 extends MyAbstract {\n+    int x;\n@@ -89,1 +86,1 @@\n-        return MyValue2.default;\n+        return new MyValue2(0);\n@@ -1741,1 +1738,1 @@\n-            if (args[i] == null && parameterTypes[0] == PrimitiveClass.asValueType(MyValue1.class)) {\n+            if (args[i] == null && parameterTypes[0] == MyValue1.class) {\n@@ -1763,1 +1760,1 @@\n-                    if (args[j] == null && parameterTypes[1] == PrimitiveClass.asValueType(MyValue1.class)) {\n+                    if (args[j] == null && parameterTypes[1] == MyValue1.class) {\n@@ -1875,1 +1872,0 @@\n-            \"-XX:+EnablePrimitiveClasses\",\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNewAcmp.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -39,1 +44,1 @@\n- * @summary Test nullable inline type arrays\n+ * @summary Test nullable value class arrays.\n@@ -42,2 +47,4 @@\n- * @compile -XDenablePrimitiveClasses TestNullableArrays.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestNullableArrays\n+ * @modules java.base\/jdk.internal.value\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestNullableArrays.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestNullableArrays\n@@ -82,1 +89,1 @@\n-    \/\/ Test nullable inline type array creation and initialization\n+    \/\/ Test nullable value class array creation and initialization\n@@ -89,2 +96,2 @@\n-    public MyValue1.ref[] test1(int len) {\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+    public MyValue1[] test1(int len) {\n+        MyValue1[] va = new MyValue1[len];\n@@ -103,1 +110,1 @@\n-        MyValue1.ref[] va = test1(len);\n+        MyValue1[] va = test1(len);\n@@ -112,1 +119,1 @@\n-    \/\/ Test creation of an inline type array and element access\n+    \/\/ Test creation of a value class array and element access\n@@ -116,1 +123,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[1];\n+        MyValue1[] va = new MyValue1[1];\n@@ -127,1 +134,1 @@\n-    \/\/ Test receiving an inline type array from the interpreter,\n+    \/\/ Test receiving a value class array from the interpreter,\n@@ -131,1 +138,1 @@\n-    public long test3(MyValue1.ref[] va) {\n+    public long test3(MyValue1[] va) {\n@@ -145,1 +152,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[10];\n+        MyValue1[] va = new MyValue1[10];\n@@ -161,1 +168,1 @@\n-    \/\/ Test returning an inline type array received from the interpreter\n+    \/\/ Test returning a value class array received from the interpreter\n@@ -164,1 +171,1 @@\n-    public MyValue1.ref[] test4(MyValue1.ref[] va) {\n+    public MyValue1[] test4(MyValue1[] va) {\n@@ -170,1 +177,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[10];\n+        MyValue1[] va = new MyValue1[10];\n@@ -180,1 +187,1 @@\n-    \/\/ Merge inline type arrays created from two branches\n+    \/\/ Merge value class arrays created from two branches\n@@ -182,2 +189,2 @@\n-    public MyValue1.ref[] test5(boolean b) {\n-        MyValue1.ref[] va;\n+    public MyValue1[] test5(boolean b) {\n+        MyValue1[] va;\n@@ -185,1 +192,1 @@\n-            va = new MyValue1.ref[5];\n+            va = new MyValue1[5];\n@@ -191,1 +198,1 @@\n-            va = new MyValue1.ref[10];\n+            va = new MyValue1[10];\n@@ -208,1 +215,1 @@\n-        MyValue1.ref[] va = test5(true);\n+        MyValue1[] va = test5(true);\n@@ -224,1 +231,1 @@\n-    \/\/ Test creation of inline type array with single element\n+    \/\/ Test creation of value class array with single element\n@@ -227,2 +234,2 @@\n-    public MyValue1.ref test6() {\n-        MyValue1.ref[] va = new MyValue1.ref[1];\n+    public MyValue1 test6() {\n+        MyValue1[] va = new MyValue1[1];\n@@ -234,2 +241,2 @@\n-        MyValue1.ref[] va = new MyValue1.ref[1];\n-        MyValue1.ref v = test6();\n+        MyValue1[] va = new MyValue1[1];\n+        MyValue1 v = test6();\n@@ -239,1 +246,1 @@\n-    \/\/ Test default initialization of inline type arrays\n+    \/\/ Test default initialization of value class arrays\n@@ -242,2 +249,2 @@\n-    public MyValue1.ref[] test7(int len) {\n-        return new MyValue1.ref[len];\n+    public MyValue1[] test7(int len) {\n+        return new MyValue1[len];\n@@ -249,1 +256,1 @@\n-        MyValue1.ref[] va = test7(len);\n+        MyValue1[] va = test7(len);\n@@ -256,1 +263,1 @@\n-    \/\/ Test creation of inline type array with zero length\n+    \/\/ Test creation of value class array with zero length\n@@ -259,2 +266,2 @@\n-    public MyValue1.ref[] test8() {\n-        return new MyValue1.ref[0];\n+    public MyValue1[] test8() {\n+        return new MyValue1[0];\n@@ -265,1 +272,1 @@\n-        MyValue1.ref[] va = test8();\n+        MyValue1[] va = test8();\n@@ -269,1 +276,1 @@\n-    static MyValue1.ref[] test9_va;\n+    static MyValue1[] test9_va;\n@@ -271,1 +278,1 @@\n-    \/\/ Test that inline type array loaded from field has correct type\n+    \/\/ Test that value class array loaded from field has correct type\n@@ -280,1 +287,1 @@\n-        test9_va = new MyValue1.ref[1];\n+        test9_va = new MyValue1[1];\n@@ -288,2 +295,2 @@\n-    public MyValue1.ref[][][] test10(int len1, int len2, int len3) {\n-        MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];\n+    public MyValue1[][][] test10(int len1, int len2, int len3) {\n+        MyValue1[][][] arr = new MyValue1[len1][len2][len3];\n@@ -305,1 +312,1 @@\n-        MyValue1.ref[][][] arr = test10(2, 3, 4);\n+        MyValue1[][][] arr = test10(2, 3, 4);\n@@ -321,1 +328,1 @@\n-    public void test11(MyValue1.ref[][][] arr, long[] res) {\n+    public void test11(MyValue1[][][] arr, long[] res) {\n@@ -338,1 +345,1 @@\n-        MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];\n+        MyValue1[][][] arr = new MyValue1[2][3][4];\n@@ -363,1 +370,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+        MyValue1[] va = new MyValue1[arraySize];\n@@ -385,1 +392,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+        MyValue1[] va = new MyValue1[arraySize];\n@@ -405,1 +412,1 @@\n-    public int test14(MyValue1.ref[] va, int index)  {\n+    public int test14(MyValue1[] va, int index)  {\n@@ -412,1 +419,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+        MyValue1[] va = new MyValue1[arraySize];\n@@ -433,1 +440,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+        MyValue1[] va = new MyValue1[arraySize];\n@@ -454,1 +461,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+        MyValue1[] va = new MyValue1[arraySize];\n@@ -473,1 +480,1 @@\n-    public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {\n+    public int test17(MyValue1[] va, int index, MyValue1 vt)  {\n@@ -481,1 +488,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[arraySize];\n+        MyValue1[] va = new MyValue1[arraySize];\n@@ -505,1 +512,1 @@\n-    public MyValue1.ref[] test18(MyValue1.ref[] va) {\n+    public MyValue1[] test18(MyValue1[] va) {\n@@ -512,2 +519,2 @@\n-        MyValue1.ref[] va1 = new MyValue1.ref[len];\n-        MyValue1[]  va2 = new MyValue1[len];\n+        MyValue1[] va1 = new MyValue1[len];\n+        MyValue1[]  va2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -518,1 +525,1 @@\n-        MyValue1.ref[] result1 = test18(va1);\n+        MyValue1[] result1 = test18(va1);\n@@ -528,1 +535,1 @@\n-            MyValue1.ref[] result2 = test18(va2);\n+            MyValue1[] result2 = test18(va2);\n@@ -535,1 +542,1 @@\n-            MyValue1.ref[] result2 = test18(va2);\n+            MyValue1[] result2 = test18(va2);\n@@ -543,1 +550,1 @@\n-    static MyValue1.ref[] test19_orig = null;\n+    static MyValue1[] test19_orig = null;\n@@ -546,2 +553,2 @@\n-    public MyValue1.ref[] test19() {\n-        MyValue1.ref[] va = new MyValue1.ref[8];\n+    public MyValue1[] test19() {\n+        MyValue1[] va = new MyValue1[8];\n@@ -558,1 +565,1 @@\n-        MyValue1.ref[] result = test19();\n+        MyValue1[] result = test19();\n@@ -565,1 +572,1 @@\n-    \/\/ arraycopy() of inline type array with oop fields\n+    \/\/ arraycopy() of value class array with oop fields\n@@ -567,1 +574,1 @@\n-    public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+    public void test20(MyValue1[] src, MyValue1[] dst) {\n@@ -574,8 +581,8 @@\n-        MyValue1.ref[] src1 = new MyValue1.ref[len];\n-        MyValue1.ref[] src2 = new MyValue1.ref[len];\n-        MyValue1[]  src3 = new MyValue1[len];\n-        MyValue1[]  src4 = new MyValue1[len];\n-        MyValue1.ref[] dst1 = new MyValue1.ref[len];\n-        MyValue1[]  dst2 = new MyValue1[len];\n-        MyValue1.ref[] dst3 = new MyValue1.ref[len];\n-        MyValue1[]  dst4 = new MyValue1[len];\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[] src2 = new MyValue1[len];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] dst1 = new MyValue1[len];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] dst3 = new MyValue1[len];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -609,1 +616,1 @@\n-    \/\/ arraycopy() of inline type array with no oop field\n+    \/\/ arraycopy() of value class array with no oop field\n@@ -611,1 +618,1 @@\n-    public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {\n+    public void test21(MyValue2[] src, MyValue2[] dst) {\n@@ -618,8 +625,8 @@\n-        MyValue2.ref[] src1 = new MyValue2.ref[len];\n-        MyValue2.ref[] src2 = new MyValue2.ref[len];\n-        MyValue2[]  src3 = new MyValue2[len];\n-        MyValue2[]  src4 = new MyValue2[len];\n-        MyValue2.ref[] dst1 = new MyValue2.ref[len];\n-        MyValue2[]  dst2 = new MyValue2[len];\n-        MyValue2.ref[] dst3 = new MyValue2.ref[len];\n-        MyValue2[]  dst4 = new MyValue2[len];\n+        MyValue2[] src1 = new MyValue2[len];\n+        MyValue2[] src2 = new MyValue2[len];\n+        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst1 = new MyValue2[len];\n+        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst3 = new MyValue2[len];\n+        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n@@ -653,1 +660,1 @@\n-    \/\/ arraycopy() of inline type array with oop field and tightly\n+    \/\/ arraycopy() of value class array with oop field and tightly\n@@ -656,2 +663,2 @@\n-    public MyValue1.ref[] test22(MyValue1.ref[] src) {\n-        MyValue1.ref[] dst = new MyValue1.ref[src.length];\n+    public MyValue1[] test22(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[src.length];\n@@ -665,2 +672,2 @@\n-        MyValue1.ref[] src1 = new MyValue1.ref[len];\n-        MyValue1[]  src2 = new MyValue1[len];\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[]  src2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -671,2 +678,2 @@\n-        MyValue1.ref[] dst1 = test22(src1);\n-        MyValue1.ref[] dst2 = test22(src2);\n+        MyValue1[] dst1 = test22(src1);\n+        MyValue1[] dst2 = test22(src2);\n@@ -675,1 +682,1 @@\n-            Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());\n+            Asserts.assertEQ(dst2[0].hash(), MyValue1.createDefaultInline().hash());\n@@ -683,1 +690,1 @@\n-    \/\/ arraycopy() of inline type array with oop fields and tightly\n+    \/\/ arraycopy() of value class array with oop fields and tightly\n@@ -686,2 +693,2 @@\n-    public MyValue1.ref[] test23(MyValue1.ref[] src) {\n-        MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];\n+    public MyValue1[] test23(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[src.length + 10];\n@@ -695,2 +702,2 @@\n-        MyValue1.ref[] src1 = new MyValue1.ref[len];\n-        MyValue1[] src2 = new MyValue1[len];\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[] src2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -701,2 +708,2 @@\n-        MyValue1.ref[] dst1 = test23(src1);\n-        MyValue1.ref[] dst2 = test23(src2);\n+        MyValue1[] dst1 = test23(src1);\n+        MyValue1[] dst2 = test23(src2);\n@@ -713,1 +720,1 @@\n-    \/\/ arraycopy() of inline type array passed as Object\n+    \/\/ arraycopy() of value class array passed as Object\n@@ -715,1 +722,1 @@\n-    public void test24(MyValue1.ref[] src, Object dst) {\n+    public void test24(MyValue1[] src, Object dst) {\n@@ -722,8 +729,8 @@\n-        MyValue1.ref[] src1 = new MyValue1.ref[len];\n-        MyValue1.ref[] src2 = new MyValue1.ref[len];\n-        MyValue1[]  src3 = new MyValue1[len];\n-        MyValue1[]  src4 = new MyValue1[len];\n-        MyValue1.ref[] dst1 = new MyValue1.ref[len];\n-        MyValue1[]  dst2 = new MyValue1[len];\n-        MyValue1.ref[] dst3 = new MyValue1.ref[len];\n-        MyValue1[]  dst4 = new MyValue1[len];\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[] src2 = new MyValue1[len];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] dst1 = new MyValue1[len];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] dst3 = new MyValue1[len];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -759,1 +766,1 @@\n-    public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {\n+    public void test25(MyValue2[] src, MyValue2[] dst) {\n@@ -765,8 +772,8 @@\n-        MyValue2.ref[] src1 = new MyValue2.ref[8];\n-        MyValue2.ref[] src2 = new MyValue2.ref[8];\n-        MyValue2[]  src3 = new MyValue2[8];\n-        MyValue2[]  src4 = new MyValue2[8];\n-        MyValue2.ref[] dst1 = new MyValue2.ref[8];\n-        MyValue2[]  dst2 = new MyValue2[8];\n-        MyValue2.ref[] dst3 = new MyValue2.ref[8];\n-        MyValue2[]  dst4 = new MyValue2[8];\n+        MyValue2[] src1 = new MyValue2[8];\n+        MyValue2[] src2 = new MyValue2[8];\n+        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] dst1 = new MyValue2[8];\n+        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] dst3 = new MyValue2[8];\n+        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n@@ -798,1 +805,1 @@\n-    public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+    public void test26(MyValue1[] src, MyValue1[] dst) {\n@@ -804,8 +811,8 @@\n-        MyValue1.ref[] src1 = new MyValue1.ref[8];\n-        MyValue1.ref[] src2 = new MyValue1.ref[8];\n-        MyValue1[]  src3 = new MyValue1[8];\n-        MyValue1[]  src4 = new MyValue1[8];\n-        MyValue1.ref[] dst1 = new MyValue1.ref[8];\n-        MyValue1[]  dst2 = new MyValue1[8];\n-        MyValue1.ref[] dst3 = new MyValue1.ref[8];\n-        MyValue1[]  dst4 = new MyValue1[8];\n+        MyValue1[] src1 = new MyValue1[8];\n+        MyValue1[] src2 = new MyValue1[8];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] dst1 = new MyValue1[8];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] dst3 = new MyValue1[8];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -837,1 +844,1 @@\n-    public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+    public void test27(MyValue1[] src, MyValue1[] dst) {\n@@ -843,8 +850,8 @@\n-        MyValue1.ref[] src1 = new MyValue1.ref[8];\n-        MyValue1.ref[] src2 = new MyValue1.ref[8];\n-        MyValue1[]  src3 = new MyValue1[8];\n-        MyValue1[]  src4 = new MyValue1[8];\n-        MyValue1.ref[] dst1 = new MyValue1.ref[8];\n-        MyValue1[]  dst2 = new MyValue1[8];\n-        MyValue1.ref[] dst3 = new MyValue1.ref[8];\n-        MyValue1[]  dst4 = new MyValue1[8];\n+        MyValue1[] src1 = new MyValue1[8];\n+        MyValue1[] src2 = new MyValue1[8];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] dst1 = new MyValue1[8];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] dst3 = new MyValue1[8];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -863,1 +870,1 @@\n-            Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());\n+            Asserts.assertEQ(dst2[i].hash(), MyValue1.createDefaultInline().hash());\n@@ -865,1 +872,1 @@\n-            Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());\n+            Asserts.assertEQ(dst4[i].hash(), MyValue1.createDefaultInline().hash());\n@@ -880,2 +887,2 @@\n-    public MyValue2.ref test28() {\n-        MyValue2.ref[] src = new MyValue2.ref[10];\n+    public MyValue2 test28() {\n+        MyValue2[] src = new MyValue2[10];\n@@ -883,1 +890,1 @@\n-        MyValue2.ref[] dst = (MyValue2.ref[])src.clone();\n+        MyValue2[] dst = (MyValue2[])src.clone();\n@@ -890,1 +897,1 @@\n-        MyValue2.ref result = test28();\n+        MyValue2 result = test28();\n@@ -897,3 +904,4 @@\n-    @IR(failOn = {ALLOCA, LOOP, TRAP})\n-    public MyValue2.ref test29(MyValue2.ref[] src) {\n-        MyValue2.ref[] dst = new MyValue2.ref[10];\n+    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n+    \/\/@IR(failOn = {ALLOCA, LOOP, TRAP})\n+    public MyValue2 test29(MyValue2[] src) {\n+        MyValue2[] dst = new MyValue2[10];\n@@ -906,2 +914,2 @@\n-        MyValue2.ref[] src1 = new MyValue2.ref[10];\n-        MyValue2.val[] src2 = new MyValue2.val[10];\n+        MyValue2[] src1 = new MyValue2[10];\n+        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -912,1 +920,1 @@\n-        MyValue2.ref v = test29(src1);\n+        MyValue2 v = test29(src1);\n@@ -921,1 +929,1 @@\n-    \/\/ eliminated inline type array element as debug info\n+    \/\/ eliminated value class array element as debug info\n@@ -923,2 +931,2 @@\n-    public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {\n-        MyValue2.ref[] dst = new MyValue2.ref[10];\n+    public MyValue2 test30(MyValue2[] src, boolean flag) {\n+        MyValue2[] dst = new MyValue2[10];\n@@ -933,2 +941,2 @@\n-        MyValue2.ref[] src1 = new MyValue2.ref[10];\n-        MyValue2.val[] src2 = new MyValue2.val[10];\n+        MyValue2[] src1 = new MyValue2[10];\n+        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n@@ -939,1 +947,1 @@\n-        MyValue2.ref v = test30(src1, !info.isWarmUp());\n+        MyValue2 v = test30(src1, !info.isWarmUp());\n@@ -952,1 +960,1 @@\n-        MyValue2.ref[] src = new MyValue2.ref[1];\n+        MyValue2[] src = new MyValue2[1];\n@@ -985,2 +993,2 @@\n-        MyValue1.ref[] va1 = new MyValue1.ref[len];\n-        MyValue1[] va2 = new MyValue1[len];\n+        MyValue1[] va1 = new MyValue1[len];\n+        MyValue1[] va2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -991,2 +999,2 @@\n-        MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);\n-        MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);\n+        MyValue1[] result1 = (MyValue1[])test32(va1);\n+        MyValue1[] result2 = (MyValue1[])test32(va2);\n@@ -995,1 +1003,1 @@\n-            Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());\n+            Asserts.assertEQ(result2[0].hash(), MyValue1.createDefaultInline().hash());\n@@ -1028,1 +1036,1 @@\n-            va = new MyValue1.ref[8];\n+            va = new MyValue1[8];\n@@ -1068,1 +1076,1 @@\n-    static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+    static void verify(MyValue1[] src, MyValue1[] dst) {\n@@ -1078,1 +1086,1 @@\n-    static void verify(MyValue1.ref[] src, Object[] dst) {\n+    static void verify(MyValue1[] src, Object[] dst) {\n@@ -1088,1 +1096,1 @@\n-    static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {\n+    static void verify(MyValue2[] src, MyValue2[] dst) {\n@@ -1098,1 +1106,1 @@\n-    static void verify(MyValue2.ref[] src, Object[] dst) {\n+    static void verify(MyValue2[] src, Object[] dst) {\n@@ -1118,1 +1126,1 @@\n-    \/\/ arraycopy() of inline type array of unknown size\n+    \/\/ arraycopy() of value class array of unknown size\n@@ -1127,2 +1135,2 @@\n-        MyValue1.ref[] src = new MyValue1.ref[len];\n-        MyValue1.ref[] dst = new MyValue1.ref[len];\n+        MyValue1[] src = new MyValue1[len];\n+        MyValue1[] dst = new MyValue1[len];\n@@ -1141,1 +1149,1 @@\n-    public void test36(Object src, MyValue2.ref[] dst) {\n+    public void test36(Object src, MyValue2[] dst) {\n@@ -1148,2 +1156,2 @@\n-        MyValue2.ref[] src = new MyValue2.ref[len];\n-        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n@@ -1162,1 +1170,1 @@\n-    public void test37(MyValue2.ref[] src, Object dst) {\n+    public void test37(MyValue2[] src, Object dst) {\n@@ -1169,2 +1177,2 @@\n-        MyValue2.ref[] src = new MyValue2.ref[len];\n-        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n@@ -1183,1 +1191,1 @@\n-    public void test38(Object src, MyValue2.ref[] dst) {\n+    public void test38(Object src, MyValue2[] dst) {\n@@ -1192,1 +1200,1 @@\n-        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        MyValue2[] dst = new MyValue2[len];\n@@ -1209,1 +1217,1 @@\n-    public void test39(MyValue2.ref[] src, Object dst) {\n+    public void test39(MyValue2[] src, Object dst) {\n@@ -1216,1 +1224,1 @@\n-        MyValue2.ref[] src = new MyValue2.ref[len];\n+        MyValue2[] src = new MyValue2[len];\n@@ -1239,1 +1247,1 @@\n-        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        MyValue2[] dst = new MyValue2[len];\n@@ -1263,1 +1271,1 @@\n-        MyValue2.ref[] src = new MyValue2.ref[len];\n+        MyValue2[] src = new MyValue2[len];\n@@ -1305,2 +1313,2 @@\n-        MyValue1.ref[] src = new MyValue1.ref[8];\n-        MyValue1.ref[] dst = new MyValue1.ref[8];\n+        MyValue1[] src = new MyValue1[8];\n+        MyValue1[] dst = new MyValue1[8];\n@@ -1319,1 +1327,1 @@\n-    public void test44(Object src, MyValue2.ref[] dst) {\n+    public void test44(Object src, MyValue2[] dst) {\n@@ -1325,2 +1333,2 @@\n-        MyValue2.ref[] src = new MyValue2.ref[8];\n-        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] dst = new MyValue2[8];\n@@ -1339,1 +1347,1 @@\n-    public void test45(MyValue2.ref[] src, Object dst) {\n+    public void test45(MyValue2[] src, Object dst) {\n@@ -1345,2 +1353,2 @@\n-        MyValue2.ref[] src = new MyValue2.ref[8];\n-        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] dst = new MyValue2[8];\n@@ -1359,1 +1367,1 @@\n-    public void test46(Object[] src, MyValue2.ref[] dst) {\n+    public void test46(Object[] src, MyValue2[] dst) {\n@@ -1367,1 +1375,1 @@\n-        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        MyValue2[] dst = new MyValue2[8];\n@@ -1384,1 +1392,1 @@\n-    public void test47(MyValue2.ref[] src, Object[] dst) {\n+    public void test47(MyValue2[] src, Object[] dst) {\n@@ -1390,1 +1398,1 @@\n-        MyValue2.ref[] src = new MyValue2.ref[8];\n+        MyValue2[] src = new MyValue2[8];\n@@ -1412,1 +1420,1 @@\n-        MyValue2.ref[] dst = new MyValue2.ref[8];\n+        MyValue2[] dst = new MyValue2[8];\n@@ -1435,1 +1443,1 @@\n-        MyValue2.ref[] src = new MyValue2.ref[8];\n+        MyValue2[] src = new MyValue2[8];\n@@ -1469,2 +1477,2 @@\n-    public MyValue1.ref[] test51(MyValue1.ref[] va) {\n-        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);\n+    public MyValue1[] test51(MyValue1[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1[].class);\n@@ -1476,1 +1484,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n@@ -1480,1 +1488,1 @@\n-        MyValue1.ref[] result = test51(va);\n+        MyValue1[] result = test51(va);\n@@ -1484,1 +1492,1 @@\n-    static final MyValue1.ref[] test52_va = new MyValue1.ref[8];\n+    static final MyValue1[] test52_va = new MyValue1[8];\n@@ -1487,2 +1495,2 @@\n-    public MyValue1.ref[] test52() {\n-        return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);\n+    public MyValue1[] test52() {\n+        return Arrays.copyOf(test52_va, 8, MyValue1[].class);\n@@ -1496,1 +1504,1 @@\n-        MyValue1.ref[] result = test52();\n+        MyValue1[] result = test52();\n@@ -1501,2 +1509,2 @@\n-    public MyValue1.ref[] test53(Object[] va) {\n-        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);\n+    public MyValue1[] test53(Object[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1[].class);\n@@ -1508,1 +1516,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n@@ -1512,1 +1520,1 @@\n-        MyValue1.ref[] result = test53(va);\n+        MyValue1[] result = test53(va);\n@@ -1517,1 +1525,1 @@\n-    public Object[] test54(MyValue1.ref[] va) {\n+    public Object[] test54(MyValue1[] va) {\n@@ -1524,1 +1532,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n@@ -1540,1 +1548,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n@@ -1549,2 +1557,2 @@\n-    public MyValue1.ref[] test56(Object[] va) {\n-        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);\n+    public MyValue1[] test56(Object[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1[].class);\n@@ -1560,1 +1568,1 @@\n-        MyValue1.ref[] result = test56(va);\n+        MyValue1[] result = test56(va);\n@@ -1572,1 +1580,1 @@\n-        Object[] va = new MyValue1.ref[len];\n+        Object[] va = new MyValue1[len];\n@@ -1576,1 +1584,1 @@\n-        Object[] result = test57(va, MyValue1.ref[].class);\n+        Object[] result = test57(va, MyValue1[].class);\n@@ -1581,1 +1589,1 @@\n-    public Object[] test58(MyValue1.ref[] va, Class klass) {\n+    public Object[] test58(MyValue1[] va, Class klass) {\n@@ -1588,1 +1596,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n@@ -1593,1 +1601,1 @@\n-            Object[] result = test58(va, MyValue1.ref[].class);\n+            Object[] result = test58(va, MyValue1[].class);\n@@ -1597,1 +1605,1 @@\n-            Object[] result = test58(va, MyValue1.ref[].class);\n+            Object[] result = test58(va, MyValue1[].class);\n@@ -1603,2 +1611,2 @@\n-    public Object[] test59(MyValue1.ref[] va) {\n-        return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);\n+    public Object[] test59(MyValue1[] va) {\n+        return Arrays.copyOf(va, va.length+1, MyValue1[].class);\n@@ -1610,2 +1618,2 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n-        MyValue1.ref[] verif = new MyValue1.ref[len+1];\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n@@ -1628,2 +1636,2 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n-        MyValue1.ref[] verif = new MyValue1.ref[len+1];\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n@@ -1634,1 +1642,1 @@\n-        Object[] result = test60(va, MyValue1.ref[].class);\n+        Object[] result = test60(va, MyValue1[].class);\n@@ -1657,1 +1665,1 @@\n-    public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test62_helper(int i, MyValue1[] va, Integer[] oa) {\n@@ -1668,1 +1676,1 @@\n-    public Object[] test62(MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test62(MyValue1[] va, Integer[] oa) {\n@@ -1680,1 +1688,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n@@ -1693,1 +1701,1 @@\n-    public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test63_helper(int i, MyValue1[] va, Integer[] oa) {\n@@ -1704,1 +1712,1 @@\n-    public Object[] test63(MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test63(MyValue1[] va, Integer[] oa) {\n@@ -1716,2 +1724,2 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n-        MyValue1.ref[] verif = new MyValue1.ref[len+1];\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n@@ -1728,1 +1736,1 @@\n-    \/\/ Test default initialization of inline type arrays: small array\n+    \/\/ Test default initialization of value class arrays: small array\n@@ -1730,2 +1738,2 @@\n-    public MyValue1.ref[] test64() {\n-        return new MyValue1.ref[8];\n+    public MyValue1[] test64() {\n+        return new MyValue1[8];\n@@ -1736,1 +1744,1 @@\n-        MyValue1.ref[] va = test64();\n+        MyValue1[] va = test64();\n@@ -1742,1 +1750,1 @@\n-    \/\/ Test default initialization of inline type arrays: large array\n+    \/\/ Test default initialization of value class arrays: large array\n@@ -1744,2 +1752,2 @@\n-    public MyValue1.ref[] test65() {\n-        return new MyValue1.ref[32];\n+    public MyValue1[] test65() {\n+        return new MyValue1[32];\n@@ -1750,1 +1758,1 @@\n-        MyValue1.ref[] va = test65();\n+        MyValue1[] va = test65();\n@@ -1759,2 +1767,2 @@\n-    public MyValue1.ref[] test66(MyValue1.ref vt) {\n-        MyValue1.ref[] va = new MyValue1.ref[1];\n+    public MyValue1[] test66(MyValue1 vt) {\n+        MyValue1[] va = new MyValue1[1];\n@@ -1767,2 +1775,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);\n-        MyValue1.ref[] va = test66(vt);\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1[] va = test66(vt);\n@@ -1774,2 +1782,2 @@\n-    public MyValue1.ref[] test67(MyValue1.ref[] src) {\n-        MyValue1.ref[] dst = new MyValue1.ref[16];\n+    public MyValue1[] test67(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[16];\n@@ -1782,2 +1790,2 @@\n-        MyValue1.ref[] va = new MyValue1.ref[16];\n-        MyValue1.ref[] var = test67(va);\n+        MyValue1[] va = new MyValue1[16];\n+        MyValue1[] var = test67(va);\n@@ -1791,2 +1799,2 @@\n-    public MyValue1.ref[] test68() {\n-        MyValue1.ref[] va = new MyValue1.ref[2];\n+    public MyValue1[] test68() {\n+        MyValue1[] va = new MyValue1[2];\n@@ -1799,1 +1807,1 @@\n-        MyValue1.ref[] va = test68();\n+        MyValue1[] va = test68();\n@@ -1807,2 +1815,2 @@\n-    public MyValue1.ref[] test69(MyValue1.ref vt) {\n-        MyValue1.ref[] va = new MyValue1.ref[4];\n+    public MyValue1[] test69(MyValue1 vt) {\n+        MyValue1[] va = new MyValue1[4];\n@@ -1816,2 +1824,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);\n-        MyValue1.ref[] va = new MyValue1.ref[4];\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1[] va = new MyValue1[4];\n@@ -1820,1 +1828,1 @@\n-        MyValue1.ref[] var = test69(vt);\n+        MyValue1[] var = test69(vt);\n@@ -1829,1 +1837,1 @@\n-    public MyValue1.ref[] test70(MyValue1.ref[] other) {\n+    public MyValue1[] test70(MyValue1[] other) {\n@@ -1831,1 +1839,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[2];\n+        MyValue1[] va = new MyValue1[2];\n@@ -1839,2 +1847,2 @@\n-        MyValue1.ref[] va = new MyValue1.ref[2];\n-        MyValue1.ref[] var = test70(va);\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] var = test70(va);\n@@ -1850,2 +1858,2 @@\n-        MyValue2.ref[] src = new MyValue2.ref[len];\n-        MyValue2.ref[] dst = new MyValue2.ref[len];\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n@@ -1891,1 +1899,1 @@\n-    public void test73(Object[] oa, MyValue1.ref v, Object o) {\n+    public void test73(Object[] oa, MyValue1 v, Object o) {\n@@ -1903,3 +1911,3 @@\n-        MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);\n-        MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);\n-        MyValue1.ref[] arr = new MyValue1.ref[3];\n+        MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);\n+        MyValue1[] arr = new MyValue1[3];\n@@ -1919,1 +1927,1 @@\n-    public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test74_helper(int i, MyValue1[] va, Integer[] oa) {\n@@ -1930,1 +1938,1 @@\n-    public Object[] test74(MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test74(MyValue1[] va, Integer[] oa) {\n@@ -1941,1 +1949,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n@@ -1957,1 +1965,1 @@\n-    public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test75_helper(int i, MyValue1[] va, Integer[] oa) {\n@@ -1968,1 +1976,1 @@\n-    public Object[] test75(MyValue1.ref[] va, Integer[] oa) {\n+    public Object[] test75(MyValue1[] va, Integer[] oa) {\n@@ -1979,2 +1987,2 @@\n-        MyValue1.ref[] va = new MyValue1.ref[len];\n-        MyValue1.ref[] verif = new MyValue1.ref[len];\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len];\n@@ -1997,1 +2005,1 @@\n-    public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {\n+    public Object[] test76(MyValue1[] vva, MyValue1[] vba, MyValue1 vt, Object[] out, int n) {\n@@ -2004,1 +2012,1 @@\n-            result = new MyValue1[42];\n+            result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -2006,1 +2014,1 @@\n-            result = new MyValue1.ref[42];\n+            result = new MyValue1[42];\n@@ -2017,2 +2025,2 @@\n-        MyValue1[] vva = new MyValue1[42];\n-        MyValue1[] vva_r = new MyValue1[42];\n+        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -2020,2 +2028,2 @@\n-        MyValue1.ref[] vba = new MyValue1.ref[42];\n-        MyValue1.ref[] vba_r = new MyValue1.ref[42];\n+        MyValue1[] vba = new MyValue1[42];\n+        MyValue1[] vba_r = new MyValue1[42];\n@@ -2041,1 +2049,1 @@\n-            va = new MyValue1.ref[5];\n+            va = new MyValue1[5];\n@@ -2046,1 +2054,1 @@\n-            va = new MyValue1[10];\n+            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n@@ -2076,1 +2084,1 @@\n-    \/\/ Same as test76 but with non inline type array cases\n+    \/\/ Same as test76 but with non value class array cases\n@@ -2078,1 +2086,1 @@\n-    public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {\n+    public Object[] test78(MyValue1[] vva, MyValue1[] vba, Object val, Object[] out, int n) {\n@@ -2085,1 +2093,1 @@\n-            result = new MyValue1[42];\n+            result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -2087,1 +2095,1 @@\n-            result = new MyValue1.ref[42];\n+            result = new MyValue1[42];\n@@ -2101,2 +2109,2 @@\n-        MyValue1[] vva = new MyValue1[42];\n-        MyValue1[] vva_r = new MyValue1[42];\n+        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -2104,2 +2112,2 @@\n-        MyValue1.ref[] vba = new MyValue1.ref[42];\n-        MyValue1.ref[] vba_r = new MyValue1.ref[42];\n+        MyValue1[] vba = new MyValue1[42];\n+        MyValue1[] vba_r = new MyValue1[42];\n@@ -2127,1 +2135,1 @@\n-    public static MyValue1.ref[] test79(MyValue1[] va) {\n+    public static MyValue1[] test79(MyValue1[] va) {\n@@ -2133,1 +2141,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2135,1 +2143,1 @@\n-        MyValue1.ref[] res = test79(va);\n+        MyValue1[] res = test79(va);\n@@ -2151,1 +2159,1 @@\n-        return (MyValue1.ref[])va;\n+        return (MyValue1[])va;\n@@ -2156,1 +2164,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2172,2 +2180,2 @@\n-    public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {\n-        MyValue1.ref[] result = b ? va1 : va2;\n+    public static long test81(MyValue1[] va1, MyValue1[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {\n+        MyValue1[] result = b ? va1 : va2;\n@@ -2184,2 +2192,2 @@\n-        MyValue1[] va = new MyValue1[2];\n-        MyValue1.ref[] vaB = new MyValue1.ref[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vaB = new MyValue1[2];\n@@ -2201,2 +2209,2 @@\n-    public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {\n-        MyValue1.ref[] result = null;\n+    public static long test82(MyValue1[] va1, MyValue1[] va2, MyValue1 vt1, MyValue1 vt2, int i, boolean shouldThrow) {\n+        MyValue1[] result = null;\n@@ -2208,1 +2216,1 @@\n-            result = new MyValue1.ref[2];\n+            result = new MyValue1[2];\n@@ -2211,1 +2219,1 @@\n-            result = new MyValue1[2];\n+            result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -2228,2 +2236,2 @@\n-        MyValue1[] va = new MyValue1[2];\n-        MyValue1.ref[] vaB = new MyValue1.ref[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vaB = new MyValue1[2];\n@@ -2252,1 +2260,1 @@\n-        MyValue1.ref[] result = va;\n+        MyValue1[] result = va;\n@@ -2258,1 +2266,1 @@\n-        MyValue1[] va = new MyValue1[42];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n@@ -2267,2 +2275,2 @@\n-    public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {\n-        MyValue1.ref[] result = new MyValue1[2];\n+    public static MyValue1[] test84(MyValue1 vt1, MyValue1 vt2) {\n+        MyValue1[] result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -2276,1 +2284,1 @@\n-        MyValue1.ref[] res = test84(testValue1, testValue1);\n+        MyValue1[] res = test84(testValue1, testValue1);\n@@ -2288,1 +2296,1 @@\n-    public static long test85(MyValue1.ref[] va, MyValue1 val) {\n+    public static long test85(MyValue1[] va, MyValue1 val) {\n@@ -2295,2 +2303,2 @@\n-        MyValue1[] va = new MyValue1[2];\n-        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vab = new MyValue1[2];\n@@ -2309,1 +2317,1 @@\n-    public static long test86(MyValue1.ref[] va, MyValue1.ref val) {\n+    public static long test86(MyValue1[] va, MyValue1 val) {\n@@ -2316,2 +2324,2 @@\n-        MyValue1[] va = new MyValue1[2];\n-        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vab = new MyValue1[2];\n@@ -2340,1 +2348,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[1];\n+        MyValue1[] va = new MyValue1[1];\n@@ -2351,1 +2359,2 @@\n-    \/\/ Test narrowing conversion from [L to [Q\n+\n+    \/\/ Test casting to null restricted array\n@@ -2354,2 +2363,2 @@\n-    public static MyValue1[] test88(MyValue1.ref[] va) {\n-        return (MyValue1[])va;\n+    public static MyValue1[] test88(Class c, MyValue1[] va) {\n+        return (MyValue1[])c.cast(va);\n@@ -2360,1 +2369,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2362,1 +2371,1 @@\n-        MyValue1[] res = test88(va);\n+        MyValue1[] res = test88(va.getClass(), va);\n@@ -2365,1 +2374,1 @@\n-        test88(null); \/\/ Should not throw NPE\n+        test88(va.getClass(), null); \/\/ Should not throw NPE\n@@ -2367,1 +2376,1 @@\n-            test88(new MyValue1.ref[1]);\n+            test88(va.getClass(), new MyValue1[1]);\n@@ -2374,1 +2383,1 @@\n-    \/\/ Same as test88 but with explicit cast and Object argument\n+    \/\/ Same as test88 but with Object argument\n@@ -2377,2 +2386,2 @@\n-    public static MyValue1[] test89(Object[] va) {\n-        return (MyValue1[])va;\n+    public static MyValue1[] test89(Class c, Object[] va) {\n+        return (MyValue1[])c.cast(va);\n@@ -2383,1 +2392,1 @@\n-        MyValue1[] va = new MyValue1[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2385,1 +2394,1 @@\n-        MyValue1[] res = test89(va);\n+        MyValue1[] res = test89(va.getClass(), va);\n@@ -2388,1 +2397,1 @@\n-        test89(null); \/\/ Should not throw NPE\n+        test89(va.getClass(), null); \/\/ Should not throw NPE\n@@ -2390,1 +2399,1 @@\n-            test89(new MyValue1.ref[1]);\n+            test89(va.getClass(), new MyValue1[1]);\n@@ -2399,2 +2408,2 @@\n-    public static MyValue1.ref[] test90(Object va) {\n-        return (MyValue1.ref[])va;\n+    public static MyValue1[] test90(Object va) {\n+        return (MyValue1[])va;\n@@ -2405,2 +2414,2 @@\n-        MyValue1[] va = new MyValue1[1];\n-        MyValue1.ref[] vab = new MyValue1.ref[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] vab = new MyValue1[1];\n@@ -2419,2 +2428,2 @@\n-    public static MyValue1.ref[] test91(Object[] va) {\n-        return (MyValue1.ref[])va;\n+    public static MyValue1[] test91(Object[] va) {\n+        return (MyValue1[])va;\n@@ -2425,2 +2434,2 @@\n-        MyValue1[] va = new MyValue1[1];\n-        MyValue1.ref[] vab = new MyValue1.ref[1];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] vab = new MyValue1[1];\n@@ -2440,1 +2449,1 @@\n-    public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {\n+    public static void test92(MyValue1[] src, MyValue1[] dst) {\n@@ -2446,2 +2455,2 @@\n-        MyValue1[]  va = new MyValue1[2];\n-        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vab = new MyValue1[2];\n@@ -2456,1 +2465,1 @@\n-    public static void test93(Object src, MyValue1.ref[] dst) {\n+    public static void test93(Object src, MyValue1[] dst) {\n@@ -2462,2 +2471,2 @@\n-        MyValue1[]  va = new MyValue1[2];\n-        MyValue1.ref[] vab = new MyValue1.ref[2];\n+        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vab = new MyValue1[2];\n@@ -2475,2 +2484,2 @@\n-        MyValue1.ref[] src = new MyValue1.ref[8];\n-        MyValue1[]  dst = new MyValue1[8];\n+        MyValue1[] src = new MyValue1[8];\n+        MyValue1[]  dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n@@ -2487,1 +2496,1 @@\n-        Asserts.assertEquals(result, MyValue1.default.hash());\n+        Asserts.assertEquals(result, MyValue1.createDefaultInline().hash());\n@@ -2493,1 +2502,1 @@\n-        MyValue1.ref[] va = new MyValue1.ref[1];\n+        MyValue1[] va = new MyValue1[1];\n@@ -2510,2 +2519,2 @@\n-    \/\/ Matrix multiplication test to exercise type flow analysis with nullable inline type arrays\n-    primitive static class Complex {\n+    \/\/ Matrix multiplication test to exercise type flow analysis with nullable value class arrays\n+    static value class Complex {\n@@ -2531,1 +2540,1 @@\n-    public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {\n+    public Complex[][] test96(Complex[][] A, Complex[][] B) {\n@@ -2533,1 +2542,1 @@\n-        Complex.ref[][] R = new Complex.ref[size][size];\n+        Complex[][] R = new Complex[size][size];\n@@ -2536,1 +2545,1 @@\n-                Complex.ref aik = A[i][k];\n+                Complex aik = A[i][k];\n@@ -2545,3 +2554,3 @@\n-    static Complex.ref[][] test96_A = new Complex.ref[10][10];\n-    static Complex.ref[][] test96_B = new Complex.ref[10][10];\n-    static Complex.ref[][] test96_R;\n+    static Complex[][] test96_A = new Complex[10][10];\n+    static Complex[][] test96_B = new Complex[10][10];\n+    static Complex[][] test96_R;\n@@ -2560,1 +2569,1 @@\n-        Complex.ref[][] result = test96(test96_A, test96_B);\n+        Complex[][] result = test96(test96_A, test96_B);\n@@ -2604,2 +2613,2 @@\n-            MyValue1[] va = new MyValue1[1];\n-            MyValue1.ref[] vab = new MyValue1.ref[1];\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] vab = new MyValue1[1];\n@@ -2607,1 +2616,1 @@\n-            Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());\n+            Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.createDefaultInline().hash());\n@@ -2694,2 +2703,2 @@\n-            MyValue1[] va = new MyValue1[1];\n-            MyValue1.ref[] vab = new MyValue1.ref[1];\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] vab = new MyValue1[1];\n@@ -2720,1 +2729,1 @@\n-            MyValue1[] va = new MyValue1[1];\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2804,2 +2813,2 @@\n-            MyValue1[] va = new MyValue1[1];\n-            MyValue1.ref[] vab = new MyValue1.ref[1];\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] vab = new MyValue1[1];\n@@ -2807,1 +2816,1 @@\n-            Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());\n+            Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.createDefaultInline().hash());\n@@ -2813,0 +2822,2 @@\n+    \/\/ TODO 8325106 Fails with \"matching stack sizes\" in Scenario 5 with -XX:TypeProfileLevel=222\n+    \/*\n@@ -2815,1 +2826,1 @@\n-    public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {\n+    public long test107_helper(MyValue1[] va, MyValue1 vt) {\n@@ -2824,2 +2835,2 @@\n-        MyValue1[] va = new MyValue1[2];\n-        MyValue1.ref[] tmp = new MyValue1.ref[2];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] tmp = new MyValue1[2];\n@@ -2829,2 +2840,2 @@\n-        Asserts.assertEquals(res1, MyValue1.default.hash());\n-        Asserts.assertEquals(res2, MyValue1.default.hash());\n+        Asserts.assertEquals(res1, MyValue1.createDefaultInline().hash());\n+        Asserts.assertEquals(res2, MyValue1.createDefaultInline().hash());\n@@ -2837,0 +2848,1 @@\n+    *\/\n@@ -2839,2 +2851,2 @@\n-    public Object test108(MyValue1.ref[] src, boolean flag) {\n-        MyValue1.ref[] dst = new MyValue1.ref[8];\n+    public Object test108(MyValue1[] src, boolean flag) {\n+        MyValue1[] dst = new MyValue1[8];\n@@ -2849,1 +2861,1 @@\n-        MyValue1.ref[] src = new MyValue1.ref[8];\n+        MyValue1[] src = new MyValue1[8];\n@@ -2856,2 +2868,2 @@\n-        MyValue1[] src = new MyValue1[1];\n-        MyValue1.ref[] dst = new MyValue1.ref[1];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] dst = new MyValue1[1];\n@@ -2871,1 +2883,1 @@\n-        MyValue1[] src = new MyValue1[1];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2886,1 +2898,1 @@\n-        MyValue1[] src = new MyValue1[1];\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2888,1 +2900,1 @@\n-        MyValue1.ref[] dst = Arrays.copyOf(src, src.length, MyValue1.ref[].class);\n+        MyValue1[] dst = Arrays.copyOf(src, src.length, MyValue1[].class);\n@@ -2897,2 +2909,2 @@\n-    MyValue1.ref[] refArray = new MyValue1.ref[2];\n-    MyValue1[] flatArray = new MyValue1[1];\n+    static final MyValue1[] refArray = new MyValue1[2];\n+    static final MyValue1[] flatArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2900,1 +2912,1 @@\n-    \/\/ Test scalarization of .ref\n+    \/\/ Test scalarization\n@@ -2904,1 +2916,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -2932,1 +2944,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -2957,2 +2969,2 @@\n-    public MyValue1.ref test114(boolean b) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+    public MyValue1 test114(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -2980,1 +2992,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -3012,2 +3024,2 @@\n-    public MyValue1.ref test116(boolean b1, boolean b2, Method m) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+    public MyValue1 test116(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -3041,1 +3053,1 @@\n-        MyValue1.ref val = null;\n+        MyValue1 val = null;\n@@ -3061,2 +3073,2 @@\n-    public MyValue1.ref test118(boolean b) {\n-        MyValue1.ref val = null;\n+    public MyValue1 test118(boolean b) {\n+        MyValue1 val = null;\n@@ -3079,1 +3091,1 @@\n-        MyValue1.ref val = refArray[0];\n+        MyValue1 val = refArray[0];\n@@ -3099,2 +3111,2 @@\n-    public MyValue1.ref test120(boolean b) {\n-        MyValue1.ref val = refArray[0];\n+    public MyValue1 test120(boolean b) {\n+        MyValue1 val = refArray[0];\n@@ -3129,0 +3141,3 @@\n+        if (o == null) {\n+            return;\n+        }\n@@ -3158,0 +3173,3 @@\n+        if (o == null) {\n+            return;\n+        }\n@@ -3179,2 +3197,2 @@\n-    public long test123(boolean b, MyValue1.ref val, Method m, boolean deopt) {\n-        MyValue1.ref[] array = new MyValue1.ref[1];\n+    public long test123(boolean b, MyValue1 val, Method m, boolean deopt) {\n+        MyValue1[] array = new MyValue1[1];\n@@ -3197,1 +3215,1 @@\n-        refArray[0] = MyValue1.default;\n+        refArray[0] = MyValue1.createDefaultInline();\n@@ -3199,1 +3217,1 @@\n-        Asserts.assertEquals(test123(false, testValue1, info.getTest(), false), MyValue1.default.hash());\n+        Asserts.assertEquals(test123(false, testValue1, info.getTest(), false), MyValue1.createDefaultInline().hash());\n@@ -3206,2 +3224,2 @@\n-    public Object test124_helper(MyValue2.ref val) {\n-        MyValue2.ref[] array = new MyValue2.ref[1];\n+    public Object test124_helper(MyValue2 val) {\n+        MyValue2[] array = new MyValue2[1];\n@@ -3214,1 +3232,1 @@\n-    public long test124(boolean b, MyValue2.ref val, Method m, boolean deopt) {\n+    public long test124(boolean b, MyValue2 val, Method m, boolean deopt) {\n@@ -3230,1 +3248,1 @@\n-        refArray[0] = MyValue1.default;\n+        refArray[0] = MyValue1.createDefaultInline();\n@@ -3241,1 +3259,1 @@\n-    public void test125_helper(Object[] array, MyValue2.ref val) {\n+    public void test125_helper(Object[] array, MyValue2 val) {\n@@ -3247,2 +3265,2 @@\n-    public long test125(boolean b, MyValue2.ref val, Method m, boolean deopt) {\n-        Object[] res = new MyValue2.ref[1];\n+    public long test125(boolean b, MyValue2 val, Method m, boolean deopt) {\n+        Object[] res = new MyValue2[1];\n@@ -3264,1 +3282,1 @@\n-        refArray[0] = MyValue1.default;\n+        refArray[0] = MyValue1.createDefaultInline();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":423,"deletions":405,"binary":false,"changes":828,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.util.Objects;\n+\n@@ -36,1 +38,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -44,1 +49,1 @@\n- * @summary Test correct handling of nullable inline types.\n+ * @summary Test correct handling of nullable value classes.\n@@ -49,2 +54,3 @@\n- * @compile -XDenablePrimitiveClasses TestNullableInlineTypes.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestNullableInlineTypes\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestNullableInlineTypes.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestNullableInlineTypes\n@@ -79,1 +85,1 @@\n-            MethodType test18_mt = MethodType.methodType(void.class, MyValue1.ref.class);\n+            MethodType test18_mt = MethodType.methodType(void.class, MyValue1.class);\n@@ -83,1 +89,1 @@\n-            MethodType test19_mt = MethodType.methodType(void.class, MyValue1.ref.class);\n+            MethodType test19_mt = MethodType.methodType(void.class, MyValue1.class);\n@@ -92,0 +98,1 @@\n+    @NullRestricted\n@@ -93,3 +100,0 @@\n-    private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,\n-                                                                      testValue1,\n-                                                                      testValue1};\n@@ -97,1 +101,9 @@\n-    MyValue1.ref nullField;\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n+    static {\n+        for (int i = 0; i < 3; ++i) {\n+            testValue1Array[i] = testValue1;\n+        }\n+    }\n+\n+    MyValue1 nullField;\n+    @NullRestricted\n@@ -102,1 +114,1 @@\n-    public long test1(MyValue1.ref vt) {\n+    public long test1(MyValue1 vt) {\n@@ -121,1 +133,1 @@\n-    public long test2(MyValue1.ref vt) {\n+    public long test2(MyValue1 vt) {\n@@ -134,1 +146,1 @@\n-        long result = test2(nullField);\n+        long result = test2(null);\n@@ -164,1 +176,1 @@\n-            valueField1 = (MyValue1) nullField;\n+            valueField1 = nullField;\n@@ -180,10 +192,3 @@\n-    public MyValue1.ref test5(MyValue1.ref vt) {\n-        try {\n-            Object o = vt;\n-            vt = (MyValue1)o;\n-            throw new RuntimeException(\"NullPointerException expected\");\n-        } catch (NullPointerException e) {\n-            \/\/ Expected\n-        }\n-\n-        \/\/ Should not throw\n+    public MyValue1 test5(MyValue1 vt) {\n+        Object o = vt;\n+        vt = (MyValue1)o;\n@@ -198,2 +203,2 @@\n-        MyValue1.ref vt = test5(nullField);\n-        Asserts.assertEquals(vt, null);\n+        Asserts.assertEquals(test5(val), val);\n+        Asserts.assertEquals(test5(null), null);\n@@ -203,1 +208,1 @@\n-    public MyValue1.ref test5_dontinline(MyValue1.ref vt) {\n+    public MyValue1 test5_dontinline(MyValue1 vt) {\n@@ -208,1 +213,1 @@\n-    public MyValue1.ref test5_inline(MyValue1.ref vt) {\n+    public MyValue1 test5_inline(MyValue1 vt) {\n@@ -213,1 +218,0 @@\n-    @IR(failOn = {ALLOC})\n@@ -217,2 +221,1 @@\n-            vt = (MyValue1)obj;\n-            throw new RuntimeException(\"NullPointerException expected\");\n+            vt = (MyValue1)Objects.requireNonNull(obj);\n@@ -232,1 +235,1 @@\n-    public MyValue1.ref getNullInline() {\n+    public MyValue1 getNullInline() {\n@@ -237,1 +240,1 @@\n-    public MyValue1.ref getNullDontInline() {\n+    public MyValue1 getNullDontInline() {\n@@ -247,1 +250,1 @@\n-            valueField1 = (MyValue1) getNullInline();\n+            valueField1 = getNullInline();\n@@ -253,1 +256,1 @@\n-            valueField1 = (MyValue1) getNullDontInline();\n+            valueField1 = getNullDontInline();\n@@ -269,1 +272,1 @@\n-            valueField1 = (MyValue1) nullField;\n+            valueField1 = nullField;\n@@ -281,1 +284,1 @@\n-    \/\/ merge of 2 inline types, one being null\n+    \/\/ Merge of two value objects, one being null\n@@ -289,1 +292,1 @@\n-            v = (MyValue1) nullField;\n+            v = nullField;\n@@ -309,2 +312,2 @@\n-        MyValue1.ref val = flag ? valueField1 : null;\n-        valueField1 = (MyValue1) val;\n+        MyValue1 val = flag ? valueField1 : null;\n+        valueField1 = val;\n@@ -328,2 +331,2 @@\n-        MyValue1.ref val = flag ? null : valueField1;\n-        valueField1 = (MyValue1) val;\n+        MyValue1 val = flag ? null : valueField1;\n+        valueField1 = val;\n@@ -347,1 +350,1 @@\n-    public MyValue1.ref test12_helper() {\n+    public MyValue1 test12_helper() {\n@@ -355,1 +358,1 @@\n-        valueField1 = (MyValue1) test12_helper();\n+        valueField1 = test12_helper();\n@@ -374,1 +377,1 @@\n-        public MyValue1.ref test13_helper() {\n+        public MyValue1 test13_helper() {\n@@ -381,1 +384,1 @@\n-            return (MyValue1) nullField;\n+            return nullField;\n@@ -386,1 +389,1 @@\n-        public MyValue1.ref test13_helper() {\n+        public MyValue1 test13_helper() {\n@@ -393,1 +396,1 @@\n-            return (MyValue1) nullField;\n+            return nullField;\n@@ -400,1 +403,1 @@\n-        valueField1 = (MyValue1) a.test13_helper();\n+        valueField1 = a.test13_helper();\n@@ -435,1 +438,1 @@\n-    \/\/ Test writing null to a (flattened) inline type array\n+    \/\/ Test writing null to a (flat) value class array\n@@ -460,1 +463,1 @@\n-    MyValue1.ref getNullField1() {\n+    MyValue1 getNullField1() {\n@@ -466,1 +469,1 @@\n-        return (MyValue1) nullField;\n+        return null;\n@@ -474,1 +477,1 @@\n-            valueField1 = (MyValue1) getNullField1();\n+            valueField1 = getNullField1();\n@@ -493,1 +496,1 @@\n-    public boolean test16_dontinline(MyValue1.ref vt) {\n+    public boolean test16_dontinline(MyValue1 vt) {\n@@ -497,1 +500,1 @@\n-    \/\/ Test c2c call passing null for an inline type\n+    \/\/ Test c2c call passing null for a value class\n@@ -501,1 +504,1 @@\n-        Method test16method = getClass().getMethod(\"test16_dontinline\", MyValue1.ref.class);\n+        Method test16method = getClass().getMethod(\"test16_dontinline\", MyValue1.class);\n@@ -512,3 +515,5 @@\n-    \/\/ Test scalarization of default inline type with non-flattenable field\n-    final primitive class Test17Value {\n-        public final MyValue1.ref valueField;\n+    \/\/ Test scalarization of default value class with non-flattenable field\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    final value class Test17Value {\n+        public final MyValue1 valueField;\n@@ -517,1 +522,1 @@\n-        public Test17Value(MyValue1.ref valueField) {\n+        public Test17Value(MyValue1 valueField) {\n@@ -527,1 +532,1 @@\n-        Test17Value vt1 = Test17Value.default;\n+        Test17Value vt1 = new Test17Value(null);\n@@ -541,1 +546,1 @@\n-    static MyValue1.ref nullValue;\n+    static MyValue1 nullValue;\n@@ -544,1 +549,1 @@\n-    static void test18_target1(MyValue1.ref vt) {\n+    static void test18_target1(MyValue1 vt) {\n@@ -549,1 +554,1 @@\n-    static void test18_target2(MyValue1.ref vt) {\n+    static void test18_target2(MyValue1 vt) {\n@@ -553,1 +558,1 @@\n-    \/\/ Test passing null for an inline type\n+    \/\/ Test passing null for a value class\n@@ -575,1 +580,1 @@\n-    static void test19_target1(MyValue1.ref vt) {\n+    static void test19_target1(MyValue1 vt) {\n@@ -580,1 +585,1 @@\n-    static void test19_target2(MyValue1.ref vt) {\n+    static void test19_target2(MyValue1 vt) {\n@@ -622,5 +627,7 @@\n-    \/\/ Test writing null to a flattenable\/non-flattenable inline type field in an inline type\n-    final primitive class Test21Value {\n-        final MyValue1.ref valueField1;\n-        final MyValue1 valueField2;\n-        final MyValue1.ref alwaysNull = null;\n+    \/\/ Test writing null to a flattenable\/non-flattenable value class field in a value class\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test21Value {\n+        MyValue1 valueField1;\n+        @NullRestricted\n+        MyValue1 valueField2;\n@@ -629,3 +636,3 @@\n-        public Test21Value(MyValue1.ref valueField1, MyValue1 valueField2) {\n-            this.valueField1 = testValue1;\n-            this.valueField2 = testValue1;\n+        public Test21Value(MyValue1 valueField1, MyValue1 valueField2) {\n+            this.valueField1 = valueField1;\n+            this.valueField2 = valueField2;\n@@ -636,1 +643,1 @@\n-            return new Test21Value(alwaysNull, this.valueField2); \/\/ Should not throw NPE\n+            return new Test21Value(null, this.valueField2); \/\/ Should not throw NPE\n@@ -641,1 +648,1 @@\n-            return new Test21Value(this.valueField1, (MyValue1) alwaysNull); \/\/ Should throw NPE\n+            return new Test21Value(this.valueField1, null); \/\/ Should throw NPE\n@@ -660,1 +667,1 @@\n-        test21(Test21Value.default);\n+        test21(new Test21Value(null, MyValue1.createDefaultInline()));\n@@ -665,1 +672,1 @@\n-        return (MyValue1) nullField;\n+        return nullField;\n@@ -689,2 +696,3 @@\n-    public void test23(MyValue1[] arr, MyValue1.ref b) {\n-        arr[0] = (MyValue1) b;\n+    public void test23(MyValue1 val) {\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        arr[0] = val;\n@@ -695,2 +703,1 @@\n-        MyValue1[] arr = new MyValue1[2];\n-        MyValue1.ref b = null;\n+        MyValue1 val = null;\n@@ -698,1 +705,1 @@\n-            test23(arr, b);\n+            test23(val);\n@@ -705,1 +712,1 @@\n-    static MyValue1.ref nullBox;\n+    static MyValue1 nullBox;\n@@ -710,1 +717,1 @@\n-        return (MyValue1) nullBox;\n+        return Objects.requireNonNull(nullBox);\n@@ -727,1 +734,1 @@\n-    \/\/ keep track of the information that the inline type can never be null.\n+    \/\/ keep track of the information that the value object can never be null.\n@@ -730,1 +737,1 @@\n-    public int test25(boolean b, MyValue1.ref vt1, MyValue1 vt2) {\n+    public int test25(boolean b, MyValue1 vt1, MyValue1 vt2) {\n@@ -745,1 +752,1 @@\n-                test25(false, null, testValue1);\n+                test25(true, null, testValue1);\n@@ -757,1 +764,1 @@\n-        return ((MyValue3)((Object)((MyValue3.ref)(MyValue3)((MyValue3.ref)((Object)vt)))));\n+        return ((MyValue3)((Object)((MyValue3)(MyValue3)((MyValue3)((Object)vt)))));\n@@ -769,2 +776,2 @@\n-    public MyValue3.ref test27(MyValue3.ref vt) {\n-        return ((MyValue3.ref)((Object)((MyValue3)(MyValue3.ref)((MyValue3)((Object)vt)))));\n+    public MyValue3 test27(MyValue3 vt) {\n+        return ((MyValue3)((Object)((MyValue3)(MyValue3)((MyValue3)((Object)vt)))));\n@@ -782,2 +789,2 @@\n-    public MyValue1.ref test28(MyValue1 vt, MyValue1.ref vtBox, int i) {\n-        MyValue1.ref result = null;\n+    public MyValue1 test28(MyValue1 vt, MyValue1 vtBox, int i) {\n+        MyValue1 result = null;\n@@ -785,1 +792,1 @@\n-            result = (MyValue1.ref)vt;\n+            result = (MyValue1)vt;\n@@ -788,1 +795,1 @@\n-            result = (MyValue1.ref)vt;\n+            result = (MyValue1)vt;\n@@ -797,1 +804,1 @@\n-        MyValue1.ref result = test28(testValue1, null, 0);\n+        MyValue1 result = test28(testValue1, null, 0);\n@@ -809,1 +816,1 @@\n-    public long test29(MyValue1 vt, MyValue1.ref vtBox) {\n+    public long test29(MyValue1 vt, MyValue1 vtBox) {\n@@ -812,1 +819,1 @@\n-            MyValue1.ref box;\n+            MyValue1 box;\n@@ -814,1 +821,1 @@\n-                box = (MyValue1.ref)vt;\n+                box = (MyValue1)vt;\n@@ -817,1 +824,1 @@\n-                box = (MyValue1.ref)vt;\n+                box = (MyValue1)vt;\n@@ -836,2 +843,2 @@\n-    \/\/ Test null check of inline type receiver with incremental inlining\n-    public long test30_callee(MyValue1.ref vt) {\n+    \/\/ Test null check of value object receiver with incremental inlining\n+    public long test30_callee(MyValue1 vt) {\n@@ -860,3 +867,3 @@\n-    \/\/ Test casting null to unloaded inline type\n-    final primitive class Test31Value {\n-        private final int i = 0;\n+    \/\/ Test casting null to unloaded value class\n+    value class Test31Value {\n+        private int i = 0;\n@@ -867,7 +874,2 @@\n-    public void test31(Object o) {\n-        try {\n-            o = (Test31Value)o;\n-            throw new RuntimeException(\"NullPointerException expected\");\n-        } catch (NullPointerException e) {\n-            \/\/ Expected\n-        }\n+    public Object test31(Object o) {\n+        return (Test31Value)o;\n@@ -881,1 +883,1 @@\n-    private static final MyValue1.ref constNullRefField = null;\n+    private static final MyValue1 constNullRefField = null;\n@@ -885,1 +887,1 @@\n-    public MyValue1.ref test32() {\n+    public MyValue1 test32() {\n@@ -891,1 +893,1 @@\n-        MyValue1.ref result = test32();\n+        MyValue1 result = test32();\n@@ -895,1 +897,3 @@\n-    static primitive class Test33Value1 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test33Value1 {\n@@ -899,2 +903,4 @@\n-    static primitive class Test33Value2 {\n-        Test33Value1.ref vt;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test33Value2 {\n+        Test33Value1 vt;\n@@ -907,0 +913,1 @@\n+    @NullRestricted\n@@ -923,1 +930,1 @@\n-    private static MyValue1.ref test34Val;\n+    private static MyValue1 test34Val;\n@@ -942,1 +949,1 @@\n-    \/\/ Same as test17 but with non-allocated inline type at withfield\n+    \/\/ Same as test17 but with non-allocated value object\n@@ -945,1 +952,1 @@\n-        Test17Value vt1 = Test17Value.default;\n+        Test17Value vt1 = new Test17Value(null);\n@@ -960,2 +967,2 @@\n-    \/\/ Test that when explicitly null checking an inline type, we keep\n-    \/\/ track of the information that the inline type can never be null.\n+    \/\/ Test that when explicitly null checking a value object, we keep\n+    \/\/ track of the information that the value object can never be null.\n@@ -964,1 +971,1 @@\n-    public int test37(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {\n+    public int test37(boolean b, MyValue1 vt1, MyValue1 vt2) {\n@@ -982,2 +989,2 @@\n-    \/\/ Test that when explicitly null checking an inline type receiver,\n-    \/\/ we keep track of the information that the inline type can never be null.\n+    \/\/ Test that when explicitly null checking a value object receiver,\n+    \/\/ we keep track of the information that the value object can never be null.\n@@ -986,1 +993,1 @@\n-    public int test38(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {\n+    public int test38(boolean b, MyValue1 vt1, MyValue1 vt2) {\n@@ -1002,2 +1009,2 @@\n-    \/\/ Test that when implicitly null checking an inline type receiver,\n-    \/\/ we keep track of the information that the inline type can never be null.\n+    \/\/ Test that when implicitly null checking a value object receiver,\n+    \/\/ we keep track of the information that the value object can never be null.\n@@ -1006,1 +1013,1 @@\n-    public int test39(boolean b, MyValue1.ref vt1, MyValue1.val vt2) {\n+    public int test39(boolean b, MyValue1 vt1, MyValue1 vt2) {\n@@ -1022,1 +1029,1 @@\n-    \/\/ Test NPE when casting constant null to inline type\n+    \/\/ Test NPE when casting constant null to a value class\n@@ -1027,1 +1034,2 @@\n-        return (MyValue1)NULL;\n+        MyValue1 val = (MyValue1)NULL;\n+        return Objects.requireNonNull(val);\n@@ -1040,1 +1048,2 @@\n-    MyValue1.ref refField;\n+    MyValue1 refField;\n+    @NullRestricted\n@@ -1047,1 +1056,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1075,1 +1084,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1100,2 +1109,2 @@\n-    public MyValue1.ref test43(boolean b) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+    public MyValue1 test43(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1123,1 +1132,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1155,2 +1164,2 @@\n-    public MyValue1.ref test45(boolean b1, boolean b2, Method m) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+    public MyValue1 test45(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1184,1 +1193,1 @@\n-        MyValue1.ref val = null;\n+        MyValue1 val = null;\n@@ -1203,2 +1212,2 @@\n-    public MyValue1.ref test47(boolean b) {\n-        MyValue1.ref val = null;\n+    public MyValue1 test47(boolean b) {\n+        MyValue1 val = null;\n@@ -1220,1 +1229,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1239,2 +1248,2 @@\n-    public MyValue1.ref test49(boolean b) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+    public MyValue1 test49(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1280,2 +1289,4 @@\n-    static final primitive class MyValue1Wrapper {\n-        final MyValue1.ref vt;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue1Wrapper {\n+        MyValue1 vt;\n@@ -1284,1 +1295,1 @@\n-        public MyValue1Wrapper(MyValue1.ref vt) {\n+        public MyValue1Wrapper(MyValue1 vt) {\n@@ -1294,0 +1305,1 @@\n+    @NullRestricted\n@@ -1299,1 +1311,1 @@\n-        MyValue1Wrapper.ref val = MyValue1Wrapper.default;\n+        MyValue1Wrapper val = new MyValue1Wrapper(null);\n@@ -1310,1 +1322,1 @@\n-        Asserts.assertEquals(test51(false), MyValue1Wrapper.default.hash());\n+        Asserts.assertEquals(test51(false), (new MyValue1Wrapper(null)).hash());\n@@ -1316,1 +1328,1 @@\n-        MyValue1.ref val = MyValue1.default;\n+        MyValue1 val = MyValue1.createDefaultInline();\n@@ -1320,1 +1332,1 @@\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1333,1 +1345,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1337,1 +1349,1 @@\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1350,1 +1362,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1354,1 +1366,1 @@\n-        MyValue1Wrapper.ref w = MyValue1Wrapper.default;\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n@@ -1364,1 +1376,1 @@\n-        Asserts.assertEquals(test54(false, false), MyValue1Wrapper.default.hash());\n+        Asserts.assertEquals(test54(false, false), (new MyValue1Wrapper(null)).hash());\n@@ -1366,1 +1378,1 @@\n-        Asserts.assertEquals(test54(true, false), MyValue1Wrapper.default.hash());\n+        Asserts.assertEquals(test54(true, false), (new MyValue1Wrapper(null)).hash());\n@@ -1373,2 +1385,2 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1401,2 +1413,2 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1427,3 +1439,3 @@\n-    public MyValue1.ref test57(boolean b) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+    public MyValue1 test57(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1451,2 +1463,2 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1484,3 +1496,3 @@\n-    public MyValue1.ref test59(boolean b1, boolean b2, Method m) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+    public MyValue1 test59(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1514,1 +1526,1 @@\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n@@ -1516,1 +1528,1 @@\n-            MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+            MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1534,2 +1546,2 @@\n-    public MyValue1.ref test61(boolean b) {\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+    public MyValue1 test61(boolean b) {\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n@@ -1537,1 +1549,1 @@\n-            MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+            MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1552,2 +1564,2 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1572,3 +1584,3 @@\n-    public MyValue1.ref test63(boolean b) {\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+    public MyValue1 test63(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n@@ -1588,1 +1600,1 @@\n-    public MyValue1.ref test64_helper() {\n+    public MyValue1 test64_helper() {\n@@ -1595,1 +1607,1 @@\n-        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n@@ -1617,1 +1629,1 @@\n-        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -1641,1 +1653,1 @@\n-    public int test66(boolean b1, boolean b2, MyValue1.ref arg, Method m) {\n+    public int test66(boolean b1, boolean b2, MyValue1 arg, Method m) {\n@@ -1672,1 +1684,1 @@\n-    public MyValue1.ref test67_helper1() {\n+    public MyValue1 test67_helper1() {\n@@ -1718,1 +1730,1 @@\n-        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n@@ -1757,1 +1769,1 @@\n-        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n@@ -1803,1 +1815,1 @@\n-        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n@@ -1849,1 +1861,1 @@\n-        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n@@ -1865,1 +1877,1 @@\n-        return ((MyValue1.ref)val).x;\n+        return ((MyValue1)val).x;\n@@ -1888,1 +1900,1 @@\n-        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n@@ -1904,1 +1916,1 @@\n-        return ((MyValue1.ref)val).hash();\n+        return ((MyValue1)val).hash();\n@@ -1934,1 +1946,1 @@\n-        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n@@ -1950,1 +1962,1 @@\n-        return ((MyValue1.ref)val).x;\n+        return ((MyValue1)val).x;\n@@ -1980,1 +1992,1 @@\n-        return (MyValue1.ref)arg;\n+        return (MyValue1)arg;\n@@ -1995,1 +2007,1 @@\n-        return ((MyValue1.ref)val).hash();\n+        return ((MyValue1)val).hash();\n@@ -2026,1 +2038,1 @@\n-    public MyValue1.ref test75(MyValue1.ref vt, Object obj) {\n+    public MyValue1 test75(MyValue1 vt, Object obj) {\n@@ -2028,1 +2040,1 @@\n-            vt = (MyValue1.ref)obj;\n+            vt = (MyValue1)obj;\n@@ -2038,2 +2050,2 @@\n-        MyValue1.ref vt = testValue1;\n-        MyValue1.ref result = test75(vt, Integer.valueOf(rI));\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test75(vt, Integer.valueOf(rI));\n@@ -2048,1 +2060,1 @@\n-    \/\/ Test that constant null .ref field does not block scalarization\n+    \/\/ Test that constant null field does not block scalarization\n@@ -2060,0 +2072,1 @@\n+        val = Objects.requireNonNull(val);\n@@ -2090,1 +2103,1 @@\n-    \/\/ Test that constant object field with inline type content does not block scalarization\n+    \/\/ Test that constant object field with value class content does not block scalarization\n@@ -2132,0 +2145,1 @@\n+        val = Objects.requireNonNull(val);\n@@ -2172,0 +2186,1 @@\n+        val = Objects.requireNonNull(val);\n@@ -2211,1 +2226,1 @@\n-        return ((MyValue1.ref)val).hash();\n+        return ((MyValue1)val).hash();\n@@ -2246,1 +2261,1 @@\n-        return ((MyValue1.ref)val).hash();\n+        return ((MyValue1)val).hash();\n@@ -2283,1 +2298,1 @@\n-        return ((MyValue1.ref)val).hash();\n+        return ((MyValue1)val).hash();\n@@ -2312,1 +2327,1 @@\n-            return ((MyValue1.ref)val).hash();\n+            return ((MyValue1)val).hash();\n@@ -2341,1 +2356,1 @@\n-        return ((MyValue1Wrapper.ref)val).vt.hash();\n+        return ((MyValue1Wrapper)val).vt.hash();\n@@ -2364,1 +2379,2 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    \/\/ TODO 8325106 Fails with Scenario 5\n+    \/\/ @IR(failOn = {ALLOC, LOAD, STORE})\n@@ -2376,1 +2392,3 @@\n-        return ((MyValue1Wrapper.ref)val).vt.hash();\n+        MyValue1 vt = ((MyValue1Wrapper)val).vt;\n+        vt = Objects.requireNonNull(vt);\n+        return vt.hash();\n@@ -2412,1 +2430,1 @@\n-        return ((MyValue1.ref)val.obj).hash();\n+        return ((MyValue1)val.obj).hash();\n@@ -2421,2 +2439,4 @@\n-    public static primitive class Test87C0 {\n-        int x = rI;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test87C0 {\n+        int x = 0;\n@@ -2425,2 +2445,5 @@\n-    public static primitive class Test87C1 {\n-        Test87C0 field = Test87C0.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test87C1 {\n+        @NullRestricted\n+        Test87C0 field = new Test87C0();\n@@ -2429,2 +2452,5 @@\n-    public static primitive class Test87C2 {\n-        Test87C1 field = Test87C1.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test87C2 {\n+        @NullRestricted\n+        Test87C1 field = new Test87C1();\n@@ -2433,1 +2459,1 @@\n-    \/\/ Test merging .val and .ref in return\n+    \/\/ Test merging field loads in return\n@@ -2435,1 +2461,1 @@\n-    public Test87C1 test87(boolean b, Test87C2.val v1, Test87C2.ref v2) {\n+    public Test87C1 test87(boolean b, Test87C2 v1, Test87C2 v2) {\n@@ -2450,1 +2476,3 @@\n-    static primitive class Test88Value {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test88Value {\n@@ -2505,1 +2533,1 @@\n-    public boolean test90_inline(MyValue1.ref vt) {\n+    public boolean test90_inline(MyValue1 vt) {\n@@ -2520,1 +2548,1 @@\n-        Method m = getClass().getMethod(\"test90_inline\", MyValue1.ref.class);\n+        Method m = getClass().getMethod(\"test90_inline\", MyValue1.class);\n@@ -2528,1 +2556,1 @@\n-    public Object test91(MyValue1.ref vt) {\n+    public Object test91(MyValue1 vt) {\n@@ -2537,1 +2565,1 @@\n-    MyValue1.ref test92Field = testValue1;\n+    MyValue1 test92Field = testValue1;\n@@ -2553,1 +2581,1 @@\n-        MethodType.methodType(PrimitiveClass.asPrimaryType(MyValue2.class), TestNullableInlineTypes.class, PrimitiveClass.asPrimaryType(MyValue1.class)),\n+        MethodType.methodType(MyValue2.class, TestNullableInlineTypes.class, MyValue1.class),\n@@ -2557,1 +2585,1 @@\n-            checkcast(PrimitiveClass.asPrimaryType(MyValue2.class)).\n+            checkcast(MyValue2.class).\n@@ -2563,1 +2591,1 @@\n-    public Object test93(MyValue1.ref vt) throws Throwable {\n+    public Object test93(MyValue1 vt) throws Throwable {\n@@ -2574,1 +2602,1 @@\n-    public MyValue1.ref test94_helper1(MyValue1.ref vt) {\n+    public MyValue1 test94_helper1(MyValue1 vt) {\n@@ -2579,1 +2607,1 @@\n-    public MyValue1.ref test94_helper2(MyValue1.ref vt) {\n+    public MyValue1 test94_helper2(MyValue1 vt) {\n@@ -2584,2 +2612,2 @@\n-    public MyValue1.ref test94_helper3(Object vt) {\n-        return test94_helper2((MyValue1.ref)vt);\n+    public MyValue1 test94_helper3(Object vt) {\n+        return test94_helper2((MyValue1)vt);\n@@ -2594,2 +2622,2 @@\n-    public MyValue1.ref test94(MyValue1.ref vt) {\n-        MyValue1.ref res = test94_helper1(vt);\n+    public MyValue1 test94(MyValue1 vt) {\n+        MyValue1 res = test94_helper1(vt);\n@@ -2610,1 +2638,1 @@\n-    public static MyValue1.ref test95_helper1(MyValue1.ref vt) {\n+    public static MyValue1 test95_helper1(MyValue1 vt) {\n@@ -2615,1 +2643,1 @@\n-    public static MyValue1.ref test95_helper2(MyValue1.ref vt) {\n+    public static MyValue1 test95_helper2(MyValue1 vt) {\n@@ -2620,2 +2648,2 @@\n-    public static MyValue1.ref test95_helper3(Object vt) {\n-        return test95_helper2((MyValue1.ref)vt);\n+    public static MyValue1 test95_helper3(Object vt) {\n+        return test95_helper2((MyValue1)vt);\n@@ -2630,2 +2658,2 @@\n-    public static MyValue1.ref test95(MyValue1.ref vt) {\n-        MyValue1.ref res = test95_helper1(vt);\n+    public static MyValue1 test95(MyValue1 vt) {\n+        MyValue1 res = test95_helper1(vt);\n@@ -2646,1 +2674,1 @@\n-    public MyValue2.ref test96_helper1(boolean b) {\n+    public MyValue2 test96_helper1(boolean b) {\n@@ -2651,1 +2679,1 @@\n-    public MyValue2.ref test96_helper2() {\n+    public MyValue2 test96_helper2() {\n@@ -2656,1 +2684,1 @@\n-    public MyValue2.ref test96_helper3(boolean b) {\n+    public MyValue2 test96_helper3(boolean b) {\n@@ -2666,2 +2694,2 @@\n-    public MyValue2.ref test96(int c, boolean b) {\n-        MyValue2.ref res = null;\n+    public MyValue2 test96(int c, boolean b) {\n+        MyValue2 res = null;\n@@ -2689,1 +2717,1 @@\n-    public MyValue3.ref test97_helper1(boolean b) {\n+    public MyValue3 test97_helper1(boolean b) {\n@@ -2694,1 +2722,1 @@\n-    public MyValue3.ref test97_helper2() {\n+    public MyValue3 test97_helper2() {\n@@ -2699,1 +2727,1 @@\n-    public MyValue3.ref test97_helper3(boolean b) {\n+    public MyValue3 test97_helper3(boolean b) {\n@@ -2703,0 +2731,1 @@\n+    @NullRestricted\n@@ -2704,0 +2733,1 @@\n+    @NullRestricted\n@@ -2712,2 +2742,2 @@\n-    public MyValue3.ref test97(int c, boolean b) {\n-        MyValue3.ref res = null;\n+    public MyValue3 test97(int c, boolean b) {\n+        MyValue3 res = null;\n@@ -2740,2 +2770,4 @@\n-    static primitive class CircularValue1 {\n-        CircularValue1.ref val;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class CircularValue1 {\n+        CircularValue1 val;\n@@ -2745,1 +2777,1 @@\n-        public CircularValue1(CircularValue1.ref val) {\n+        public CircularValue1(CircularValue1 val) {\n@@ -2751,1 +2783,1 @@\n-    \/\/ Test scalarization of primitive class with circularity in fields\n+    \/\/ Test scalarization of value class with circularity in fields\n@@ -2765,1 +2797,4 @@\n-    static primitive class CircularValue2 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class CircularValue2 {\n+        @NullRestricted\n@@ -2774,0 +2809,2 @@\n+    \/\/ TODO 8325106 fix assert in InlineTypeNode::merge_with\n+\/*\n@@ -2787,3 +2824,5 @@\n-\n-    static primitive class CircularValue3 {\n-        CircularValue4.ref val;\n+*\/\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class CircularValue3 {\n+        CircularValue4 val;\n@@ -2793,1 +2832,1 @@\n-        public CircularValue3(CircularValue4.ref val, int x) {\n+        public CircularValue3(CircularValue4 val, int x) {\n@@ -2799,1 +2838,4 @@\n-    static primitive class CircularValue4 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class CircularValue4 {\n+        @NullRestricted\n@@ -2822,1 +2864,4 @@\n-    static primitive class CircularValue5 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class CircularValue5 {\n+        @NullRestricted\n@@ -2833,2 +2878,4 @@\n-    static primitive class CircularValue6 {\n-        CircularValue5.ref val;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class CircularValue6 {\n+        CircularValue5 val;\n@@ -2837,1 +2884,1 @@\n-        public CircularValue6(CircularValue5.ref val) {\n+        public CircularValue6(CircularValue5 val) {\n@@ -2842,1 +2889,1 @@\n-    \/\/ Same as test100 but with different combination of .ref\/.val fields\n+    \/\/ Same as test100 but with different combination of field types\n@@ -2850,1 +2897,1 @@\n-        CircularValue5 val5 = new CircularValue5(CircularValue6.default, 42);\n+        CircularValue5 val5 = new CircularValue5(new CircularValue6(null), 42);\n@@ -2858,2 +2905,2 @@\n-    public CircularValue1.ref test102(boolean b) {\n-        CircularValue1.ref val = new CircularValue1(CircularValue1.default);\n+    public CircularValue1 test102(boolean b) {\n+        CircularValue1 val = new CircularValue1(new CircularValue1(null));\n@@ -2868,1 +2915,1 @@\n-        Asserts.assertEQ(test102(false), new CircularValue1(CircularValue1.default));\n+        Asserts.assertEQ(test102(false), new CircularValue1(new CircularValue1(null)));\n@@ -2874,1 +2921,1 @@\n-        return (MyValue1.ref)obj;\n+        return (MyValue1)obj;\n@@ -2879,1 +2926,1 @@\n-    public MyValue1.ref test103() {\n+    public MyValue1 test103() {\n@@ -2881,1 +2928,1 @@\n-        return (MyValue1.ref)obj;\n+        return (MyValue1)obj;\n@@ -2888,0 +2935,354 @@\n+\n+    \/\/ Test null restricted fields\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue104 {\n+        @NullRestricted\n+        static MyValue105 field1;\n+\n+        @NullRestricted\n+        MyValue105 field2;\n+\n+        @NullRestricted\n+        static MyValueEmpty field3;\n+\n+        @NullRestricted\n+        MyValueEmpty field4;\n+\n+        @ForceInline\n+        public MyValue104() {\n+            this.field1 = new MyValue105();\n+            this.field2 = new MyValue105();\n+            this.field3 = new MyValueEmpty();\n+            this.field4 = new MyValueEmpty();\n+        }\n+\n+        @ForceInline\n+        public MyValue104(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+            this.field1 = val1;\n+            this.field2 = val2;\n+            this.field3 = val3;\n+            this.field4 = val4;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue105 {\n+        int x = 42;\n+    }\n+\n+    @NullRestricted\n+    static MyValue104 field1;\n+\n+    @NullRestricted\n+    MyValue104 field2;\n+\n+    @NullRestricted\n+    static MyValueEmpty field3;\n+\n+    @NullRestricted\n+    MyValueEmpty field4;\n+\n+    @Test\n+    void test105(MyValue104 arg) {\n+        field1 = arg;\n+    }\n+\n+    @Run(test = \"test105\")\n+    public void test105_verifier() {\n+        try {\n+            test105(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test106() {\n+        field1 = null;\n+    }\n+\n+    @Run(test = \"test106\")\n+    public void test106_verifier() {\n+        try {\n+            test106();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test107(MyValue104 arg) {\n+        field2 = arg;\n+    }\n+\n+    @Run(test = \"test107\")\n+    public void test107_verifier() {\n+        try {\n+            test107(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test108(TestNullableInlineTypes t, MyValue104 arg) {\n+        t.field2 = arg;\n+    }\n+\n+    @Run(test = \"test108\")\n+    public void test108_verifier() {\n+        try {\n+            test108(null, new MyValue104());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test109(MyValue104 arg) {\n+        TestNullableInlineTypes t = null;\n+        t.field2 = null;\n+    }\n+\n+    @Run(test = \"test109\")\n+    public void test109_verifier() {\n+        try {\n+            test109(new MyValue104());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test110() {\n+        field2 = null;\n+    }\n+\n+    @Run(test = \"test110\")\n+    public void test110_verifier() {\n+        try {\n+            test110();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test111(MyValueEmpty arg) {\n+        field3 = arg;\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        try {\n+            test111(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test112() {\n+        field3 = null;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier() {\n+        try {\n+            test112();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test113(MyValueEmpty arg) {\n+        field4 = arg;\n+    }\n+\n+    @Run(test = \"test113\")\n+    public void test113_verifier() {\n+        try {\n+            test113(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test114(TestNullableInlineTypes t, MyValueEmpty arg) {\n+        t.field4 = arg;\n+    }\n+\n+    @Run(test = \"test114\")\n+    public void test114_verifier() {\n+        try {\n+            test114(null, new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test115(MyValueEmpty arg) {\n+        TestNullableInlineTypes t = null;\n+        t.field4 = arg;\n+    }\n+\n+    @Run(test = \"test115\")\n+    public void test115_verifier() {\n+        try {\n+            test115(new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test116() {\n+        field4 = null;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier() {\n+        try {\n+            test116();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test117(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        try {\n+            test117(null, new MyValue105(), new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test118(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        try {\n+            test118(new MyValue105(), null, new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test119(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier() {\n+        try {\n+            test119(new MyValue105(), new MyValue105(), null, new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test120(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        try {\n+            test120(new MyValue105(), new MyValue105(), new MyValueEmpty(), null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test121(MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(null, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        try {\n+            test121(new MyValue105(), new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test122(MyValue105 val1, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, null, val3, val4);\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        try {\n+            test122(new MyValue105(), new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test123(MyValue105 val1, MyValue105 val2, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, null, val4);\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier() {\n+        try {\n+            test123(new MyValue105(), new MyValue105(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test124(MyValue105 val1, MyValue105 val2, MyValueEmpty val3) {\n+        return new MyValue104(val1, val2, val3, null);\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier() {\n+        try {\n+            test124(new MyValue105(), new MyValue105(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":674,"deletions":273,"binary":false,"changes":947,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -36,1 +41,1 @@\n- * @summary Test on stack replacement (OSR) with inline types\n+ * @summary Test on stack replacement (OSR) with value classes.\n@@ -39,2 +44,3 @@\n- * @compile -XDenablePrimitiveClasses TestOnStackReplacement.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestOnStackReplacement\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestOnStackReplacement.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestOnStackReplacement\n@@ -45,1 +51,0 @@\n-\n@@ -74,1 +79,1 @@\n-        MyValue1[] va = new MyValue1[Math.abs(rI) % 3];\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, Math.abs(rI) % 3);\n@@ -81,1 +86,1 @@\n-            \/\/ Reference local inline type in interpreter state\n+            \/\/ Reference local value object in interpreter state\n@@ -168,1 +173,1 @@\n-    \/\/ OSR compilation with null inline type local\n+    \/\/ OSR compilation with null value class local\n@@ -170,1 +175,1 @@\n-    MyValue1.ref nullField;\n+    MyValue1 nullField;\n@@ -174,1 +179,1 @@\n-        MyValue1.ref vt = nullField;\n+        MyValue1 vt = nullField;\n@@ -188,2 +193,4 @@\n-    \/\/ Test OSR in method with inline type receiver\n-    primitive class Test6Value {\n+    \/\/ Test OSR in method with value class receiver\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test6Value {\n@@ -216,1 +223,3 @@\n-    static primitive class Test7Value1 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test7Value1 {\n@@ -225,1 +234,3 @@\n-    static primitive class Test7Value2 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test7Value2 {\n@@ -248,0 +259,1 @@\n+        @NullRestricted\n@@ -273,1 +285,2 @@\n-    \/\/ Test OSR with scalarized inline type return\n+    \/\/ Test OSR with scalarized value class return\n+    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Verify that Parse::optimize_cmp_with_klass() works with inline types.\n+ * @summary Verify that Parse::optimize_cmp_with_klass() works with value classes.\n@@ -29,2 +29,1 @@\n- * @compile -XDenablePrimitiveClasses TestOptimizeKlassCmp.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch compiler.valhalla.inlinetypes.TestOptimizeKlassCmp\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch compiler.valhalla.inlinetypes.TestOptimizeKlassCmp\n@@ -37,2 +36,2 @@\n-primitive class MyValue {\n-    public final int x;\n+value class MyValue {\n+    public int x;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOptimizeKlassCmp.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,2 @@\n- * @summary Test that oop fields of value\/primitive classes are preserved over safepoints at returns.\n- * @compile -XDenablePrimitiveClasses TestSafepointAtPollReturn.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @summary Test that oop fields of value classes are preserved over safepoints at returns.\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -40,4 +39,0 @@\n-    static primitive class MyPrimitive {\n-        Integer val = INT_VAL;\n-    }\n-\n@@ -52,8 +47,0 @@\n-    static public MyPrimitive testPrimitiveCallee() {\n-        return new MyPrimitive();\n-    }\n-\n-    static public MyPrimitive testPrimitive() {\n-        return testPrimitiveCallee();\n-    }\n-\n@@ -75,4 +62,0 @@\n-            int res = testPrimitive().val;\n-            if (res != i) {\n-                throw new RuntimeException(\"testPrimitive failed: \" + res + \" != \" + i);\n-            }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestSafepointAtPollReturn.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @requires vm.gc != \"Z\"\n@@ -28,1 +27,1 @@\n- * @summary Verify that TLAB allocated buffer initialization when returning an inline type works properly with oops.\n+ * @summary Verify that TLAB allocated buffer initialization when returning a value object works properly with oops.\n@@ -30,2 +29,1 @@\n- * @compile -XDenablePrimitiveClasses TestStressReturnBuffering.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -40,1 +38,1 @@\n-primitive class MyValue {\n+value class MyValue {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestStressReturnBuffering.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n- * @compile -XDenablePrimitiveClasses TestTrivialMethods.java\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestTrivialMethods.java\n@@ -34,1 +35,3 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -49,1 +52,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -59,0 +65,1 @@\n+    @NullRestricted\n@@ -60,1 +67,2 @@\n-    static MyValue3.ref staticFieldRef = MyValue3.create();\n+    static MyValue3 staticFieldRef = MyValue3.create();\n+    @NullRestricted\n@@ -62,1 +70,1 @@\n-    MyValue3.ref fieldRef = MyValue3.create();\n+    MyValue3 fieldRef = MyValue3.create();\n@@ -85,1 +93,1 @@\n-    public MyValue3.ref getter1Ref() {\n+    public MyValue3 getter1Ref() {\n@@ -89,1 +97,1 @@\n-    public static MyValue3.ref getter2Ref() {\n+    public static MyValue3 getter2Ref() {\n@@ -93,1 +101,1 @@\n-    public MyValue3.ref getter3Ref() {\n+    public MyValue3 getter3Ref() {\n@@ -97,1 +105,1 @@\n-    public Object getter4Ref(MyValue3.ref unusedArg) {\n+    public Object getter4Ref(MyValue3 unusedArg) {\n@@ -101,1 +109,1 @@\n-    public int constantGetterRef(MyValue3.ref unusedArg) {\n+    public int constantGetterRef(MyValue3 unusedArg) {\n@@ -117,1 +125,1 @@\n-    public void setter1Ref(MyValue3.ref val) {\n+    public void setter1Ref(MyValue3 val) {\n@@ -121,1 +129,1 @@\n-    public static void setter2Ref(MyValue3.ref val) {\n+    public static void setter2Ref(MyValue3 val) {\n@@ -125,1 +133,1 @@\n-    public void setter3Ref(MyValue3.ref val) {\n+    public void setter3Ref(MyValue3 val) {\n@@ -157,2 +165,2 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter1\", PrimitiveClass.asValueType(MyValue3.class));\n-        m = TestTrivialMethods.class.getMethod(\"getter4\", PrimitiveClass.asValueType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"setter1\", MyValue3.class);\n+        m = TestTrivialMethods.class.getMethod(\"getter4\", MyValue3.class);\n@@ -160,1 +168,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"constantGetter\", PrimitiveClass.asValueType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"constantGetter\", MyValue3.class);\n@@ -168,1 +176,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"getter4Ref\", PrimitiveClass.asPrimaryType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"getter4Ref\", MyValue3.class);\n@@ -170,1 +178,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"constantGetterRef\", PrimitiveClass.asPrimaryType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"constantGetterRef\", MyValue3.class);\n@@ -172,1 +180,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter1\", PrimitiveClass.asValueType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"setter1\", MyValue3.class);\n@@ -174,1 +182,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter2\", PrimitiveClass.asValueType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"setter2\", MyValue3.class);\n@@ -176,1 +184,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter3\", PrimitiveClass.asValueType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"setter3\", MyValue3.class);\n@@ -178,1 +186,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter1Ref\", PrimitiveClass.asPrimaryType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"setter1Ref\", MyValue3.class);\n@@ -180,1 +188,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter2Ref\", PrimitiveClass.asPrimaryType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"setter2Ref\", MyValue3.class);\n@@ -182,1 +190,1 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter3Ref\", PrimitiveClass.asPrimaryType(MyValue3.class));\n+        m = TestTrivialMethods.class.getMethod(\"setter3Ref\", MyValue3.class);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTrivialMethods.java","additions":33,"deletions":25,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Membars of non-escaping inline type buffer allocations should be removed.\n+ * @summary Membars of non-escaping value class buffer allocations should be removed.\n@@ -29,2 +29,2 @@\n- * @compile -XDenablePrimitiveClasses TestUnexpectedMemBar.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @compile TestUnexpectedMemBar.java\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -36,1 +36,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -42,1 +42,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -53,6 +53,6 @@\n-primitive class MyValue {\n-    final int a = 0;\n-    final int b = 0;\n-    final int c = 0;\n-    final int d = 0;\n-    final int e = 0;\n+value class MyValue {\n+    int a = 0;\n+    int b = 0;\n+    int c = 0;\n+    int d = 0;\n+    int e = 0;\n@@ -60,2 +60,2 @@\n-    final Integer i;\n-    final int[] array;\n+    Integer i;\n+    int[] array;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnexpectedMemBar.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUninitializedValueClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Red Hat, Inc. All rights reserved.\n@@ -28,3 +29,6 @@\n- * @summary Test the handling of arrays of unloaded inline classes.\n- * @compile -XDenablePrimitiveClasses TestUnloadedInlineTypeArray.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @summary Test the handling of arrays of unloaded value classes.\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestUnloadedInlineTypeArray.java\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -34,1 +38,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -38,1 +44,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -41,1 +49,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -44,1 +54,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -48,1 +60,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -52,1 +66,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -55,1 +71,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -62,2 +80,4 @@\n-final primitive class MyValue1 {\n-    final int foo;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -65,4 +85,4 @@\n-    private MyValue1() {\n-        foo = 0x42;\n-    }\n-}\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue1 {\n+    int foo;\n@@ -70,4 +90,1 @@\n-final primitive class MyValue1Box {\n-    final int foo;\n-\n-    private MyValue1Box() {\n+    private MyValue1() {\n@@ -78,2 +95,4 @@\n-final primitive class MyValue2 {\n-    final int foo;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue2 {\n+    int foo;\n@@ -86,10 +105,4 @@\n-final primitive class MyValue2Box {\n-    final int foo;\n-\n-    public MyValue2Box(int n) {\n-        foo = n;\n-    }\n-}\n-\n-final primitive class MyValue3 {\n-    final int foo;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue3 {\n+    int foo;\n@@ -102,10 +115,4 @@\n-final primitive class MyValue3Box {\n-    final int foo;\n-\n-    public MyValue3Box(int n) {\n-        foo = n;\n-    }\n-}\n-\n-final primitive class MyValue4 {\n-    final int foo;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue4 {\n+    int foo;\n@@ -118,10 +125,4 @@\n-final primitive class MyValue4Box {\n-    final int foo;\n-\n-    public MyValue4Box(int n) {\n-        foo = n;\n-    }\n-}\n-\n-final primitive class MyValue5 {\n-    final int foo;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue5 {\n+    int foo;\n@@ -134,2 +135,4 @@\n-final primitive class MyValue6 {\n-    final int foo;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue6 {\n+    int foo;\n@@ -146,14 +149,4 @@\n-final primitive class MyValue6Box {\n-    final int foo;\n-\n-    public MyValue6Box(int n) {\n-        foo = n;\n-    }\n-\n-    public MyValue6Box(MyValue6Box v, MyValue6Box.ref[] dummy) {\n-        foo = v.foo + 1;\n-    }\n-}\n-\n-final primitive class MyValue7 {\n-    final int foo;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue7 {\n+    int foo;\n@@ -166,10 +159,4 @@\n-final primitive class MyValue7Box {\n-    final int foo;\n-\n-    public MyValue7Box(int n) {\n-        foo = n;\n-    }\n-}\n-\n-final primitive class MyValue8 {\n-    final int foo = 123;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue8 {\n+    int foo = 123;\n@@ -181,2 +168,4 @@\n-final primitive class MyValue9 {\n-    final int foo = 123;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue9 {\n+    int foo = 123;\n@@ -188,2 +177,4 @@\n-final primitive class MyValue10 {\n-    final int foo = 42;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue10 {\n+    int foo = 42;\n@@ -192,2 +183,4 @@\n-final primitive class MyValue11 {\n-    final int foo = 42;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue11 {\n+    int foo = 42;\n@@ -201,1 +194,1 @@\n-        return new MyValue1[10];\n+        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n@@ -208,2 +201,2 @@\n-    static MyValue1Box.ref[] target1Box() {\n-        return new MyValue1Box.ref[10];\n+    static MyValue1[] target1Nullable() {\n+        return new MyValue1[10];\n@@ -212,2 +205,2 @@\n-    static void test1Box() {\n-        target1Box();\n+    static void test1Nullable() {\n+        target1Nullable();\n@@ -228,1 +221,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -233,1 +226,1 @@\n-        MyValue2[] arr = new MyValue2[2];\n+        MyValue2[] arr = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 2);\n@@ -236,1 +229,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -242,1 +235,1 @@\n-    static int test2Box(MyValue2Box.ref[] arr) {\n+    static int test2Nullable(MyValue2[] arr) {\n@@ -250,1 +243,1 @@\n-    static void verifyTest2Box() {\n+    static void verifyTest2Nullable() {\n@@ -254,2 +247,2 @@\n-        for (int i=0; i<n; i++) {\n-            m = test2Box(null);\n+        for (int i = 0; i < n; i++) {\n+            m = test2Nullable(null);\n@@ -259,2 +252,2 @@\n-        MyValue2Box.ref[] arr = new MyValue2Box.ref[2];\n-        arr[1] = new MyValue2Box(5678);\n+        MyValue2[] arr = new MyValue2[2];\n+        arr[1] = new MyValue2(5678);\n@@ -262,2 +255,2 @@\n-        for (int i=0; i<n; i++) {\n-            m = test2Box(arr);\n+        for (int i = 0; i < n; i++) {\n+            m = test2Nullable(arr);\n@@ -277,1 +270,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -281,2 +274,2 @@\n-        MyValue3[] arr = new MyValue3[2];\n-        for (int i=0; i<n; i++) {\n+        MyValue3[] arr = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 2);\n+        for (int i = 0; i < n; i++) {\n@@ -288,1 +281,1 @@\n-    static void test3Box(MyValue3Box.ref[] arr) {\n+    static void test3Nullable(MyValue3[] arr) {\n@@ -291,1 +284,1 @@\n-            arr[1] = new MyValue3Box(2345);\n+            arr[1] = new MyValue3(2345);\n@@ -295,1 +288,1 @@\n-    static void verifyTest3Box() {\n+    static void verifyTest3Nullable() {\n@@ -298,2 +291,2 @@\n-        for (int i=0; i<n; i++) {\n-            test3Box(null);\n+        for (int i = 0; i < n; i++) {\n+            test3Nullable(null);\n@@ -302,3 +295,3 @@\n-        MyValue3Box.ref[] arr = new MyValue3Box.ref[2];\n-        for (int i=0; i<n; i++) {\n-            test3Box(arr);\n+        MyValue3[] arr = new MyValue3[2];\n+        for (int i = 0; i < n; i++) {\n+            test3Nullable(arr);\n@@ -313,1 +306,1 @@\n-            MyValue4[] arr = new MyValue4[10];\n+            MyValue4[] arr = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 10);\n@@ -324,1 +317,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -329,1 +322,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -335,1 +328,1 @@\n-    static MyValue4Box.ref[] test4Box(boolean b) {\n+    static MyValue4[] test4Nullable(boolean b) {\n@@ -338,1 +331,1 @@\n-            MyValue4Box.ref[] arr = new MyValue4Box.ref[10];\n+            MyValue4[] arr = new MyValue4[10];\n@@ -340,1 +333,1 @@\n-            arr[1] = new MyValue4Box(2345);\n+            arr[1] = new MyValue4(2345);\n@@ -347,1 +340,1 @@\n-    static void verifyTest4Box() {\n+    static void verifyTest4Nullable() {\n@@ -350,2 +343,2 @@\n-        for (int i=0; i<n; i++) {\n-            test4Box(false);\n+        for (int i = 0; i < n; i++) {\n+            test4Nullable(false);\n@@ -354,3 +347,3 @@\n-        MyValue4Box.ref[] arr = null;\n-        for (int i=0; i<n; i++) {\n-            arr = test4Box(true);\n+        MyValue4[] arr = null;\n+        for (int i = 0; i < n; i++) {\n+            arr = test4Nullable(true);\n@@ -367,1 +360,1 @@\n-            MyValue5[] arr = new MyValue5[10];\n+            MyValue5[] arr = (MyValue5[])ValueClass.newNullRestrictedArray(MyValue5.class, 10);\n@@ -371,1 +364,1 @@\n-            MyValue5.ref[] arr = new MyValue5.ref[10];\n+            MyValue5[] arr = new MyValue5[10];\n@@ -380,1 +373,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -386,1 +379,1 @@\n-            for (int i=0; i<n; i++) {\n+            for (int i = 0; i < n; i++) {\n@@ -392,3 +385,3 @@\n-            MyValue5.ref[] arr = null;\n-            for (int i=0; i<n; i++) {\n-                arr = (MyValue5.ref[])test5(2);\n+            MyValue5[] arr = null;\n+            for (int i = 0; i < n; i++) {\n+                arr = (MyValue5[])test5(2);\n@@ -409,9 +402,0 @@\n-    static Object test6Box() {\n-        return new MyValue6Box(new MyValue6Box(123), null);\n-    }\n-\n-    static void verifyTest6Box() {\n-        Object n = test6Box();\n-        Asserts.assertEQ(n.toString(), \"MyValue6Box@\" + Integer.toHexString(n.hashCode()));\n-    }\n-\n@@ -430,1 +414,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -435,1 +419,2 @@\n-        MyValue7[][] arr = new MyValue7[2][2];\n+        MyValue7[][] arr = { (MyValue7[])ValueClass.newNullRestrictedArray(MyValue7.class, 2),\n+                             (MyValue7[])ValueClass.newNullRestrictedArray(MyValue7.class, 2) };\n@@ -441,1 +426,1 @@\n-        for (int i=0; i<n; i++) {\n+        for (int i = 0; i < n; i++) {\n@@ -447,1 +432,1 @@\n-    static int test7Box(MyValue7Box.ref[][] arr) {\n+    static int test7Nullable(MyValue7[][] arr) {\n@@ -456,1 +441,1 @@\n-    static void verifyTest7Box() {\n+    static void verifyTest7Nullable() {\n@@ -460,2 +445,2 @@\n-        for (int i=0; i<n; i++) {\n-            m = test7Box(null);\n+        for (int i = 0; i < n; i++) {\n+            m = test7Nullable(null);\n@@ -465,1 +450,1 @@\n-        MyValue7Box.ref[][] arr = new MyValue7Box.ref[2][2];\n+        MyValue7[][] arr = new MyValue7[2][2];\n@@ -469,1 +454,1 @@\n-        arr[0][1] = new MyValue7Box(5678);\n+        arr[0][1] = new MyValue7(5678);\n@@ -471,2 +456,2 @@\n-        for (int i=0; i<n; i++) {\n-            m = test7Box(arr);\n+        for (int i = 0; i < n; i++) {\n+            m = test7Nullable(arr);\n@@ -479,1 +464,1 @@\n-        MyValue8.ref a[] = new MyValue8.ref[0];\n+        MyValue8 a[] = new MyValue8[0];\n@@ -482,1 +467,1 @@\n-        MyValue8  b[] = new MyValue8 [0];\n+        MyValue8 b[] = (MyValue8[])ValueClass.newNullRestrictedArray(MyValue8.class, 0);\n@@ -487,1 +472,1 @@\n-        MyValue9.ref a[][] = new MyValue9.ref[10][0];\n+        MyValue9 a[][] = new MyValue9[10][0];\n@@ -490,1 +475,1 @@\n-        MyValue9  b[][] = new MyValue9 [10][0];\n+        a[0] = (MyValue9[])ValueClass.newNullRestrictedArray(MyValue9.class, 0);\n@@ -494,2 +479,2 @@\n-    static void test10(MyValue10.ref dummy) {\n-        MyValue10[][] a = new MyValue10[1][1];\n+    static void test10(MyValue10 dummy) {\n+        MyValue10[][] a = { (MyValue10[])ValueClass.newNullRestrictedArray(MyValue10.class, 1) };\n@@ -497,0 +482,1 @@\n+        Asserts.assertNE(a[0][0], null);\n@@ -499,3 +485,3 @@\n-    static void test11(MyValue10.ref dummy) {\n-        MyValue11.ref[][] a = new MyValue11.ref[1][1];\n-        if (a[0][0] != null) throw new RuntimeException(\"test11 failed\");\n+    static void test11(MyValue10 dummy) {\n+        MyValue11[][] a = new MyValue11[1][1];\n+        Asserts.assertEQ(a[0][0], null);\n@@ -506,1 +492,1 @@\n-        test1Box();\n+        test1Nullable();\n@@ -508,1 +494,1 @@\n-        verifyTest2Box();\n+        verifyTest2Nullable();\n@@ -510,1 +496,1 @@\n-        verifyTest3Box();\n+        verifyTest3Nullable();\n@@ -512,1 +498,1 @@\n-        verifyTest4Box();\n+        verifyTest4Nullable();\n@@ -515,1 +501,0 @@\n-        verifyTest6Box();\n@@ -517,1 +502,1 @@\n-        verifyTest7Box();\n+        verifyTest7Nullable();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeArray.java","additions":151,"deletions":166,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -34,1 +39,1 @@\n- * @summary Test the handling of fields of unloaded inline classes.\n+ * @summary Test the handling of fields of unloaded value classes.\n@@ -37,3 +42,7 @@\n- * @compile -XDenablePrimitiveClasses hack\/GetUnresolvedInlineFieldWrongSignature.java\n- * @compile -XDenablePrimitiveClasses TestUnloadedInlineTypeField.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestUnloadedInlineTypeField\n+ * @compile hack\/GetUnresolvedInlineFieldWrongSignature.java\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestUnloadedInlineTypeField.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla\n+ *                               --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                               --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n+ *                               compiler.valhalla.inlinetypes.TestUnloadedInlineTypeField\n@@ -56,8 +65,0 @@\n-        final String[] flags = { \"-XX:+EnableValhalla\" ,\"-XX:+EnablePrimitiveClasses\",\n-                                \/\/ Prevent IR Test Framework from loading classes\n-                                \"-DIgnoreCompilerControls=true\",\n-                                \/\/ Some tests trigger frequent re-compilation. Don't mark them as non-compilable.\n-                                \"-XX:PerMethodRecompilationCutoff=-1\", \"-XX:PerBytecodeRecompilationCutoff=-1\"};\n-        for (Scenario s : scenarios) {\n-           s.addFlags(flags);\n-        }\n@@ -66,0 +67,5 @@\n+                   .addFlags(\"-XX:+EnableValhalla\",\n+                             \/\/ Prevent IR Test Framework from loading classes\n+                             \"-DIgnoreCompilerControls=true\",\n+                             \/\/ Some tests trigger frequent re-compilation. Don't mark them as non-compilable.\n+                             \"-XX:PerMethodRecompilationCutoff=-1\", \"-XX:PerBytecodeRecompilationCutoff=-1\")\n@@ -70,1 +76,1 @@\n-    \/\/ The inline type field class has been loaded, but the holder class has not been loaded.\n+    \/\/ The value class field class has been loaded, but the holder class has not been loaded.\n@@ -73,1 +79,1 @@\n-    \/\/     getfield  MyValue1Holder.v:QMyValue1;\n+    \/\/     getfield  MyValue1Holder.v:LMyValue1;\n@@ -76,1 +82,1 @@\n-    \/\/ MyValue1 has already been loaded, because it's in the InlineType attribute of\n+    \/\/ MyValue1 has already been loaded, because it's in the preload attribute of\n@@ -78,2 +84,4 @@\n-    static final primitive class MyValue1 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue1 {\n+        int foo;\n@@ -87,0 +95,1 @@\n+        @NullRestricted\n@@ -119,1 +128,1 @@\n-    \/\/ Both the inline type field class, and the holder class have not been loaded.\n+    \/\/ Both the value class field class, and the holder class have not been loaded.\n@@ -122,1 +131,1 @@\n-    \/\/     getfield  MyValue2Holder.v:QMyValue2;\n+    \/\/     getfield  MyValue2Holder.v:LMyValue2;\n@@ -127,2 +136,4 @@\n-    static final primitive class MyValue2 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue2 {\n+        int foo;\n@@ -136,0 +147,1 @@\n+        @NullRestricted\n@@ -163,57 +175,0 @@\n-    \/\/ Test case 3: same as test1, except we are using an incorrect signature to\n-    \/\/ refer to the inline class.\n-    \/\/ The inline type field class has been loaded, but the holder class has not been loaded.\n-    \/\/\n-    \/\/ GetUnresolvedInlineFieldWrongSignature::test3() {\n-    \/\/     aload_0\n-    \/\/     getfield  MyValue3Holder.v:LMyValue3;\n-    \/\/               ^ not loaded    ^ already loaded (but should have been \"Q\")\n-    \/\/     ...\n-    \/\/ }\n-    \/\/\n-    \/\/ MyValue3 has already been loaded, because it's in the InlineType attribute of\n-    \/\/ TestUnloadedInlineTypeField, due to TestUnloadedInlineTypeField.test3_precondition().\n-    static final primitive class MyValue3 {\n-        final int foo;\n-\n-        public MyValue3() {\n-            foo = rI;\n-        }\n-    }\n-\n-    static class MyValue3Holder {\n-        MyValue3 v;\n-\n-        public MyValue3Holder() {\n-            v = new MyValue3();\n-        }\n-    }\n-\n-    static MyValue3 test3_precondition() {\n-        return new MyValue3();\n-    }\n-\n-    @Test\n-    public int test3(Object holder) {\n-        \/\/ Don't use MyValue3Holder in the signature, it might trigger class loading\n-        return GetUnresolvedInlineFieldWrongSignature.test3(holder);\n-    }\n-\n-    @Run(test = \"test3\")\n-    public void test3_verifier(RunInfo info) {\n-        if (info.isWarmUp() && !info.isC2CompilationEnabled()) {\n-            test3(null);\n-        } else {\n-            \/\/ Make sure klass is resolved\n-            for (int i = 0; i < 10; ++i) {\n-                MyValue3Holder holder = new MyValue3Holder();\n-                try {\n-                    test3(holder);\n-                    Asserts.fail(\"Should have thrown NoSuchFieldError\");\n-                } catch (NoSuchFieldError e) {\n-                    \/\/ OK\n-                }\n-            }\n-        }\n-    }\n-\n@@ -222,2 +177,4 @@\n-    static final primitive class MyValue4 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue4 {\n+        int foo;\n@@ -231,0 +188,1 @@\n+        @NullRestricted\n@@ -260,2 +218,4 @@\n-    static final primitive class MyValue5 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue5 {\n+        int foo;\n@@ -269,0 +229,1 @@\n+        @NullRestricted\n@@ -303,1 +264,1 @@\n-    \/\/ The inline type field class has been loaded, but the holder class has not been loaded.\n+    \/\/ The value class field class has been loaded, but the holder class has not been loaded.\n@@ -305,1 +266,1 @@\n-    \/\/     getstatic  MyValue6Holder.v:QMyValue1;\n+    \/\/     getstatic  MyValue6Holder.v:LMyValue1;\n@@ -308,1 +269,1 @@\n-    \/\/ MyValue6 has already been loaded, because it's in the InlineType attribute of\n+    \/\/ MyValue6 has already been loaded, because it's in the preload attribute of\n@@ -310,2 +271,4 @@\n-    static final primitive class MyValue6 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue6 {\n+        int foo;\n@@ -319,0 +282,1 @@\n+        @NullRestricted\n@@ -346,1 +310,1 @@\n-    \/\/ Both the inline type field class, and the holder class have not been loaded.\n+    \/\/ Both the value class field class, and the holder class have not been loaded.\n@@ -348,1 +312,1 @@\n-    \/\/     getstatic  MyValue7Holder.v:QMyValue7;\n+    \/\/     getstatic  MyValue7Holder.v:LMyValue7;\n@@ -353,2 +317,4 @@\n-    static final primitive class MyValue7 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue7 {\n+        int foo;\n@@ -362,0 +328,1 @@\n+        @NullRestricted\n@@ -385,2 +352,4 @@\n-    static final primitive class MyValue8 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue8 {\n+        int foo;\n@@ -394,0 +363,1 @@\n+        @NullRestricted\n@@ -426,2 +396,4 @@\n-    static final primitive class MyValue9 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue9 {\n+        int foo;\n@@ -435,0 +407,1 @@\n+        @NullRestricted\n@@ -461,48 +434,0 @@\n-    \/\/ Test case 10:\n-    \/\/ Same as case 4, but with putfield\n-    static final primitive class MyValue10 {\n-        final int foo;\n-\n-        public MyValue10() {\n-            foo = rI;\n-        }\n-    }\n-\n-    static class MyValue10Holder {\n-        MyValue10 v1;\n-        MyValue10 v2;\n-\n-        public MyValue10Holder() {\n-            v1 = new MyValue10();\n-            v2 = new MyValue10();\n-        }\n-    }\n-\n-    static MyValue10 test10_precondition() {\n-        return new MyValue10();\n-    }\n-\n-    @Test\n-    public void test10(Object holder) {\n-        \/\/ Don't use MyValue10Holder in the signature, it might trigger class loading\n-        GetUnresolvedInlineFieldWrongSignature.test10(holder);\n-    }\n-\n-    @Run(test = \"test10\")\n-    public void test10_verifier(RunInfo info) {\n-        if (info.isWarmUp() && !info.isC2CompilationEnabled()) {\n-            test10(null);\n-        } else {\n-            \/\/ Make sure klass is resolved\n-            for (int i = 0; i < 10; ++i) {\n-                MyValue10Holder holder = new MyValue10Holder();\n-                try {\n-                    test10(holder);\n-                    Asserts.fail(\"Should have thrown NoSuchFieldError\");\n-                } catch (NoSuchFieldError e) {\n-                    \/\/ OK\n-                }\n-            }\n-        }\n-    }\n-\n@@ -511,2 +436,4 @@\n-    static final primitive class MyValue11 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue11 {\n+        int foo;\n@@ -520,0 +447,1 @@\n+        @NullRestricted\n@@ -551,2 +479,4 @@\n-    static final primitive class MyValue12 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue12 {\n+        int foo;\n@@ -560,0 +490,1 @@\n+        @NullRestricted\n@@ -592,2 +523,4 @@\n-    static final primitive class MyValue13 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue13 {\n+        int foo;\n@@ -601,0 +534,1 @@\n+        @NullRestricted\n@@ -636,46 +570,0 @@\n-    \/\/ Test case 14:\n-    \/\/ Same as case 10, except storing null\n-    static final primitive class MyValue14 {\n-        final int foo;\n-\n-        public MyValue14() {\n-            foo = rI;\n-        }\n-    }\n-\n-    static class MyValue14Holder {\n-        MyValue14 v;\n-\n-        public MyValue14Holder() {\n-            v = new MyValue14();\n-        }\n-    }\n-\n-    static MyValue14 test14_precondition() {\n-        return new MyValue14();\n-    }\n-\n-    @Test\n-    public void test14(Object holder) {\n-        \/\/ Don't use MyValue14Holder in the signature, it might trigger class loading\n-        GetUnresolvedInlineFieldWrongSignature.test14(holder);\n-    }\n-\n-    @Run(test = \"test14\")\n-    public void test14_verifier(RunInfo info) {\n-        if (info.isWarmUp() && !info.isC2CompilationEnabled()) {\n-            test14(null);\n-        } else {\n-            \/\/ Make sure klass is resolved\n-            for (int i = 0; i < 10; ++i) {\n-                MyValue14Holder holder = new MyValue14Holder();\n-                try {\n-                    test14(holder);\n-                    Asserts.fail(\"Should have thrown NoSuchFieldError\");\n-                } catch (NoSuchFieldError e) {\n-                    \/\/ OK\n-                }\n-            }\n-        }\n-    }\n-\n@@ -684,2 +572,4 @@\n-    static final primitive class MyValue15 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue15 {\n+        int foo;\n@@ -693,0 +583,1 @@\n+        @NullRestricted\n@@ -725,3 +616,3 @@\n-    \/\/ aconst_init with type which is not an inline type\n-    static final class MyValue16 {\n-        final int foo;\n+    \/\/ aconst_init with type which is not a value class\n+    static class MyValue16 {\n+        int foo;\n@@ -762,2 +653,2 @@\n-    static final class MyValue17 {\n-        final int foo;\n+    static class MyValue17 {\n+        int foo;\n@@ -794,2 +685,4 @@\n-    static final primitive class MyValue18 {\n-        final int foo;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue18 {\n+        int foo;\n@@ -803,0 +696,1 @@\n+        @NullRestricted\n@@ -827,3 +721,5 @@\n-    \/\/ Same as test18 but uninitialized (null) static inline type field\n-    static final primitive class MyValue19 {\n-        final int foo;\n+    \/\/ Same as test18 but uninitialized (null) static value class field\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue19 {\n+        int foo;\n@@ -837,0 +733,1 @@\n+        @NullRestricted\n@@ -861,1 +758,1 @@\n-    \/\/ Inline type with object field of unloaded type.\n+    \/\/ Value class with object field of unloaded type.\n@@ -866,1 +763,3 @@\n-    static final primitive class MyValue20 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue20 {\n@@ -885,1 +784,4 @@\n-    static primitive class Test21ClassA {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test21ClassA {\n+        @NullRestricted\n@@ -887,0 +789,1 @@\n+        @NullRestricted\n@@ -890,1 +793,3 @@\n-    static primitive class Test21ClassB {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test21ClassB {\n@@ -894,1 +799,3 @@\n-    static primitive class Test21ClassC {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test21ClassC {\n@@ -898,1 +805,1 @@\n-    \/\/ Test access to static inline type field with unloaded type\n+    \/\/ Test access to static value class field with unloaded type\n@@ -913,1 +820,3 @@\n-    static primitive class Test22ClassA {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test22ClassA {\n@@ -915,0 +824,1 @@\n+        @NullRestricted\n@@ -918,1 +828,3 @@\n-    static primitive class Test22ClassB {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test22ClassB {\n@@ -922,1 +834,1 @@\n-                throw new RuntimeException();\n+                throw new RuntimeException(\"Init failed\");\n@@ -927,1 +839,1 @@\n-    \/\/ Test that load from static field of uninitialized inline type throws an exception\n+    \/\/ Test that load from static field of uninitialized value class throws an exception\n@@ -952,1 +864,3 @@\n-    static primitive class Test23ClassA {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test23ClassA {\n@@ -954,0 +868,1 @@\n+        @NullRestricted\n@@ -957,1 +872,3 @@\n-    static primitive class Test23ClassB {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test23ClassB {\n@@ -960,1 +877,1 @@\n-                throw new RuntimeException();\n+                throw new RuntimeException(\"Init failed\");\n@@ -990,2 +907,5 @@\n-    static primitive class Test24ClassA {\n-        Test24ClassB b = Test24ClassB.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test24ClassA {\n+        @NullRestricted\n+        Test24ClassB b = new Test24ClassB();\n@@ -994,1 +914,3 @@\n-    static primitive class Test24ClassB {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test24ClassB {\n@@ -998,1 +920,1 @@\n-                throw new RuntimeException();\n+                throw new RuntimeException(\"Init failed\");\n@@ -1003,1 +925,1 @@\n-    \/\/ Test that access to non-static field of uninitialized inline type throws an exception\n+    \/\/ Test that access to non-static field of uninitialized value class throws an exception\n@@ -1006,1 +928,1 @@\n-        return Test24ClassA.default.b.x;\n+        return (new Test24ClassA()).b.x;\n@@ -1028,2 +950,5 @@\n-    static primitive class Test25ClassA {\n-        Test25ClassB b = Test25ClassB.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test25ClassA {\n+        @NullRestricted\n+        Test25ClassB b = new Test25ClassB();\n@@ -1032,1 +957,3 @@\n-    static primitive class Test25ClassB {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test25ClassB {\n@@ -1036,1 +963,1 @@\n-                throw new RuntimeException();\n+                throw new RuntimeException(\"Init failed\");\n@@ -1044,1 +971,1 @@\n-        return Test25ClassA.default.b;\n+        return (new Test25ClassA()).b;\n@@ -1067,2 +994,5 @@\n-    static primitive class Test26ClassA {\n-        Test26ClassB b = Test26ClassB.default;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test26ClassA {\n+        @NullRestricted\n+        Test26ClassB b = new Test26ClassB();\n@@ -1071,1 +1001,3 @@\n-    static primitive class Test26ClassB {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Test26ClassB {\n@@ -1074,1 +1006,1 @@\n-                throw new RuntimeException();\n+                throw new RuntimeException(\"Init failed\");\n@@ -1082,1 +1014,1 @@\n-        return Test26ClassA.default.b;\n+        return (new Test26ClassA()).b;\n@@ -1102,2 +1034,4 @@\n-    static final primitive class MyValue27 {\n-        final int foo = rI;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue27 {\n+        int foo = rI;\n@@ -1107,0 +1041,1 @@\n+        @NullRestricted\n@@ -1113,1 +1048,1 @@\n-    \/\/ Test unloaded inline type field load from loaded holder\n+    \/\/ Test unloaded value class field load from loaded holder\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":175,"deletions":240,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -41,1 +41,1 @@\n-primitive class MyPrimitive {\n+value class MyValue1 {\n@@ -44,9 +44,1 @@\n-    public MyPrimitive(int x) {\n-        this.x = x;\n-    }\n-}\n-\n-value class MyValue {\n-    int x;\n-\n-    public MyValue(int x) {\n+    public MyValue1(int x) {\n@@ -59,10 +51,2 @@\n-    static MyPrimitive test1() {\n-        return new MyPrimitive(42);\n-    }\n-\n-    static MyPrimitive.ref test2(boolean b) {\n-        return b ? new MyPrimitive(42) : null;\n-    }\n-\n-    static MyValue test3(boolean b) {\n-        return b ? new MyValue(42) : null;\n+    static MyValue1 test(boolean b) {\n+        return b ? new MyValue1(42) : null;\n@@ -75,7 +59,1 @@\n-    static Object res1 = null;\n-\n-    public static void test1() {\n-        res1 = MyClass.test1();\n-    }\n-\n-    static Object res2 = null;\n+    static Object res = null;\n@@ -83,8 +61,2 @@\n-    public static void test2(boolean b) {\n-        res2 = MyClass.test2(b);\n-    }\n-\n-    static Object res3 = null;\n-\n-    public static void test3(boolean b) {\n-        res3 = MyClass.test3(b);\n+    public static void test(boolean b) {\n+        res = MyClass.test(b);\n@@ -94,8 +66,2 @@\n-        \/\/ C1 compile all caller methods\n-        Method m = TestUnloadedReturnTypes.class.getMethod(\"test1\");\n-        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n-\n-        m = TestUnloadedReturnTypes.class.getMethod(\"test2\", boolean.class);\n-        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n-\n-        m = TestUnloadedReturnTypes.class.getMethod(\"test3\", boolean.class);\n+        \/\/ C1 compile caller method\n+        Method m = TestUnloadedReturnTypes.class.getMethod(\"test\", boolean.class);\n@@ -104,1 +70,1 @@\n-        \/\/ Make sure the callee methods are C2 compiled\n+        \/\/ Make sure the callee method is C2 compiled\n@@ -106,8 +72,1 @@\n-            MyClass.test1();\n-            MyClass.test2((i % 2) == 0);\n-            MyClass.test3((i % 2) == 0);\n-        }\n-\n-        test1();\n-        if (((MyPrimitive)res1).x != 42) {\n-            throw new RuntimeException(\"Test1 failed\");\n+            MyClass.test((i % 2) == 0);\n@@ -116,12 +75,3 @@\n-        test2(true);\n-        if (((MyPrimitive)res2).x != 42) {\n-            throw new RuntimeException(\"Test2 failed\");\n-        }\n-\n-        test2(false);\n-        if (res2 != null) {\n-            throw new RuntimeException(\"Test2 failed\");\n-        }\n-        test3(true);\n-        if (((MyValue)res3).x != 42) {\n-            throw new RuntimeException(\"Test3 failed\");\n+        test(true);\n+        if (((MyValue1)res).x != 42) {\n+            throw new RuntimeException(\"Test failed\");\n@@ -130,3 +80,3 @@\n-        test3(false);\n-        if (res3 != null) {\n-            throw new RuntimeException(\"Test3 failed\");\n+        test(false);\n+        if (res != null) {\n+            throw new RuntimeException(\"Test failed\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedReturnTypes.java","additions":19,"deletions":69,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8247309\n- * @summary Test correct handling of aconst_init bytecode with unresolved inline class.\n- * @compile -XDenablePrimitiveClasses TestUnresolvedDefault.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xcomp -XX:CompileCommand=compileonly,TestUnresolvedDefault::test TestUnresolvedDefault\n- *\/\n-\n-public class TestUnresolvedDefault {\n-\n-    static primitive class UnresolvedInline {\n-        int x = 42;\n-    }\n-\n-    static int test() {\n-        return UnresolvedInline.default.x;\n-    }\n-\n-    static public void main(String[] args) {\n-        test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnresolvedDefault.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary The VM should exit gracefully when unable to resolve an inline type argument\n+ * @summary The VM should exit gracefully when unable to preload an inline type argument\n@@ -29,2 +29,2 @@\n- * @compile -XDenablePrimitiveClasses SimpleInlineType.java TestUnresolvedInlineClass.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses TestUnresolvedInlineClass\n+ * @compile SimpleInlineType.java TestUnresolvedInlineClass.java\n+ * @run main\/othervm -XX:+EnableValhalla TestUnresolvedInlineClass\n@@ -47,1 +47,1 @@\n-            \/\/ Delete SimpleInlineType.class to cause a NoClassDefFoundError\n+            \/\/ Delete SimpleInlineType.class\n@@ -54,1 +54,1 @@\n-            String[] arg = {\"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\", \"-XX:+InlineTypePassFieldsAsArgs\", \"TestUnresolvedInlineClass\", \"run\"};\n+            String[] arg = {\"-XX:+EnableValhalla\", \"-XX:+InlineTypePassFieldsAsArgs\", \"TestUnresolvedInlineClass\", \"run\"};\n@@ -57,2 +57,1 @@\n-            \/\/ Adapter creation for TestUnresolvedInlineClass::test1 should fail with a\n-            \/\/ ClassNotFoundException because the class for argument 'vt' was not found.\n+            \/\/ Verify that a warning is printed\n@@ -60,1 +59,1 @@\n-            oa.shouldContain(\"java.lang.NoClassDefFoundError: SimpleInlineType\");\n+            oa.shouldContain(\"Preloading of class SimpleInlineType during linking of class TestUnresolvedInlineClass (Preload attribute) failed\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnresolvedInlineClass.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,4 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -46,2 +50,3 @@\n- * @compile -XDenablePrimitiveClasses TestValueClasses.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestValueClasses\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestValueClasses.java\n+ * @run main\/othervm\/timeout=300 -XX:+EnableValhalla compiler.valhalla.inlinetypes.TestValueClasses\n@@ -160,1 +165,1 @@\n-    \/\/ Non-primitive Wrapper\n+    \/\/ Non-value class Wrapper\n@@ -326,1 +331,1 @@\n-        Empty2 empty2 = Empty2.default;\n+        Empty2 empty2 = new Empty2();\n@@ -332,1 +337,1 @@\n-        Empty2 empty2 = Empty2.default;\n+        Empty2 empty2 = new Empty2();\n@@ -355,1 +360,1 @@\n-    \/\/ Test scalarization in calls and returns with empty nullable inline types\n+    \/\/ Test scalarization in calls and returns with empty value classes\n@@ -367,1 +372,1 @@\n-        Asserts.assertEQ(test6(Empty1.default), Empty1.default);\n+        Asserts.assertEQ(test6(new Empty1()), new Empty1());\n@@ -383,1 +388,1 @@\n-    \/\/ Test deoptimization at call return with inline type returned in registers\n+    \/\/ Test deoptimization at call return with value object returned in registers\n@@ -405,1 +410,1 @@\n-    \/\/ Test calling a method returning a nullable inline type as fields via reflection\n+    \/\/ Test calling a method returning a value class as fields via reflection\n@@ -447,2 +452,1 @@\n-        Asserts.assertEQ(test10(PrimitiveClass.asPrimaryType(MyValueClass1.class), null), null);\n-        Asserts.assertEQ(test10(PrimitiveClass.asPrimaryType(MyValueClass2.class), null), null);\n+        Asserts.assertEQ(test10(MyValueClass1.class, null), null);\n@@ -451,1 +455,1 @@\n-            test10(PrimitiveClass.asPrimaryType(MyValueClass2.class), testValue1);\n+            test10(MyValueClass2.class, testValue1);\n@@ -470,1 +474,1 @@\n-        Asserts.assertFalse(test12(testValue1, MyValueClass1.default));\n+        Asserts.assertFalse(test12(testValue1, MyValueClass1.createDefaultInline()));\n@@ -485,1 +489,1 @@\n-        Asserts.assertFalse(test13(testValue1, MyValueClass1.default));\n+        Asserts.assertFalse(test13(testValue1, MyValueClass1.createDefaultInline()));\n@@ -593,1 +597,3 @@\n-    static primitive class MyPrimitive17 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyPrimitive17 {\n@@ -602,0 +608,1 @@\n+        @NullRestricted\n@@ -622,1 +629,1 @@\n-    \/\/ Test handling of null when mixing value and primitive classes\n+    \/\/ Test handling of null when mixing nullable and null-restricted fields\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueRematDuringTypeSharpening.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -40,1 +40,1 @@\n-    static primitive class MyValue {\n+    static value class MyValue {\n@@ -44,1 +44,1 @@\n-    static MyValue.ref getNull() {\n+    static MyValue getNull() {\n@@ -54,1 +54,1 @@\n-    static boolean test2(MyValue.ref vt) {\n+    static boolean test2(MyValue vt) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithSpeculativeTypes.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.valhalla.inlinetypes;\n-\n-import jdk.test.lib.Asserts;\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @key randomness\n- * @summary Verify that C1 performs escape analysis before optimizing withfield bytecode to putfield.\n- * @library \/test\/lib \/\n- * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n- * @build org.openjdk.asmtools.* org.openjdk.asmtools.jasm.*\n- * @run driver org.openjdk.asmtools.JtregDriver jasm -strict TestWithfieldC1Classes.jasm\n- * @compile -XDenablePrimitiveClasses TestWithfieldC1.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestWithfieldC1\n- *\/\n-\n-@ForceCompileClassInitializer\n-public class TestWithfieldC1 {\n-\n-    public static void main(String[] args) {\n-        final Scenario[] scenarios = {\n-                new Scenario(0, \/\/ C1 only\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                        \"-XX:TieredStopAtLevel=1\",\n-                        \"-XX:+TieredCompilation\"),\n-                new Scenario(1, \/\/ C2 only. (Make sure the tests are correctly written)\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                        \"-XX:TieredStopAtLevel=4\",\n-                        \"-XX:-TieredCompilation\"),\n-                new Scenario(2, \/\/ interpreter only\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                        \"-Xint\"),\n-                new Scenario(3, \/\/ Xcomp Only C1.\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                        \"-XX:TieredStopAtLevel=1\",\n-                        \"-XX:+TieredCompilation\",\n-                        \"-Xcomp\"),\n-                new Scenario(4, \/\/ Xcomp Only C2.\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                        \"-XX:TieredStopAtLevel=4\",\n-                        \"-XX:-TieredCompilation\",\n-                        \"-Xcomp\")\n-        };\n-\n-        InlineTypes.getFramework()\n-                   .addScenarios(scenarios)\n-                   .start();\n-    }\n-\n-    static FooValue.ref foo_static;\n-    static FooValue.ref foo_static_arr[] = new FooValue.ref[1];\n-    FooValue.ref foo_instance;\n-\n-    @DontInline\n-    static void set_foo_static_if_null(FooValue v) {\n-        if (foo_static == null) {\n-            foo_static = v;\n-        }\n-    }\n-\n-    static void validate_foo_static_and(FooValue v) {\n-        Asserts.assertEQ(foo_static.x, 1);\n-        Asserts.assertEQ(foo_static.y, 1);\n-        Asserts.assertEQ(v.x, 2);\n-        Asserts.assertEQ(v.y, 2);\n-    }\n-\n-    \/\/ escape with putstatic\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test1() {\n-        return FooValue.test1();\n-    }\n-\n-    @Run(test = \"test1\")\n-    public void test1_verifier() {\n-        FooValue v = test1();\n-        validate_foo_static_and(v);\n-    }\n-\n-    \/\/ escape with putfield\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test2() {\n-        return FooValue.test2(this);\n-    }\n-\n-    @Run(test = \"test2\")\n-    public void test2_verifier() {\n-        foo_instance = null;\n-        FooValue v = test2();\n-        Asserts.assertEQ(foo_instance.x, 1);\n-        Asserts.assertEQ(foo_instance.y, 1);\n-        Asserts.assertEQ(v.x, 2);\n-        Asserts.assertEQ(v.y, 2);\n-    }\n-\n-    \/\/ escape with function call\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test3() {\n-        return FooValue.test3();\n-    }\n-\n-    @Run(test = \"test3\")\n-    public void test3_verifier() {\n-        foo_static = null;\n-        FooValue v = test3();\n-        validate_foo_static_and(v);\n-    }\n-\n-    \/\/ escape and then branch backwards\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test4() {\n-        return FooValue.test4();\n-    }\n-\n-    @Run(test = \"test4\")\n-    public void test4_verifier() {\n-        foo_static = null;\n-        FooValue v = test4();\n-        validate_foo_static_and(v);\n-    }\n-\n-    \/\/ escape using a different local variable\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test5() {\n-        return FooValue.test5();\n-    }\n-\n-    @Run(test = \"test5\")\n-    public void test5_verifier() {\n-        foo_static = null;\n-        FooValue v = test5();\n-        validate_foo_static_and(v);\n-    }\n-\n-    \/\/ escape using aastore\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test6() {\n-        return FooValue.test6();\n-    }\n-\n-    @Run(test = \"test6\")\n-    public void test6_verifier() {\n-        foo_static_arr[0] = null;\n-        FooValue v = test6();\n-        Asserts.assertEQ(foo_static_arr[0].x, 1);\n-        Asserts.assertEQ(foo_static_arr[0].y, 1);\n-        Asserts.assertEQ(v.x, 2);\n-        Asserts.assertEQ(v.y, 2);\n-    }\n-\n-    \/\/ Copying a value into different local slots -- disable withfield optimization\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test7() {\n-        return FooValue.test7();\n-    }\n-\n-    @Run(test = \"test7\")\n-    public void test7_verifier() {\n-        FooValue v = test7();\n-        Asserts.assertEQ(v.x, 1);\n-        Asserts.assertEQ(v.y, 1);\n-    }\n-\n-    \/\/ escape by invoking non-static method\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test8() {\n-        return FooValue.test8();\n-    }\n-\n-    @Run(test = \"test8\")\n-    public void test8_verifier() {\n-        foo_static = null;\n-        FooValue v = test8();\n-        validate_foo_static_and(v);\n-    }\n-\n-    \/\/ duplicate reference with local variables\n-    @Test(compLevel = CompLevel.C1_SIMPLE)\n-    public FooValue test9() {\n-        return FooValue.test9(this);\n-    }\n-\n-    @Run(test = \"test9\")\n-    public void test9_verifier() {\n-        foo_instance = null;\n-        FooValue v = test9();\n-        Asserts.assertEQ(foo_instance.x, 3);\n-        Asserts.assertEQ(foo_instance.y, 3);\n-        Asserts.assertEQ(v.x, 2);\n-        Asserts.assertEQ(v.y, 2);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package compiler\/valhalla\/inlinetypes;\n-\n-public final primitive value class FooValue\n-    version 66:0\n-{\n-    public final Field x:I;\n-    public final Field y:I;\n-\n-    \/\/ escape with putstatic\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test1:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n-        aconst_init FooValue; astore_0;\n-        aload_0; iconst_1; withfield x:I; astore_0;\n-        aload_0; iconst_1; withfield y:I; astore_0;\n-\n-        aload_0; putstatic TestWithfieldC1.foo_static:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n-\n-        aload_0; iconst_2; withfield x:I; astore_0;\n-        aload_0; iconst_2; withfield y:I; astore_0;\n-\n-        aload_0; areturn;\n-    }\n-\n-    \/\/ escape with putfield\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test2:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n-        aconst_init FooValue; astore_1;\n-        aload_1; iconst_1; withfield FooValue.x:I; astore_1;\n-        aload_1; iconst_1; withfield FooValue.y:I; astore_1;\n-\n-        aload_0; aload_1; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n-\n-        aload_1; iconst_2; withfield x:I; astore_1;\n-        aload_1; iconst_2; withfield y:I; astore_1;\n-\n-        aload_1; areturn;\n-    }\n-\n-    \/\/ escape with function call\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test3:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n-        aconst_init FooValue; astore_0;\n-        aload_0; iconst_1; withfield x:I; astore_0;\n-        aload_0; iconst_1; withfield y:I; astore_0;\n-\n-        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n-\n-        aload_0; iconst_2; withfield x:I; astore_0;\n-        aload_0; iconst_2; withfield y:I; astore_0;\n-\n-        aload_0; areturn;\n-    }\n-\n-    \/\/ escape and then branch backwards\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test4:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n-        aconst_init FooValue; astore_0;\n-        iconst_1; istore_1;\n-\n-        loop: stack_frame_type append; locals_map class \"Qcompiler\/valhalla\/inlinetypes\/FooValue;\", int;\n-            \/\/ iterate two times\n-            iload_1; iconst_2; if_icmpgt end;\n-\n-            aload_0; iload_1; withfield x:I; astore_0;\n-            aload_0; iload_1; withfield y:I; astore_0;\n-\n-            aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n-\n-            iinc 1,1; goto loop;\n-\n-        end: stack_frame_type same;\n-            aload_0; areturn;\n-    }\n-\n-    \/\/ escape using a different local variable\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test5:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n-        aconst_init FooValue; astore_0;\n-        aconst_init FooValue; astore_1;\n-        aload_0; astore_1;\n-\n-        aload_0; iconst_1; withfield x:I; astore_0;\n-        aload_0; iconst_1; withfield y:I; astore_0;\n-\n-        aload_0; invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n-\n-        aload_1; iconst_2; withfield x:I; astore_1;\n-        aload_1; iconst_2; withfield y:I; astore_1;\n-\n-        aload_1; areturn;\n-    }\n-\n-    \/\/ escape using aastore\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test6:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 3 locals 1 {\n-        aconst_init FooValue; astore_0;\n-        aload_0; iconst_1; withfield x:I; astore_0;\n-        aload_0; iconst_1; withfield y:I; astore_0;\n-\n-        getstatic TestWithfieldC1.foo_static_arr:\"[Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n-        iconst_0; aload_0; aastore;\n-\n-        aload_0; iconst_2; withfield x:I; astore_0;\n-        aload_0; iconst_2; withfield y:I; astore_0;\n-\n-        aload_0; areturn;\n-    }\n-\n-    \/\/ Copying a value into different local slots -- disable withfield optimization\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test7:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 2 {\n-        aconst_init FooValue; astore_0;\n-        aconst_init FooValue; astore_1;\n-        aload_0; astore_1;\n-\n-        aload_0; iconst_1; withfield x:I; astore_0;\n-        aload_0; iconst_1; withfield y:I; astore_0;\n-\n-        aload_1; iconst_2; withfield x:I; astore_1;\n-        aload_1; iconst_2; withfield y:I; astore_1;\n-\n-        aload_0; areturn;\n-    }\n-\n-    \/\/ escape by invoking non-static method\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test8:\"()Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 1 {\n-        aconst_init FooValue; astore_0;\n-        aload_0; iconst_1; withfield x:I; astore_0;\n-        aload_0; iconst_1; withfield y:I; astore_0;\n-\n-        aload_0; invokevirtual non_static_method:\"()V\";\n-\n-        aload_0; iconst_2; withfield x:I; astore_0;\n-        aload_0; iconst_2; withfield y:I; astore_0;\n-\n-        aload_0; areturn;\n-    }\n-\n-    @+compiler\/lib\/ir_framework\/DontInline{}\n-    private Method non_static_method:\"()V\" stack 1 {\n-        aload_0;\n-        invokestatic TestWithfieldC1.set_foo_static_if_null:\"(Qcompiler\/valhalla\/inlinetypes\/FooValue;)V\";\n-        return;\n-    }\n-\n-    \/\/ duplicate reference with local variables\n-    @+compiler\/lib\/ir_framework\/ForceInline{}\n-    static Method test9:\"(Lcompiler\/valhalla\/inlinetypes\/TestWithfieldC1;)Qcompiler\/valhalla\/inlinetypes\/FooValue;\" stack 2 locals 3 {\n-        aconst_init FooValue; astore_1;\n-        aload_1; iconst_1; withfield x:I; astore_1;\n-        aload_1; iconst_1; withfield y:I; astore_1;\n-\n-        aload_1; astore_2;\n-\n-        aload_1; iconst_2; withfield x:I; astore_1;\n-        aload_1; iconst_2; withfield y:I; astore_1;\n-\n-        aload_2; iconst_3; withfield x:I; astore_2;\n-        aload_2; iconst_3; withfield y:I; astore_2;\n-\n-        aload_0; aload_2; putfield TestWithfieldC1.foo_instance:\"Lcompiler\/valhalla\/inlinetypes\/FooValue;\";\n-\n-        aload_1; areturn;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1Classes.jasm","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Test that GenZ uses correct array copy stub for flat primitive clone arrays when expanding ArrayCopyNode.\n+ * @summary Test that GenZ uses correct array copy stub for flat value class arrays when expanding ArrayCopyNode.\n@@ -30,2 +30,5 @@\n- * @compile -XDenablePrimitiveClasses TestWrongFlatArrayCopyStubWithZGC.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xbatch -XX:+UseZGC -XX:-ZGenerational\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED TestWrongFlatArrayCopyStubWithZGC.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:+UseZGC -XX:-ZGenerational\n+ *                   --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *                   --add-exports java.base\/jdk.internal.value=ALL-UNNAMED\n@@ -42,0 +45,5 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -45,1 +53,1 @@\n-        ValueWithLong[] arrWithLong = new ValueWithLong[3];\n+        ValueWithLong[] arrWithLong = (ValueWithLong[])ValueClass.newNullRestrictedArray(ValueWithLong.class, 3);\n@@ -58,1 +66,1 @@\n-        ValueWithOop[] arrWithOop = new ValueWithOop[2];\n+        ValueWithOop[] arrWithOop = (ValueWithOop[])ValueClass.newNullRestrictedArray(ValueWithOop.class, 2);\n@@ -80,3 +88,4 @@\n-\n-final primitive class ValueWithLong {\n-    final long l;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class ValueWithLong {\n+    long l;\n@@ -89,2 +98,4 @@\n-final primitive class ValueWithOop {\n-    final Object v;\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class ValueWithOop {\n+    Object v;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWrongFlatArrayCopyStubWithZGC.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -34,1 +36,1 @@\n- * @summary Test that field flattening works as expected if primitive classes of\n+ * @summary Test that field flattening works as expected if value classes of\n@@ -36,1 +38,0 @@\n- * @modules java.base\/jdk.internal.value\n@@ -39,1 +40,2 @@\n- * @compile -XDenablePrimitiveClasses ValueOnBootclasspath.java InstallBootstrapClasses.java TestBootClassloader.java\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\n+ *          --add-exports java.base\/jdk.internal.value=ALL-UNNAMED ValueOnBootclasspath.java InstallBootstrapClasses.java TestBootClassloader.java\n@@ -42,2 +44,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses InstallBootstrapClasses\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm -XX:+EnableValhalla InstallBootstrapClasses\n+ * @run main\/othervm -XX:+EnableValhalla\n@@ -53,1 +55,4 @@\n-    static primitive class Wrapper1 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Wrapper1 {\n+        @NullRestricted\n@@ -65,1 +70,4 @@\n-    static primitive class Wrapper2 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Wrapper2 {\n+        @NullRestricted\n@@ -92,1 +100,1 @@\n-        Method method = TestBootClassloader.class.getDeclaredMethod(\"test1\", PrimitiveClass.asValueType(Wrapper1.class));\n+        Method method = TestBootClassloader.class.getDeclaredMethod(\"test1\", Wrapper1.class);\n@@ -96,1 +104,1 @@\n-        method = TestBootClassloader.class.getDeclaredMethod(\"test2\", PrimitiveClass.asValueType(Wrapper2.class));\n+        method = TestBootClassloader.class.getDeclaredMethod(\"test2\", Wrapper2.class);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/bootstrap\/TestBootClassloader.java","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n@@ -29,1 +32,3 @@\n-public primitive class ValueOnBootclasspath {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public value class ValueOnBootclasspath {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/bootstrap\/ValueOnBootclasspath.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    static primitive class MyValue16 {\n+    static value class MyValue16 {\n@@ -72,1 +72,1 @@\n-    static primitive class MyValue17 {\n+    static value class MyValue17 {\n@@ -78,15 +78,0 @@\n-    static int test3(Object holder) {\n-        if (holder != null) {\n-            \/\/ Don't use MyValue3Holder in the signature, it might trigger class loading\n-            return ((TestUnloadedInlineTypeField.MyValue3Holder)holder).v.foo + 3;\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n-    static void test10(Object holder) {\n-        if (holder != null) {\n-            \/\/ Don't use MyValue10Holder in the signature, it might trigger class loading\n-            ((TestUnloadedInlineTypeField.MyValue10Holder)holder).v1 = ((TestUnloadedInlineTypeField.MyValue10Holder)holder).v2;\n-        }\n-    }\n@@ -101,7 +86,0 @@\n-    static void test14(Object holder) {\n-        if (holder != null) {\n-            \/\/ Don't use MyValue14Holder in the signature, it might trigger class loading\n-            ((TestUnloadedInlineTypeField.MyValue14Holder)holder).v = null;\n-        }\n-    }\n-\n@@ -117,1 +95,1 @@\n-            return TestUnloadedInlineTypeField.MyValue16.default;\n+            return new TestUnloadedInlineTypeField.MyValue16();\n@@ -125,1 +103,1 @@\n-            return TestUnloadedInlineTypeField.MyValue17.default;\n+            return new TestUnloadedInlineTypeField.MyValue17();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/hack\/GetUnresolvedInlineFieldWrongSignature.java","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-    jmethodID mid = (*env)->GetMethodID(env, cls, \"test1\", \"(Qcompiler\/valhalla\/inlinetypes\/MyValue1;Z)Qcompiler\/valhalla\/inlinetypes\/MyValue1;\");\n+    jmethodID mid = (*env)->GetMethodID(env, cls, \"test1\", \"(Lcompiler\/valhalla\/inlinetypes\/MyValue1;Z)Lcompiler\/valhalla\/inlinetypes\/MyValue1;\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/libTestJNICalls.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}