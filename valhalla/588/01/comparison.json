{"files":[{"patch":"@@ -2169,1 +2169,0 @@\n-        assert(!tag_at(idx).is_Qdescriptor_klass(), \"Failed to encode QDesc\");\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -886,1 +886,1 @@\n-  write_u2(ik()->access_flags().get_flags() & JVM_RECOGNIZED_CLASS_MODIFIERS);\n+  write_u2(ik()->access_flags().get_flags() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_INLINE));\n@@ -1003,0 +1003,1 @@\n+      case Bytecodes::_withfield       :  \/\/ fall through\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2244,0 +2244,2 @@\n+      case Bytecodes::_defaultvalue   : \/\/ fall through\n+      case Bytecodes::_withfield      : \/\/ fall through\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-  compiler\/valhalla\n+  compiler\/valhalla \\\n+  serviceability\/jvmti\/Valhalla\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,1 +116,2 @@\n-    valhalla\n+    valhalla \\\n+    java\/lang\/instrument\/valhalla\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,537 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8274800\n+ * @library \/test\/lib\n+ * @library ..\/..\/..\/..\/com\/sun\/jdi\n+ * @summary [lworld] Primitive classes can't be retransformed\n+ * @modules java.instrument\n+ * @run driver RedefinePrimitive master\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.RuntimeException;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.Instrumentation;\n+import java.security.ProtectionDomain;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.regex.Pattern;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import lib.jdb.ClassTransformer;\n+\n+\n+primitive class MyPrimitive {\n+\n+    long sum() {\n+        \/\/ This adds a number of new entries in the beginning of the CP\n+        \/\/ and this causes CP mapping during class redefinition.\n+        \/\/ @2 uncomment System.out.println(RedefinePrimitive.class);\n+        return x + z;\n+    }\n+    public MyPrimitive(int x, long z) {\n+        this.x = x;\n+        this.y = String.valueOf(x);\n+        this.z = z;\n+        \/\/ @1 uncomment z2 = z+1;\n+    }\n+\n+    public static MyPrimitive create(int x, long z) {\n+        return new MyPrimitive(x,z);\n+    }\n+\n+    int x;\n+    public String y;\n+    public long z;\n+    \/\/ @1 uncomment long z2;\n+\n+    void method1(CountDownLatch ready, Object wait) {\n+        ready.countDown();\n+        try {\n+            synchronized (wait) {\n+                wait.wait();\n+            }\n+        } catch (InterruptedException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+}\n+\n+primitive   \/\/ @1 commentout\n+class TestClass2 {\n+    public TestClass2(int x) {\n+        this.x = x;\n+    }\n+    int x;\n+}\n+\n+\/\/ @1 uncomment primitive\n+class TestClass3 {\n+    public TestClass3(int x) {\n+        this.x = x;\n+    }\n+    int x;\n+}\n+\n+class InlineHolder {\n+    MyPrimitive primField;\n+    InlineHolder() {\n+        primField = new MyPrimitive(8, 12);\n+    }\n+}\n+\n+public class RedefinePrimitive {\n+\n+    private static Instrumentation inst;\n+\n+    private static final ToolProvider JAR = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() -> new RuntimeException(\"ToolProvider for jar not found\"));\n+\n+    static class MyTransformer implements ClassFileTransformer {\n+        private Test test;\n+        Exception exceptionThrown;\n+\n+        public MyTransformer(Test t) {\n+            test = t;\n+        }\n+\n+        public byte[] transform(ClassLoader loader, String className,\n+                                Class classBeingRedefined, ProtectionDomain protectionDomain,\n+                                byte[] classfileBuffer) throws IllegalClassFormatException {\n+            byte[] result = null;\n+            if (className.equals(test.className)) {\n+                log(\">>transform, class=\" + className);\n+                try {\n+                    result = test.transform(className, classfileBuffer);\n+                } catch (Exception ex) {\n+                    exceptionThrown = ex;\n+                    log(\"Exception thrown by test.transform:\");\n+                    ex.printStackTrace();\n+                }\n+                log(\"<<transform, class=\" + className);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static void premain(String agentArgs, Instrumentation inst1) throws Exception {\n+        inst = inst1;\n+    }\n+\n+    private static void buildAgent() {\n+        try {\n+            ClassFileInstaller.main(\"RedefinePrimitive\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Could not write agent classfile\", e);\n+        }\n+\n+        try (PrintWriter pw = new PrintWriter(\"MANIFEST.MF\")) {\n+            pw.println(\"Premain-Class: RedefinePrimitive\");\n+            \/\/pw.println(\"Agent-Class: RedefinePrimitive\");\n+            \/\/pw.println(\"Can-Redefine-Classes: true\");\n+            pw.println(\"Can-Retransform-Classes: true\");\n+        } catch (FileNotFoundException e) {\n+            throw new RuntimeException(\"Could not write manifest file for the agent\", e);\n+        }\n+\n+        if (JAR.run(System.out, System.err, \"-cmf\", \"MANIFEST.MF\", \"redefineagent.jar\", \"RedefinePrimitive.class\") != 0) {\n+            throw new RuntimeException(\"Could not write the agent jar file\");\n+        }\n+    }\n+\n+    private static File getClassFile(String className) {\n+        return new File(System.getProperty(\"test.classes\", \".\"), className + \".class\");\n+    }\n+\n+    private static byte[] loadClassBytes(File f) throws IOException {\n+        log(\"Reading test class from \" + f);\n+        return Files.readAllBytes(f.toPath());\n+    }\n+\n+    private static byte[] loadClassBytes(String className) throws IOException {\n+        return loadClassBytes(new File(System.getProperty(\"test.classes\", \".\"), className + \".class\"));\n+    }\n+\n+    private static void compareClassBytes(String className, byte[] expected, byte[] actual) throws Exception {\n+        log(\"comparing class bytes for class \" + className);\n+        if (Arrays.equals(expected, actual)) {\n+            log(\"identical\");\n+        } else {\n+            log(\"class bytes mismatch\");\n+            File redefinedFile = new File(className + \"_redefined.class\");\n+            try (FileOutputStream stream = new FileOutputStream(redefinedFile)) {\n+                stream.write(actual);\n+                log(\".class saved to \" + redefinedFile);\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                throw new RuntimeException(ex);\n+            }\n+\n+            compareClassFiles(getClassFile(className), redefinedFile);\n+        }\n+    }\n+\n+    private static List<String> disassembleClassFile(File file) throws Exception {\n+        JDKToolLauncher javap = JDKToolLauncher.create(\"javap\")\n+                .addToolArg(\"-c\")\n+                .addToolArg(\"-s\")\n+                .addToolArg(\"-verbose\")\n+                .addToolArg(file.toString());\n+        ProcessBuilder pb = new ProcessBuilder(javap.getCommand());\n+        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n+        return out.asLines();\n+    }\n+\n+    private static final String[] expectedDifferentStrings = {\n+            \"^Classfile .+$\",\n+            \"^[\\\\s]+SHA-256 checksum .[^\\\\s]+$\"\n+    };\n+\n+    private static boolean expectedDifferent(String line) {\n+        for (String s: expectedDifferentStrings) {\n+            Pattern p = Pattern.compile(s);\n+            if (p.matcher(line).find()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void compareClassFiles(File original, File redefined) throws Exception {\n+        log(\"Disassembly difference (\" + original + \" vs \" + redefined+\"):\");\n+        \/\/ compare javap output for the class files\n+        List<String> out1 = disassembleClassFile(original);\n+        List<String> out2 = disassembleClassFile(redefined);\n+\n+        boolean different = false;\n+        boolean orderChanged = false;\n+        int lineNum = 0;\n+        for (String line: out1) {\n+            if (!expectedDifferent(line)) {\n+                if (!out2.contains(line)) {\n+                    different = true;\n+                    log(\"< (\" + (lineNum + 1) + \") \" + line);\n+                } else {\n+                    if (lineNum < out2.size() && out1.get(lineNum) != out2.get(lineNum)) {\n+                        \/\/ out2 contains line, but at different position\n+                        orderChanged = true;\n+                    }\n+                }\n+            }\n+            lineNum++;\n+        }\n+        lineNum = 0;\n+        for (String line: out2) {\n+            if (!expectedDifferent(line)) {\n+                if (!out1.contains(line)) {\n+                    different = true;\n+                    log(\"> (\" + (lineNum + 1) + \") \" + line);\n+                }\n+            }\n+            lineNum++;\n+        }\n+        if (different || orderChanged) {\n+            log(\"original:\");\n+            log(\"-------------------\");\n+            for (String line: out1) {\n+                log(line);\n+            }\n+            log(\"===================\");\n+            log(\"-------------------\");\n+            log(\"redefined:\");\n+            for (String line: out2) {\n+                log(line);\n+            }\n+            log(\"===================\");\n+        }\n+        \/\/ accordingly the spec orderChanged is fine\n+        if (different) {\n+            throw new Exception(\"classfile bytes mismatch\");\n+        } else if (orderChanged) {\n+            log(\"classfile bytes are different - only order changed\");\n+        }\n+    }\n+\n+    public static String getPropOpt(String prop) {\n+        String propVal = System.getProperty(prop);\n+        if (propVal == null) propVal = \"\";\n+        System.out.println(prop + \": '\" + propVal  + \"'\");\n+        return \"-D\" + prop + \"=\" + propVal;\n+    }\n+\n+    private static void log(Object msg) {\n+        System.out.println(String.valueOf(msg));\n+        System.out.flush();\n+    }\n+\n+    public static void main(String argv[]) throws Exception {\n+        if (argv.length == 1 && argv[0].equals(\"master\")) {\n+            buildAgent();\n+\n+            for (int i = 0; i < tests.length; i++) {\n+                log(\"Starting \" + tests[i].name + \"...\");\n+                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                        \"-javaagent:redefineagent.jar\",\n+                        getPropOpt(\"test.jdk\"),\n+                        getPropOpt(\"test.classes\"),\n+                        getPropOpt(\"test.java.opts\"),\n+                        getPropOpt(\"test.vm.opts\"),\n+                        getPropOpt(\"test.src\"),\n+                        \"RedefinePrimitive\", String.valueOf(i));\n+                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+                output.shouldNotContain(\"processing of -javaagent failed\");\n+                output.shouldHaveExitValue(0);\n+                log(\"test stdout: [\" + output.getStdout() + \"]\");\n+                log(\"test stderr: [\" + output.getStderr() + \"]\");\n+                log(\"\");\n+            }\n+        } else {\n+            int i = Integer.parseInt(argv[0]);\n+            Test t = tests[i];\n+            t.run();\n+        }\n+   }\n+\n+\n+    private static final String SOURCE_FILE = \"RedefinePrimitive.java\";\n+    private static class Test {\n+        String name;\n+        String className;\n+        boolean transformErrorExpected;\n+\n+        public Test(String name, String className) {\n+            this.name = name;\n+            this.className = className;\n+            transformErrorExpected = false;\n+        }\n+\n+        public void prologue() throws Exception {}\n+        public byte[] transform(String className, byte[] classBytes) throws Exception { return null; }\n+        public void epilogue() throws Exception {}\n+\n+        public void run() throws Exception {\n+            log(\">>main (\" + name + \")\");\n+\n+            Class theClass = Class.forName(className);\n+\n+            MyTransformer transformer = new MyTransformer(this);\n+            inst.addTransformer(transformer, true);\n+\n+            prologue();\n+\n+            try {\n+                log(\">>retransformClasses (\" + className + \")\");\n+                inst.retransformClasses(theClass);\n+                log(\"<<retransformClasses (\" + className + \")\");\n+\n+                if (transformErrorExpected) {\n+                    throw new Exception(\"retransformClasses is expected to fail, but no exception thrown\");\n+                }\n+            } catch (Exception ex) {\n+                if (transformErrorExpected) {\n+                    log(\"retransformClasses is expected to fail, got exception:\");\n+                    ex.printStackTrace(System.out);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+            if (transformer.exceptionThrown != null) {\n+                throw transformer.exceptionThrown;\n+            }\n+\n+            inst.removeTransformer(transformer);\n+\n+            epilogue();\n+\n+            log(\"<<main (\" + name + \")\");\n+        }\n+    }\n+\n+    private static Test[] tests = {\n+            new Test(\"Reconstituter sanity\", \"MyPrimitive\") {\n+                byte[] savedClassBytes;\n+                @Override\n+                public void prologue() {\n+                }\n+\n+                @Override\n+                public byte[] transform(String className, byte[] classBytes) {\n+                    savedClassBytes = classBytes;\n+                    return null;\n+                }\n+\n+                @Override\n+                public void epilogue() throws Exception {\n+                    compareClassBytes(className, loadClassBytes(className), savedClassBytes);\n+                }\n+            },\n+\n+            new Test(\"Class in in use\", \"MyPrimitive\") {\n+                CountDownLatch ready;\n+                Object wait;\n+\n+                @Override\n+                public void prologue() throws Exception {\n+                    MyPrimitive o1 = new MyPrimitive(2, 5);\n+                    CountDownLatch ready = new CountDownLatch(1);\n+                    wait = new Object();\n+\n+                    Thread t = new Thread(\n+                            () -> {\n+                                log(\">>o1.method1\");\n+                                o1.method1(ready, wait);\n+                                log(\"<<o1.method1\");\n+                            });\n+                    t.setDaemon(true);\n+                    t.start();\n+                    ready.await();\n+                }\n+\n+                @Override\n+                public byte[] transform(String className, byte[] classBytes) {\n+                    return null;\n+                }\n+\n+                @Override\n+                public void epilogue() throws Exception {\n+                    synchronized (wait) {\n+                        wait.notifyAll();\n+                    }\n+                }\n+            },\n+\n+            new Test(\"Redefine primitive with instance\", \"TestClass2\") {\n+                byte[] redefineClassBytes;\n+                @Override\n+                public void prologue() throws Exception {\n+                    transformErrorExpected = true;\n+                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n+                            .transform(1, className);\n+                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n+                }\n+\n+                @Override\n+                public byte[] transform(String className, byte[] classBytes) {\n+                    return redefineClassBytes;\n+                }\n+\n+                @Override\n+                public void epilogue() throws Exception {\n+                }\n+            },\n+\n+            new Test(\"Redefine instance with primitive\", \"TestClass3\") {\n+                byte[] redefineClassBytes;\n+                @Override\n+                public void prologue() throws Exception {\n+                    transformErrorExpected = true;\n+                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n+                            .transform(1, className);\n+                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n+                }\n+\n+                @Override\n+                public byte[] transform(String className, byte[] classBytes) {\n+                    return redefineClassBytes;\n+                }\n+\n+                @Override\n+                public void epilogue() throws Exception {\n+                }\n+            },\n+\n+            new Test(\"Change object size\", \"MyPrimitive\") {\n+                byte[] redefineClassBytes;\n+                @Override\n+                public void prologue() throws Exception {\n+                    transformErrorExpected = true;\n+                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n+                            .transform(1, className);\n+                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n+                }\n+\n+                @Override\n+                public byte[] transform(String className, byte[] classBytes) {\n+                    return redefineClassBytes;\n+                }\n+\n+                @Override\n+                public void epilogue() throws Exception {\n+                }\n+            },\n+\n+            new Test(\"Reconstitute class with inlined field\", \"InlineHolder\") {\n+                byte[] savedClassBytes;\n+                @Override\n+                public void prologue() {\n+                }\n+\n+                @Override\n+                public byte[] transform(String className, byte[] classBytes) {\n+                    savedClassBytes = classBytes;\n+                    return null;\n+                }\n+\n+                @Override\n+                public void epilogue() throws Exception {\n+                    compareClassBytes(className, loadClassBytes(className), savedClassBytes);\n+                }\n+            },\n+\n+            new Test(\"CP mapping\", \"MyPrimitive\") {\n+                byte[] redefineClassBytes;\n+\n+                @Override\n+                public void prologue() throws Exception {\n+                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n+                            .transform(2, className);\n+                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n+                }\n+\n+                @Override\n+                public byte[] transform(String className, byte[] classBytes) {\n+                    \/\/ with wrong mapping retransformClasses() fails with InternalError\n+                    return redefineClassBytes;\n+                }\n+\n+                @Override\n+                public void epilogue() throws Exception {\n+                }\n+            },\n+    };\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/instrument\/valhalla\/RedefinePrimitive.java","additions":537,"deletions":0,"binary":false,"changes":537,"status":"added"}]}