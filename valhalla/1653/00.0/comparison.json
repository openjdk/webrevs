{"files":[{"patch":"@@ -2429,7 +2429,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ b(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1102,2 +1102,6 @@\n-  ss.print(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-           cores_per_cpu(), threads_per_core(),\n+  if (supports_hybrid()) {\n+    ss.print(\"(hybrid)\");\n+  } else {\n+    ss.print(\"(%u cores per cpu, %u threads per core)\", cores_per_cpu(), threads_per_core());\n+  }\n+  ss.print(\" family %d model %d stepping %d microcode 0x%x\",\n@@ -3046,0 +3050,2 @@\n+    if (sef_cpuid7_edx.bits.hybrid != 0)\n+      vm_features.set_feature(CPU_HYBRID);\n@@ -3145,1 +3151,4 @@\n-    result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);\n+    result = _cpuid_info.ext_cpuid8_ecx.bits.threads_per_cpu + 1;\n+    if (cpu_family() >= 0x17) { \/\/ Zen or later\n+      result \/= _cpuid_info.ext_cpuid1E_ebx.bits.threads_per_core + 1;\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -63,1 +63,0 @@\n-#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -751,7 +750,2 @@\n-  return (p != nullptr);\n-}\n-\n-bool ArchiveBuilder::has_been_buffered(address src_addr) const {\n-  if (RegeneratedClasses::has_been_regenerated(src_addr) ||\n-      _src_obj_table.get(src_addr) == nullptr ||\n-      get_buffered_addr(src_addr) == nullptr) {\n+  if (p == nullptr) {\n+    \/\/ This object has never been seen by ArchiveBuilder\n@@ -759,2 +753,19 @@\n-  } else {\n-    return true;\n+  if (p->buffered_addr() == nullptr) {\n+    \/\/ ArchiveBuilder has seen this object, but decided not to archive it. So\n+    \/\/ Any reference to this object will be modified to nullptr inside the buffer.\n+    assert(p->follow_mode() == set_to_null, \"must be\");\n+    return false;\n+  }\n+\n+  DEBUG_ONLY({\n+    \/\/ This is a class\/method that belongs to one of the \"original\" classes that\n+    \/\/ have been regenerated by lambdaFormInvokers.cpp. We must have archived\n+    \/\/ the \"regenerated\" version of it.\n+    if (RegeneratedClasses::has_been_regenerated(src_addr)) {\n+      address regen_obj = RegeneratedClasses::get_regenerated_object(src_addr);\n+      precond(regen_obj != nullptr && regen_obj != src_addr);\n+      assert(has_been_archived(regen_obj), \"must be\");\n+      assert(get_buffered_addr(src_addr) == get_buffered_addr(regen_obj), \"must be\");\n+    }});\n+\n+  return true;\n@@ -1185,418 +1196,0 @@\n-\/\/ Write detailed info to a mapfile to analyze contents of the archive.\n-\/\/ static dump:\n-\/\/   java -Xshare:dump -Xlog:cds+map=trace:file=cds.map:none:filesize=0\n-\/\/ dynamic dump:\n-\/\/   java -cp MyApp.jar -XX:ArchiveClassesAtExit=MyApp.jsa \\\n-\/\/        -Xlog:cds+map=trace:file=cds.map:none:filesize=0 MyApp\n-\/\/\n-\/\/ We need to do some address translation because the buffers used at dump time may be mapped to\n-\/\/ a different location at runtime. At dump time, the buffers may be at arbitrary locations\n-\/\/ picked by the OS. At runtime, we try to map at a fixed location (SharedBaseAddress). For\n-\/\/ consistency, we log everything using runtime addresses.\n-class ArchiveBuilder::CDSMapLogger : AllStatic {\n-  static intx buffer_to_runtime_delta() {\n-    \/\/ Translate the buffers used by the RW\/RO regions to their eventual (requested) locations\n-    \/\/ at runtime.\n-    return ArchiveBuilder::current()->buffer_to_requested_delta();\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_region(const char* name, DumpRegion* region,\n-                                   const ArchiveBuilder::SourceObjList* src_objs) {\n-    address region_base = address(region->base());\n-    address region_top  = address(region->top());\n-    log_region(name, region_base, region_top, region_base + buffer_to_runtime_delta());\n-    log_metaspace_objects(region, src_objs);\n-  }\n-\n-#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n-\n-  static void log_klass(Klass* k, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes, k->external_name());\n-  }\n-  static void log_method(Method* m, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes,  m->external_name());\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_objects(DumpRegion* region, const ArchiveBuilder::SourceObjList* src_objs) {\n-    address last_obj_base = address(region->base());\n-    address last_obj_end  = address(region->base());\n-    address region_end    = address(region->end());\n-    Thread* current = Thread::current();\n-    for (int i = 0; i < src_objs->objs()->length(); i++) {\n-      SourceObjInfo* src_info = src_objs->at(i);\n-      address src = src_info->source_addr();\n-      address dest = src_info->buffered_addr();\n-      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n-      address runtime_dest = dest + buffer_to_runtime_delta();\n-      int bytes = src_info->size_in_bytes();\n-\n-      MetaspaceObj::Type type = src_info->msotype();\n-      const char* type_name = MetaspaceObj::type_name(type);\n-\n-      switch (type) {\n-      case MetaspaceObj::ClassType:\n-        log_klass((Klass*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolType:\n-        log_klass(((ConstantPool*)src)->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolCacheType:\n-        log_klass(((ConstantPoolCache*)src)->constant_pool()->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::MethodType:\n-        log_method((Method*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstMethodType:\n-        log_method(((ConstMethod*)src)->method(), runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::SymbolType:\n-        {\n-          ResourceMark rm(current);\n-          Symbol* s = (Symbol*)src;\n-          log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(runtime_dest), type_name, bytes,\n-                              s->as_quoted_ascii());\n-        }\n-        break;\n-      default:\n-        log_debug(aot, map)(_LOG_PREFIX, p2i(runtime_dest), type_name, bytes);\n-        break;\n-      }\n-\n-      last_obj_base = dest;\n-      last_obj_end  = dest + bytes;\n-    }\n-\n-    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n-    if (last_obj_end < region_end) {\n-      log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n-                          p2i(last_obj_end + buffer_to_runtime_delta()),\n-                          size_t(region_end - last_obj_end));\n-      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n-    }\n-  }\n-\n-#undef _LOG_PREFIX\n-\n-  \/\/ Log information about a region, whose address at dump time is [base .. top). At\n-  \/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n-  \/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n-  \/\/ be accessed with os::read (the header).\n-  \/\/\n-  \/\/ Note: across -Xshare:dump runs, base may be different, but requested_base should\n-  \/\/ be the same as the archive contents should be deterministic.\n-  static void log_region(const char* name, address base, address top, address requested_base) {\n-    size_t size = top - base;\n-    base = requested_base;\n-    if (requested_base == nullptr) {\n-      top = (address)size;\n-    } else {\n-      top = requested_base + size;\n-    }\n-    log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n-                       name, p2i(base), p2i(top), size);\n-  }\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static void log_heap_region(ArchiveHeapInfo* heap_info) {\n-    MemRegion r = heap_info->buffer_region();\n-    address start = address(r.start()); \/\/ start of the current oop inside the buffer\n-    address end = address(r.end());\n-    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n-\n-    LogStreamHandle(Info, aot, map) st;\n-\n-    HeapRootSegments segments = heap_info->heap_root_segments();\n-    assert(segments.base_offset() == 0, \"Sanity\");\n-\n-    for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print_cr(PTR_FORMAT \": Heap roots segment [%d]\",\n-                  p2i(requested_start), segments.size_in_elems(seg_idx));\n-      start += segments.size_in_bytes(seg_idx);\n-    }\n-    log_heap_roots();\n-\n-    while (start < end) {\n-      size_t byte_size;\n-      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n-\n-      if (source_oop != nullptr) {\n-        \/\/ This is a regular oop that got archived.\n-        \/\/ Don't print the requested addr again as we have just printed it at the beginning of the line.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffd27938: @@ Object (0xfffa4f27) java.util.HashMap\n-        print_oop_info_cr(&st, source_oop, \/*print_requested_addr=*\/false);\n-        byte_size = source_oop->size() * BytesPerWord;\n-      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n-        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffc3ffd8: @@ Object filler 40 bytes\n-        st.print_cr(\"filler %zu bytes\", byte_size);\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-\n-      address oop_end = start + byte_size;\n-      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n-\n-      if (source_oop != nullptr) {\n-        log_oop_details(heap_info, source_oop, \/*buffered_addr=*\/start);\n-      }\n-      start = oop_end;\n-    }\n-  }\n-\n-  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n-  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n-  \/\/ in _source_obj with their requested addresses using print_oop_info_cr().\n-  class ArchivedFieldPrinter : public FieldClosure {\n-    ArchiveHeapInfo* _heap_info;\n-    outputStream* _st;\n-    oop _source_obj;\n-    address _buffered_addr;\n-  public:\n-    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj, address buffered_addr) :\n-      _heap_info(heap_info), _st(st), _source_obj(src_obj), _buffered_addr(buffered_addr) {}\n-\n-    void do_field(fieldDescriptor* fd) {\n-      _st->print(\" - \");\n-      BasicType ft = fd->field_type();\n-      switch (ft) {\n-      case T_ARRAY:\n-      case T_OBJECT:\n-        {\n-          fd->print_on(_st); \/\/ print just the name and offset\n-          oop obj = _source_obj->obj_field(fd->offset());\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(_st, obj);\n-        }\n-        break;\n-      default:\n-        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n-          print_as_native_pointer(fd);\n-        } else {\n-          fd->print_on_for(_st, cast_to_oop(_buffered_addr)); \/\/ name, offset, value\n-          _st->cr();\n-        }\n-      }\n-    }\n-\n-    void print_as_native_pointer(fieldDescriptor* fd) {\n-      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n-      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n-\n-      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n-      address source_native_ptr = (address)\n-          LP64_ONLY(_source_obj->long_field(fd->offset()))\n-          NOT_LP64( _source_obj->int_field (fd->offset()));\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-\n-      \/\/ The value of the native pointer at runtime.\n-      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n-\n-      \/\/ The address of _source_obj at runtime\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n-      \/\/ The address of this field in the requested space\n-      assert(requested_obj != nullptr, \"Attempting to load field from null oop\");\n-      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n-\n-      fd->print_on(_st);\n-      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n-                    p2i(requested_native_ptr), p2i(requested_field_addr));\n-    }\n-  };\n-\n-  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n-  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop, address buffered_addr) {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      Klass* source_klass = source_oop->klass();\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n-\n-      st.print(\" - klass: \");\n-      source_klass->print_value_on(&st);\n-      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n-      st.cr();\n-\n-      if (source_oop->is_typeArray()) {\n-        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n-      } else if (source_oop->is_objArray()) {\n-        objArrayOop source_obj_array = objArrayOop(source_oop);\n-        for (int i = 0; i < source_obj_array->length(); i++) {\n-          st.print(\" -%4d: \", i);\n-          oop obj = source_obj_array->obj_at(i);\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(&st, obj);\n-        }\n-      } else {\n-        st.print_cr(\" - fields (%zu words):\", source_oop->size());\n-        ArchivedFieldPrinter print_field(heap_info, &st, source_oop, buffered_addr);\n-        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n-\n-        if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-          st.print(\" - signature: \");\n-          print_class_signature_for_mirror(&st, scratch_mirror);\n-          st.cr();\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            oop rr = HeapShared::scratch_resolved_references(InstanceKlass::cast(src_klass)->constants());\n-            st.print(\" - archived_resolved_references: \");\n-            print_oop_info_cr(&st, rr);\n-\n-            \/\/ We need to print the fields in the scratch_mirror, not the original mirror.\n-            \/\/ (if a class is not aot-initialized, static fields in its scratch mirror will be cleared).\n-            assert(scratch_mirror == HeapShared::scratch_java_mirror(src_klass->java_mirror()), \"sanity\");\n-            st.print_cr(\"- ---- static fields (%d):\", java_lang_Class::static_oop_field_count(scratch_mirror));\n-            InstanceKlass::cast(src_klass)->do_local_static_fields(&print_field);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static void print_class_signature_for_mirror(outputStream* st, oop scratch_mirror) {\n-    assert(java_lang_Class::is_instance(scratch_mirror), \"sanity\");\n-    if (java_lang_Class::is_primitive(scratch_mirror)) {\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        BasicType bt = (BasicType)i;\n-        if (!is_reference_type(bt) && scratch_mirror == HeapShared::scratch_java_mirror(bt)) {\n-          oop orig_mirror = Universe::java_mirror(bt);\n-          java_lang_Class::print_signature(orig_mirror, st);\n-          return;\n-        }\n-      }\n-      ShouldNotReachHere();\n-    }\n-    java_lang_Class::print_signature(scratch_mirror, st);\n-  }\n-\n-  static void log_heap_roots() {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n-        st.print(\"roots[%4d]: \", i);\n-        print_oop_info_cr(&st, HeapShared::pending_roots()->at(i));\n-      }\n-    }\n-  }\n-\n-  \/\/ Example output:\n-  \/\/ - The first number is the requested address (if print_requested_addr == true)\n-  \/\/ - The second number is the narrowOop version of the requested address (if UseCompressedOops == true)\n-  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class Ljava\/util\/Array;\n-  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n-  static void print_oop_info_cr(outputStream* st, oop source_oop, bool print_requested_addr = true) {\n-    if (source_oop == nullptr) {\n-      st->print_cr(\"null\");\n-    } else {\n-      ResourceMark rm;\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n-      if (print_requested_addr) {\n-        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n-      }\n-      if (UseCompressedOops) {\n-        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n-      }\n-      if (source_oop->is_array()) {\n-        int array_len = arrayOop(source_oop)->length();\n-        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n-      } else {\n-        st->print(\"%s\", source_oop->klass()->external_name());\n-\n-        if (java_lang_String::is_instance(source_oop)) {\n-          st->print(\" \");\n-          java_lang_String::print(source_oop, st);\n-        } else if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-\n-          st->print(\" \");\n-          print_class_signature_for_mirror(st, scratch_mirror);\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            InstanceKlass* buffered_klass =\n-              ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_klass));\n-            if (buffered_klass->has_aot_initialized_mirror()) {\n-              st->print(\" (aot-inited)\");\n-            }\n-          }\n-        }\n-        st->cr();\n-      }\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-\n-  \/\/ Log all the data [base...top). Pretend that the base address\n-  \/\/ will be mapped to requested_base at run-time.\n-  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n-    assert(top >= base, \"must be\");\n-\n-    LogStreamHandle(Trace, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      int unitsize = sizeof(address);\n-      if (is_heap && UseCompressedOops) {\n-        \/\/ This makes the compressed oop pointers easier to read, but\n-        \/\/ longs and doubles will be split into two words.\n-        unitsize = sizeof(narrowOop);\n-      }\n-      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n-    }\n-  }\n-\n-  static void log_header(FileMapInfo* mapinfo) {\n-    LogStreamHandle(Info, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      mapinfo->print(&lsh);\n-    }\n-  }\n-\n-public:\n-  static void log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n-                  ArchiveHeapInfo* heap_info,\n-                  char* bitmap, size_t bitmap_size_in_bytes) {\n-    log_info(aot, map)(\"%s CDS archive map for %s\", CDSConfig::is_dumping_static_archive() ? \"Static\" : \"Dynamic\", mapinfo->full_path());\n-\n-    address header = address(mapinfo->header());\n-    address header_end = header + mapinfo->header()->header_size();\n-    log_region(\"header\", header, header_end, nullptr);\n-    log_header(mapinfo);\n-    log_as_hex(header, header_end, nullptr);\n-\n-    DumpRegion* rw_region = &builder->_rw_region;\n-    DumpRegion* ro_region = &builder->_ro_region;\n-\n-    log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n-    log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n-\n-    address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n-    log_region(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n-    log_as_hex((address)bitmap, bitmap_end, nullptr);\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (heap_info->is_used()) {\n-      log_heap_region(heap_info);\n-    }\n-#endif\n-\n-    log_info(aot, map)(\"[End of CDS archive map]\");\n-  }\n-}; \/\/ end ArchiveBuilder::CDSMapLogger\n-\n@@ -1642,2 +1235,1 @@\n-    CDSMapLogger::log(this, mapinfo, heap_info,\n-                      bitmap, bitmap_size_in_bytes);\n+    AOTMapLogger::dumptime_log(this, mapinfo, heap_info, bitmap, bitmap_size_in_bytes);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":23,"deletions":431,"binary":false,"changes":454,"status":"modified"},{"patch":"@@ -165,0 +165,38 @@\n+Klass* ArchiveHeapWriter::real_klass_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->klass();\n+  } else if (get_filler_size_at(buffered_addr) > 0) {\n+    return Universe::fillerArrayKlass();\n+  } else {\n+    \/\/ This is one of the root segments\n+    return Universe::objectArrayKlass();\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::size_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->size();\n+  }\n+\n+  size_t nbytes = get_filler_size_at(buffered_addr);\n+  if (nbytes > 0) {\n+    assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+    return nbytes \/ BytesPerWord;\n+  }\n+\n+  address hrs = buffer_bottom();\n+  for (size_t seg_idx = 0; seg_idx < _heap_root_segments.count(); seg_idx++) {\n+    nbytes = _heap_root_segments.size_in_bytes(seg_idx);\n+    if (hrs == buffered_addr) {\n+      assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+      return nbytes \/ BytesPerWord;\n+    }\n+    hrs += nbytes;\n+  }\n+\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n@@ -715,21 +753,0 @@\n-\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n-bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n-  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n-  assert(p != nullptr, \"must be\");\n-\n-  \/\/ requested_field_addr = the address of this field in the requested space\n-  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n-  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n-  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n-\n-  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n-  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n-  size_t start_pos = FileMapInfo::current_info()->heap_ptrmap_start_pos();\n-  if (idx < start_pos) {\n-    return false;\n-  } else {\n-    idx -= start_pos;\n-  }\n-  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n-}\n-\n@@ -770,1 +787,1 @@\n-    guarantee(ArchiveBuilder::current()->has_been_buffered((address)native_ptr),\n+    guarantee(ArchiveBuilder::current()->has_been_archived((address)native_ptr),\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -386,2 +386,1 @@\n-  if (SystemDictionaryShared::is_excluded_class(src_ik)) {\n-    assert(!ArchiveBuilder::current()->has_been_buffered(src_ik), \"sanity\");\n+  if (!ArchiveBuilder::current()->has_been_archived(src_ik)) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -111,0 +112,2 @@\n+\n+  AOTMapLogger::ergo_initialize();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -330,0 +331,18 @@\n+    FileMapInfo *static_mapinfo = FileMapInfo::current_info();\n+    FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n+\n+    if (AOTMapLogger::is_logging_at_bootstrap()) {\n+      \/\/ The map logging needs to be done here, as it requires some stubs on Windows,\n+      \/\/ which are not generated until the end of init_globals().\n+      AOTMapLogger::runtime_log(static_mapinfo, dynamic_mapinfo);\n+    }\n+\n+    \/\/ Close any open file descriptors. However, mmap'ed pages will remain in memory.\n+    static_mapinfo->close();\n+    static_mapinfo->unmap_region(MetaspaceShared::bm);\n+\n+    if (dynamic_mapinfo != nullptr) {\n+      dynamic_mapinfo->close();\n+      dynamic_mapinfo->unmap_region(MetaspaceShared::bm);\n+    }\n+\n@@ -1964,0 +1983,1 @@\n+  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1979,6 +1999,0 @@\n-  \/\/ Close the mapinfo file\n-  static_mapinfo->close();\n-\n-  static_mapinfo->unmap_region(MetaspaceShared::bm);\n-\n-  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1990,2 +2004,0 @@\n-    dynamic_mapinfo->close();\n-    dynamic_mapinfo->unmap_region(MetaspaceShared::bm);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1383,1 +1383,1 @@\n-  SET_ADDRESS(_extrs, ShenandoahRuntime::write_ref_field_pre);\n+  SET_ADDRESS(_extrs, ShenandoahRuntime::write_barrier_pre);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n+  _mutable_data(nullptr),\n@@ -163,3 +163,1 @@\n-  } else {\n-    \/\/ We need unique and valid not null address\n-    assert(_mutable_data == blob_end(), \"sanity\");\n+  assert(_mutable_data != nullptr || _mutable_data_size == 0, \"No mutable data => mutable data size is 0\");\n@@ -175,1 +173,1 @@\n-  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n+  _mutable_data(nullptr),\n@@ -189,0 +187,1 @@\n+  assert(_mutable_data == nullptr && _mutable_data_size == 0, \"invariant\");\n@@ -191,1 +190,0 @@\n-  assert(_mutable_data == blob_end(), \"sanity\");\n@@ -202,1 +200,1 @@\n-    _mutable_data = blob_end(); \/\/ default value\n+    _mutable_data = nullptr;\n@@ -211,11 +209,7 @@\n-  assert(_mutable_data != nullptr, \"should never be null\");\n-  if (_mutable_data != blob_end()) {\n-    os::free(_mutable_data);\n-    _mutable_data = blob_end(); \/\/ Valid not null address\n-    _mutable_data_size = 0;\n-    _relocation_size = 0;\n-  }\n-  if (_oop_maps != nullptr) {\n-    delete _oop_maps;\n-    _oop_maps = nullptr;\n-  }\n+  os::free(_mutable_data);\n+  _mutable_data = nullptr;\n+  _mutable_data_size = 0;\n+  delete _oop_maps;\n+  _oop_maps = nullptr;\n+  _relocation_size = 0;\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1345,2 +1345,2 @@\n-    \/\/ native wrapper does not have read-only data but we need unique not null address\n-    _immutable_data          = blob_end();\n+    \/\/ native wrapper does not have read-only data\n+    _immutable_data          = nullptr;\n@@ -1532,2 +1532,1 @@\n-      \/\/ We need unique not null address\n-      _immutable_data     = blob_end();\n+      _immutable_data     = nullptr;\n@@ -2169,3 +2168,2 @@\n-  if (_pc_desc_container != nullptr) {\n-    delete _pc_desc_container;\n-  }\n+\n+  delete _pc_desc_container;\n@@ -2174,4 +2172,4 @@\n-  if (_immutable_data != blob_end()) {\n-    os::free(_immutable_data);\n-    _immutable_data = blob_end(); \/\/ Valid not null address\n-  }\n+  os::free(_immutable_data);\n+  _immutable_data = nullptr;\n+  _immutable_data_size = 0;\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  thread->timeout()->arm();\n@@ -231,0 +232,1 @@\n+  thread->timeout()->disarm();\n@@ -483,0 +485,1 @@\n+        task->set_next(nullptr);\n@@ -1928,0 +1931,4 @@\n+  if (!thread->init_compilation_timeout()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    Prefetch::write(obj->mark_addr(), 0);\n+    Prefetch::write(obj->base_addr(), oopDesc::mark_offset_in_bytes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -92,0 +93,1 @@\n+  friend class CPUTimeUsage::GC;\n@@ -433,2 +435,0 @@\n-  void log_gc_cpu_time() const;\n-\n@@ -467,2 +467,0 @@\n-  double elapsed_gc_cpu_time() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -253,3 +253,2 @@\n-        const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_Type();\n-        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), \"shenandoah_wb_pre\",\n-                          pre_val, tls);\n+        const TypeFunc *tf = ShenandoahBarrierSetC2::write_barrier_pre_Type();\n+        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), \"shenandoah_wb_pre\", pre_val);\n@@ -273,1 +272,1 @@\n-         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre);\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre);\n@@ -523,2 +522,2 @@\n-const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_Type() {\n-  const Type **fields = TypeTuple::fields(2);\n+const TypeFunc* ShenandoahBarrierSetC2::write_barrier_pre_Type() {\n+  const Type **fields = TypeTuple::fields(1);\n@@ -526,2 +525,1 @@\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n@@ -1111,1 +1109,1 @@\n-    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain_sig()->cnt();\n+    uint cnt = ShenandoahBarrierSetC2::write_barrier_pre_Type()->domain_sig()->cnt();\n@@ -1197,1 +1195,1 @@\n-        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain_sig()->cnt();\n+        uint cnt = ShenandoahBarrierSetC2::write_barrier_pre_Type()->domain_sig()->cnt();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  static const TypeFunc* write_ref_field_pre_Type();\n+  static const TypeFunc* write_barrier_pre_Type();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -653,1 +653,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool);\n+(JNIEnv *env, jobject jcpool);\n@@ -656,1 +656,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -659,1 +659,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -662,1 +662,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -665,1 +665,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -668,1 +668,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -671,1 +671,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -674,1 +674,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -677,1 +677,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -680,1 +680,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -683,1 +683,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -686,1 +686,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -689,1 +689,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -692,1 +692,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -695,1 +695,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -698,1 +698,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -701,1 +701,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -704,1 +704,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -90,0 +91,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -1319,0 +1321,57 @@\n+static void log_cpu_time() {\n+  LogTarget(Info, cpu) cpuLog;\n+  if (!cpuLog.is_enabled()) {\n+    return;\n+  }\n+\n+  const double process_cpu_time = os::elapsed_process_cpu_time();\n+  if (process_cpu_time == 0 || process_cpu_time == -1) {\n+    \/\/ 0 can happen e.g. for short running processes with\n+    \/\/ low CPU utilization\n+    return;\n+  }\n+\n+  const double gc_threads_cpu_time = (double) CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_SEC;\n+  const double gc_vm_thread_cpu_time = (double) CPUTimeUsage::GC::vm_thread() \/ NANOSECS_PER_SEC;\n+  const double gc_string_dedup_cpu_time = (double) CPUTimeUsage::GC::stringdedup() \/ NANOSECS_PER_SEC;\n+  const double gc_cpu_time = (double) gc_threads_cpu_time + gc_vm_thread_cpu_time + gc_string_dedup_cpu_time;\n+\n+  const double elasped_time = os::elapsedTime();\n+  const bool has_error = CPUTimeUsage::Error::has_error();\n+\n+  if (gc_cpu_time < process_cpu_time) {\n+    cpuLog.print(\"=== CPU time Statistics =============================================================\");\n+    if (has_error) {\n+      cpuLog.print(\"WARNING: CPU time sampling reported errors, numbers may be unreliable\");\n+    }\n+    cpuLog.print(\"                                                                            CPUs\");\n+    cpuLog.print(\"                                                               s       %%  utilized\");\n+    cpuLog.print(\"   Process\");\n+    cpuLog.print(\"     Total                        %30.4f  %6.2f  %8.1f\", process_cpu_time, 100.0, process_cpu_time \/ elasped_time);\n+    cpuLog.print(\"     Garbage Collection           %30.4f  %6.2f  %8.1f\", gc_cpu_time, percent_of(gc_cpu_time, process_cpu_time), gc_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       GC Threads                 %30.4f  %6.2f  %8.1f\", gc_threads_cpu_time, percent_of(gc_threads_cpu_time, process_cpu_time), gc_threads_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       VM Thread                  %30.4f  %6.2f  %8.1f\", gc_vm_thread_cpu_time, percent_of(gc_vm_thread_cpu_time, process_cpu_time), gc_vm_thread_cpu_time \/ elasped_time);\n+\n+    if (UseStringDeduplication) {\n+      cpuLog.print(\"       String Deduplication       %30.4f  %6.2f  %8.1f\", gc_string_dedup_cpu_time, percent_of(gc_string_dedup_cpu_time, process_cpu_time), gc_string_dedup_cpu_time \/ elasped_time);\n+    }\n+    cpuLog.print(\"=====================================================================================\");\n+  }\n+}\n+\n+void Universe::before_exit() {\n+  log_cpu_time();\n+  heap()->before_exit();\n+\n+  \/\/ Print GC\/heap related information.\n+  Log(gc, exit) log;\n+  if (log.is_info()) {\n+    LogStream ls_info(log.info());\n+    Universe::print_on(&ls_info);\n+    if (log.is_trace()) {\n+      LogStream ls_trace(log.trace());\n+      MutexLocker mcld(ClassLoaderDataGraph_lock);\n+      ClassLoaderDataGraph::print_on(&ls_trace);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -312,0 +312,2 @@\n+  static void before_exit();\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  friend class AOTMapLogger;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+  inline void* base_addr();\n+  inline const void* base_addr() const;\n+\n@@ -80,1 +83,0 @@\n-  inline markWord* mark_addr() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+void* oopDesc::base_addr() { return this; }\n+const void* oopDesc::base_addr() const { return this; }\n+\n@@ -58,4 +61,0 @@\n-markWord* oopDesc::mark_addr() const {\n-  return (markWord*) &_mark;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -143,13 +143,5 @@\n-static const char* phase_descriptions[] = {\n-#define array_of_labels(name, description) description,\n-       COMPILER_PHASES(array_of_labels)\n-#undef array_of_labels\n-};\n-\n-static const char* phase_names[] = {\n-#define array_of_labels(name, description) #name,\n-       COMPILER_PHASES(array_of_labels)\n-#undef array_of_labels\n-};\n-\n-  public:\n+ private:\n+  static const char* const _phase_descriptions[];\n+  static const char* const _phase_names[];\n+\n+ public:\n@@ -158,1 +150,1 @@\n-    return phase_names[cpt];\n+    return _phase_names[cpt];\n@@ -161,1 +153,1 @@\n-    return phase_descriptions[cpt];\n+    return _phase_descriptions[cpt];\n@@ -163,9 +155,2 @@\n-};\n-static CompilerPhaseType find_phase(const char* str) {\n-  for (int i = 0; i < PHASE_NUM_TYPES; i++) {\n-    if (strcmp(phase_names[i], str) == 0) {\n-      return (CompilerPhaseType)i;\n-    }\n-  }\n-  return PHASE_NONE;\n-}\n+  static CompilerPhaseType find_phase(const char* str);\n+};\n@@ -188,1 +173,1 @@\n-      CompilerPhaseType cpt = find_phase(*iter);\n+      CompilerPhaseType cpt = CompilerPhaseTypeHelper::find_phase(*iter);\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -698,0 +698,5 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n@@ -802,0 +807,6 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -975,0 +986,6 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -1029,0 +1046,5 @@\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -1472,0 +1494,4 @@\n+  if( CC == TypeInt::CC_NE ) {\n+    if( _test == ne ) return TypeInt::ONE;\n+    if( _test == eq ) return TypeInt::ZERO;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2108,1 +2108,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj))\n@@ -2116,1 +2116,1 @@\n-JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jint index))\n@@ -2129,1 +2129,1 @@\n-JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2172,1 +2172,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jint index))\n@@ -2182,1 +2182,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2217,1 +2217,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jint index))\n@@ -2227,1 +2227,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2237,1 +2237,1 @@\n-JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jint index))\n@@ -2262,1 +2262,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jint index))\n@@ -2275,1 +2275,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jint index))\n@@ -2288,1 +2288,1 @@\n-JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jint index))\n@@ -2309,1 +2309,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jint index))\n@@ -2321,1 +2321,1 @@\n-JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jint index))\n@@ -2333,1 +2333,1 @@\n-JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jint index))\n@@ -2345,1 +2345,1 @@\n-JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jint index))\n@@ -2357,1 +2357,1 @@\n-JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jint index))\n@@ -2370,1 +2370,1 @@\n-JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jint index))\n@@ -2385,1 +2385,1 @@\n-JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jint index))\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3049,2 +3049,0 @@\n-            if (bc_case == BC_CASE_LIMIT && (int)bc == 0)\n-              bc = Bytecodes::_illegal;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-     * Returns the unique {@link java.io.Console Console} object associated\n+     * Returns the unique {@link Console Console} object associated\n@@ -245,0 +245,1 @@\n+     * @see Console\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -628,1 +628,1 @@\n-\n+java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java       8365398 generic-all\n@@ -765,5 +765,0 @@\n-sun\/tools\/jstat\/jstatLineCounts1.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts2.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts3.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts4.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -406,2 +406,0 @@\n-                                                   \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                   \"-XX:VerifyArchivedFields=2\", \/\/ make sure archived heap objects are good.\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,1 +443,0 @@\n-        addVerifyArchivedFields(cmd);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}