{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,5 @@\n-    BASIC_ASFLAGS=\"-nologo -c\"\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      BASIC_ASFLAGS=\"-nologo\"\n+    else\n+      BASIC_ASFLAGS=\"-nologo -c\"\n+    fi\n","filename":"make\/autoconf\/flags-other.m4","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -658,2 +658,5 @@\n-    if test \"x$OPENJDK_TARGET_CPU_BITS\" = \"x64\"; then\n-      # On 64 bit windows, the assembler is \"ml64.exe\"\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+      # On Windows aarch64, the assembler is \"armasm64.exe\"\n+      UTIL_LOOKUP_TOOLCHAIN_PROGS(AS, armasm64)\n+    elif test \"x$OPENJDK_TARGET_CPU_BITS\" = \"x64\"; then\n+      # On Windows x64, the assembler is \"ml64.exe\"\n","filename":"make\/autoconf\/toolchain.m4","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -158,0 +158,6 @@\n+      else ifeq ($(TOOLCHAIN_TYPE), microsoft)\n+        ifeq ($(OPENJDK_TARGET_CPU), aarch64)\n+          $1_NON_ASM_EXTENSION_FLAG :=\n+        else\n+          $1_NON_ASM_EXTENSION_FLAG := \"-Ta\"\n+        endif\n@@ -239,1 +245,1 @@\n-\t        $(CC_OUT_OPTION)$$($1_OBJ) -Ta $$($1_SRC_FILE))) \\\n+\t        $(CC_OUT_OPTION)$$($1_OBJ) $$($1_NON_ASM_EXTENSION_FLAG) $$($1_SRC_FILE))) \\\n","filename":"make\/common\/native\/CompileFile.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        \"NumberElements\/lenientMinusSigns\",\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/Bundle.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -847,0 +847,20 @@\n+        \/\/ Lenient parsing\n+        case \"parseLenients\":\n+            if (\"lenient\".equals(attributes.getValue(\"level\"))) {\n+                pushKeyContainer(qName, attributes, attributes.getValue(\"scope\"));\n+            } else {\n+                pushIgnoredContainer(qName);\n+            }\n+            break;\n+\n+        case \"parseLenient\":\n+            \/\/ Use only the lenient minus sign for now\n+            if (currentContainer instanceof KeyContainer kc\n+                && kc.getKey().equals(\"number\")\n+                && attributes.getValue(\"sample\").equals(\"-\")) {\n+                pushStringEntry(qName, attributes, currentNumberingSystem + \"NumberElements\/lenientMinusSigns\");\n+            } else {\n+                pushIgnoredContainer(qName);\n+            }\n+            break;\n+\n@@ -1153,0 +1173,8 @@\n+        case \"parseLenient\":\n+            if (currentContainer instanceof StringEntry se) {\n+                \/\/ Convert to a simple concatenation of lenient minuses\n+                \/\/ e.g. \"[\\-－﹣ ‐‑ ‒ – −⁻₋ ➖]\" -> \"-－﹣‐‑‒–−⁻₋➖\" for the root locale\n+                put(se.getKey(), se.getValue().replaceAll(\"[\\\\[\\\\]\\\\\\\\ ]\", \"\"));\n+            }\n+            break;\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/LDMLParseHandler.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -925,2 +925,4 @@\n-        printConstructor2(out, event, empty);\n-        printCommitMethod(out, event, empty);\n+        if (!event.fields.isEmpty()) {\n+            printConstructor2(out, event, empty);\n+            printCommitMethod(out, event, empty);\n+        }\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -177,1 +177,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -756,1 +756,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2429,7 +2429,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ b(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -180,1 +180,0 @@\n-  Label done, fast_lock, fast_lock_done;\n@@ -187,2 +186,1 @@\n-  const ByteSize obj_offset = BasicObjectLock::obj_offset();\n-  const int mark_offset = BasicLock::displaced_header_offset_in_bytes();\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"Required by atomic instructions\");\n@@ -191,1 +189,1 @@\n-  str(obj, Address(disp_hdr, obj_offset));\n+  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n@@ -202,47 +200,3 @@\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"Required by atomic instructions\");\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    Register t1 = disp_hdr; \/\/ Needs saving, probably\n-    Register t2 = hdr;      \/\/ blow\n-    Register t3 = Rtemp;    \/\/ blow\n-\n-    lightweight_lock(obj \/* obj *\/, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n-    \/\/ Success: fall through\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    \/\/ On MP platforms the next load could return a 'stale' value if the memory location has been modified by another thread.\n-    \/\/ That would be acceptable as ether CAS or slow case path is taken in that case.\n-\n-    \/\/ Must be the first instruction here, because implicit null check relies on it\n-    ldr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n-\n-    tst(hdr, markWord::unlocked_value);\n-    b(fast_lock, ne);\n-\n-    \/\/ Check for recursive locking\n-    \/\/ See comments in InterpreterMacroAssembler::lock_object for\n-    \/\/ explanations on the fast recursive locking check.\n-    \/\/ -1- test low 2 bits\n-    movs(tmp2, AsmOperand(hdr, lsl, 30));\n-    \/\/ -2- test (hdr - SP) if the low two bits are 0\n-    sub(tmp2, hdr, SP, eq);\n-    movs(tmp2, AsmOperand(tmp2, lsr, exact_log2(os::vm_page_size())), eq);\n-    \/\/ If still 'eq' then recursive locking OK\n-    \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n-    str(tmp2, Address(disp_hdr, mark_offset));\n-    b(fast_lock_done, eq);\n-    \/\/ else need slow case\n-    b(slow_case);\n-\n-\n-    bind(fast_lock);\n-    \/\/ Save previous object header in BasicLock structure and update the header\n-    str(hdr, Address(disp_hdr, mark_offset));\n-\n-    cas_for_lock_acquire(hdr, disp_hdr, obj, tmp2, slow_case);\n-\n-    bind(fast_lock_done);\n-  }\n-  bind(done);\n+  Register t1 = disp_hdr; \/\/ Needs saving, probably\n+  Register t2 = hdr;      \/\/ blow\n+  Register t3 = Rtemp;    \/\/ blow\n@@ -250,0 +204,2 @@\n+  lightweight_lock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+  \/\/ Success: fall through\n@@ -255,1 +211,0 @@\n-  Register tmp2 = Rtemp;\n@@ -258,5 +213,0 @@\n-  const ByteSize obj_offset = BasicObjectLock::obj_offset();\n-  const int mark_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n-  Label done;\n-\n@@ -265,1 +215,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n@@ -267,1 +217,3 @@\n-    ldr(obj, Address(disp_hdr, obj_offset));\n+  Register t1 = disp_hdr; \/\/ Needs saving, probably\n+  Register t2 = hdr;      \/\/ blow\n+  Register t3 = Rtemp;    \/\/ blow\n@@ -269,22 +221,2 @@\n-    Register t1 = disp_hdr; \/\/ Needs saving, probably\n-    Register t2 = hdr;      \/\/ blow\n-    Register t3 = Rtemp;    \/\/ blow\n-\n-    lightweight_unlock(obj \/* object *\/, t1, t2, t3, 1 \/* savemask (save t1) *\/,\n-                       slow_case);\n-    \/\/ Success: Fall through\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    \/\/ Load displaced header and object from the lock\n-    ldr(hdr, Address(disp_hdr, mark_offset));\n-    \/\/ If hdr is null, we've got recursive locking and there's nothing more to do\n-    cbz(hdr, done);\n-\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-\n-    \/\/ Restore the object header\n-    cas_for_lock_release(disp_hdr, hdr, obj, tmp2, slow_case);\n-  }\n-  bind(done);\n+  lightweight_unlock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+  \/\/ Success: fall through\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":13,"deletions":81,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  Label fast_lock, done;\n+  Label done;\n@@ -93,36 +93,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_lock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                     1 \/* savemask (save t1) *\/, done);\n-\n-    \/\/ Success: set Z\n-    cmp(Roop, Roop);\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    Register Rmark      = Rscratch2;\n-\n-    ldr(Rmark, Address(Roop, oopDesc::mark_offset_in_bytes()));\n-    tst(Rmark, markWord::unlocked_value);\n-    b(fast_lock, ne);\n-\n-    \/\/ Check for recursive lock\n-    \/\/ See comments in InterpreterMacroAssembler::lock_object for\n-    \/\/ explanations on the fast recursive locking check.\n-    \/\/ -1- test low 2 bits\n-    movs(Rscratch, AsmOperand(Rmark, lsl, 30));\n-    \/\/ -2- test (hdr - SP) if the low two bits are 0\n-    sub(Rscratch, Rmark, SP, eq);\n-    movs(Rscratch, AsmOperand(Rscratch, lsr, exact_log2(os::vm_page_size())), eq);\n-    \/\/ If still 'eq' then recursive locking OK\n-    \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8153107)\n-    str(Rscratch, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    b(done);\n-\n-    bind(fast_lock);\n-    str(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    bool allow_fallthrough_on_failure = true;\n-    bool one_shot = true;\n-    cas_for_lock_acquire(Rmark, Rbox, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);\n-  }\n+  lightweight_lock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                   1 \/* savemask (save t1) *\/, done);\n@@ -130,0 +96,1 @@\n+  cmp(Roop, Roop); \/\/ Success: set Z\n@@ -143,11 +110,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_unlock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                       1 \/* savemask (save t1) *\/, done);\n-\n-    cmp(Roop, Roop); \/\/ Success: Set Z\n-    \/\/ Fall through\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    Register Rmark      = Rscratch2;\n+  lightweight_unlock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                     1 \/* savemask (save t1) *\/, done);\n@@ -155,5 +113,2 @@\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ldr(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ If hdr is null, we've got recursive locking and there's nothing more to do\n-    cmp(Rmark, 0);\n-    b(done, eq);\n+  cmp(Roop, Roop); \/\/ Success: Set Z\n+  \/\/ Fall through\n@@ -161,5 +116,0 @@\n-    \/\/ Restore the object header\n-    bool allow_fallthrough_on_failure = true;\n-    bool one_shot = true;\n-    cas_for_lock_release(Rbox, Rmark, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);\n-  }\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":8,"deletions":58,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -891,12 +891,3 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-  } else {\n-    Label done;\n-\n-    const Register Robj = R2;\n-    const Register Rmark = R3;\n-    assert_different_registers(Robj, Rmark, Rlock, R0, Rtemp);\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n+  const Register Robj = R2;\n+  const Register Rmark = R3;\n+  assert_different_registers(Robj, Rmark, Rlock, R0, Rtemp);\n@@ -904,1 +895,1 @@\n-    Label already_locked, slow_case;\n+  Label done, slow_case;\n@@ -906,2 +897,2 @@\n-    \/\/ Load object pointer\n-    ldr(Robj, Address(Rlock, obj_offset));\n+  \/\/ Load object pointer\n+  ldr(Robj, Address(Rlock, BasicObjectLock::obj_offset()));\n@@ -909,6 +900,6 @@\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(R0, Robj);\n-      ldrb(R0, Address(R0, Klass::misc_flags_offset()));\n-      tst(R0, KlassFlags::_misc_is_value_based_class);\n-      b(slow_case, ne);\n-    }\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(R0, Robj);\n+    ldrb(R0, Address(R0, Klass::misc_flags_offset()));\n+    tst(R0, KlassFlags::_misc_is_value_based_class);\n+    b(slow_case, ne);\n+  }\n@@ -916,67 +907,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ On MP platforms the next load could return a 'stale' value if the memory location has been modified by another thread.\n-      \/\/ That would be acceptable as ether CAS or slow case path is taken in that case.\n-      \/\/ Exception to that is if the object is locked by the calling thread, then the recursive test will pass (guaranteed as\n-      \/\/ loads are satisfied from a store queue if performed on the same processor).\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"must be\");\n-      ldr(Rmark, Address(Robj, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ Test if object is already locked\n-      tst(Rmark, markWord::unlocked_value);\n-      b(already_locked, eq);\n-\n-      \/\/ Save old object->mark() into BasicLock's displaced header\n-      str(Rmark, Address(Rlock, mark_offset));\n-\n-      cas_for_lock_acquire(Rmark, Rlock, Robj, Rtemp, slow_case);\n-\n-      b(done);\n-\n-      \/\/ If we got here that means the object is locked by ether calling thread or another thread.\n-      bind(already_locked);\n-      \/\/ Handling of locked objects: recursive locks and slow case.\n-\n-      \/\/ Fast check for recursive lock.\n-      \/\/\n-      \/\/ Can apply the optimization only if this is a stack lock\n-      \/\/ allocated in this thread. For efficiency, we can focus on\n-      \/\/ recently allocated stack locks (instead of reading the stack\n-      \/\/ base and checking whether 'mark' points inside the current\n-      \/\/ thread stack):\n-      \/\/  1) (mark & 3) == 0\n-      \/\/  2) SP <= mark < SP + os::pagesize()\n-      \/\/\n-      \/\/ Warning: SP + os::pagesize can overflow the stack base. We must\n-      \/\/ neither apply the optimization for an inflated lock allocated\n-      \/\/ just above the thread stack (this is why condition 1 matters)\n-      \/\/ nor apply the optimization if the stack lock is inside the stack\n-      \/\/ of another thread. The latter is avoided even in case of overflow\n-      \/\/ because we have guard pages at the end of all stacks. Hence, if\n-      \/\/ we go over the stack base and hit the stack of another thread,\n-      \/\/ this should not be in a writeable area that could contain a\n-      \/\/ stack lock allocated by that thread. As a consequence, a stack\n-      \/\/ lock less than page size away from SP is guaranteed to be\n-      \/\/ owned by the current thread.\n-      \/\/\n-      \/\/ Note: assuming SP is aligned, we can check the low bits of\n-      \/\/ (mark-SP) instead of the low bits of mark. In that case,\n-      \/\/ assuming page size is a power of 2, we can merge the two\n-      \/\/ conditions into a single test:\n-      \/\/ => ((mark - SP) & (3 - os::pagesize())) == 0\n-\n-      \/\/ (3 - os::pagesize()) cannot be encoded as an ARM immediate operand.\n-      \/\/ Check independently the low bits and the distance to SP.\n-      \/\/ -1- test low 2 bits\n-      movs(R0, AsmOperand(Rmark, lsl, 30));\n-      \/\/ -2- test (mark - SP) if the low two bits are 0\n-      sub(R0, Rmark, SP, eq);\n-      movs(R0, AsmOperand(R0, lsr, exact_log2(os::vm_page_size())), eq);\n-      \/\/ If still 'eq' then recursive locking OK: store 0 into lock record\n-      str(R0, Address(Rlock, mark_offset), eq);\n-\n-      b(done, eq);\n-    }\n+  lightweight_lock(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n+  b(done);\n@@ -984,1 +910,1 @@\n-    bind(slow_case);\n+  bind(slow_case);\n@@ -986,4 +912,3 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-    bind(done);\n-  }\n+  \/\/ Call the runtime routine for slow case\n+  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n+  bind(done);\n@@ -1000,12 +925,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), Rlock);\n-  } else {\n-    Label done, slow_case;\n-\n-    const Register Robj = R2;\n-    const Register Rmark = R3;\n-    assert_different_registers(Robj, Rmark, Rlock, Rtemp);\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n+  Label done, slow_case;\n@@ -1013,27 +927,3 @@\n-    const Register Rzero = zero_register(Rtemp);\n-\n-    \/\/ Load oop into Robj\n-    ldr(Robj, Address(Rlock, obj_offset));\n-\n-    \/\/ Free entry\n-    str(Rzero, Address(Rlock, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-      \/\/ must handle it.\n-      ldr(Rtemp, Address(Rthread, JavaThread::lock_stack_top_offset()));\n-      sub(Rtemp, Rtemp, oopSize);\n-      ldr(Rtemp, Address(Rthread, Rtemp));\n-      cmpoop(Rtemp, Robj);\n-      b(slow_case, ne);\n-\n-      lightweight_unlock(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n-                         1 \/* savemask (save t1) *\/, slow_case);\n-\n-      b(done);\n-\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      \/\/ Load the old header from BasicLock structure\n-      ldr(Rmark, Address(Rlock, mark_offset));\n+  const Register Robj = R2;\n+  const Register Rmark = R3;\n+  assert_different_registers(Robj, Rmark, Rlock, Rtemp);\n@@ -1041,2 +931,2 @@\n-      \/\/ Test for recursion (zero mark in BasicLock)\n-      cbz(Rmark, done);\n+  const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n+  const Register Rzero = zero_register(Rtemp);\n@@ -1044,1 +934,2 @@\n-      bool allow_fallthrough_on_failure = true;\n+  \/\/ Load oop into Robj\n+  ldr(Robj, Address(Rlock, obj_offset));\n@@ -1046,1 +937,2 @@\n-      cas_for_lock_release(Rlock, Rmark, Robj, Rtemp, slow_case, allow_fallthrough_on_failure);\n+  \/\/ Free entry\n+  str(Rzero, Address(Rlock, obj_offset));\n@@ -1048,1 +940,7 @@\n-      b(done, eq);\n+  \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+  \/\/ must handle it.\n+  ldr(Rtemp, Address(Rthread, JavaThread::lock_stack_top_offset()));\n+  sub(Rtemp, Rtemp, oopSize);\n+  ldr(Rtemp, Address(Rthread, Rtemp));\n+  cmpoop(Rtemp, Robj);\n+  b(slow_case, ne);\n@@ -1050,2 +948,3 @@\n-    }\n-    bind(slow_case);\n+  lightweight_unlock(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n+                     1 \/* savemask (save t1) *\/, slow_case);\n+  b(done);\n@@ -1053,3 +952,4 @@\n-    \/\/ Call the runtime routine for slow case.\n-    str(Robj, Address(Rlock, obj_offset)); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), Rlock);\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  str(Robj, Address(Rlock, obj_offset)); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), Rlock);\n@@ -1057,2 +957,1 @@\n-    bind(done);\n-  }\n+  bind(done);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":43,"deletions":144,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -1761,1 +1761,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -1819,1 +1818,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1142,4 +1142,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      log_trace(fastlock)(\"SharedRuntime lock fast\");\n-      __ lightweight_lock(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n-                          0x7 \/* savemask *\/, slow_lock);\n+    log_trace(fastlock)(\"SharedRuntime lock fast\");\n+    __ lightweight_lock(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+                        0x7 \/* savemask *\/, slow_lock);\n@@ -1147,30 +1146,0 @@\n-    } else if (LockingMode == LM_LEGACY) {\n-      const Register mark = tmp;\n-      \/\/ On MP platforms the next load could return a 'stale' value if the memory location has been modified by another thread.\n-      \/\/ That would be acceptable as either CAS or slow case path is taken in that case\n-\n-      __ ldr(mark, Address(sync_obj, oopDesc::mark_offset_in_bytes()));\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-      __ tst(mark, markWord::unlocked_value);\n-      __ b(fast_lock, ne);\n-\n-      \/\/ Check for recursive lock\n-      \/\/ See comments in InterpreterMacroAssembler::lock_object for\n-      \/\/ explanations on the fast recursive locking check.\n-      \/\/ Check independently the low bits and the distance to SP\n-      \/\/ -1- test low 2 bits\n-      __ movs(Rtemp, AsmOperand(mark, lsl, 30));\n-      \/\/ -2- test (hdr - SP) if the low two bits are 0\n-      __ sub(Rtemp, mark, SP, eq);\n-      __ movs(Rtemp, AsmOperand(Rtemp, lsr, exact_log2(os::vm_page_size())), eq);\n-      \/\/ If still 'eq' then recursive locking OK\n-      \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n-      __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(lock_done, eq);\n-      __ b(slow_lock);\n-\n-      __ bind(fast_lock);\n-      __ str(mark, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      __ cas_for_lock_acquire(mark, disp_hdr, sync_obj, Rtemp, slow_lock);\n-    }\n@@ -1229,15 +1198,5 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      log_trace(fastlock)(\"SharedRuntime unlock fast\");\n-      __ lightweight_unlock(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n-                            7 \/* savemask *\/, slow_unlock);\n-      \/\/ Fall through\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ See C1_MacroAssembler::unlock_object() for more comments\n-      __ ldr(sync_obj, Address(sync_handle));\n-\n-      \/\/ See C1_MacroAssembler::unlock_object() for more comments\n-      __ ldr(R2, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n-      __ cbz(R2, unlock_done);\n-\n-      __ cas_for_lock_release(disp_hdr, R2, sync_obj, Rtemp, slow_unlock);\n-    }\n+    log_trace(fastlock)(\"SharedRuntime unlock fast\");\n+    __ lightweight_unlock(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+                          7 \/* savemask *\/, slow_unlock);\n+    \/\/ Fall through\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, R16_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -969,1 +969,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), R0_pre_val, R16_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), R0_pre_val);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1991,0 +1991,1 @@\n+  INSN(vnsrl_wi, 0b1010111, 0b011, 0b101100);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2164,12 +2164,1 @@\n-  __ fmv_x_w(dst, src);\n-\n-  \/\/ preserve the payloads of non-canonical NaNs.\n-  __ srai(dst, dst, 13);\n-  \/\/ preserve the sign bit.\n-  __ srai(tmp, dst, 13);\n-  __ slli(tmp, tmp, 10);\n-  __ mv(t0, 0x3ff);\n-  __ orr(tmp, tmp, t0);\n-\n-  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-  __ andr(dst, dst, tmp);\n+  __ float_to_float16_NaN(dst, src, t0, tmp);\n@@ -2183,1 +2172,1 @@\n-  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path);\n+  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 64, float_to_float16_slow_path);\n@@ -2262,1 +2251,3 @@\n-  VectorRegister tmp = stub.data<2>();\n+  VectorRegister vtmp = stub.data<2>();\n+  assert_different_registers(dst, src, vtmp);\n+\n@@ -2265,0 +2256,1 @@\n+  \/\/ Active elements (NaNs) are marked in v0 mask register.\n@@ -2267,11 +2259,47 @@\n-  \/\/ preserve the payloads of non-canonical NaNs.\n-  __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n-\n-  \/\/ preserve the sign bit.\n-  __ vnsra_wi(tmp, src, 26, Assembler::v0_t);\n-  __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n-  __ mv(t0, 0x3ff);\n-  __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n-\n-  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-  __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+  \/\/  Float (32 bits)\n+  \/\/    Bit:     31        30 to 23          22 to 0\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          | S |     Exponent     |      Mantissa (Fraction)    |\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          1 bit       8 bits                  23 bits\n+  \/\/\n+  \/\/  Float (16 bits)\n+  \/\/    Bit:    15        14 to 10         9 to 0\n+  \/\/          +---+----------------+------------------+\n+  \/\/          | S |    Exponent    |     Mantissa     |\n+  \/\/          +---+----------------+------------------+\n+  \/\/          1 bit      5 bits          10 bits\n+  const int fp_sign_bits = 1;\n+  const int fp32_bits = 32;\n+  const int fp32_mantissa_2nd_part_bits = 9;\n+  const int fp32_mantissa_3rd_part_bits = 4;\n+  const int fp16_exponent_bits = 5;\n+  const int fp16_mantissa_bits = 10;\n+\n+  \/\/ preserve the sign bit and exponent, clear mantissa.\n+  __ vnsra_wi(dst, src, fp32_bits - fp_sign_bits - fp16_exponent_bits, Assembler::v0_t);\n+  __ vsll_vi(dst, dst, fp16_mantissa_bits, Assembler::v0_t);\n+\n+  \/\/ Preserve high order bit of float NaN in the\n+  \/\/ binary16 result NaN (tenth bit); OR in remaining\n+  \/\/ bits into lower 9 bits of binary 16 significand.\n+  \/\/   | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+  \/\/   | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+  \/\/   | (doppel & 0x0000_000f));     \/\/  4 bits\n+  \/\/\n+  \/\/ Check j.l.Float.floatToFloat16 for more information.\n+  \/\/ 10 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x3ff); \/\/ retain first part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 9 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x1ff); \/\/ retain second part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 4 bits\n+  \/\/ Narrow shift is necessary to move data from 32 bits element to 16 bits element in vector register.\n+  __ vnsrl_wi(vtmp, src, 0, Assembler::v0_t);\n+  __ vand_vi(vtmp, vtmp, 0xf, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n@@ -2284,2 +2312,2 @@\n-void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src, VectorRegister vtmp,\n-                                           Register tmp, uint vector_length) {\n+void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src,\n+                                           VectorRegister vtmp, Register tmp, uint vector_length) {\n@@ -2289,1 +2317,1 @@\n-              (dst, src, vtmp, 28, float_to_float16_v_slow_path);\n+              (dst, src, vtmp, 56, float_to_float16_v_slow_path);\n@@ -2296,1 +2324,1 @@\n-  \/\/ replace v_fclass with vmseq_vv as performance optimization.\n+  \/\/ replace v_fclass with vmfne_vv as performance optimization.\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":57,"deletions":29,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -177,1 +177,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -705,1 +705,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5957,0 +5957,56 @@\n+\/\/ Helper routine processing the slow path of NaN when converting float to float16\n+void MacroAssembler::float_to_float16_NaN(Register dst, FloatRegister src,\n+                                          Register tmp1, Register tmp2) {\n+  fmv_x_w(dst, src);\n+\n+  \/\/  Float (32 bits)\n+  \/\/    Bit:     31        30 to 23          22 to 0\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          | S |     Exponent     |      Mantissa (Fraction)    |\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          1 bit       8 bits                  23 bits\n+  \/\/\n+  \/\/  Float (16 bits)\n+  \/\/    Bit:    15        14 to 10         9 to 0\n+  \/\/          +---+----------------+------------------+\n+  \/\/          | S |    Exponent    |     Mantissa     |\n+  \/\/          +---+----------------+------------------+\n+  \/\/          1 bit      5 bits          10 bits\n+  const int fp_sign_bits = 1;\n+  const int fp32_bits = 32;\n+  const int fp32_exponent_bits = 8;\n+  const int fp32_mantissa_1st_part_bits = 10;\n+  const int fp32_mantissa_2nd_part_bits = 9;\n+  const int fp32_mantissa_3rd_part_bits = 4;\n+  const int fp16_exponent_bits = 5;\n+  const int fp16_mantissa_bits = 10;\n+\n+  \/\/ preserve the sign bit and exponent, clear mantissa.\n+  srai(tmp2, dst, fp32_bits - fp_sign_bits - fp16_exponent_bits);\n+  slli(tmp2, tmp2, fp16_mantissa_bits);\n+\n+  \/\/ Preserve high order bit of float NaN in the\n+  \/\/ binary16 result NaN (tenth bit); OR in remaining\n+  \/\/ bits into lower 9 bits of binary 16 significand.\n+  \/\/   | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+  \/\/   | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+  \/\/   | (doppel & 0x0000_000f));     \/\/  4 bits\n+  \/\/\n+  \/\/ Check j.l.Float.floatToFloat16 for more information.\n+  \/\/ 10 bits\n+  int left_shift = fp_sign_bits + fp32_exponent_bits + 32;\n+  int right_shift = left_shift + fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits;\n+  slli(tmp1, dst, left_shift);\n+  srli(tmp1, tmp1, right_shift);\n+  orr(tmp2, tmp2, tmp1);\n+  \/\/ 9 bits\n+  left_shift += fp32_mantissa_1st_part_bits;\n+  right_shift = left_shift + fp32_mantissa_3rd_part_bits;\n+  slli(tmp1, dst, left_shift);\n+  srli(tmp1, tmp1, right_shift);\n+  orr(tmp2, tmp2, tmp1);\n+  \/\/ 4 bits\n+  andi(tmp1, dst, 0xf);\n+  orr(dst, tmp2, tmp1);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1434,0 +1434,3 @@\n+  \/\/ Helper routine processing the slow path of NaN when converting float to float16\n+  void float_to_float16_NaN(Register dst, FloatRegister src, Register tmp1, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8557,1 +8557,1 @@\n-  format %{ \"fmv.h.x $dst, $src\" %}\n+  format %{ \"fmv.h.x $dst, $src\\t# reinterpretS2HF\" %}\n@@ -8577,1 +8577,1 @@\n-  format %{ \"fmv.x.h $dst, $src\" %}\n+  format %{ \"fmv.x.h $dst, $src\\t# reinterpretHF2S\" %}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6360,12 +6360,2 @@\n-    __ fmv_x_w(dst, src);\n-\n-    \/\/ preserve the payloads of non-canonical NaNs.\n-    __ srai(dst, dst, 13);\n-    \/\/ preserve the sign bit.\n-    __ srai(t1, dst, 13);\n-    __ slli(t1, t1, 10);\n-    __ mv(t0, 0x3ff);\n-    __ orr(t1, t1, t0);\n-\n-    \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-    __ andr(dst, dst, t1);\n+\n+    __ float_to_float16_NaN(dst, src, t0, t1);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -167,9 +167,10 @@\n-      __ z_stmg(Z_R6, Z_R14, 16, Z_SP);\n-      __ z_std(Z_F8, 96, Z_SP);\n-      __ z_std(Z_F9, 104, Z_SP);\n-      __ z_std(Z_F10, 112, Z_SP);\n-      __ z_std(Z_F11, 120, Z_SP);\n-      __ z_std(Z_F12, 128, Z_SP);\n-      __ z_std(Z_F13, 136, Z_SP);\n-      __ z_std(Z_F14, 144, Z_SP);\n-      __ z_std(Z_F15, 152, Z_SP);\n+      __ save_return_pc();\n+      __ z_stmg(Z_R6, Z_R13, 16, Z_SP);\n+      __ z_std(Z_F8, 80, Z_SP);\n+      __ z_std(Z_F9, 88, Z_SP);\n+      __ z_std(Z_F10, 96, Z_SP);\n+      __ z_std(Z_F11, 104, Z_SP);\n+      __ z_std(Z_F12, 112, Z_SP);\n+      __ z_std(Z_F13, 120, Z_SP);\n+      __ z_std(Z_F14, 128, Z_SP);\n+      __ z_std(Z_F15, 136, Z_SP);\n@@ -340,9 +341,10 @@\n-      __ z_lmg(Z_R6, Z_R14, 16, Z_SP);\n-      __ z_ld(Z_F8, 96, Z_SP);\n-      __ z_ld(Z_F9, 104, Z_SP);\n-      __ z_ld(Z_F10, 112, Z_SP);\n-      __ z_ld(Z_F11, 120, Z_SP);\n-      __ z_ld(Z_F12, 128, Z_SP);\n-      __ z_ld(Z_F13, 136, Z_SP);\n-      __ z_ld(Z_F14, 144, Z_SP);\n-      __ z_ld(Z_F15, 152, Z_SP);\n+      __ restore_return_pc();\n+      __ z_lmg(Z_R6, Z_R13, 16, Z_SP);\n+      __ z_ld(Z_F8, 80, Z_SP);\n+      __ z_ld(Z_F9, 88, Z_SP);\n+      __ z_ld(Z_F10, 96, Z_SP);\n+      __ z_ld(Z_F11, 104, Z_SP);\n+      __ z_ld(Z_F12, 112, Z_SP);\n+      __ z_ld(Z_F13, 120, Z_SP);\n+      __ z_ld(Z_F14, 128, Z_SP);\n+      __ z_ld(Z_F15, 136, Z_SP);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-    __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), 2);\n+    __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), 1);\n@@ -281,1 +281,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), c_rarg0, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), c_rarg0);\n@@ -949,1 +949,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), rcx, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), rcx);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1102,2 +1102,6 @@\n-  ss.print(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-           cores_per_cpu(), threads_per_core(),\n+  if (supports_hybrid()) {\n+    ss.print(\"(hybrid)\");\n+  } else {\n+    ss.print(\"(%u cores per cpu, %u threads per core)\", cores_per_cpu(), threads_per_core());\n+  }\n+  ss.print(\" family %d model %d stepping %d microcode 0x%x\",\n@@ -3046,0 +3050,2 @@\n+    if (sef_cpuid7_edx.bits.hybrid != 0)\n+      vm_features.set_feature(CPU_HYBRID);\n@@ -3145,1 +3151,4 @@\n-    result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);\n+    result = _cpuid_info.ext_cpuid8_ecx.bits.threads_per_cpu + 1;\n+    if (cpu_family() >= 0x17) { \/\/ Zen or later\n+      result \/= _cpuid_info.ext_cpuid1E_ebx.bits.threads_per_core + 1;\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -202,2 +202,2 @@\n-      uint32_t cores_per_cpu : 8,\n-                             : 24;\n+      uint32_t threads_per_cpu : 8,\n+                               : 24;\n@@ -279,1 +279,2 @@\n-                           : 5,\n+                     hybrid: 1,\n+                           : 4,\n@@ -447,1 +448,2 @@\n-    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n+    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/ \\\n+    decl(HYBRID,            \"hybrid\",            65) \/* Hybrid architecture *\/\n@@ -880,0 +882,1 @@\n+  static bool supports_hybrid()       { return _features.supports_feature(CPU_HYBRID); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compilerThreadTimeout_linux.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"signals_posix.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <pthread.h>\n+\n+#ifdef ASSERT\n+void compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  CompilerThread::current()->timeout()->compiler_signal_handler(signo, info, context);\n+}\n+\n+void CompilerThreadTimeoutLinux::compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  switch (signo) {\n+    case TIMEOUT_SIGNAL: {\n+      CompileTask* task = CompilerThread::current()->task();\n+      const int SIZE = 512;\n+      char method_name_buf[SIZE];\n+      task->method()->name_and_sig_as_C_string(method_name_buf, SIZE);\n+      assert(false, \"compile task %d (%s) timed out after %zd ms\",\n+             task->compile_id(), method_name_buf, CompileTaskTimeout);\n+    }\n+    default: {\n+      assert(false, \"unexpected signal %d\", signo);\n+    }\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+void CompilerThreadTimeoutLinux::arm() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  const intx sec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) \/ NANOSECS_PER_SEC;\n+  const intx nsec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) % NANOSECS_PER_SEC;\n+  const struct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n+  const struct itimerspec its {.it_interval = ts, .it_value = ts};\n+\n+  \/\/ Start the timer.\n+  timer_settime(_timer, 0, &its, nullptr);\n+#endif \/\/ ASSERT\n+}\n+\n+void CompilerThreadTimeoutLinux::disarm() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  \/\/ Reset the timer by setting it to zero.\n+  const struct itimerspec its {\n+    .it_interval = {.tv_sec = 0, .tv_nsec=0},\n+    .it_value = {.tv_sec = 0, .tv_nsec=0}\n+  };\n+  timer_settime(_timer, 0, &its, nullptr);\n+#endif \/\/ ASSERT\n+}\n+\n+bool CompilerThreadTimeoutLinux::init_timeout() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return true;\n+  }\n+\n+  JavaThread* thread = JavaThread::current();\n+\n+  \/\/ Create a POSIX timer sending SIGALRM to this thread only.\n+  sigevent_t sev;\n+  sev.sigev_value.sival_ptr = nullptr;\n+  sev.sigev_signo = TIMEOUT_SIGNAL;\n+  sev.sigev_notify = SIGEV_THREAD_ID;\n+#ifdef MUSL_LIBC\n+  sev.sigev_notify_thread_id = thread->osthread()->thread_id();\n+#else\n+  sev._sigev_un._tid = thread->osthread()->thread_id();\n+#endif \/\/ MUSL_LIBC\n+  clockid_t clock;\n+  int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n+  if (err != 0) {\n+    return false;\n+  }\n+  err = timer_create(clock, &sev, &_timer);\n+  if (err != 0) {\n+    return false;\n+  }\n+\n+  \/\/ Install the signal handler and check that we do not have a conflicting handler.\n+  struct sigaction sigact, sigact_old;\n+  err = PosixSignals::install_sigaction_signal_handler(&sigact,\n+                                                       &sigact_old,\n+                                                       TIMEOUT_SIGNAL,\n+                                                       (sa_sigaction_t)::compiler_signal_handler);\n+  if (err != 0 || (sigact_old.sa_sigaction != sigact.sa_sigaction &&\n+      sigact_old.sa_handler != SIG_DFL && sigact_old.sa_handler != SIG_IGN)) {\n+    return false;\n+  }\n+#endif \/\/ ASSERT\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.cpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+#define LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <csignal>\n+#include <ctime>\n+\n+class CompilerThreadTimeoutLinux : public CHeapObj<mtCompiler> {\n+#ifdef ASSERT\n+ public:\n+  static const int TIMEOUT_SIGNAL = SIGALRM;\n+  void compiler_signal_handler(int signo, siginfo_t* info, void* context);\n+ private:\n+  timer_t          _timer;\n+#endif \/\/ ASSERT\n+ public:\n+  CompilerThreadTimeoutLinux() DEBUG_ONLY(: _timer(nullptr)) {};\n+\n+  bool init_timeout();\n+  void arm();\n+  void disarm();\n+};\n+\n+#endif \/\/LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -92,0 +92,5 @@\n+  develop(intx, CompileTaskTimeout, 0,                                  \\\n+          \"Set the timeout for compile tasks' CPU time in milliseconds.\"\\\n+          \" 0 = no timeout (default)\")                                  \\\n+          range(0,1000000)                                              \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,930 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotMapLogger.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+bool AOTMapLogger::_is_logging_at_bootstrap;\n+bool AOTMapLogger::_is_runtime_logging;\n+intx AOTMapLogger::_buffer_to_requested_delta;\n+intx AOTMapLogger::_requested_to_mapped_metadata_delta;\n+size_t AOTMapLogger::_num_root_segments;\n+size_t AOTMapLogger::_num_obj_arrays_logged;\n+GrowableArrayCHeap<AOTMapLogger::FakeOop, mtClass>* AOTMapLogger::_roots;\n+ArchiveHeapInfo* AOTMapLogger::_dumptime_heap_info;\n+\n+class AOTMapLogger::RequestedMetadataAddr {\n+  address _raw_addr;\n+\n+public:\n+  RequestedMetadataAddr(address raw_addr) : _raw_addr(raw_addr) {}\n+\n+  address raw_addr() const { return _raw_addr; }\n+\n+  Klass* to_real_klass() const {\n+    if (_raw_addr == nullptr) {\n+      return nullptr;\n+    }\n+\n+    if (_is_runtime_logging) {\n+      return (Klass*)(_raw_addr + _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      address buffered_addr = builder->requested_to_buffered(_raw_addr);\n+      address klass = builder->get_source_addr(buffered_addr);\n+      return (Klass*)klass;\n+    }\n+  }\n+}; \/\/ AOTMapLogger::RequestedMetadataAddr\n+\n+void AOTMapLogger::ergo_initialize() {\n+  if (!CDSConfig::is_dumping_archive() && CDSConfig::is_using_archive() && log_is_enabled(Info, aot, map)) {\n+    _is_logging_at_bootstrap = true;\n+    if (FLAG_IS_DEFAULT(ArchiveRelocationMode)) {\n+      FLAG_SET_ERGO(ArchiveRelocationMode, 0);\n+    } else if (ArchiveRelocationMode != 0) {\n+      log_warning(aot, map)(\"Addresses in the AOT map may be incorrect for -XX:ArchiveRelocationMode=%d.\", ArchiveRelocationMode);\n+    }\n+  }\n+}\n+\n+void AOTMapLogger::dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                                ArchiveHeapInfo* heap_info,\n+                                char* bitmap, size_t bitmap_size_in_bytes) {\n+  _is_runtime_logging = false;\n+  _buffer_to_requested_delta =  ArchiveBuilder::current()->buffer_to_requested_delta();\n+  _num_root_segments = mapinfo->heap_root_segments().count();\n+  _dumptime_heap_info = heap_info;\n+\n+  log_file_header(mapinfo);\n+\n+  DumpRegion* rw_region = &builder->_rw_region;\n+  DumpRegion* ro_region = &builder->_ro_region;\n+\n+  dumptime_log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n+  dumptime_log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n+\n+  address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n+  log_region_range(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n+  log_as_hex((address)bitmap, bitmap_end, nullptr);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (heap_info->is_used()) {\n+    dumptime_log_heap_region(heap_info);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of AOT cache map]\");\n+}\n+\n+\/\/ This class is used to find the location and type of all the\n+\/\/ archived metaspace objects.\n+class AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs : public UniqueMetaspaceClosure {\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass> _objs;\n+\n+  static int compare_objs_by_addr(ArchivedObjInfo* a, ArchivedObjInfo* b) {\n+    intx diff = a->_src_addr - b->_src_addr;\n+    if (diff < 0) {\n+      return -1;\n+    } else if (diff == 0) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  }\n+\n+public:\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs() { return &_objs; }\n+\n+  virtual bool do_unique_ref(Ref* ref, bool read_only) {\n+    ArchivedObjInfo info;\n+    info._src_addr = ref->obj();\n+    info._buffered_addr = ref->obj();\n+    info._requested_addr = ref->obj();\n+    info._bytes = ref->size() * BytesPerWord;\n+    info._type = ref->msotype();\n+    _objs.append(info);\n+\n+    return true; \/\/ keep iterating\n+  }\n+\n+  void finish() {\n+    UniqueMetaspaceClosure::finish();\n+    _objs.sort(compare_objs_by_addr);\n+  }\n+}; \/\/ AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo) {\n+  _is_runtime_logging = true;\n+  _requested_to_mapped_metadata_delta = static_mapinfo->relocation_delta();\n+\n+  ResourceMark rm;\n+  RuntimeGatherArchivedMetaspaceObjs gatherer;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    \/\/ The metaspace objects in the AOT cache are stored as a stream of bytes. For space\n+    \/\/ saving, we don't store a complete index that tells us where one object ends and\n+    \/\/ another object starts. There's also no type information.\n+    \/\/\n+    \/\/ However, we can rebuild our index by iterating over all the objects using\n+    \/\/ MetaspaceClosure, starting from the dictionary of Klasses in SystemDictionaryShared.\n+    GrowableArray<Klass*> klasses;\n+    SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/true, &klasses);\n+    if (dynamic_mapinfo != nullptr) {\n+      SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/false, &klasses);\n+    }\n+\n+    for (int i = 0; i < klasses.length(); i++) {\n+      gatherer.push(klasses.adr_at(i));\n+    }\n+    gatherer.finish();\n+  }\n+\n+  runtime_log(static_mapinfo, gatherer.objs());\n+  if (dynamic_mapinfo != nullptr) {\n+    runtime_log(dynamic_mapinfo, gatherer.objs());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  log_file_header(mapinfo);\n+\n+  runtime_log_metaspace_regions(mapinfo, objs);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (mapinfo->has_heap_region() && CDSConfig::is_loading_heap()) {\n+    _num_root_segments = mapinfo->heap_root_segments().count();\n+    runtime_log_heap_region(mapinfo);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of map]\");\n+}\n+\n+void AOTMapLogger::dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                                 const ArchiveBuilder::SourceObjList* src_objs) {\n+  address region_base = address(region->base());\n+  address region_top  = address(region->top());\n+  log_region_range(name, region_base, region_top, region_base + _buffer_to_requested_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    GrowableArrayCHeap<ArchivedObjInfo, mtClass> objs;\n+    for (int i = 0; i < src_objs->objs()->length(); i++) {\n+      ArchiveBuilder::SourceObjInfo* src_info = src_objs->at(i);\n+      ArchivedObjInfo info;\n+      info._src_addr = src_info->source_addr();\n+      info._buffered_addr = src_info->buffered_addr();\n+      info._requested_addr = info._buffered_addr + _buffer_to_requested_delta;\n+      info._bytes = src_info->size_in_bytes();\n+      info._type = src_info->msotype();\n+      objs.append(info);\n+    }\n+\n+    log_metaspace_objects_impl(address(region->base()), address(region->end()), &objs, 0, objs.length());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  FileMapRegion* rw = mapinfo->region_at(MetaspaceShared::rw);\n+  FileMapRegion* ro = mapinfo->region_at(MetaspaceShared::ro);\n+\n+  address rw_base = address(rw->mapped_base());\n+  address rw_end  = address(rw->mapped_end());\n+  address ro_base = address(ro->mapped_base());\n+  address ro_end  = address(ro->mapped_end());\n+\n+  int first_rw_index = -1;\n+  int first_ro_index = -1;\n+  int last_ro_index = -1;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    int i = 0;\n+    for (; i < objs->length(); i++) {\n+      address p = objs->at(i)._src_addr;\n+      if (p < rw_base) {\n+        \/\/ We are printing the dynamic archive but found an object in the static archive\n+        precond(!mapinfo->is_static());\n+        continue;\n+      }\n+      if (first_rw_index < 0) {\n+        first_rw_index = i;\n+        continue;\n+      }\n+      if (p < ro_base) {\n+        continue;\n+      }\n+      if (first_ro_index < 0) {\n+        first_ro_index = i;\n+        continue;\n+      }\n+      if (p < ro_end) {\n+        continue;\n+      } else {\n+        last_ro_index = i;\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (last_ro_index < 0) {\n+    last_ro_index = objs->length();\n+  }\n+\n+  log_region_range(\"rw\", rw_base, rw_end, rw_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(rw_base, rw_end, objs, first_rw_index, first_ro_index);\n+  }\n+\n+  log_region_range(\"ro\", ro_base, ro_end, ro_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(ro_base, ro_end, objs, first_ro_index, last_ro_index);\n+  }\n+}\n+\n+void AOTMapLogger::log_file_header(FileMapInfo* mapinfo) {\n+  const char* type;\n+  if (mapinfo->is_static()) {\n+    if (CDSConfig::new_aot_flags_used()) {\n+      type = \"AOT cache\";\n+    } else {\n+      type = \"Static CDS archive\";\n+    }\n+  } else {\n+    type = \"Dynamic CDS archive\";\n+  }\n+\n+  log_info(aot, map)(\"%s map for %s\", type, mapinfo->full_path());\n+\n+  address header = address(mapinfo->header());\n+  address header_end = header + mapinfo->header()->header_size();\n+\n+  log_region_range(\"header\", header, header_end, nullptr);\n+  LogStreamHandle(Info, aot, map) lsh;\n+  mapinfo->print(&lsh);\n+  log_as_hex(header, header_end, nullptr);\n+}\n+\n+\/\/ Log information about a region, whose address at dump time is [base .. top). At\n+\/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n+\/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n+\/\/ be accessed with os::read (the header).\n+void AOTMapLogger::log_region_range(const char* name, address base, address top, address requested_base) {\n+  size_t size = top - base;\n+  base = requested_base;\n+  if (requested_base == nullptr) {\n+    top = (address)size;\n+  } else {\n+    top = requested_base + size;\n+  }\n+  log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n+                     name, p2i(base), p2i(top), size);\n+}\n+\n+#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n+\n+void AOTMapLogger::log_metaspace_objects_impl(address region_base, address region_end, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs,\n+                                              int start_idx, int end_idx) {\n+  address last_obj_base = region_base;\n+  address last_obj_end  = region_base;\n+  Thread* current = Thread::current();\n+\n+  for (int i = start_idx; i < end_idx; i++) {\n+    ArchivedObjInfo& info = objs->at(i);\n+    address src = info._src_addr;\n+    address buffered_addr = info._buffered_addr;\n+    address requested_addr = info._requested_addr;\n+    int bytes = info._bytes;\n+    MetaspaceObj::Type type = info._type;\n+    const char* type_name = MetaspaceObj::type_name(type);\n+\n+    log_as_hex(last_obj_base, buffered_addr, last_obj_base + _buffer_to_requested_delta);\n+\n+    switch (type) {\n+    case MetaspaceObj::ClassType:\n+      log_klass((Klass*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolType:\n+      log_constant_pool((ConstantPool*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolCacheType:\n+      log_constant_pool_cache((ConstantPoolCache*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstMethodType:\n+      log_const_method((ConstMethod*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::MethodType:\n+      log_method((Method*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::SymbolType:\n+      log_symbol((Symbol*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    default:\n+      log_debug(aot, map)(_LOG_PREFIX, p2i(requested_addr), type_name, bytes);\n+      break;\n+    }\n+\n+    last_obj_base = buffered_addr;\n+    last_obj_end  = buffered_addr + bytes;\n+  }\n+\n+  log_as_hex(last_obj_base, last_obj_end, last_obj_base + _buffer_to_requested_delta);\n+  if (last_obj_end < region_end) {\n+    log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n+                        p2i(last_obj_end + _buffer_to_requested_delta),\n+                        size_t(region_end - last_obj_end));\n+    log_as_hex(last_obj_end, region_end, last_obj_end + _buffer_to_requested_delta);\n+  }\n+}\n+\n+void AOTMapLogger::log_constant_pool(ConstantPool* cp, address requested_addr,\n+                                     const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cp->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                           const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cpc->constant_pool()->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_const_method(ConstMethod* cm, address requested_addr, const char* type_name,\n+                                    int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  cm->method()->external_name());\n+}\n+\n+void AOTMapLogger::log_klass(Klass* k, address requested_addr, const char* type_name,\n+                             int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes, k->external_name());\n+}\n+\n+void AOTMapLogger::log_method(Method* m, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  m->external_name());\n+}\n+\n+void AOTMapLogger::log_symbol(Symbol* s, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      s->as_quoted_ascii());\n+}\n+\n+#undef _LOG_PREFIX\n+\n+\/\/ Log all the data [base...top). Pretend that the base address\n+\/\/ will be mapped to requested_base at run-time.\n+void AOTMapLogger::log_as_hex(address base, address top, address requested_base, bool is_heap) {\n+  assert(top >= base, \"must be\");\n+\n+  LogStreamHandle(Trace, aot, map) lsh;\n+  if (lsh.is_enabled()) {\n+    int unitsize = sizeof(address);\n+    if (is_heap && UseCompressedOops) {\n+      \/\/ This makes the compressed oop pointers easier to read, but\n+      \/\/ longs and doubles will be split into two words.\n+      unitsize = sizeof(narrowOop);\n+    }\n+    os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n+  }\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\/\/ FakeOop (and subclasses FakeMirror, FakeString, FakeObjArray, FakeTypeArray) are used to traverse\n+\/\/ and print the (image of) heap objects stored in the AOT cache. These objects are different than regular oops:\n+\/\/ - They do not reside inside the range of the heap.\n+\/\/ - For +UseCompressedOops: pointers may use a different narrowOop encoding: see FakeOop::read_oop_at(narrowOop*)\n+\/\/ - For -UseCompressedOops: pointers are not direct: see FakeOop::read_oop_at(oop*)\n+\/\/\n+\/\/ Hence, in general, we cannot use regular oop API (such as oopDesc::obj_field()) on these objects. There\n+\/\/ are a few rare case where regular oop API work, but these are all guarded with the raw_oop() method and\n+\/\/ should be used with care.\n+class AOTMapLogger::FakeOop {\n+  static int _requested_shift;\n+  static intx _buffer_to_requested_delta;\n+  static address _buffer_start;\n+  static address _buffer_end;\n+  static uint64_t _buffer_start_narrow_oop; \/\/ The encoded narrow oop for the objects at _buffer_start\n+\n+  address _buffer_addr;\n+\n+  static void assert_range(address buffer_addr) {\n+    assert(_buffer_start <= buffer_addr && buffer_addr < _buffer_end, \"range check\");\n+  }\n+\n+  address* field_addr(int field_offset) {\n+    return (address*)(_buffer_addr + field_offset);\n+  }\n+\n+protected:\n+  RequestedMetadataAddr metadata_field(int field_offset) {\n+    return RequestedMetadataAddr(*(address*)(field_addr(field_offset)));\n+  }\n+\n+  \/\/ Return an \"oop\" pointer so we can use APIs that accept regular oops. This\n+  \/\/ must be used with care, as only a limited number of APIs can work with oops that\n+  \/\/ live outside of the range of the heap.\n+  oop raw_oop() { return cast_to_oop(_buffer_addr); }\n+\n+public:\n+  static void init_globals(address requested_base, address requested_start, int requested_shift,\n+                           address buffer_start, address buffer_end) {\n+    _requested_shift = requested_shift;\n+    _buffer_to_requested_delta = requested_start - buffer_start;\n+    _buffer_start = buffer_start;\n+    _buffer_end = buffer_end;\n+\n+    precond(requested_start >= requested_base);\n+    if (UseCompressedOops) {\n+      _buffer_start_narrow_oop = (uint64_t)(pointer_delta(requested_start, requested_base, 1)) >> _requested_shift;\n+      assert(_buffer_start_narrow_oop < 0xffffffff, \"sanity\");\n+    } else {\n+      _buffer_start_narrow_oop = 0xdeadbeed;\n+    }\n+  }\n+\n+  FakeOop() : _buffer_addr(nullptr) {}\n+\n+  FakeOop(address buffer_addr) : _buffer_addr(buffer_addr) {\n+    if (_buffer_addr != nullptr) {\n+      assert_range(_buffer_addr);\n+    }\n+  }\n+\n+  FakeMirror& as_mirror();\n+  FakeObjArray& as_obj_array();\n+  FakeString& as_string();\n+  FakeTypeArray& as_type_array();\n+\n+  RequestedMetadataAddr klass() {\n+    address rk = (address)real_klass();\n+    if (_is_runtime_logging) {\n+      return RequestedMetadataAddr(rk - _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      return builder->to_requested(builder->get_buffered_addr(rk));\n+    }\n+  }\n+\n+  Klass* real_klass() {\n+    assert(UseCompressedClassPointers, \"heap archiving requires UseCompressedClassPointers\");\n+    if (_is_runtime_logging) {\n+      return raw_oop()->klass();\n+    } else {\n+      return ArchiveHeapWriter::real_klass_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  \/\/ in heap words\n+  size_t size() {\n+    if (_is_runtime_logging) {\n+      return raw_oop()->size_given_klass(real_klass());\n+    } else {\n+      return ArchiveHeapWriter::size_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  bool is_array() { return real_klass()->is_array_klass(); }\n+  bool is_null() { return _buffer_addr == nullptr; }\n+\n+  int array_length() {\n+    precond(is_array());\n+    return arrayOop(raw_oop())->length();\n+  }\n+\n+  address requested_addr() {\n+    return _buffer_addr + _buffer_to_requested_delta;\n+  }\n+\n+  uint32_t as_narrow_oop_value() {\n+    precond(UseCompressedOops);\n+    if (_buffer_addr == nullptr) {\n+      return 0;\n+    }\n+    uint64_t pd = (uint64_t)(pointer_delta(_buffer_addr, _buffer_start, 1));\n+    return checked_cast<uint32_t>(_buffer_start_narrow_oop + (pd >> _requested_shift));\n+  }\n+\n+  FakeOop read_oop_at(narrowOop* addr) { \/\/ +UseCompressedOops\n+    uint64_t n = (uint64_t)(*addr);\n+    if (n == 0) {\n+      return FakeOop(nullptr);\n+    } else {\n+      precond(n >= _buffer_start_narrow_oop);\n+      address value = _buffer_start + ((n - _buffer_start_narrow_oop) << _requested_shift);\n+      return FakeOop(value);\n+    }\n+  }\n+\n+  FakeOop read_oop_at(oop* addr) { \/\/ -UseCompressedOops\n+    address requested_value = cast_from_oop<address>(*addr);\n+    if (requested_value == nullptr) {\n+      return FakeOop(nullptr);\n+    } else {\n+      return FakeOop(requested_value - _buffer_to_requested_delta);\n+    }\n+  }\n+\n+  FakeOop obj_field(int field_offset) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_oop()->field_addr<narrowOop>(field_offset));\n+    } else {\n+      return read_oop_at(raw_oop()->field_addr<oop>(field_offset));\n+    }\n+  }\n+\n+  void print_non_oop_field(outputStream* st, fieldDescriptor* fd) {\n+    \/\/ fd->print_on_for() works for non-oop fields in fake oops\n+    precond(fd->field_type() != T_ARRAY && fd->field_type() != T_OBJECT);\n+    fd->print_on_for(st, raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeOop\n+\n+class AOTMapLogger::FakeMirror : public AOTMapLogger::FakeOop {\n+public:\n+  void print_class_signature_on(outputStream* st);\n+\n+  Klass* real_mirrored_klass() {\n+    RequestedMetadataAddr mirrored_klass = metadata_field(java_lang_Class::klass_offset());\n+    return mirrored_klass.to_real_klass();\n+  }\n+\n+  int static_oop_field_count() {\n+    return java_lang_Class::static_oop_field_count(raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeMirror\n+\n+class AOTMapLogger::FakeObjArray : public AOTMapLogger::FakeOop {\n+  objArrayOop raw_objArrayOop() {\n+    return (objArrayOop)raw_oop();\n+  }\n+\n+public:\n+  int length() {\n+    return raw_objArrayOop()->length();\n+  }\n+  FakeOop obj_at(int i) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<narrowOop>(i));\n+    } else {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<oop>(i));\n+    }\n+  }\n+}; \/\/ AOTMapLogger::FakeObjArray\n+\n+class AOTMapLogger::FakeString : public AOTMapLogger::FakeOop {\n+public:\n+  bool is_latin1() {\n+    jbyte coder = raw_oop()->byte_field(java_lang_String::coder_offset());\n+    assert(CompactStrings || coder == java_lang_String::CODER_UTF16, \"Must be UTF16 without CompactStrings\");\n+    return coder == java_lang_String::CODER_LATIN1;\n+  }\n+\n+  FakeTypeArray value();\n+\n+  int length();\n+  void print_on(outputStream* st, int max_length = MaxStringPrintSize);\n+}; \/\/ AOTMapLogger::FakeString\n+\n+class AOTMapLogger::FakeTypeArray : public AOTMapLogger::FakeOop {\n+  typeArrayOop raw_typeArrayOop() {\n+    return (typeArrayOop)raw_oop();\n+  }\n+\n+public:\n+  void print_elements_on(outputStream* st) {\n+    TypeArrayKlass::cast(real_klass())->oop_print_elements_on(raw_typeArrayOop(), st);\n+  }\n+\n+  int length() { return raw_typeArrayOop()->length(); }\n+  jbyte byte_at(int i) { return raw_typeArrayOop()->byte_at(i); }\n+  jchar char_at(int i) { return raw_typeArrayOop()->char_at(i); }\n+}; \/\/ AOTMapLogger::FakeTypeArray\n+\n+AOTMapLogger::FakeMirror& AOTMapLogger::FakeOop::as_mirror() {\n+  precond(real_klass() == vmClasses::Class_klass());\n+  return (FakeMirror&)*this;\n+}\n+\n+AOTMapLogger::FakeObjArray& AOTMapLogger::FakeOop::as_obj_array() {\n+  precond(real_klass()->is_objArray_klass());\n+  return (FakeObjArray&)*this;\n+}\n+\n+AOTMapLogger::FakeTypeArray& AOTMapLogger::FakeOop::as_type_array() {\n+  precond(real_klass()->is_typeArray_klass());\n+  return (FakeTypeArray&)*this;\n+}\n+\n+AOTMapLogger::FakeString& AOTMapLogger::FakeOop::as_string() {\n+  precond(real_klass() == vmClasses::String_klass());\n+  return (FakeString&)*this;\n+}\n+\n+void AOTMapLogger::FakeMirror::print_class_signature_on(outputStream* st) {\n+  ResourceMark rm;\n+  RequestedMetadataAddr requested_klass = metadata_field(java_lang_Class::klass_offset());\n+  Klass* real_klass = requested_klass.to_real_klass();\n+\n+  if (real_klass == nullptr) {\n+    \/\/ This is a primitive mirror (Java expressions of int.class, long.class, void.class, etc);\n+    RequestedMetadataAddr requested_array_klass = metadata_field(java_lang_Class::array_klass_offset());\n+    Klass* real_array_klass = requested_array_klass.to_real_klass();\n+    if (real_array_klass == nullptr) {\n+      st->print(\" V\"); \/\/ The special mirror for void.class that doesn't have any representation in C++\n+    } else {\n+      precond(real_array_klass->is_typeArray_klass());\n+      st->print(\" %c\", real_array_klass->name()->char_at(1));\n+    }\n+  } else {\n+    const char* class_name = real_klass->name()->as_C_string();\n+    if (real_klass->is_instance_klass()) {\n+      st->print(\" L%s;\", class_name);\n+    } else {\n+      st->print(\" %s\", class_name);\n+    }\n+    if (real_klass->has_aot_initialized_mirror()) {\n+      st->print(\" (aot-inited)\");\n+    }\n+  }\n+}\n+\n+AOTMapLogger::FakeTypeArray AOTMapLogger::FakeString::value() {\n+  return obj_field(java_lang_String::value_offset()).as_type_array();\n+}\n+\n+int AOTMapLogger::FakeString::length() {\n+  FakeTypeArray v = value();\n+  if (v.is_null()) {\n+    return 0;\n+  }\n+  int arr_length = v.length();\n+  if (!is_latin1()) {\n+    assert((arr_length & 1) == 0, \"should be even for UTF16 string\");\n+    arr_length >>= 1; \/\/ convert number of bytes to number of elements\n+  }\n+  return arr_length;\n+}\n+\n+void AOTMapLogger::FakeString::print_on(outputStream* st, int max_length) {\n+  FakeTypeArray v = value();\n+  int length = this->length();\n+  bool is_latin1 = this->is_latin1();\n+  bool abridge = length > max_length;\n+\n+  st->print(\"\\\"\");\n+  for (int index = 0; index < length; index++) {\n+    \/\/ If we need to abridge and we've printed half the allowed characters\n+    \/\/ then jump to the tail of the string.\n+    if (abridge && index >= max_length \/ 2) {\n+      st->print(\" ... (%d characters ommitted) ... \", length - 2 * (max_length \/ 2));\n+      index = length - (max_length \/ 2);\n+      abridge = false; \/\/ only do this once\n+    }\n+    jchar c = (!is_latin1) ?  v.char_at(index) :\n+                             ((jchar) v.byte_at(index)) & 0xff;\n+    if (c < ' ') {\n+      st->print(\"\\\\x%02X\", c); \/\/ print control characters e.g. \\x0A\n+    } else {\n+      st->print(\"%c\", c);\n+    }\n+  }\n+  st->print(\"\\\"\");\n+\n+  if (length > max_length) {\n+    st->print(\" (abridged) \");\n+  }\n+}\n+\n+class AOTMapLogger::ArchivedFieldPrinter : public FieldClosure {\n+  FakeOop _fake_oop;\n+  outputStream* _st;\n+public:\n+  ArchivedFieldPrinter(FakeOop fake_oop, outputStream* st) : _fake_oop(fake_oop), _st(st) {}\n+\n+  void do_field(fieldDescriptor* fd) {\n+    _st->print(\" - \");\n+    BasicType ft = fd->field_type();\n+    switch (ft) {\n+    case T_ARRAY:\n+    case T_OBJECT:\n+      {\n+        fd->print_on(_st); \/\/ print just the name and offset\n+        FakeOop field_value = _fake_oop.obj_field(fd->offset());\n+        print_oop_info_cr(_st, field_value);\n+      }\n+      break;\n+    default:\n+      _fake_oop.print_non_oop_field(_st, fd); \/\/ name, offset, value\n+      _st->cr();\n+    }\n+  }\n+}; \/\/ AOTMapLogger::ArchivedFieldPrinter\n+\n+int AOTMapLogger::FakeOop::_requested_shift;\n+intx AOTMapLogger::FakeOop::_buffer_to_requested_delta;\n+address AOTMapLogger::FakeOop::_buffer_start;\n+address AOTMapLogger::FakeOop::_buffer_end;\n+uint64_t AOTMapLogger::FakeOop::_buffer_start_narrow_oop;\n+\n+void AOTMapLogger::dumptime_log_heap_region(ArchiveHeapInfo* heap_info) {\n+  MemRegion r = heap_info->buffer_region();\n+  address buffer_start = address(r.start()); \/\/ start of the current oop inside the buffer\n+  address buffer_end = address(r.end());\n+\n+  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)ArchiveHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_start = UseCompressedOops ? ArchiveHeapWriter::buffered_addr_to_requested_addr(buffer_start) : requested_base;\n+  int requested_shift =  CompressedOops::shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::runtime_log_heap_region(FileMapInfo* mapinfo) {\n+  ResourceMark rm;\n+  int heap_region_index = MetaspaceShared::hp;\n+  FileMapRegion* r = mapinfo->region_at(heap_region_index);\n+  size_t alignment = ObjectAlignmentInBytes;\n+\n+  \/\/ Allocate a buffer and read the image of the archived heap region. This buffer is outside\n+  \/\/ of the real Java heap, so we must use FakeOop to access the contents of the archived heap objects.\n+  char* buffer = resource_allocate_bytes(r->used() + alignment);\n+  address buffer_start = (address)align_up(buffer, alignment);\n+  address buffer_end = buffer_start + r->used();\n+  if (!mapinfo->read_region(heap_region_index, (char*)buffer_start, r->used(), \/* do_commit = *\/ false)) {\n+    log_error(aot)(\"Cannot read heap region; AOT map logging of heap objects failed\");\n+    return;\n+  }\n+\n+  address requested_base = UseCompressedOops ? (address)mapinfo->narrow_oop_base() : mapinfo->heap_region_requested_address();\n+  address requested_start = requested_base + r->mapping_offset();\n+  int requested_shift = mapinfo->narrow_oop_shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::log_oops(address buffer_start, address buffer_end) {\n+  LogStreamHandle(Debug, aot, map) st;\n+  if (!st.is_enabled()) {\n+    return;\n+  }\n+\n+  _roots = new GrowableArrayCHeap<FakeOop, mtClass>();\n+  _num_obj_arrays_logged = 0;\n+\n+  for (address fop = buffer_start; fop < buffer_end; ) {\n+    FakeOop fake_oop(fop);\n+    st.print(PTR_FORMAT \": @@ Object \", p2i(fake_oop.requested_addr()));\n+    print_oop_info_cr(&st, fake_oop, \/*print_requested_addr=*\/false);\n+\n+    LogStreamHandle(Trace, aot, map, oops) trace_st;\n+    if (trace_st.is_enabled()) {\n+      print_oop_details(fake_oop, &trace_st);\n+    }\n+\n+    address next_fop = fop + fake_oop.size() * BytesPerWord;\n+    log_as_hex(fop, next_fop, fake_oop.requested_addr(), \/*is_heap=*\/true);\n+\n+    fop = next_fop;\n+  }\n+\n+  delete _roots;\n+}\n+\n+void AOTMapLogger::print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr) {\n+  if (fake_oop.is_null()) {\n+    st->print_cr(\"null\");\n+  } else {\n+    ResourceMark rm;\n+    Klass* real_klass = fake_oop.real_klass();\n+    address requested_addr = fake_oop.requested_addr();\n+    if (print_requested_addr) {\n+      st->print(PTR_FORMAT \" \", p2i(requested_addr));\n+    }\n+    if (UseCompressedOops) {\n+      st->print(\"(0x%08x) \", fake_oop.as_narrow_oop_value());\n+    }\n+    if (fake_oop.is_array()) {\n+      int array_len = fake_oop.array_length();\n+      st->print_cr(\"%s length: %d\", real_klass->external_name(), array_len);\n+    } else {\n+      st->print(\"%s\", real_klass->external_name());\n+\n+      if (real_klass == vmClasses::String_klass()) {\n+        st->print(\" \");\n+        fake_oop.as_string().print_on(st);\n+      } else if (real_klass == vmClasses::Class_klass()) {\n+        fake_oop.as_mirror().print_class_signature_on(st);\n+      }\n+\n+      st->cr();\n+    }\n+  }\n+}\n+\n+\/\/ Print the fields of instanceOops, or the elements of arrayOops\n+void AOTMapLogger::print_oop_details(FakeOop fake_oop, outputStream* st) {\n+  Klass* real_klass = fake_oop.real_klass();\n+\n+  st->print(\" - klass: \");\n+  real_klass->print_value_on(st);\n+  st->print(\" \" PTR_FORMAT, p2i(fake_oop.klass().raw_addr()));\n+  st->cr();\n+\n+  if (real_klass->is_typeArray_klass()) {\n+    fake_oop.as_type_array().print_elements_on(st);\n+  } else if (real_klass->is_objArray_klass()) {\n+    FakeObjArray fake_obj_array = fake_oop.as_obj_array();\n+    bool is_logging_root_segment = _num_obj_arrays_logged < _num_root_segments;\n+\n+    for (int i = 0; i < fake_obj_array.length(); i++) {\n+      FakeOop elm = fake_obj_array.obj_at(i);\n+      if (is_logging_root_segment) {\n+        st->print(\" root[%4d]: \", _roots->length());\n+        _roots->append(elm);\n+      } else {\n+        st->print(\" -%4d: \", i);\n+      }\n+      print_oop_info_cr(st, elm);\n+    }\n+    _num_obj_arrays_logged ++;\n+  } else {\n+    st->print_cr(\" - fields (%zu words):\", fake_oop.size());\n+\n+    ArchivedFieldPrinter print_field(fake_oop, st);\n+    InstanceKlass::cast(real_klass)->print_nonstatic_fields(&print_field);\n+\n+    if (real_klass == vmClasses::Class_klass()) {\n+      FakeMirror fake_mirror = fake_oop.as_mirror();\n+\n+      st->print(\" - signature: \");\n+      fake_mirror.print_class_signature_on(st);\n+      st->cr();\n+\n+      Klass* real_mirrored_klass = fake_mirror.real_mirrored_klass();\n+      if (real_mirrored_klass != nullptr && real_mirrored_klass->is_instance_klass()) {\n+        InstanceKlass* real_mirrored_ik = InstanceKlass::cast(real_mirrored_klass);\n+\n+        ConstantPoolCache* cp_cache = real_mirrored_ik->constants()->cache();\n+        if (!_is_runtime_logging) {\n+          cp_cache = ArchiveBuilder::current()->get_buffered_addr(cp_cache);\n+        }\n+        int rr_root_index = cp_cache->archived_references_index();\n+        st->print(\" - resolved_references: \");\n+        if (rr_root_index >= 0) {\n+          FakeOop resolved_references = _roots->at(rr_root_index);\n+          print_oop_info_cr(st, resolved_references);\n+        } else {\n+          st->print(\"null\");\n+        }\n+\n+        st->print_cr(\"- ---- static fields (%d):\", fake_mirror.static_oop_field_count());\n+        real_mirrored_ik->do_local_static_fields(&print_field);\n+      }\n+    }\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":930,"deletions":0,"binary":false,"changes":930,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTMAPLOGGER_HPP\n+#define SHARE_CDS_AOTMAPLOGGER_HPP\n+\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ArchiveHeapInfo;\n+class DumpRegion;\n+class FileMapInfo;\n+class outputStream;\n+\n+\/\/ Write detailed info to a mapfile to analyze contents of the AOT cache\/CDS archive.\n+\/\/ -Xlog:aot+map* can be used both when creating an AOT cache, or when using an AOT cache.\n+\/\/\n+\/\/ Creating cache:\n+\/\/     java -XX:AOTCacheOutput=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ Using cache:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ You can also print the map of a cache without executing the application by using the\n+\/\/ --version flag:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace --version\n+\/\/\n+\/\/ Because the output can be large, it's best to save it to a file\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace:file=aot.map:none:filesize=0 --version\n+class AOTMapLogger : AllStatic {\n+  struct ArchivedObjInfo {\n+    address _src_addr;\n+    address _buffered_addr;\n+    address _requested_addr;\n+    int _bytes;\n+    MetaspaceObj::Type _type;\n+  };\n+\n+  \/\/ FakeOop and subtypes\n+  class FakeOop;\n+  class   FakeMirror;\n+  class   FakeObjArray;\n+  class   FakeString;\n+  class   FakeTypeArray;\n+\n+  class RequestedMetadataAddr;\n+  class RuntimeGatherArchivedMetaspaceObjs;\n+\n+  static bool _is_logging_at_bootstrap;\n+  static bool _is_runtime_logging;\n+  static size_t _num_root_segments;\n+  static size_t _num_obj_arrays_logged;\n+  static GrowableArrayCHeap<FakeOop, mtClass>* _roots;\n+  static ArchiveHeapInfo* _dumptime_heap_info;\n+\n+  static intx _buffer_to_requested_delta;\n+  static intx _requested_to_mapped_metadata_delta;\n+\n+  static void runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                            const ArchiveBuilder::SourceObjList* src_objs);\n+\n+  \/\/ Common code for dumptime\/runtime\n+  static void log_file_header(FileMapInfo* mapinfo);\n+  static void log_region_range(const char* name, address base, address top, address requested_base);\n+  static void log_metaspace_objects_impl(address region_base, address region_end,\n+                                         GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs, int start_idx, int end_idx);\n+  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false);\n+\n+  \/\/ Metaspace object: type-specific logging\n+  static void log_constant_pool(ConstantPool* cp, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                      const char* type_name, int bytes, Thread* current);\n+  static void log_const_method(ConstMethod* cm, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_klass(Klass* k, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_method(Method* m, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_symbol(Symbol* s, address requested_addr, const char* type_name, int bytes, Thread* current);\n+\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static void dumptime_log_heap_region(ArchiveHeapInfo* heap_info);\n+  static void runtime_log_heap_region(FileMapInfo* mapinfo);\n+\n+  static void print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr = true);\n+  static void print_oop_details(FakeOop fake_oop, outputStream* st);\n+  static void log_oops(address buf_start, address buf_end);\n+  class ArchivedFieldPrinter; \/\/ to be replaced by ArchivedFieldPrinter2\n+#endif\n+\n+public:\n+  static void ergo_initialize();\n+  static bool is_logging_at_bootstrap() { return _is_logging_at_bootstrap; }\n+\n+  static void dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                           ArchiveHeapInfo* heap_info,\n+                           char* bitmap, size_t bitmap_size_in_bytes);\n+  static void runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTMAPLOGGER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.hpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -63,1 +63,0 @@\n-#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -751,7 +750,2 @@\n-  return (p != nullptr);\n-}\n-\n-bool ArchiveBuilder::has_been_buffered(address src_addr) const {\n-  if (RegeneratedClasses::has_been_regenerated(src_addr) ||\n-      _src_obj_table.get(src_addr) == nullptr ||\n-      get_buffered_addr(src_addr) == nullptr) {\n+  if (p == nullptr) {\n+    \/\/ This object has never been seen by ArchiveBuilder\n@@ -759,2 +753,0 @@\n-  } else {\n-    return true;\n@@ -762,0 +754,19 @@\n+  if (p->buffered_addr() == nullptr) {\n+    \/\/ ArchiveBuilder has seen this object, but decided not to archive it. So\n+    \/\/ Any reference to this object will be modified to nullptr inside the buffer.\n+    assert(p->follow_mode() == set_to_null, \"must be\");\n+    return false;\n+  }\n+\n+  DEBUG_ONLY({\n+    \/\/ This is a class\/method that belongs to one of the \"original\" classes that\n+    \/\/ have been regenerated by lambdaFormInvokers.cpp. We must have archived\n+    \/\/ the \"regenerated\" version of it.\n+    if (RegeneratedClasses::has_been_regenerated(src_addr)) {\n+      address regen_obj = RegeneratedClasses::get_regenerated_object(src_addr);\n+      precond(regen_obj != nullptr && regen_obj != src_addr);\n+      assert(has_been_archived(regen_obj), \"must be\");\n+      assert(get_buffered_addr(src_addr) == get_buffered_addr(regen_obj), \"must be\");\n+    }});\n+\n+  return true;\n@@ -1185,418 +1196,0 @@\n-\/\/ Write detailed info to a mapfile to analyze contents of the archive.\n-\/\/ static dump:\n-\/\/   java -Xshare:dump -Xlog:cds+map=trace:file=cds.map:none:filesize=0\n-\/\/ dynamic dump:\n-\/\/   java -cp MyApp.jar -XX:ArchiveClassesAtExit=MyApp.jsa \\\n-\/\/        -Xlog:cds+map=trace:file=cds.map:none:filesize=0 MyApp\n-\/\/\n-\/\/ We need to do some address translation because the buffers used at dump time may be mapped to\n-\/\/ a different location at runtime. At dump time, the buffers may be at arbitrary locations\n-\/\/ picked by the OS. At runtime, we try to map at a fixed location (SharedBaseAddress). For\n-\/\/ consistency, we log everything using runtime addresses.\n-class ArchiveBuilder::CDSMapLogger : AllStatic {\n-  static intx buffer_to_runtime_delta() {\n-    \/\/ Translate the buffers used by the RW\/RO regions to their eventual (requested) locations\n-    \/\/ at runtime.\n-    return ArchiveBuilder::current()->buffer_to_requested_delta();\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_region(const char* name, DumpRegion* region,\n-                                   const ArchiveBuilder::SourceObjList* src_objs) {\n-    address region_base = address(region->base());\n-    address region_top  = address(region->top());\n-    log_region(name, region_base, region_top, region_base + buffer_to_runtime_delta());\n-    log_metaspace_objects(region, src_objs);\n-  }\n-\n-#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n-\n-  static void log_klass(Klass* k, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes, k->external_name());\n-  }\n-  static void log_method(Method* m, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes,  m->external_name());\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_objects(DumpRegion* region, const ArchiveBuilder::SourceObjList* src_objs) {\n-    address last_obj_base = address(region->base());\n-    address last_obj_end  = address(region->base());\n-    address region_end    = address(region->end());\n-    Thread* current = Thread::current();\n-    for (int i = 0; i < src_objs->objs()->length(); i++) {\n-      SourceObjInfo* src_info = src_objs->at(i);\n-      address src = src_info->source_addr();\n-      address dest = src_info->buffered_addr();\n-      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n-      address runtime_dest = dest + buffer_to_runtime_delta();\n-      int bytes = src_info->size_in_bytes();\n-\n-      MetaspaceObj::Type type = src_info->msotype();\n-      const char* type_name = MetaspaceObj::type_name(type);\n-\n-      switch (type) {\n-      case MetaspaceObj::ClassType:\n-        log_klass((Klass*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolType:\n-        log_klass(((ConstantPool*)src)->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolCacheType:\n-        log_klass(((ConstantPoolCache*)src)->constant_pool()->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::MethodType:\n-        log_method((Method*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstMethodType:\n-        log_method(((ConstMethod*)src)->method(), runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::SymbolType:\n-        {\n-          ResourceMark rm(current);\n-          Symbol* s = (Symbol*)src;\n-          log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(runtime_dest), type_name, bytes,\n-                              s->as_quoted_ascii());\n-        }\n-        break;\n-      default:\n-        log_debug(aot, map)(_LOG_PREFIX, p2i(runtime_dest), type_name, bytes);\n-        break;\n-      }\n-\n-      last_obj_base = dest;\n-      last_obj_end  = dest + bytes;\n-    }\n-\n-    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n-    if (last_obj_end < region_end) {\n-      log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n-                          p2i(last_obj_end + buffer_to_runtime_delta()),\n-                          size_t(region_end - last_obj_end));\n-      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n-    }\n-  }\n-\n-#undef _LOG_PREFIX\n-\n-  \/\/ Log information about a region, whose address at dump time is [base .. top). At\n-  \/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n-  \/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n-  \/\/ be accessed with os::read (the header).\n-  \/\/\n-  \/\/ Note: across -Xshare:dump runs, base may be different, but requested_base should\n-  \/\/ be the same as the archive contents should be deterministic.\n-  static void log_region(const char* name, address base, address top, address requested_base) {\n-    size_t size = top - base;\n-    base = requested_base;\n-    if (requested_base == nullptr) {\n-      top = (address)size;\n-    } else {\n-      top = requested_base + size;\n-    }\n-    log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n-                       name, p2i(base), p2i(top), size);\n-  }\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static void log_heap_region(ArchiveHeapInfo* heap_info) {\n-    MemRegion r = heap_info->buffer_region();\n-    address start = address(r.start()); \/\/ start of the current oop inside the buffer\n-    address end = address(r.end());\n-    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n-\n-    LogStreamHandle(Info, aot, map) st;\n-\n-    HeapRootSegments segments = heap_info->heap_root_segments();\n-    assert(segments.base_offset() == 0, \"Sanity\");\n-\n-    for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print_cr(PTR_FORMAT \": Heap roots segment [%d]\",\n-                  p2i(requested_start), segments.size_in_elems(seg_idx));\n-      start += segments.size_in_bytes(seg_idx);\n-    }\n-    log_heap_roots();\n-\n-    while (start < end) {\n-      size_t byte_size;\n-      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n-\n-      if (source_oop != nullptr) {\n-        \/\/ This is a regular oop that got archived.\n-        \/\/ Don't print the requested addr again as we have just printed it at the beginning of the line.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffd27938: @@ Object (0xfffa4f27) java.util.HashMap\n-        print_oop_info_cr(&st, source_oop, \/*print_requested_addr=*\/false);\n-        byte_size = source_oop->size() * BytesPerWord;\n-      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n-        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffc3ffd8: @@ Object filler 40 bytes\n-        st.print_cr(\"filler %zu bytes\", byte_size);\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-\n-      address oop_end = start + byte_size;\n-      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n-\n-      if (source_oop != nullptr) {\n-        log_oop_details(heap_info, source_oop, \/*buffered_addr=*\/start);\n-      }\n-      start = oop_end;\n-    }\n-  }\n-\n-  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n-  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n-  \/\/ in _source_obj with their requested addresses using print_oop_info_cr().\n-  class ArchivedFieldPrinter : public FieldClosure {\n-    ArchiveHeapInfo* _heap_info;\n-    outputStream* _st;\n-    oop _source_obj;\n-    address _buffered_addr;\n-  public:\n-    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj, address buffered_addr) :\n-      _heap_info(heap_info), _st(st), _source_obj(src_obj), _buffered_addr(buffered_addr) {}\n-\n-    void do_field(fieldDescriptor* fd) {\n-      _st->print(\" - \");\n-      BasicType ft = fd->field_type();\n-      switch (ft) {\n-      case T_ARRAY:\n-      case T_OBJECT:\n-        {\n-          fd->print_on(_st); \/\/ print just the name and offset\n-          oop obj = _source_obj->obj_field(fd->offset());\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(_st, obj);\n-        }\n-        break;\n-      default:\n-        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n-          print_as_native_pointer(fd);\n-        } else {\n-          fd->print_on_for(_st, cast_to_oop(_buffered_addr)); \/\/ name, offset, value\n-          _st->cr();\n-        }\n-      }\n-    }\n-\n-    void print_as_native_pointer(fieldDescriptor* fd) {\n-      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n-      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n-\n-      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n-      address source_native_ptr = (address)\n-          LP64_ONLY(_source_obj->long_field(fd->offset()))\n-          NOT_LP64( _source_obj->int_field (fd->offset()));\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-\n-      \/\/ The value of the native pointer at runtime.\n-      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n-\n-      \/\/ The address of _source_obj at runtime\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n-      \/\/ The address of this field in the requested space\n-      assert(requested_obj != nullptr, \"Attempting to load field from null oop\");\n-      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n-\n-      fd->print_on(_st);\n-      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n-                    p2i(requested_native_ptr), p2i(requested_field_addr));\n-    }\n-  };\n-\n-  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n-  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop, address buffered_addr) {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      Klass* source_klass = source_oop->klass();\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n-\n-      st.print(\" - klass: \");\n-      source_klass->print_value_on(&st);\n-      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n-      st.cr();\n-\n-      if (source_oop->is_typeArray()) {\n-        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n-      } else if (source_oop->is_objArray()) {\n-        objArrayOop source_obj_array = objArrayOop(source_oop);\n-        for (int i = 0; i < source_obj_array->length(); i++) {\n-          st.print(\" -%4d: \", i);\n-          oop obj = source_obj_array->obj_at(i);\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(&st, obj);\n-        }\n-      } else {\n-        st.print_cr(\" - fields (%zu words):\", source_oop->size());\n-        ArchivedFieldPrinter print_field(heap_info, &st, source_oop, buffered_addr);\n-        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n-\n-        if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-          st.print(\" - signature: \");\n-          print_class_signature_for_mirror(&st, scratch_mirror);\n-          st.cr();\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            oop rr = HeapShared::scratch_resolved_references(InstanceKlass::cast(src_klass)->constants());\n-            st.print(\" - archived_resolved_references: \");\n-            print_oop_info_cr(&st, rr);\n-\n-            \/\/ We need to print the fields in the scratch_mirror, not the original mirror.\n-            \/\/ (if a class is not aot-initialized, static fields in its scratch mirror will be cleared).\n-            assert(scratch_mirror == HeapShared::scratch_java_mirror(src_klass->java_mirror()), \"sanity\");\n-            st.print_cr(\"- ---- static fields (%d):\", java_lang_Class::static_oop_field_count(scratch_mirror));\n-            InstanceKlass::cast(src_klass)->do_local_static_fields(&print_field);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static void print_class_signature_for_mirror(outputStream* st, oop scratch_mirror) {\n-    assert(java_lang_Class::is_instance(scratch_mirror), \"sanity\");\n-    if (java_lang_Class::is_primitive(scratch_mirror)) {\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        BasicType bt = (BasicType)i;\n-        if (!is_reference_type(bt) && scratch_mirror == HeapShared::scratch_java_mirror(bt)) {\n-          oop orig_mirror = Universe::java_mirror(bt);\n-          java_lang_Class::print_signature(orig_mirror, st);\n-          return;\n-        }\n-      }\n-      ShouldNotReachHere();\n-    }\n-    java_lang_Class::print_signature(scratch_mirror, st);\n-  }\n-\n-  static void log_heap_roots() {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n-        st.print(\"roots[%4d]: \", i);\n-        print_oop_info_cr(&st, HeapShared::pending_roots()->at(i));\n-      }\n-    }\n-  }\n-\n-  \/\/ Example output:\n-  \/\/ - The first number is the requested address (if print_requested_addr == true)\n-  \/\/ - The second number is the narrowOop version of the requested address (if UseCompressedOops == true)\n-  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class Ljava\/util\/Array;\n-  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n-  static void print_oop_info_cr(outputStream* st, oop source_oop, bool print_requested_addr = true) {\n-    if (source_oop == nullptr) {\n-      st->print_cr(\"null\");\n-    } else {\n-      ResourceMark rm;\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n-      if (print_requested_addr) {\n-        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n-      }\n-      if (UseCompressedOops) {\n-        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n-      }\n-      if (source_oop->is_array()) {\n-        int array_len = arrayOop(source_oop)->length();\n-        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n-      } else {\n-        st->print(\"%s\", source_oop->klass()->external_name());\n-\n-        if (java_lang_String::is_instance(source_oop)) {\n-          st->print(\" \");\n-          java_lang_String::print(source_oop, st);\n-        } else if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-\n-          st->print(\" \");\n-          print_class_signature_for_mirror(st, scratch_mirror);\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            InstanceKlass* buffered_klass =\n-              ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_klass));\n-            if (buffered_klass->has_aot_initialized_mirror()) {\n-              st->print(\" (aot-inited)\");\n-            }\n-          }\n-        }\n-        st->cr();\n-      }\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-\n-  \/\/ Log all the data [base...top). Pretend that the base address\n-  \/\/ will be mapped to requested_base at run-time.\n-  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n-    assert(top >= base, \"must be\");\n-\n-    LogStreamHandle(Trace, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      int unitsize = sizeof(address);\n-      if (is_heap && UseCompressedOops) {\n-        \/\/ This makes the compressed oop pointers easier to read, but\n-        \/\/ longs and doubles will be split into two words.\n-        unitsize = sizeof(narrowOop);\n-      }\n-      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n-    }\n-  }\n-\n-  static void log_header(FileMapInfo* mapinfo) {\n-    LogStreamHandle(Info, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      mapinfo->print(&lsh);\n-    }\n-  }\n-\n-public:\n-  static void log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n-                  ArchiveHeapInfo* heap_info,\n-                  char* bitmap, size_t bitmap_size_in_bytes) {\n-    log_info(aot, map)(\"%s CDS archive map for %s\", CDSConfig::is_dumping_static_archive() ? \"Static\" : \"Dynamic\", mapinfo->full_path());\n-\n-    address header = address(mapinfo->header());\n-    address header_end = header + mapinfo->header()->header_size();\n-    log_region(\"header\", header, header_end, nullptr);\n-    log_header(mapinfo);\n-    log_as_hex(header, header_end, nullptr);\n-\n-    DumpRegion* rw_region = &builder->_rw_region;\n-    DumpRegion* ro_region = &builder->_ro_region;\n-\n-    log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n-    log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n-\n-    address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n-    log_region(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n-    log_as_hex((address)bitmap, bitmap_end, nullptr);\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (heap_info->is_used()) {\n-      log_heap_region(heap_info);\n-    }\n-#endif\n-\n-    log_info(aot, map)(\"[End of CDS archive map]\");\n-  }\n-}; \/\/ end ArchiveBuilder::CDSMapLogger\n-\n@@ -1642,2 +1235,1 @@\n-    CDSMapLogger::log(this, mapinfo, heap_info,\n-                      bitmap, bitmap_size_in_bytes);\n+    AOTMapLogger::dumptime_log(this, mapinfo, heap_info, bitmap, bitmap_size_in_bytes);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":23,"deletions":431,"binary":false,"changes":454,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  friend class AOTMapLogger;\n+\n@@ -183,0 +185,1 @@\n+    FollowMode follow_mode() const { return _follow_mode; }\n@@ -204,2 +207,0 @@\n-  class CDSMapLogger;\n-\n@@ -318,0 +319,6 @@\n+  template <typename T> T requested_to_buffered(T obj) const {\n+    T b = (T)(address(obj) - _buffer_to_requested_delta);\n+    assert(is_in_buffer_space(b), \"must be\");\n+    return b;\n+  }\n+\n@@ -446,4 +453,2 @@\n-\n-  bool has_been_buffered(address src_addr) const;\n-  template <typename T> bool has_been_buffered(T src_addr) const {\n-    return has_been_buffered((address)src_addr);\n+  template <typename T> bool has_been_archived(T src_addr) const {\n+    return has_been_archived((address)src_addr);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -165,0 +165,38 @@\n+Klass* ArchiveHeapWriter::real_klass_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->klass();\n+  } else if (get_filler_size_at(buffered_addr) > 0) {\n+    return Universe::fillerArrayKlass();\n+  } else {\n+    \/\/ This is one of the root segments\n+    return Universe::objectArrayKlass();\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::size_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->size();\n+  }\n+\n+  size_t nbytes = get_filler_size_at(buffered_addr);\n+  if (nbytes > 0) {\n+    assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+    return nbytes \/ BytesPerWord;\n+  }\n+\n+  address hrs = buffer_bottom();\n+  for (size_t seg_idx = 0; seg_idx < _heap_root_segments.count(); seg_idx++) {\n+    nbytes = _heap_root_segments.size_in_bytes(seg_idx);\n+    if (hrs == buffered_addr) {\n+      assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+      return nbytes \/ BytesPerWord;\n+    }\n+    hrs += nbytes;\n+  }\n+\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n@@ -715,21 +753,0 @@\n-\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n-bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n-  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n-  assert(p != nullptr, \"must be\");\n-\n-  \/\/ requested_field_addr = the address of this field in the requested space\n-  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n-  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n-  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n-\n-  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n-  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n-  size_t start_pos = FileMapInfo::current_info()->heap_ptrmap_start_pos();\n-  if (idx < start_pos) {\n-    return false;\n-  } else {\n-    idx -= start_pos;\n-  }\n-  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n-}\n-\n@@ -770,1 +787,1 @@\n-    guarantee(ArchiveBuilder::current()->has_been_buffered((address)native_ptr),\n+    guarantee(ArchiveBuilder::current()->has_been_archived((address)native_ptr),\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -239,1 +239,0 @@\n-  static bool is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset);\n@@ -243,1 +242,2 @@\n-\n+  static Klass* real_klass_of_buffered_oop(address buffered_addr);\n+  static size_t size_of_buffered_oop(address buffered_addr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,2 +386,1 @@\n-  if (SystemDictionaryShared::is_excluded_class(src_ik)) {\n-    assert(!ArchiveBuilder::current()->has_been_buffered(src_ik), \"sanity\");\n+  if (!ArchiveBuilder::current()->has_been_archived(src_ik)) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -111,0 +112,2 @@\n+\n+  AOTMapLogger::ergo_initialize();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -330,0 +331,18 @@\n+    FileMapInfo *static_mapinfo = FileMapInfo::current_info();\n+    FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n+\n+    if (AOTMapLogger::is_logging_at_bootstrap()) {\n+      \/\/ The map logging needs to be done here, as it requires some stubs on Windows,\n+      \/\/ which are not generated until the end of init_globals().\n+      AOTMapLogger::runtime_log(static_mapinfo, dynamic_mapinfo);\n+    }\n+\n+    \/\/ Close any open file descriptors. However, mmap'ed pages will remain in memory.\n+    static_mapinfo->close();\n+    static_mapinfo->unmap_region(MetaspaceShared::bm);\n+\n+    if (dynamic_mapinfo != nullptr) {\n+      dynamic_mapinfo->close();\n+      dynamic_mapinfo->unmap_region(MetaspaceShared::bm);\n+    }\n+\n@@ -1964,0 +1983,1 @@\n+  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1979,6 +1999,0 @@\n-  \/\/ Close the mapinfo file\n-  static_mapinfo->close();\n-\n-  static_mapinfo->unmap_region(MetaspaceShared::bm);\n-\n-  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1990,2 +2004,0 @@\n-    dynamic_mapinfo->close();\n-    dynamic_mapinfo->unmap_region(MetaspaceShared::bm);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1182,0 +1182,6 @@\n+void SystemDictionaryShared::get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes) {\n+  get_archive(is_static_archive)->_builtin_dictionary.iterate([&] (const RunTimeClassInfo* record) {\n+      classes->append(record->klass());\n+    });\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+template <typename E> class GrowableArray;\n+\n@@ -272,0 +274,1 @@\n+  static void get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1383,1 +1383,1 @@\n-  SET_ADDRESS(_extrs, ShenandoahRuntime::write_ref_field_pre);\n+  SET_ADDRESS(_extrs, ShenandoahRuntime::write_barrier_pre);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n+  _mutable_data(nullptr),\n@@ -163,3 +163,0 @@\n-  } else {\n-    \/\/ We need unique and valid not null address\n-    assert(_mutable_data == blob_end(), \"sanity\");\n@@ -167,0 +164,1 @@\n+  assert(_mutable_data != nullptr || _mutable_data_size == 0, \"No mutable data => mutable data size is 0\");\n@@ -175,1 +173,1 @@\n-  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n+  _mutable_data(nullptr),\n@@ -189,0 +187,1 @@\n+  assert(_mutable_data == nullptr && _mutable_data_size == 0, \"invariant\");\n@@ -191,1 +190,0 @@\n-  assert(_mutable_data == blob_end(), \"sanity\");\n@@ -202,1 +200,1 @@\n-    _mutable_data = blob_end(); \/\/ default value\n+    _mutable_data = nullptr;\n@@ -211,11 +209,7 @@\n-  assert(_mutable_data != nullptr, \"should never be null\");\n-  if (_mutable_data != blob_end()) {\n-    os::free(_mutable_data);\n-    _mutable_data = blob_end(); \/\/ Valid not null address\n-    _mutable_data_size = 0;\n-    _relocation_size = 0;\n-  }\n-  if (_oop_maps != nullptr) {\n-    delete _oop_maps;\n-    _oop_maps = nullptr;\n-  }\n+  os::free(_mutable_data);\n+  _mutable_data = nullptr;\n+  _mutable_data_size = 0;\n+  delete _oop_maps;\n+  _oop_maps = nullptr;\n+  _relocation_size = 0;\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1345,2 +1345,2 @@\n-    \/\/ native wrapper does not have read-only data but we need unique not null address\n-    _immutable_data          = blob_end();\n+    \/\/ native wrapper does not have read-only data\n+    _immutable_data          = nullptr;\n@@ -1532,2 +1532,1 @@\n-      \/\/ We need unique not null address\n-      _immutable_data     = blob_end();\n+      _immutable_data     = nullptr;\n@@ -2169,3 +2168,2 @@\n-  if (_pc_desc_container != nullptr) {\n-    delete _pc_desc_container;\n-  }\n+\n+  delete _pc_desc_container;\n@@ -2174,4 +2172,4 @@\n-  if (_immutable_data != blob_end()) {\n-    os::free(_immutable_data);\n-    _immutable_data = blob_end(); \/\/ Valid not null address\n-  }\n+  os::free(_immutable_data);\n+  _immutable_data = nullptr;\n+  _immutable_data_size = 0;\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -119,3 +119,0 @@\n-\/\/ A static dummy to serve as a safe pointer when there is no relocation info.\n-static relocInfo dummy_relocInfo = relocInfo(relocInfo::none, 0);\n-\n@@ -133,8 +130,3 @@\n-  if (nm->relocation_size() == 0) {\n-    _current = &dummy_relocInfo - 1;\n-    _end = &dummy_relocInfo;\n-  } else {\n-    assert(((nm->relocation_begin() != nullptr) && (nm->relocation_end() != nullptr)), \"valid start and end pointer\");\n-    _current = nm->relocation_begin() - 1;\n-    _end     = nm->relocation_end();\n-  }\n+  _base = nm->relocation_begin();\n+  _current = -1;\n+  _len = nm->relocation_end() - _base;\n@@ -159,0 +151,9 @@\n+RelocIterator::RelocIterator(relocInfo& ri) {\n+  initialize_misc();\n+  _base = &ri;\n+  _len = 1;\n+  _current = -1;\n+  _limit = nullptr;\n+  _addr = 0;\n+}\n+\n@@ -162,2 +163,3 @@\n-  _current = cs->locs_start() - 1;\n-  _end     = cs->locs_end();\n+  _base = cs->locs_start();\n+  _len = cs->locs_end() - _base;\n+  _current = -1;\n@@ -189,2 +191,3 @@\n-  _current = cb->relocation_begin() - 1;\n-  _end     = cb->relocation_end();\n+  _base = cb->relocation_begin();\n+  _len = cb->relocation_end() - _base;\n+  _current = -1;\n@@ -219,1 +222,1 @@\n-    relocInfo* backup;\n+    int backup;\n@@ -241,3 +244,3 @@\n-  if (_current->is_datalen()) {\n-    _data    = (short*) _current->data();\n-    _datalen =          _current->datalen();\n+  if (current()->is_datalen()) {\n+    _data    = (short*) current()->data();\n+    _datalen =          current()->datalen();\n@@ -246,1 +249,1 @@\n-    _databuf = _current->immediate();\n+    _databuf = current()->immediate();\n@@ -353,3 +356,3 @@\n-  relocInfo ri = relocInfo(rtype, 0);\n-  RelocIterator itr;\n-  itr.set_current(ri);\n+  relocInfo ri(rtype, 0);\n+  RelocIterator itr(ri);\n+  itr.next();\n@@ -842,1 +845,1 @@\n-             p2i(_current), type(), relocInfo::type_name((relocInfo::relocType) type()), p2i(_addr), _current->addr_offset());\n+            p2i(current()), type(), relocInfo::type_name((relocInfo::relocType) type()), p2i(_addr), current()->addr_offset());\n@@ -993,1 +996,1 @@\n-  relocInfo* scan = _current;\n+  relocInfo* scan = current_no_check();\n@@ -1003,1 +1006,1 @@\n-    relocInfo* newscan = _current+1;\n+    relocInfo* newscan = current_no_check()+1;\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -565,2 +565,3 @@\n-  relocInfo*      _current; \/\/ the current relocation information\n-  relocInfo*      _end;     \/\/ end marker; we're done iterating when _current == _end\n+  relocInfo*      _base;    \/\/ base pointer into relocInfo array\n+  int             _current; \/\/ current index\n+  int             _len;     \/\/ length\n@@ -569,1 +570,0 @@\n-  short           _databuf; \/\/ spare buffer for compressed data\n@@ -571,0 +571,1 @@\n+  short           _databuf; \/\/ spare buffer for compressed data\n@@ -581,4 +582,0 @@\n-  void set_current(relocInfo& ri) {\n-    _current = &ri;\n-    set_has_current(true);\n-  }\n@@ -588,2 +585,5 @@\n-  relocInfo* current() const { assert(has_current(), \"must have current\");\n-                               return _current; }\n+  relocInfo* current_no_check() const { return &_base[_current]; }\n+  relocInfo* current() const {\n+    assert(has_current(), \"must have current\");\n+    return current_no_check();\n+  }\n@@ -600,0 +600,1 @@\n+  RelocIterator(relocInfo& ri);\n@@ -610,2 +611,2 @@\n-    assert(_current <= _end, \"must not overrun relocInfo\");\n-    if (_current == _end) {\n+    assert(_current <= _len, \"must not overrun relocInfo\");\n+    if (_current == _len) {\n@@ -617,1 +618,1 @@\n-    if (_current->is_prefix()) {\n+    if (current()->is_prefix()) {\n@@ -622,1 +623,1 @@\n-    _addr += _current->addr_offset();\n+    _addr += current()->addr_offset();\n@@ -628,1 +629,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  thread->timeout()->arm();\n@@ -231,0 +232,1 @@\n+  thread->timeout()->disarm();\n@@ -483,0 +485,1 @@\n+        task->set_next(nullptr);\n@@ -1928,0 +1931,4 @@\n+  if (!thread->init_compilation_timeout()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  _timeout = nullptr;\n@@ -52,0 +53,1 @@\n+  delete _timeout;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -29,0 +31,5 @@\n+#include \"utilities\/macros.hpp\"\n+\n+#ifdef LINUX\n+#include \"compilerThreadTimeout_linux.hpp\"\n+#endif \/\/LINUX\n@@ -41,0 +48,10 @@\n+#ifndef LINUX\n+class CompilerThreadTimeoutGeneric : public CHeapObj<mtCompiler> {\n+ public:\n+  CompilerThreadTimeoutGeneric() {};\n+  void arm() {};\n+  void disarm() {};\n+  bool init_timeout() { return true; };\n+};\n+#endif \/\/ !LINUX\n+\n@@ -45,0 +62,7 @@\n+\n+#ifdef LINUX\n+  typedef CompilerThreadTimeoutLinux Timeout;\n+#else \/\/ LINUX\n+  typedef CompilerThreadTimeoutGeneric Timeout;\n+#endif \/\/ LINUX\n+\n@@ -60,0 +84,1 @@\n+  Timeout*              _timeout;\n@@ -116,1 +141,7 @@\n-#endif\n+#endif \/\/ !PRODUCT\n+\n+  Timeout* timeout() const { return _timeout; };\n+  bool init_compilation_timeout() {\n+    _timeout = new Timeout();\n+    return _timeout->init_timeout();\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -76,0 +77,2 @@\n+    _gc_cpu_time_at_pause_end_ms(),\n+    _concurrent_gc_cpu_time_ms(),\n@@ -91,2 +94,2 @@\n-    _long_term_pause_time_ratio(0.0),\n-    _short_term_pause_time_ratio(0.0) {\n+    _long_term_gc_time_ratio(0.0),\n+    _short_term_gc_time_ratio(0.0) {\n@@ -152,0 +155,4 @@\n+double G1Analytics::gc_cpu_time_ms() const {\n+  return (double)CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_MILLISEC;\n+}\n+\n@@ -160,1 +167,9 @@\n-void G1Analytics::compute_pause_time_ratios(double end_time_sec, double pause_time_ms) {\n+void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms) {\n+  \/\/ This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n+  \/\/ activity. We do not account for contention on other shared resources such as memory bandwidth and\n+  \/\/ caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n+  uint num_cpus = (uint)os::active_processor_count();\n+  double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms \/ num_cpus;\n+\n+  double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n+\n@@ -162,3 +177,4 @@\n-  double gc_pause_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + pause_time_ms;\n-  _long_term_pause_time_ratio = gc_pause_time_ms \/ long_interval_ms;\n-  _long_term_pause_time_ratio = clamp(_long_term_pause_time_ratio, 0.0, 1.0);\n+  double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n+\n+  _long_term_gc_time_ratio = long_term_gc_time_ms \/ long_interval_ms;\n+  _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n@@ -167,2 +183,5 @@\n-  _short_term_pause_time_ratio = pause_time_ms \/ short_interval_ms;\n-  _short_term_pause_time_ratio = clamp(_short_term_pause_time_ratio, 0.0, 1.0);\n+\n+  _short_term_gc_time_ratio = gc_time_ms \/ short_interval_ms;\n+  _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n+\n+  update_recent_gc_times(end_time_sec, gc_time_ms);\n@@ -308,2 +327,2 @@\n-                                         double pause_time_ms) {\n-  _recent_gc_times_ms.add(pause_time_ms);\n+                                         double gc_time_ms) {\n+  _recent_gc_times_ms.add(gc_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -47,1 +47,9 @@\n-  double        _prev_collection_pause_end_ms;\n+  double       _prev_collection_pause_end_ms;\n+\n+  \/\/ Records the total GC CPU time (in ms) at the end of the last GC pause.\n+  \/\/ Used as a baseline to calculate CPU time spent in GC threads between pauses.\n+  double _gc_cpu_time_at_pause_end_ms;\n+\n+  \/\/ CPU time (ms) spent by GC threads between the end of the last pause\n+  \/\/ and the start of the current pause; calculated at start of a GC pause.\n+  double _concurrent_gc_cpu_time_ms;\n@@ -78,4 +86,4 @@\n-  \/\/ Cached values for long and short term pause time ratios. See\n-  \/\/ compute_pause_time_ratios() for how they are computed.\n-  double _long_term_pause_time_ratio;\n-  double _short_term_pause_time_ratio;\n+  \/\/ Cached values for long and short term gc time ratios. See\n+  \/\/ update_gc_time_ratios() for how they are computed.\n+  double _long_term_gc_time_ratio;\n+  double _short_term_gc_time_ratio;\n@@ -105,2 +113,2 @@\n-  double long_term_pause_time_ratio() const {\n-    return _long_term_pause_time_ratio;\n+  double long_term_gc_time_ratio() const {\n+    return _long_term_gc_time_ratio;\n@@ -109,2 +117,2 @@\n-  double short_term_pause_time_ratio() const {\n-    return _short_term_pause_time_ratio;\n+  double short_term_gc_time_ratio() const {\n+    return _short_term_gc_time_ratio;\n@@ -125,0 +133,14 @@\n+  void set_gc_cpu_time_at_pause_end_ms(double ms) {\n+    _gc_cpu_time_at_pause_end_ms = ms;\n+  }\n+\n+  double gc_cpu_time_at_pause_end_ms() const {\n+    return _gc_cpu_time_at_pause_end_ms;\n+  }\n+\n+  void set_concurrent_gc_cpu_time_ms(double ms) {\n+    _concurrent_gc_cpu_time_ms = ms;\n+  }\n+\n+  double gc_cpu_time_ms() const;\n+\n@@ -176,2 +198,2 @@\n-  void update_recent_gc_times(double end_time_sec, double elapsed_ms);\n-  void compute_pause_time_ratios(double end_time_sec, double pause_time_ms);\n+  void update_recent_gc_times(double end_time_sec, double gc_time_ms);\n+  void update_gc_time_ratios(double end_time_sec, double pause_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -802,0 +803,1 @@\n+  finish_codecache_marking_cycle();\n@@ -3082,0 +3084,2 @@\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  bs_nm->disarm(nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"utilities\/quickSort.hpp\"\n@@ -70,1 +69,1 @@\n-  _inc_build_state(CSetBuildType::Inactive),\n+  DEBUG_ONLY(_inc_build_state(CSetBuildType::Inactive) COMMA)\n@@ -109,1 +108,1 @@\n-  groups()->prepare_for_scan();\n+  _groups.prepare_for_scan();\n@@ -145,1 +144,1 @@\n-  _inc_build_state = CSetBuildType::Active;\n+  DEBUG_ONLY(_inc_build_state = CSetBuildType::Active;)\n@@ -149,1 +148,1 @@\n-  _inc_build_state = CSetBuildType::Inactive;\n+  DEBUG_ONLY(_inc_build_state = CSetBuildType::Inactive;)\n@@ -347,4 +346,0 @@\n-static int compare_region_idx(const uint a, const uint b) {\n-  return static_cast<int>(a-b);\n-}\n-\n@@ -607,1 +602,0 @@\n-  uint num_groups_selected = 0;\n@@ -623,1 +617,0 @@\n-    num_groups_selected++;\n@@ -630,1 +623,1 @@\n-                            num_regions_selected, num_groups_selected);\n+                            num_regions_selected, selected.length());\n@@ -632,1 +625,1 @@\n-  if (num_groups_selected > 0) {\n+  if (selected.length() > 0) {\n@@ -691,1 +684,0 @@\n-  QuickSort::sort(_regions, _regions_cur_length, compare_region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+#ifdef ASSERT\n@@ -174,0 +175,1 @@\n+#endif\n@@ -234,3 +236,0 @@\n-  G1CSetCandidateGroupList* groups() { return &_groups; }\n-  const G1CSetCandidateGroupList* groups() const { return &_groups; }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    G1HeapRegionRemSet::iterate_for_merge(groups()->at(offset + cur_pos)->card_set(), cl);\n+    G1HeapRegionRemSet::iterate_for_merge(_groups.at(offset + cur_pos)->card_set(), cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  assert(length() > 0, \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3124,2 +3124,2 @@\n-                          group->gc_efficiency(),\n-                          group->liveness_percent(),\n+                          group->length() > 0 ? group->gc_efficiency() : 0.0,\n+                          group->length() > 0 ? group->liveness_percent() : 0.0,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -227,2 +227,0 @@\n-\n-  G1CollectedHeap::finish_codecache_marking_cycle();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,2 +220,2 @@\n-  const double long_term_gc_cpu_usage = _analytics->long_term_pause_time_ratio();\n-  const double short_term_gc_cpu_usage = _analytics->short_term_pause_time_ratio();\n+  const double long_term_gc_cpu_usage = _analytics->long_term_gc_time_ratio();\n+  const double short_term_gc_cpu_usage = _analytics->short_term_gc_time_ratio();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-  Prefetch::write(obj->mark_addr(), 0);\n-  Prefetch::read(obj->mark_addr(), (HeapWordSize*2));\n+  Prefetch::write(obj->base_addr(), oopDesc::mark_offset_in_bytes());\n+  Prefetch::read(obj->base_addr(), oopDesc::mark_offset_in_bytes() + (HeapWordSize*2));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -667,0 +667,6 @@\n+\n+  double prev_gc_cpu_pause_end_ms = _analytics->gc_cpu_time_at_pause_end_ms();\n+  double cur_gc_cpu_time_ms = _analytics->gc_cpu_time_ms();\n+\n+  double concurrent_gc_cpu_time_ms = cur_gc_cpu_time_ms - prev_gc_cpu_pause_end_ms;\n+  _analytics->set_concurrent_gc_cpu_time_ms(concurrent_gc_cpu_time_ms);\n@@ -1349,2 +1355,1 @@\n-  _analytics->compute_pause_time_ratios(end_time_sec, pause_time_ms);\n-  _analytics->update_recent_gc_times(end_time_sec, pause_time_ms);\n+  _analytics->update_gc_time_ratios(end_time_sec, pause_time_ms);\n@@ -1373,0 +1378,3 @@\n+\n+  double elapsed_gc_cpu_time = _analytics->gc_cpu_time_ms();\n+  _analytics->set_gc_cpu_time_at_pause_end_ms(elapsed_gc_cpu_time);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -864,0 +865,2 @@\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  bs_nm->disarm(nm);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    Prefetch::write(obj->mark_addr(), 0);\n+    Prefetch::write(obj->base_addr(), oopDesc::mark_offset_in_bytes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -435,0 +436,2 @@\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  bs_nm->disarm(nm);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -204,28 +204,0 @@\n-class CPUTimeThreadClosure : public ThreadClosure {\n-private:\n-  jlong _cpu_time = 0;\n-\n-public:\n-  virtual void do_thread(Thread* thread) {\n-    jlong cpu_time = os::thread_cpu_time(thread);\n-    if (cpu_time != -1) {\n-      _cpu_time += cpu_time;\n-    }\n-  }\n-  jlong cpu_time() { return _cpu_time; };\n-};\n-\n-double CollectedHeap::elapsed_gc_cpu_time() const {\n-  double string_dedup_cpu_time = UseStringDeduplication ?\n-    os::thread_cpu_time((Thread*)StringDedup::_processor->_thread) : 0;\n-\n-  if (string_dedup_cpu_time == -1) {\n-    string_dedup_cpu_time = 0;\n-  }\n-\n-  CPUTimeThreadClosure cl;\n-  gc_threads_do(&cl);\n-\n-  return (double)(cl.cpu_time() + _vmthread_cpu_time + string_dedup_cpu_time) \/ NANOSECS_PER_SEC;\n-}\n-\n@@ -636,24 +608,0 @@\n-void CollectedHeap::log_gc_cpu_time() const {\n-  LogTarget(Info, gc, cpu) out;\n-  if (os::is_thread_cpu_time_supported() && out.is_enabled()) {\n-    double process_cpu_time = os::elapsed_process_cpu_time();\n-    double gc_cpu_time = elapsed_gc_cpu_time();\n-\n-    if (process_cpu_time == -1 || gc_cpu_time == -1) {\n-      log_warning(gc, cpu)(\"Could not sample CPU time\");\n-      return;\n-    }\n-\n-    double usage;\n-    if (gc_cpu_time > process_cpu_time ||\n-        process_cpu_time == 0 || gc_cpu_time == 0) {\n-      \/\/ This can happen e.g. for short running processes with\n-      \/\/ low CPU utilization\n-      usage = 0;\n-    } else {\n-      usage = 100 * gc_cpu_time \/ process_cpu_time;\n-    }\n-    out.print(\"GC CPU usage: %.2f%% (Process: %.4fs GC: %.4fs)\", usage, process_cpu_time, gc_cpu_time);\n-  }\n-}\n-\n@@ -663,3 +611,0 @@\n-  \/\/ Log GC CPU usage.\n-  log_gc_cpu_time();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -92,0 +93,1 @@\n+  friend class CPUTimeUsage::GC;\n@@ -433,2 +435,0 @@\n-  void log_gc_cpu_time() const;\n-\n@@ -467,2 +467,0 @@\n-  double elapsed_gc_cpu_time() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -108,1 +109,0 @@\n-class CollectedHeap;\n@@ -119,1 +119,1 @@\n-  friend class CollectedHeap;\n+  friend class CPUTimeUsage::GC;\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -32,1 +33,0 @@\n-class CollectedHeap;\n@@ -46,1 +46,1 @@\n-  friend class CollectedHeap;\n+  friend class CPUTimeUsage::GC;\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -253,3 +253,2 @@\n-        const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_Type();\n-        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), \"shenandoah_wb_pre\",\n-                          pre_val, tls);\n+        const TypeFunc *tf = ShenandoahBarrierSetC2::write_barrier_pre_Type();\n+        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), \"shenandoah_wb_pre\", pre_val);\n@@ -273,1 +272,1 @@\n-         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre);\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre);\n@@ -523,2 +522,2 @@\n-const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_Type() {\n-  const Type **fields = TypeTuple::fields(2);\n+const TypeFunc* ShenandoahBarrierSetC2::write_barrier_pre_Type() {\n+  const Type **fields = TypeTuple::fields(1);\n@@ -526,2 +525,1 @@\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n@@ -1111,1 +1109,1 @@\n-    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain_sig()->cnt();\n+    uint cnt = ShenandoahBarrierSetC2::write_barrier_pre_Type()->domain_sig()->cnt();\n@@ -1197,1 +1195,1 @@\n-        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain_sig()->cnt();\n+        uint cnt = ShenandoahBarrierSetC2::write_barrier_pre_Type()->domain_sig()->cnt();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  static const TypeFunc* write_ref_field_pre_Type();\n+  static const TypeFunc* write_barrier_pre_Type();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-JRT_LEAF(void, ShenandoahRuntime::write_ref_field_pre(oopDesc * orig, JavaThread * thread))\n-  assert(thread == JavaThread::current(), \"pre-condition\");\n+JRT_LEAF(void, ShenandoahRuntime::write_barrier_pre(oopDesc* orig))\n@@ -46,0 +45,1 @@\n+  JavaThread* thread = JavaThread::current();\n@@ -51,4 +51,0 @@\n-void ShenandoahRuntime::write_barrier_pre(oopDesc* orig) {\n-  write_ref_field_pre(orig, JavaThread::current());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  static void write_ref_field_pre(oopDesc* orig, JavaThread* thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+\n+  template <typename Function, typename... Args>\n+  bool next_if(T* elem, Function predicate, Args&&... args);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,0 +164,14 @@\n+template <typename T, bool Parallel>\n+template <typename Function, typename... Args>\n+inline bool ZArrayIteratorImpl<T, Parallel>::next_if(T* elem, Function predicate, Args&&... args) {\n+  size_t index;\n+  while (next_index(&index)) {\n+    if (predicate(index_to_elem(index), args...)) {\n+      *elem = index_to_elem(index);\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+  const uint32_t         _partition_id;\n@@ -111,0 +112,2 @@\n+  uint32_t partition_id() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    _partition_id(page->single_partition_id()),\n@@ -105,0 +106,4 @@\n+inline uint32_t ZForwarding::partition_id() const {\n+  return _partition_id;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -253,2 +253,2 @@\n-ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n-  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age);\n+ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n+  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age, preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -61,3 +62,5 @@\n-  \/\/ Calculate headroom needed to avoid in-place relocation. Each worker will try\n-  \/\/ to allocate a small page, and all workers will share a single medium page.\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  \/\/ Calculate headroom needed to avoid in-place relocation. For each NUMA node,\n+  \/\/ each worker will try to allocate a small page, and all workers will share a\n+  \/\/ single medium page.\n+  const size_t per_numa_headroom = (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  return per_numa_headroom * ZNUMA::count();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-int ZMappedCache::EntryCompare::cmp(const IntrusiveRBNode* a, const IntrusiveRBNode* b) {\n+bool ZMappedCache::EntryCompare::cmp(const IntrusiveRBNode* a, const IntrusiveRBNode* b) {\n@@ -125,4 +125,1 @@\n-  if (vmem_a.end() < vmem_b.start()) { return -1; }\n-  if (vmem_b.end() < vmem_a.start()) { return 1; }\n-\n-  return 0; \/\/ Overlapping\n+  return vmem_a.end() < vmem_b.start();\n@@ -174,1 +171,1 @@\n-  if (_left_most == nullptr || EntryCompare::cmp(node, _left_most) < 0) {\n+  if (_left_most == nullptr || EntryCompare::cmp(node, _left_most)) {\n@@ -179,1 +176,1 @@\n-  if (_right_most == nullptr || EntryCompare::cmp(_right_most, node) < 0) {\n+  if (_right_most == nullptr || EntryCompare::cmp(_right_most, node)) {\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    static int cmp(const IntrusiveRBNode*  a, const IntrusiveRBNode* b);\n+    static bool cmp(const IntrusiveRBNode*  a, const IntrusiveRBNode* b);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, _age, ZNUMA::id());\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  assert(!is_multi_partition(), \"Don't fetch single partition id if page is multi-partition\");\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  const uint32_t             _initiating_numa_id;\n+  const uint32_t             _preferred_partition;\n@@ -423,1 +423,1 @@\n-  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age)\n+  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition)\n@@ -431,1 +431,1 @@\n-      _initiating_numa_id(ZNUMA::id()),\n+      _preferred_partition(preferred_partition),\n@@ -436,1 +436,3 @@\n-      _stall_result() {}\n+      _stall_result() {\n+    assert(_preferred_partition < ZNUMA::count(), \"Preferred partition out-of-bounds (0 <= %d < %d)\", _preferred_partition, ZNUMA::count());\n+  }\n@@ -477,2 +479,2 @@\n-  uint32_t initiating_numa_id() const {\n-    return _initiating_numa_id;\n+  uint32_t preferred_partition() const {\n+    return _preferred_partition;\n@@ -1400,1 +1402,1 @@\n-ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n+ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n@@ -1403,1 +1405,1 @@\n-  ZPageAllocation allocation(type, size, flags, age);\n+  ZPageAllocation allocation(type, size, flags, age, preferred_partition);\n@@ -1551,1 +1553,1 @@\n-  const uint32_t start_numa_id = allocation->initiating_numa_id();\n+  const uint32_t start_numa_id = allocation->preferred_partition();\n@@ -1563,1 +1565,1 @@\n-  if (!is_multi_partition_enabled() || sum_available() < allocation->size()) {\n+  if (!is_multi_partition_allowed(allocation)) {\n@@ -1581,1 +1583,1 @@\n-  const uint32_t start_node = allocation->initiating_numa_id();\n+  const uint32_t start_node = allocation->preferred_partition();\n@@ -2194,0 +2196,6 @@\n+bool ZPageAllocator::is_multi_partition_allowed(const ZPageAllocation* allocation) const {\n+  return is_multi_partition_enabled() &&\n+         allocation->type() == ZPageType::large &&\n+         allocation->size() <= sum_available();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  bool is_multi_partition_allowed(const ZPageAllocation* allocation) const;\n@@ -266,1 +267,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"gc\/z\/zValue.inline.hpp\"\n@@ -307,0 +309,25 @@\n+ZRelocationTargets::ZRelocationTargets()\n+  : _targets() {}\n+\n+ZPage* ZRelocationTargets::get(uint32_t partition_id, ZPageAge age) {\n+  return _targets.get(partition_id)[untype(age) - 1];\n+}\n+\n+void ZRelocationTargets::set(uint32_t partition_id, ZPageAge age, ZPage* page) {\n+  _targets.get(partition_id)[untype(age) - 1] = page;\n+}\n+\n+template <typename Function>\n+void ZRelocationTargets::apply_and_clear_targets(Function function) {\n+  ZPerNUMAIterator<TargetArray> iter(&_targets);\n+  for (TargetArray* targets; iter.next(&targets);) {\n+    for (size_t i = 0; i < ZNumRelocationAges; i++) {\n+      \/\/ Apply function\n+      function((*targets)[i]);\n+\n+      \/\/ Clear target\n+      (*targets)[i] = nullptr;\n+    }\n+  }\n+}\n+\n@@ -309,1 +336,5 @@\n-    _queue() {}\n+    _queue(),\n+    _iters(),\n+    _small_targets(),\n+    _medium_targets(),\n+    _shared_medium_targets() {}\n@@ -397,0 +428,1 @@\n+  const uint32_t preferred_partition = forwarding->partition_id();\n@@ -402,1 +434,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, age, preferred_partition);\n@@ -445,1 +477,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -470,5 +502,5 @@\n-  ZGeneration* const _generation;\n-  ZConditionLock     _lock;\n-  ZPage*             _shared[ZNumRelocationAges];\n-  bool               _in_place;\n-  volatile size_t    _in_place_count;\n+  ZGeneration* const  _generation;\n+  ZConditionLock      _lock;\n+  ZRelocationTargets* _shared_targets;\n+  bool                _in_place;\n+  volatile size_t     _in_place_count;\n@@ -477,1 +509,1 @@\n-  ZRelocateMediumAllocator(ZGeneration* generation)\n+  ZRelocateMediumAllocator(ZGeneration* generation, ZRelocationTargets* shared_targets)\n@@ -480,1 +512,1 @@\n-      _shared(),\n+      _shared_targets(shared_targets),\n@@ -485,3 +517,3 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      if (_shared[i] != nullptr) {\n-        retire_target_page(_generation, _shared[i]);\n+    _shared_targets->apply_and_clear_targets([&](ZPage* page) {\n+      if (page != nullptr) {\n+        retire_target_page(_generation, page);\n@@ -489,9 +521,1 @@\n-    }\n-  }\n-\n-  ZPage* shared(ZPageAge age) {\n-    return _shared[untype(age - 1)];\n-  }\n-\n-  void set_shared(ZPageAge age, ZPage* page) {\n-    _shared[untype(age - 1)] = page;\n+    });\n@@ -513,1 +537,2 @@\n-    if (shared(to_age) == target) {\n+    const uint32_t partition_id = forwarding->partition_id();\n+    if (_shared_targets->get(partition_id, to_age) == target) {\n@@ -515,1 +540,1 @@\n-      set_shared(to_age, to_page);\n+      _shared_targets->set(partition_id, to_age, to_page);\n@@ -527,1 +552,1 @@\n-    return shared(to_age);\n+    return _shared_targets->get(partition_id, to_age);\n@@ -530,1 +555,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -535,1 +560,1 @@\n-    assert(shared(age) == nullptr, \"Invalid state\");\n+    assert(_shared_targets->get(partition_id, age) == nullptr, \"Invalid state\");\n@@ -538,1 +563,1 @@\n-    set_shared(age, page);\n+    _shared_targets->set(partition_id, age, page);\n@@ -566,1 +591,1 @@\n-  ZPage*              _target[ZNumRelocationAges];\n+  ZRelocationTargets* _targets;\n@@ -572,9 +597,0 @@\n-\n-  ZPage* target(ZPageAge age) {\n-    return _target[untype(age - 1)];\n-  }\n-\n-  void set_target(ZPageAge age, ZPage* page) {\n-    _target[untype(age - 1)] = page;\n-  }\n-\n@@ -594,1 +610,1 @@\n-  zaddress try_relocate_object_inner(zaddress from_addr) {\n+  zaddress try_relocate_object_inner(zaddress from_addr, uint32_t partition_id) {\n@@ -598,1 +614,1 @@\n-    ZPage* const to_page = target(_forwarding->to_age());\n+    ZPage* const to_page = _targets->get(partition_id, _forwarding->to_age());\n@@ -809,2 +825,2 @@\n-  bool try_relocate_object(zaddress from_addr) {\n-    const zaddress to_addr = try_relocate_object_inner(from_addr);\n+  bool try_relocate_object(zaddress from_addr, uint32_t partition_id) {\n+    const zaddress to_addr = try_relocate_object_inner(from_addr, partition_id);\n@@ -891,7 +907,12 @@\n-    while (!try_relocate_object(addr)) {\n-      \/\/ Allocate a new target page, or if that fails, use the page being\n-      \/\/ relocated as the new target, which will cause it to be relocated\n-      \/\/ in-place.\n-      const ZPageAge to_age = _forwarding->to_age();\n-      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target(to_age));\n-      set_target(to_age, to_page);\n+    const ZPageAge to_age = _forwarding->to_age();\n+    const uint32_t partition_id = _forwarding->partition_id();\n+\n+    while (!try_relocate_object(addr, partition_id)) {\n+      \/\/ Failed to relocate object, try to allocate a new target page,\n+      \/\/ or if that fails, use the page being relocated as the new target,\n+      \/\/ which will cause it to be relocated in-place.\n+      ZPage* const target_page = _targets->get(partition_id, to_age);\n+      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target_page);\n+      _targets->set(partition_id, to_age, to_page);\n+\n+      \/\/ We got a new page, retry relocation\n@@ -906,1 +927,1 @@\n-      set_target(to_age, to_page);\n+      _targets->set(partition_id, to_age, to_page);\n@@ -911,1 +932,1 @@\n-  ZRelocateWork(Allocator* allocator, ZGeneration* generation)\n+  ZRelocateWork(Allocator* allocator, ZRelocationTargets* targets, ZGeneration* generation)\n@@ -914,1 +935,1 @@\n-      _target(),\n+      _targets(targets),\n@@ -920,3 +941,4 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      _allocator->free_target_page(_target[i]);\n-    }\n+    _targets->apply_and_clear_targets([&](ZPage* page) {\n+        _allocator->free_target_page(page);\n+    });\n+\n@@ -1015,2 +1037,3 @@\n-      ZPage* const target_page = target(_forwarding->to_age());\n-      _allocator->share_target_page(target_page);\n+      const uint32_t target_partition = _forwarding->partition_id();\n+      ZPage* const target_page = _targets->get(target_partition, _forwarding->to_age());\n+      _allocator->share_target_page(target_page, target_partition);\n@@ -1060,5 +1083,9 @@\n-  ZRelocationSetParallelIterator _iter;\n-  ZGeneration* const             _generation;\n-  ZRelocateQueue* const          _queue;\n-  ZRelocateSmallAllocator        _small_allocator;\n-  ZRelocateMediumAllocator       _medium_allocator;\n+  ZGeneration* const                        _generation;\n+  ZRelocateQueue* const                     _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator>* _iters;\n+  ZPerWorker<ZRelocationTargets>*           _small_targets;\n+  ZPerWorker<ZRelocationTargets>*           _medium_targets;\n+  ZRelocateSmallAllocator                   _small_allocator;\n+  ZRelocateMediumAllocator                  _medium_allocator;\n+  const size_t                              _total_forwardings;\n+  volatile size_t                           _numa_local_forwardings;\n@@ -1067,1 +1094,6 @@\n-  ZRelocateTask(ZRelocationSet* relocation_set, ZRelocateQueue* queue)\n+  ZRelocateTask(ZRelocationSet* relocation_set,\n+                ZRelocateQueue* queue,\n+                ZPerNUMA<ZRelocationSetParallelIterator>* iters,\n+                ZPerWorker<ZRelocationTargets>* small_targets,\n+                ZPerWorker<ZRelocationTargets>* medium_targets,\n+                ZRelocationTargets* shared_medium_targets)\n@@ -1069,1 +1101,0 @@\n-      _iter(relocation_set),\n@@ -1072,0 +1103,3 @@\n+      _iters(iters),\n+      _small_targets(small_targets),\n+      _medium_targets(medium_targets),\n@@ -1073,1 +1107,15 @@\n-      _medium_allocator(_generation) {}\n+      _medium_allocator(_generation, shared_medium_targets),\n+      _total_forwardings(relocation_set->nforwardings()),\n+      _numa_local_forwardings(0) {\n+\n+    for (uint32_t i = 0; i < ZNUMA::count(); i++) {\n+      ZRelocationSetParallelIterator* const iter = _iters->addr(i);\n+\n+      \/\/ Destruct the iterator from the previous GC-cycle, which is a temporary\n+      \/\/ iterator if this is the first GC-cycle.\n+      iter->~ZRelocationSetParallelIterator();\n+\n+      \/\/ In-place construct the iterator with the current relocation set\n+      ::new (iter) ZRelocationSetParallelIterator(relocation_set);\n+    }\n+  }\n@@ -1080,0 +1128,5 @@\n+\n+    if (ZNUMA::is_enabled()) {\n+      log_debug(gc, reloc, numa)(\"Forwardings relocated NUMA-locally: %zu \/ %zu (%.0f%%)\",\n+                                 _numa_local_forwardings, _total_forwardings, percent_of(_numa_local_forwardings, _total_forwardings));\n+    }\n@@ -1083,2 +1136,4 @@\n-    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _generation);\n-    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _generation);\n+    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _small_targets->addr(), _generation);\n+    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _medium_targets->addr(), _generation);\n+    const uint32_t num_nodes = ZNUMA::count();\n+    uint32_t numa_local_forwardings_worker = 0;\n@@ -1110,0 +1165,4 @@\n+    const auto check_numa_local = [&](ZForwarding* forwarding, uint32_t numa_id) {\n+      return forwarding->partition_id() == numa_id;\n+    };\n+\n@@ -1112,0 +1171,6 @@\n+      const uint32_t start_node = ZNUMA::id();\n+      uint32_t current_node = start_node;\n+\n+      for (uint32_t i = 0; i < num_nodes; i++) {\n+        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n+          claim_and_do_forwarding(forwarding);\n@@ -1113,3 +1178,10 @@\n-      if (_iter.next(&forwarding)) {\n-        claim_and_do_forwarding(forwarding);\n-        return true;\n+          if (current_node == start_node) {\n+            \/\/ Track if this forwarding was relocated on the local NUMA node\n+            numa_local_forwardings_worker++;\n+          }\n+\n+          return true;\n+        }\n+\n+        \/\/ Check next node.\n+        current_node = (current_node + 1) % num_nodes;\n@@ -1141,0 +1213,4 @@\n+    if (ZNUMA::is_enabled()) {\n+      Atomic::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n+    }\n+\n@@ -1221,1 +1297,1 @@\n-    ZRelocateTask relocate_task(relocation_set, &_queue);\n+    ZRelocateTask relocate_task(relocation_set, &_queue, &_iters, &_small_targets, &_medium_targets, &_shared_medium_targets);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":147,"deletions":71,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zValue.hpp\"\n@@ -77,0 +78,16 @@\n+class ZRelocationTargets {\n+private:\n+  using TargetArray = ZPage*[ZNumRelocationAges];\n+\n+  ZPerNUMA<TargetArray> _targets;\n+\n+public:\n+  ZRelocationTargets();\n+\n+  ZPage* get(uint32_t partition_id, ZPageAge age);\n+  void set(uint32_t partition_id, ZPageAge age, ZPage* page);\n+\n+  template <typename Function>\n+  void apply_and_clear_targets(Function function);\n+};\n+\n@@ -81,2 +98,6 @@\n-  ZGeneration* const _generation;\n-  ZRelocateQueue     _queue;\n+  ZGeneration* const                       _generation;\n+  ZRelocateQueue                           _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator> _iters;\n+  ZPerWorker<ZRelocationTargets>           _small_targets;\n+  ZPerWorker<ZRelocationTargets>           _medium_targets;\n+  ZRelocationTargets                       _shared_medium_targets;\n@@ -85,1 +106,0 @@\n-  void work(ZRelocationSetParallelIterator* iter);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+  size_t nforwardings() const;\n+\n@@ -67,0 +69,1 @@\n+  ZRelocationSetIteratorImpl();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,8 @@\n+inline size_t ZRelocationSet::nforwardings() const {\n+  return _nforwardings;\n+}\n+\n+template <bool Parallel>\n+inline ZRelocationSetIteratorImpl<Parallel>::ZRelocationSetIteratorImpl()\n+  : ZArrayIteratorImpl<ZForwarding*, Parallel>(nullptr, 0) {}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -653,1 +653,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool);\n+(JNIEnv *env, jobject jcpool);\n@@ -656,1 +656,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -659,1 +659,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -662,1 +662,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -665,1 +665,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -668,1 +668,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -671,1 +671,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -674,1 +674,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -677,1 +677,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -680,1 +680,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -683,1 +683,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -686,1 +686,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -689,1 +689,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -692,1 +692,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -695,1 +695,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -698,1 +698,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -701,1 +701,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -704,1 +704,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+       void baz(char* text) {\n+         EventText event;\n+         event.set_text(text);\n+         event.commit();\n+       }\n+\n@@ -45,0 +51,5 @@\n+       $ jfr view Text dump.jfr\n+       Time     Event Thread                             Text\n+       ======== ======================================== ==========================\n+       21:54:29 Attach Listener                          hello\n+       21:54:29 Attach Listener                          world\n@@ -46,1 +57,12 @@\n-       $ jfr print dump.jfr\n+       $ jfr query 'SELECT text, COUNT(text) FROM Text GROUP BY text ORDER BY text ASC' dump.jfr\n+\n+       Text                              Count\n+       =================== ===================\n+       hello                               622\n+       world                                37\n+\n+       $ jfr query 'SELECT COUNT(duration), AVG(duration), MEDIAN(duration), P90(duration),\n+                    P99(duration), P999(duration) FROM Duration' dump.jfr\n+\n+       The 'jfr query' command is only available in debug builds, but recordings with internal\n+       events can be generated by product builds.\n@@ -52,1 +74,2 @@\n-               System.out.println(e.getName() + \" \" + e.getDuration());\n+               EventType et = e.getEventType();\n+               System.out.println(et.getName() + \" \" + e.getDuration() + \" \" + e.getValue(\"text\"));\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -29,0 +30,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,3 +40,38 @@\n-static JfrEventThrottler* _disabled_cpu_time_sample_throttler = nullptr;\n-static JfrEventThrottler* _object_allocation_throttler = nullptr;\n-static JfrEventThrottler* _safepoint_latency_throttler = nullptr;\n+constexpr static const JfrEventId throttleble_events[] = {\n+    JfrCPUTimeSampleEvent, JfrObjectAllocationSampleEvent,  JfrSafepointLatencyEvent\n+};\n+constexpr static int num_throttled_events = sizeof(throttleble_events) \/ sizeof(throttleble_events[0]);\n+\n+\/\/ Throttler-by-ID lookup table\n+class ThrottlerLookupTable {\n+  static constexpr int max = (int)LAST_EVENT_ID;\n+  STATIC_ASSERT(max < 1000); \/\/ should this ever get unreasonably large, we rethink this table.\n+  JfrEventThrottler* _table[max];\n+public:\n+  ThrottlerLookupTable() { memset(_table, 0, sizeof(_table)); }\n+\n+  bool initialize() {\n+    for (int i = 0; i < num_throttled_events; i++) {\n+      const JfrEventId id = throttleble_events[i];\n+      JfrEventThrottler* p = JfrEventThrottler::create_throttler(id);\n+      _table[(int)id] = p;\n+      if (p == nullptr) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  void destroy() {\n+    for (int i = 0; i < max; i++) {\n+      delete _table[i];\n+      _table[i] = nullptr;\n+    }\n+  }\n+\n+  JfrEventThrottler* at(JfrEventId id) const {\n+    return _table[(int)id];\n+  }\n+};\n+\n+static ThrottlerLookupTable _throttler_table;\n@@ -52,7 +90,3 @@\n-  assert(_disabled_cpu_time_sample_throttler == nullptr, \"invariant\");\n-  _disabled_cpu_time_sample_throttler = new JfrEventThrottler(JfrCPUTimeSampleEvent);\n-  _disabled_cpu_time_sample_throttler->_disabled = true;\n-  assert(_object_allocation_throttler == nullptr, \"invariant\");\n-  _object_allocation_throttler = new JfrEventThrottler(JfrObjectAllocationSampleEvent);\n-  if (_object_allocation_throttler == nullptr || !_object_allocation_throttler->initialize()) {\n-    return false;\n+  bool rc = _throttler_table.initialize();\n+  if (rc) {\n+    _throttler_table.at(JfrCPUTimeSampleEvent)->_disabled = true; \/\/ CPU time sampler disabled\n@@ -60,3 +94,1 @@\n-  assert(_safepoint_latency_throttler == nullptr, \"invariant\");\n-  _safepoint_latency_throttler = new JfrEventThrottler(JfrSafepointLatencyEvent);\n-  return _safepoint_latency_throttler != nullptr && _safepoint_latency_throttler->initialize();\n+  return rc;\n@@ -66,6 +98,1 @@\n-  delete _disabled_cpu_time_sample_throttler;\n-  _disabled_cpu_time_sample_throttler = nullptr;\n-  delete _object_allocation_throttler;\n-  _object_allocation_throttler = nullptr;\n-  delete _safepoint_latency_throttler;\n-  _safepoint_latency_throttler = nullptr;\n+  _throttler_table.destroy();\n@@ -74,3 +101,0 @@\n-\/\/ There is currently only two throttler instances, one for the jdk.ObjectAllocationSample event\n-\/\/ and another for the SamplingLatency event.\n-\/\/ When introducing many more throttlers, consider adding a lookup map keyed by event id.\n@@ -78,14 +102,3 @@\n-  assert(_disabled_cpu_time_sample_throttler != nullptr, \"Disabled CPU time throttler has not been properly initialized\");\n-  assert(_object_allocation_throttler != nullptr, \"ObjectAllocation throttler has not been properly initialized\");\n-  assert(_safepoint_latency_throttler != nullptr, \"SafepointLatency throttler has not been properly initialized\");\n-  assert(event_id == JfrObjectAllocationSampleEvent || event_id == JfrSafepointLatencyEvent || event_id == JfrCPUTimeSampleEvent, \"Event type has an unconfigured throttler\");\n-  if (event_id == JfrObjectAllocationSampleEvent) {\n-    return _object_allocation_throttler;\n-  }\n-  if (event_id == JfrSafepointLatencyEvent) {\n-    return _safepoint_latency_throttler;\n-  }\n-  if (event_id == JfrCPUTimeSampleEvent) {\n-    return _disabled_cpu_time_sample_throttler;\n-  }\n-  return nullptr;\n+  JfrEventThrottler* const throttler = _throttler_table.at(event_id);\n+  assert(throttler != nullptr, \"Event type %d has an unconfigured throttler\", (int)event_id);\n+  return throttler;\n@@ -95,8 +108,10 @@\n-  if (event_id == JfrObjectAllocationSampleEvent) {\n-    assert(_object_allocation_throttler != nullptr, \"ObjectAllocation throttler has not been properly initialized\");\n-    _object_allocation_throttler->configure(sample_size, period_ms);\n-    return;\n-  }\n-  if (event_id == JfrSafepointLatencyEvent) {\n-    assert(_safepoint_latency_throttler != nullptr, \"SafepointLatency throttler has not been properly initialized\");\n-    _safepoint_latency_throttler->configure(sample_size, period_ms);\n+  JfrEventThrottler* const throttler = _throttler_table.at(event_id);\n+  assert(throttler != nullptr, \"Event type %d has an unconfigured throttler\", (int)event_id);\n+  throttler->configure(sample_size, period_ms);\n+}\n+\n+JfrEventThrottler* JfrEventThrottler::create_throttler(JfrEventId id) {\n+  JfrEventThrottler* p = new JfrEventThrottler(id);\n+  if (p != nullptr && p->initialize() == false) {\n+    delete p;\n+    p = nullptr;\n@@ -104,0 +119,1 @@\n+  return p;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":60,"deletions":44,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+class ThrottlerLookupTable;\n+\n@@ -34,0 +36,1 @@\n+  friend class ThrottlerLookupTable;\n@@ -46,0 +49,1 @@\n+  static JfrEventThrottler* create_throttler(JfrEventId event_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"logging\/logTagSet.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"logging\/logTagSet.hpp\"\n","filename":"src\/hotspot\/share\/logging\/log.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"utilities\/stringUtils.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n","filename":"src\/hotspot\/share\/logging\/logTag.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -90,0 +91,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -1319,0 +1321,57 @@\n+static void log_cpu_time() {\n+  LogTarget(Info, cpu) cpuLog;\n+  if (!cpuLog.is_enabled()) {\n+    return;\n+  }\n+\n+  const double process_cpu_time = os::elapsed_process_cpu_time();\n+  if (process_cpu_time == 0 || process_cpu_time == -1) {\n+    \/\/ 0 can happen e.g. for short running processes with\n+    \/\/ low CPU utilization\n+    return;\n+  }\n+\n+  const double gc_threads_cpu_time = (double) CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_SEC;\n+  const double gc_vm_thread_cpu_time = (double) CPUTimeUsage::GC::vm_thread() \/ NANOSECS_PER_SEC;\n+  const double gc_string_dedup_cpu_time = (double) CPUTimeUsage::GC::stringdedup() \/ NANOSECS_PER_SEC;\n+  const double gc_cpu_time = (double) gc_threads_cpu_time + gc_vm_thread_cpu_time + gc_string_dedup_cpu_time;\n+\n+  const double elasped_time = os::elapsedTime();\n+  const bool has_error = CPUTimeUsage::Error::has_error();\n+\n+  if (gc_cpu_time < process_cpu_time) {\n+    cpuLog.print(\"=== CPU time Statistics =============================================================\");\n+    if (has_error) {\n+      cpuLog.print(\"WARNING: CPU time sampling reported errors, numbers may be unreliable\");\n+    }\n+    cpuLog.print(\"                                                                            CPUs\");\n+    cpuLog.print(\"                                                               s       %%  utilized\");\n+    cpuLog.print(\"   Process\");\n+    cpuLog.print(\"     Total                        %30.4f  %6.2f  %8.1f\", process_cpu_time, 100.0, process_cpu_time \/ elasped_time);\n+    cpuLog.print(\"     Garbage Collection           %30.4f  %6.2f  %8.1f\", gc_cpu_time, percent_of(gc_cpu_time, process_cpu_time), gc_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       GC Threads                 %30.4f  %6.2f  %8.1f\", gc_threads_cpu_time, percent_of(gc_threads_cpu_time, process_cpu_time), gc_threads_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       VM Thread                  %30.4f  %6.2f  %8.1f\", gc_vm_thread_cpu_time, percent_of(gc_vm_thread_cpu_time, process_cpu_time), gc_vm_thread_cpu_time \/ elasped_time);\n+\n+    if (UseStringDeduplication) {\n+      cpuLog.print(\"       String Deduplication       %30.4f  %6.2f  %8.1f\", gc_string_dedup_cpu_time, percent_of(gc_string_dedup_cpu_time, process_cpu_time), gc_string_dedup_cpu_time \/ elasped_time);\n+    }\n+    cpuLog.print(\"=====================================================================================\");\n+  }\n+}\n+\n+void Universe::before_exit() {\n+  log_cpu_time();\n+  heap()->before_exit();\n+\n+  \/\/ Print GC\/heap related information.\n+  Log(gc, exit) log;\n+  if (log.is_info()) {\n+    LogStream ls_info(log.info());\n+    Universe::print_on(&ls_info);\n+    if (log.is_trace()) {\n+      LogStream ls_trace(log.trace());\n+      MutexLocker mcld(ClassLoaderDataGraph_lock);\n+      ClassLoaderDataGraph::print_on(&ls_trace);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -312,0 +312,2 @@\n+  static void before_exit();\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  CDS_JAVA_HEAP_ONLY(int archived_references_index() { return _archived_references_index; })\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  friend class AOTMapLogger;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+  inline void* base_addr();\n+  inline const void* base_addr() const;\n+\n@@ -80,1 +83,0 @@\n-  inline markWord* mark_addr() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+void* oopDesc::base_addr() { return this; }\n+const void* oopDesc::base_addr() const { return this; }\n+\n@@ -58,4 +61,0 @@\n-markWord* oopDesc::mark_addr() const {\n-  return (markWord*) &_mark;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"phasetype.hpp\"\n+\n+const char* const CompilerPhaseTypeHelper::_phase_descriptions[] = {\n+#define array_of_labels(name, description) description,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+const char* const CompilerPhaseTypeHelper::_phase_names[] = {\n+#define array_of_labels(name, description) #name,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+CompilerPhaseType CompilerPhaseTypeHelper::find_phase(const char* str) {\n+  for (int i = 0; i < PHASE_NUM_TYPES; i++) {\n+    if (strcmp(CompilerPhaseTypeHelper::_phase_names[i], str) == 0) {\n+      return (CompilerPhaseType)i;\n+    }\n+  }\n+  return PHASE_NONE;\n+}\n","filename":"src\/hotspot\/share\/opto\/phasetype.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -143,12 +143,0 @@\n-static const char* phase_descriptions[] = {\n-#define array_of_labels(name, description) description,\n-       COMPILER_PHASES(array_of_labels)\n-#undef array_of_labels\n-};\n-\n-static const char* phase_names[] = {\n-#define array_of_labels(name, description) #name,\n-       COMPILER_PHASES(array_of_labels)\n-#undef array_of_labels\n-};\n-\n@@ -156,1 +144,5 @@\n-  public:\n+ private:\n+  static const char* const _phase_descriptions[];\n+  static const char* const _phase_names[];\n+\n+ public:\n@@ -158,1 +150,1 @@\n-    return phase_names[cpt];\n+    return _phase_names[cpt];\n@@ -161,1 +153,1 @@\n-    return phase_descriptions[cpt];\n+    return _phase_descriptions[cpt];\n@@ -163,1 +155,0 @@\n-};\n@@ -165,8 +156,2 @@\n-static CompilerPhaseType find_phase(const char* str) {\n-  for (int i = 0; i < PHASE_NUM_TYPES; i++) {\n-    if (strcmp(phase_names[i], str) == 0) {\n-      return (CompilerPhaseType)i;\n-    }\n-  }\n-  return PHASE_NONE;\n-}\n+  static CompilerPhaseType find_phase(const char* str);\n+};\n@@ -188,1 +173,1 @@\n-      CompilerPhaseType cpt = find_phase(*iter);\n+      CompilerPhaseType cpt = CompilerPhaseTypeHelper::find_phase(*iter);\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -698,0 +698,5 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n@@ -802,0 +807,6 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -975,0 +986,6 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -1029,0 +1046,5 @@\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -1472,0 +1494,4 @@\n+  if( CC == TypeInt::CC_NE ) {\n+    if( _test == ne ) return TypeInt::ONE;\n+    if( _test == eq ) return TypeInt::ZERO;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2108,1 +2108,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj))\n@@ -2116,1 +2116,1 @@\n-JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jint index))\n@@ -2129,1 +2129,1 @@\n-JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2172,1 +2172,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jint index))\n@@ -2182,1 +2182,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2217,1 +2217,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jint index))\n@@ -2227,1 +2227,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2237,1 +2237,1 @@\n-JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jint index))\n@@ -2262,1 +2262,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jint index))\n@@ -2275,1 +2275,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jint index))\n@@ -2288,1 +2288,1 @@\n-JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jint index))\n@@ -2309,1 +2309,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jint index))\n@@ -2321,1 +2321,1 @@\n-JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jint index))\n@@ -2333,1 +2333,1 @@\n-JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jint index))\n@@ -2345,1 +2345,1 @@\n-JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jint index))\n@@ -2357,1 +2357,1 @@\n-JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jint index))\n@@ -2370,1 +2370,1 @@\n-JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jint index))\n@@ -2385,1 +2385,1 @@\n-JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jint index))\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -78,4 +78,1 @@\n-  \/\/ Ensure that we are only incrementing atomically by using Atomic::cmpxchg\n-  \/\/ to set the value to zero after we obtain the new CPU time difference.\n-  jlong old_value;\n-  jlong fetched_value = Atomic::load(&(instance->_gc_total_cpu_time_diff));\n+  \/\/ Atomically fetch the current _gc_total_cpu_time_diff and reset it to zero.\n@@ -83,4 +80,1 @@\n-  do {\n-    old_value = fetched_value;\n-    fetched_value = Atomic::cmpxchg(&(instance->_gc_total_cpu_time_diff), old_value, new_value);\n-  } while (old_value != fetched_value);\n+  jlong fetched_value = Atomic::xchg(&(instance->_gc_total_cpu_time_diff), new_value);\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3049,2 +3049,0 @@\n-            if (bc_case == BC_CASE_LIMIT && (int)bc == 0)\n-              bc = Bytecodes::_illegal;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,13 +478,1 @@\n-  Universe::heap()->before_exit();\n-\n-  \/\/ Print GC\/heap related information.\n-  Log(gc, exit) log;\n-  if (log.is_info()) {\n-    LogStream ls_info(log.info());\n-    Universe::print_on(&ls_info);\n-    if (log.is_trace()) {\n-      LogStream ls_trace(log.trace());\n-      MutexLocker mcld(ClassLoaderDataGraph_lock);\n-      ClassLoaderDataGraph::print_on(&ls_trace);\n-    }\n-  }\n+  Universe::before_exit();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -49,1 +49,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -51,0 +50,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/perfDataTypes.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/perfDataTypes.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupProcessor.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/perfData.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/cpuTimeUsage.hpp\"\n+\n+volatile bool CPUTimeUsage::Error::_has_error = false;\n+\n+static inline jlong thread_cpu_time_or_zero(Thread* thread) {\n+  jlong cpu_time = os::thread_cpu_time(thread);\n+  if (cpu_time == -1) {\n+    CPUTimeUsage::Error::mark_error();\n+    return 0;\n+  }\n+  return cpu_time;\n+}\n+\n+class CPUTimeThreadClosure : public ThreadClosure {\n+private:\n+  jlong _cpu_time = 0;\n+\n+public:\n+  virtual void do_thread(Thread* thread) {\n+    _cpu_time += thread_cpu_time_or_zero(thread);\n+  }\n+  jlong cpu_time() { return _cpu_time; };\n+};\n+\n+jlong CPUTimeUsage::GC::vm_thread() {\n+  return Universe::heap()->_vmthread_cpu_time;\n+}\n+\n+jlong CPUTimeUsage::GC::gc_threads() {\n+  CPUTimeThreadClosure cl;\n+  Universe::heap()->gc_threads_do(&cl);\n+  return cl.cpu_time();\n+}\n+\n+jlong CPUTimeUsage::GC::total() {\n+  return gc_threads() + vm_thread() + stringdedup();\n+}\n+\n+jlong CPUTimeUsage::GC::stringdedup() {\n+  if (UseStringDeduplication) {\n+    return thread_cpu_time_or_zero((Thread*)StringDedup::_processor->_thread);\n+  }\n+  return 0;\n+}\n+\n+bool CPUTimeUsage::Error::has_error() {\n+  return Atomic::load(&_has_error);\n+}\n+\n+void CPUTimeUsage::Error::mark_error() {\n+  Atomic::store(&_has_error, true);\n+}\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_CPUTIMEUSAGE_HPP\n+#define SHARE_SERVICES_CPUTIMEUSAGE_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+namespace CPUTimeUsage {\n+  class GC : public AllStatic {\n+  public:\n+    static jlong total();\n+    static jlong gc_threads();\n+    static jlong vm_thread();\n+    static jlong stringdedup();\n+  };\n+\n+  class Error : public AllStatic {\n+  private:\n+    static volatile bool _has_error;\n+\n+  public:\n+    static bool has_error();\n+    static void mark_error();\n+  };\n+}\n+\n+#endif \/\/ SHARE_SERVICES_CPUTIMEUSAGE_HPP\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n- * <p> Whether a virtual machine has a console is dependent upon the\n+ * <p> Whether a virtual machine's console exists is dependent upon the\n@@ -45,1 +45,1 @@\n- * output streams then its console will exist and will typically be\n+ * output streams, then its console will generally exist and will be\n@@ -47,3 +47,4 @@\n- * was launched.  If the virtual machine is started automatically, for\n- * example by a background job scheduler, then it may not\n- * have a console.\n+ * was launched. If the standard input or standard output have been\n+ * redirected (for example, to a file or to a pipe), or if the virtual\n+ * machine was started from a background job scheduler, the console\n+ * will not exist.\n@@ -51,4 +52,3 @@\n- * If this virtual machine has a console then it is represented by a\n- * unique instance of this class which can be obtained by invoking the\n- * {@link java.lang.System#console()} method.  If no console device is\n- * available then an invocation of that method will return {@code null}.\n+ * If the console exists, then it is represented by a unique instance of this\n+ * class which can be obtained by invoking the {@link System#console()} method.\n+ * If the console does not exist, that method will return {@code null}.\n@@ -538,7 +538,3 @@\n-     * This method returns {@code true} if the console device, associated with the current\n-     * Java virtual machine, is a terminal, typically an interactive command line\n-     * connected to a keyboard and display.\n-     *\n-     * @implNote The default implementation returns the value equivalent to calling\n-     * {@code isatty(stdin\/stdout)} on POSIX platforms, or whether standard in\/out file\n-     * descriptors are character devices or not on Windows.\n+     * This method always returns {@code true}, since {@link System#console()}\n+     * provides a {@code Console} instance only when both standard input and\n+     * output are unredirected, that is, when running in an interactive terminal.\n@@ -549,1 +545,1 @@\n-        return istty;\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -1052,3 +1053,9 @@\n-        Class<?> c = defineClass2(this, name, b, b.position(), len, protectionDomain, source);\n-        postDefineClass(c, protectionDomain);\n-        return c;\n+\n+        SharedSecrets.getJavaNioAccess().acquireSession(b);\n+        try {\n+            Class<?> c = defineClass2(this, name, b, b.position(), len, protectionDomain, source);\n+            postDefineClass(c, protectionDomain);\n+            return c;\n+        } finally {\n+            SharedSecrets.getJavaNioAccess().releaseSession(b);\n+        }\n@@ -1060,0 +1067,2 @@\n+    \/\/ Warning: Before calling this method, the provided ByteBuffer must be guarded\n+    \/\/          via JavaNioAccess::(acquire|release)Session\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-     * Returns the unique {@link java.io.Console Console} object associated\n+     * Returns the unique {@link Console Console} object associated\n@@ -245,0 +245,1 @@\n+     * @see Console\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-     * @spec security\/standard-names.html Java Security Standard Algorithm Names\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-     * @spec security\/standard-names.html Java Security Standard Algorithm Names\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-     * @spec security\/standard-names.html Java Security Standard Algorithm Names\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n- * <h3>Negative Subpatterns<\/h3>\n+ * <h3><a id=\"negative_subpatterns\">Negative Subpatterns<\/a><\/h3>\n@@ -162,1 +162,4 @@\n- * as {@code \"0K;-0K\"}.\n+ * as {@code \"0K;-0K\"}. In {@link NumberFormat##leniency lenient parsing}\n+ * mode, loose matching of the minus sign pattern is enabled, following the\n+ * LDML’s <a href=\"https:\/\/unicode.org\/reports\/tr35\/#Loose_Matching\">\n+ * loose matching<\/a> specification.\n@@ -1588,0 +1591,3 @@\n+     * When lenient, the minus sign in the {@link ##negative_subpatterns\n+     * negative subpatterns} is loosely matched against lenient minus sign characters.\n+     * <p>\n@@ -1696,2 +1702,1 @@\n-            if (text.regionMatches(pos.index, defaultPosPrefix, 0,\n-                    defaultPosPrefix.length())) {\n+            if (decimalFormat.matchAffix(text, position, defaultPosPrefix)) {\n@@ -1702,2 +1707,1 @@\n-            if (text.regionMatches(pos.index, defaultNegPrefix, 0,\n-                    defaultNegPrefix.length())) {\n+            if (decimalFormat.matchAffix(text, position, defaultNegPrefix)) {\n@@ -1927,1 +1931,1 @@\n-                return text.regionMatches(position, affix, 0, affix.length());\n+                return decimalFormat.matchAffix(text, position, affix);\n@@ -2029,2 +2033,1 @@\n-            boolean containsPosSuffix = text.regionMatches(position,\n-                    positiveSuffix, 0, positiveSuffix.length());\n+            boolean containsPosSuffix = decimalFormat.matchAffix(text, position, positiveSuffix);\n@@ -2038,2 +2041,1 @@\n-            boolean containsNegSuffix = text.regionMatches(position,\n-                    negativeSuffix, 0, negativeSuffix.length());\n+            boolean containsNegSuffix = decimalFormat.matchAffix(text, position, negativeSuffix);\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n- * <h3>Negative Subpatterns<\/h3>\n+ * <h3><a id=\"negative_subpatterns\">Negative Subpatterns<\/a><\/h3>\n@@ -310,1 +310,5 @@\n- * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n+ * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}. In\n+ * {@link NumberFormat##leniency lenient parsing} mode, loose matching of the\n+ * minus sign pattern is enabled, following the LDML’s\n+ * <a href=\"https:\/\/unicode.org\/reports\/tr35\/#Loose_Matching\">\n+ * loose matching<\/a> specification.\n@@ -2192,0 +2196,3 @@\n+     * When lenient, the minus sign in the {@link ##negative_subpatterns\n+     * negative subpatterns} is loosely matched against lenient minus sign characters.\n+     * <p>\n@@ -2388,4 +2395,2 @@\n-        gotPositive = text.regionMatches(position, positivePrefix, 0,\n-                positivePrefix.length());\n-        gotNegative = text.regionMatches(position, negativePrefix, 0,\n-                negativePrefix.length());\n+        gotPositive = matchAffix(text, position, positivePrefix);\n+        gotNegative = matchAffix(text, position, negativePrefix);\n@@ -2427,2 +2432,1 @@\n-                boolean containsPosSuffix =\n-                        text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\n+                boolean containsPosSuffix = matchAffix(text, position, positiveSuffix);\n@@ -2434,2 +2438,1 @@\n-                boolean containsNegSuffix =\n-                        text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\n+                boolean containsNegSuffix = matchAffix(text, position, negativeSuffix);\n@@ -3504,0 +3507,48 @@\n+    \/**\n+     * {@return true if the text matches the affix}\n+     * In lenient mode, lenient minus signs also match the hyphen-minus\n+     * (U+002D). Package-private access, as this is called from\n+     * CompactNumberFormat.\n+     *\n+     * Note: Minus signs in the supplementary character range or normalization\n+     * equivalents are not matched, as they may alter the affix length.\n+     *\/\n+    boolean matchAffix(String text, int position, String affix) {\n+        var alen = affix.length();\n+        var tlen = text.length();\n+\n+        if (alen == 0) {\n+            \/\/ always match with an empty affix, as affix is optional\n+            return true;\n+        }\n+        if (position >= tlen) {\n+            return false;\n+        }\n+        if (parseStrict) {\n+            return text.regionMatches(position, affix, 0, alen);\n+        }\n+\n+        var lms = symbols.getLenientMinusSigns();\n+        int i = 0;\n+        int limit = Math.min(tlen, position + alen);\n+        for (; position + i < limit; i++) {\n+            char t = text.charAt(position + i);\n+            char a = affix.charAt(i);\n+            int tIndex = lms.indexOf(t);\n+            int aIndex = lms.indexOf(a);\n+            \/\/ Non LMS. Match direct\n+            if (tIndex < 0 && aIndex < 0) {\n+                if (t != a) {\n+                    return false;\n+                }\n+            } else {\n+                \/\/ By here, at least one LMS. Ensure both LMS.\n+                if (tIndex < 0 || aIndex < 0) {\n+                    return false;\n+                }\n+            }\n+        }\n+        \/\/ Return true if entire affix was matched\n+        return i == alen;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":61,"deletions":10,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -721,0 +721,11 @@\n+    \/**\n+     * {@return the lenient minus signs} Multiple lenient minus signs\n+     * are concatenated to form the returned string. Each codepoint\n+     * in the string is a valid minus sign pattern. If there are no\n+     * lenient minus signs defined in this locale, {@code minusSignText}\n+     * is returned.\n+     *\/\n+    String getLenientMinusSigns() {\n+        return lenientMinusSigns;\n+    }\n+\n@@ -821,12 +832,1 @@\n-        \/\/ check for region override\n-        Locale override = locale.getUnicodeLocaleType(\"nu\") == null ?\n-            CalendarDataUtility.findRegionOverride(locale) :\n-            locale;\n-\n-        \/\/ get resource bundle data\n-        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);\n-        \/\/ Avoid potential recursions\n-        if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n-            adapter = LocaleProviderAdapter.getResourceBundleBased();\n-        }\n-        Object[] data = adapter.getLocaleResources(override).getDecimalFormatSymbolsData();\n+        Object[] data = loadNumberData(locale);\n@@ -857,0 +857,3 @@\n+        \/\/ Lenient minus signs\n+        lenientMinusSigns = numberElements.length < 14 ? minusSignText : numberElements[13];\n+\n@@ -862,0 +865,16 @@\n+    private Object[] loadNumberData(Locale locale) {\n+        \/\/ check for region override\n+        Locale override = locale.getUnicodeLocaleType(\"nu\") == null ?\n+            CalendarDataUtility.findRegionOverride(locale) :\n+            locale;\n+\n+        \/\/ get resource bundle data\n+        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);\n+        \/\/ Avoid potential recursions\n+        if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n+            adapter = LocaleProviderAdapter.getResourceBundleBased();\n+        }\n+\n+        return adapter.getLocaleResources(override).getDecimalFormatSymbolsData();\n+    }\n+\n@@ -998,0 +1017,8 @@\n+\n+        if (loadNumberData(locale) instanceof Object[] d &&\n+            d[0] instanceof String[] numberElements &&\n+            numberElements.length >= 14) {\n+            lenientMinusSigns = numberElements[13];\n+        } else {\n+            lenientMinusSigns = minusSignText;\n+        }\n@@ -1177,0 +1204,3 @@\n+    \/\/ Lenient minus. No need to be set by applications\n+    private transient String lenientMinusSigns;\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+import java.nio.charset.StandardCharsets;\n+\n+import jdk.internal.access.SharedSecrets;\n@@ -106,1 +109,1 @@\n-    public char[] digits = new char[MAX_COUNT];\n+    public byte[] digits = new byte[MAX_COUNT];\n@@ -108,1 +111,1 @@\n-    private char[] data;\n+    private byte[] data;\n@@ -157,1 +160,1 @@\n-            char[] data = new char[ArraysSupport.newLength(count, 1, count)];\n+            byte[] data = new byte[ArraysSupport.newLength(count, 1, count)];\n@@ -161,1 +164,1 @@\n-        digits[count++] = digit;\n+        digits[count++] = (byte) digit;\n@@ -191,1 +194,1 @@\n-        long v = Long.parseUnsignedLong(new String(digits, 0, count));\n+        long v = Long.parseUnsignedLong(new String(digits, 0, count, StandardCharsets.ISO_8859_1));\n@@ -212,0 +215,1 @@\n+        int count = this.count;\n@@ -216,5 +220,9 @@\n-       if (decimalAt == count) {\n-           return new BigDecimal(digits, 0, count);\n-       } else {\n-           return new BigDecimal(digits, 0, count).scaleByPowerOfTen(decimalAt - count);\n-       }\n+        char[] chars = new char[count];\n+        SharedSecrets.getJavaLangAccess()\n+                     .inflateBytesToChars(digits, 0, chars, 0, count);\n+        BigDecimal value = new BigDecimal(chars, 0, count);\n+        if (decimalAt == count) {\n+            return value;\n+        } else {\n+            return value.scaleByPowerOfTen(decimalAt - count);\n+        }\n@@ -259,1 +267,1 @@\n-            char dig = digits[i], max = LONG_MIN_REP[i];\n+            byte dig = digits[i], max = LONG_MIN_REP[i];\n@@ -320,1 +328,0 @@\n-        String digitsString = fdConverter.toJavaFormatString();\n@@ -322,1 +329,3 @@\n-        set(isNegative, digitsString,\n+        byte[] chars = getDataChars(26);\n+        int len = fdConverter.getChars(chars);\n+        set(isNegative, chars, len,\n@@ -334,1 +343,1 @@\n-    private void set(boolean isNegative, String s,\n+    private void set(boolean isNegative, byte[] source, int len,\n@@ -339,3 +348,0 @@\n-        int len = s.length();\n-        char[] source = getDataChars(len);\n-        s.getChars(0, len, source, 0);\n@@ -352,1 +358,1 @@\n-            char c = source[i++];\n+            byte c = source[i++];\n@@ -636,1 +642,1 @@\n-                digits[--left] = (char)('0' + (source % 10));\n+                digits[--left] = (byte)('0' + (source % 10));\n@@ -664,0 +670,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -668,1 +675,4 @@\n-        set(isNegative, s,\n+        int len = s.length();\n+        byte[] chars = getDataChars(len);\n+        s.getBytes(0, len, chars, 0);\n+        set(isNegative, chars, len,\n@@ -681,0 +691,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -686,1 +697,1 @@\n-        s.getChars(0, len, digits, 0);\n+        s.getBytes(0, len, digits, 0);\n@@ -737,1 +748,1 @@\n-            char[] newDigits = new char[digits.length];\n+            byte[] newDigits = new byte[digits.length];\n@@ -752,2 +763,2 @@\n-    private static int parseInt(char[] str, int offset, int strLen) {\n-        char c;\n+    private static int parseInt(byte[] str, int offset, int strLen) {\n+        byte c;\n@@ -775,1 +786,1 @@\n-    private static final char[] LONG_MIN_REP = \"9223372036854775808\".toCharArray();\n+    private static final byte[] LONG_MIN_REP = \"9223372036854775808\".getBytes(StandardCharsets.ISO_8859_1);\n@@ -782,1 +793,1 @@\n-        return \"0.\" + new String(digits, 0, count) + \"x10^\" + decimalAt;\n+        return \"0.\" + new String(digits, 0, count, StandardCharsets.ISO_8859_1) + \"x10^\" + decimalAt;\n@@ -787,1 +798,1 @@\n-            digits = new char[len];\n+            digits = new byte[len];\n@@ -791,1 +802,1 @@\n-    private char[] getDataChars(int length) {\n+    private byte[] getDataChars(int length) {\n@@ -793,1 +804,1 @@\n-            data = new char[length];\n+            data = new byte[length];\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":40,"deletions":29,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -198,1 +198,5 @@\n- * {@code 1000} out of the String \"$1,000.00 was paid\".\n+ * {@code 1000} out of the String \"$1,000.00 was paid\". Lenient parsing also\n+ * allows loose matching of characters in the source text. For example, an\n+ * implementation of the {@code NumberFormat} class may allow matching \"−\"\n+ * (U+2212 MINUS SIGN) to the \"-\" (U+002D HYPHEN-MINUS) pattern character\n+ * when used as a negative prefix.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1202,2 +1202,4 @@\n-     * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}\n-     * will be used to parse the offset, converting the instant to UTC as necessary.\n+     * When parsing, the lenient mode behavior of\n+     * {@link DateTimeFormatterBuilder#appendOffset(String, String)\n+     * appendOffset(\"+HH\", \"Z\")} will be used to parse the offset,\n+     * converting the instant to UTC as necessary.\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -897,2 +897,4 @@\n-     * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}\n-     * will be used to parse the offset, converting the instant to UTC as necessary.\n+     * When parsing, the lenient mode behaviour of\n+     * {@link DateTimeFormatterBuilder#appendOffset(String, String)\n+     * appendOffset(\"+HH\", \"Z\")} will be used to parse the offset,\n+     * converting the instant to UTC as necessary.\n@@ -959,1 +961,1 @@\n-     * This is equivalent to calling {@code appendOffset(\"+HH:mm:ss\", \"Z\")}.\n+     * This is equivalent to calling {@code appendOffset(\"+HH:MM:ss\", \"Z\")}.\n@@ -3890,1 +3892,2 @@\n-                    .appendOffsetId()\n+                    .parseLenient()\n+                    .appendOffset(\"+HH\", \"Z\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,13 @@\n+    \/**\n+     * Adjusts the given {@link TemporalAccessor} using chronology and time-zone from a formatter if present.\n+     * <p>\n+     * This method serves as an optimization front-end that checks for non-null overrides in the formatter.\n+     * If neither chronology nor time-zone is specified in the formatter, returns the original temporal unchanged.\n+     * Otherwise, delegates to the core adjustment method {@link #adjustWithOverride(TemporalAccessor, Chronology, ZoneId)}.\n+     *\n+     * @implNote Optimizes for the common case where formatters don't specify chronology\/time-zone\n+     *           by avoiding unnecessary processing. Most formatters have null for these properties.\n+     * @param temporal  the temporal object to adjust, not null\n+     * @param formatter the formatter providing potential chronology and time-zone overrides\n+     * @return the adjusted temporal, or the original if no overrides are present in the formatter\n+     *\/\n@@ -131,0 +144,26 @@\n+        \/\/ Placing the non-null cases in a separate method allows more flexible code optimizations\n+        return adjustWithOverride(temporal, overrideChrono, overrideZone);\n+    }\n+\n+    \/**\n+     * Adjusts the given {@link TemporalAccessor} with optional overriding chronology and time-zone.\n+     * <p>\n+     * This method minimizes changes by returning the original temporal if the override parameters\n+     * are either {@code null} or equivalent to those already present in the temporal. When overrides\n+     * are applied:\n+     * <ul>\n+     *   <li>If a time-zone override is provided and the temporal supports {@link ChronoField#INSTANT_SECONDS},\n+     *       the result is a zoned date-time using the override time-zone and chronology (defaulting to ISO if not overridden).<\/li>\n+     *   <li>Other cases (including partial date-times or mixed chronology\/time-zone changes) are delegated\n+     *       to a secondary adjustment method.<\/li>\n+     * <\/ul>\n+     *\n+     * @param temporal       the temporal object to adjust, not null\n+     * @param overrideChrono the chronology to override (null retains the original chronology)\n+     * @param overrideZone   the time-zone to override (null retains the original time-zone)\n+     * @return the adjusted temporal, which may be the original object if no effective changes were made,\n+     *         or a new object with the applied overrides\n+     * @implNote Optimizes for common cases where overrides are identical to existing values\n+     *           or where instant-based temporals can be directly converted with a time-zone.\n+     *\/\n+    private static TemporalAccessor adjustWithOverride(TemporalAccessor temporal, Chronology overrideChrono, ZoneId overrideZone) {\n@@ -152,0 +191,47 @@\n+        }\n+\n+        \/\/ Split uncommon code branches into a separate method\n+        return adjustSlow(temporal, overrideZone, temporalZone, overrideChrono, effectiveChrono, temporalChrono);\n+    }\n+\n+    \/**\n+     * Internal helper method to adjust temporal fields using override chronology and time-zone in complex cases.\n+     * <p>\n+     * Handles non-instant temporal objects by creating a delegate {@link TemporalAccessor} that combines:\n+     * <ul>\n+     *   <li>The original temporal's time-related fields<\/li>\n+     *   <li>Date fields converted to the effective chronology (if available)<\/li>\n+     *   <li>Override zone\/chronology information for temporal queries<\/li>\n+     * <\/ul>\n+     *\n+     * Performs critical validation before processing:\n+     * <ul>\n+     *   <li>Rejects offset changes for non-instant temporal objects with existing offsets<\/li>\n+     *   <li>Verifies date field integrity when applying chronology overrides to partial dates<\/li>\n+     * <\/ul>\n+     *\n+     * @param temporal        the original temporal object to adjust, not null\n+     * @param overrideZone    override time-zone (nullable)\n+     * @param temporalZone    original time-zone from temporal (nullable)\n+     * @param overrideChrono  override chronology (nullable)\n+     * @param effectiveChrono precomputed effective chronology (override if present, otherwise temporal's chronology)\n+     * @param temporalChrono  original chronology from temporal (nullable)\n+     * @return adjusted temporal accessor combining original fields with overrides\n+     * @throws DateTimeException if:\n+     *         <ul>\n+     *           <li>Applying a {@link ZoneOffset} override to a temporal with conflicting existing offset that doesn't represent an instant<\/li>\n+     *           <li>Applying chronology override to temporal with partial date fields<\/li>\n+     *         <\/ul>\n+     * @implNote Creates an anonymous temporal accessor that:\n+     *         <ul>\n+     *           <li>Delegates time-based fields to original temporal<\/li>\n+     *           <li>Uses converted date fields when chronology override is applied<\/li>\n+     *           <li>Responds to chronology\/zone queries with effective values<\/li>\n+     *           <li>Preserves precision queries from original temporal<\/li>\n+     *         <\/ul>\n+     *\/\n+    private static TemporalAccessor adjustSlow(\n+            TemporalAccessor temporal,\n+            ZoneId overrideZone, ZoneId temporalZone,\n+            Chronology overrideChrono, Chronology effectiveChrono, Chronology temporalChrono) {\n+        if (overrideZone != null) {\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimePrintContext.java","additions":87,"deletions":1,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -63,38 +63,0 @@\n-    \/**\n-     * Converts a double precision floating point value to a <code>String<\/code>.\n-     *\n-     * @param d The double precision value.\n-     * @return The value converted to a <code>String<\/code>.\n-     *\/\n-    public static String toJavaFormatString(double d) {\n-        return getBinaryToASCIIConverter(d).toJavaFormatString();\n-    }\n-\n-    \/**\n-     * Converts a single precision floating point value to a <code>String<\/code>.\n-     *\n-     * @param f The single precision value.\n-     * @return The value converted to a <code>String<\/code>.\n-     *\/\n-    public static String toJavaFormatString(float f) {\n-        return getBinaryToASCIIConverter(f).toJavaFormatString();\n-    }\n-\n-    \/**\n-     * Appends a double precision floating point value to an <code>Appendable<\/code>.\n-     * @param d The double precision value.\n-     * @param buf The <code>Appendable<\/code> with the value appended.\n-     *\/\n-    public static void appendTo(double d, Appendable buf) {\n-        getBinaryToASCIIConverter(d).appendTo(buf);\n-    }\n-\n-    \/**\n-     * Appends a single precision floating point value to an <code>Appendable<\/code>.\n-     * @param f The single precision value.\n-     * @param buf The <code>Appendable<\/code> with the value appended.\n-     *\/\n-    public static void appendTo(float f, Appendable buf) {\n-        getBinaryToASCIIConverter(f).appendTo(buf);\n-    }\n-\n@@ -134,1 +96,1 @@\n-    public static double parseDoubleSignlessDigits(int decExp, char[] digits, int length) {\n+    public static double parseDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n@@ -143,11 +105,1 @@\n-        \/**\n-         * Converts a floating point value into an ASCII <code>String<\/code>.\n-         * @return The value converted to a <code>String<\/code>.\n-         *\/\n-        String toJavaFormatString();\n-\n-        \/**\n-         * Appends a floating point value to an <code>Appendable<\/code>.\n-         * @param buf The <code>Appendable<\/code> to receive the value.\n-         *\/\n-        void appendTo(Appendable buf);\n+        int getChars(byte[] result);\n@@ -212,13 +164,4 @@\n-        public String toJavaFormatString() {\n-            return image;\n-        }\n-\n-        @Override\n-        public void appendTo(Appendable buf) {\n-            if (buf instanceof StringBuilder) {\n-                ((StringBuilder) buf).append(image);\n-            } else if (buf instanceof StringBuffer) {\n-                ((StringBuffer) buf).append(image);\n-            } else {\n-                assert false;\n-            }\n+        @SuppressWarnings(\"deprecation\")\n+        public int getChars(byte[] chars) {\n+            image.getBytes(0, image.length(), chars, 0);\n+            return image.length();\n@@ -264,2 +207,2 @@\n-    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new char[]{'0'});\n-    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new char[]{'0'});\n+    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new byte[]{'0'});\n+    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new byte[]{'0'});\n@@ -275,2 +218,1 @@\n-        private final char[] digits;\n-        private final char[] buffer = new char[26];\n+        private final byte[] digits;\n@@ -296,1 +238,1 @@\n-            this.digits = new char[20];\n+            this.digits = new byte[20];\n@@ -302,1 +244,1 @@\n-        BinaryToASCIIBuffer(boolean isNegative, char[] digits){\n+        BinaryToASCIIBuffer(boolean isNegative, byte[] digits){\n@@ -310,18 +252,0 @@\n-        @Override\n-        public String toJavaFormatString() {\n-            int len = getChars(buffer);\n-            return new String(buffer, 0, len);\n-        }\n-\n-        @Override\n-        public void appendTo(Appendable buf) {\n-            int len = getChars(buffer);\n-            if (buf instanceof StringBuilder) {\n-                ((StringBuilder) buf).append(buffer, 0, len);\n-            } else if (buf instanceof StringBuffer) {\n-                ((StringBuffer) buf).append(buffer, 0, len);\n-            } else {\n-                assert false;\n-            }\n-        }\n-\n@@ -406,1 +330,1 @@\n-                    digits[digitno--] = (char)(c+'0');\n+                    digits[digitno--] = (byte)(c+'0');\n@@ -411,1 +335,1 @@\n-                digits[digitno] = (char)(c+'0');\n+                digits[digitno] = (byte)(c+'0');\n@@ -423,1 +347,1 @@\n-                    digits[digitno--] = (char)(c+'0');\n+                    digits[digitno--] = (byte) (c+'0');\n@@ -428,1 +352,1 @@\n-                digits[digitno] = (char)(c+'0');\n+                digits[digitno] = (byte)(c+'0');\n@@ -629,1 +553,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -657,1 +581,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -683,1 +607,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -711,1 +635,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -744,1 +668,1 @@\n-                    digits[ndigit++] = (char)('0' + q);\n+                    digits[ndigit++] = (byte)('0' + q);\n@@ -761,1 +685,1 @@\n-                    digits[ndigit++] = (char)('0' + q);\n+                    digits[ndigit++] = (byte)('0' + q);\n@@ -815,1 +739,1 @@\n-            digits[i] = (char) (q + 1);\n+            digits[i] = (byte) (q + 1);\n@@ -848,8 +772,0 @@\n-        private static int insignificantDigits(long insignificant) {\n-            int i;\n-            for ( i = 0; insignificant >= 10L; i++ ) {\n-                insignificant \/= 10L;\n-            }\n-            return i;\n-        }\n-\n@@ -858,3 +774,0 @@\n-         * <pre>\n-         * insignificantDigitsForPow2(v) == insignificantDigits(1L<<v)\n-         * <\/pre>\n@@ -916,1 +829,8 @@\n-        private int getChars(char[] result) {\n+        \/**\n+         * Converts the decimal representation of a floating-point number into its\n+         * ASCII character representation and stores it in the provided byte array.\n+         *\n+         * @param result the byte array to store the ASCII representation, must have length at least 26\n+         * @return the number of characters written to the result array\n+         *\/\n+        public int getChars(byte[] result) {\n@@ -930,1 +850,1 @@\n-                    Arrays.fill(result,i,i+charLength,'0');\n+                    Arrays.fill(result, i, i + charLength, (byte) '0');\n@@ -938,1 +858,1 @@\n-                        System.arraycopy(digits, firstDigitIndex+charLength, result, i, t);\n+                        System.arraycopy(digits, firstDigitIndex + charLength, result, i, t);\n@@ -948,1 +868,1 @@\n-                    Arrays.fill(result, i, i-decExponent, '0');\n+                    Arrays.fill(result, i, i-decExponent, (byte) '0');\n@@ -972,1 +892,1 @@\n-                    result[i++] = (char) (e + '0');\n+                    result[i++] = (byte) (e + '0');\n@@ -974,2 +894,2 @@\n-                    result[i++] = (char) (e \/ 10 + '0');\n-                    result[i++] = (char) (e % 10 + '0');\n+                    result[i++] = (byte) (e \/ 10 + '0');\n+                    result[i++] = (byte) (e % 10 + '0');\n@@ -977,1 +897,1 @@\n-                    result[i++] = (char) (e \/ 100 + '0');\n+                    result[i++] = (byte) (e \/ 100 + '0');\n@@ -979,2 +899,2 @@\n-                    result[i++] = (char) (e \/ 10 + '0');\n-                    result[i++] = (char) (e % 10 + '0');\n+                    result[i++] = (byte) (e \/ 10 + '0');\n+                    result[i++] = (byte) (e % 10 + '0');\n@@ -1046,4 +966,4 @@\n-        boolean     isNegative;\n-        int         decExponent;\n-        byte[]      digits;\n-        int         nDigits;\n+        final boolean isNegative;\n+        final int     decExponent;\n+        final byte[]  digits;\n+        int           nDigits;\n@@ -1768,1 +1688,1 @@\n-        char[] digits = buf.digits;\n+        byte[] digits = buf.digits;\n@@ -1771,1 +1691,1 @@\n-            digits[i] = (char) ((f - 10 * q) + '0');\n+            digits[i] = (byte) ((f - 10 * q) + '0');\n@@ -1822,41 +1742,1 @@\n-    private static BinaryToASCIIConverter getBinaryToASCIIConverter(float f) {\n-        int fBits = Float.floatToRawIntBits( f );\n-        boolean isNegative = (fBits&FloatConsts.SIGN_BIT_MASK) != 0;\n-        int fractBits = fBits&FloatConsts.SIGNIF_BIT_MASK;\n-        int binExp = (fBits&FloatConsts.EXP_BIT_MASK) >> SINGLE_EXP_SHIFT;\n-        \/\/ Discover obvious special cases of NaN and Infinity.\n-        if ( binExp == (FloatConsts.EXP_BIT_MASK>>SINGLE_EXP_SHIFT) ) {\n-            if ( fractBits == 0L ){\n-                return isNegative ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;\n-            } else {\n-                return B2AC_NOT_A_NUMBER;\n-            }\n-        }\n-        \/\/ Finish unpacking\n-        \/\/ Normalize denormalized numbers.\n-        \/\/ Insert assumed high-order bit for normalized numbers.\n-        \/\/ Subtract exponent bias.\n-        int  nSignificantBits;\n-        if ( binExp == 0 ){\n-            if ( fractBits == 0 ){\n-                \/\/ not a denorm, just a 0!\n-                return isNegative ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;\n-            }\n-            int leadingZeros = Integer.numberOfLeadingZeros(fractBits);\n-            int shift = leadingZeros-(31-SINGLE_EXP_SHIFT);\n-            fractBits <<= shift;\n-            binExp = 1 - shift;\n-            nSignificantBits =  32 - leadingZeros; \/\/ recall binExp is  - shift count.\n-        } else {\n-            fractBits |= SINGLE_FRACT_HOB;\n-            nSignificantBits = SINGLE_EXP_SHIFT+1;\n-        }\n-        binExp -= FloatConsts.EXP_BIAS;\n-        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n-        buf.setSign(isNegative);\n-        \/\/ call the routine that actually does all the hard work.\n-        buf.dtoa(binExp, ((long)fractBits)<<(EXP_SHIFT-SINGLE_EXP_SHIFT), nSignificantBits, true);\n-        return buf;\n-    }\n-\n-    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, char[] digits, int length) {\n+    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n@@ -1869,5 +1749,1 @@\n-        byte[] buf = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            buf[i] = (byte) digits[i];\n-        }\n-        return new ASCIIToBinaryBuffer(false, decExp, buf, length);\n+        return new ASCIIToBinaryBuffer(false, decExp, digits, length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":47,"deletions":171,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,3 @@\n-  public int      getSize()                      { return getSize0            (constantPoolOop);        }\n-  public Class<?> getClassAt         (int index) { return getClassAt0         (constantPoolOop, index); }\n-  public Class<?> getClassAtIfLoaded (int index) { return getClassAtIfLoaded0 (constantPoolOop, index); }\n+  public int      getSize()                      { return getSize0            ();        }\n+  public Class<?> getClassAt         (int index) { return getClassAt0         (index); }\n+  public Class<?> getClassAtIfLoaded (int index) { return getClassAtIfLoaded0 (index); }\n@@ -42,1 +42,1 @@\n-      return getClassRefIndexAt0(constantPoolOop, index);\n+      return getClassRefIndexAt0(index);\n@@ -46,4 +46,4 @@\n-  public Member   getMethodAt        (int index) { return getMethodAt0        (constantPoolOop, index); }\n-  public Member   getMethodAtIfLoaded(int index) { return getMethodAtIfLoaded0(constantPoolOop, index); }\n-  public Field    getFieldAt         (int index) { return getFieldAt0         (constantPoolOop, index); }\n-  public Field    getFieldAtIfLoaded (int index) { return getFieldAtIfLoaded0 (constantPoolOop, index); }\n+  public Member   getMethodAt        (int index) { return getMethodAt0        (index); }\n+  public Member   getMethodAtIfLoaded(int index) { return getMethodAtIfLoaded0(index); }\n+  public Field    getFieldAt         (int index) { return getFieldAt0         (index); }\n+  public Field    getFieldAtIfLoaded (int index) { return getFieldAtIfLoaded0 (index); }\n@@ -52,1 +52,1 @@\n-  public String[] getMemberRefInfoAt (int index) { return getMemberRefInfoAt0 (constantPoolOop, index); }\n+  public String[] getMemberRefInfoAt (int index) { return getMemberRefInfoAt0 (index); }\n@@ -55,1 +55,1 @@\n-      return getNameAndTypeRefIndexAt0(constantPoolOop, index);\n+      return getNameAndTypeRefIndexAt0(index);\n@@ -59,1 +59,1 @@\n-      return getNameAndTypeRefInfoAt0(constantPoolOop, index);\n+      return getNameAndTypeRefInfoAt0(index);\n@@ -61,6 +61,6 @@\n-  public int      getIntAt           (int index) { return getIntAt0           (constantPoolOop, index); }\n-  public long     getLongAt          (int index) { return getLongAt0          (constantPoolOop, index); }\n-  public float    getFloatAt         (int index) { return getFloatAt0         (constantPoolOop, index); }\n-  public double   getDoubleAt        (int index) { return getDoubleAt0        (constantPoolOop, index); }\n-  public String   getStringAt        (int index) { return getStringAt0        (constantPoolOop, index); }\n-  public String   getUTF8At          (int index) { return getUTF8At0          (constantPoolOop, index); }\n+  public int      getIntAt           (int index) { return getIntAt0           (index); }\n+  public long     getLongAt          (int index) { return getLongAt0          (index); }\n+  public float    getFloatAt         (int index) { return getFloatAt0         (index); }\n+  public double   getDoubleAt        (int index) { return getDoubleAt0        (index); }\n+  public String   getStringAt        (int index) { return getStringAt0        (index); }\n+  public String   getUTF8At          (int index) { return getUTF8At0          (index); }\n@@ -68,1 +68,1 @@\n-      return Tag.valueOf(getTagAt0(constantPoolOop, index));\n+      return Tag.valueOf(getTagAt0(index));\n@@ -71,1 +71,1 @@\n-  public static enum Tag {\n+  public enum Tag {\n@@ -85,0 +85,1 @@\n+      DYNAMIC(17),\n@@ -86,0 +87,1 @@\n+      \/\/ For index after long\/double and 0\n@@ -114,18 +116,18 @@\n-  private native int      getSize0            (Object constantPoolOop);\n-  private native Class<?> getClassAt0         (Object constantPoolOop, int index);\n-  private native Class<?> getClassAtIfLoaded0 (Object constantPoolOop, int index);\n-  private native int      getClassRefIndexAt0 (Object constantPoolOop, int index);\n-  private native Member   getMethodAt0        (Object constantPoolOop, int index);\n-  private native Member   getMethodAtIfLoaded0(Object constantPoolOop, int index);\n-  private native Field    getFieldAt0         (Object constantPoolOop, int index);\n-  private native Field    getFieldAtIfLoaded0 (Object constantPoolOop, int index);\n-  private native String[] getMemberRefInfoAt0 (Object constantPoolOop, int index);\n-  private native int      getNameAndTypeRefIndexAt0(Object constantPoolOop, int index);\n-  private native String[] getNameAndTypeRefInfoAt0(Object constantPoolOop, int index);\n-  private native int      getIntAt0           (Object constantPoolOop, int index);\n-  private native long     getLongAt0          (Object constantPoolOop, int index);\n-  private native float    getFloatAt0         (Object constantPoolOop, int index);\n-  private native double   getDoubleAt0        (Object constantPoolOop, int index);\n-  private native String   getStringAt0        (Object constantPoolOop, int index);\n-  private native String   getUTF8At0          (Object constantPoolOop, int index);\n-  private native byte     getTagAt0           (Object constantPoolOop, int index);\n+  private native int      getSize0            ();\n+  private native Class<?> getClassAt0         (int index);\n+  private native Class<?> getClassAtIfLoaded0 (int index);\n+  private native int      getClassRefIndexAt0 (int index);\n+  private native Member   getMethodAt0        (int index);\n+  private native Member   getMethodAtIfLoaded0(int index);\n+  private native Field    getFieldAt0         (int index);\n+  private native Field    getFieldAtIfLoaded0 (int index);\n+  private native String[] getMemberRefInfoAt0 (int index);\n+  private native int      getNameAndTypeRefIndexAt0(int index);\n+  private native String[] getNameAndTypeRefInfoAt0(int index);\n+  private native int      getIntAt0           (int index);\n+  private native long     getLongAt0          (int index);\n+  private native float    getFloatAt0         (int index);\n+  private native double   getDoubleAt0        (int index);\n+  private native String   getStringAt0        (int index);\n+  private native String   getUTF8At0          (int index);\n+  private native byte     getTagAt0           (int index);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ConstantPool.java","additions":40,"deletions":38,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,9 @@\n-            if (t != null)\n-                t = t.arrayType();\n+            if (t != null) {\n+                try {\n+                    t = t.arrayType();\n+                } catch (UnsupportedOperationException ex) {\n+                    \/\/ Bad arrays, such as [V or more than 255 dims\n+                    \/\/ We have a more informative IAE\n+                    return null;\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n- * href=\"http:\/\/www.ibm.com\/java\/education\/boundaries\/boundaries.html\">http:\/\/www.ibm.com\/java\/education\/boundaries\/boundaries.html<\/a>.\n+ * href=\"https:\/\/icu-project.org\/docs\/papers\/text_boundary_analysis_in_java\/\">Text Boundary Analysis in Java<\/a> by Richard Gillam.\n","filename":"src\/java.base\/share\/classes\/sun\/text\/RuleBasedBreakIterator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool)\n+(JNIEnv *env, jobject jcpool)\n@@ -32,1 +32,1 @@\n-  return JVM_ConstantPoolGetSize(env, unused, jcpool);\n+  return JVM_ConstantPoolGetSize(env, jcpool);\n@@ -36,1 +36,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -38,1 +38,1 @@\n-  return JVM_ConstantPoolGetClassAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetClassAt(env, jcpool, index);\n@@ -42,1 +42,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -44,1 +44,1 @@\n-  return JVM_ConstantPoolGetClassAtIfLoaded(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetClassAtIfLoaded(env, jcpool, index);\n@@ -48,1 +48,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -50,1 +50,1 @@\n-    return JVM_ConstantPoolGetClassRefIndexAt(env, unused, jcpool, index);\n+    return JVM_ConstantPoolGetClassRefIndexAt(env, jcpool, index);\n@@ -54,1 +54,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -56,1 +56,1 @@\n-  return JVM_ConstantPoolGetMethodAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetMethodAt(env, jcpool, index);\n@@ -60,1 +60,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -62,1 +62,1 @@\n-  return JVM_ConstantPoolGetMethodAtIfLoaded(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetMethodAtIfLoaded(env, jcpool, index);\n@@ -66,1 +66,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -68,1 +68,1 @@\n-  return JVM_ConstantPoolGetFieldAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetFieldAt(env, jcpool, index);\n@@ -72,1 +72,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -74,1 +74,1 @@\n-  return JVM_ConstantPoolGetFieldAtIfLoaded(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetFieldAtIfLoaded(env, jcpool, index);\n@@ -78,1 +78,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -80,1 +80,1 @@\n-  return JVM_ConstantPoolGetMemberRefInfoAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetMemberRefInfoAt(env, jcpool, index);\n@@ -84,1 +84,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -86,1 +86,1 @@\n-    return JVM_ConstantPoolGetNameAndTypeRefIndexAt(env, unused, jcpool, index);\n+    return JVM_ConstantPoolGetNameAndTypeRefIndexAt(env, jcpool, index);\n@@ -90,1 +90,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -92,1 +92,1 @@\n-  return JVM_ConstantPoolGetNameAndTypeRefInfoAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetNameAndTypeRefInfoAt(env, jcpool, index);\n@@ -96,1 +96,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -98,1 +98,1 @@\n-  return JVM_ConstantPoolGetIntAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetIntAt(env, jcpool, index);\n@@ -102,1 +102,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -104,1 +104,1 @@\n-  return JVM_ConstantPoolGetLongAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetLongAt(env, jcpool, index);\n@@ -108,1 +108,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -110,1 +110,1 @@\n-  return JVM_ConstantPoolGetFloatAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetFloatAt(env, jcpool, index);\n@@ -114,1 +114,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -116,1 +116,1 @@\n-  return JVM_ConstantPoolGetDoubleAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetDoubleAt(env, jcpool, index);\n@@ -120,1 +120,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -122,1 +122,1 @@\n-  return JVM_ConstantPoolGetStringAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetStringAt(env, jcpool, index);\n@@ -126,1 +126,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -128,1 +128,1 @@\n-  return JVM_ConstantPoolGetUTF8At(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetUTF8At(env, jcpool, index);\n@@ -132,1 +132,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -134,1 +134,1 @@\n-  return JVM_ConstantPoolGetTagAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetTagAt(env, jcpool, index);\n","filename":"src\/java.base\/share\/native\/libjava\/ConstantPool.c","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-    \/\/ get the UnixFileAttributes for a given file. Returns null if the file does not exist.\n+    \/\/ get the UnixFileAttributes for a given file.\n+    \/\/ Returns null if the file does not exist.\n@@ -86,0 +87,8 @@\n+        return getIfExists(path, true);\n+    }\n+\n+    \/\/ get the UnixFileAttributes for a given file, optionally following links.\n+    \/\/ Returns null if the file does not exist.\n+    static UnixFileAttributes getIfExists(UnixPath path, boolean followLinks)\n+        throws UnixException\n+    {\n@@ -87,2 +96,4 @@\n-        int errno = UnixNativeDispatcher.stat2(path, attrs);\n-        if (errno == 0) {\n+        int flag = (followLinks) ? 0 : UnixConstants.AT_SYMLINK_NOFOLLOW;\n+        int errno = UnixNativeDispatcher.fstatat2(UnixConstants.AT_FDCWD,\n+                                                  path, flag, attrs);\n+        if (errno == 0)\n@@ -90,1 +101,1 @@\n-        } else if (errno == UnixConstants.ENOENT) {\n+        else if (errno == UnixConstants.ENOENT)\n@@ -92,1 +103,1 @@\n-        } else {\n+        else\n@@ -94,1 +105,0 @@\n-        }\n@@ -110,1 +120,1 @@\n-        UnixNativeDispatcher.fstatat(dfd, path.asByteArray(), flag, attrs);\n+        UnixNativeDispatcher.fstatat(dfd, path, flag, attrs);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import java.util.HashSet;\n@@ -351,0 +352,23 @@\n+    \/\/ find the key of the last accessible link in the chain\n+    private UnixFileKey lastFileKey(UnixPath path) throws UnixException {\n+        var fileKeys = new HashSet<UnixFileKey>();\n+        UnixFileKey lastFileKey = null;\n+        while (path != null) {\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(path, false);\n+            if (attrs == null) {\n+                break;\n+            }\n+            UnixFileKey fileKey = attrs.fileKey();\n+            if (!attrs.isSymbolicLink()) {\n+                break;\n+            }\n+            if (!fileKeys.add(fileKey)) {\n+                throw new UnixException(ELOOP);\n+            }\n+            lastFileKey = fileKey;\n+            byte[] target = readlink(path);\n+            path = new UnixPath(theFileSystem, target);\n+        }\n+        return lastFileKey;\n+    }\n+\n@@ -353,0 +377,1 @@\n+        \/\/ toUnixPath verifies its argument is a non-null UnixPath\n@@ -361,2 +386,1 @@\n-        UnixFileAttributes attrs1;\n-        UnixFileAttributes attrs2;\n+        UnixFileKey key1;\n@@ -364,4 +388,5 @@\n-             attrs1 = UnixFileAttributes.get(file1, true);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file1);\n-            return false;    \/\/ keep compiler happy\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(file1);\n+            key1 = (attrs != null) ? attrs.fileKey() : lastFileKey(file1);\n+        } catch (UnixException e) {\n+            e.rethrowAsIOException(file1);\n+            return false;\n@@ -369,0 +394,5 @@\n+\n+        if (key1 == null)\n+            return false;\n+\n+        UnixFileKey key2;\n@@ -370,4 +400,5 @@\n-            attrs2 = UnixFileAttributes.get(file2, true);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file2);\n-            return false;    \/\/ keep compiler happy\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(file2);\n+            key2 = (attrs != null) ? attrs.fileKey() : lastFileKey(file2);\n+        } catch (UnixException e) {\n+            e.rethrowAsIOException(file2);\n+            return false;\n@@ -375,1 +406,2 @@\n-        return attrs1.isSameFile(attrs2);\n+\n+        return key1.equals(key2);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":44,"deletions":12,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+    private static native int stat0(long pathAddress, UnixFileAttributes attrs);\n@@ -260,0 +261,1 @@\n+    \/\/ Variant of stat() returning errno instead of throwing UnixException\n@@ -266,2 +268,0 @@\n-    private static native int stat0(long pathAddress, UnixFileAttributes attrs);\n-\n@@ -291,1 +291,1 @@\n-    static void fstatat(int dfd, byte[] path, int flag, UnixFileAttributes attrs)\n+    static void fstatat(int dfd, UnixPath path, int flag, UnixFileAttributes attrs)\n@@ -294,2 +294,14 @@\n-        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(path)) {\n-            fstatat0(dfd, buffer.address(), flag, attrs);\n+        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n+            int errno = fstatat0(dfd, buffer.address(), flag, attrs);\n+            if (errno != 0) {\n+                throw new UnixException(errno);\n+            }\n+        }\n+    }\n+    private static native int fstatat0(int dfd, long pathAddress, int flag,\n+        UnixFileAttributes attrs);\n+\n+    \/\/ Variant of fstatat() returning errno instead of throwing UnixException\n+    static int fstatat2(int dfd, UnixPath path, int flag, UnixFileAttributes attrs) {\n+        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n+            return fstatat0(dfd, buffer.address(), flag, attrs);\n@@ -298,2 +310,0 @@\n-    private static native void fstatat0(int dfd, long pathAddress, int flag,\n-        UnixFileAttributes attrs) throws UnixException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jint JNICALL\n@@ -764,0 +764,1 @@\n+            return 0;\n@@ -765,1 +766,1 @@\n-            throwUnixException(env, errno);\n+            return errno;\n@@ -767,2 +768,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -774,1 +773,1 @@\n-        return;\n+        return ENOTSUP;\n@@ -777,3 +776,1 @@\n-    if (err == -1) {\n-        throwUnixException(env, errno);\n-    } else {\n+    if (err == 0) {\n@@ -781,0 +778,3 @@\n+        return 0;\n+    } else {\n+        return errno;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -437,1 +437,3 @@\n-            x.rethrowAsIOException(file1);\n+            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                x.lastError() != ERROR_PATH_NOT_FOUND)\n+                x.rethrowAsIOException(file1);\n@@ -439,0 +441,5 @@\n+\n+        \/\/ if file1 does not exist, it cannot equal file2\n+        if (h1 == 0L)\n+            return false;\n+\n@@ -450,1 +457,3 @@\n-                x.rethrowAsIOException(file2);\n+                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                    x.lastError() != ERROR_PATH_NOT_FOUND)\n+                    x.rethrowAsIOException(file2);\n@@ -452,0 +461,5 @@\n+\n+            \/\/ if file2 does not exist, it cannot equal file1, which does\n+            if (h2 == 0L)\n+                return false;\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -144,2 +144,0 @@\n-        System.err.flush();\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -737,0 +737,1 @@\n+        stream.flush();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/gif\/GIFImageWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2330,0 +2330,1 @@\n+        stream.flush();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFImageWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,4 +72,0 @@\n-    private static Color disabledForeground;\n-    private static Color acceleratorSelectionForeground;\n-    private static Color acceleratorForeground;\n-\n@@ -207,1 +203,4 @@\n-                             MenuItemLayoutHelper.LayoutResult lr) {\n+                             MenuItemLayoutHelper.LayoutResult lr,\n+                             Color disabledForeground,\n+                             Color acceleratorSelectionForeground,\n+                             Color acceleratorForeground) {\n@@ -246,12 +245,0 @@\n-    public static void setDisabledForeground(Color disabledFg) {\n-        disabledForeground = disabledFg;\n-    }\n-\n-    public static void setAcceleratorSelectionForeground(Color acceleratorSelectionFg) {\n-        acceleratorSelectionForeground = acceleratorSelectionFg;\n-    }\n-\n-    public static void setAcceleratorForeground(Color acceleratorFg) {\n-        acceleratorForeground = acceleratorFg;\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import sun.awt.AppContext;\n@@ -108,0 +107,2 @@\n+    private static final IIORegistry registry = new IIORegistry();\n+\n@@ -112,5 +113,1 @@\n-     *\n-     * <p> Each {@code ThreadGroup} will receive its own instance.\n-     *\n-     * @return the default registry for the current\n-     * {@code ThreadGroup}.\n+     * @return the default registry for the Image I\/O API\n@@ -119,8 +116,0 @@\n-        AppContext context = AppContext.getAppContext();\n-        IIORegistry registry =\n-            (IIORegistry)context.get(IIORegistry.class);\n-        if (registry == null) {\n-            \/\/ Create an instance for this AppContext\n-            registry = new IIORegistry();\n-            context.put(IIORegistry.class, registry);\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/IIORegistry.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n- * sees fit, so long as it has the appropriate runtime permission.\n+ * sees fit.\n@@ -286,2 +286,1 @@\n-     * it is deregistered from a category or when the registry is\n-     * finalized.\n+     * it is deregistered from a category.\n@@ -316,2 +315,1 @@\n-     * it is deregistered from a category or when the registry is\n-     * finalized.\n+     * it is deregistered from a category.\n@@ -663,0 +661,6 @@\n+     * <p>\n+     * If an application creates a new {@code ServiceRegistry} instance and registers providers,\n+     * and at some point no longer needs the instance, it should call this method to ensure\n+     * that all providers which are instances of {@link RegisterableService}\n+     * receive a {@link RegisterableService#onDeregistration(ServiceRegistry, Class<?>)} call back,\n+     * before allowing the instance to be garbage collected.\n@@ -670,20 +674,0 @@\n-    \/**\n-     * Finalizes this object prior to garbage collection.  The\n-     * {@code deregisterAll} method is called to deregister all\n-     * currently registered service providers.  This method should not\n-     * be called from application code.\n-     *\n-     * @throws Throwable if an error occurs during superclass\n-     * finalization.\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    public void finalize() throws Throwable {\n-        deregisterAll();\n-        super.finalize();\n-    }\n-\n@@ -824,4 +808,0 @@\n-    @SuppressWarnings(\"removal\")\n-    public synchronized void finalize() {\n-        clear();\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/ServiceRegistry.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import sun.java2d.Disposer;\n-import sun.java2d.DisposerRecord;\n@@ -51,6 +49,0 @@\n-    \/** The referent to be registered with the Disposer. *\/\n-    private final Object disposerReferent = new Object();\n-\n-    \/** The DisposerRecord that resets the underlying MemoryCache. *\/\n-    private final DisposerRecord disposerRecord;\n-\n@@ -71,3 +63,0 @@\n-\n-        disposerRecord = new StreamDisposerRecord(cache);\n-        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -168,1 +157,0 @@\n-        disposerRecord.dispose(); \/\/ this resets the MemoryCache\n@@ -170,0 +158,1 @@\n+        cache.reset();\n@@ -172,15 +161,0 @@\n-\n-    private static class StreamDisposerRecord implements DisposerRecord {\n-        private MemoryCache cache;\n-\n-        public StreamDisposerRecord(MemoryCache cache) {\n-            this.cache = cache;\n-        }\n-\n-        public synchronized void dispose() {\n-            if (cache != null) {\n-                cache.reset();\n-                cache = null;\n-            }\n-        }\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/MemoryCacheImageInputStream.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,8 @@\n+ * If the image source parameter to a constructor or method is non-null,\n+ * but does not reference valid accessible image data,\n+ * no exceptions will be thrown but no image will be rendered\n+ * even though {@link #getImage()} will return a non-null value,\n+ * as the image will have no dimensions\n+ * and {@link #getImageLoadStatus()} will report {@code MediaTracker.ERRORED}.\n+ *\n+ * <p>\n@@ -181,0 +189,1 @@\n+     * @throws NullPointerException if {@code location} is {@code null}\n@@ -200,0 +209,1 @@\n+     * @throws NullPointerException if {@code location} is {@code null}\n@@ -210,0 +220,1 @@\n+     * @throws NullPointerException if {@code image} is {@code null}\n@@ -212,1 +223,1 @@\n-        this(image);\n+        this.image = image;\n@@ -214,0 +225,2 @@\n+\n+        loadImage(image);\n@@ -221,0 +234,1 @@\n+     * @throws NullPointerException if {@code image} is {@code null}\n@@ -225,6 +239,11 @@\n-        this.image = image;\n-        Object o = image.getProperty(\"comment\", imageObserver);\n-        if (o instanceof String) {\n-            description = (String) o;\n-        }\n-        loadImage(image);\n+        this(image, getImageComment(image));\n+    }\n+\n+    \/**\n+     * @return the {@code \"comment\"} property of the image\n+     *         if the value of the property is a sting}\n+     * @param image the image to get the {@code \"comment\"} property\n+     *\/\n+    private static String getImageComment(Image image) {\n+        Object o = image.getProperty(\"comment\", null);\n+        return (o instanceof String) ? (String) o : null;\n@@ -244,0 +263,1 @@\n+     * @throws NullPointerException if {@code imageData} is {@code null}\n@@ -267,0 +287,1 @@\n+     * @throws NullPointerException if {@code imageData} is {@code null}\n@@ -371,0 +392,1 @@\n+     * @throws NullPointerException if {@code image} is {@code null}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ImageIcon.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1167,1 +1167,1 @@\n-            = \"The color used to draw the grid lines.\")\n+            = \"Whether grid lines are drawn around the cells.\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -719,5 +719,4 @@\n-        SwingUtilities3.setDisabledForeground(disabledForeground);\n-        SwingUtilities3.setAcceleratorSelectionForeground(\n-                        acceleratorSelectionForeground);\n-        SwingUtilities3.setAcceleratorForeground(acceleratorForeground);\n-        SwingUtilities3.paintAccText(g, lh, lr);\n+        SwingUtilities3.paintAccText(g, lh, lr,\n+                                     disabledForeground,\n+                                     acceleratorSelectionForeground,\n+                                     acceleratorForeground);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicMenuItemUI.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -175,7 +175,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        dispose();\n-        super.finalize();\n-    }\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11InputMethodBase.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,1 +87,3 @@\n-                    arrowIcon, background, foreground, defaultTextIconGap,\n+                    arrowIcon, background, foreground,\n+                    disabledForeground, acceleratorSelectionForeground,\n+                    acceleratorForeground, defaultTextIconGap,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsCheckBoxMenuItemUI.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-    private static Color disabledForeground;\n-    private static Color acceleratorSelectionForeground;\n-    private static Color acceleratorForeground;\n@@ -170,30 +167,0 @@\n-    private static void applyInsets(Rectangle rect, Insets insets) {\n-        SwingUtilities3.applyInsets(rect, insets);\n-    }\n-\n-    private static void paintCheckIcon(Graphics g, MenuItemLayoutHelper lh,\n-                                MenuItemLayoutHelper.LayoutResult lr,\n-                                Color holdc, Color foreground) {\n-        SwingUtilities3.paintCheckIcon(g, lh, lr, holdc, foreground);\n-    }\n-\n-    private static void paintIcon(Graphics g, MenuItemLayoutHelper lh,\n-                           MenuItemLayoutHelper.LayoutResult lr, Color holdc) {\n-        SwingUtilities3.paintIcon(g, lh, lr, holdc);\n-    }\n-\n-    private static void paintAccText(Graphics g, MenuItemLayoutHelper lh,\n-                              MenuItemLayoutHelper.LayoutResult lr) {\n-        SwingUtilities3.setDisabledForeground(disabledForeground);\n-        SwingUtilities3.setAcceleratorSelectionForeground(\n-                        acceleratorSelectionForeground);\n-        SwingUtilities3.setAcceleratorForeground(acceleratorForeground);\n-        SwingUtilities3.paintAccText(g, lh, lr);\n-    }\n-\n-    private static void paintArrowIcon(Graphics g, MenuItemLayoutHelper lh,\n-                                MenuItemLayoutHelper.LayoutResult lr,\n-                                Color foreground) {\n-        SwingUtilities3.paintArrowIcon(g, lh, lr, foreground);\n-    }\n-\n@@ -207,1 +174,2 @@\n-                                            defaultTextIconGap, menuItem,\n+                                            disabledForeground, acceleratorSelectionForeground,\n+                                            acceleratorForeground, defaultTextIconGap, menuItem,\n@@ -218,0 +186,3 @@\n+                              Color disabledForeground,\n+                              Color acceleratorSelectionForeground,\n+                              Color acceleratorForeground,\n@@ -227,1 +198,1 @@\n-        applyInsets(viewRect, mi.getInsets());\n+        SwingUtilities3.applyInsets(viewRect, mi.getInsets());\n@@ -245,2 +216,2 @@\n-        paintCheckIcon(g, lh, lr, holdc, foreground);\n-        paintIcon(g, lh, lr, holdc);\n+        SwingUtilities3.paintCheckIcon(g, lh, lr, holdc, foreground);\n+        SwingUtilities3.paintIcon(g, lh, lr, holdc);\n@@ -270,2 +241,4 @@\n-        paintAccText(g, lh, lr);\n-        paintArrowIcon(g, lh, lr, foreground);\n+        SwingUtilities3.paintAccText(g, lh, lr, disabledForeground,\n+                                     acceleratorSelectionForeground,\n+                                     acceleratorForeground);\n+        SwingUtilities3.paintArrowIcon(g, lh, lr, foreground);\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":12,"deletions":39,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -143,1 +143,2 @@\n-                                            defaultTextIconGap, menuItem,\n+                                            disabledForeground, acceleratorSelectionForeground,\n+                                            acceleratorForeground, defaultTextIconGap, menuItem,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,1 +87,3 @@\n-                    arrowIcon, background, foreground, defaultTextIconGap,\n+                    arrowIcon, background, foreground,\n+                    disabledForeground, acceleratorSelectionForeground,\n+                    acceleratorForeground, defaultTextIconGap,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRadioButtonMenuItemUI.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -127,0 +129,2 @@\n+        disposerRecord = new ContextDisposerRecord(context);\n+        Disposer.addRecord(this, disposerRecord);\n@@ -135,8 +139,16 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable\n-    {\n-        \/\/ Release the resources used by the native input context.\n-        if (context!=0) {\n-            destroyNativeContext(context);\n-            context=0;\n+    private final ContextDisposerRecord disposerRecord;\n+\n+    private static final class ContextDisposerRecord implements DisposerRecord {\n+\n+        private final int context;\n+        private volatile boolean disposed;\n+\n+        ContextDisposerRecord(int c) {\n+            context = c;\n+        }\n+\n+        public synchronized void dispose() {\n+            if (!disposed) {\n+                destroyNativeContext(context);\n+            }\n+            disposed = true;\n@@ -144,1 +156,0 @@\n-        super.finalize();\n@@ -154,3 +165,1 @@\n-        \/\/ Due to a memory management problem in Windows 98, we should retain\n-        \/\/ the native input context until this object is finalized. So do\n-        \/\/ nothing here.\n+        disposerRecord.dispose();\n@@ -451,0 +460,1 @@\n+        disableNativeIME(awtFocussedComponentPeer);\n@@ -661,2 +671,2 @@\n-    private native int createNativeContext();\n-    private native void destroyNativeContext(int context);\n+    private static native int createNativeContext();\n+    private static native void destroyNativeContext(int context);\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WInputMethod.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-Java_sun_awt_windows_WInputMethod_createNativeContext(JNIEnv *env, jobject self)\n+Java_sun_awt_windows_WInputMethod_createNativeContext(JNIEnv *env, jclass cls)\n@@ -72,1 +72,1 @@\n-Java_sun_awt_windows_WInputMethod_destroyNativeContext(JNIEnv *env, jobject self, jint context)\n+Java_sun_awt_windows_WInputMethod_destroyNativeContext(JNIEnv *env, jclass cls, jint context)\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_InputMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        return new LazyDelegatingJdkConsoleImpl(inCharset, outCharset);\n+        return isTTY ? new LazyDelegatingJdkConsoleImpl(inCharset, outCharset) : null;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -290,1 +290,2 @@\n-        AVX10_2\n+        AVX10_2,\n+        HYBRID\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashMap;\n@@ -32,0 +33,1 @@\n+import java.util.Map;\n@@ -48,0 +50,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;\n@@ -55,0 +58,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -209,2 +213,3 @@\n-\n-        buildMainSummary(summaryTreeList);\n+        var inheritedTocEntries = new LinkedHashMap<HtmlId, Content>();\n+        var ownMemberCount = buildMainSummary(summaryTreeList);\n+        var inheritedSummaries = 0;\n@@ -217,2 +222,3 @@\n-        if (showInherited)\n-            buildInheritedSummary(summaryTreeList);\n+        if (showInherited) {\n+            inheritedSummaries = buildInheritedSummary(summaryTreeList, inheritedTocEntries);\n+        }\n@@ -226,0 +232,6 @@\n+\n+            \/\/ Omit TOC entries for inherited members unless there's a substantial number of own members.\n+            if (!inheritedTocEntries.isEmpty() && ownMemberCount > 8 && inheritedSummaries > 0) {\n+                inheritedTocEntries.forEach((key, value)\n+                        -> writer.tableOfContents.addLink(key, value, TableOfContents.Level.SECOND));\n+            }\n@@ -233,0 +245,1 @@\n+     * @return the number of documented members\n@@ -234,1 +247,1 @@\n-    private void buildMainSummary(List<Content> summaryTreeList) {\n+    private int buildMainSummary(List<Content> summaryTreeList) {\n@@ -238,0 +251,1 @@\n+            var table = getSummaryTable();\n@@ -239,16 +253,1 @@\n-                final Element property = pHelper.getPropertyElement(member);\n-                if (property != null && member instanceof ExecutableElement ee) {\n-                    configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n-                }\n-                if (utils.isMethod(member)) {\n-                    var docFinder = utils.docFinder();\n-                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n-                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n-                        Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n-                        return DocFinder.Result.fromOptional(optional);\n-                    })).toOptional();\n-                    \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n-                    addMemberSummary(typeElement, member, r.orElse(List.of()));\n-                } else {\n-                    addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n-                }\n+                addMemberSummaryTableRow(typeElement, member, table, pHelper);\n@@ -258,0 +257,30 @@\n+        return members.size();\n+    }\n+\n+    \/**\n+     * Adds the summary table row for a member.\n+     * @param enclosingType the enclosing type of the member\n+     * @param member the member\n+     * @param table the summary table\n+     * @param propertyHelper property helper to patch doctree\n+     *\/\n+    private void addMemberSummaryTableRow(TypeElement enclosingType, Element member, Table<Element> table,\n+                                          PropertyUtils.PropertyHelper propertyHelper) {\n+        final Element property = propertyHelper.getPropertyElement(member);\n+        if (property != null && member instanceof ExecutableElement ee) {\n+            configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n+        }\n+\n+        if (utils.isMethod(member)) {\n+            var docFinder = utils.docFinder();\n+            Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n+                var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n+                Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty()\n+                        ? Optional.empty() : Optional.of(firstSentenceTrees);\n+                return DocFinder.Result.fromOptional(optional);\n+            })).toOptional();\n+            \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n+            addMemberSummary(enclosingType, member, r.orElse(List.of()), table);\n+        } else {\n+            addMemberSummary(enclosingType, member, utils.getFirstSentenceTrees(member), table);\n+        }\n@@ -264,0 +293,2 @@\n+     * @param tocEntries map of TOC entries for added summaries\n+     * @return the number of added summary lists, excluding methods from java.lang.Object\n@@ -265,1 +296,1 @@\n-    private void buildInheritedSummary(List<Content> targets) {\n+    private int buildInheritedSummary(List<Content> targets, Map<HtmlId, Content> tocEntries) {\n@@ -267,0 +298,2 @@\n+        \/\/ Avoid showing TOC entry if it's just methods inherited from java.lang.Object\n+        var summaryCount = kind == METHODS && utils.isClass(typeElement) ? -1 : 0;\n@@ -287,0 +320,11 @@\n+\n+                if (utils.isIncluded(inheritedClass)) {\n+                    var pHelper = writer.getPropertyHelper();\n+                    Table<Element> table = createInheritedSummaryTable(inheritedClass);\n+\n+                    for (Element member : inheritedMembers) {\n+                        addMemberSummaryTableRow(inheritedClass, member, table, pHelper);\n+                    }\n+\n+                    inheritedHeader.add(table);\n+                }\n@@ -288,0 +332,5 @@\n+\n+                summaryCount++;\n+                var label = new ContentBuilder();\n+                addInheritedSummaryLabel(inheritedClass, label);\n+                tocEntries.put(getInheritedSummaryId(inheritedClass), label.stripTags());\n@@ -290,0 +339,2 @@\n+\n+        return summaryCount;\n@@ -331,0 +382,1 @@\n+\n@@ -386,0 +438,22 @@\n+    \/**\n+     * Creates a summary table for members of the kind supported by this writer inherited\n+     * from {@code typeElement}.\n+     *\n+     * @param typeElement the superclass or interface\n+     * @return a summary table\n+     *\/\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n+\n+    \/**\n+     * Creates an id for a summary table for members of the kind supported by this writer\n+     * inherited from {@code typeElement}.\n+     *\n+     * @param typeElement the superclass or interface\n+     * @return the id for the summary table\n+     *\/\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n+\n@@ -392,1 +466,3 @@\n-    public abstract void addInheritedSummaryLabel(TypeElement typeElement, Content content);\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n@@ -431,2 +507,3 @@\n-    protected abstract void addInheritedSummaryLink(TypeElement typeElement,\n-            Element member, Content target);\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n@@ -619,5 +696,1 @@\n-            List<? extends DocTree> firstSentenceTrees) {\n-        if (tElement != typeElement) {\n-            throw new IllegalStateException(getClass() + \": \" + tElement + \", \" + typeElement);\n-        }\n-        var table = getSummaryTable();\n+            List<? extends DocTree> firstSentenceTrees, Table<Element> table) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":103,"deletions":30,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -287,4 +287,0 @@\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n@@ -300,6 +296,0 @@\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement,\n-            Element member, Content target) {\n-        \/\/Not applicable.\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.element.TypeElement;\n@@ -43,1 +42,0 @@\n-import jdk.javadoc.internal.html.HtmlTag;\n@@ -296,4 +294,0 @@\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -216,4 +216,0 @@\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n@@ -229,4 +225,0 @@\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriter.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-\n@@ -41,1 +38,1 @@\n-import jdk.javadoc.internal.html.HtmlStyle;\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -222,3 +219,0 @@\n-        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyles.colFirst, HtmlStyles.colSecond,\n-                HtmlStyles.colLast);\n-\n@@ -228,1 +222,10 @@\n-                .setColumnStyles(bodyRowStyles);\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond,\n+                        HtmlStyles.colLast);\n+    }\n+\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(null))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n@@ -246,1 +249,1 @@\n-        labelHeading.setId(htmlIds.forInheritedFields(typeElement));\n+        labelHeading.setId(getInheritedSummaryId(typeElement));\n@@ -272,0 +275,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedFields(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriter.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -320,2 +320,3 @@\n-        \/\/ If a stylesheet file is not specified, copy the default stylesheet\n-        \/\/ and replace newline with platform-specific newline.\n+        \/\/ If a stylesheet file is not specified, copy the default stylesheet,\n+        \/\/ replace newline with platform-specific newline,\n+        \/\/ and remove the reference to fonts if --no-fonts is used.\n@@ -323,1 +324,1 @@\n-            copyResource(DocPaths.STYLESHEET, DocPaths.RESOURCE_FILES.resolve(DocPaths.STYLESHEET), true);\n+            copyStylesheet(options);\n@@ -326,0 +327,1 @@\n+        copyResource(DocPaths.DOWN_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.DOWN_SVG), true);\n@@ -466,6 +468,1 @@\n-        DocPath resourcePath = DocPaths.RESOURCES.resolve(sourcePath);\n-        \/\/ Resolve resources against doclets.formats.html package\n-        URL resourceURL = HtmlConfiguration.class.getResource(resourcePath.getPath());\n-        if (resourceURL == null) {\n-            throw new ResourceIOException(sourcePath, new FileNotFoundException(resourcePath.getPath()));\n-        }\n+        ReadableResource resource = resolveResource(sourcePath);\n@@ -475,1 +472,1 @@\n-            f.copyResource(resourcePath, resourceURL, configuration.docResources);\n+            f.copyResource(resource.path(), resource.url(), configuration.docResources);\n@@ -477,1 +474,1 @@\n-            f.copyResource(resourcePath, resourceURL, replaceNewLine);\n+            f.copyResource(resource.path(), resource.url(), replaceNewLine);\n@@ -506,0 +503,17 @@\n+    private void copyStylesheet(HtmlOptions options) throws DocletException {\n+        ReadableResource resource = resolveResource(DocPaths.STYLESHEET);\n+        var targetPath = DocPaths.RESOURCE_FILES.resolve(DocPaths.STYLESHEET);\n+        DocFile f = DocFile.createFileForOutput(configuration, targetPath);\n+\n+        if (options.noFonts()) {\n+            f.copyResource(resource.path(), resource.url(), line -> {\n+                if (line.startsWith(\"@import url('fonts\")) {\n+                    return null; \/\/ remove the line\n+                }\n+                return line;\n+            });\n+        } else {\n+            f.copyResource(resource.path(), resource.url(), true);\n+        }\n+    }\n+\n@@ -522,0 +536,13 @@\n+\n+    private ReadableResource resolveResource(DocPath sourcePath) throws ResourceIOException {\n+        DocPath resolvedPath = DocPaths.RESOURCES.resolve(sourcePath);\n+        \/\/ Resolve resources against doclets.formats.html package\n+        URL resourceURL = HtmlConfiguration.class.getResource(resolvedPath.getPath());\n+        if (resourceURL == null) {\n+            throw new ResourceIOException(sourcePath, new FileNotFoundException(resolvedPath.getPath()));\n+        }\n+        return new ReadableResource(resolvedPath, resourceURL);\n+    }\n+\n+    private record ReadableResource(DocPath path, URL url) {\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -305,0 +306,8 @@\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(null))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n+    }\n+\n@@ -320,1 +329,1 @@\n-        labelHeading.setId(htmlIds.forInheritedMethods(typeElement));\n+        labelHeading.setId(getInheritedSummaryId(typeElement));\n@@ -326,0 +335,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedMethods(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-\n@@ -39,1 +36,1 @@\n-import jdk.javadoc.internal.html.HtmlStyle;\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -97,3 +94,0 @@\n-        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyles.colFirst, HtmlStyles.colSecond,\n-                HtmlStyles.colLast);\n-\n@@ -103,1 +97,10 @@\n-                .setColumnStyles(bodyRowStyles);\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond,\n+                        HtmlStyles.colLast);\n+    }\n+\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n@@ -120,1 +123,1 @@\n-        labelHeading.setId(htmlIds.forInheritedClasses(typeElement));\n+        labelHeading.setId(getInheritedSummaryId(typeElement));\n@@ -126,0 +129,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedClasses(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NestedClassWriter.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -258,0 +259,8 @@\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(null))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n+    }\n+\n@@ -273,1 +282,1 @@\n-                        .setId(htmlIds.forInheritedProperties(typeElement))\n+                        .setId(getInheritedSummaryId(typeElement))\n@@ -279,0 +288,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedProperties(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriter.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -379,2 +379,5 @@\n-        if ((tabs == null || occurringTabs.size() == 1) && renderTabs) {\n-            if (tabs == null) {\n+        if (tabs == null || (occurringTabs.size() == 1 && renderTabs)) {\n+            \/\/ Render table with static content. Note that a single-tab table is only static\n+            \/\/ if it is controlled by local tabs. In a multi-table summary page, it still\n+            \/\/ must be able to show\/hide its content depending on page-level controls.\n+            if (caption != null) {\n@@ -382,1 +385,1 @@\n-            } else {\n+            } else if (tabs != null) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Table.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\">\n+  <path d=\"m35.763 5.058 38.675 36.885a12.596 12.596 90 0 1 0 18.23L35.763 97.058v-18.32l27.055-25.431a2.975 2.975 90.09 0 0 .007-4.33L35.763 23.38Z\" style=\"fill:#000;stroke-width:.285806\" transform=\"rotate(90 53.877 47.354)\"\/>\n+<\/svg>\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/down.svg","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -12,1 +12,1 @@\n-<\/svg>\n+<\/svg>\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/right.svg","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+const toggleMemberListing = \"##REPLACE:doclet.Toggle_member_listing##\";\n@@ -511,3 +512,3 @@\n-                template.innerHTML =\" <a href='#\" + encodeURI(id) + \"' class='anchor-link' aria-label='\" + linkToSection\n-                    + \"'><img src='\" + pathtoroot + \"resource-files\/link.svg' alt='\" + linkIcon +\"' tabindex='0'\"\n-                    + \" width='16' height='16'><\/a>\";\n+                template.innerHTML =\" <a href='#\" + encodeURI(id) + \"' class='anchor-link' aria-label='\"\n+                    + linkToSection + \"'><img src='\" + pathtoroot + \"resource-files\/link.svg' alt='\"\n+                    + linkIcon + \"' width='16' height='16'><\/a>\";\n@@ -517,0 +518,15 @@\n+    document.querySelectorAll(\"div.inherited-list:has( > div.summary-table) > h3\").forEach(h => {\n+        const button = document.createElement(\"button\");\n+        const p = h.parentElement;\n+        button.addEventListener(\"click\", e => {\n+            toggleStyle(p.classList, p.classList.contains(\"expanded\"), \"collapsed\", \"expanded\");\n+        });\n+        button.addEventListener(\"keydown\", e => {\n+            if (e.key === \" \" || e.key === \"Enter\") {\n+                toggleStyle(p.classList, p.classList.contains(\"expanded\"), \"collapsed\", \"expanded\");\n+                e.preventDefault();\n+            }\n+        });\n+        button.setAttribute(\"aria-label\", toggleMemberListing);\n+        h.insertAdjacentElement(\"afterbegin\", button);\n+    });\n@@ -522,10 +538,12 @@\n-        sections = [{ id: \"\", top: 0 }].concat(Array.from(main.querySelectorAll(\n-                \"section[id], h2[id], h2 a[id], h3[id], h3 a[id], div[id]\"))\n-            .filter((e) => {\n-                return sidebar.querySelector(\"a[href=\\\"#\" + encodeURI(e.getAttribute(\"id\")) + \"\\\"]\") !== null\n-            }).map((e) => {\n-                return {\n-                    id: e.getAttribute(\"id\"),\n-                    top: e.offsetTop\n-                };\n-            }));\n+        sections = [{ id: \"\", top: 0 }].concat(\n+            Array.from(main.querySelectorAll(\"section[id], h2[id], h2 a[id], h3[id], h3 a[id], div[id]\"))\n+                .filter((e) => {\n+                    var id = encodeURI(e.getAttribute(\"id\"));\n+                    return sidebar.querySelector(\"a[href=\\\"#\" + id + \"\\\"]\") !== null\n+                }).map((e) => {\n+                    return {\n+                        id: e.getAttribute(\"id\"),\n+                       top: e.offsetTop\n+                    };\n+                })\n+        );\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -158,1 +158,2 @@\n-    div.main-grid img {\n+    div.main-grid img,\n+    .inherited-list h3 > button {\n@@ -211,1 +212,2 @@\n-        div.main-grid img {\n+        div.main-grid img,\n+        .inherited-list h3 > button {\n@@ -260,1 +262,2 @@\n-        div.main-grid img {\n+        div.main-grid img,\n+        .inherited-list h3 > button {\n@@ -884,2 +887,2 @@\n-    padding:5px 12px 7px 12px;\n-    height:16px;\n+    padding:4.5px 12px;\n+    height:19px;\n@@ -891,2 +894,2 @@\n-    padding:6px 12px 7px 12px;\n-    height:17px;\n+    padding:5px 5px 6px 12px;\n+    height:18px;\n@@ -895,0 +898,1 @@\n+    font-size: 0.99em;\n@@ -910,0 +914,6 @@\n+.caption a:hover,\n+.caption a:active,\n+.inherited-list.expanded h3 a:hover,\n+.inherited-list.expanded h3 a:active {\n+    color: var(--link-color-active);\n+}\n@@ -998,1 +1008,1 @@\n-    padding: 8px 3px 3px 7px;\n+    padding: 8px 5px 3px 7px;\n@@ -1518,0 +1528,21 @@\n+.inherited-list h3 > button {\n+    cursor: pointer;\n+    color: var(--subnav-link-color);\n+    position: relative;\n+    background-color: transparent;\n+    background-image:url(\"right.svg\");\n+    background-repeat: no-repeat;\n+    background-size: 12px;\n+    background-position:3px 6px;\n+    border:none;\n+    width: 1.3em;\n+    height: 1.6em;\n+    vertical-align: middle;\n+    top: -2px;\n+}\n+.inherited-list h3:has(button) {\n+    padding-left: 2px;\n+}\n+.inherited-list.expanded h3 > button {\n+    background-image: url(\"down.svg\");\n+}\n@@ -1525,0 +1556,9 @@\n+.inherited-list > div {\n+    display: none;\n+}\n+.inherited-list.expanded > code {\n+    display: none;\n+}\n+.inherited-list.expanded > div {\n+    display: grid;\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,3 @@\n-        Content desc = tagletWriter.htmlWriter.commentTagsToContent(element, indexTree.getDescription(), context.within(indexTree));\n-        String descText = utils.normalizeWhitespace(extractText(desc));\n+        Content desc = tagletWriter.htmlWriter.commentTagsToContent(element, indexTree.getDescription(),\n+                context.within(indexTree));\n+        String descText = utils.normalizeWhitespace(desc.stripTags().toString());\n@@ -68,6 +69,0 @@\n-\n-    \/\/ ugly but simple;\n-    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n-    private String extractText(Content c) {\n-        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/IndexTaglet.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.html.Entity;\n@@ -51,1 +50,0 @@\n-import jdk.javadoc.internal.html.RawHtml;\n@@ -53,1 +51,0 @@\n-import jdk.javadoc.internal.html.TextBuilder;\n@@ -126,29 +123,1 @@\n-                utils.normalizeWhitespace(textOf(label)), label);\n-    }\n-\n-    \/\/ this is here, for now, but might be a useful addition elsewhere,\n-    \/\/ perhaps as a method on Content\n-    private String textOf(Content c) {\n-        return appendText(new StringBuilder(), c).toString();\n-    }\n-\n-    private StringBuilder appendText(StringBuilder sb, Content c) {\n-        if (c instanceof ContentBuilder cb) {\n-            appendText(sb, cb.getContents());\n-        } else if (c instanceof HtmlTree ht) {\n-            appendText(sb, ht.getContents());\n-        } else if (c instanceof RawHtml rh) {\n-            sb.append(rh.toString().replaceAll(\"<[^>]*>\", \"\"));\n-        } else if (c instanceof TextBuilder tb) {\n-            sb.append(tb.toString());\n-        } else if (c instanceof Text t) {\n-            sb.append(t.toString());\n-        } else if (c instanceof Entity e) {\n-            sb.append(e.toString());\n-        }\n-        return sb;\n-    }\n-\n-    private StringBuilder appendText(StringBuilder sb, List<? extends Content> contents) {\n-        contents.forEach(c -> appendText(sb, c));\n-        return sb;\n+                utils.normalizeWhitespace(label.stripTags().toString()), label);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -364,0 +364,4 @@\n+        \/\/ Check if member was already processed\n+        if (dcInfoMap.containsKey(member)) {\n+            return;\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+doclet.Toggle_member_listing=Toggle between short and detailed list view\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.function.UnaryOperator;\n@@ -191,1 +192,1 @@\n-        copyResource(resource, url, replaceNewLine, null);\n+        copyResource(resource, url, replaceNewLine, UnaryOperator.identity());\n@@ -205,1 +206,1 @@\n-        copyResource(resource, url, true, resources);\n+        copyResource(resource, url, resources == null ? UnaryOperator.identity() : line -> localize(line, resources));\n@@ -208,2 +209,18 @@\n-    private void copyResource(DocPath resource, URL url, boolean replaceNewLine, Resources resources)\n-                throws DocFileIOException, ResourceIOException {\n+    \/**\n+     * Copy the contents of a resource file to this file while transforming and filtering its lines.\n+     *\n+     * @param resource the path of the resource\n+     * @param url the URL of the resource\n+     * @param lineTransformer the transforming function that is called for each line; may return\n+     * {@code null} to remove a line.\n+     *\n+     * @throws DocFileIOException if there is a problem while writing the copy\n+     * @throws ResourceIOException if there is a problem while reading the resource\n+     *\/\n+    public void copyResource(DocPath resource, URL url, UnaryOperator<String> lineTransformer)\n+            throws DocFileIOException, ResourceIOException {\n+        copyResource(resource, url, true, lineTransformer);\n+    }\n+\n+    private void copyResource(DocPath resource, URL url, boolean replaceNewLine, UnaryOperator<String> lineTransformer)\n+            throws ResourceIOException, DocFileIOException {\n@@ -219,2 +236,5 @@\n-                                write(this, writer, resources == null ? line : localize(line, resources));\n-                                write(this, writer, PLATFORM_LINE_SEPARATOR);\n+                                String transformedLine = lineTransformer.apply(line);\n+                                if (transformedLine != null) {\n+                                    write(this, writer, transformedLine);\n+                                    write(this, writer, PLATFORM_LINE_SEPARATOR);\n+                                }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocFile.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+    \/** The name of the downwards pointing angle icon. *\/\n+    public static final DocPath DOWN_SVG = DocPath.create(\"down.svg\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,0 +145,7 @@\n+    \/**\n+     * {@return the plain text of this content with HTML tags removed}\n+     *\/\n+    public Content stripTags() {\n+        return this;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/Content.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -108,0 +108,9 @@\n+    @Override\n+    public Content stripTags() {\n+        var text = new ContentBuilder();\n+        for (Content c : contents) {\n+            text.add(c.stripTags());\n+        }\n+        return text;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/ContentBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+        Objects.requireNonNull(content, \"Content must not be null\");\n@@ -282,0 +283,9 @@\n+    @Override\n+    public Content stripTags() {\n+        var text = new ContentBuilder();\n+        for (Content c : content) {\n+            text.add(c.stripTags());\n+        }\n+        return text;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlTree.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -160,0 +160,5 @@\n+    @Override\n+    public Content stripTags() {\n+        return Text.of(rawHtmlContent.replaceAll(\"<[^>]*>\", \"\"));\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/RawHtml.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.Files;\n@@ -30,0 +31,2 @@\n+import java.util.List;\n+import java.util.Set;\n@@ -98,0 +101,1 @@\n+        validateAppContentDirs(app);\n@@ -143,0 +147,12 @@\n+    private static void validateAppContentDirs(Application app) {\n+        for (var contentDir : app.contentDirs()) {\n+            if (!Files.isDirectory(contentDir)) {\n+                Log.info(I18N.format(\"warning.app.content.is.not.dir\",\n+                        contentDir));\n+            } else if (!CONTENTS_SUB_DIRS.contains(contentDir.getFileName().toString())) {\n+                Log.info(I18N.format(\"warning.non.standard.contents.sub.dir\",\n+                        contentDir));\n+            }\n+        }\n+    }\n+\n@@ -253,0 +269,4 @@\n+\n+    \/\/ List of standard subdirectories of the \"Contents\" directory\n+    private static final Set<String> CONTENTS_SUB_DIRS = Set.of(\"MacOS\",\n+            \"Resources\", \"Frameworks\", \"PlugIns\", \"SharedSupport\");\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+warning.non.standard.contents.sub.dir=Warning: The file name of the directory \"{0}\" specified for the --app-content option is not a standard subdirectory name in the \"Contents\" directory of the application bundle. The result application bundle may fail code signing and\/or notarization.\n+warning.app.content.is.not.dir=Warning: The value \"{0}\" of the --app-content option is not a directory. The result application bundle may fail code signing and\/or notarization.\n\\ No newline at end of file\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+            String pAppContentNote;\n@@ -69,0 +70,2 @@\n+                    pAppContentNote\n+                            = I18N.getString(\"MSG_Help_mac_app_content_note\");\n@@ -79,0 +82,1 @@\n+                    pAppContentNote = \"\";\n@@ -89,0 +93,1 @@\n+                    pAppContentNote = \"\";\n@@ -102,0 +107,1 @@\n+                    pAppContentNote = \"\";\n@@ -107,1 +113,1 @@\n-                    pSignSampleUsage));\n+                    pSignSampleUsage, pAppContentNote));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CLIHelp.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-\\n\\\n+{7}\\n\\\n@@ -337,0 +337,7 @@\n+\n+MSG_Help_mac_app_content_note=\\\n+\\          Note: The value should be a directory with the \"Resources\"\\n\\\n+\\          subdirectory (or any other directory that is valid in the \"Contents\"\\n\\\n+\\          directory of the application bundle). Otherwise, jpackage may produce\\n\\\n+\\          invalid application bundle which may fail code signing and\/or\\n\\\n+\\          notarization.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -193,0 +193,6 @@\n+    macOS note: The value should be a directory with the \"Resources\"\n+                subdirectory (or any other directory that is valid in the\n+                \"Contents\" directory of the application bundle). Otherwise,\n+                jpackage may produce invalid application bundle which may fail\n+                code signing and\/or notarization.\n+\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -142,0 +143,1 @@\n+import javax.tools.DiagnosticListener;\n@@ -657,1 +659,4 @@\n-            Scanner scanner = ScannerFactory.instance(new Context()).newScanner(wrappedCode, false);\n+            Context ctx = new Context();\n+            ctx.put(DiagnosticListener.class, (DiagnosticListener) d -> {});\n+            Scanner scanner = ScannerFactory.instance(ctx).newScanner(wrappedCode, false);\n+            Log.instance(ctx).useSource(cut.getSourceFile());\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+    if (type.isPrimitive() || type.isHidden() || type.isArray()) throw new IllegalArgumentException(\"Type has no class file: \" + type);\n@@ -12,2 +13,1 @@\n-        var name = type.getCanonicalName();\n-        if (name == null) throw new IllegalArgumentException(\"Type not supported: \" + type);\n+        var name = type.getName();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/resources\/TOOLING.jsh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-  ASSERT_EQ(a.long_term_pause_time_ratio(), 0.0);\n-  ASSERT_EQ(a.short_term_pause_time_ratio(), 0.0);\n+  ASSERT_EQ(a.long_term_gc_time_ratio(), 0.0);\n+  ASSERT_EQ(a.short_term_gc_time_ratio(), 0.0);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1Analytics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arguments;\n+\n+\/*\n+ * @test TestCompileTaskTimeout\n+ * @bug 8308094 8365909\n+ * @requires vm.debug & vm.flagless & os.name == \"Linux\"\n+ * @summary Check functionality of CompileTaskTimeout\n+ * @library \/test\/lib\n+ * @run driver compiler.arguments.TestCompileTaskTimeout\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestCompileTaskTimeout {\n+\n+    public static void main(String[] args) throws Throwable {\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=1\", \"--version\")\n+                    .shouldHaveExitValue(134)\n+                    .shouldContain(\"timed out after\");\n+\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=1\", \"-XX:TieredStopAtLevel=3\", \"--version\")\n+                    .shouldHaveExitValue(134)\n+                    .shouldContain(\"timed out after\");\n+\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=1\", \"-XX:-TieredCompilation\", \"--version\")\n+                    .shouldHaveExitValue(134)\n+                    .shouldContain(\"timed out after\");\n+\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=200\", \"--version\")\n+                    .shouldHaveExitValue(0);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompileTaskTimeout.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8360561\n+ * @summary Ranges can be proven to be disjoint but not orderable (thanks to unsigned range)\n+ *          Comparing such values in such range with != should always be true.\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.igvn.CmpDisjointButNonOrderedRanges::*\n+ *                   compiler.igvn.CmpDisjointButNonOrderedRanges\n+ * @run main compiler.igvn.CmpDisjointButNonOrderedRanges\n+ *\/\n+package compiler.igvn;\n+\n+public class CmpDisjointButNonOrderedRanges {\n+    static boolean bFld;\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+\n+    static void test() {\n+        int x = 7;\n+        int y = 4;\n+        for (int i = 3; i < 12; i++) {\n+            \/\/ x = 7 \\\/ x = -195 => x \\in [-195, 7] as a signed value\n+            \/\/ but [7, bitwise_cast_uint(-195)] as unsigned\n+            \/\/ So 0 is not possible.\n+            if (x != 0) {\n+                A.foo();\n+                \/\/ Because A is not loaded, A.foo() traps and this point is not reachable.\n+            }\n+            \/\/ x is tighten to be in the meet (so Hotspot's join) of [0, 0] and [7, bitwise_cast_uint(-195)]\n+            \/\/ that is bottom (Hotspot's top). Data is dead, control needs to be dead as well.\n+            for (int j = 1; j < 8; j++) {\n+                x = -195;\n+                if (bFld) {\n+                    y += 2;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void foo() {\n+    }\n+}\n+\n+\n+class A {\n+    static void foo() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/CmpDisjointButNonOrderedRanges.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8360561\n+ * @summary Ranges can be proven to be disjoint but not orderable (thanks to unsigned range)\n+ *          Comparing such values in such range with != should always be true.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=compileonly,compiler.igvn.CmpDisjointButNonOrderedRanges2::*\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:+UnlockExperimentalVMOptions\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.igvn.CmpDisjointButNonOrderedRanges2\n+ * @run main compiler.igvn.CmpDisjointButNonOrderedRanges2\n+ *\/\n+package compiler.igvn;\n+\n+public class CmpDisjointButNonOrderedRanges2 {\n+    int array[];\n+\n+    void test() {\n+        int val = 2;\n+        for (int i = 0; i < 10; i++) {\n+            \/\/ val = 2 \\\/ val = -12 => val \\in [-12, 2] as a signed value\n+            \/\/ but [2, bitwise_cast_uint(-12)] as unsigned\n+            \/\/ So 0 is not possible.\n+            if (val != 0) {\n+                return;\n+            }\n+            \/\/ val is tighten to be in the meet (so Hotspot's join) of [0, 0] and [2, bitwise_cast_uint(-12)]\n+            \/\/ that is bottom (Hotspot's top). Data is dead, control needs to be dead as well.\n+            for (int j = 0; j < 10; j++) {\n+                array[1] = val;\n+                val = -12;\n+            }\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        var c = new CmpDisjointButNonOrderedRanges2();\n+        for (int i = 0; i < 1000; ++i) {\n+            c.test();\n+            for (int j = 0; j < 100; ++j) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/CmpDisjointButNonOrderedRanges2.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8360561\n+ * @summary Ranges can be proven to be disjoint but not orderable (thanks to unsigned range)\n+ *          Comparing such values in such range with != should always be true.\n+ * @library \/test\/lib \/\n+ * @run main compiler.igvn.CmpDisjointButNonOrderedRangesLong\n+ *\/\n+package compiler.igvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class CmpDisjointButNonOrderedRangesLong {\n+    static boolean bFld;\n+    static double dFld1;\n+    static double dFld2;\n+\n+    public static void main(String[] strArr) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.PHI})\n+    @Warmup(0)\n+    static int test() {\n+        long x = 7;\n+        if (bFld) {\n+            x = -195;\n+        }\n+\n+        dFld1 = dFld2 % 2.5;\n+\n+        if (x == 0) {\n+            return 0;\n+        }\n+        return 1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/CmpDisjointButNonOrderedRangesLong.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+ * @requires (os.arch != \"riscv64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"))\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestVerifyIntrinsicChecks.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365206\n+ * @summary Verify NaN sign and significand bits are preserved across conversions,\n+ *          float -> float16 -> float\n+ * @requires (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh.*\")\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xmixed -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileThresholdScaling=1000.0 Binary16ConversionNaN_2\n+ *\/\n+\n+\/*\n+ * The behavior tested below is an implementation property not\n+ * required by the specification. It would be acceptable for this\n+ * information to not be preserved (as long as a NaN is returned) if,\n+ * say, a intrinsified version using native hardware instructions\n+ * behaved differently.\n+ *\n+ * If that is the case, this test should be modified to disable\n+ * intrinsics or to otherwise not run on platforms with an differently\n+ * behaving intrinsic.\n+ *\/\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Method;\n+import java.util.Random;\n+\n+public class Binary16ConversionNaN_2 {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/*\n+     * Put all 16-bit NaN values through a conversion loop and make\n+     * sure the significand, sign, and exponent are all preserved.\n+     *\/\n+    public static void main(String... argv) throws NoSuchMethodException {\n+        int errors = 0;\n+        final int NAN_EXPONENT = 0x7f80_0000;\n+        final int SIGN_BIT     = 0x8000_0000;\n+\n+        \/\/ First, run with Interpreter only to  collect \"gold\" data.\n+        \/\/ Glags -Xmixed -XX:CompileThresholdScaling=1000.0 are used\n+        \/\/ to prevent compilation during this phase.\n+        float[] pVal = new float[1024];\n+        float[] pRes = new float[1024];\n+        float[] nVal = new float[1024];\n+        float[] nRes = new float[1024];\n+\n+        Random rand = new Random();\n+\n+        \/\/ A NaN has a nonzero significand\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            int shift = rand.nextInt(13+1);\n+            int binaryNaN = (NAN_EXPONENT | (i << shift));\n+            assert isNaN(binaryNaN);\n+            \/\/ the payloads of non-canonical NaNs are preserved.\n+            float f1 = Float.intBitsToFloat(binaryNaN);\n+            float f2 = testRoundTrip(f1);\n+            errors  += verify(f1, f2);\n+            pVal[i] = f1;\n+            pRes[i] = f2;\n+\n+            int binaryNegNaN = (SIGN_BIT | binaryNaN);\n+            float f3 = Float.intBitsToFloat(binaryNegNaN);\n+            float f4 = testRoundTrip(f3);\n+            errors  += verify(f3, f4);\n+            nVal[i] = f3;\n+            nRes[i] = f4;\n+        }\n+        if (errors > 0) { \/\/ Exit if Interpreter failed\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+\n+        Method test_method = Binary16ConversionNaN_2.class.getDeclaredMethod(\"testRoundTrip\", float.class);\n+\n+        \/\/ Compile with C1 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C1\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            float f1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], f1, \"C1\");\n+            float f2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], f2, \"C1\");\n+        }\n+\n+        WHITE_BOX.deoptimizeMethod(test_method);\n+\n+        \/\/ Compile with C2 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C2\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            float f1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], f1, \"C2\");\n+            float f2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], f2, \"C2\");\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+    }\n+\n+    private static boolean isNaN(int binary) {\n+        return ((binary & 0x7f80_0000) == 0x7f80_0000) \/\/ Max exponent and...\n+            && ((binary & 0x007f_ffff) != 0 );         \/\/ significand nonzero.\n+    }\n+\n+    private static float testRoundTrip(float f) {\n+        short s = Float.floatToFloat16(f);\n+        return Float.float16ToFloat(s);\n+    }\n+\n+    private static int verify(float f1, float f2) {\n+        int errors = 0;\n+        int i1 = Float.floatToRawIntBits(f1);\n+        int i2 = Float.floatToRawIntBits(f2);\n+        assert Float.isNaN(f1);\n+        if (!Float.isNaN(f2) ||\n+            ((i1 & 0x8000_0000) != (i2 & 0x8000_0000))) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(i1) +\n+                               \"\\t got back \" + Integer.toHexString(i2));\n+        }\n+        return errors;\n+    }\n+\n+    private static int verifyCompiler(float f1, float f2, String name) {\n+        int errors = 0;\n+        int i1 = Float.floatToRawIntBits(f1);\n+        int i2 = Float.floatToRawIntBits(f2);\n+        assert Float.isNaN(f1);\n+        if (!Float.isNaN(f2) ||\n+            ((i1 & 0x8000_0000) != (i2 & 0x8000_0000))) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(i1) +\n+                               \"\\t got back \" + Integer.toHexString(i2) +\n+                               \"\\t from \" + name + \" code\");\n+        }\n+        return errors;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN_2.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -40,0 +41,1 @@\n+import java.util.Random;\n@@ -43,0 +45,1 @@\n+import jdk.test.lib.Utils;\n@@ -82,0 +85,1 @@\n+        Random rand = Utils.getRandomInstance();\n@@ -88,2 +92,3 @@\n-            if (i%39 == 0) {\n-                int x = 0x7f800000 + ((i\/39) << 13);\n+            if (i%3 == 0) {\n+                int shift = rand.nextInt(13+1);\n+                int x = 0x7f800000 + ((i\/39) << shift);\n@@ -131,1 +136,2 @@\n-        String msg = \"floatToFloat16 wrong result: idx: \" + idx + \", \\t\" + f +\n+        String msg = \"floatToFloat16 wrong result: idx: \" + idx +\n+                     \", \\t\" + f + \", hex: \" + Integer.toHexString(Float.floatToRawIntBits(f)) +\n@@ -170,1 +176,1 @@\n-            if (i%39 == 0) {\n+            if (i%3 == 0) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/CreateCoredumpOnCrash.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n@@ -36,0 +37,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -49,1 +52,1 @@\n-        ArrayList<String> dumpArgs = new ArrayList<>();\n+        ArrayList<String> vmArgs = new ArrayList<>();\n@@ -52,1 +55,1 @@\n-        dumpArgs.add(\"-Xmx128M\");\n+        vmArgs.add(\"-Xmx128M\");\n@@ -57,1 +60,1 @@\n-            dumpArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+            vmArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n@@ -60,1 +63,3 @@\n-        dump(dumpArgs);\n+        String archiveFile = dump(vmArgs);\n+        exec(vmArgs, archiveFile);\n+\n@@ -64,1 +69,3 @@\n-    static void dump(ArrayList<String> args, String... more) throws Exception {\n+\n+    \/\/ Create a map file when creating the archive\n+    static String dump(ArrayList<String> args) throws Exception {\n@@ -70,0 +77,1 @@\n+            \/\/ filesize=0 ensures that a large map file not broken up in multiple files.\n@@ -72,2 +80,1 @@\n-            .addSuffix(args)\n-            .addSuffix(more);\n+            .addSuffix(args);\n@@ -78,0 +85,19 @@\n+\n+        return archiveName;\n+    }\n+\n+    \/\/ Create a map file when using the archive\n+    static void exec(ArrayList<String> vmArgs, String archiveFile) throws Exception {\n+        String mapName = archiveFile + \".exec.map\";\n+        vmArgs.add(\"-XX:SharedArchiveFile=\" + archiveFile);\n+        vmArgs.add(\"-Xlog:cds=debug\");\n+        vmArgs.add(\"-Xshare:on\");\n+        vmArgs.add(\"-Xlog:aot+map=debug,aot+map+oops=trace:file=\" + mapName + \":none:filesize=0\");\n+        vmArgs.add(\"--version\");\n+        String[] cmdLine = vmArgs.toArray(new String[vmArgs.size()]);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        OutputAnalyzer out = CDSTestUtils.executeAndLog(pb, \"exec\");\n+        out.shouldHaveExitValue(0);\n+\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        CDSMapReader.validate(mapFile);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-                MAIN_CLASS_NAME,\n@@ -126,0 +125,1 @@\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n@@ -137,0 +137,1 @@\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfSyntheticClasses.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,2 +430,0 @@\n-        CDSTestUtils.addVerifyArchivedFields(cmd);\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=aot\n+ * @bug 8362566\n+ * @summary Test the contents of -Xlog:aot+map with AOT workflow\n+ * @requires vm.flagless\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @build AOTMapTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTMapTestApp\n+ * @run driver AOTMapTest AOT --two-step-training\n+ *\/\n+\n+\/**\n+ * @test id=dynamic\n+ * @bug 8362566\n+ * @summary Test the contents of -Xlog:aot+map with AOT workflow\n+ * @requires vm.flagless\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @build AOTMapTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTMapTestApp\n+ * @run  main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. AOTMapTest DYNAMIC\n+ *\/\n+\n+\n+import java.util.ArrayList;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.Platform;\n+\n+public class AOTMapTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"AOTMapTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        doTest(args, false);\n+\n+        if (Platform.is64bit()) {\n+            \/\/ There's no oop\/klass compression on 32-bit.\n+            doTest(args, true);\n+        }\n+    }\n+\n+    public static void doTest(String[] args, boolean compressed) throws Exception {\n+        Tester tester = new Tester(compressed);\n+        tester.run(args);\n+\n+        validate(tester.dumpMapFile);\n+        validate(tester.runMapFile);\n+    }\n+\n+    static void validate(String mapFileName) {\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapFileName);\n+        CDSMapReader.validate(mapFile);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        boolean compressed;\n+        String dumpMapFile;\n+        String runMapFile;\n+\n+        public Tester(boolean compressed) {\n+            super(mainClass);\n+            this.compressed = compressed;\n+\n+            dumpMapFile = \"test\" + (compressed ? \"0\" : \"1\") + \".dump.aotmap\";\n+            runMapFile  = \"test\" + (compressed ? \"0\" : \"1\") + \".run.aotmap\";\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            ArrayList<String> vmArgs = new ArrayList<>();\n+\n+            vmArgs.add(\"-Xmx128M\");\n+            vmArgs.add(\"-Xlog:aot=debug\");\n+\n+            if (Platform.is64bit()) {\n+                \/\/ These options are available only on 64-bit.\n+                String sign = (compressed) ?  \"+\" : \"-\";\n+                vmArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+            }\n+\n+            \/\/ filesize=0 ensures that a large map file not broken up in multiple files.\n+            String logMapPrefix = \"-Xlog:aot+map=debug,aot+map+oops=trace:file=\";\n+            String logMapSuffix = \":none:filesize=0\";\n+\n+            if (runMode == RunMode.ASSEMBLY || runMode == RunMode.DUMP_DYNAMIC) {\n+                vmArgs.add(logMapPrefix + dumpMapFile + logMapSuffix);\n+            } else if (runMode == RunMode.PRODUCTION) {\n+                vmArgs.add(logMapPrefix + runMapFile + logMapSuffix);\n+            }\n+\n+            return vmArgs.toArray(new String[vmArgs.size()]);\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+            };\n+        }\n+    }\n+}\n+\n+class AOTMapTestApp {\n+    public static void main(String[] args) {\n+        System.out.println(\"Hello AOTMapTestApp\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTMapTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @requires os.family != \"windows\" & os.family != \"aix\" & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/signal\/TestSigalrm.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+                    \"share\/logging\",\n","filename":"test\/hotspot\/jtreg\/sources\/TestIncludesAreSorted.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1127,2 +1127,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_MAX, \"> 0\"}) \/\/ valid\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"> 0\"}) \/\/ valid, but only if MaxVectorSize > 0, otherwise, a violation is reported\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_MAX, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"> 0\"}) \/\/ valid, but only if MaxVectorSize > 0, otherwise, a violation is reported\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestBadFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+\n+    \/\/ In nanoseconds\n@@ -62,1 +64,0 @@\n-    private long finishTime;\n@@ -64,0 +65,2 @@\n+    private long stressTime;\n+\n@@ -182,1 +185,1 @@\n-        println(out, \"Execution time: \" + (currentTime - startTime) + \" seconds\");\n+        println(out, \"Execution time: \" + (currentTime - startTime) \/ 1_000_000_000.0 + \" seconds\");\n@@ -189,2 +192,2 @@\n-        } else if (finishTime != 0 && currentTime >= finishTime) {\n-            println(out, \"Execution finished because time was exceeded: \" + (currentTime - startTime) + \" >= \" + (finishTime - startTime));\n+        } else if (stressTime != 0 && (currentTime - startTime) >= stressTime) {\n+            println(out, \"Execution finished because time has exceeded stress time: \" + stressTime \/ 1_000_000_000 + \" seconds\");\n@@ -211,7 +214,2 @@\n-        long stressTime = options.getTime();\n-        startTime = System.currentTimeMillis();\n-        if (stressTime == 0) {\n-            finishTime = 0;\n-        } else {\n-            finishTime = startTime + stressTime * 1000;\n-        }\n+        stressTime = options.getTime() * 1_000_000_000;\n+        startTime = System.nanoTime();\n@@ -235,1 +233,1 @@\n-        currentTime = System.currentTimeMillis();\n+        currentTime = System.nanoTime();\n@@ -258,0 +256,2 @@\n+        boolean result = continueExecution();\n+        \/\/ Call print at the end to show the most up-to-date info.\n@@ -261,1 +261,1 @@\n-        return continueExecution();\n+        return result;\n@@ -270,1 +270,1 @@\n-        currentTime = System.currentTimeMillis();\n+        currentTime = System.nanoTime();\n@@ -277,1 +277,1 @@\n-                && (finishTime == 0 || currentTime < finishTime);\n+                && (stressTime == 0 || (currentTime - startTime) < stressTime);\n@@ -312,1 +312,1 @@\n-        return System.currentTimeMillis() - startTime;\n+        return (System.nanoTime() - startTime) \/ 1_000_000;\n@@ -321,2 +321,2 @@\n-        long current = System.currentTimeMillis();\n-        if (current >= finishTime) {\n+        long elapsedTime = System.nanoTime() - startTime;\n+        if (elapsedTime >= stressTime) {\n@@ -325,1 +325,1 @@\n-            return finishTime - current;\n+            return (stressTime - elapsedTime) \/ 1_000_000;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/Stresser.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -628,1 +628,1 @@\n-\n+java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java       8365398 generic-all\n@@ -765,5 +765,0 @@\n-sun\/tools\/jstat\/jstatLineCounts1.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts2.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts3.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts4.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,6 +25,5 @@\n-  @test\n-  @key headful\n-  @bug 6315717\n-  @summary verifies that drag events are coming for every button if the property is set to true\n-  @author Andrei Dmitriev : area=awt.mouse\n-  @run main ExtraButtonDrag\n+ * @test\n+ * @key headful\n+ * @bug 6315717\n+ * @summary Verifies that the mouse drag events received for every button if the property is set to true\n+ * @run main ExtraButtonDrag\n@@ -33,36 +32,27 @@\n-\/\/events from standard should also come\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-\n-public class ExtraButtonDrag extends Frame {\n-    static String tk = Toolkit.getDefaultToolkit().getClass().getName();\n-    static Robot robot;\n-    static int [] buttonsPressed;\n-    static int [] buttonsReleased;\n-    static int [] buttonsClicked;\n-    volatile static boolean dragged = false;\n-    volatile static boolean moved = false;\n-\n-    public ExtraButtonDrag(){\n-        super(\"ExtraButtonDrag\");\n-    }\n-\n-    public static void main(String []s){\n-        Frame frame = new ExtraButtonDrag();\n-\n-        MouseAdapter ma = new MouseAdapter() {\n-                public void mouseDragged(MouseEvent e) {\n-                    System.out.println(\"Dragged \"+e);\/\/ +\" : \"+ e.getButton() + \" : \" +e.getButtonState(e.getButton()));\n-                    dragged = true;\n-                }\n-                public void mouseMoved(MouseEvent e) {\n-                    System.out.println(\"Moved \"+e);\n-                    moved = true;\n-                }\n-                public void mousePressed(MouseEvent e) {\n-                    System.out.println(\">>> \"+e);\n-                }\n-                public void mouseReleased(MouseEvent e) {\n-                    System.out.println(\">>> \"+e);\n-                }\n+import java.awt.AWTException;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ExtraButtonDrag {\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+    private static volatile boolean dragged = false;\n+    private static volatile boolean moved = false;\n+    private static volatile Point centerFrame;\n+    private static volatile Point outboundsFrame;\n+    private static final String OS_NAME = System.getProperty(\"os.name\");\n+    private static MouseAdapter mAdapter = new MouseAdapter() {\n+        @Override\n+        public void mouseDragged(MouseEvent e) {\n+            dragged = true;\n+        }\n@@ -70,1 +60,5 @@\n-            };\n+        @Override\n+        public void mouseMoved(MouseEvent e) {\n+            moved = true;\n+        }\n+    };\n@@ -72,2 +66,4 @@\n-        frame.addMouseMotionListener(ma);\n-        frame.addMouseListener(ma);\n+    public static void initializeGUI() {\n+        frame = new Frame(\"ExtraButtonDrag\");\n+        frame.addMouseMotionListener(mAdapter);\n+        frame.addMouseListener(mAdapter);\n@@ -76,0 +72,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -77,0 +74,1 @@\n+    }\n@@ -78,6 +76,2 @@\n-        int [] buttonMask = new int [MouseInfo.getNumberOfButtons()]; \/\/InputEvent.getButtonMasks();\n-\n-        for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++){\n-            buttonMask[i] = InputEvent.getMaskForButton(i+1);\n-            \/\/            System.out.println(\"TEST: \"+tmp[i]);\n-        }\n+    public static void doTest()\n+        throws InvocationTargetException, InterruptedException {\n@@ -85,5 +79,1 @@\n-        try {\n-            robot = new Robot();\n-            robot.delay(1000);\n-            Point centerFrame = new Point(frame.getLocationOnScreen().x + frame.getWidth()\/2, frame.getLocationOnScreen().y + frame.getHeight()\/2);\n-            Point outboundsFrame = new Point(frame.getLocationOnScreen().x + frame.getWidth()*3\/2, frame.getLocationOnScreen().y + frame.getHeight()\/2);\n+        int[] buttonMask = new int[MouseInfo.getNumberOfButtons()];\n@@ -91,4 +81,3 @@\n-            System.out.println(\"areExtraMouseButtonsEnabled() == \" + Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled() );\n-\n-            for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++){\n-                System.out.println(\"button to drag = \" +(i+1) + \" : value passed to robot = \" +buttonMask[i]);\n+        for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++) {\n+            buttonMask[i] = InputEvent.getMaskForButton(i + 1);\n+        }\n@@ -96,5 +85,23 @@\n-                try {\n-                    dragMouse(buttonMask[i], centerFrame.x, centerFrame.y, outboundsFrame.x, outboundsFrame.y);\n-                } catch (IllegalArgumentException e){\n-                    throw new RuntimeException(\"Test failed. Exception occured.\", e);\n-                }\n+        EventQueue.invokeAndWait(() -> {\n+            Point location = frame.getLocationOnScreen();\n+            Dimension size = frame.getSize();\n+            centerFrame = new Point(location.x + size.width \/ 2,\n+                location.y + size.height \/ 2);\n+            outboundsFrame = new Point(location.x + size.width * 3 \/ 2,\n+                location.y + size.height \/ 2);\n+        });\n+\n+        System.out.println(\"areExtraMouseButtonsEnabled() == \"\n+            + Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled());\n+\n+        for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++) {\n+            System.out.println(\"button to drag = \" + (i + 1)\n+                + \" : value passed to robot = \" + buttonMask[i]);\n+\n+            try {\n+                dragMouse(buttonMask[i], centerFrame.x, centerFrame.y,\n+                    outboundsFrame.x, outboundsFrame.y);\n+            } catch (IllegalArgumentException e) {\n+                throw new RuntimeException(\"Test failed. Exception occured.\",\n+                    e);\n+            }\n@@ -102,14 +109,12 @@\n-                robot.delay(500);\n-                \/\/this is a choice-case for X protocol issue: native events from extra buttons doesn't contain\n-                \/\/ the correct state so it's unable to decide if there is a drag or move. By default we send MOVED event.\n-                \/\/XToolkit: extra buttons should report MOVED events only\n-                \/\/WToolkit: extra buttons should report DRAGGED events only\n-                if (i > 2){ \/\/extra buttons only\n-                    if (tk.equals(\"sun.awt.X11.XToolkit\")) {\n-                        if (!moved || dragged) {\n-                            throw new RuntimeException(\"Test failed.\"+ tk +\" Button = \" +(i+1) + \" moved = \"+moved +\" : dragged = \" +dragged);\n-                        }\n-                    } else { \/\/WToolkit\n-                        if (moved || !dragged) {\n-                            throw new RuntimeException(\"Test failed.\"+ tk +\" Button = \" +(i+1) + \" moved = \"+moved +\" : dragged = \" +dragged);\n-                        }\n+            \/\/ this is a choice-case for X protocol issue: native events from\n+            \/\/ extra buttons doesn't contain\n+            \/\/ the correct state so it's unable to decide if there is a drag or\n+            \/\/ move. By default we send MOVED event.\n+            \/\/ XToolkit: extra buttons should report MOVED events only\n+            \/\/ WToolkit: extra buttons should report DRAGGED events only\n+            if (i > 2) { \/\/ extra buttons only\n+                if (OS_NAME.equals(\"Linux\")) {\n+                    if (!moved || dragged) {\n+                        throw new RuntimeException(\"Test failed.\" + OS_NAME\n+                            + \" Button = \" + (i + 1) + \" moved = \" + moved\n+                            + \" : dragged = \" + dragged);\n@@ -117,3 +122,5 @@\n-                } else {\n-                    if (moved || !dragged){\n-                        throw new RuntimeException(\"Test failed. Button = \" +(i+1) + \" not dragged.\");\n+                } else { \/\/ WToolkit\n+                    if (moved || !dragged) {\n+                        throw new RuntimeException(\"Test failed.\" + OS_NAME\n+                            + \" Button = \" + (i + 1) + \" moved = \" + moved\n+                            + \" : dragged = \" + dragged);\n@@ -122,0 +129,5 @@\n+            } else {\n+                if (moved || !dragged) {\n+                    throw new RuntimeException(\n+                        \"Test failed. Button = \" + (i + 1) + \" not dragged.\");\n+                }\n@@ -123,2 +135,0 @@\n-        } catch (Exception e){\n-            throw new RuntimeException(\"\", e);\n@@ -128,1 +138,1 @@\n-    public static void dragMouse(int button, int x0, int y0, int x1, int y1){\n+    public static void dragMouse(int button, int x0, int y0, int x1, int y1) {\n@@ -141,1 +151,1 @@\n-        while (curX != x1){\n+        while (curX != x1) {\n@@ -146,1 +156,1 @@\n-        while (curY != y1 ){\n+        while (curY != y1) {\n@@ -154,0 +164,26 @@\n+    public static void main(String[] s)\n+        throws InvocationTargetException, InterruptedException, AWTException {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(10);\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(ExtraButtonDrag::initializeGUI);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            doTest();\n+\n+            System.out.println(\"Test Passed\");\n+        } finally {\n+            EventQueue.invokeAndWait(ExtraButtonDrag::disposeFrame);\n+        }\n+    }\n+\n+    public static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseModifiersUnitTest\/ExtraButtonDrag.java","additions":124,"deletions":88,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -24,2 +24,11 @@\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -29,1 +38,1 @@\n- * @bug 8341975 8351435\n+ * @bug 8341975 8351435 8361613\n@@ -32,6 +41,6 @@\n- * @modules jdk.internal.le\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=UTF-8 DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=ISO-8859-1 DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=US-ASCII DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=foo DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le DefaultCharsetTest\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.JDKToolFinder\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run junit DefaultCharsetTest\n@@ -40,2 +49,24 @@\n-    @Test\n-    public void testDefaultCharset() {\n+    @BeforeAll\n+    static void checkExpectAvailability() {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+    }\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"UTF-8\", \"ISO-8859-1\", \"US-ASCII\", \"foo\", \"\"})\n+    void testDefaultCharset(String stdoutEncoding) throws Exception {\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer oa = ProcessTools.executeProcess(\n+            \"expect\",\n+            \"-n\",\n+            TEST_SRC + \"\/defaultCharset.exp\",\n+            TEST_CLASSES,\n+            TEST_JDK + \"\/bin\/java\",\n+            \"-Dstdout.encoding=\" + stdoutEncoding,\n+            getClass().getName());\n+        oa.reportDiagnosticSummary();\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String... args) {\n@@ -45,7 +76,9 @@\n-        System.out.println(\"\"\"\n-                    stdout.encoding = %s\n-                    System.out.charset() = %s\n-                    System.console().charset() = %s\n-                \"\"\".formatted(stdoutEncoding, sysoutCharset.name(), consoleCharset.name()));\n-        assertEquals(consoleCharset, sysoutCharset,\n-            \"Charsets for System.out and Console differ for stdout.encoding: %s\".formatted(stdoutEncoding));\n+        System.out.printf(\"\"\"\n+                stdout.encoding = %s\n+                System.out.charset() = %s\n+                System.console().charset() = %s\n+            \"\"\", stdoutEncoding, sysoutCharset.name(), consoleCharset.name());\n+        if (!consoleCharset.equals(sysoutCharset)) {\n+            System.err.printf(\"Charsets for System.out and Console differ for stdout.encoding: %s%n\", stdoutEncoding);\n+            System.exit(-1);\n+        }\n","filename":"test\/jdk\/java\/io\/Console\/DefaultCharsetTest.java","additions":51,"deletions":18,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.io.File;\n@@ -29,0 +28,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.function.Predicate;\n@@ -30,0 +32,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -31,0 +34,4 @@\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -34,1 +41,1 @@\n- * @bug 8330276 8351435\n+ * @bug 8330276 8351435 8361613\n@@ -36,0 +43,1 @@\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n@@ -37,1 +45,5 @@\n- * @modules jdk.internal.le jdk.localedata\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.JDKToolFinder\n+ *        jdk.test.lib.process.ProcessTools\n+ * @modules jdk.localedata\n+ * @run junit LocaleTest\n@@ -40,2 +52,2 @@\n-    private static Calendar TODAY  = new GregorianCalendar(2024, Calendar.APRIL, 22);\n-    private static String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n+    private static final Calendar TODAY = new GregorianCalendar(2024, Calendar.APRIL, 22);\n+    private static final String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n@@ -45,1 +57,1 @@\n-    private static List<String> EXPECTED = List.of(\n+    private static final List<String> EXPECTED = List.of(\n@@ -56,25 +68,25 @@\n-    public static void main(String... args) throws Throwable {\n-        if (args.length == 0) {\n-            \/\/ no arg will launch the child process that actually perform tests\n-            var pb = ProcessTools.createTestJavaProcessBuilder(\n-                    \"-Djdk.console=jdk.internal.le\",\n-                    \"LocaleTest\", \"dummy\");\n-            var input = new File(System.getProperty(\"test.src\", \".\"), \"input.txt\");\n-            pb.redirectInput(input);\n-            var oa = ProcessTools.executeProcess(pb);\n-            if (oa.getExitValue() == -1) {\n-                System.out.println(\"System.console() returns null. Ignoring the test.\");\n-            } else {\n-                var output = oa.asLines();\n-                var resultText =\n-                    \"\"\"\n-                    Actual output: %s\n-                    Expected output: %s\n-                    \"\"\".formatted(output, EXPECTED);\n-                if (!output.equals(EXPECTED)) {\n-                    throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n-                } else {\n-                    oa.shouldHaveExitValue(0);\n-                    System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n-                }\n-            }\n+    @Test\n+    void testLocale() throws Exception {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer oa = ProcessTools.executeProcess(\n+            \"expect\",\n+            \"-n\",\n+            TEST_SRC + \"\/locale.exp\",\n+            TEST_CLASSES,\n+            TEST_JDK + \"\/bin\/java\",\n+            getClass().getName());\n+\n+        var stdout =\n+            oa.stdoutAsLines().stream().filter(Predicate.not(String::isEmpty)).toList();\n+        var resultText =\n+            \"\"\"\n+            Actual output: %s\n+            Expected output: %s\n+            \"\"\".formatted(stdout, EXPECTED);\n+        if (!stdout.equals(EXPECTED)) {\n+            throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n@@ -82,11 +94,17 @@\n-            var con = System.console();\n-            if (con != null) {\n-                \/\/ tests these additional methods that take a Locale\n-                con.format(Locale.UK, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.printf(Locale.FRANCE, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readLine(Locale.GERMANY, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n-                con.printf(\"\\n\");\n+            oa.shouldHaveExitValue(0);\n+            System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        var con = System.console();\n+        if (con != null) {\n+            \/\/ tests these additional methods that take a Locale\n+            con.format(Locale.UK, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.printf(Locale.FRANCE, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readLine(Locale.GERMANY, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n+            con.printf(\"\\n\");\n@@ -94,12 +112,11 @@\n-                \/\/ tests null locale\n-                con.format((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.printf((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readLine((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readPassword((Locale)null, FORMAT, TODAY);\n-            } else {\n-                \/\/ Exit with -1\n-                System.exit(-1);\n-            }\n+            \/\/ tests null locale\n+            con.format((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.printf((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readLine((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readPassword((Locale)null, FORMAT, TODAY);\n+        } else {\n+            \/\/ Exit with -1\n+            System.exit(-1);\n","filename":"test\/jdk\/java\/io\/Console\/LocaleTest.java","additions":71,"deletions":54,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8295803 8299689 8351435\n+ * @bug 8295803 8299689 8351435 8361613\n@@ -29,5 +29,4 @@\n- * @modules java.base\/java.io:+open\n- * @run main\/othervm ModuleSelectionTest java.base\n- * @run main\/othervm -Djdk.console=jdk.internal.le ModuleSelectionTest jdk.internal.le\n- * @run main\/othervm -Djdk.console=java.base ModuleSelectionTest java.base\n- * @run main\/othervm --limit-modules java.base ModuleSelectionTest java.base\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run junit ModuleSelectionTest\n@@ -39,0 +38,12 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -41,0 +52,39 @@\n+    private static Stream<Arguments> options() {\n+        return Stream.of(\n+            Arguments.of(\"-Djdk.console=foo\", \"java.base\"),\n+            Arguments.of(\"-Djdk.console=java.base\", \"java.base\"),\n+            Arguments.of(\"-Djdk.console=jdk.internal.le\", \"jdk.internal.le\"),\n+            Arguments.of(\"--limit-modules java.base\", \"java.base\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"options\")\n+    void testNonTTY(String opts) throws Exception {\n+        opts = opts +\n+            \" --add-opens java.base\/java.io=ALL-UNNAMED ModuleSelectionTest null\";\n+        OutputAnalyzer output = ProcessTools.executeTestJava(opts.split(\" \"));\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"options\")\n+    void testTTY(String opts, String expected) throws Exception {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+\n+        opts = \"expect -n \" + TEST_SRC + \"\/moduleSelection.exp \" +\n+            TEST_CLASSES + \" \" +\n+            expected + \" \" +\n+            TEST_JDK + \"\/bin\/java\" +\n+            \" --add-opens java.base\/java.io=ALL-UNNAMED \"\n+            + opts;\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer output = ProcessTools.executeProcess(opts.split(\" \"));\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+    }\n+\n@@ -52,4 +102,1 @@\n-        var expected = switch (args[0]) {\n-            case \"java.base\" -> istty ? \"java.base\" : \"null\";\n-            default -> args[0];\n-        };\n+        var expected = args[0];\n@@ -65,1 +112,1 @@\n-            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", impl, istty);\n+            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", actual, istty);\n","filename":"test\/jdk\/java\/io\/Console\/ModuleSelectionTest.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set java [lrange $argv 1 1]\n+set stdoutProp [lrange $argv 2 2]\n+set clsname [lrange $argv 3 3]\n+eval spawn $java -classpath $classpath $stdoutProp $clsname\n+expect eof\n+set result [wait]\n+exit [lindex $result 3]\n","filename":"test\/jdk\/java\/io\/Console\/defaultCharset.exp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set java [lrange $argv 1 1]\n+set clsname [lrange $argv 2 2]\n+eval spawn -noecho $java -classpath $classpath $clsname\n+\n+# sends CR 4 times (readLine x 2, readPassword x 2)\n+send \"\\r\"\n+send \"\\r\"\n+send \"\\r\"\n+send \"\\r\"\n+expect eof\n+set result [wait]\n+exit [lindex $result 3]\n","filename":"test\/jdk\/java\/io\/Console\/locale.exp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set expected [lrange $argv 1 1]\n+set java [lrange $argv 2 2]\n+set opts [lrange $argv 3 end]\n+eval spawn $java $opts -classpath $classpath ModuleSelectionTest $expected\n+expect eof\n","filename":"test\/jdk\/java\/io\/Console\/moduleSelection.exp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365203\n+ * @summary Tests guarding of ByteBuffers in ClassLoader::defineClass\n+ * @run junit TestGuardByteBuffer\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.util.HexFormat;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestGuardByteBuffer {\n+\n+    @Test\n+    void guardCrash() {\n+        final byte[] classBytes = getClassBytes(); \/\/ get bytes of a valid class\n+        final var cl = new ClassLoader() {\n+            void tryCrash() {\n+                var arena = Arena.ofConfined();\n+                var byteBuffer = arena.allocate(classBytes.length).asByteBuffer();\n+                \/\/ Close the arena underneath\n+                arena.close();\n+                \/\/ expected to always fail because the arena\n+                \/\/ from which the ByteBuffer was constructed\n+                \/\/ has been closed\n+                assertThrows(IllegalStateException.class,\n+                        () -> defineClass(null, byteBuffer, null));\n+            }\n+        };\n+        for (int i = 0; i < 10_000; i++) {\n+            cl.tryCrash();\n+        }\n+    }\n+\n+    private static byte[] getClassBytes() {\n+        \/\/ unused. this is here just for reference\n+        final String source = \"\"\"\n+                    public class NoOp {}\n+                \"\"\";\n+        \/\/ (externally) compiled content of the above \"source\", represented as hex\n+        final String classBytesHex = \"\"\"\n+                cafebabe00000044000d0a000200030700040c000500060100106a6176612f\n+                6c616e672f4f626a6563740100063c696e69743e0100032829560700080100\n+                044e6f4f70010004436f646501000f4c696e654e756d6265725461626c6501\n+                000a536f7572636546696c650100094e6f4f702e6a61766100210007000200\n+                0000000001000100050006000100090000001d00010001000000052ab70001\n+                b100000001000a000000060001000000010001000b00000002000c\n+                \"\"\";\n+\n+        return HexFormat.of().parseHex(classBytesHex.replaceAll(\"\\n\", \"\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/defineClass\/TestGuardByteBuffer.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n- * @bug 8305457 8342936 8351435 8344706\n+ * @bug 8305457 8342936 8351435 8344706 8361613\n@@ -56,1 +56,0 @@\n- * @modules jdk.internal.le\n@@ -81,16 +80,0 @@\n-        \/*\n-         * Unlike printTest, which tests a _default_ console that is normally\n-         * jdk.internal.org.jline.JdkConsoleProviderImpl, this test tests\n-         * jdk.internal.io.JdkConsoleImpl. Those console implementations operate\n-         * in different conditions and, thus, are tested separately.\n-         *\n-         * To test jdk.internal.io.JdkConsoleImpl one needs to ensure that both\n-         * conditions are met:\n-         *\n-         *   - a non-existent console provider is requested\n-         *   - isatty is true\n-         *\n-         * To achieve isatty, the test currently uses the EXPECT(1) Unix command,\n-         * which does not work for Windows. Later, a library like pty4j or JPty\n-         * might be used instead of EXPECT, to cover both Unix and Windows.\n-         *\/\n@@ -105,2 +88,0 @@\n-                    \"--enable-preview\",\n-                    \"-Djdk.console=gibberish\",\n@@ -133,1 +114,1 @@\n-        public void inputTestInteractive(String console, String prompt) throws Exception {\n+        public void inputTestInteractive(String prompt) throws Exception {\n@@ -141,3 +122,0 @@\n-            command.add(\"--enable-preview\");\n-            if (console != null)\n-                command.add(\"-Djdk.console=\" + console);\n@@ -155,3 +133,2 @@\n-            \/\/ cross product: consoles x prompts\n-            return Stream.of(\"jdk.internal.le\", \"gibberish\").flatMap(console -> Stream.of(null, \"?\", \"%s\", PROMPT_NONE)\n-                    .map(prompt -> new String[]{console, prompt}).map(Arguments::of));\n+            \/\/ prompts\n+            return Stream.of(null, \"?\", \"%s\", PROMPT_NONE).map(Arguments::of);\n@@ -161,21 +138,0 @@\n-    @ParameterizedTest\n-    @ValueSource(strings = {\"println\", \"print\"})\n-    public void printTest(String mode) throws Exception {\n-        var file = Path.of(System.getProperty(\"test.src\", \".\"), \"Output.java\")\n-                .toAbsolutePath().toString();\n-        var pb = ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", \"--enable-preview\", file, mode);\n-        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n-        assertEquals(0, output.getExitValue());\n-        assertTrue(output.getStderr().isEmpty());\n-        output.reportDiagnosticSummary();\n-        String out = output.getStdout();\n-        \/\/ The first half of the output is produced by Console, the second\n-        \/\/ half is produced by IO: those halves must match.\n-        \/\/ Executing Console and IO in the same VM (as opposed to\n-        \/\/ consecutive VM runs, which are cleaner) to be able to compare string\n-        \/\/ representation of objects.\n-        assertFalse(out.isBlank());\n-        assertEquals(out.substring(0, out.length() \/ 2),\n-                out.substring(out.length() \/ 2));\n-    }\n-\n@@ -196,1 +152,1 @@\n-        var pb = ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", \"--enable-preview\", file.toString());\n+        var pb = ProcessTools.createTestJavaProcessBuilder(file.toString());\n","filename":"test\/jdk\/java\/lang\/IO\/IO.java","additions":5,"deletions":49,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.IntStream;\n@@ -80,4 +81,6 @@\n-            ThreadFactory factory = Thread.ofVirtual().factory();\n-            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n-                for (int i = 0; i < 100; i++) {\n-                    executor.submit(() -> { });\n+            try {\n+                List<Thread> threads = IntStream.range(0, 100)\n+                        .mapToObj(_ -> Thread.startVirtualThread(() -> { }))\n+                        .toList();\n+                for (Thread t : threads) {\n+                    t.join();\n@@ -85,1 +88,0 @@\n-                Thread.sleep(1000); \/\/ give time for thread end events to be recorded\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+ * @bug 8366028\n@@ -38,0 +39,2 @@\n+\n+import static org.testng.Assert.assertThrows;\n@@ -221,0 +224,18 @@\n+    @DataProvider(name = \"badMethodDescriptorStrings\")\n+    public String[] badMethodDescriptorStrings() {\n+        return new String[] {\n+                \"(I)\",\n+                \"(V)V\",\n+                \"([V)V\",\n+                \"(\" + \"[\".repeat(256) + \"J)I\",\n+                \"(java\/lang\/Object)V\",\n+                \"()java\/lang\/Object\",\n+        };\n+    }\n+\n+    \/\/ JDK-8366028\n+    @Test(dataProvider = \"badMethodDescriptorStrings\", expectedExceptions = IllegalArgumentException.class)\n+    public void testFromMethodDescriptorStringNegatives(String desc) {\n+        MethodType.fromMethodDescriptorString(desc, null);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodTypeTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @key intermittent\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -32,1 +32,1 @@\n-\/**\n+\/*\n@@ -40,1 +40,1 @@\n-\/**\n+\/*\n@@ -65,0 +65,1 @@\n+import java.util.concurrent.locks.LockSupport;\n@@ -164,0 +165,16 @@\n+    \/**\n+     * SocketChannel shutdownInput while virtual thread blocked in read.\n+     *\/\n+    @Test\n+    void testSocketChannelReadAsyncShutdownInput() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (var connection = new Connection()) {\n+                SocketChannel sc = connection.channel1();\n+                runAfterParkedAsync(sc::shutdownInput);\n+                int n = sc.read(ByteBuffer.allocate(100));\n+                assertEquals(-1, n);\n+                assertTrue(sc.isOpen());\n+            }\n+        });\n+    }\n+\n@@ -193,2 +210,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -199,1 +216,3 @@\n-                    runAfterParkedAsync(sc::close);\n+                    runAfterParkedAsync(sc::close, true);\n+\n+                    \/\/ write until channel is closed\n@@ -209,1 +228,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -211,1 +230,26 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+\n+    \/**\n+     * SocketChannel shutdownOutput while virtual thread blocked in write.\n+     *\/\n+    @Test\n+    void testSocketChannelWriteAsyncShutdownOutput() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (var connection = new Connection()) {\n+                SocketChannel sc = connection.channel1();\n+\n+                \/\/ shutdown output when current thread blocks in write\n+                runAfterParkedAsync(sc::shutdownOutput);\n+                try {\n+                    ByteBuffer bb = ByteBuffer.allocate(100*1024);\n+                    for (;;) {\n+                        int n = sc.write(bb);\n+                        assertTrue(n > 0);\n+                        bb.clear();\n@@ -213,0 +257,2 @@\n+                } catch (ClosedChannelException e) {\n+                    \/\/ expected\n@@ -214,0 +260,1 @@\n+                assertTrue(sc.isOpen());\n@@ -224,2 +271,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -231,1 +278,1 @@\n-                    runAfterParkedAsync(thisThread::interrupt);\n+                    runAfterParkedAsync(thisThread::interrupt, true);\n@@ -233,0 +280,1 @@\n+                    \/\/ write until channel is closed\n@@ -243,1 +291,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -245,1 +293,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -737,2 +786,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -744,1 +793,3 @@\n-                    runAfterParkedAsync(sink::close);\n+                    runAfterParkedAsync(sink::close, true);\n+\n+                    \/\/ write until channel is closed\n@@ -754,1 +805,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -756,1 +807,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -769,2 +821,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -777,1 +829,1 @@\n-                    runAfterParkedAsync(thisThread::interrupt);\n+                    runAfterParkedAsync(thisThread::interrupt, true);\n@@ -779,0 +831,1 @@\n+                    \/\/ write until channel is closed\n@@ -789,1 +842,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -791,1 +844,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -851,1 +905,2 @@\n-     * Runs the given task asynchronously after the current virtual thread has parked.\n+     * Runs the given task asynchronously after the current virtual thread parks.\n+     * @param writing if the thread will block in write\n@@ -854,1 +909,1 @@\n-    static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+    private static Thread runAfterParkedAsync(ThrowingRunnable task, boolean writing) {\n@@ -860,3 +915,2 @@\n-                Thread.State state = target.getState();\n-                while (state != Thread.State.WAITING\n-                        && state != Thread.State.TIMED_WAITING) {\n+                \/\/ wait for target thread to park\n+                while (!isWaiting(target)) {\n@@ -864,1 +918,0 @@\n-                    state = target.getState();\n@@ -866,1 +919,12 @@\n-                Thread.sleep(20);  \/\/ give a bit more time to release carrier\n+\n+                \/\/ if the target thread is parked in write then we nudge it a few times\n+                \/\/ to avoid wakeup with some bytes written\n+                if (writing) {\n+                    for (int i = 0; i < 3; i++) {\n+                        LockSupport.unpark(target);\n+                        while (!isWaiting(target)) {\n+                            Thread.sleep(20);\n+                        }\n+                    }\n+                }\n+\n@@ -868,0 +932,1 @@\n+\n@@ -873,0 +938,13 @@\n+\n+    private static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+        return runAfterParkedAsync(task, false);\n+    }\n+\n+    \/**\n+     * Return true if the given Thread is parked.\n+     *\/\n+    private static boolean isWaiting(Thread target) {\n+        Thread.State state = target.getState();\n+        assertNotEquals(Thread.State.TERMINATED, state);\n+        return (state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING);\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":109,"deletions":31,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -0,0 +1,456 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8154364\n+ * @summary Test of Files.isSameFile\n+ * @requires (os.family != \"windows\")\n+ * @library .. \/test\/lib\n+ * @build IsSameFile jdk.test.lib.util.FileUtils\n+ * @run junit IsSameFile\n+ *\/\n+import java.io.IOException;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystemException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+public class IsSameFile {\n+    private Path home;\n+    private Path a;\n+    private Path aa;\n+    private Path b;\n+    private Path c;\n+    private List<Path> allFiles;\n+\n+    @BeforeAll\n+    public void init() throws IOException {\n+        home = Files.createTempDirectory(\"TestIsSameFile\");\n+\n+        allFiles = new ArrayList();\n+        allFiles.add(a = home.resolve(\"a\"));\n+        allFiles.add(aa = home.resolve(\"a\"));\n+        allFiles.add(b = home.resolve(\"b\"));\n+        allFiles.add(c = home.resolve(\"c\"));\n+    }\n+\n+    public void deleteFiles() throws IOException {\n+        for (Path p : allFiles)\n+            Files.deleteIfExists(p);\n+    }\n+\n+    @AfterAll\n+    public void deleteHome() throws IOException {\n+        TestUtil.removeAll(home);\n+    }\n+\n+    public void test(boolean expect, Path x, Path y) throws IOException {\n+        assertTrue(Files.isSameFile(x, y) == expect);\n+    }\n+\n+    private Stream<Arguments> stringCompareSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        Path x = Path.of(\"x\/y\/z\");\n+        list.add(Arguments.of(true, x, x));\n+        list.add(Arguments.of(false, Path.of(\"w\/x\/y\/z\"), x));\n+        Path y = Path.of(\"v\/w\/x\/..\/y\/z\");\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/y\/z\")));\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/x\/y\/..\/z\")));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"stringCompareSource\")\n+    public void stringCompare(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> noneExistSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        return list.stream();\n+    }\n+\n+    @Test\n+    public void obj2Null() {\n+        Path x = Path.of(\"x\/y\");\n+        assertThrows(NullPointerException.class, () -> Files.isSameFile(x, null));\n+    }\n+\n+    private static void zipStringToFile(String entry, String content,\n+                                        Path path)\n+        throws IOException\n+    {\n+        FileOutputStream fos = new FileOutputStream(path.toString());\n+        ZipOutputStream zos = new ZipOutputStream(fos);\n+\n+        ZipEntry zipEntry = new ZipEntry(entry);\n+        zos.putNextEntry(zipEntry);\n+        zos.write(content.getBytes());\n+\n+        zos.close();\n+        fos.close();\n+    }\n+\n+    private Stream<Arguments> obj2ZipSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        zipStringToFile(\"quote.txt\", \"To be determined\", b);\n+        FileSystem zipfs = FileSystems.newFileSystem(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, zipfs.getPath(b.toString())));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"obj2ZipSource\")\n+    public void obj2Zip(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"noneExistSource\")\n+    public void noneExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> aExistsSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"aExistsSource\")\n+    public void aExists(boolean expect, Path x, Path y) throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abExistSource\")\n+    public void abExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, c));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abcExistSource\")\n+    public void abcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> bcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"bcExistSource\")\n+    public void bcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => target\n+    \/\/\n+    private Stream<Arguments> equalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, target);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalFollowingSource\")\n+    public void equalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => cible\n+    \/\/\n+    private Stream<Arguments> unequalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path cible = home.resolve(\"cible\");\n+        Files.createFile(cible);\n+        allFiles.add(cible);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, cible);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalFollowingSource\")\n+    public void unequalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => <does not exist>\n+    \/\/ L3 => L4 => <does not exist>\n+    \/\/\n+    private Stream<Arguments> unequalNotFollowingSource() throws IOException {\n+        deleteFiles();\n+\n+        Path doesNotExist = Path.of(\"doesNotExist\");\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, doesNotExist);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, doesNotExist);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalNotFollowingSource\")\n+    public void unequalNotFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => target\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(true, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkSource\")\n+    public void multiLink(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => <does not exist>\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkNoTargetSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        Files.delete(target);\n+        allFiles.remove(target);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(false, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkNoTargetSource\")\n+    public void multiLinkNoTarget(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 -> L2 -> L3 -> L1...\n+    \/\/\n+    \/\/ This is a loop and should throw FileSystemException.\n+    \/\/\n+    private Stream<Arguments> linkLoopSource() throws IOException {\n+        deleteFiles();\n+\n+        Path link1 = home.resolve(\"L1\");\n+        Path link2 = home.resolve(\"L2\");\n+        Path link3 = home.resolve(\"L3\");\n+        allFiles.add(Files.createSymbolicLink(link1, link2));\n+        allFiles.add(Files.createSymbolicLink(link2, link3));\n+        allFiles.add(Files.createSymbolicLink(link3, link1));\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, link1, link2));\n+        list.add(Arguments.of(true, link2, link3));\n+        list.add(Arguments.of(true, link3, link1));\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"linkLoopSource\")\n+    public void linkLoop(boolean expect, Path x, Path y) throws IOException {\n+        assertThrows(FileSystemException.class, () -> Files.isSameFile(x, y));\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":456,"deletions":0,"binary":false,"changes":456,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 8005566 8215467 8255576 8286160\n+ * @bug 4313887 6838333 8005566 8154364 8215467 8255576 8286160\n@@ -116,1 +116,1 @@\n-         * Test: Neither files exist\n+         * Test: Neither file exists\n@@ -118,10 +118,2 @@\n-        try {\n-            isSameFile(thisFile, thatFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n-        try {\n-            isSameFile(thatFile, thisFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n+        assertTrue(!isSameFile(thisFile, thatFile));\n+        assertTrue(!isSameFile(thatFile, thisFile));\n@@ -134,10 +126,2 @@\n-            try {\n-                isSameFile(thisFile, thatFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n-            try {\n-                isSameFile(thatFile, thisFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n+            assertTrue(!isSameFile(thisFile, thatFile));\n+            assertTrue(!isSameFile(thatFile, thisFile));\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Misc.java","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690 8363972\n@@ -465,0 +465,2 @@\n+                \/\/ lenient parsing. Hyphen-minus should match the localized minus sign\n+                {FORMAT_SE_SHORT, \"-8\\u00a0mn\", -8000000L, Long.class},\n@@ -506,2 +508,1 @@\n-            \/\/ Localized minus sign should be used\n-            {FORMAT_SE_SHORT, \"-8\\u00a0mn\", null},};\n+        };\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8363972\n+ * @summary Unit tests for lenient minus parsing\n+ * @modules jdk.localedata\n+ *          java.base\/java.text:+open\n+ * @run junit LenientMinusSignTest\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class LenientMinusSignTest {\n+    private static final Locale FINNISH = Locale.of(\"fi\");\n+    private static final DecimalFormatSymbols DFS =\n+        new DecimalFormatSymbols(Locale.ROOT);\n+    private static final String MINUS_PATTERN = \"\\u002D\";\n+\n+    \/\/ \"parseLenient\" data from CLDR v47. These data are subject to change\n+    private static Stream<String> minus() {\n+        return Stream.of(\n+            MINUS_PATTERN,     \/\/ \"-\" Hyphen-Minus\n+            \"\\uFF0D\",          \/\/ \"－\" Fullwidth Hyphen-Minus\n+            \"\\uFE63\",          \/\/ \"﹣\" Small Hyphen-Minus\n+            \"\\u2010\",          \/\/ \"‐\" Hyphen\n+            \"\\u2011\",          \/\/ \"‑\" Non-Breaking Hyphen\n+            \"\\u2012\",          \/\/ \"‒\" Figure Dash\n+            \"\\u2013\",          \/\/ \"–\" En Dash\n+            \"\\u2212\",          \/\/ \"−\" Minus Sign\n+            \"\\u207B\",          \/\/ \"⁻\" Superscript Minus\n+            \"\\u208B\",          \/\/ \"₋\" Subscript Minus\n+            \"\\u2796\"           \/\/ \"➖\" Heavy Minus Sign\n+        );\n+    }\n+\n+    @Test\n+    void testFinnishMinus() throws ParseException {\n+        \/\/ originally reported in JDK-8189097\n+        \/\/ Should not throw a ParseException\n+        assertEquals(NumberFormat.getInstance(FINNISH).parse(MINUS_PATTERN + \"1,5\"), -1.5);\n+    }\n+\n+    @Test\n+    void testFinnishMinusStrict() {\n+        \/\/ Should throw a ParseException\n+        var nf = NumberFormat.getInstance(FINNISH);\n+        nf.setStrict(true);\n+        assertThrows(ParseException.class, () -> nf.parse(MINUS_PATTERN + \"1,5\"));\n+    }\n+\n+    @Test\n+    void testReadObject() throws IOException, ClassNotFoundException, ParseException {\n+        \/\/ check if deserialized NF works with lenient minus. Using the Finnish example\n+        var nf = NumberFormat.getInstance(FINNISH);\n+        NumberFormat nfDeser;\n+        byte[] serialized;\n+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(bos)) {\n+            out.writeObject(nf);\n+            out.flush();\n+            serialized = bos.toByteArray();\n+        }\n+        try (ByteArrayInputStream bis = new ByteArrayInputStream(serialized);\n+             ObjectInputStream in = new ObjectInputStream(bis)) {\n+            nfDeser = (NumberFormat) in.readObject();\n+        }\n+        assertEquals(nfDeser.parse(MINUS_PATTERN + \"1,5\"), -1.5);\n+    }\n+\n+    \/\/ White box test. modifies the private `lenientMinusSigns` field in the DFS\n+    @Test\n+    void testSupplementary() throws IllegalAccessException, NoSuchFieldException, ParseException {\n+        var dfs = new DecimalFormatSymbols(Locale.ROOT);\n+        MethodHandles.privateLookupIn(DecimalFormatSymbols.class, MethodHandles.lookup())\n+            .findVarHandle(DecimalFormatSymbols.class, \"lenientMinusSigns\", String.class)\n+            .set(dfs, \"-🙂\");\n+        \/\/ Direct match. Should succeed\n+        var df = new DecimalFormat(\"#.#;🙂#.#\", dfs);\n+        assertEquals(df.parse(\"🙂1.5\"), -1.5);\n+\n+        \/\/ Fail if the lengths of negative prefixes differ\n+        assertThrows(ParseException.class, () -> df.parse(\"-1.5\"));\n+        var df2= new DecimalFormat(\"#.#;-#.#\", dfs);\n+        assertThrows(ParseException.class, () -> df2.parse(\"🙂1.5\"));\n+    }\n+\n+    @Nested\n+    class DecimalFormatTest {\n+        private static final String PREFIX = \"+#;-#\";\n+        private static final String SUFFIX = \"#+;#-\";\n+        private static final String LONG_PREFIX = \"pos#;-neg#\";\n+        private static final String LONG_SUFFIX = \"#pos;#neg-\";\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(PREFIX, DFS);\n+            df.setStrict(false);\n+            assertEquals(MINUS_PATTERN + \"1\", df.format(df.parse(sign + \"1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(SUFFIX, DFS);\n+            df.setStrict(false);\n+            assertEquals(\"1\" + MINUS_PATTERN, df.format(df.parse(\"1\" + sign)));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(PREFIX, DFS);\n+            df.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(MINUS_PATTERN + \"1\", df.format(df.parse(sign + \"1\")));\n+            } else {\n+                assertThrows(ParseException.class, () -> df.parse(sign + \"1\"));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(SUFFIX, DFS);\n+            df.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(\"1\" + MINUS_PATTERN, df.format(df.parse(\"1\" + sign)));\n+            } else {\n+                assertThrows(ParseException.class, () -> df.parse(\"1\" + sign));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(LONG_PREFIX, DFS);\n+            assertEquals(MINUS_PATTERN + \"neg1\", df.format(df.parse(sign + \"neg1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(LONG_SUFFIX, DFS);\n+            assertEquals(\"1neg\" + MINUS_PATTERN, df.format(df.parse(\"1neg\" + sign)));\n+        }\n+    }\n+\n+    @Nested\n+    class CompactNumberFormatTest {\n+        private static final String[] PREFIX = {\"+0;-0\"};\n+        private static final String[] SUFFIX = {\"0+;0-\"};\n+        private static final String[] LONG_PREFIX = {\"pos0;-neg0\"};\n+        private static final String[] LONG_SUFFIX = {\"0pos;0neg-\"};\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, PREFIX);\n+            cnf.setStrict(false);\n+            assertEquals(MINUS_PATTERN + \"1\", cnf.format(cnf.parse(sign + \"1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, SUFFIX);\n+            cnf.setStrict(false);\n+            assertEquals(\"1\" + MINUS_PATTERN, cnf.format(cnf.parse(\"1\" + sign)));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, PREFIX);\n+            cnf.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(MINUS_PATTERN + \"1\", cnf.format(cnf.parse(sign + \"1\")));\n+            } else {\n+                assertThrows(ParseException.class, () -> cnf.parse(sign + \"1\"));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, SUFFIX);\n+            cnf.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(\"1\" + MINUS_PATTERN, cnf.format(cnf.parse(\"1\" + sign)));\n+            } else {\n+                assertThrows(ParseException.class, () -> cnf.parse(\"1\" + sign));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, LONG_PREFIX);\n+            assertEquals(MINUS_PATTERN + \"neg1\", cnf.format(cnf.parse(sign + \"neg1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, LONG_SUFFIX);\n+            assertEquals(\"1neg\" + MINUS_PATTERN, cnf.format(cnf.parse( \"1neg\" + sign)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientMinusSignTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,3 @@\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeParseException;\n@@ -73,1 +76,1 @@\n- * @bug 8273369 8331202\n+ * @bug 8273369 8331202 8364752\n@@ -154,0 +157,54 @@\n+\n+    @DataProvider\n+    private Object[][] valid_instants() {\n+        var I1 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"+02\")).toInstant();\n+        var I2 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"+02:02\")).toInstant();\n+        var I3 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"+02:02:02\")).toInstant();\n+        var I4 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"Z\")).toInstant();\n+        return new Object[][] {\n+            {\"2017-01-01T00:00:00.000+02\", I1},\n+            {\"2017-01-01T00:00:00.000+0200\", I1},\n+            {\"2017-01-01T00:00:00.000+02:00\", I1},\n+            {\"2017-01-01T00:00:00.000+020000\", I1},\n+            {\"2017-01-01T00:00:00.000+02:00:00\", I1},\n+\n+            {\"2017-01-01T00:00:00.000+0202\", I2},\n+            {\"2017-01-01T00:00:00.000+02:02\", I2},\n+\n+            {\"2017-01-01T00:00:00.000+020202\", I3},\n+            {\"2017-01-01T00:00:00.000+02:02:02\", I3},\n+\n+            {\"2017-01-01T00:00:00.000Z\", I4},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"valid_instants\")\n+    public void test_parse_valid(String instant, Instant expected) {\n+        assertEquals(Instant.parse(instant), expected);\n+    }\n+\n+    @DataProvider\n+    private Object[][] invalid_instants() {\n+        return new Object[][] {\n+            {\"2017-01-01T00:00:00.000\"},\n+            {\"2017-01-01T00:00:00.000+0\"},\n+            {\"2017-01-01T00:00:00.000+0:\"},\n+            {\"2017-01-01T00:00:00.000+02:\"},\n+            {\"2017-01-01T00:00:00.000+020\"},\n+            {\"2017-01-01T00:00:00.000+02:0\"},\n+            {\"2017-01-01T00:00:00.000+02:0:\"},\n+            {\"2017-01-01T00:00:00.000+02:00:\"},\n+            {\"2017-01-01T00:00:00.000+02:000\"},\n+            {\"2017-01-01T00:00:00.000+02:00:0\"},\n+            {\"2017-01-01T00:00:00.000+02:00:0:\"},\n+            {\"2017-01-01T00:00:00.000+0200000\"},\n+            {\"2017-01-01T00:00:00.000+02:00:000\"},\n+            {\"2017-01-01T00:00:00.000+02:00:00:\"},\n+            {\"2017-01-01T00:00:00.000UTC\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalid_instants\")\n+    public void test_parse_invalid(String instant) {\n+        assertThrows(DateTimeParseException.class, () -> Instant.parse(instant));\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstant.java","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4421190\n- * @summary Tests that Image I\/O statics may be referenced properly from\n- *          multiple AppContexts, as would be the case for multiple Applets in a\n- *          single VM. Each AppContext should get its own copy of the registry\n- *          and the caching parameters in the ImageIO class.\n- * @modules java.desktop\/sun.awt\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-import javax.imageio.ImageIO;\n-import javax.imageio.spi.IIORegistry;\n-\n-import sun.awt.SunToolkit;\n-\n-class TestThread extends Thread {\n-\n-    IIORegistry registry;\n-    boolean useCache;\n-    File cacheDirectory;\n-    boolean cacheSettingsOK = false;\n-    String threadName;\n-\n-    boolean gotCrosstalk = false;\n-\n-    public TestThread(ThreadGroup tg,\n-                      boolean useCache, File cacheDirectory,\n-                      String threadName) {\n-        super(tg, threadName);\n-        this.useCache = useCache;\n-        this.cacheDirectory = cacheDirectory;\n-        this.threadName = threadName;\n-    }\n-\n-    public void run() {\n-\/\/          System.out.println(\"Thread \" + threadName + \" in thread group \" +\n-\/\/                             getThreadGroup().getName());\n-\n-        \/\/ Create a new AppContext as though we were an applet\n-        SunToolkit.createNewAppContext();\n-\n-        \/\/ Get default registry and store reference\n-        this.registry = IIORegistry.getDefaultInstance();\n-\n-        for (int i = 0; i < 10; i++) {\n-\/\/              System.out.println(threadName +\n-\/\/                                 \": setting cache parameters to \" +\n-\/\/                                 useCache + \", \" + cacheDirectory);\n-            ImageIO.setUseCache(useCache);\n-            ImageIO.setCacheDirectory(cacheDirectory);\n-\n-            try {\n-                sleep(1000L);\n-            } catch (InterruptedException e) {\n-            }\n-\n-\/\/              System.out.println(threadName + \": reading cache parameters\");\n-            boolean newUseCache = ImageIO.getUseCache();\n-            File newCacheDirectory = ImageIO.getCacheDirectory();\n-            if (newUseCache != useCache ||\n-                newCacheDirectory != cacheDirectory) {\n-\/\/                  System.out.println(threadName + \": got \" +\n-\/\/                                     newUseCache + \", \" +\n-\/\/                                     newCacheDirectory);\n-\/\/                  System.out.println(threadName + \": crosstalk encountered!\");\n-                gotCrosstalk = true;\n-            }\n-        }\n-    }\n-\n-    public IIORegistry getRegistry() {\n-        return registry;\n-    }\n-\n-    public boolean gotCrosstalk() {\n-        return gotCrosstalk;\n-    }\n-}\n-\n-public class AppContextTest {\n-\n-    public AppContextTest() {\n-        ThreadGroup tg0 = new ThreadGroup(\"ThreadGroup0\");\n-        ThreadGroup tg1 = new ThreadGroup(\"ThreadGroup1\");\n-\n-        TestThread t0 =\n-            new TestThread(tg0, false, null, \"TestThread 0\");\n-        TestThread t1 =\n-            new TestThread(tg1, true, new File(\".\"), \"TestThread 1\");\n-\n-        t0.start();\n-        t1.start();\n-\n-        try {\n-            t0.join();\n-        } catch (InterruptedException ie0) {\n-        }\n-        try {\n-            t1.join();\n-        } catch (InterruptedException ie1) {\n-        }\n-\n-        if (t0.gotCrosstalk() || t1.gotCrosstalk()) {\n-            throw new RuntimeException(\"ImageIO methods had crosstalk!\");\n-        }\n-\n-        if (t0.getRegistry() == t1.getRegistry()) {\n-            throw new RuntimeException(\"ThreadGroups had same IIORegistry!\");\n-        }\n-    }\n-\n-    public static void main(String[] args) throws IOException {\n-        new AppContextTest();\n-    }\n-}\n","filename":"test\/jdk\/javax\/imageio\/AppContextTest.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8364768\n+ * @summary Tests that the standard plugins flush the stream after writing a complete image.\n+ *\/\n+\n+import static java.awt.Color.WHITE;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.io.ByteArrayOutputStream;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.FileCacheImageOutputStream;\n+\n+public class FlushTest {\n+\n+    static final int SZ = 1000;\n+    static BufferedImage bi;\n+    static final String[] FORMATS = { \"jpg\", \"png\", \"gif\", \"tiff\", \"bmp\", \"wbmp\" } ;\n+    static boolean failed = false;\n+\n+    public static void main(String[] args) throws IOException {\n+\n+        bi = new BufferedImage(SZ, SZ, BufferedImage.TYPE_BYTE_BINARY);\n+        Graphics2D g2d = bi.createGraphics();\n+        g2d.setPaint(WHITE);\n+        g2d.fillRect(0, 0, SZ, SZ);\n+\n+        for (String f : FORMATS) {\n+            testWrite(f);\n+        }\n+        if (failed) {\n+           throw new RuntimeException(\"Stream sizes differ.\");\n+        }\n+    }\n+\n+    static void testWrite(String fmt) throws IOException {\n+        ImageWriter iw = ImageIO.getImageWritersBySuffix(fmt).next();\n+        System.out.println(iw);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        FileCacheImageOutputStream fcs = new FileCacheImageOutputStream(baos, null);\n+        iw.setOutput(fcs);\n+        iw.write(bi);\n+        int sz0 = baos.size();\n+        fcs.close();\n+        int sz1 = baos.size();\n+        System.out.println(\"fmt=\" + fmt + \" sizes=\" + sz0 + \", \" + sz1);\n+        if (sz0 != sz1) {\n+           failed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/FlushTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8159055\n+ * @summary Verifies null parameter and invalid data handling of\n+ *          ImageIcon constructors and setImage method\n+ * @run main ImageIconTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Random;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import javax.swing.ImageIcon;\n+\n+public class ImageIconTest {\n+\n+    static enum ArgType { FILE, URL, BYTE_ARRAY, IMAGE, SET_IMAGE };\n+    static enum ArgVal { NULL, INVALID_DATA };\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        String imgName = \"invalid.gif\";\n+        byte[] invalidData = new byte[100];\n+        new Random().nextBytes(invalidData);\n+        try (FileOutputStream fos = new FileOutputStream(imgName)) {\n+            fos.write(invalidData);\n+        }\n+        File file = new File(imgName);\n+        file.deleteOnExit();\n+\n+        for (ArgType a : ArgType.values()) {\n+            for (final ArgVal v : ArgVal.values()) {\n+                System.out.println(\"Testing for ArgType \" + a + \" for case \" + v);\n+                boolean expected = true;\n+                boolean passed = false;\n+                try {\n+                    switch (a) {\n+\n+                       case FILE :\n+\n+                           expected = false;\n+                           String s = (v == ArgVal.NULL) ? null : imgName;\n+                           new ImageIcon(s);\n+                           passed = true; \/\/ no exception expected for this case\n+                           break;\n+\n+                       case URL :\n+\n+                           if (v == ArgVal.NULL) {\n+\n+                               new ImageIcon((URL)null);\n+\n+                           } else if (v == ArgVal.INVALID_DATA) {\n+                               expected = false;\n+                               new ImageIcon(new URI(\"file:\/\/\" + imgName).toURL());\n+                               passed = true; \/\/ no exception expected for this case\n+\n+                           }\n+                           break;\n+\n+                       case BYTE_ARRAY :\n+\n+                           if (v == ArgVal.NULL) {\n+\n+                               byte[] bytes = null;\n+                               new ImageIcon(bytes);\n+\n+                           } else if (v == ArgVal.INVALID_DATA) {\n+                               expected = false;\n+\n+                               new ImageIcon(invalidData);\n+\n+                               passed = true; \/\/ no exception expected for this case\n+                           }\n+                           break;\n+\n+                       case IMAGE :\n+\n+                           if (v == ArgVal.NULL) {\n+\n+                               new ImageIcon((Image)null);\n+\n+                           } else if (v == ArgVal.INVALID_DATA) {\n+                               expected = false;\n+\n+                               new ImageIcon((Image)Toolkit.getDefaultToolkit().createImage(imgName));\n+\n+                               passed = true; \/\/ no exception expected for this case\n+                           }\n+                           break;\n+\n+                        case SET_IMAGE :\n+\n+                            ImageIcon ii = new ImageIcon();\n+\n+                            if (v == ArgVal.NULL) {\n+\n+                                ii.setImage((Image) null);\n+\n+                            } else if (v == ArgVal.INVALID_DATA) {\n+                                expected = false;\n+\n+                                ii.setImage((Image)Toolkit.getDefaultToolkit().createImage(imgName));\n+\n+                                passed = true; \/\/ no exception expected for this case\n+                            }\n+                            break;\n+                    }\n+                } catch (NullPointerException e) {\n+                    if (expected) {\n+                        passed = true;\n+                    }\n+                }\n+                if (expected && !passed) {\n+                   throw new RuntimeException(\"Did not receive expected exception for : \" + a);\n+                }\n+                if (!expected && !passed) {\n+                   throw new RuntimeException(\"Received unexpected exception for : \" + a);\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/ImageIcon\/ImageIconTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.io.File;\n@@ -31,0 +32,1 @@\n+import javax.imageio.ImageIO;\n@@ -54,0 +56,1 @@\n+    private static final int tolerance = 10;\n@@ -72,0 +75,1 @@\n+            Color testColor = new Color(testRGB);\n@@ -75,1 +79,9 @@\n-                if (rgbCW != testRGB || rgbCH != testRGB) {\n+                Color rgbCWColor = new Color(rgbCW);\n+                Color rgbCHColor = new Color(rgbCH);\n+\n+                if (Math.abs(rgbCWColor.getRed() - testColor.getRed()) > tolerance\n+                    || Math.abs(rgbCWColor.getGreen() - testColor.getGreen()) > tolerance\n+                    || Math.abs(rgbCWColor.getBlue() - testColor.getBlue()) > tolerance\n+                    || Math.abs(rgbCHColor.getRed() - testColor.getRed()) > tolerance\n+                    || Math.abs(rgbCHColor.getGreen() - testColor.getGreen()) > tolerance\n+                    || Math.abs(rgbCHColor.getBlue() - testColor.getBlue()) > tolerance) {\n@@ -80,0 +92,1 @@\n+                    ImageIO.write(img, \"png\", new File(\"JInternalFrameDraggingTest.png\"));\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/8160248\/JInternalFrameDraggingTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8331535 8351435 8347050\n+ * @bug 8331535 8351435 8347050 8361613\n@@ -28,1 +28,2 @@\n- * @modules jdk.internal.le\n+ * @modules java.base\/jdk.internal.io\n+ *          jdk.internal.le\/jdk.internal.org.jline\n@@ -30,1 +31,1 @@\n- * @run main\/othervm -Djdk.console=jdk.internal.le JLineConsoleProviderTest\n+ * @run main JLineConsoleProviderTest\n@@ -34,0 +35,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -36,0 +38,1 @@\n+import jdk.internal.org.jline.JdkConsoleProviderImpl;\n@@ -69,2 +72,7 @@\n-                ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName(),\n-                                                          testName);\n+                ProcessTools.createTestJavaProcessBuilder(\n+                    \"--add-exports\",\n+                    \"java.base\/jdk.internal.io=ALL-UNNAMED\",\n+                    \"--add-exports\",\n+                    \"jdk.internal.le\/jdk.internal.org.jline=ALL-UNNAMED\",\n+                    ConsoleTest.class.getName(),\n+                    testName);\n@@ -101,0 +109,2 @@\n+            \/\/ directly instantiate JLine JdkConsole, simulating isTTY=true\n+            var impl = new JdkConsoleProviderImpl().console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8);\n@@ -103,1 +113,1 @@\n-                    System.console().readLine(\"%%s\");\n+                    impl.readLine(null, \"%%s\");\n@@ -105,1 +115,1 @@\n-                    System.console().readPassword(\"%%s\");\n+                    impl.readPassword(null, \"%%s\");\n@@ -107,1 +117,1 @@\n-                    System.out.println(\"'\" + System.console().readLine() + \"'\");\n+                    System.out.println(\"'\" + impl.readLine() + \"'\");\n@@ -109,2 +119,2 @@\n-                    System.out.println(\"1: '\" +System.console().readLine() + \"'\");\n-                    System.out.println(\"2: '\" + System.console().readLine() + \"'\");\n+                    System.out.println(\"1: '\" + impl.readLine() + \"'\");\n+                    System.out.println(\"2: '\" + impl.readLine() + \"'\");\n","filename":"test\/jdk\/jdk\/internal\/jline\/JLineConsoleProviderTest.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8333086 8344706\n+ * @bug 8333086 8344706 8361613\n@@ -28,2 +28,3 @@\n- * @enablePreview\n- * @modules jdk.internal.le\/jdk.internal.org.jline.reader\n+ * @modules java.base\/jdk.internal.io\n+ *          jdk.internal.le\/jdk.internal.org.jline\n+ *          jdk.internal.le\/jdk.internal.org.jline.reader\n@@ -35,0 +36,3 @@\n+import java.nio.charset.StandardCharsets;\n+\n+import jdk.internal.org.jline.JdkConsoleProviderImpl;\n@@ -44,0 +48,1 @@\n+        \/\/ directly instantiate JLine JdkConsole, simulating isTTY=true\n@@ -46,10 +51,5 @@\n-                System.console().printf(\"Hello!\\n\");\n-                System.console().printf(\"Hello!\");\n-                System.console().format(\"\\nHello!\\n\");\n-                System.console().flush();\n-                IO.println(\"Hello!\");\n-                IO.print(\"Hello!\");\n-            }\n-            case \"read\" -> System.console().readLine(\"Hello!\");\n-            case \"IO-read\" -> {\n-                IO.readln(\"Hello!\");\n+                var impl = new JdkConsoleProviderImpl().console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8);\n+                impl.println(\"Hello!\\n\");\n+                impl.println(\"Hello!\");\n+                impl.format(null, \"\\nHello!\\n\");\n+                impl.flush();\n@@ -57,0 +57,3 @@\n+            case \"read\" -> new JdkConsoleProviderImpl()\n+                .console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8)\n+                .readLine(null, \"Hello!\");\n@@ -67,2 +70,1 @@\n-            new TestCase(\"read\", LineReader.class.getName(), null),\n-            new TestCase(\"IO-read\", null, Terminal.class.getName())\n+            new TestCase(\"read\", LineReader.class.getName(), null)\n@@ -72,3 +74,5 @@\n-                    ProcessTools.createTestJavaProcessBuilder(\"--enable-preview\",\n-                                                              \"-verbose:class\",\n-                                                              \"-Djdk.console=jdk.internal.le\",\n+                    ProcessTools.createTestJavaProcessBuilder(\"-verbose:class\",\n+                                                              \"--add-exports\",\n+                                                              \"java.base\/jdk.internal.io=ALL-UNNAMED\",\n+                                                              \"--add-exports\",\n+                                                              \"jdk.internal.le\/jdk.internal.org.jline=ALL-UNNAMED\",\n","filename":"test\/jdk\/jdk\/internal\/jline\/LazyJdkConsoleProvider.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8330998 8351435\n- * @summary Verify that even if the stdout is redirected java.io.Console will\n- *          use it for writing.\n- * @modules jdk.internal.le\n- * @library \/test\/lib\n- * @run main RedirectedStdOut runRedirectAllTest\n- * @run main\/othervm --enable-native-access=ALL-UNNAMED RedirectedStdOut runRedirectOutOnly\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class RedirectedStdOut {\n-    private static final String OUTPUT = \"Hello!\";\n-\n-    public static void main(String... args) throws Throwable {\n-        RedirectedStdOut.class.getDeclaredMethod(args[0])\n-                              .invoke(new RedirectedStdOut());\n-    }\n-\n-    \/\/verify the case where neither stdin\/out\/err is attached to a terminal,\n-    \/\/this test is weaker, but more reliable:\n-    void runRedirectAllTest() throws Exception {\n-        ProcessBuilder builder =\n-                ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName());\n-        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n-\n-        output.waitFor();\n-\n-        if (output.getExitValue() != 0) {\n-            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n-                                     \", actualOut: \" + output.getStdout() +\n-                                     \", actualErr: \" + output.getStderr());\n-        }\n-\n-        String expectedOut = OUTPUT;\n-        String actualOut = output.getStdout();\n-\n-        if (!Objects.equals(expectedOut, actualOut)) {\n-            throw new AssertionError(\"Unexpected stdout content. \" +\n-                                     \"Expected: '\" + expectedOut + \"'\" +\n-                                     \", got: '\" + actualOut + \"'\");\n-        }\n-\n-        String expectedErr = \"\";\n-        String actualErr = output.getStderr();\n-\n-        if (!Objects.equals(expectedErr, actualErr)) {\n-            throw new AssertionError(\"Unexpected stderr content. \" +\n-                                     \"Expected: '\" + expectedErr + \"'\" +\n-                                     \", got: '\" + actualErr + \"'\");\n-        }\n-    }\n-\n-    \/\/verify the case where stdin is attached to a terminal,\n-    \/\/this test allocates pty, and it might be skipped, if the appropriate\n-    \/\/native functions cannot be found\n-    \/\/it also leaves the VM in a broken state (with a pty attached), and so\n-    \/\/should run in a separate VM instance\n-    void runRedirectOutOnly() throws Throwable {\n-        Path stdout = Path.of(\".\", \"stdout.txt\").toAbsolutePath();\n-\n-        Files.deleteIfExists(stdout);\n-\n-        Linker linker = Linker.nativeLinker();\n-        SymbolLookup stdlib = linker.defaultLookup();\n-        MemorySegment parent = Arena.global().allocate(ValueLayout.ADDRESS);\n-        MemorySegment child = Arena.global().allocate(ValueLayout.ADDRESS);\n-        Optional<MemorySegment> openptyAddress = stdlib.find(\"openpty\");\n-\n-        if (openptyAddress.isEmpty()) {\n-            System.out.println(\"Cannot lookup openpty.\");\n-            \/\/does not have forkpty, ignore\n-            return ;\n-        }\n-\n-        Optional<MemorySegment> loginttyAddress = stdlib.find(\"login_tty\");\n-\n-        if (loginttyAddress.isEmpty()) {\n-            System.out.println(\"Cannot lookup login_tty.\");\n-            \/\/does not have forkpty, ignore\n-            return ;\n-        }\n-\n-        FunctionDescriptor openttyDescriptor =\n-                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS);\n-        MethodHandle forkpty = linker.downcallHandle(openptyAddress.get(),\n-                                                     openttyDescriptor);\n-        int res = (int) forkpty.invoke(parent,\n-                                       child,\n-                                       MemorySegment.NULL,\n-                                       MemorySegment.NULL,\n-                                       MemorySegment.NULL);\n-\n-        if (res != 0) {\n-            throw new AssertionError();\n-        }\n-\n-        \/\/set the current VM's in\/out to the terminal:\n-        FunctionDescriptor loginttyDescriptor =\n-                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n-                                      ValueLayout.JAVA_INT);\n-        MethodHandle logintty = linker.downcallHandle(loginttyAddress.get(),\n-                                                      loginttyDescriptor);\n-        logintty.invoke(child.get(ValueLayout.JAVA_INT, 0));\n-\n-        \/\/createTestJavaProcessBuilder logs to (current process') System.out, but\n-        \/\/that may not work since the redirect. Setting System.out to a scratch value:\n-        System.setOut(new PrintStream(new ByteArrayOutputStream()));\n-\n-        ProcessBuilder builder =\n-            ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName());\n-\n-        builder.inheritIO();\n-        builder.redirectOutput(stdout.toFile());\n-\n-        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n-\n-        output.waitFor();\n-\n-        String expectedOut = OUTPUT;\n-        String actualOut = Files.readString(stdout);\n-\n-        if (!Objects.equals(expectedOut, actualOut)) {\n-            throw new AssertionError(\"Unexpected stdout content. \" +\n-                                     \"Expected: '\" + expectedOut + \"'\" +\n-                                     \", got: '\" + actualOut + \"'\");\n-        }\n-    }\n-\n-    public static class ConsoleTest {\n-        public static void main(String... args) {\n-            System.console().printf(OUTPUT);\n-            System.exit(0);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/jline\/RedirectedStdOut.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n- * @run main jdk.internal.reflect.constantPool.ConstantPoolTest\n+ * @compile ConstantPoolTest.java\n+ * @run junit ConstantPoolTest\n@@ -35,2 +36,1 @@\n-package jdk.internal.reflect.constantPool;\n-\n+import java.lang.classfile.ClassFile;\n@@ -42,0 +42,5 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -49,3 +54,11 @@\n-    public static void main(String[] s) {\n-        for (TestCase testCase : TestCase.values()) {\n-            testCase.test();\n+    @ParameterizedTest\n+    @EnumSource(TestCase.class)\n+    void runTestCases(TestCase testCase) {\n+        testCase.test();\n+    }\n+\n+    @Test\n+    void testSize() throws Throwable {\n+        byte[] data;\n+        try (var in = ConstantPoolTest.class.getResourceAsStream(\"\/ConstantPoolTestDummy.class\")) {\n+            data = in.readAllBytes();\n@@ -53,0 +66,2 @@\n+        var testClass = ClassFile.of().parse(data);\n+        assertEquals(testClass.constantPool().size(), CP.getSize());\n@@ -55,1 +70,1 @@\n-    public static enum TestCase {\n+    public enum TestCase {\n","filename":"test\/jdk\/jdk\/internal\/reflect\/constantPool\/ConstantPoolTest.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-package  jdk\/internal\/reflect\/constantPool;\n-\n@@ -44,1 +42,1 @@\n-const #11 = Asciz   \"jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy\";\n+const #11 = Asciz   \"ConstantPoolTestDummy\";\n@@ -79,1 +77,1 @@\n-const #48 = Field    #2.#49;    \/\/  jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy.myField:\"I\"\n+const #48 = Field    #2.#49;    \/\/  ConstantPoolTestDummy.myField:\"I\"\n","filename":"test\/jdk\/jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy.jasm","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-\/**\n+\/*\n@@ -759,1 +759,1 @@\n-        try (JarFile jf = new JarFile(ZIP_FILE.toFile())) {\n+        try (JarFile jf = new JarFile(JAR_FILE.toFile())) {\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestPosix.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.OptionalInt;\n@@ -814,0 +815,4 @@\n+    public Executor.Result executeIgnoreExitCode() {\n+        return execute(OptionalInt.empty());\n+    }\n+\n@@ -819,0 +824,4 @@\n+        return execute(OptionalInt.of(expectedExitCode));\n+    }\n+\n+    private Executor.Result execute(OptionalInt expectedExitCode) {\n@@ -855,1 +864,2 @@\n-        if (expectedExitCode == 0 && !isImagePackageType()) {\n+        if (expectedExitCode.isPresent() && expectedExitCode.orElseThrow() == 0\n+                && !isImagePackageType()) {\n@@ -863,1 +873,6 @@\n-        Executor.Result result = copy.createExecutor().execute(expectedExitCode);\n+        Executor.Result result;\n+        if (expectedExitCode.isEmpty()) {\n+            result = copy.createExecutor().executeWithoutExitCodeCheck();\n+        } else {\n+            result = copy.createExecutor().execute(expectedExitCode.orElseThrow());\n+        }\n@@ -867,1 +882,2 @@\n-        if (expectedExitCode == 0 && isImagePackageType()) {\n+        if (expectedExitCode.isPresent() && expectedExitCode.orElseThrow() == 0\n+                && isImagePackageType()) {\n@@ -875,1 +891,1 @@\n-        if (result.exitCode() == 0) {\n+        if (result.exitCode() == 0 && expectedExitCode.isPresent()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Collection;\n@@ -42,0 +41,1 @@\n+import jdk.jpackage.test.JPackageStringBundle;\n@@ -119,0 +119,14 @@\n+    @Test(ifOS = MACOS)\n+    @Parameter({TEST_DIR, \"warning.non.standard.contents.sub.dir\"})\n+    @Parameter({TEST_DUKE, \"warning.app.content.is.not.dir\"})\n+    public void testWarnings(String testPath, String warningId) throws Exception {\n+        final var appContentValue = TKit.TEST_SRC_ROOT.resolve(testPath);\n+        final var expectedWarning = JPackageStringBundle.MAIN.cannedFormattedString(\n+                warningId, appContentValue);\n+\n+        JPackageCommand.helloAppImage()\n+            .addArguments(\"--app-content\", appContentValue)\n+            .validateOutput(expectedWarning)\n+            .executeIgnoreExitCode();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-                <code><a href=\"PubJ.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code><\/div>\n+                <code><a href=\"PubJ.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDuplicateMethodsWarn\/TestDuplicateMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+        checkOutput(\"resource-files\/stylesheet.css\", true,\n+                \"@import url('fonts\/dejavu.css');\");\n@@ -118,0 +120,2 @@\n+        checkOutput(\"resource-files\/stylesheet.css\", false,\n+                \"@import url('fonts\/dejavu.css');\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testFonts\/TestFonts.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                    InnerExtendsInvisibleInner<\/a><\/code><\/div>\n+                    InnerExtendsInvisibleInner<\/a><\/code>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/TestHiddenTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-             8186332 8186703 8182765 8187288 8261976 8303349 8319988\n+             8186332 8186703 8182765 8187288 8261976 8303349 8319988 8350920\n@@ -214,1 +214,34 @@\n-                code><\/div>\"\"\");\n+                code>\n+                <div class=\"summary-table three-column-summary\">\n+                <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                <div class=\"table-header col-second\">Interface<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-first even-row-color\"><code>static interface&nbsp;<\/code><\/div>\n+                <div class=\"col-second even-row-color\"><code><a href=\"Spliterator.OfDouble.html\"\\\n+                 class=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfDouble<\/a><\/code\\\n+                ><\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <div class=\"col-first odd-row-color\"><code>static interface&nbsp;<\/code><\/div>\n+                <div class=\"col-second odd-row-color\"><code><a href=\"Spliterator.OfInt.html\" cla\\\n+                ss=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfInt<\/a>&lt;<a href=\"\\\n+                Spliterator.OfInt.html#type-param-Integer\" title=\"type parameter in Spliterator.\\\n+                OfInt\">Integer<\/a>&gt;<\/code><\/div>\n+                <div class=\"col-last odd-row-color\">&nbsp;<\/div>\n+                <div class=\"col-first even-row-color\"><code>static interface&nbsp;<\/code><\/div>\n+                <div class=\"col-second even-row-color\"><code><a href=\"Spliterator.OfPrimitive.ht\\\n+                ml\" class=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfPrimitive<\/a>\\\n+                &lt;<a href=\"Spliterator.OfPrimitive.html#type-param-T\" title=\"type parameter in\\\n+                 Spliterator.OfPrimitive\">T<\/a>, <a href=\"Spliterator.OfPrimitive.html#type-para\\\n+                m-T_CONS\" title=\"type parameter in Spliterator.OfPrimitive\">T_CONS<\/a>, <a href\\\n+                =\"Spliterator.OfPrimitive.html#type-param-T_SPLITR\" title=\"type parameter in Sp\\\n+                literator.OfPrimitive\">T_SPLITR<\/a> extends <a href=\"Spliterator.OfPrimitive.ht\\\n+                ml\" title=\"interface in pkg2\">Spliterator.OfPrimitive<\/a>&lt;<a href=\"Spliterat\\\n+                or.OfPrimitive.html#type-param-T\" title=\"type parameter in Spliterator.OfPrimit\\\n+                ive\">T<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html#type-param-T_CONS\" title=\\\n+                \"type parameter in Spliterator.OfPrimitive\">T_CONS<\/a>,<wbr><a href=\"Spliterato\\\n+                r.OfPrimitive.html#type-param-T_SPLITR\" title=\"type parameter in Spliterator.Of\\\n+                Primitive\">T_SPLITR<\/a>&gt;&gt;<\/code><\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <\/div>\n+                <\/div>\n+                <\/section>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      8203791 8184205 8249633 8261976\n+ *      8203791 8184205 8249633 8261976 8350920\n@@ -244,1 +244,23 @@\n-                    <code><a href=\"C.html#pausedProperty\">paused<\/a>, <a href=\"C.html#rateProperty\">rate<\/a><\/code><\/div>\"\"\");\n+                    <code><a href=\"C.html#pausedProperty\">paused<\/a>, <a href=\"C.html#rateProperty\">rate<\/a><\/code>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Type<\/div>\n+                    <div class=\"table-header col-second\">Property<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>final <a href=\"C.BooleanProperty.htm\\\n+                    l\" title=\"class in pkg1\">C.BooleanProperty<\/a><\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"C.html#pausedProperty\" cla\\\n+                    ss=\"member-name-link\">paused<\/a><\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">Defines if paused.<\/div>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color\"><code>final <a href=\"C.DoubleProperty.html\"\\\n+                     title=\"class in pkg1\">C.DoubleProperty<\/a><\/code><\/div>\n+                    <div class=\"col-second odd-row-color\"><code><a href=\"C.html#rateProperty\" class=\\\n+                    \"member-name-link\">rate<\/a><\/code><\/div>\n+                    <div class=\"col-last odd-row-color\">\n+                    <div class=\"block\">Defines the direction\/speed at which the <code>Timeline<\/code> is expected to\n+                    be played.<\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/section>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8157000 8192850 8182765 8223607 8261976 8281376 8313204 8345777\n+ * @bug 8157000 8192850 8182765 8223607 8261976 8281376 8313204 8345777 8350920\n@@ -88,0 +88,11 @@\n+                \/\/ Check summary table for inherited nested classes\n+                \"summary-table three-column-summary\",\n+                \"Modifier and Type\",\n+                \"Class\",\n+                \"Description\",\n+                \"class&nbsp;\",\n+                \"Classes.P.PN.html\",\n+                \"Classes.P.PN.html#type-param-K\",\n+                \"Classes.P.PN.html#type-param-V\",\n+                \"A nested class in parent\",\n+\n@@ -95,0 +106,9 @@\n+                \/\/ Check summary table for inherited properties\n+                \"summary-table three-column-summary\",\n+                \"Type\",\n+                \"Property\",\n+                \"Description\",\n+                \"Classes.DoubleProperty\",\n+                \"Classes.P.html#rateProperty\",\n+                \"rate\",\n+\n@@ -101,0 +121,9 @@\n+                \/\/ Check summary table for inherited fields\n+                \"summary-table three-column-summary\",\n+                \"Modifier and Type\",\n+                \"Field\",\n+                \"Description\",\n+                \"int\",\n+                \"Classes.P.html#field0\",\n+                \"field0\",\n+\n@@ -121,0 +150,10 @@\n+                \/\/ Check summary table for inherited methods\n+                \"summary-table three-column-summary\",\n+                \"Modifier and Type\",\n+                \"Method\",\n+                \"Description\",\n+                \"void\",\n+                \"Classes.GP.html#m0()\",\n+                \"m0\",\n+                \"m0 in grand parent\",\n+\n@@ -123,3 +162,5 @@\n-                    Methods declared in class&nbsp;java.lang.Object\"\"\",\n-                \"\"\"\n-                    clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait\"\"\",\n+                    <h3 id=\"methods-inherited-from-class-java.lang.Object\">Methods declared in clas\\\n+                    s&nbsp;java.lang.Object<\/h3>\n+                    <code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString,\\\n+                     wait, wait, wait<\/code><\/div>\n+                    <\/section>\"\"\",\n@@ -193,0 +234,15 @@\n+        checkOrder(\"pkg5\/Classes.P.html\",\n+                \/\/ Check table of contents for inherited members\n+                \"\"\"\n+                    <li><a href=\"#nested-class-summary\" tabindex=\"0\">Nested Class Summary<\/a><\/li>\n+                    <li><a href=\"#property-summary\" tabindex=\"0\">Property Summary<\/a><\/li>\n+                    <li><a href=\"#field-summary\" tabindex=\"0\">Field Summary<\/a><\/li>\n+                    <li><a href=\"#constructor-summary\" tabindex=\"0\">Constructor Summary<\/a><\/li>\n+                    <li><a href=\"#method-summary\" tabindex=\"0\">Method Summary<\/a>\n+                    <ol class=\"toc-list\">\n+                    <li><a href=\"#methods-inherited-from-class-pkg5.Classes.GP\" tabindex=\"0\">Method\\\n+                    s declared in class&nbsp;Classes.GP<\/a><\/li>\n+                    <li><a href=\"#methods-inherited-from-class-java.lang.Object\" tabindex=\"0\">Metho\\\n+                    ds declared in class&nbsp;java.lang.Object<\/a><\/li>\n+                    <\/ol>\"\"\");\n+\n@@ -394,2 +450,26 @@\n-                    le=\"m3()\">m3<\/a>, <a href=\"Base.html#m9()\" title=\"m9()\">m9<\/a><\/code><\/div>\n-                    \"\"\");\n+                    le=\"m3()\">m3<\/a>, <a href=\"Base.html#m9()\" title=\"m9()\">m9<\/a><\/code>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                    <div class=\"table-header col-second\">Method<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>java.lang.Object<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"Base.html#m1()\" class=\"mem\\\n+                    ber-name-link\">m1<\/a>()<\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">This is Base::m1.<\/div>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color\"><code><a href=\"#type-param-T\" title=\"type p\\\n+                    arameter in Sub\">T<\/a><\/code><\/div>\n+                    <div class=\"col-second odd-row-color\"><code><a href=\"Base.html#m3()\" class=\"memb\\\n+                    er-name-link\">m3<\/a>()<\/code><\/div>\n+                    <div class=\"col-last odd-row-color\">\n+                    <div class=\"block\">This is Base::m3.<\/div>\n+                    <\/div>\n+                    <div class=\"col-first even-row-color\"><code>abstract java.lang.Object<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"Base.html#m9()\" class=\"mem\\\n+                    ber-name-link\">m9<\/a>()<\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">This is Base::m9.<\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/div>\"\"\");\n@@ -418,1 +498,16 @@\n-                    , int[])\">m1<\/a><\/code><\/div>\"\"\");\n+                    , int[])\">m1<\/a><\/code>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                    <div class=\"table-header col-second\">Method<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>java.lang.Iterable<wbr>&lt;java.lang\\\n+                    .String&gt;<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"AnnotatedBase.html#m1(java\\\n+                    .lang.Class,int%5B%5D)\" class=\"member-name-link\">m1<\/a><wbr>(java.lang.Class&lt;\\\n+                    ? extends java.lang.CharSequence&gt;&nbsp;p1,\n+                     int[]&nbsp;p2)<\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">This is AnnotatedBase::m1.<\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/div>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestOverrideMethods.java","additions":103,"deletions":8,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+        setUseDefaultOptions(false);\n@@ -89,1 +90,1 @@\n-                        padding: 8px 3px 3px 7px;\n+                        padding: 8px 5px 3px 7px;\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-                    <code><a href=\"internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code><\/div>\n+                    <code><a href=\"internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code>\n@@ -267,1 +267,1 @@\n-                    <code><a href=\"internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code><\/div>\n+                    <code><a href=\"internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code>\n@@ -289,1 +289,1 @@\n-                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code><\/div>\n+                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code>\n@@ -295,1 +295,1 @@\n-                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code><\/div>\n+                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnexported\/TestUnexported.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+            \"resource-files\/down.svg\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8274148 8301580\n+ * @bug 8274148 8301580 8359497\n@@ -117,0 +117,6 @@\n+    public void testNoCrashOnLexicalErrors() { \/\/JDK-8359497\n+        assertHighlights(\"\"\"\n+                         \"\n+                         \"\"\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/SnippetHighlightTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8306560\n+ * @bug 8306560 8365878\n@@ -82,0 +82,27 @@\n+\n+    @Test\n+    public void testDisassembleBuiltinInnerClass() {\n+        test(\n+            a -> assertCommand(a, \"\/open TOOLING\",\n+                        \"\"),\n+            a -> assertCommandUserOutputContains(a, \"javap(Base64.Decoder.class)\",\n+                        \"Classfile jrt:\/java.base\/java\/util\/Base64$Decoder.class\",\n+                        \"class java.util.Base64$Decoder\",\n+                        \"SourceFile: \\\"Base64.java\\\"\")\n+        );\n+    }\n+\n+    @Test\n+    public void testDisassembleAnonymousClass() {\n+        test(\n+            a -> assertCommand(a, \"Object o() {return new ArrayList<>(){ };}\", \/\/ must be in a method or it won't be anonymous\n+                        \"|  created method o()\"),\n+            a -> assertCommand(a, \"\/open TOOLING\",\n+                        \"\"),\n+            a -> assertCommandUserOutputContains(a, \"javap(o().getClass())\",\n+                        \"Classfile \", \/\/ Classfile \/...\/TOOLING-16063368030094702464.class\n+                        \" extends java.util.ArrayList<java.lang.Object>\", \/\/ class REPL.$JShell$22$1 extends java.util.ArrayList<java.lang.Object>\n+                        \"SourceFile: \\\"$JShell$\" \/\/ SourceFile: \"$JShell$22.java\"\n+            )\n+        );\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ToolingTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -406,2 +406,0 @@\n-                                                   \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                   \"-XX:VerifyArchivedFields=2\", \/\/ make sure archived heap objects are good.\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,1 +443,0 @@\n-        addVerifyArchivedFields(cmd);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}