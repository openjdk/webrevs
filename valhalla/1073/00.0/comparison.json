{"files":[{"patch":"@@ -26,1 +26,1 @@\n-DISABLED_WARNINGS_java += this-escape\n+DISABLED_WARNINGS_java += this-escape restricted preview\n@@ -30,1 +30,1 @@\n-JAVAC_FLAGS += -XDstringConcat=inline\n+JAVAC_FLAGS += -XDstringConcat=inline --enable-preview\n","filename":"make\/modules\/java.base\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+JAVAC_FLAGS += --enable-preview\n+JAVA_FLAGS += --enable-preview\n","filename":"make\/modules\/jdk.incubator.vector\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2585,1 +2585,1 @@\n-  if (UseSVE == 0 || !VectorNode::is_invariant_vector(m)) {\n+  if (UseSVE == 0 || m->Opcode() != Op_Replicate) {\n@@ -3750,18 +3750,15 @@\n-      if (!_method->signature()->returns_null_free_inline_type()) {\n-        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n-        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n-        uint con = (tf()->range_cc()->cnt() - 1);\n-        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-          ProjNode* proj = fast_out(i)->as_Proj();\n-          if (proj->_con == con) {\n-            \/\/ Set IsInit if r0 is non-null (a non-null value is returned buffered or scalarized)\n-            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n-            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n-            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n-            __ cmp(r0, zr);\n-            __ cset(toReg, Assembler::NE);\n-            if (reg->is_stack()) {\n-              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n-              __ str(toReg, Address(sp, st_off));\n-            }\n-            break;\n+      \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+      \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+      uint con = (tf()->range_cc()->cnt() - 1);\n+      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+        ProjNode* proj = fast_out(i)->as_Proj();\n+        if (proj->_con == con) {\n+          \/\/ Set IsInit if r0 is non-null (a non-null value is returned buffered or scalarized)\n+          OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+          VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+          Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+          __ cmp(r0, zr);\n+          __ cset(toReg, Assembler::NE);\n+          if (reg->is_stack()) {\n+            int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+            __ str(toReg, Address(sp, st_off));\n@@ -3769,0 +3766,1 @@\n+          break;\n@@ -16483,1 +16481,1 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16486,1 +16484,1 @@\n-  effect(TEMP tmp, TEMP tmp2);\n+  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n@@ -16494,1 +16492,1 @@\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -9464,2 +9464,3 @@\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (ReplicateB src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate src));\n@@ -9486,2 +9487,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd());\n-  match(Set dst (ReplicateB src));\n+  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate src));\n@@ -9501,2 +9503,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (ReplicateB src));\n+  predicate(n->as_Vector()->length_in_bytes() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate src));\n@@ -9516,2 +9519,3 @@\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (ReplicateB src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate src));\n@@ -9531,2 +9535,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd());\n-  match(Set dst (ReplicateB src));\n+  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate src));\n@@ -9546,2 +9551,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd());\n-  match(Set dst (ReplicateB src));\n+  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate src));\n@@ -9561,2 +9567,3 @@\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateS src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n@@ -9581,2 +9588,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd());\n-  match(Set dst (ReplicateS src));\n+  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n@@ -9596,2 +9604,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd());\n-  match(Set dst (ReplicateS src));\n+  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n@@ -9612,2 +9621,3 @@\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateS src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n@@ -9626,2 +9636,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd());\n-  match(Set dst (ReplicateS src));\n+  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n@@ -9641,2 +9652,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd());\n-  match(Set dst (ReplicateS src));\n+  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n@@ -9656,2 +9668,3 @@\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateI src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -9669,2 +9682,3 @@\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateI src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -9687,2 +9701,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd());\n-  match(Set dst (ReplicateI src));\n+  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -9702,2 +9717,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd());\n-  match(Set dst (ReplicateI src));\n+  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -9718,2 +9734,3 @@\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateI src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -9732,2 +9749,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd());\n-  match(Set dst (ReplicateI src));\n+  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -9747,2 +9765,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd());\n-  match(Set dst (ReplicateI src));\n+  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -9762,2 +9781,3 @@\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateL src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate src));\n@@ -9780,2 +9800,3 @@\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateF src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -9793,2 +9814,3 @@\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateF src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -9807,2 +9829,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd());\n-  match(Set dst (ReplicateF src));\n+  predicate(n->as_Vector()->length_in_bytes() == 8 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -9822,2 +9845,3 @@\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateF src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -9842,2 +9866,3 @@\n-  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd());\n-  match(Set dst (ReplicateF src));\n+  predicate(n->as_Vector()->length_in_bytes() == 16 && VM_Version::has_simd() &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -9857,2 +9882,3 @@\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateF src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -9871,2 +9897,3 @@\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateD src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (Replicate src));\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":81,"deletions":54,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -13452,2 +13452,3 @@\n-  match(Set dst (ReplicateB src));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -13463,2 +13464,3 @@\n-  match(Set dst (ReplicateB zero));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -13474,2 +13476,3 @@\n-  match(Set dst (ReplicateB src));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -13485,2 +13488,3 @@\n-  match(Set dst (ReplicateB src));\n-  predicate(n->as_Vector()->length() == 16);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -13501,2 +13505,3 @@\n-  match(Set dst (ReplicateB zero));\n-  predicate(n->as_Vector()->length() == 16);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -13513,2 +13518,3 @@\n-  match(Set dst (ReplicateB src));\n-  predicate(n->as_Vector()->length() == 16);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -13525,2 +13531,3 @@\n-  match(Set dst (ReplicateS src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -13535,2 +13542,3 @@\n-  match(Set dst (ReplicateS zero));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -13546,2 +13554,3 @@\n-  match(Set dst (ReplicateS src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -13557,2 +13566,3 @@\n-  match(Set dst (ReplicateS src));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -13573,2 +13583,3 @@\n-  match(Set dst (ReplicateS zero));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -13585,2 +13596,3 @@\n-  match(Set dst (ReplicateS src));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -13597,2 +13609,3 @@\n-  match(Set dst (ReplicateI src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -13607,2 +13620,3 @@\n-  match(Set dst (ReplicateI zero));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -13618,2 +13632,3 @@\n-  match(Set dst (ReplicateI src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -13629,2 +13644,3 @@\n-  match(Set dst (ReplicateI src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -13645,2 +13661,3 @@\n-  match(Set dst (ReplicateI zero));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -13657,2 +13674,3 @@\n-  match(Set dst (ReplicateI src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -13670,2 +13688,3 @@\n-  match(Set dst (ReplicateF src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -13685,2 +13704,3 @@\n-  match(Set dst (ReplicateF src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -13695,2 +13715,3 @@\n-  match(Set dst (ReplicateF zero));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -14212,2 +14233,3 @@\n-  match(Set dst (ReplicateF src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -14225,2 +14247,3 @@\n-  match(Set dst (ReplicateF src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -14234,2 +14257,3 @@\n-  match(Set dst (ReplicateF zero));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -14245,2 +14269,3 @@\n-  match(Set dst (ReplicateD src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -14257,2 +14282,3 @@\n-  match(Set dst (ReplicateD zero));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -14303,1 +14329,2 @@\n-  match(Set dst (ReplicateL src));\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate src));\n@@ -14314,2 +14341,3 @@\n-  match(Set dst (ReplicateL zero));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -14326,2 +14354,3 @@\n-  match(Set dst (ReplicateL src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":86,"deletions":57,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -937,0 +937,20 @@\n+\/\/ class for vector register v12\n+reg_class v12_reg(\n+    V12, V12_H, V12_J, V12_K\n+);\n+\n+\/\/ class for vector register v13\n+reg_class v13_reg(\n+    V13, V13_H, V13_J, V13_K\n+);\n+\n+\/\/ class for vector register v14\n+reg_class v14_reg(\n+    V14, V14_H, V14_J, V14_K\n+);\n+\n+\/\/ class for vector register v15\n+reg_class v15_reg(\n+    V15, V15_H, V15_J, V15_K\n+);\n+\n@@ -986,2 +1006,2 @@\n-  int_def IDIVSI_COST          ( 3400, 34 * DEFAULT_COST);          \/\/ idivdi\n-  int_def IDIVDI_COST          ( 6600, 66 * DEFAULT_COST);          \/\/ idivsi\n+  int_def IDIVSI_COST          ( 3400, 34 * DEFAULT_COST);          \/\/ idivsi\n+  int_def IDIVDI_COST          ( 6600, 66 * DEFAULT_COST);          \/\/ idivdi\n@@ -1891,0 +1911,3 @@\n+    case Op_ExpandBits:        \/\/ fall through\n+    case Op_CompressBits:      \/\/ fall through\n+      guarantee(UseRVV == (MaxVectorSize >= 16), \"UseRVV and MaxVectorSize not matched\");\n@@ -1893,3 +1916,1 @@\n-    case Op_CountPositives:\n-      return UseRVV;\n-\n+    case Op_CountPositives:    \/\/ fall through\n@@ -1897,1 +1918,1 @@\n-      return UseRVV && SpecialEncodeISOArray;\n+      return UseRVV;\n@@ -2436,1 +2457,9 @@\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, false);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n+  %}\n+\n+  enc_class riscv_enc_divuw(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ false);\n@@ -2444,1 +2473,9 @@\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, false);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n+  %}\n+\n+  enc_class riscv_enc_divu(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ false);\n@@ -2452,1 +2489,9 @@\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, true);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n+  %}\n+\n+  enc_class riscv_enc_moduw(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ false);\n@@ -2460,1 +2505,9 @@\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, true);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n+  %}\n+\n+  enc_class riscv_enc_modu(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ false);\n@@ -3469,0 +3522,40 @@\n+operand vReg_V12()\n+%{\n+  constraint(ALLOC_IN_RC(v12_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V13()\n+%{\n+  constraint(ALLOC_IN_RC(v13_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V14()\n+%{\n+  constraint(ALLOC_IN_RC(v14_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V15()\n+%{\n+  constraint(ALLOC_IN_RC(v15_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -6666,0 +6759,9 @@\n+instruct UdivI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{\n+  match(Set dst (UDivI src1 src2));\n+  ins_cost(IDIVSI_COST);\n+  format %{ \"divuw  $dst, $src1, $src2\\t#@UdivI\"%}\n+\n+  ins_encode(riscv_enc_divuw(dst, src1, src2));\n+  ins_pipe(idiv_reg_reg);\n+%}\n+\n@@ -6688,0 +6790,10 @@\n+instruct UdivL(iRegLNoSp dst, iRegL src1, iRegL src2) %{\n+  match(Set dst (UDivL src1 src2));\n+  ins_cost(IDIVDI_COST);\n+\n+  format %{ \"divu $dst, $src1, $src2\\t#@UdivL\" %}\n+\n+  ins_encode(riscv_enc_divu(dst, src1, src2));\n+  ins_pipe(ldiv_reg_reg);\n+%}\n+\n@@ -6710,0 +6822,9 @@\n+instruct UmodI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{\n+  match(Set dst (UModI src1 src2));\n+  ins_cost(IDIVSI_COST);\n+  format %{ \"remuw  $dst, $src1, $src2\\t#@UmodI\" %}\n+\n+  ins_encode(riscv_enc_moduw(dst, src1, src2));\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -6721,0 +6842,9 @@\n+instruct UmodL(iRegLNoSp dst, iRegL src1, iRegL src2) %{\n+  match(Set dst (UModL src1 src2));\n+  ins_cost(IDIVDI_COST);\n+  format %{ \"remu  $dst, $src1, $src2\\t#@UmodL\" %}\n+\n+  ins_encode(riscv_enc_modu(dst, src1, src2));\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -7285,1 +7415,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0010000001);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::inf);\n@@ -7300,1 +7430,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0010000001);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::inf);\n@@ -7315,1 +7445,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0001111110);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::finite);\n@@ -7330,1 +7460,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), 0b0001111110);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::finite);\n@@ -7499,0 +7629,44 @@\n+\/\/ Copysign and signum intrinsics\n+\n+instruct copySignD_reg(fRegD dst, fRegD src1, fRegD src2, immD zero) %{\n+  match(Set dst (CopySignD src1 (Binary src2 zero)));\n+  format %{ \"CopySignD  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ fsgnj_d(dst, src1, src2);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_d);\n+%}\n+\n+instruct copySignF_reg(fRegF dst, fRegF src1, fRegF src2) %{\n+  match(Set dst (CopySignF src1 src2));\n+  format %{ \"CopySignF  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ fsgnj_s(dst, src1, src2);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+instruct signumD_reg(fRegD dst, immD zero, fRegD one) %{\n+  match(Set dst (SignumD dst (Binary zero one)));\n+  format %{ \"signumD  $dst, $dst\" %}\n+  ins_encode %{\n+    __ signum_fp(as_FloatRegister($dst$$reg), as_FloatRegister($one$$reg), true \/* is_double *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct signumF_reg(fRegF dst, immF zero, fRegF one) %{\n+  match(Set dst (SignumF dst (Binary zero one)));\n+  format %{ \"signumF  $dst, $dst\" %}\n+  ins_encode %{\n+    __ signum_fp(as_FloatRegister($dst$$reg), as_FloatRegister($one$$reg), false \/* is_double *\/);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -8588,0 +8762,36 @@\n+instruct cmpUL3_reg_reg(iRegINoSp dst, iRegL op1, iRegL op2)\n+%{\n+  match(Set dst (CmpUL3 op1 op2));\n+\n+  ins_cost(ALU_COST * 3 + BRANCH_COST);\n+  format %{ \"sltu  $dst, $op2, $op1\\t#@cmpUL3_reg_reg\\n\\t\"\n+            \"bnez  $dst, done\\n\\t\"\n+            \"sltu  $dst, $op1, $op2\\n\\t\"\n+            \"neg   $dst, $dst\\t#@cmpUL3_reg_reg\"\n+  %}\n+  ins_encode %{\n+    __ cmp_ul2i(t0, as_Register($op1$$reg), as_Register($op2$$reg));\n+    __ mv(as_Register($dst$$reg), t0);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpU3_reg_reg(iRegINoSp dst, iRegI op1, iRegI op2)\n+%{\n+  match(Set dst (CmpU3 op1 op2));\n+\n+  ins_cost(ALU_COST * 3 + BRANCH_COST);\n+  format %{ \"sltu  $dst, $op2, $op1\\t#@cmpU3_reg_reg\\n\\t\"\n+            \"bnez  $dst, done\\n\\t\"\n+            \"sltu  $dst, $op1, $op2\\n\\t\"\n+            \"neg   $dst, $dst\\t#@cmpU3_reg_reg\"\n+  %}\n+  ins_encode %{\n+    __ cmp_uw2i(t0, as_Register($op1$$reg), as_Register($op2$$reg));\n+    __ mv(as_Register($dst$$reg), t0);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -10184,1 +10394,1 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10187,1 +10397,1 @@\n-  effect(TEMP tmp1, TEMP tmp2);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10190,1 +10400,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2, #@cmpFastLock\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3, #@cmpFastLock\" %}\n@@ -10193,1 +10403,1 @@\n-    __ fast_lock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_lock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":228,"deletions":18,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+  if (UseVectorizedMismatchIntrinsic) {\n+    warning(\"VectorizedMismatch intrinsic is not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);\n+  }\n+\n@@ -189,8 +194,10 @@\n-  if (UseRVV) {\n-    if (!ext_V.enabled()) {\n-      warning(\"RVV is not supported on this CPU\");\n-      FLAG_SET_DEFAULT(UseRVV, false);\n-    } else {\n-      \/\/ read vector length from vector CSR vlenb\n-      _initial_vector_length = cpu_vector_length();\n-    }\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n+\n+  if (FLAG_IS_DEFAULT(UseCopySignIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseCopySignIntrinsic, true);\n+  }\n+\n+  if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n@@ -252,0 +259,10 @@\n+  if (UseRVV) {\n+    if (!ext_V.enabled()) {\n+      warning(\"RVV is not supported on this CPU\");\n+      FLAG_SET_DEFAULT(UseRVV, false);\n+    } else {\n+      \/\/ read vector length from vector CSR vlenb\n+      _initial_vector_length = cpu_vector_length();\n+    }\n+  }\n+\n@@ -255,0 +272,15 @@\n+\n+  \/\/ NOTE: Make sure codes dependent on UseRVV are put after c2_initialize(),\n+  \/\/       as there are extra checks inside it which could disable UseRVV\n+  \/\/       in some situations.\n+\n+  if (UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, true);\n+    }\n+  } else if (UseChaCha20Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      warning(\"Chacha20 intrinsic requires RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n@@ -268,10 +300,1 @@\n-    FLAG_SET_DEFAULT(SpecialEncodeISOArray, false);\n-  }\n-\n-  if (!UseRVV && MaxVectorSize) {\n-  }\n-\n-  if (!UseRVV) {\n-  }\n-\n-  if (UseRVV) {\n+  } else {\n@@ -282,1 +305,8 @@\n-    } else if (MaxVectorSize < 16) {\n+    } else if (!is_power_of_2(MaxVectorSize)) {\n+      vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d, must be a power of 2\", (int)MaxVectorSize));\n+    } else if (MaxVectorSize > _initial_vector_length) {\n+      warning(\"Current system only supports max RVV vector length %d. Set MaxVectorSize to %d\",\n+              _initial_vector_length, _initial_vector_length);\n+      MaxVectorSize = _initial_vector_length;\n+    }\n+    if (MaxVectorSize < 16) {\n@@ -285,8 +315,1 @@\n-    } else if (is_power_of_2(MaxVectorSize)) {\n-      if (MaxVectorSize > _initial_vector_length) {\n-        warning(\"Current system only supports max RVV vector length %d. Set MaxVectorSize to %d\",\n-                _initial_vector_length, _initial_vector_length);\n-        MaxVectorSize = _initial_vector_length;\n-      }\n-    } else {\n-      vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d\", (int)MaxVectorSize));\n+      FLAG_SET_DEFAULT(MaxVectorSize, 0);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":50,"deletions":27,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -10448,1 +10448,1 @@\n-  match(Set dst (ReplicateB src));\n+  match(Set dst (Replicate src));\n@@ -10450,1 +10450,1 @@\n-  predicate((n->as_Vector()->length() == 8));\n+  predicate(n->as_Vector()->length() == 8 && Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -10465,2 +10465,2 @@\n-  match(Set dst (ReplicateB src));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 && Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -10483,2 +10483,2 @@\n-  match(Set dst (ReplicateB src));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 && Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -10493,2 +10493,2 @@\n-  match(Set dst (ReplicateB src));\n-  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 && Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -10504,1 +10504,1 @@\n-  match(Set dst (ReplicateS src));\n+  match(Set dst (Replicate src));\n@@ -10506,1 +10506,1 @@\n-  predicate((n->as_Vector()->length() == 4));\n+  predicate((n->as_Vector()->length() == 4) && Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -10520,2 +10520,2 @@\n-  match(Set dst (ReplicateS src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 && Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -10538,2 +10538,2 @@\n-  match(Set dst (ReplicateS src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 && Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -10548,2 +10548,2 @@\n-  match(Set dst (ReplicateS src));\n-  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 && Matcher::vector_element_basic_type(n) == T_SHORT);\n@@ -10559,1 +10559,1 @@\n-  match(Set dst (ReplicateI src));\n+  match(Set dst (Replicate src));\n@@ -10561,1 +10561,1 @@\n-  predicate((n->as_Vector()->length() == 2));\n+  predicate((n->as_Vector()->length() == 2) && Matcher::vector_element_basic_type(n) == T_INT);\n@@ -10574,2 +10574,2 @@\n-  match(Set dst (ReplicateI src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 && Matcher::vector_element_basic_type(n) == T_INT);\n@@ -10590,2 +10590,2 @@\n-  match(Set dst (ReplicateI src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 && Matcher::vector_element_basic_type(n) == T_INT);\n@@ -10600,2 +10600,2 @@\n-  match(Set dst (ReplicateI src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 && Matcher::vector_element_basic_type(n) == T_INT);\n@@ -10611,1 +10611,1 @@\n-  match(Set dst (ReplicateF src));\n+  match(Set dst (Replicate src));\n@@ -10613,1 +10613,2 @@\n-  predicate(!VM_Version::has_FPSupportEnhancements() && n->as_Vector()->length() == 2);\n+  predicate(!VM_Version::has_FPSupportEnhancements() && n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -10626,1 +10627,1 @@\n-  match(Set dst (ReplicateF src));\n+  match(Set dst (Replicate src));\n@@ -10628,1 +10629,2 @@\n-  predicate(VM_Version::has_FPSupportEnhancements() && n->as_Vector()->length() == 2);\n+  predicate(VM_Version::has_FPSupportEnhancements() && n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -10643,2 +10645,2 @@\n-  match(Set dst (ReplicateF src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -10662,2 +10664,2 @@\n-  match(Set dst (ReplicateF src));\n-  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/resolvedMethodEntry.hpp\"\n@@ -459,50 +460,0 @@\n-void InterpreterMacroAssembler::get_cache_and_index_at_bcp(Register cache,\n-                                                           Register index,\n-                                                           int bcp_offset,\n-                                                           size_t index_size) {\n-  assert_different_registers(cache, index);\n-  get_cache_index_at_bcp(index, bcp_offset, index_size);\n-  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));\n-  assert(sizeof(ConstantPoolCacheEntry) == 4 * wordSize, \"adjust code below\");\n-  \/\/ convert from field index to ConstantPoolCacheEntry index\n-  assert(exact_log2(in_words(ConstantPoolCacheEntry::size())) == 2, \"else change next line\");\n-  shll(index, 2);\n-}\n-\n-void InterpreterMacroAssembler::get_cache_and_index_and_bytecode_at_bcp(Register cache,\n-                                                                        Register index,\n-                                                                        Register bytecode,\n-                                                                        int byte_no,\n-                                                                        int bcp_offset,\n-                                                                        size_t index_size) {\n-  get_cache_and_index_at_bcp(cache, index, bcp_offset, index_size);\n-  \/\/ We use a 32-bit load here since the layout of 64-bit words on\n-  \/\/ little-endian machines allow us that.\n-  movl(bytecode, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::indices_offset()));\n-  const int shift_count = (1 + byte_no) * BitsPerByte;\n-  assert((byte_no == TemplateTable::f1_byte && shift_count == ConstantPoolCacheEntry::bytecode_1_shift) ||\n-         (byte_no == TemplateTable::f2_byte && shift_count == ConstantPoolCacheEntry::bytecode_2_shift),\n-         \"correct shift count\");\n-  shrl(bytecode, shift_count);\n-  assert(ConstantPoolCacheEntry::bytecode_1_mask == ConstantPoolCacheEntry::bytecode_2_mask, \"common mask\");\n-  andl(bytecode, ConstantPoolCacheEntry::bytecode_1_mask);\n-}\n-\n-void InterpreterMacroAssembler::get_cache_entry_pointer_at_bcp(Register cache,\n-                                                               Register tmp,\n-                                                               int bcp_offset,\n-                                                               size_t index_size) {\n-  assert_different_registers(cache, tmp);\n-\n-  get_cache_index_at_bcp(tmp, bcp_offset, index_size);\n-  assert(sizeof(ConstantPoolCacheEntry) == 4 * wordSize, \"adjust code below\");\n-  \/\/ convert from field index to ConstantPoolCacheEntry index\n-  \/\/ and from word offset to byte offset\n-  assert(exact_log2(in_bytes(ConstantPoolCacheEntry::size_in_bytes())) == 2 + LogBytesPerWord, \"else change next line\");\n-  shll(tmp, 2 + LogBytesPerWord);\n-  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));\n-  \/\/ skip past the header\n-  addptr(cache, in_bytes(ConstantPoolCache::base_offset()));\n-  addptr(cache, tmp);  \/\/ construct pointer to cache entry\n-}\n-\n@@ -537,15 +488,0 @@\n-void InterpreterMacroAssembler::load_resolved_method_at_index(int byte_no,\n-                                                              Register method,\n-                                                              Register cache,\n-                                                              Register index) {\n-  assert_different_registers(cache, index);\n-\n-  const int method_offset = in_bytes(\n-    ConstantPoolCache::base_offset() +\n-      ((byte_no == TemplateTable::f2_byte)\n-       ? ConstantPoolCacheEntry::f2_offset()\n-       : ConstantPoolCacheEntry::f1_offset()));\n-\n-  movptr(method, Address(cache, index, Address::times_ptr, method_offset)); \/\/ get f1 Method*\n-}\n-\n@@ -2345,1 +2281,1 @@\n-  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  \/\/ Get index out of bytecode pointer\n@@ -2372,0 +2308,10 @@\n+\n+void InterpreterMacroAssembler::load_method_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+\n+  movptr(cache, Address(cache, ConstantPoolCache::method_entries_offset()));\n+  imull(index, index, sizeof(ResolvedMethodEntry)); \/\/ Scale the index to be the entry index * sizeof(ResolvedMethodEntry)\n+  lea(cache, Address(cache, index, Address::times_1, Array<ResolvedMethodEntry>::base_offset_in_bytes()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":12,"deletions":66,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -860,0 +860,6 @@\n+  \/\/ Check if processor has Intel Ecore\n+  if (FLAG_IS_DEFAULT(EnableX86ECoreOpts) && is_intel() && cpu_family() == 6 &&\n+    (_model == 0x97 || _model == 0xAC || _model == 0xAF)) {\n+    FLAG_SET_DEFAULT(EnableX86ECoreOpts, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-\/\/ Windows ABI: XMM6-XMM31 preserved across function calls\n+\/\/ Windows ABI: XMM6-XMM15 preserved across function calls\n@@ -2759,19 +2759,16 @@\n-      if (!_method->signature()->returns_null_free_inline_type()) {\n-        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n-        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n-        uint con = (tf()->range_cc()->cnt() - 1);\n-        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-          ProjNode* proj = fast_out(i)->as_Proj();\n-          if (proj->_con == con) {\n-            \/\/ Set IsInit if rax is non-null (a non-null value is returned buffered or scalarized)\n-            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n-            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n-            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n-            __ testq(rax, rax);\n-            __ setb(Assembler::notZero, toReg);\n-            __ movzbl(toReg, toReg);\n-            if (reg->is_stack()) {\n-              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n-              __ movq(Address(rsp, st_off), toReg);\n-            }\n-            break;\n+      \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+      \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+      uint con = (tf()->range_cc()->cnt() - 1);\n+      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+        ProjNode* proj = fast_out(i)->as_Proj();\n+        if (proj->_con == con) {\n+          \/\/ Set IsInit if rax is non-null (a non-null value is returned buffered or scalarized)\n+          OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+          VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+          Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+          __ testq(rax, rax);\n+          __ setb(Assembler::notZero, toReg);\n+          __ movzbl(toReg, toReg);\n+          if (reg->is_stack()) {\n+            int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+            __ movq(Address(rsp, st_off), toReg);\n@@ -2779,0 +2776,1 @@\n+          break;\n@@ -4160,2 +4158,2 @@\n-  predicate(UseAVX >= 2);\n-  match(Set dst (ReplicateB src));\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate src));\n@@ -4165,4 +4163,9 @@\n-    int vlen_enc = vector_length_encoding(this);\n-    if (vlen == 64 || VM_Version::supports_avx512vlbw()) { \/\/ AVX512VL for <512bit operands\n-      assert(VM_Version::supports_avx512bw(), \"required\"); \/\/ 512-bit byte vectors assume AVX512BW\n-      __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vlen_enc);\n+    if (UseAVX >= 2) {\n+      int vlen_enc = vector_length_encoding(this);\n+      if (vlen == 64 || VM_Version::supports_avx512vlbw()) { \/\/ AVX512VL for <512bit operands\n+        assert(VM_Version::supports_avx512bw(), \"required\"); \/\/ 512-bit byte vectors assume AVX512BW\n+        __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vlen_enc);\n+      } else {\n+        __ movdl($dst$$XMMRegister, $src$$Register);\n+        __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      }\n@@ -4170,0 +4173,1 @@\n+       assert(UseAVX < 2, \"\");\n@@ -4171,18 +4175,6 @@\n-      __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct ReplB_reg(vec dst, rRegI src) %{\n-  predicate(UseAVX < 2);\n-  match(Set dst (ReplicateB src));\n-  format %{ \"replicateB $dst,$src\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    __ movdl($dst$$XMMRegister, $src$$Register);\n-    __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);\n-    __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-    if (vlen >= 16) {\n-      assert(vlen == 16, \"\");\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);\n+      __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n+      if (vlen >= 16) {\n+        assert(vlen == 16, \"\");\n+        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      }\n@@ -4195,2 +4187,2 @@\n-  predicate(UseAVX >= 2);\n-  match(Set dst (ReplicateB (LoadB mem)));\n+  predicate(UseAVX >= 2 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (Replicate (LoadB mem)));\n@@ -4208,2 +4200,2 @@\n-  predicate(UseAVX >= 2);\n-  match(Set dst (ReplicateS src));\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n@@ -4214,3 +4206,8 @@\n-    if (vlen == 32 || VM_Version::supports_avx512vlbw()) { \/\/ AVX512VL for <512bit operands\n-      assert(VM_Version::supports_avx512bw(), \"required\"); \/\/ 512-bit short vectors assume AVX512BW\n-      __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vlen_enc);\n+    if (UseAVX >= 2) {\n+      if (vlen == 32 || VM_Version::supports_avx512vlbw()) { \/\/ AVX512VL for <512bit operands\n+        assert(VM_Version::supports_avx512bw(), \"required\"); \/\/ 512-bit short vectors assume AVX512BW\n+        __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vlen_enc);\n+      } else {\n+        __ movdl($dst$$XMMRegister, $src$$Register);\n+        __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      }\n@@ -4218,0 +4215,1 @@\n+      assert(UseAVX < 2, \"\");\n@@ -4219,18 +4217,5 @@\n-      __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct ReplS_reg(vec dst, rRegI src) %{\n-  predicate(UseAVX < 2);\n-  match(Set dst (ReplicateS src));\n-  format %{ \"replicateS $dst,$src\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    int vlen_enc = vector_length_encoding(this);\n-    __ movdl($dst$$XMMRegister, $src$$Register);\n-    __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-    if (vlen >= 8) {\n-      assert(vlen == 8, \"\");\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n+      if (vlen >= 8) {\n+        assert(vlen == 8, \"\");\n+        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      }\n@@ -4243,2 +4228,2 @@\n-  predicate(UseAVX >= 2);\n-  match(Set dst (ReplicateS (LoadS mem)));\n+  predicate(UseAVX >= 2 && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate (LoadS mem)));\n@@ -4256,1 +4241,2 @@\n-  match(Set dst (ReplicateI src));\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate src));\n@@ -4275,1 +4261,2 @@\n-  match(Set dst (ReplicateI (LoadI mem)));\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (Replicate (LoadI mem)));\n@@ -4292,3 +4279,2 @@\n-  match(Set dst (ReplicateB con));\n-  match(Set dst (ReplicateS con));\n-  match(Set dst (ReplicateI con));\n+  predicate(Matcher::is_non_long_integral_vector(n));\n+  match(Set dst (Replicate con));\n@@ -4310,3 +4296,2 @@\n-  match(Set dst (ReplicateB zero));\n-  match(Set dst (ReplicateS zero));\n-  match(Set dst (ReplicateI zero));\n+  predicate(Matcher::is_non_long_integral_vector(n));\n+  match(Set dst (Replicate zero));\n@@ -4326,4 +4311,2 @@\n-  predicate(UseSSE >= 2);\n-  match(Set dst (ReplicateB con));\n-  match(Set dst (ReplicateS con));\n-  match(Set dst (ReplicateI con));\n+  predicate(UseSSE >= 2 && Matcher::is_non_long_integral_vector(n));\n+  match(Set dst (Replicate con));\n@@ -4343,1 +4326,2 @@\n-  match(Set dst (ReplicateL src));\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate src));\n@@ -4363,2 +4347,2 @@\n-  predicate(Matcher::vector_length(n) <= 4);\n-  match(Set dst (ReplicateL src));\n+  predicate(Matcher::vector_length(n) <= 4 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate src));\n@@ -4392,2 +4376,2 @@\n-  predicate(Matcher::vector_length(n) == 8);\n-  match(Set dst (ReplicateL src));\n+  predicate(Matcher::vector_length(n) == 8 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate src));\n@@ -4417,1 +4401,2 @@\n-  match(Set dst (ReplicateL (LoadL mem)));\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate (LoadL mem)));\n@@ -4435,1 +4420,2 @@\n-  match(Set dst (ReplicateL con));\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate con));\n@@ -4446,1 +4432,2 @@\n-  match(Set dst (ReplicateL zero));\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate zero));\n@@ -4460,2 +4447,2 @@\n-  predicate(UseSSE >= 2);\n-  match(Set dst (ReplicateL con));\n+  predicate(UseSSE >= 2 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (Replicate con));\n@@ -4473,2 +4460,2 @@\n-  predicate(UseAVX > 0);\n-  match(Set dst (ReplicateF src));\n+  predicate(UseAVX > 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -4493,2 +4480,2 @@\n-  predicate(UseAVX == 0);\n-  match(Set dst (ReplicateF src));\n+  predicate(UseAVX == 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate src));\n@@ -4503,2 +4490,2 @@\n-  predicate(UseAVX > 0);\n-  match(Set dst (ReplicateF (LoadF mem)));\n+  predicate(UseAVX > 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate (LoadF mem)));\n@@ -4515,1 +4502,2 @@\n-  match(Set dst (ReplicateF con));\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate con));\n@@ -4527,1 +4515,2 @@\n-  match(Set dst (ReplicateF zero));\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (Replicate zero));\n@@ -4544,2 +4533,2 @@\n-  predicate(UseSSE >= 3);\n-  match(Set dst (ReplicateD src));\n+  predicate(UseSSE >= 3 && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (Replicate src));\n@@ -4564,2 +4553,2 @@\n-  predicate(UseSSE < 3);\n-  match(Set dst (ReplicateD src));\n+  predicate(UseSSE < 3 && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (Replicate src));\n@@ -4574,2 +4563,2 @@\n-  predicate(UseSSE >= 3);\n-  match(Set dst (ReplicateD (LoadD mem)));\n+  predicate(UseSSE >= 3 && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (Replicate (LoadD mem)));\n@@ -4590,1 +4579,2 @@\n-  match(Set dst (ReplicateD con));\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (Replicate con));\n@@ -4601,1 +4591,2 @@\n-  match(Set dst (ReplicateD zero));\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (Replicate zero));\n@@ -7425,1 +7416,1 @@\n-    InternalAddress new_mxcsr = $constantaddress((jint)0x3F80);\n+    InternalAddress new_mxcsr = $constantaddress((jint)(EnableX86ECoreOpts ? 0x3FBF : 0x3F80));\n@@ -7442,1 +7433,1 @@\n-    InternalAddress new_mxcsr = $constantaddress((jint)0x3F80);\n+    InternalAddress new_mxcsr = $constantaddress((jint)(EnableX86ECoreOpts ? 0x3FBF : 0x3F80));\n@@ -7457,1 +7448,1 @@\n-    InternalAddress new_mxcsr = $constantaddress((jint)0x3F80);\n+    InternalAddress new_mxcsr = $constantaddress((jint)(EnableX86ECoreOpts ? 0x3FBF : 0x3F80));\n@@ -8999,1 +8990,1 @@\n-instruct vmask_gen(kReg dst, rRegL len, rRegL temp) %{\n+instruct vmask_gen(kReg dst, rRegL len, rRegL temp, rFlagsReg cr) %{\n@@ -9001,1 +8992,1 @@\n-  effect(TEMP temp);\n+  effect(TEMP temp, KILL cr);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":105,"deletions":114,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -730,11 +730,0 @@\n-  \/\/ Record this newly allocated object\n-  void new_instance(NewInlineTypeInstance* object) {\n-    int index = _newobjects.length();\n-    _newobjects.append(object);\n-    if (_fields.at_grow(index, nullptr) == nullptr) {\n-      _fields.at_put(index, new FieldBuffer());\n-    } else {\n-      _fields.at(index)->kill();\n-    }\n-  }\n-\n@@ -1040,7 +1029,0 @@\n-  if (x->as_NewInlineTypeInstance() != nullptr && x->as_NewInlineTypeInstance()->in_larval_state()) {\n-    if (x->as_NewInlineTypeInstance()->on_stack_count() == 1) {\n-      x->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-    } else {\n-      x->as_NewInlineTypeInstance()->increment_on_stack_count();\n-    }\n-  }\n@@ -1053,3 +1035,0 @@\n-  if (x->as_NewInlineTypeInstance() != nullptr) {\n-    x->as_NewInlineTypeInstance()->set_local_index(index);\n-  }\n@@ -1084,3 +1063,0 @@\n-  if (x->as_NewInlineTypeInstance() != nullptr) {\n-    x->as_NewInlineTypeInstance()->set_local_index(index);\n-  }\n@@ -1145,1 +1121,1 @@\n-        NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before);\n+        NewInstance* new_instance = new NewInstance(elem_klass, state_before, false, true);\n@@ -1228,1 +1204,0 @@\n-        update_larva_stack_count(w);\n@@ -1234,2 +1209,0 @@\n-        update_larva_stack_count(w1);\n-        update_larva_stack_count(w2);\n@@ -1240,1 +1213,0 @@\n-        update_larval_state(w);\n@@ -1248,1 +1220,0 @@\n-        update_larval_state(w1);\n@@ -1258,11 +1229,0 @@\n-        \/\/ special handling for the dup_x2\/pop sequence (see JDK-8251046)\n-        if (w1 != nullptr && w1->as_NewInlineTypeInstance() != nullptr) {\n-          ciBytecodeStream s(method());\n-          s.force_bci(bci());\n-          s.next();\n-          if (s.cur_bc() != Bytecodes::_pop) {\n-            w1->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-          } else {\n-            w1->as_NewInlineTypeInstance()->increment_on_stack_count();\n-          }\n-        }\n@@ -1278,2 +1238,0 @@\n-        update_larval_state(w1);\n-        update_larval_state(w2);\n@@ -1290,2 +1248,0 @@\n-        update_larval_state(w1);\n-        update_larval_state(w2);\n@@ -1304,2 +1260,0 @@\n-        update_larval_state(w1);\n-        update_larval_state(w2);\n@@ -1713,1 +1667,1 @@\n-  if ((method()->is_object_constructor() || method()->is_static_vnew_factory()) &&\n+  if (method()->is_object_constructor() &&\n@@ -1920,0 +1874,5 @@\n+  if ((field->is_multifield_base() || field->is_multifield()) &&\n+      (code == Bytecodes::_getfield || code == Bytecodes::_getstatic)) {\n+    assert(false, \"Illegal direct read access to mutifield through getfield bytecode\");\n+  }\n+\n@@ -1956,0 +1915,3 @@\n+      if (field->is_null_free()) {\n+        null_check(val);\n+      }\n@@ -2049,1 +2011,1 @@\n-        } else {\n+        } else {  \/\/ field is flat\n@@ -2087,1 +2049,1 @@\n-              NewInlineTypeInstance* vt = new NewInlineTypeInstance(inline_klass, pending_load_indexed()->state_before());\n+              NewInstance* vt = new NewInstance(inline_klass, pending_load_indexed()->state_before(), false, true);\n@@ -2095,1 +2057,1 @@\n-              NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before);\n+              NewInstance* new_instance = new NewInstance(inline_klass, state_before, false, true);\n@@ -2133,0 +2095,1 @@\n+        null_check(val);\n@@ -2134,4 +2097,14 @@\n-        StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);\n-        if (!needs_patching) store = _memory->store(store);\n-        if (store != nullptr) {\n-          append(store);\n+        if (field->is_null_free()) {\n+          null_check(val);\n+        }\n+        \/\/ Only possible non-unsafe access to multifield base is within vector payload constructors\n+        \/\/ for initializing entire bundle with a default value.\n+        int sec_field_size = type2aelembytes(field_type);\n+        assert(field->secondary_fields_count() == 1 || field->is_multifield_base(), \"\");\n+        for (int i = 0; i < field->secondary_fields_count(); i++) {\n+          ciField* temp = i > 0 ? static_cast<ciMultiField*>(field)->secondary_field_at(i-1) : field;\n+          StoreField* store = new StoreField(obj, offset + i * sec_field_size, temp, val, false, state_before, needs_patching);\n+          if (!needs_patching) store = _memory->store(store);\n+          if (store != nullptr) {\n+            append(store);\n+          }\n@@ -2152,83 +2125,0 @@\n-\/\/ Baseline version of withfield, allocate every time\n-void GraphBuilder::withfield(int field_index) {\n-  \/\/ Save the entire state and re-execute on deopt\n-  ValueStack* state_before = copy_state_before();\n-  state_before->set_should_reexecute(true);\n-\n-  bool will_link;\n-  ciField* field_modify = stream()->get_field(will_link);\n-  ciInstanceKlass* holder = field_modify->holder();\n-  BasicType field_type = field_modify->type()->basic_type();\n-  ValueType* type = as_ValueType(field_type);\n-  Value val = pop(type);\n-  Value obj = apop();\n-  null_check(obj);\n-\n-  if (!holder->is_loaded() || !holder->is_inlinetype() || !will_link) {\n-    apush(append_split(new Deoptimize(holder, state_before)));\n-    return;\n-  }\n-\n-  \/\/ call will_link again to determine if the field is valid.\n-  const bool needs_patching = !field_modify->will_link(method(), Bytecodes::_withfield) ||\n-                              (!field_modify->is_flat() && PatchALot);\n-  const int offset_modify = !needs_patching ? field_modify->offset_in_bytes() : -1;\n-\n-  scope()->set_wrote_final();\n-  scope()->set_wrote_fields();\n-\n-  NewInlineTypeInstance* new_instance;\n-  if (obj->as_NewInlineTypeInstance() != nullptr && obj->as_NewInlineTypeInstance()->in_larval_state()) {\n-    new_instance = obj->as_NewInlineTypeInstance();\n-    apush(append_split(new_instance));\n-  } else {\n-    new_instance = new NewInlineTypeInstance(holder->as_inline_klass(), state_before);\n-    _memory->new_instance(new_instance);\n-    apush(append_split(new_instance));\n-\n-    \/\/ Initialize fields which are not modified\n-    for (int i = 0; i < holder->nof_nonstatic_fields(); i++) {\n-      ciField* field = holder->nonstatic_field_at(i);\n-      int offset = field->offset_in_bytes();\n-      \/\/ Don't use offset_modify here, it might be set to -1 if needs_patching\n-      if (offset != field_modify->offset_in_bytes()) {\n-        if (field->is_flat()) {\n-          ciInlineKlass* vk = field->type()->as_inline_klass();\n-          if (!vk->is_empty()) {\n-            copy_inline_content(vk, obj, offset, new_instance, vk->first_field_offset(), state_before, field);\n-          }\n-        } else {\n-          for (int i = 0, sec_offset = 0; i < field->secondary_fields_count(); i++) {\n-            ciField* temp = i > 0 ? static_cast<ciMultiField*>(field)->secondary_field_at(i-1) : field;\n-            LoadField* load = new LoadField(obj, offset + sec_offset, temp, false, state_before, false);\n-            Value replacement = append(load);\n-            StoreField* store = new StoreField(new_instance, offset + sec_offset, temp, replacement, false, state_before, false);\n-            append(store);\n-            sec_offset += type2aelembytes(as_BasicType(load->type()));\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Field to modify\n-  if (field_type == T_BOOLEAN) {\n-    Value mask = append(new Constant(new IntConstant(1)));\n-    val = append(new LogicOp(Bytecodes::_iand, val, mask));\n-  }\n-  if (field_modify->is_flat()) {\n-    assert(!needs_patching, \"Can't patch flat inline type field access\");\n-    ciInlineKlass* vk = field_modify->type()->as_inline_klass();\n-    if (!vk->is_empty()) {\n-      copy_inline_content(vk, val, vk->first_field_offset(), new_instance, offset_modify, state_before, field_modify);\n-    }\n-  } else {\n-    int sec_field_size = type2aelembytes(field_type);\n-    for (int i = 0; i < field_modify->secondary_fields_count(); i++) {\n-      ciField* temp = i > 0 ? static_cast<ciMultiField*>(field_modify)->secondary_field_at(i-1) : field_modify;\n-      StoreField* store = new StoreField(new_instance, offset_modify + i * sec_field_size, temp, val, false, state_before, needs_patching);\n-      append(store);\n-    }\n-  }\n-}\n-\n@@ -2587,2 +2477,1 @@\n-  Invoke* result = new Invoke(code, result_type, recv, args, target, state_before,\n-                              declared_signature->returns_null_free_inline_type());\n+  Invoke* result = new Invoke(code, result_type, recv, args, target, state_before);\n@@ -2605,9 +2494,1 @@\n-  NewInstance* new_instance = new NewInstance(klass->as_instance_klass(), state_before, stream()->is_unresolved_klass());\n-  _memory->new_instance(new_instance);\n-  apush(append_split(new_instance));\n-}\n-\n-void GraphBuilder::default_value(int klass_index) {\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n-      klass->as_inline_klass()->is_initialized()) {\n+      klass->as_inline_klass()->is_initialized() && klass->as_inline_klass()->is_empty()) {\n@@ -2618,1 +2499,3 @@\n-    apush(append_split(new Deoptimize(klass, copy_state_before())));\n+    NewInstance* new_instance = new NewInstance(klass->as_instance_klass(), state_before, stream()->is_unresolved_klass(), false);\n+    _memory->new_instance(new_instance);\n+    apush(append_split(new_instance));\n@@ -2630,2 +2513,1 @@\n-  bool null_free = stream()->has_Q_signature();\n-  NewArray* n = new NewObjectArray(klass, ipop(), state_before, null_free);\n+  NewArray* n = new NewObjectArray(klass, ipop(), state_before);\n@@ -2656,2 +2538,1 @@\n-  bool null_free = stream()->has_Q_signature();\n-  CheckCast* c = new CheckCast(klass, apop(), state_before, null_free);\n+  CheckCast* c = new CheckCast(klass, apop(), state_before);\n@@ -2853,1 +2734,1 @@\n-  if (value->as_NewArray() != nullptr || value->as_NewInstance() != nullptr || value->as_NewInlineTypeInstance() != nullptr) {\n+  if (value->as_NewArray() != nullptr || value->as_NewInstance() != nullptr) {\n@@ -3382,2 +3263,0 @@\n-      case Bytecodes::_aconst_init   : default_value(s.get_index_u2()); break;\n-      case Bytecodes::_withfield      : withfield(s.get_index_u2()); break;\n@@ -3685,1 +3564,1 @@\n-    state->store_local(idx, new Local(type, vt, idx, false, sig->is_null_free_at(i)));\n+    state->store_local(idx, new Local(type, vt, idx, false, false));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":37,"deletions":158,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -533,2 +533,1 @@\n-       sym->char_at(1) == JVM_SIGNATURE_CLASS ||\n-       sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT )) {\n+       sym->char_at(1) == JVM_SIGNATURE_CLASS )) {\n@@ -547,2 +546,1 @@\n-      bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n-      return ciArrayKlass::make(elem_klass, null_free_array);\n+      return ciArrayKlass::make(elem_klass);\n@@ -578,11 +576,0 @@\n-  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n-    \/\/ An unloaded array class of inline types is an ObjArrayKlass, an\n-    \/\/ unloaded inline type class is an InstanceKlass. For consistency,\n-    \/\/ make the signature of the unloaded array of inline type use L\n-    \/\/ rather than Q.\n-    char* new_name = name_buffer(sym->utf8_length()+1);\n-    strncpy(new_name, (char*)sym->base(), sym->utf8_length());\n-    new_name[i] = JVM_SIGNATURE_CLASS;\n-    new_name[sym->utf8_length()] = '\\0';\n-    return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));\n-  }\n@@ -675,8 +662,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciEnv::is_inline_klass\n-\/\/\n-\/\/ Check if the klass is an inline klass.\n-bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n-  GUARDED_VM_ENTRY(return cpool->klass_name_at(index)->is_Q_signature();)\n-}\n-\n@@ -779,5 +758,1 @@\n-    if (klass->is_loaded() && tag.is_Qdescriptor_klass()) {\n-      return ciConstant(T_OBJECT, klass->as_inline_klass()->val_mirror());\n-    } else {\n-      return ciConstant(T_OBJECT, mirror);\n-    }\n+    return ciConstant(T_OBJECT, mirror);\n@@ -1570,2 +1545,2 @@\n-    ConstantPoolCacheEntry* cp_cache_entry = cp->cache()->entry_at(cp->decode_cpcache_index(index));\n-    if (cp_cache_entry->is_resolved(Bytecodes::_invokehandle)) {\n+    ResolvedMethodEntry* method_entry = cp->resolved_method_entry_at(index);\n+    if (method_entry->is_resolved(Bytecodes::_invokehandle)) {\n@@ -1573,2 +1548,2 @@\n-      Method* adapter = cp_cache_entry->f1_as_method();\n-      oop appendix = cp_cache_entry->appendix_if_resolved(cp);\n+      Method* adapter = method_entry->method();\n+      oop appendix = cp->cache()->appendix_if_resolved(method_entry);\n@@ -1626,1 +1601,1 @@\n-              int cp_cache_index = bcs.get_index_u2_cpcache();\n+              int cp_cache_index = bcs.get_index_u2();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":8,"deletions":33,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-  bool       has_Q_signature(const constantPoolHandle& cpool,\n-                             int klass_index);\n@@ -328,1 +326,1 @@\n-  bool failing() { return _failure_reason != nullptr; }\n+  bool failing() const { return _failure_reason != nullptr; }\n@@ -331,1 +329,1 @@\n-  const char* failure_reason() { return _failure_reason; }\n+  const char* failure_reason() const { return _failure_reason; }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -110,2 +110,1 @@\n-  \/\/ this is needed if the field class is not yet loaded.\n-  _is_null_free = _signature->is_Q_signature();\n+  _is_null_free = false;\n@@ -419,2 +418,2 @@\n-         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield  ||\n-         bc == Bytecodes::_withfield, \"unexpected bytecode\");\n+         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield,\n+         \"unexpected bytecode\");\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,14 +121,0 @@\n-ciInstance* ciInlineKlass::ref_instance() const {\n-  GUARDED_VM_ENTRY(\n-    oop ref_mirror = to_InlineKlass()->ref_mirror();\n-    return CURRENT_ENV->get_instance(ref_mirror);\n-  )\n-}\n-\n-ciInstance* ciInlineKlass::val_instance() const {\n-  GUARDED_VM_ENTRY(\n-    oop val_mirror = to_InlineKlass()->val_mirror();\n-    return CURRENT_ENV->get_instance(val_mirror);\n-  )\n-}\n-\n@@ -155,7 +141,0 @@\n-ciInstance* ciInlineKlass::ref_mirror() {\n-  GUARDED_VM_ENTRY(return CURRENT_ENV->get_instance(to_InlineKlass()->ref_mirror());)\n-}\n-\n-ciInstance* ciInlineKlass::val_mirror() {\n-  GUARDED_VM_ENTRY(return CURRENT_ENV->get_instance(to_InlineKlass()->val_mirror());)\n-}\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,2 +88,0 @@\n-  ciInstance* ref_instance() const;\n-  ciInstance* val_instance() const;\n@@ -95,2 +93,0 @@\n-  ciInstance* ref_mirror();\n-  ciInstance* val_mirror();\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -780,1 +780,1 @@\n-    return !get_instanceKlass()->carries_identity_modifier();\n+    return !get_instanceKlass()->access_flags().is_identity_class() || is_java_lang_Object() ;\n@@ -856,1 +856,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall-through\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -176,1 +176,0 @@\n-  case Bytecodes::_aconst_init:\n@@ -211,10 +210,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciBytecodeStream::is_inline_klass\n-\/\/\n-\/\/ Check if the klass is an inline klass.\n-bool ciBytecodeStream::has_Q_signature() const {\n-  VM_ENTRY_MARK;\n-  constantPoolHandle cpool(THREAD, _method->get_Method()->constants());\n-  return CURRENT_ENV->has_Q_signature(cpool, get_klass_index());\n-}\n-\n@@ -311,2 +300,1 @@\n-         cur_bc() == Bytecodes::_putstatic ||\n-         cur_bc() == Bytecodes::_withfield, \"wrong bc\");\n+         cur_bc() == Bytecodes::_putstatic, \"wrong bc\");\n@@ -374,1 +362,1 @@\n-  return get_index_u2_cpcache();\n+  return get_index_u2();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -519,5 +520,1 @@\n-        if (name->is_Q_signature()) {\n-          cp->unresolved_qdescriptor_at_put(index, class_index, num_klasses++);\n-        } else {\n-          cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n-        }\n+        cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n@@ -723,2 +720,1 @@\n-          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature,\n-          \/\/ or if it is an inline type, <vnew> with return.\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n@@ -728,2 +724,1 @@\n-            if (name != vmSymbols::object_initializer_name() &&\n-                name != vmSymbols::inline_factory_name()) {\n+            if (name != vmSymbols::object_initializer_name()) {\n@@ -734,7 +729,2 @@\n-            } else if (!Signature::is_void_method(signature)) {\n-              \/\/ if return type is non-void then it must be an inline type\n-              if (name == vmSymbols::object_initializer_name() ||\n-                  !EnableValhalla || !supports_inline_types() ||\n-                  !signature->ends_with(JVM_SIGNATURE_ENDCLASS)) {\n-                throwIllegalSignature(\"Method\", name, signature, CHECK);\n-              }\n+            } else if (!Signature::is_void_method(signature)) {  \/\/ must have void signature.\n+              throwIllegalSignature(\"Method\", name, signature, CHECK);\n@@ -760,11 +750,1 @@\n-            if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) { \/\/ <vnew>\n-              \/\/ <vnew> factory methods must be non-void return and invokeStatic.\n-              const int signature_ref_index =\n-                cp->signature_ref_index_at(name_and_type_ref_index);\n-              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n-              if (signature->is_void_method_signature() || ref_kind != JVM_REF_invokeStatic) {\n-                classfile_parse_error(\n-                  \"Bad factory method name at constant pool index %u in class file %s\",\n-                  name_ref_index, CHECK);\n-              }\n-            } else if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n+            if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n@@ -840,23 +820,5 @@\n-  if (super_type->carries_identity_modifier()) {\n-    if (current->carries_value_modifier()) {\n-        ResourceMark rm(THREAD);\n-        Exceptions::fthrow(\n-          THREAD_AND_LOCATION,\n-          vmSymbols::java_lang_IncompatibleClassChangeError(),\n-          \"Value type %s has an identity type as supertype\",\n-          current->class_name()->as_klass_external_name());\n-        return;\n-      }\n-    current->set_carries_identity_modifier();\n-  }\n-  if (super_type->carries_value_modifier()) {\n-    if (current->carries_identity_modifier()) {\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_IncompatibleClassChangeError(),\n-        \"Identity type %s has a value type as supertype\",\n-        current->class_name()->as_klass_external_name());\n-      return;\n-    }\n-    current->set_carries_value_modifier();\n+  if (super_type->access_flags().is_identity_class() && !current->access_flags().is_identity_class()\n+      && super_type->super() != nullptr \/* Super is not j.l.Object *\/) {\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Value type %s has an identity type as supertype\",\n+                current->class_name()->as_klass_external_name()));\n@@ -1513,1 +1475,1 @@\n-  bool is_inline_type = class_access_flags.is_value_class() && !class_access_flags.is_abstract();\n+  bool is_inline_type = !class_access_flags.is_identity_class() && !class_access_flags.is_abstract();\n@@ -1624,0 +1586,1 @@\n+    \/\/ This use of T_PRIMITIVE_OBJECT is not valid anymore => FIXME (relate to cleanup (removal?) of FiedAllocationCount\n@@ -1626,5 +1589,1 @@\n-    \/\/ Here, we still detect that the field's type is an inline type by checking if it has\n-    \/\/ a Q-descriptor. This test will be replaced later by something not relying on Q-desriptors.\n-    \/\/ From this point forward, checking if a field's type is an inline type should be performed\n-    \/\/ using the inline_type flag of FieldFlags, and not by looking for a Q-descriptor in its signature\n-    if (type == T_PRIMITIVE_OBJECT || is_null_restricted) fieldFlags.update_null_free_inline_type(true);\n+    if (is_null_restricted) fieldFlags.update_null_free_inline_type(true);\n@@ -2093,5 +2052,0 @@\n-  const char* class_note = \"\";\n-  if (is_inline_type() && name == vmSymbols::object_initializer_name()) {\n-    class_note = \" (an inline class)\";\n-  }\n-\n@@ -2101,2 +2055,2 @@\n-      \"%s \\\"%s\\\" in class %s%s has illegal signature \\\"%s\\\"\", type,\n-      name->as_C_string(), _class_name->as_C_string(), class_note, sig->as_C_string());\n+      \"%s \\\"%s\\\" in class %s has illegal signature \\\"%s\\\"\", type,\n+      name->as_C_string(), _class_name->as_C_string(), sig->as_C_string());\n@@ -2467,48 +2421,3 @@\n-  if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) {\n-    if (is_interface) {\n-      classfile_parse_error(\"Interface cannot have a method named <vnew>, class file %s\", CHECK_NULL);\n-    } else if (!is_value_class) {\n-       classfile_parse_error(\"Identity class cannot have a method <vnew>, class file %s\", CHECK_NULL);\n-    } else if (signature->is_void_method_signature()) {\n-       classfile_parse_error(\"Factory method <vnew> must have a non-void return type, class file %s\", CHECK_NULL);\n-    } else { \/\/ also OK, a static factory, as long as the return value is good\n-      bool ok = false;\n-      SignatureStream ss((Symbol*) signature, true);\n-      while (!ss.at_return_type())  ss.next();\n-      if (ss.is_reference()) {\n-        Symbol* ret = ss.as_symbol();\n-        const Symbol* required = class_name();\n-        if (is_hidden()) {\n-          \/\/ The original class name for hidden classes changed.\n-          \/\/\/ So using the original name in the return type is no longer valid.\n-          required = vmSymbols::java_lang_Object();\n-        }\n-        ok = (ret == required);\n-      }\n-      if (!ok) {\n-        throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-      }\n-      \/\/ factory method, with a non-void return.  No other\n-      \/\/ definition of <vnew> is possible.\n-      \/\/\n-      \/\/ The verifier (in verify_invoke_instructions) will inspect the\n-      \/\/ signature of any attempt to invoke <vnew>, and ensure that it\n-      \/\/ returns non-void.\n-    }\n-  }\n-\n-  if (name == vmSymbols::object_initializer_name()) {\n-    if (is_interface) {\n-      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", CHECK_NULL);\n-    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n-      \/\/ OK, a constructor\n-    } else {\n-      \/\/ not OK, so throw the same error as in verify_legal_method_signature.\n-      throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-    }\n-    \/\/ A declared <init> method must always be a non-static\n-    \/\/ object constructor, with a void return.\n-    \/\/\n-    \/\/ The verifier (in verify_invoke_instructions) will inspect the\n-    \/\/ signature of any attempt to invoke <init>, and ensure that it\n-    \/\/ returns void.\n+  if (name == vmSymbols::object_initializer_name() && is_interface) {\n+    classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n+    return nullptr;\n@@ -2520,1 +2429,1 @@\n-        && !carries_identity_modifier()) {\n+        && !_access_flags.is_identity_class()) {\n@@ -3160,1 +3069,1 @@\n-  if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {\n+  if (JvmtiExport::can_maintain_original_method_order() || CDSConfig::is_dumping_archive()) {\n@@ -3174,1 +3083,1 @@\n-  if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {\n+  if (JvmtiExport::can_maintain_original_method_order() || CDSConfig::is_dumping_archive()) {\n@@ -3367,2 +3276,1 @@\n-    const Symbol* outer_class_name = nullptr;\n-      outer_class_name = cp->klass_name_at(outer_class_info_index);\n+      const Symbol* const outer_class_name = cp->klass_name_at(outer_class_info_index);\n@@ -3390,3 +3298,0 @@\n-    if (supports_inline_types()) {\n-      recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY;\n-    }\n@@ -3402,7 +3307,5 @@\n-    if (EnableValhalla) {\n-      if (!supports_inline_types()) {\n-        const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n-        const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n-        if (!is_module && !is_interface) {\n-          flags |= JVM_ACC_IDENTITY;\n-        }\n+    if (!supports_inline_types()) {\n+      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+      if (!is_module && !is_interface) {\n+        flags |= JVM_ACC_IDENTITY;\n@@ -3413,1 +3316,1 @@\n-    verify_legal_class_modifiers(flags, name, outer_class_name, false, CHECK_0);\n+    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n@@ -4267,0 +4170,1 @@\n+  this_klass->set_inline_type_field_klasses_array(_inline_type_field_klasses);\n@@ -4553,1 +4457,1 @@\n-         (_major_version == JAVA_22_VERSION \/*&& _minor_version == JAVA_PREVIEW_MINOR_VERSION*\/); \/\/ JAVA_PREVIEW_MINOR_VERSION not yet implemented by javac, check JVMS draft\n+         (_major_version == JAVA_22_VERSION && _minor_version == JAVA_PREVIEW_MINOR_VERSION);\n@@ -4655,1 +4559,1 @@\n-    if (this_klass->access_flags().is_value_class() &&\n+    if (!this_klass->access_flags().is_identity_class() &&\n@@ -4748,0 +4652,1 @@\n+        return;\n@@ -4755,0 +4660,1 @@\n+        return;\n@@ -4843,10 +4749,11 @@\n-\/\/ utility function to skip over internal jdk primitive classes used to override the need for passing\n-\/\/ an explict JVM flag EnablePrimitiveClasses.\n-bool ClassFileParser::is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const {\n-  if (outer_class &&\n-      inner_class &&\n-      (vmSymbols::jdk_internal_vm_vector_VectorSupport() == outer_class ||\n-       vmSymbols::jdk_internal_vm_vector_VectorPayloadMF() == outer_class)) {\n-    if (strstr(inner_class, \"VectorPayloadMF\")) {\n-      return true;\n-    }\n+\/\/ utility function to skip over internal jdk primitive classes while performing some\n+\/\/ verification checks.\n+bool ClassFileParser::is_jdk_internal_class(const Symbol* class_name) {\n+  if (class_name &&\n+       (vmSymbols::jdk_internal_vm_vector_VectorSupport() == class_name ||\n+         vmSymbols::jdk_internal_vm_vector_VectorPayload() == class_name ||\n+         vmSymbols::jdk_internal_vm_vector_Vector() == class_name ||\n+         vmSymbols::jdk_internal_vm_vector_VectorMask() == class_name ||\n+         vmSymbols::jdk_internal_vm_vector_VectorShuffle() == class_name ||\n+         vmSymbols::jdk_internal_vm_vector_VectorPayloadMF() == class_name)) {\n+    return true;\n@@ -4859,1 +4766,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, const Symbol* outer_class, bool is_Object, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n@@ -4861,3 +4768,0 @@\n-  const bool is_value_class = (flags & JVM_ACC_VALUE) != 0;\n-  const bool is_primitive_class = (flags & JVM_ACC_PRIMITIVE) != 0;\n-  const bool is_identity_class = (flags & JVM_ACC_IDENTITY) != 0;\n@@ -4876,23 +4780,1 @@\n-  if (is_value_class && !EnableValhalla) {\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_ClassFormatError(),\n-        \"Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla\",\n-        _class_name->as_C_string()\n-      );\n-    return;\n-  }\n-\n-  if (is_primitive_class && !is_jdk_internal_class(outer_class, name) && !EnablePrimitiveClasses) {\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_ClassFormatError(),\n-        \"Class modifier ACC_PRIMITIVE in class %s requires option -XX:+EnablePrimitiveClasses\",\n-        _class_name->as_C_string()\n-      );\n-    return;\n-  }\n-\n-  \/\/ if (!_need_verify) { return; }\n+  if (!_need_verify) { return; }\n@@ -4903,1 +4785,1 @@\n-  const bool is_super      = (flags & JVM_ACC_SUPER)      != 0;\n+  const bool is_identity   = (flags & JVM_ACC_IDENTITY)   != 0;\n@@ -4910,6 +4792,2 @@\n-      (is_interface && major_gte_1_5 && ((is_super && (!EnableValhalla || !supports_inline_types())) || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n-      (!is_interface && major_gte_1_5 && is_annotation) ||\n-      (is_value_class && is_enum) ||\n-      (is_identity_class && is_value_class) ||\n-      (EnableValhalla && supports_inline_types() && !is_module && !is_abstract && !is_Object && !(is_identity_class || is_value_class) && !is_inner_class) ||\n-      (EnablePrimitiveClasses && supports_inline_types() && is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n+      (is_interface && major_gte_1_5 && (is_identity || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (!is_interface && major_gte_1_5 && is_annotation)) {\n@@ -4918,3 +4796,1 @@\n-    if (is_value_class)  class_note = \" (a value class)\";\n-    if (is_primitive_class)  class_note = \" (a primitive class)\";\n-    if (is_value_class && is_identity_class) class_note = \" (a value and identity class)\";\n+    if (!is_identity)  class_note = \" (a value class)\";\n@@ -4991,1 +4867,1 @@\n-    if (!Arguments::enable_preview()) {\n+    if (!Arguments::enable_preview() && !is_jdk_internal_class(class_name)) {\n@@ -5020,1 +4896,0 @@\n-  const bool is_value_class = class_access_flags.is_value_class();\n@@ -5035,1 +4910,1 @@\n-      if (is_value_class && !is_abstract && !is_static && !is_final) {\n+      if (!is_identity_class && !is_abstract && !is_static && !is_final) {\n@@ -5074,1 +4949,1 @@\n-  const bool is_factory      = (name == vmSymbols::inline_factory_name() && supports_inline_types());\n+  \/\/ LW401 CR required: removal of value factories support\n@@ -5076,1 +4951,1 @@\n-  const bool is_value_class  = class_access_flags.is_value_class();\n+  const bool is_value_class  = !class_access_flags.is_identity_class();\n@@ -5116,7 +4991,1 @@\n-      if (is_factory) { \/\/ <vnew> factory method\n-        if (is_final || is_synchronized || is_native || !is_static ||\n-            is_abstract || is_bridge) {\n-          is_illegal = true;\n-          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n-        }\n-      } else if (is_initializer) {\n+      if (is_initializer) {\n@@ -5218,1 +5087,0 @@\n-        \/\/ if (_cp->tag_at(_preload_classes->at(i)).is_klass()) continue;\n@@ -5326,10 +5194,0 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n-      \/\/ Can't enable this check fully until JDK upgrades the bytecode generators (TODO: JDK-8270852).\n-      \/\/ For now, compare to class file version 51 so old verifier doesn't see Q signatures.\n-      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses)) {\n-        classfile_parse_error(\"Class name contains illegal Q-signature \"\n-                              \"in descriptor in class file %s, requires option -XX:+EnablePrimitiveClasses\",\n-                              CHECK_0);\n-        return nullptr;\n-      }\n-      \/\/ fall through\n@@ -5474,3 +5332,1 @@\n-          name == vmSymbols::class_initializer_name()  ||\n-          (EnableValhalla && supports_inline_types() &&\n-          name == vmSymbols::inline_factory_name())) {\n+          name == vmSymbols::class_initializer_name()) {\n@@ -5508,3 +5364,0 @@\n-  if ((!supports_inline_types() || !EnablePrimitiveClasses) && (signature->is_Q_signature() || signature->is_Q_array_signature())) {\n-    throwIllegalSignature(\"Field\", name, signature, CHECK);\n-  }\n@@ -5538,8 +5391,6 @@\n-  if (!is_value_class()) {\n-    int sig_length = signature->utf8_length();\n-    if (name->utf8_length() > 0 &&\n-      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-      sig_length > 0 &&\n-      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n-      throwIllegalSignature(\"Method\", name, signature, THREAD);\n-    }\n+  int sig_length = signature->utf8_length();\n+  if (name->utf8_length() > 0 &&\n+    name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+    sig_length > 0 &&\n+    signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n@@ -5760,6 +5611,0 @@\n-  if (carries_identity_modifier()) {\n-    ik->set_carries_identity_modifier();\n-  } else if (carries_value_modifier()) {\n-    ik->set_carries_value_modifier();\n-  }\n-\n@@ -5793,0 +5638,1 @@\n+  assert(nullptr == _inline_type_field_klasses, \"invariant\");\n@@ -5944,2 +5790,2 @@\n-        Klass* k = _inline_type_field_klasses->at(fs.index());\n-        ik->set_inline_type_field_klass(fs.index(), k);\n+        Klass* k = ik->inline_type_field_klasses_array()->at(fs.index());\n+        assert(k->is_inline_klass(), \"must be\");\n@@ -6109,2 +5955,0 @@\n-  _carries_value_modifier(false),\n-  _carries_identity_modifier(false),\n@@ -6129,1 +5973,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_static_archive()) {\n@@ -6169,0 +6013,1 @@\n+  _inline_type_field_klasses = nullptr;\n@@ -6310,4 +6155,0 @@\n-  \/\/ JVM_ACC_VALUE and JVM_ACC_PRIMITIVE supported version\n-  if (supports_inline_types()) {\n-    recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE;\n-  }\n@@ -6323,0 +6164,10 @@\n+  \/\/ Fixing ACC_SUPER\/ACC_IDENTITY for old class files\n+  if (!supports_inline_types()) {\n+    const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+    const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+    if (!is_module && !is_interface) {\n+      flags |= JVM_ACC_IDENTITY;\n+    }\n+  }\n+\n+\n@@ -6336,9 +6187,1 @@\n-  if (EnableValhalla) {\n-    if(!supports_inline_types()) {\n-      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n-      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n-      if (!is_module && !is_interface && !is_java_lang_Object) {\n-        flags |= JVM_ACC_IDENTITY;\n-      }\n-    }\n-  }\n+  verify_legal_class_modifiers(flags, nullptr, is_java_lang_Object, CHECK);\n@@ -6348,8 +6191,0 @@\n-  if (EnableValhalla) {\n-    if (_access_flags.is_identity_class()) set_carries_identity_modifier();\n-    if (_access_flags.is_value_class()) set_carries_value_modifier();\n-    if (carries_identity_modifier() && carries_value_modifier()) {\n-      classfile_parse_error(\"Class %s has both ACC_IDENTITY and ACC_VALUE modifiers\", THREAD);\n-    }\n-  }\n-\n@@ -6435,3 +6270,0 @@\n-  const Symbol* super_klass_name = _super_class_index ? cp->klass_name_at(_super_class_index) : nullptr;\n-  verify_legal_class_modifiers(flags, _class_name->as_C_string(), super_klass_name, is_java_lang_Object, CHECK);\n-\n@@ -6461,1 +6293,1 @@\n-                is_value_class(),\n+                !is_identity_class(),\n@@ -6499,1 +6331,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_static_archive()) {\n@@ -6532,12 +6364,0 @@\n-bool ClassFileParser::is_jdk_internal_class(const Klass* cls) {\n-  while(cls) {\n-    const Symbol* cls_name = cls->name();\n-    if(cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayload() ||\n-       cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayloadMF()) {\n-      return true;\n-    }\n-    cls = cls->super();\n-  }\n-  return false;\n-}\n-\n@@ -6572,1 +6392,1 @@\n-                       SystemDictionary::resolve_super_or_fail(_class_name,\n+                       SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name,\n@@ -6595,1 +6415,1 @@\n-    if (EnableValhalla && _access_flags.is_value_class()) {\n+    if (EnableValhalla && !_access_flags.is_identity_class()) {\n@@ -6610,1 +6430,1 @@\n-  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && !_access_flags.is_value_class()) {\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && _access_flags.is_identity_class()) {\n@@ -6615,1 +6435,1 @@\n-  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_ImplicitlyConstructible) && !_access_flags.is_value_class()) {\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_ImplicitlyConstructible) && _access_flags.is_identity_class()) {\n@@ -6623,13 +6443,8 @@\n-  if (EnableValhalla && _access_flags.is_value_class()) {\n-    if (_access_flags.is_primitive_class()) {\n-      _must_be_atomic = false;             \/\/ old semantic, primitive classes are always non-atomic\n-      _is_implicitly_constructible = true; \/\/ old semantic, primitive classes are always implicitly constructible\n-    } else {\n-      if (_super_klass != nullptr  \/\/ not j.l.Object\n-               && _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n-               && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n-        _must_be_atomic = false;\n-      }\n-      if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)) {\n-        _is_implicitly_constructible = true;\n-      }\n+  if (EnableValhalla && !_access_flags.is_identity_class()) {\n+    if (_super_klass != nullptr  \/\/ not j.l.Object\n+              && _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+              && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+      _must_be_atomic = false;\n+    }\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)) {\n+      _is_implicitly_constructible = true;\n@@ -6664,1 +6479,1 @@\n-        interf = SystemDictionary::resolve_super_or_fail(\n+        interf = SystemDictionary::resolve_with_circularity_detection_or_fail(\n@@ -6727,1 +6542,1 @@\n-  if (EnableValhalla || is_jdk_internal_class(_super_klass)) {\n+  if (EnableValhalla) {\n@@ -6734,0 +6549,1 @@\n+      if (fieldinfo.access_flags().is_static()) continue;  \/\/ Only non-static fields are processed at load time\n@@ -6735,5 +6551,13 @@\n-      if (fieldinfo.field_flags().is_null_free_inline_type() && !fieldinfo.access_flags().is_static()) {\n-        \/\/ Pre-load classes of fields that are candidate for flattening\n-        Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(sig,\n-            Handle(THREAD, _loader_data->class_loader()),\n-            _protection_domain, true, CHECK);\n+      if (fieldinfo.field_flags().is_null_free_inline_type()) {\n+        \/\/ Pre-load classes of null-free fields that are candidate for flattening\n+        TempNewSymbol s = Signature::strip_envelope(sig);\n+        if (s == _class_name) {\n+          THROW_MSG(vmSymbols::java_lang_ClassCircularityError(), err_msg(\"Class %s cannot have a null-free non-static field of its own type\", _class_name->as_C_string()));\n+        }\n+        log_info(class, preload)(\"Preloading class %s during loading of class %s. Cause: a null-free non-static field is declared with this type\", s->as_C_string(), _class_name->as_C_string());\n+        Klass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, s, Handle(THREAD, _loader_data->class_loader()), _protection_domain, false, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          log_warning(class, preload)(\"Preloading of class %s during loading of class %s (cause: null-free non-static field) failed: %s\",\n+                                      s->as_C_string(), _class_name->as_C_string(), PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          return; \/\/ Exception is still pending\n+        }\n@@ -6741,1 +6565,8 @@\n-        if (!klass->access_flags().is_value_class()) {\n+        if (klass->access_flags().is_identity_class()) {\n+          ResourceMark rm(THREAD);\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Class %s expects class %s to be a value class, but it is an identity class\",\n+                    _class_name->as_C_string(),\n+                    InstanceKlass::cast(klass)->external_name()));\n+        }\n+        if (klass->is_abstract()) {\n@@ -6745,1 +6576,1 @@\n-                    err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                    err_msg(\"Class %s expects class %s to be concrete value type, but it is an abstract class\",\n@@ -6749,3 +6580,15 @@\n-        _inline_type_field_klasses->at_put(fieldinfo.index(), InlineKlass::cast(klass));\n-      } else {\n-        if (sig != _class_name && is_class_in_preload_attribute(sig)) {\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        if (!vk->is_implicitly_constructible()) {\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"class %s is not implicitly constructible and it is used in a null restricted non-static field (not supported)\",\n+                    klass->name()->as_C_string()));\n+        }\n+        _inline_type_field_klasses->at_put(fieldinfo.index(), vk);\n+        log_info(class, preload)(\"Preloading of class %s during loading of class %s (cause: null-free non-static field) succeeded\", s->as_C_string(), _class_name->as_C_string());\n+      } else if (Signature::has_envelope(sig)) {\n+        \/\/ Preloading classes for nullable fields that are listed in the Preload attribute\n+        \/\/ Those classes would be required later for the flattening of nullable inline type fields\n+        TempNewSymbol name = Signature::strip_envelope(sig);\n+        if (name != _class_name && is_class_in_preload_attribute(name)) {\n+          if (ClassFileParser::is_jdk_internal_class(name)) continue;\n+          log_info(class, preload)(\"Preloading class %s during loading of class %s. Cause: field type in Preload attribute\", name->as_C_string(), _class_name->as_C_string());\n@@ -6753,5 +6596,1 @@\n-          Klass* klass = SystemDictionary::resolve_or_null(sig, Handle(THREAD, loader), _protection_domain, THREAD);\n-          if (HAS_PENDING_EXCEPTION) {\n-            CLEAR_PENDING_EXCEPTION;\n-          }\n-          \/\/ Should we verify that klass is a value class? What the PreLoad attribute spec says about that?\n+          Klass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, name, Handle(THREAD, loader), _protection_domain, false, THREAD);\n@@ -6759,0 +6598,1 @@\n+            if (VectorSupport::is_vector(klass)) continue;\n@@ -6761,1 +6601,1 @@\n-              log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute\", sig->as_C_string(), _class_name->as_C_string());\n+              log_info(class, preload)(\"Preloading of class %s during loading of class %s (cause: field type in Preload attribute) succeeded\", name->as_C_string(), _class_name->as_C_string());\n@@ -6763,1 +6603,2 @@\n-              log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute but loaded class is not a value class\", sig->as_C_string(), _class_name->as_C_string());\n+              \/\/ Non value class are allowed by the current spec, but it could be an indication of an issue so let's log a warning\n+              log_warning(class, preload)(\"Preloading class %s during loading of class %s (cause: field type in Preload attribute) but loaded class is not a value class\", name->as_C_string(), _class_name->as_C_string());\n@@ -6765,2 +6606,7 @@\n-          } else {\n-            log_warning(class, preload)(\"Preloading of class %s during linking of class %s (Preload attribute) failed\", sig->as_C_string(), _class_name->as_C_string());\n+            } else {\n+            log_warning(class, preload)(\"Preloading of class %s during loading of class %s (cause: field type in Preload attribute) failed : %s\",\n+                                          name->as_C_string(), _class_name->as_C_string(), PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          }\n+          \/\/ Loads triggered by the preload attribute are speculative, failures must not impact loading of current class\n+          if (HAS_PENDING_EXCEPTION) {\n+            CLEAR_PENDING_EXCEPTION;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":146,"deletions":300,"binary":false,"changes":446,"status":"modified"},{"patch":"@@ -213,2 +213,0 @@\n-  bool _carries_value_modifier;      \/\/ Has ACC_VALUE mddifier or one of its super types has\n-  bool _carries_identity_modifier;   \/\/ Has ACC_IDENTITY modifier or one of its super types has\n@@ -507,1 +505,1 @@\n-  void verify_legal_class_modifiers(jint flags, const char* name, const Symbol* out_class, bool is_Object, TRAPS) const;\n+  void verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const;\n@@ -527,2 +525,0 @@\n-  bool is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const;\n-  bool is_jdk_internal_class(const Klass* cls);\n@@ -603,2 +599,1 @@\n-  bool is_inline_type() const { return _access_flags.is_value_class() && !_access_flags.is_interface() && !_access_flags.is_abstract(); }\n-  bool is_value_class() const { return _access_flags.is_value_class(); }\n+  bool is_inline_type() const { return !_access_flags.is_identity_class() && !_access_flags.is_interface() && !_access_flags.is_abstract(); }\n@@ -607,5 +602,0 @@\n-  bool is_value_capable_class() const;\n-  bool carries_identity_modifier() const { return _carries_identity_modifier; }\n-  void set_carries_identity_modifier() { _carries_identity_modifier = true; }\n-  bool carries_value_modifier() const { return _carries_value_modifier; }\n-  void set_carries_value_modifier() { _carries_value_modifier = true; }\n@@ -623,0 +613,1 @@\n+  static bool is_jdk_internal_class(const Symbol*);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -755,1 +755,0 @@\n-      case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n@@ -760,0 +759,1 @@\n+          assert(type != T_ARRAY, \"null free ptr to array not supported\");\n@@ -771,3 +771,1 @@\n-            if (!vk->is_implicitly_constructible()) {\n-              THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n-            }\n+            assert(vk->is_implicitly_constructible(), \"must be, should have been checked in post_process_parsed_stream()\");\n@@ -841,0 +839,1 @@\n+    assert(group != nullptr, \"invariant\");\n@@ -862,1 +861,0 @@\n-      case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n@@ -866,1 +864,1 @@\n-            field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n@@ -870,0 +868,1 @@\n+          assert(type != T_ARRAY, \"null free ptr to array not supported\");\n@@ -881,3 +880,1 @@\n-            if (!vk->is_implicitly_constructible()) {\n-              THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n-            }\n+            assert(vk->is_implicitly_constructible(), \"must be, should have been checked in post_process_parsed_stream()\");\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -792,2 +793,1 @@\n-int java_lang_Class::_primary_mirror_offset;\n-int java_lang_Class::_secondary_mirror_offset;\n+\n@@ -808,3 +808,1 @@\n-  \/\/ Can't use vmSymbols::string_signature() as fd->signature() may have been relocated\n-  \/\/ during DumpSharedSpaces\n-  assert(fd->signature()->equals(\"Ljava\/lang\/String;\"), \"just checking\");\n+  assert(fd->signature() == vmSymbols::string_signature(), \"just checking\");\n@@ -1001,2 +999,1 @@\n-        InlineKlass* vk = InlineKlass::cast(element_klass);\n-        comp_mirror = Handle(THREAD, vk->val_mirror());\n+        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n@@ -1018,1 +1015,1 @@\n-        comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+        comp_oop = ik->java_mirror();\n@@ -1086,6 +1083,1 @@\n-    if (k->is_inline_klass()) {\n-      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n-      set_primary_mirror(mirror(), mirror());\n-      set_secondary_mirror(mirror(), secondary_mirror);\n-    }\n-    if (DumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_heap()) {\n@@ -1099,19 +1091,0 @@\n-\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n-\/\/ instance with the same value as the primary mirror\n-oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n-  assert(k->is_inline_klass(), \"primitive class\");\n-  \/\/ Allocate mirror (java.lang.Class instance)\n-  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n-  Handle secondary_mirror(THREAD, mirror_oop);\n-\n-  java_lang_Class::set_klass(secondary_mirror(), k);\n-  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n-\n-  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n-  set_class_loader(secondary_mirror(), class_loader(mirror()));\n-  \/\/ ## handle if java.base is not yet defined\n-  set_module(secondary_mirror(), module(mirror()));\n-  set_primary_mirror(secondary_mirror(), mirror());\n-  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n-  return secondary_mirror();\n-}\n@@ -1248,20 +1221,0 @@\n-oop java_lang_Class::primary_mirror(oop java_class) {\n-  assert(_primary_mirror_offset != 0, \"must be set\");\n-  return java_class->obj_field(_primary_mirror_offset);\n-}\n-\n-void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n-  assert(_primary_mirror_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_primary_mirror_offset, mirror);\n-}\n-\n-oop java_lang_Class::secondary_mirror(oop java_class) {\n-  assert(_secondary_mirror_offset != 0, \"must be set\");\n-  return java_class->obj_field(_secondary_mirror_offset);\n-}\n-\n-void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n-  assert(_secondary_mirror_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n-}\n-\n@@ -1352,1 +1305,0 @@\n-  bool is_Q_descriptor = false;\n@@ -1358,1 +1310,0 @@\n-    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1366,1 +1317,1 @@\n-    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n+    st->print(\"L\");\n@@ -1388,7 +1339,2 @@\n-      const char* sigstr;\n-      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n-        sigstr = InlineKlass::cast(k)->val_signature_name();\n-      } else {\n-        sigstr = k->signature_name();\n-      }\n-      int siglen = (int) strlen(sigstr);\n+      const char* sigstr = k->signature_name();\n+      int         siglen = (int) strlen(sigstr);\n@@ -1431,0 +1377,4 @@\n+  if (klass->is_flatArray_klass() || (klass->is_objArray_klass() && ObjArrayKlass::cast(klass)->is_null_free_array_klass())) {\n+    \/\/ TODO 8325106 Ignore flat \/ null-free arrays\n+    return;\n+  }\n@@ -1446,1 +1396,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n@@ -1482,2 +1432,0 @@\n-  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n-  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n@@ -2534,1 +2482,1 @@\n-    {\n+    if (THREAD->can_call_java()) {\n@@ -2556,0 +2504,3 @@\n+    } else {\n+      st->print_raw_cr(\"<<cannot call Java to get cause>>\");\n+      return;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":18,"deletions":67,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -233,2 +233,0 @@\n-  static int _primary_mirror_offset;\n-  static int _secondary_mirror_offset;\n@@ -249,2 +247,0 @@\n-  static void set_primary_mirror(oop java_class, oop comp_mirror);\n-  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n@@ -266,1 +262,0 @@\n-  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -297,2 +292,1 @@\n-  static int primary_mirror_offset()       { CHECK_INIT(_primary_mirror_offset); }\n-  static int secondary_mirror_offset()     { CHECK_INIT(_secondary_mirror_offset); }\n+\n@@ -306,4 +300,0 @@\n-  static oop  primary_mirror(oop java_class);\n-  static oop  secondary_mirror(oop java_class);\n-  static bool is_primary_mirror(oop java_class);\n-  static bool is_secondary_mirror(oop java_class);\n@@ -868,0 +858,3 @@\n+    \/\/ CDS\n+    static int module_entry_offset() { return _module_entry_offset; }\n+\n@@ -1483,0 +1476,1 @@\n+  \/\/ Support for CDS\n@@ -1484,0 +1478,1 @@\n+  static int loader_data_offset() { return  _loader_data_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -171,0 +171,10 @@\n+  \/* support for vectors*\/                                                                                      \\\n+  do_klass(vector_VectorSupport_klass,                  jdk_internal_vm_vector_VectorSupport                  ) \\\n+  do_klass(vector_VectorPayload_klass,                  jdk_internal_vm_vector_VectorPayload                  ) \\\n+  do_klass(vector_Vector_klass,                         jdk_internal_vm_vector_Vector                         ) \\\n+  do_klass(vector_VectorMask_klass,                     jdk_internal_vm_vector_VectorMask                     ) \\\n+  do_klass(vector_VectorShuffle_klass,                  jdk_internal_vm_vector_VectorShuffle                  ) \\\n+                                                                                                                \\\n+  \/* support multi-field based vectors *\/                                                                       \\\n+  do_klass(vector_VectorPayloadMF_klass,                jdk_internal_vm_vector_VectorPayloadMF                ) \\\n+                                                                                                                \\\n@@ -187,10 +197,0 @@\n-  \/* support for vectors*\/                                                                                      \\\n-  do_klass(vector_VectorSupport_klass,                  jdk_internal_vm_vector_VectorSupport                  ) \\\n-  do_klass(vector_VectorPayload_klass,                  jdk_internal_vm_vector_VectorPayload                  ) \\\n-  do_klass(vector_Vector_klass,                         jdk_internal_vm_vector_Vector                         ) \\\n-  do_klass(vector_VectorMask_klass,                     jdk_internal_vm_vector_VectorMask                     ) \\\n-  do_klass(vector_VectorShuffle_klass,                  jdk_internal_vm_vector_VectorShuffle                  ) \\\n-                                                                                                                \\\n-  \/* support multi-field based vectors *\/                                                                       \\\n-  do_klass(vector_VectorPayloadMF_klass,                jdk_internal_vm_vector_VectorPayloadMF                ) \\\n-                                                                                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+  template(java_util_DualPivotQuicksort,              \"java\/util\/DualPivotQuicksort\")             \\\n@@ -484,1 +485,0 @@\n-  template(inline_factory_name,                       \"<vnew>\")                                   \\\n@@ -894,0 +894,1 @@\n+  template(jdk_internal_value_ValueClass,                   \"jdk\/internal\/value\/ValueClass\")                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -279,0 +279,8 @@\n+Handle ObjectMergeValue::value() const {\n+  if (_selected != nullptr) {\n+    return _selected->value();\n+  } else {\n+    return Handle();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  Handle                      value() const                   { assert(_selected != nullptr, \"Should call select() first.\"); return _selected->value(); }\n+  Handle                      value() const;\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\/\/ HierarchicalFieldStream allows to also iterate over fields of supertypes.\n@@ -170,1 +171,1 @@\n-\/\/ Iterate over only the internal fields\n+\/\/ Iterate over only the Java fields\n@@ -213,0 +214,100 @@\n+\/\/ Iterate over fields including the ones declared in supertypes\n+template<typename FieldStreamType>\n+class HierarchicalFieldStream : public StackObj  {\n+ private:\n+  const Array<InstanceKlass*>* _interfaces;\n+  InstanceKlass* _next_klass; \/\/ null indicates no more type to visit\n+  FieldStreamType _current_stream;\n+  int _interface_index;\n+\n+  void prepare() {\n+    _next_klass = next_klass_with_fields();\n+    \/\/ special case: the initial klass has no fields. If any supertype has any fields, use that directly.\n+    \/\/ if no such supertype exists, done() will return false already.\n+    next_stream_if_done();\n+  }\n+\n+  InstanceKlass* next_klass_with_fields() {\n+    assert(_next_klass != nullptr, \"reached end of types already\");\n+    InstanceKlass* result = _next_klass;\n+    do  {\n+      if (!result->is_interface() && result->super() != nullptr) {\n+        result = result->java_super();\n+      } else if (_interface_index > 0) {\n+        result = _interfaces->at(--_interface_index);\n+      } else {\n+        return nullptr; \/\/ we did not find any more supertypes with fields\n+      }\n+    } while (FieldStreamType(result).done());\n+    return result;\n+  }\n+\n+  \/\/ sets _current_stream to the next if the current is done and any more is available\n+  void next_stream_if_done() {\n+    if (_next_klass != nullptr && _current_stream.done()) {\n+      _current_stream = FieldStreamType(_next_klass);\n+      assert(!_current_stream.done(), \"created empty stream\");\n+      _next_klass = next_klass_with_fields();\n+    }\n+  }\n+\n+ public:\n+  HierarchicalFieldStream(InstanceKlass* klass) :\n+    _interfaces(klass->transitive_interfaces()),\n+    _next_klass(klass),\n+    _current_stream(FieldStreamType(klass)),\n+    _interface_index(_interfaces->length()) {\n+      prepare();\n+  }\n+\n+  void next() {\n+    _current_stream.next();\n+    next_stream_if_done();\n+  }\n+\n+  bool done() const { return _next_klass == nullptr && _current_stream.done(); }\n+\n+  \/\/ bridge functions from FieldStreamBase\n+\n+  AccessFlags access_flags() const {\n+    return _current_stream.access_flags();\n+  }\n+\n+  FieldInfo::FieldFlags field_flags() const {\n+    return _current_stream.field_flags();\n+  }\n+\n+  Symbol* name() const {\n+    return _current_stream.name();\n+  }\n+\n+  Symbol* signature() const {\n+    return _current_stream.signature();\n+  }\n+\n+  Symbol* generic_signature() const {\n+    return _current_stream.generic_signature();\n+  }\n+\n+  int offset() const {\n+    return _current_stream.offset();\n+  }\n+\n+  bool is_contended() const {\n+    return _current_stream.is_contended();\n+  }\n+\n+  int contended_group() const {\n+    return _current_stream.contended_group();\n+  }\n+\n+  FieldInfo to_FieldInfo() {\n+    return _current_stream.to_FieldInfo();\n+  }\n+\n+  fieldDescriptor& field_descriptor() const {\n+    return _current_stream.field_descriptor();\n+  }\n+\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+<<<<<<< HEAD\n@@ -3,0 +4,3 @@\n+=======\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+>>>>>>> e01ec832189453cc302c7ca8915e69bb63a3d4b1\n@@ -26,0 +30,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -61,0 +66,4 @@\n+InlineKlass::InlineKlass() {\n+  assert(CDSConfig::is_dumping_archive() || UseSharedSpaces, \"only for CDS\");\n+}\n+\n@@ -193,1 +202,1 @@\n-          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, true, CHECK_NULL);\n+          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, CHECK_NULL);\n@@ -248,1 +257,1 @@\n-    if (fs.is_multifield()) continue;\n+    \/\/ TODO 8284443 Use different heuristic to decide what should be scalarized in the calling convention\n@@ -256,3 +265,0 @@\n-      if (bt == T_PRIMITIVE_OBJECT) {\n-        bt = T_OBJECT;\n-      }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  InlineKlass() { assert(DumpSharedSpaces || UseSharedSpaces, \"only for CDS\"); }\n+  InlineKlass();\n@@ -153,13 +153,0 @@\n-  bool is_null_free() const { return access_flags().is_primitive_class(); }\n-\n-  \/\/ ref and val mirror\n-  oop ref_mirror() const { return java_mirror(); }\n-  oop val_mirror() const { return java_lang_Class::secondary_mirror(java_mirror()); }\n-\n-  \/\/ naming\n-  const char* ref_signature_name() const {\n-    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n-  }\n-  const char* val_signature_name() const {\n-    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_PRIMITIVE_OBJECT);\n-  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -78,0 +79,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -182,0 +184,9 @@\n+bool InstanceKlass::is_class_in_preload_attribute(Symbol* name) const {\n+  if (_preload_classes == nullptr) return false;\n+  for (int i = 0; i < _preload_classes->length(); i++) {\n+        Symbol* class_name = _constants->klass_at_noresolve(_preload_classes->at(i));\n+        if (class_name == name) return true;\n+  }\n+  return false;\n+}\n+\n@@ -455,1 +466,0 @@\n-                                       parser.has_inline_fields() ? parser.java_fields_count() : 0,\n@@ -550,0 +560,4 @@\n+InstanceKlass::InstanceKlass() {\n+  assert(CDSConfig::is_dumping_static_archive() || UseSharedSpaces, \"only for CDS\");\n+}\n+\n@@ -581,4 +595,0 @@\n-\n-  if (has_inline_type_fields()) {\n-    _inline_type_field_klasses = (const Klass**) adr_inline_type_field_klasses();\n-  }\n@@ -720,0 +730,5 @@\n+  if (inline_type_field_klasses_array() != nullptr) {\n+    MetadataFactory::free_array<InlineKlass*>(loader_data, inline_type_field_klasses_array());\n+  }\n+  set_inline_type_field_klasses_array(nullptr);\n+\n@@ -773,1 +788,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n@@ -892,2 +907,2 @@\n-  if (DumpSharedSpaces && SystemDictionaryShared::has_class_failed_verification(this)) {\n-    \/\/ This is for CDS dumping phase only -- we use the in_error_state to indicate that\n+  if (CDSConfig::is_dumping_static_archive() && SystemDictionaryShared::has_class_failed_verification(this)) {\n+    \/\/ This is for CDS static dump only -- we use the in_error_state to indicate that\n@@ -968,27 +983,27 @@\n-    if (EnablePrimitiveClasses) {\n-      for (int i = 0; i < methods()->length(); i++) {\n-        Method* m = methods()->at(i);\n-        for (SignatureStream ss(m->signature()); !ss.is_done(); ss.next()) {\n-          if (ss.is_reference()) {\n-            if (ss.is_array()) {\n-              continue;\n-            }\n-            if (ss.type() == T_PRIMITIVE_OBJECT) {\n-              Symbol* symb = ss.as_symbol();\n-              if (symb == name()) continue;\n-              oop loader = class_loader();\n-              oop protection_domain = this->protection_domain();\n-              Klass* klass = SystemDictionary::resolve_or_fail(symb,\n-                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n-                                                              CHECK_false);\n-              if (klass == nullptr) {\n-                THROW_(vmSymbols::java_lang_LinkageError(), false);\n-              }\n-              if (!klass->is_inline_klass()) {\n-                Exceptions::fthrow(\n-                  THREAD_AND_LOCATION,\n-                  vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  \"class %s is not an inline type\",\n-                  klass->external_name());\n-              }\n-            }\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+      if (fs.is_null_free_inline_type() && fs.access_flags().is_static()) {\n+        Symbol* sig = fs.signature();\n+        TempNewSymbol s = Signature::strip_envelope(sig);\n+        if (s != name()) {\n+          log_info(class, preload)(\"Preloading class %s during linking of class %s. Cause: a null-free static field is declared with this type\", s->as_C_string(), name()->as_C_string());\n+          Klass* klass = SystemDictionary::resolve_or_fail(s,\n+                                                          Handle(THREAD, class_loader()), Handle(THREAD, protection_domain()), true,\n+                                                          CHECK_false);\n+          if (HAS_PENDING_EXCEPTION) {\n+            log_warning(class, preload)(\"Preloading of class %s during linking of class %s (cause: null-free static field) failed: %s\",\n+                                      s->as_C_string(), name()->as_C_string(), PENDING_EXCEPTION->klass()->name()->as_C_string());\n+            return false; \/\/ Exception is still pending\n+          }\n+          log_info(class, preload)(\"Preloading of class %s during linking of class %s (cause: null-free static field) succeeded\",\n+                                   s->as_C_string(), name()->as_C_string());\n+          assert(klass != nullptr, \"Sanity check\");\n+          if (!klass->is_inline_klass()) {\n+            THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                       err_msg(\"class %s expects class %s to be a value class but it is an identity class\",\n+                       name()->as_C_string(), klass->external_name()), false);\n+          }\n+          if (klass->is_abstract()) {\n+            THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                      err_msg(\"Class %s expects class %s to be concrete value class, but it is an abstract class\",\n+                      name()->as_C_string(),\n+                      InstanceKlass::cast(klass)->external_name()), false);\n@@ -996,0 +1011,7 @@\n+          InstanceKlass* ik = InstanceKlass::cast(klass);\n+          if (!ik->is_implicitly_constructible()) {\n+             THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                        err_msg(\"class %s is not implicitly constructible and it is used in a null restricted static field (not supported)\",\n+                        klass->external_name()), false);\n+          }\n+          \/\/ the inline_type_field_klass_array is not updated because of CDS (see verifications in SystemDictionary::load_shared_class())\n@@ -1001,0 +1023,1 @@\n+      HandleMark hm(THREAD);\n@@ -1005,0 +1028,2 @@\n+        if (ClassFileParser::is_jdk_internal_class(class_name)) continue;\n+        log_info(class, preload)(\"Preloading class %s during linking of class %s because of the class is listed in the Preload attribute\", class_name->as_C_string(), name()->as_C_string());\n@@ -1009,0 +1034,1 @@\n+        if (klass && VectorSupport::is_vector(klass)) continue;\n@@ -1013,1 +1039,5 @@\n-          log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute\", class_name->as_C_string(), name()->as_C_string());\n+          log_info(class, preload)(\"Preloading of class %s during linking of class %s (cause: Preload attribute) succeeded\", class_name->as_C_string(), name()->as_C_string());\n+          if (!klass->is_inline_klass()) {\n+            \/\/ Non value class are allowed by the current spec, but it could be an indication of an issue so let's log a warning\n+              log_warning(class, preload)(\"Preloading class %s during linking of class %s (cause: Preload attribute) but loaded class is not a value class\", class_name->as_C_string(), name()->as_C_string());\n+          }\n@@ -1015,30 +1045,1 @@\n-          log_warning(class, preload)(\"Preloading of class %s during linking of class %s (Preload attribute) failed\", class_name->as_C_string(), name()->as_C_string());\n-        }\n-      }\n-    }\n-\n-    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n-      if (fs.is_null_free_inline_type() && fs.access_flags().is_static()) {\n-        Symbol* sig = fs.signature();\n-        oop loader = class_loader();\n-        oop protection_domain = this->protection_domain();\n-        Klass* klass = SystemDictionary::resolve_or_fail(sig,\n-                                                        Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n-                                                        CHECK_false);\n-        if (klass == nullptr) {\n-          THROW_(vmSymbols::java_lang_LinkageError(), false);\n-        }\n-        if (!klass->is_inline_klass()) {\n-          Exceptions::fthrow(\n-            THREAD_AND_LOCATION,\n-            vmSymbols::java_lang_IncompatibleClassChangeError(),\n-            \"class %s is not an inline type\",\n-            klass->external_name());\n-        }\n-        InstanceKlass* ik = InstanceKlass::cast(klass);\n-        if (!ik->is_implicitly_constructible()) {\n-          Exceptions::fthrow(\n-            THREAD_AND_LOCATION,\n-            vmSymbols::java_lang_IncompatibleClassChangeError(),\n-            \"class %s is not implicitly constructible and it is used in a null restricted static field (not supported)\",\n-            klass->external_name());\n+          log_warning(class, preload)(\"Preloading of class %s during linking of class %s (cause: Preload attribute) failed\", class_name->as_C_string(), name()->as_C_string());\n@@ -1401,1 +1402,2 @@\n-          set_inline_type_field_klass(fs.index(), klass);\n+          assert(klass->is_inline_klass(), \"Must be\");\n+          set_inline_type_field_klass(fs.index(), InlineKlass::cast(klass));\n@@ -1786,1 +1788,1 @@\n-                                                                  false, false, CHECK_NULL);\n+                                                                  false, CHECK_NULL);\n@@ -2117,1 +2119,1 @@\n-    assert(DynamicDumpSharedSpaces, \"must be\");\n+    assert(CDSConfig::is_dumping_dynamic_archive(), \"must be\");\n@@ -2364,3 +2366,2 @@\n-    if (name == vmSymbols::object_initializer_name() ||\n-        name == vmSymbols::inline_factory_name()) {\n-      break;  \/\/ <init> and <vnew> is never inherited\n+    if (name == vmSymbols::object_initializer_name()) {\n+      break;  \/\/ <init> is never inherited\n@@ -2749,1 +2750,3 @@\n-      InstanceKlass* impl = Atomic::load_acquire(adr_implementor());\n+      InstanceKlass* volatile* iklass = adr_implementor();\n+      assert(iklass != nullptr, \"Klass must not be null\");\n+      InstanceKlass* impl = Atomic::load_acquire(iklass);\n@@ -2752,1 +2755,0 @@\n-        InstanceKlass* volatile* iklass = adr_implementor();\n@@ -2854,5 +2856,1 @@\n-  if (has_inline_type_fields()) {\n-    for (int i = 0; i < java_fields_count(); i++) {\n-      it->push(&((Klass**)adr_inline_type_field_klasses())[i]);\n-    }\n-  }\n+  it->push(&_inline_type_field_klasses, MetaspaceClosure::_writable);\n@@ -2902,8 +2900,0 @@\n-  if (has_inline_type_fields()) {\n-    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n-      if (fs.is_null_free_inline_type()) {\n-        reset_inline_type_field_klass(fs.index());\n-      }\n-    }\n-  }\n-\n@@ -2954,0 +2944,1 @@\n+  assert(CDSConfig::is_dumping_archive(), \"must be\");\n@@ -2957,7 +2948,1 @@\n-  if (!MetaspaceShared::use_full_module_graph()) {\n-    _package_entry = nullptr;\n-  } else if (DynamicDumpSharedSpaces) {\n-    if (!MetaspaceShared::is_in_shared_metaspace(_package_entry)) {\n-      _package_entry = nullptr;\n-    }\n-  } else {\n+  if (CDSConfig::is_dumping_full_module_graph()) {\n@@ -2969,0 +2954,6 @@\n+  } else if (CDSConfig::is_dumping_dynamic_archive() &&\n+             CDSConfig::is_loading_full_module_graph() &&\n+             MetaspaceShared::is_in_shared_metaspace(_package_entry)) {\n+    \/\/ _package_entry is an archived package in the base archive. Leave it as is.\n+  } else {\n+    _package_entry = nullptr;\n@@ -3297,1 +3288,1 @@\n-    if (MetaspaceShared::use_full_module_graph() && _package_entry == pkg_entry) {\n+    if (CDSConfig::is_loading_full_module_graph() && _package_entry == pkg_entry) {\n@@ -4382,1 +4373,1 @@\n-        ((UseSharedSpaces || Arguments::is_dumping_archive()) && length != 0)) {\n+        ((UseSharedSpaces || CDSConfig::is_dumping_archive()) && length != 0)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":88,"deletions":97,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\/\/    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true\n@@ -169,1 +168,1 @@\n-  InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, \"only for CDS\"); }\n+  InstanceKlass();\n@@ -303,1 +302,1 @@\n-  const Klass**   _inline_type_field_klasses; \/\/ For \"inline class\" fields, null if none present\n+  Array<InlineKlass*>* _inline_type_field_klasses; \/\/ For \"inline class\" fields, null if none present\n@@ -382,6 +381,0 @@\n-  bool carries_value_modifier() const { return _misc_flags.carries_value_modifier(); }\n-  void set_carries_value_modifier()   { _misc_flags.set_carries_value_modifier(true); }\n-\n-  bool carries_identity_modifier() const  { return _misc_flags.carries_identity_modifier(); }\n-  void set_carries_identity_modifier()    { _misc_flags.set_carries_identity_modifier(true); }\n-\n@@ -450,2 +443,2 @@\n-  int     field_offset      (int index) const { return field(index).offset(); }\n-  int     field_access_flags(int index) const { return field(index).access_flags().as_int(); }\n+  int field_offset      (int index) const { return field(index).offset(); }\n+  int field_access_flags(int index) const { return field(index).access_flags().as_int(); }\n@@ -456,2 +449,3 @@\n-  bool    field_is_flat(int index) const { return field_flags(index).is_flat(); }\n-  bool    field_is_null_free_inline_type(int index) const;\n+  bool field_is_flat(int index) const { return field_flags(index).is_flat(); }\n+  bool field_is_null_free_inline_type(int index) const;\n+  bool is_class_in_preload_attribute(Symbol* name) const;\n@@ -1018,1 +1012,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  bool is_inline_type) {\n@@ -1024,1 +1018,0 @@\n-           (java_fields * (int)sizeof(Klass*)\/wordSize) +\n@@ -1032,1 +1025,0 @@\n-                                               has_inline_type_fields() ? java_fields_count() : 0,\n@@ -1047,4 +1039,6 @@\n-  inline address adr_inline_type_field_klasses() const;\n-  inline Klass* get_inline_type_field_klass(int idx) const;\n-  inline Klass* get_inline_type_field_klass_or_null(int idx) const;\n-  inline void set_inline_type_field_klass(int idx, Klass* k);\n+  Array<InlineKlass*>* inline_type_field_klasses_array() const { return _inline_type_field_klasses; }\n+  void set_inline_type_field_klasses_array(Array<InlineKlass*>* array) { _inline_type_field_klasses = array; }\n+\n+  inline InlineKlass* get_inline_type_field_klass(int idx) const;\n+  inline InlineKlass* get_inline_type_field_klass_or_null(int idx) const;\n+  inline void set_inline_type_field_klass(int idx, InlineKlass* k);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -66,14 +66,1 @@\n-inline address InstanceKlass::adr_inline_type_field_klasses() const {\n-  if (has_inline_type_fields()) {\n-    InstanceKlass* volatile* adr_impl = adr_implementor();\n-    if (adr_impl != nullptr) {\n-      return (address)(adr_impl + 1);\n-    }\n-\n-    return (address)end_of_nonstatic_oop_maps();\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-inline Klass* InstanceKlass::get_inline_type_field_klass(int idx) const {\n+inline InlineKlass* InstanceKlass::get_inline_type_field_klass(int idx) const {\n@@ -82,1 +69,1 @@\n-  Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n+  InlineKlass* k = inline_type_field_klasses_array()->at(idx);\n@@ -84,1 +71,0 @@\n-  assert(k->is_inline_klass(), \"Must be an inline type\");\n@@ -88,1 +74,1 @@\n-inline Klass* InstanceKlass::get_inline_type_field_klass_or_null(int idx) const {\n+inline InlineKlass* InstanceKlass::get_inline_type_field_klass_or_null(int idx) const {\n@@ -91,2 +77,1 @@\n-  Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n-  assert(k == nullptr || k->is_inline_klass(), \"Must be an inline type\");\n+  InlineKlass* k = inline_type_field_klasses_array()->at(idx);\n@@ -96,1 +81,1 @@\n-inline void InstanceKlass::set_inline_type_field_klass(int idx, Klass* k) {\n+inline void InstanceKlass::set_inline_type_field_klass(int idx, InlineKlass* k) {\n@@ -100,2 +85,3 @@\n-  assert(((Klass**)adr_inline_type_field_klasses())[idx] == nullptr, \"Should not be set twice\");\n-  ((Klass**)adr_inline_type_field_klasses())[idx] = k;\n+  assert(inline_type_field_klasses_array() != nullptr, \"array must have been created\");\n+  assert(inline_type_field_klasses_array()->at(idx) == nullptr, \"Should not be set twice\");\n+  inline_type_field_klasses_array()->at_put(idx, k);\n@@ -107,1 +93,1 @@\n-  ((Klass**)adr_inline_type_field_klasses())[idx] = nullptr;\n+  inline_type_field_klasses_array()->at_put(idx, nullptr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  if (C->failing()) return nullptr;\n+\n@@ -461,1 +463,1 @@\n-    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline, \"we're doing late inlining\");\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline || StressIncrementalInlining, \"we're doing late inlining\");\n@@ -583,1 +585,1 @@\n-    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline, \"we're doing late inlining\");\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline || StressIncrementalInlining, \"we're doing late inlining\");\n@@ -801,1 +803,1 @@\n-        vt->replace_call_results(&kit, call, C, inline_method->signature()->returns_null_free_inline_type());\n+        vt->replace_call_results(&kit, call, C);\n@@ -810,3 +812,1 @@\n-          if (!inline_method->signature()->returns_null_free_inline_type()) {\n-            kit.null_check_common(vt->get_is_init(), T_INT, false, &null_ctl);\n-          }\n+          kit.null_check_common(vt->get_is_init(), T_INT, false, &null_ctl);\n@@ -832,1 +832,1 @@\n-          vt->set_oop(kit.gvn().transform(oop));\n+          vt->set_oop(kit.gvn(), kit.gvn().transform(oop));\n@@ -1142,0 +1142,1 @@\n+  bool should_delay = C->should_delay_inlining();\n@@ -1143,1 +1144,1 @@\n-    if (AlwaysIncrementalInline) {\n+    if (should_delay) {\n@@ -1154,1 +1155,1 @@\n-                            (call_site_count > 0 && (input_not_const || !C->inlining_incrementally() || C->over_inlining_cutoff())))) {\n+                            (call_site_count > 0 && (should_delay || input_not_const || !C->inlining_incrementally() || C->over_inlining_cutoff())))) {\n@@ -1162,1 +1163,1 @@\n-static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit, bool null_free) {\n+static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit) {\n@@ -1167,3 +1168,0 @@\n-  if (t->as_klass()->is_inlinetype() && null_free) {\n-    sig_type = sig_type->filter_speculative(TypePtr::NOTNULL);\n-  }\n@@ -1254,1 +1252,1 @@\n-          cast_argument(nargs, 0, signature->accessing_klass(), kit, false);\n+          cast_argument(nargs, 0, signature->accessing_klass(), kit);\n@@ -1260,2 +1258,1 @@\n-            bool null_free = signature->is_null_free_at(i);\n-            cast_argument(nargs, receiver_skip + j, t, kit, null_free);\n+            cast_argument(nargs, receiver_skip + j, t, kit);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1430,1 +1430,1 @@\n-  SharedRuntime::c_calling_convention(sig_bt, parm_regs, \/*regs2=*\/nullptr, argcnt);\n+  SharedRuntime::c_calling_convention(sig_bt, parm_regs, argcnt);\n@@ -1824,1 +1824,1 @@\n-         initializer->is_object_constructor_or_class_initializer(),\n+         (initializer->is_object_constructor() || initializer->is_class_initializer()),\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    vt->set_oop(phase->transform(cast));\n+    vt->set_oop(*phase, phase->transform(cast));\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1898,0 +1898,11 @@\n+\/\/ Returns the BasicType of a given convert node and a type, with special handling to ensure that conversions to\n+\/\/ and from half float will return the SHORT basic type, as that wouldn't be returned typically from TypeInt.\n+static BasicType get_convert_type(Node* convert, const Type* type) {\n+  int convert_op = convert->Opcode();\n+  if (type->isa_int() && (convert_op == Op_ConvHF2F || convert_op == Op_ConvF2HF)) {\n+    return T_SHORT;\n+  }\n+\n+  return type->basic_type();\n+}\n+\n@@ -2032,2 +2043,3 @@\n-InlineTypeNode* PhiNode::push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk) {\n-  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, vk)->clone_with_phis(phase, in(0), !_type->maybe_null());\n+InlineTypeNode* PhiNode::push_inline_types_down(PhaseGVN* phase, bool can_reshape, ciInlineKlass* inline_klass) {\n+  assert(inline_klass != nullptr, \"must be\");\n+  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, inline_klass, \/* transform = *\/ false)->clone_with_phis(phase, in(0), nullptr, !_type->maybe_null());\n@@ -2056,1 +2068,1 @@\n-      n = InlineTypeNode::make_null(*phase, vk);\n+      n = InlineTypeNode::make_null(*phase, inline_klass);\n@@ -2059,1 +2071,1 @@\n-      n = phase->transform(n->as_Phi()->push_inline_types_through(phase, can_reshape, vk));\n+      n = phase->transform(n->as_Phi()->push_inline_types_down(phase, can_reshape, inline_klass));\n@@ -2063,0 +2075,1 @@\n+      \/\/ TODO 8325106 Can we avoid cloning?\n@@ -2066,1 +2079,1 @@\n-      n->as_InlineType()->set_oop(phase->transform(cast));\n+      n->as_InlineType()->set_oop(*phase, phase->transform(cast));\n@@ -2625,10 +2638,4 @@\n-  \/\/ Check recursively if inputs are either an inline type, constant null\n-  \/\/ or another Phi (including self references through data loops). If so,\n-  \/\/ push the inline types down through the phis to enable folding of loads.\n-  if (EnableValhalla && _type->isa_ptr() && req() > 2) {\n-    ResourceMark rm;\n-    Unique_Node_List worklist;\n-    worklist.push(this);\n-    bool can_optimize = true;\n-    ciInlineKlass* vk = nullptr;\n-    Node_List casts;\n+  Node* inline_type = try_push_inline_types_down(phase, can_reshape);\n+  if (inline_type != this) {\n+    return inline_type;\n+  }\n@@ -2636,45 +2643,13 @@\n-    \/\/ TODO 8302217 We need to prevent endless pushing through\n-    bool only_phi = (outcnt() != 0);\n-    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-      Node* n = fast_out(i);\n-      if (n->is_InlineType() && n->in(1) == this) {\n-        can_optimize = false;\n-        break;\n-      }\n-      if (!n->is_Phi()) {\n-        only_phi = false;\n-      }\n-    }\n-    if (only_phi) {\n-      can_optimize = false;\n-    }\n-    for (uint next = 0; next < worklist.size() && can_optimize; next++) {\n-      Node* phi = worklist.at(next);\n-      for (uint i = 1; i < phi->req() && can_optimize; i++) {\n-        Node* n = phi->in(i);\n-        if (n == nullptr) {\n-          can_optimize = false;\n-          break;\n-        }\n-        while (n->is_ConstraintCast()) {\n-          if (n->in(0) != nullptr && n->in(0)->is_top()) {\n-            \/\/ Will die, don't optimize\n-            can_optimize = false;\n-            break;\n-          }\n-          casts.push(n);\n-          n = n->in(1);\n-        }\n-        const Type* t = phase->type(n);\n-        \/\/ FIXME: Skipping pushing VectorBox across Phi\n-        \/\/ since they are special type of InlineTypeNode\n-        \/\/ carrying VBA as oop fields.\n-        \/\/ We have a seperate handling for pushing VectorBoxes\n-        \/\/ across PhiNodes in merge_through_phi.\n-        \/\/ In long run we should eliminate VectorBox which is\n-        \/\/ just a light weight wrapper of InlineTypeNode.\n-        \/\/ Only reason to keep VectorBox was to defer buffering\n-        \/\/ to a later stage and associate VBA which carry\n-        \/\/ JVM state to reinitialize GraphKit before buffering.\n-        if (n->is_VectorBox()) {\n-          can_optimize = false;\n+  \/\/ Try to convert a Phi with two duplicated convert nodes into a phi of the pre-conversion type and the convert node\n+  \/\/ proceeding the phi, to de-duplicate the convert node and compact the IR.\n+  if (can_reshape && progress == nullptr) {\n+    ConvertNode* convert = in(1)->isa_Convert();\n+    if (convert != nullptr) {\n+      int conv_op = convert->Opcode();\n+      bool ok = true;\n+\n+      \/\/ Check the rest of the inputs\n+      for (uint i = 2; i < req(); i++) {\n+        \/\/ Make sure that all inputs are of the same type of convert node\n+        if (in(i)->Opcode() != conv_op) {\n+          ok = false;\n@@ -2683,14 +2658,15 @@\n-        if (n->is_InlineType() && (vk == nullptr || vk == t->inline_klass())) {\n-          vk = (vk == nullptr) ? t->inline_klass() : vk;\n-        } else if (n->is_Phi() && can_reshape && n->bottom_type()->isa_ptr()) {\n-          worklist.push(n);\n-        } else if (!t->is_zero_type()) {\n-          can_optimize = false;\n-        }\n-    }\n-    \/\/ Check if cast nodes can be pushed through\n-    const Type* t = Type::get_const_type(vk);\n-    while (casts.size() != 0 && can_optimize && t != nullptr) {\n-      Node* cast = casts.pop();\n-      if (t->filter(cast->bottom_type()) == Type::TOP) {\n-        can_optimize = false;\n+\n+      if (ok) {\n+        \/\/ Find the local bottom type to set as the type of the phi\n+        const Type* source_type = Type::get_const_basic_type(convert->in_type()->basic_type());\n+        const Type* dest_type = convert->bottom_type();\n+\n+        PhiNode* newphi = new PhiNode(in(0), source_type, nullptr);\n+        \/\/ Set inputs to the new phi be the inputs of the convert\n+        for (uint i = 1; i < req(); i++) {\n+          newphi->init_req(i, in(i)->in(1));\n+        }\n+\n+        phase->is_IterGVN()->register_new_node_with_optimizer(newphi, this);\n+\n+        return ConvertNode::create_convert(get_convert_type(convert, source_type), get_convert_type(convert, dest_type), newphi);\n@@ -2700,3 +2676,0 @@\n-    if (can_optimize && vk != nullptr) {\n-      return push_inline_types_through(phase, can_reshape, vk);\n-    }\n@@ -2713,0 +2686,97 @@\n+\/\/ Check recursively if inputs are either an inline type, constant null\n+\/\/ or another Phi (including self references through data loops). If so,\n+\/\/ push the inline types down through the phis to enable folding of loads.\n+Node* PhiNode::try_push_inline_types_down(PhaseGVN* phase, const bool can_reshape) {\n+  if (!can_be_inline_type()) {\n+    return this;\n+  }\n+\n+  ciInlineKlass* inline_klass;\n+  if (can_push_inline_types_down(phase, can_reshape, inline_klass)) {\n+    assert(inline_klass != nullptr, \"must be\");\n+    return push_inline_types_down(phase, can_reshape, inline_klass);\n+  }\n+  return this;\n+}\n+\n+bool PhiNode::can_push_inline_types_down(PhaseGVN* phase, const bool can_reshape, ciInlineKlass*& inline_klass) {\n+  if (req() <= 2) {\n+    \/\/ Dead phi.\n+    return false;\n+  }\n+  inline_klass = nullptr;\n+\n+  \/\/ TODO 8302217 We need to prevent endless pushing through\n+  bool only_phi = (outcnt() != 0);\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* n = fast_out(i);\n+    if (n->is_InlineType() && n->in(1) == this) {\n+      return false;\n+    }\n+    if (!n->is_Phi()) {\n+      only_phi = false;\n+    }\n+  }\n+  if (only_phi) {\n+    return false;\n+  }\n+\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(this);\n+  Node_List casts;\n+\n+  for (uint next = 0; next < worklist.size(); next++) {\n+    Node* phi = worklist.at(next);\n+    for (uint i = 1; i < phi->req(); i++) {\n+      Node* n = phi->in(i);\n+      if (n == nullptr) {\n+        return false;\n+      }\n+      while (n->is_ConstraintCast()) {\n+        if (n->in(0) != nullptr && n->in(0)->is_top()) {\n+          \/\/ Will die, don't optimize\n+          return false;\n+        }\n+        casts.push(n);\n+        n = n->in(1);\n+      }\n+      \/\/ FIXME: Skipping pushing VectorBox across Phi\n+      \/\/ since they are special type of InlineTypeNode\n+      \/\/ carrying VBA as oop fields.\n+      \/\/ We have a seperate handling for pushing VectorBoxes\n+      \/\/ across PhiNodes in merge_through_phi.\n+      \/\/ In long run we should eliminate VectorBox which is\n+      \/\/ just a light weight wrapper of InlineTypeNode.\n+      \/\/ Only reason to keep VectorBox was to defer buffering\n+      \/\/ to a later stage and associate VBA which carry\n+      \/\/ JVM state to reinitialize GraphKit before buffering.\n+      if (n->is_VectorBox()) {\n+        return false;\n+      }\n+      const Type* type = phase->type(n);\n+      if (n->is_InlineType() && (inline_klass == nullptr || inline_klass == type->inline_klass())) {\n+        inline_klass = type->inline_klass();\n+      } else if (n->is_Phi() && can_reshape && n->bottom_type()->isa_ptr()) {\n+        worklist.push(n);\n+      } else if (!type->is_zero_type()) {\n+        return false;\n+      }\n+    }\n+  }\n+  if (inline_klass == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ Check if cast nodes can be pushed through\n+  const Type* t = Type::get_const_type(inline_klass);\n+  while (casts.size() != 0 && t != nullptr) {\n+    Node* cast = casts.pop();\n+    if (t->filter(cast->bottom_type()) == Type::TOP) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":147,"deletions":77,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+  bool can_push_inline_types_down(PhaseGVN* phase, bool can_reshape, ciInlineKlass*& inline_klass);\n+  InlineTypeNode* push_inline_types_down(PhaseGVN* phase, bool can_reshape, ciInlineKlass* inline_klass);\n+\n@@ -257,1 +260,5 @@\n-  InlineTypeNode* push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk);\n+  bool can_be_inline_type() const {\n+    return EnableValhalla && _type->isa_instptr() && _type->is_instptr()->can_be_inline_type();\n+  }\n+\n+  Node* try_push_inline_types_down(PhaseGVN* phase, bool can_reshape);\n@@ -436,0 +443,1 @@\n+  bool is_zero_trip_guard() const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -289,0 +290,1 @@\n+    PhaseIterGVN::add_users_of_use_to_worklist(nn, use, *_igvn_worklist);\n@@ -664,2 +666,2 @@\n-                  _node_arena_one(mtCompiler),\n-                  _node_arena_two(mtCompiler),\n+                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -679,0 +681,1 @@\n+                  _oom(false),\n@@ -826,2 +829,0 @@\n-    print_method(PHASE_BEFORE_REMOVEUSELESS, 3);\n-\n@@ -854,1 +855,1 @@\n-  if (StressLCM || StressGCM || StressIGVN || StressCCP) {\n+  if (StressLCM || StressGCM || StressIGVN || StressCCP || StressIncrementalInlining) {\n@@ -965,0 +966,1 @@\n+    _oom(false),\n@@ -1927,0 +1929,1 @@\n+    if (failing()) return;\n@@ -2424,1 +2427,1 @@\n-        if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+        if (!live_locals.at(i) && !local->is_top() && local != lhs && local != rhs) {\n@@ -2439,1 +2442,1 @@\n-    \/\/ keep the mondified trap for late query\n+    \/\/ keep the modified trap for late query\n@@ -2482,1 +2485,0 @@\n-    PhaseGVN* gvn = initial_gvn();\n@@ -2554,0 +2556,1 @@\n+    if (failing()) return;\n@@ -2734,0 +2737,2 @@\n+  if (failing())  return;\n+\n@@ -2744,1 +2749,3 @@\n-    if (AlwaysIncrementalInline) {\n+    if (failing())  return;\n+\n+    if (AlwaysIncrementalInline || StressIncrementalInlining) {\n@@ -2759,0 +2766,2 @@\n+  if (failing())  return;\n+\n@@ -2763,0 +2772,3 @@\n+  if (failing())  return;\n+\n+\n@@ -2772,0 +2784,1 @@\n+    if (failing()) return;\n@@ -2782,1 +2795,1 @@\n-\n+    if (failing())  return;\n@@ -2793,0 +2806,2 @@\n+  if (failing())  return;\n+\n@@ -2814,1 +2829,1 @@\n-      if (failing())  return;\n+      if (failing()) return;\n@@ -2824,0 +2839,2 @@\n+        if (failing()) return;\n+\n@@ -2905,0 +2922,2 @@\n+  if (failing())  return;\n+\n@@ -2943,0 +2962,1 @@\n+    if (failing()) return;\n@@ -4531,2 +4551,0 @@\n-        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n-        assert(false, \"malformed control flow\");\n@@ -4878,0 +4896,1 @@\n+  if (_compile->failing()) return;\n@@ -4918,0 +4937,1 @@\n+    \/\/ TODO 8325106 Fix comment\n@@ -5458,0 +5478,1 @@\n+      if (failing())  return;\n@@ -5623,0 +5644,1 @@\n+  if (failing()) { return; }\n@@ -5793,0 +5815,3 @@\n+void Compile::record_method_not_compilable_oom() {\n+  record_method_not_compilable(CompilationMemoryStatistic::failure_reason_memlimit());\n+}\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":38,"deletions":13,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -989,1 +989,1 @@\n-      for (j = 0; j < l; j++)\n+      for (j = 0; j < l; j++) {\n@@ -991,0 +991,10 @@\n+        Node* local = in_map->in(k+j);\n+        \/\/ TODO 8325106\n+        \/*\n+        if (false && local->is_InlineType() && local->isa_InlineType()->is_larval()) {\n+          tty->print_cr(\"LARVAL FOUND in LOCAL\");\n+          in_map->dump(0);\n+          local->dump(0);\n+        }\n+        *\/\n+      }\n@@ -1000,1 +1010,1 @@\n-      for (j = 0; j < l; j++)\n+      for (j = 0; j < l; j++) {\n@@ -1002,0 +1012,13 @@\n+        Node* local = in_map->in(k+j);\n+        \/\/ TODO 8325106 check if there's a larval on stack in the caller state that has been written in the callee state and update it accordingly\n+        \/*\n+        if (false && local->is_InlineType() && local->isa_InlineType()->is_larval()) {\n+          tty->print_cr(\"LARVAL FOUND on STACK\");\n+          in_map->dump(0);\n+          local->dump(0);\n+          map()->replaced_nodes().dump(tty);\n+          map()->replaced_nodes().apply(call, 0);\n+          tty->print_cr(\"\");\n+        }\n+        *\/\n+      }\n@@ -1133,9 +1156,0 @@\n-  case Bytecodes::_withfield: {\n-    bool ignored_will_link;\n-    ciField* field = method()->get_field_at_bci(bci(), ignored_will_link);\n-    int size = InlineTypeNode::stack_size_for_field(field);\n-    inputs = size+1;\n-    depth = rsize() - inputs;\n-    break;\n-  }\n-\n@@ -1482,0 +1496,1 @@\n+    \/\/ TODO 8325106 Can we avoid cloning?\n@@ -1881,3 +1896,0 @@\n-      if (!is_late_inline) {\n-        arg = arg->as_InlineType()->get_oop();\n-      }\n@@ -1948,1 +1960,1 @@\n-    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, call->method()->signature()->returns_null_free_inline_type());\n+    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, false);\n@@ -1960,0 +1972,10 @@\n+  \/\/ We just called the constructor on a value type receiver. Reload it from the buffer\n+  if (call->method()->is_object_constructor() && call->method()->holder()->is_inlinetype()) {\n+    InlineTypeNode* receiver = call->in(TypeFunc::Parms)->as_InlineType();\n+    assert(receiver->is_larval(), \"must be larval\");\n+    assert(receiver->is_allocated(&gvn()), \"larval must be buffered\");\n+    InlineTypeNode* reloaded = InlineTypeNode::make_from_oop(this, receiver->get_oop(), receiver->bottom_type()->inline_klass(), true);\n+    assert(!reloaded->is_larval(), \"should not be larval anymore\");\n+    replace_in_map(receiver, reloaded);\n+  }\n+\n@@ -3670,7 +3692,0 @@\n-Node* GraphKit::is_val_mirror(Node* mirror) {\n-  Node* p = basic_plus_adr(mirror, java_lang_Class::secondary_mirror_offset());\n-  Node* secondary_mirror = access_load_at(mirror, p, _gvn.type(p)->is_ptr(), TypeInstPtr::MIRROR->cast_to_ptr_type(TypePtr::BotPTR), T_OBJECT, IN_HEAP);\n-  Node* cmp = _gvn.transform(new CmpPNode(mirror, secondary_mirror));\n-  return _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n-}\n-\n@@ -3686,0 +3701,1 @@\n+\/\/ TODO 8325106 With JEP 401, flatness is not a property of the Class anymore.\n@@ -3911,0 +3927,1 @@\n+      \/\/ TODO 8325106 Fix comment\n@@ -4313,0 +4330,1 @@\n+  \/\/ TODO 8325106 Fix comment\n@@ -4326,40 +4344,9 @@\n-    }\n-  } else if (ary_type->can_be_inline_array()) {\n-    \/\/ Array type is not known, add runtime checks\n-    assert(!ary_klass->klass_is_exact(), \"unexpected exact type\");\n-    Node* r = new RegionNode(3);\n-    default_value = new PhiNode(r, TypeInstPtr::BOTTOM);\n-\n-    Node* bol = array_lh_test(klass_node, Klass::_lh_array_tag_flat_value_bit_inplace | Klass::_lh_null_free_array_bit_inplace, Klass::_lh_null_free_array_bit_inplace);\n-    IfNode* iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n-\n-    \/\/ Null-free, non-flat inline type array, initialize with the default value\n-    set_control(_gvn.transform(new IfTrueNode(iff)));\n-    Node* p = basic_plus_adr(klass_node, in_bytes(ArrayKlass::element_klass_offset()));\n-    Node* eklass = _gvn.transform(LoadKlassNode::make(_gvn, control(), immutable_memory(), p, TypeInstPtr::KLASS));\n-    Node* adr_fixed_block_addr = basic_plus_adr(eklass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset()));\n-    Node* adr_fixed_block = make_load(control(), adr_fixed_block_addr, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n-    Node* default_value_offset_addr = basic_plus_adr(adr_fixed_block, in_bytes(InlineKlass::default_value_offset_offset()));\n-    Node* default_value_offset = make_load(control(), default_value_offset_addr, TypeInt::INT, T_INT, MemNode::unordered);\n-    Node* elem_mirror = load_mirror_from_klass(eklass);\n-    Node* default_value_addr = basic_plus_adr(elem_mirror, ConvI2X(default_value_offset));\n-    Node* val = access_load_at(elem_mirror, default_value_addr, TypeInstPtr::MIRROR, TypeInstPtr::NOTNULL, T_OBJECT, IN_HEAP);\n-    r->init_req(1, control());\n-    default_value->init_req(1, val);\n-\n-    \/\/ Otherwise initialize with all zero\n-    r->init_req(2, _gvn.transform(new IfFalseNode(iff)));\n-    default_value->init_req(2, null());\n-\n-    set_control(_gvn.transform(r));\n-    default_value = _gvn.transform(default_value);\n-  }\n-  if (default_value != nullptr) {\n-    if (UseCompressedOops) {\n-      \/\/ With compressed oops, the 64-bit init value is built from two 32-bit compressed oops\n-      default_value = _gvn.transform(new EncodePNode(default_value, default_value->bottom_type()->make_narrowoop()));\n-      Node* lower = _gvn.transform(new CastP2XNode(control(), default_value));\n-      Node* upper = _gvn.transform(new LShiftLNode(lower, intcon(32)));\n-      raw_default_value = _gvn.transform(new OrLNode(lower, upper));\n-    } else {\n-      raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));\n+      if (UseCompressedOops) {\n+        \/\/ With compressed oops, the 64-bit init value is built from two 32-bit compressed oops\n+        default_value = _gvn.transform(new EncodePNode(default_value, default_value->bottom_type()->make_narrowoop()));\n+        Node* lower = _gvn.transform(new CastP2XNode(control(), default_value));\n+        Node* upper = _gvn.transform(new LShiftLNode(lower, intcon(32)));\n+        raw_default_value = _gvn.transform(new OrLNode(lower, upper));\n+      } else {\n+        raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));\n+      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":49,"deletions":62,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -89,1 +89,2 @@\n-    assert(!has_exceptions(), \"user must call transfer_exceptions_into_jvms\");\n+    assert(failing() || !has_exceptions(),\n+           \"unless compilation failed, user must call transfer_exceptions_into_jvms\");\n@@ -704,1 +705,1 @@\n-  Node* null_check_receiver_before_call(ciMethod* callee, bool replace_value = true) {\n+  Node* null_check_receiver_before_call(ciMethod* callee) {\n@@ -861,1 +862,0 @@\n-  Node* is_val_mirror(Node* mirror);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-      !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      !Matcher::match_rule_supported_vector(Op_Replicate, vec_len, bt)) {\n@@ -64,2 +64,2 @@\n-InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init) {\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, SafePointNode* map, bool is_init) {\n+  InlineTypeNode* vt = clone_if_required(gvn, map);\n@@ -74,1 +74,1 @@\n-  vt->set_oop(oop);\n+  vt->set_oop(*gvn, oop);\n@@ -100,1 +100,1 @@\n-    \/\/ of the same type but with different scalarization depth during IGVN. To avoid inconsistencies\n+    \/\/ of the same type but with different scalarization depth during GVN. To avoid inconsistencies\n@@ -102,1 +102,1 @@\n-    bool no_circularity = !gvn->C->has_circular_inline_type() || !gvn->is_IterGVN() || field_is_flat(i);\n+    bool no_circularity = !gvn->C->has_circular_inline_type() || field_is_flat(i);\n@@ -105,1 +105,1 @@\n-      value = value->as_InlineType()->clone_with_phis(gvn, region);\n+      value = value->as_InlineType()->clone_with_phis(gvn, region, map);\n@@ -150,1 +150,1 @@\n-    set_oop(gvn->transform(phi));\n+    set_oop(*gvn, gvn->transform(phi));\n@@ -352,2 +352,26 @@\n-  bool use_oop = allow_oop && is_allocated(igvn) &&\n-                 (oop->is_Con() || oop->is_Parm() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n+  \/\/ TODO 8325106\n+  \/\/ TestBasicFunctionality::test3 fails without this. Add more tests?\n+  \/\/ Add proj nodes here? Recursive handling of phis required? We need a test that fails without.\n+  bool use_oop = false;\n+  if (allow_oop && is_allocated(igvn) && oop->is_Phi()) {\n+    Unique_Node_List worklist;\n+    worklist.push(oop);\n+    use_oop = true;\n+    while (worklist.size() > 0 && use_oop) {\n+      Node* n = worklist.pop();\n+      for (uint i = 1; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in->is_Phi()) {\n+          worklist.push(in);\n+        \/\/ TestNullableArrays.test123 fails when enabling this, probably we should make sure that we don't load from a just allocated object\n+        \/\/} else if (!(in->is_Con() || in->is_Parm() || in->is_Load() || (in->isa_DecodeN() && in->in(1)->is_Load()))) {\n+        } else if (!(in->is_Con() || in->is_Parm())) {\n+          use_oop = false;\n+          break;\n+        }\n+      }\n+    }\n+  } else {\n+    use_oop = allow_oop && is_allocated(igvn) &&\n+              (oop->is_Con() || oop->is_Parm() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n+  }\n@@ -414,3 +438,3 @@\n-\/\/ We limit scalarization for inline types with circular fields and can therefore observe\n-\/\/ nodes of same type but with different scalarization depth during GVN. This method adjusts\n-\/\/ the scalarization depth to avoid inconsistencies during merging.\n+\/\/ We limit scalarization for inline types with circular fields and can therefore observe nodes\n+\/\/ of the same type but with different scalarization depth during GVN. This method adjusts the\n+\/\/ scalarization depth to avoid inconsistencies during merging.\n@@ -449,1 +473,1 @@\n-        val = clone()->as_InlineType();\n+        val = clone_if_required(&kit->gvn(), kit->map());\n@@ -532,1 +556,1 @@\n-void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n+void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, int offsetOnly) const {\n@@ -536,0 +560,1 @@\n+    if (offsetOnly != -1 && offsetOnly != field_offset(i)) continue;\n@@ -572,1 +597,1 @@\n-    InlineTypeNode* vt = clone()->as_InlineType();\n+    InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map(), safe_for_replace);\n@@ -618,7 +643,12 @@\n-    store(kit, alloc_oop, alloc_oop, vk);\n-\n-    \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n-    \/\/ store that would make this buffer accessible by other threads.\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-    assert(alloc != nullptr, \"must have an allocation node\");\n-    kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+    \/\/ No need to initialize a larval buffer, we make sure that the oop can not escape\n+    if (!is_larval()) {\n+      \/\/ Larval will be initialized later\n+      \/\/ TODO 8325106 should this use C2_TIGHTLY_COUPLED_ALLOC?\n+      store(kit, alloc_oop, alloc_oop, vk);\n+\n+      \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+      \/\/ store that would make this buffer accessible by other threads.\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+      assert(alloc != nullptr, \"must have an allocation node\");\n+      kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+    }\n@@ -643,2 +673,2 @@\n-  InlineTypeNode* vt = clone()->as_InlineType();\n-  vt->set_oop(res_oop);\n+  InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map(), safe_for_replace);\n+  vt->set_oop(kit->gvn(), res_oop);\n@@ -669,1 +699,1 @@\n-void InlineTypeNode::replace_call_results(GraphKit* kit, CallNode* call, Compile* C, bool null_free) {\n+void InlineTypeNode::replace_call_results(GraphKit* kit, CallNode* call, Compile* C) {\n@@ -677,1 +707,1 @@\n-    } else if (!null_free && con == (call->tf()->range_cc()->cnt() - 1)) {\n+    } else if (con == (call->tf()->range_cc()->cnt() - 1)) {\n@@ -702,1 +732,1 @@\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+  InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map());\n@@ -748,2 +778,4 @@\n-  if (!is_larval(phase) &&\n-      is_default(phase) &&\n+  const Type* tinit = phase->type(get_is_init());\n+  if (!is_larval(phase) && !is_larval() &&\n+      (tinit->isa_int() && tinit->is_int()->is_con(1)) &&\n+      (is_default(phase) || inline_klass()->is_empty()) &&\n@@ -752,2 +784,2 @@\n-    \/\/ Use the pre-allocated oop for default inline types\n-    set_oop(default_oop(*phase, inline_klass()));\n+    \/\/ Use the pre-allocated oop for null-free default or empty inline types\n+    set_oop(*phase, default_oop(*phase, inline_klass()));\n@@ -759,1 +791,1 @@\n-    set_oop(vtptr->get_oop());\n+    set_oop(*phase, vtptr->get_oop());\n@@ -767,1 +799,2 @@\n-  if (!is_allocated(phase)) {\n+  \/\/ TODO 8325106 Re-evaluate this: We prefer a \"loaded\" oop because it's free. The existing oop might come from a buffering.\n+  if (!is_larval(phase) && !is_larval()) {\n@@ -771,2 +804,2 @@\n-    if (base != nullptr && !phase->type(base)->maybe_null()) {\n-      set_oop(base);\n+    if (base != nullptr && get_oop() != base && !phase->type(base)->maybe_null()) {\n+      set_oop(*phase, base);\n@@ -806,1 +839,2 @@\n-  Node* oop = (vk->is_empty() && vk->is_initialized()) ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n+  bool use_default_oop = vk->is_empty() && vk->is_initialized() && null_free;\n+  Node* oop = use_default_oop ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n@@ -808,1 +842,1 @@\n-  vt->set_is_buffered(gvn, vk->is_empty() && vk->is_initialized());\n+  vt->set_is_buffered(gvn, use_default_oop);\n@@ -825,1 +859,1 @@\n-      Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      Matcher::match_rule_supported_vector(Op_Replicate, vec_len, bt)) {\n@@ -831,1 +865,1 @@\n-InlineTypeNode* InlineTypeNode::make_default(PhaseGVN& gvn, ciInlineKlass* vk) {\n+InlineTypeNode* InlineTypeNode::make_default(PhaseGVN& gvn, ciInlineKlass* vk, bool is_larval) {\n@@ -834,1 +868,1 @@\n-  return make_default_impl(gvn, vk, visited);\n+  return make_default_impl(gvn, vk, visited, is_larval);\n@@ -837,1 +871,1 @@\n-InlineTypeNode* InlineTypeNode::make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited) {\n+InlineTypeNode* InlineTypeNode::make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval) {\n@@ -839,1 +873,1 @@\n-  Node* oop = vk->is_initialized() ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n+  Node* oop = vk->is_initialized() && !is_larval ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n@@ -841,1 +875,3 @@\n-  vt->set_is_buffered(gvn, vk->is_initialized());\n+  \/\/ TODO 8325106 we should be able to set buffered here for non-larvals, right?\n+  \/\/vt->set_is_buffered(gvn, vk->is_initialized());\n+  vt->set_is_buffered(gvn, false);\n@@ -843,0 +879,1 @@\n+  vt->set_is_larval(is_larval);\n@@ -867,1 +904,1 @@\n-  const Type* tinit = gvn->type(in(IsInit));\n+  const Type* tinit = gvn->type(get_is_init());\n@@ -880,1 +917,9 @@\n-      value = value->as_InlineType()->get_oop();\n+      if (value->as_InlineType()->is_default(gvn)) {\n+        continue;\n+      } else {\n+        const Type* tinit = gvn->type(value->as_InlineType()->get_is_init());\n+        if (tinit->isa_int() && tinit->is_int()->is_con(0)) {\n+          continue;\n+        }\n+        return false;\n+      }\n@@ -890,1 +935,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free) {\n+InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, bool is_larval) {\n@@ -893,1 +938,1 @@\n-  return make_from_oop_impl(kit, oop, vk, null_free, visited);\n+  return make_from_oop_impl(kit, oop, vk, null_free, visited, is_larval);\n@@ -896,1 +941,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited) {\n+InlineTypeNode* InlineTypeNode::make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited, bool is_larval) {\n@@ -899,1 +944,1 @@\n-  if (vk->is_empty() && null_free) {\n+  if (!is_larval && vk->is_empty() && null_free) {\n@@ -909,0 +954,1 @@\n+    assert(!is_larval || oop->as_InlineType()->is_larval(), \"must be larval\");\n@@ -928,0 +974,1 @@\n+    vt->set_is_larval(is_larval);\n@@ -940,2 +987,1 @@\n-\n-      vt = vt->clone_with_phis(&gvn, region);\n+      vt = vt->clone_with_phis(&gvn, region, kit->map());\n@@ -944,1 +990,1 @@\n-        vt->set_oop(oop);\n+        vt->set_oop(gvn, oop);\n@@ -954,0 +1000,1 @@\n+    vt->set_is_larval(is_larval);\n@@ -991,1 +1038,1 @@\n-    vt->set_oop(oop);\n+    vt->set_oop(kit->gvn(), oop);\n@@ -1045,1 +1092,2 @@\n-    if (tinit->isa_int() && tinit->is_int()->is_con(1)) {\n+    \/\/ TODO 8325106\n+    if (false && !is_larval() && tinit->isa_int() && tinit->is_int()->is_con(1)) {\n@@ -1207,0 +1255,3 @@\n+          \/\/ We limit scalarization for inline types with circular fields and can therefore observe nodes\n+          \/\/ of the same type but with different scalarization depth during GVN. To avoid inconsistencies\n+          \/\/ during merging, make sure that we only create Phis for fields that are guaranteed to be scalarized.\n@@ -1246,0 +1297,3 @@\n+  if (is_larval()) {\n+    return;\n+  }\n@@ -1256,1 +1310,2 @@\n-      assert((!is_default(igvn) || !inline_klass()->is_initialized()) && !is_allocated(igvn), \"re-allocation should be removed by Ideal transformation\");\n+      \/\/ TODO 8325106\n+      \/\/ assert((!is_default(igvn) || !inline_klass()->is_initialized()) && !is_allocated(igvn), \"re-allocation should be removed by Ideal transformation\");\n@@ -1280,1 +1335,1 @@\n-InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk, bool transform) {\n@@ -1283,1 +1338,1 @@\n-  return make_null_impl(gvn, vk, visited);\n+  return make_null_impl(gvn, vk, visited, transform);\n@@ -1286,1 +1341,1 @@\n-InlineTypeNode* InlineTypeNode::make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited) {\n+InlineTypeNode* InlineTypeNode::make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool transform) {\n@@ -1303,1 +1358,1 @@\n-  return gvn.transform(vt)->as_InlineType();\n+  return transform ? gvn.transform(vt)->as_InlineType() : vt;\n@@ -1306,3 +1361,8 @@\n-Node* InlineTypeNode::Identity(PhaseGVN* phase) {\n-  if (get_oop()->is_InlineType()) {\n-    return get_oop();\n+InlineTypeNode* InlineTypeNode::clone_if_required(PhaseGVN* gvn, SafePointNode* map, bool safe_for_replace) {\n+  if (!safe_for_replace || (map == nullptr && outcnt() != 0)) {\n+    return clone()->as_InlineType();\n+  }\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    if (fast_out(i) != map) {\n+      return clone()->as_InlineType();\n+    }\n@@ -1310,0 +1370,1 @@\n+  gvn->hash_delete(this);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":125,"deletions":64,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+    _is_larval = false;\n@@ -54,0 +55,7 @@\n+  bool _is_larval;\n+\n+  virtual uint hash() const { return TypeNode::hash() + _is_larval; }\n+  \/\/ TODO 8325106 why can't we gvn larvals?\n+  virtual bool cmp(const Node &n) const { return TypeNode::cmp(n) && !((InlineTypeNode&)n)._is_larval && !_is_larval; }\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n@@ -75,3 +83,3 @@\n-  static InlineTypeNode* make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited);\n-  static InlineTypeNode* make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited);\n-  static InlineTypeNode* make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval = false);\n+  static InlineTypeNode* make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited, bool is_larval = false);\n+  static InlineTypeNode* make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool transform = true);\n@@ -82,1 +90,1 @@\n-  static InlineTypeNode* make_default(PhaseGVN& gvn, ciInlineKlass* vk);\n+  static InlineTypeNode* make_default(PhaseGVN& gvn, ciInlineKlass* vk, bool is_larval = false);\n@@ -86,1 +94,1 @@\n-  static InlineTypeNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true);\n+  static InlineTypeNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true, bool is_larval = false);\n@@ -92,1 +100,1 @@\n-  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n+  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk, bool transform = true);\n@@ -106,1 +114,1 @@\n-  InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init = false);\n+  InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, SafePointNode* map = nullptr, bool is_init = false);\n@@ -112,1 +120,1 @@\n-  void  set_oop(Node* oop) { set_req(Oop, oop); }\n+  void  set_oop(PhaseGVN& gvn, Node* oop) { set_req_X(Oop, oop, &gvn); }\n@@ -114,1 +122,1 @@\n-  void  set_is_init(PhaseGVN& gvn, bool init = true) { set_req(IsInit, gvn.intcon(init ? 1 : 0)); }\n+  void  set_is_init(PhaseGVN& gvn, bool init = true) { set_req_X(IsInit, gvn.intcon(init ? 1 : 0), &gvn); }\n@@ -116,1 +124,4 @@\n-  void  set_is_buffered(PhaseGVN& gvn, bool buffered = true) { set_req(IsBuffered, gvn.intcon(buffered ? 1 : 0)); }\n+  void  set_is_buffered(PhaseGVN& gvn, bool buffered = true) { set_req_X(IsBuffered, gvn.intcon(buffered ? 1 : 0), &gvn); }\n+\n+  void set_is_larval(bool is_larval) { _is_larval = is_larval; }\n+  bool is_larval() { return _is_larval; }\n@@ -145,1 +156,1 @@\n-  void store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n+  void store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED, int offset = -1) const;\n@@ -155,1 +166,1 @@\n-  void replace_call_results(GraphKit* kit, CallNode* call, Compile* C, bool null_free = true);\n+  void replace_call_results(GraphKit* kit, CallNode* call, Compile* C);\n@@ -173,1 +184,1 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n+  InlineTypeNode* clone_if_required(PhaseGVN* gvn, SafePointNode* map, bool safe_for_replace = true);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -297,0 +297,3 @@\n+  case vmIntrinsics::_arraySort:                return inline_array_sort();\n+  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n+\n@@ -512,1 +515,1 @@\n-  case vmIntrinsics::_isFlattenedArray:         return inline_unsafe_isFlattenedArray();\n+  case vmIntrinsics::_isFlatArray:              return inline_unsafe_isFlatArray();\n@@ -524,0 +527,1 @@\n+  case vmIntrinsics::_newNullRestrictedArray:   return inline_newNullRestrictedArray();\n@@ -536,5 +540,0 @@\n-  case vmIntrinsics::_asPrimaryType:\n-  case vmIntrinsics::_asPrimaryTypeArg:\n-  case vmIntrinsics::_asValueType:\n-  case vmIntrinsics::_asValueTypeArg:           return inline_primitive_Class_conversion(intrinsic_id());\n-\n@@ -1123,0 +1122,1 @@\n+  clear_upper_avx();\n@@ -1377,0 +1377,1 @@\n+  clear_upper_avx();\n@@ -4114,30 +4115,0 @@\n-\/\/-------------------------inline_primitive_Class_conversion-------------------\n-\/\/               Class<T> java.lang.Class                  .asPrimaryType()\n-\/\/ public static Class<T> jdk.internal.value.PrimitiveClass.asPrimaryType(Class<T>)\n-\/\/               Class<T> java.lang.Class                  .asValueType()\n-\/\/ public static Class<T> jdk.internal.value.PrimitiveClass.asValueType(Class<T>)\n-bool LibraryCallKit::inline_primitive_Class_conversion(vmIntrinsics::ID id) {\n-  Node* mirror = argument(0); \/\/ Receiver\/argument Class\n-  const TypeInstPtr* mirror_con = _gvn.type(mirror)->isa_instptr();\n-  if (mirror_con == nullptr) {\n-    return false;\n-  }\n-\n-  bool is_val_mirror = true;\n-  ciType* tm = mirror_con->java_mirror_type(&is_val_mirror);\n-  if (tm != nullptr) {\n-    Node* result = mirror;\n-    if ((id == vmIntrinsics::_asPrimaryType || id == vmIntrinsics::_asPrimaryTypeArg) && is_val_mirror) {\n-      result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->ref_mirror()));\n-    } else if (id == vmIntrinsics::_asValueType || id == vmIntrinsics::_asValueTypeArg) {\n-      if (!tm->is_inlinetype()) {\n-        return false; \/\/ Throw UnsupportedOperationException\n-      } else if (!is_val_mirror) {\n-        result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->val_mirror()));\n-      }\n-    }\n-    set_result(result);\n-    return true;\n-  }\n-  return false;\n-}\n@@ -4160,2 +4131,1 @@\n-  bool requires_null_check = false;\n-  ciType* tm = mirror_con->java_mirror_type(&requires_null_check);\n+  ciType* tm = mirror_con->java_mirror_type();\n@@ -4171,3 +4141,0 @@\n-        if (requires_null_check) {\n-          obj = null_check(obj);\n-        }\n@@ -4194,3 +4161,0 @@\n-  if (requires_null_check) {\n-    obj = null_check(obj);\n-  }\n@@ -4217,20 +4181,0 @@\n-    if (EnableValhalla && !requires_null_check) {\n-      \/\/ Check if we are casting to QMyValue\n-      Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), nullptr);\n-      if (ctrl_val_mirror != nullptr) {\n-        RegionNode* r = new RegionNode(3);\n-        record_for_igvn(r);\n-        r->init_req(1, control());\n-\n-        \/\/ Casting to QMyValue, check for null\n-        set_control(ctrl_val_mirror);\n-        { \/\/ PreserveJVMState because null check replaces obj in map\n-          PreserveJVMState pjvms(this);\n-          Node* null_ctr = top();\n-          null_check_oop(obj, &null_ctr);\n-          region->init_req(_npe_path, null_ctr);\n-          r->init_req(2, control());\n-        }\n-        set_control(_gvn.transform(r));\n-      }\n-    }\n@@ -4327,4 +4271,0 @@\n-    \/\/ If superc is an inline mirror, we also need to check if superc == subc because LMyValue\n-    \/\/ is not a subtype of QMyValue but due to subk == superk the subtype check will pass.\n-    generate_fair_guard(is_val_mirror(args[0]), prim_region);\n-    \/\/ now we have a successful reference subtype check\n@@ -4432,0 +4372,28 @@\n+\/\/-----------------------inline_newNullRestrictedArray--------------------------\n+\/\/ public static native Object[] newNullRestrictedArray(Class<?> componentType, int length);\n+bool LibraryCallKit::inline_newNullRestrictedArray() {\n+  Node* componentType = argument(0);\n+  Node* length = argument(1);\n+\n+  const TypeInstPtr* tp = _gvn.type(componentType)->isa_instptr();\n+  if (tp != nullptr) {\n+    ciInstanceKlass* ik = tp->instance_klass();\n+    if (ik == C->env()->Class_klass()) {\n+      ciType* t = tp->java_mirror_type();\n+      if (t != nullptr && t->is_inlinetype()) {\n+        ciArrayKlass* array_klass = ciArrayKlass::make(t, true);\n+        if (array_klass->is_loaded() && array_klass->element_klass()->as_inline_klass()->is_initialized()) {\n+          const TypeAryKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces)->is_aryklassptr();\n+          array_klass_type = array_klass_type->cast_to_null_free();\n+          Node* obj = new_array(makecon(array_klass_type), length, 0, nullptr, false);  \/\/ no arguments to push\n+          AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj);\n+          alloc->set_null_free();\n+          set_result(obj);\n+          assert(gvn().type(obj)->is_aryptr()->is_null_free(), \"must be null-free\");\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -5269,2 +5237,3 @@\n-\/\/----------------------inline_unsafe_isFlattenedArray-------------------\n-\/\/ public native boolean Unsafe.isFlattenedArray(Class<?> arrayClass);\n+\/\/ TODO 8325106 Remove this and corresponding tests. Flatness is not a property of the Class anymore with JEP 401.\n+\/\/----------------------inline_unsafe_isFlatArray------------------------\n+\/\/ public native boolean Unsafe.isFlatArray(Class<?> arrayClass);\n@@ -5273,1 +5242,1 @@\n-bool LibraryCallKit::inline_unsafe_isFlattenedArray() {\n+bool LibraryCallKit::inline_unsafe_isFlatArray() {\n@@ -5588,0 +5557,12 @@\n+  int adjustment = 1;\n+  \/\/ TODO 8325106 why can't we check via the type of the const klass node?\n+  if (alloc->is_null_free()) {\n+    \/\/ A null-free, tightly coupled array allocation can only come from LibraryCallKit::inline_newNullRestrictedArray\n+    \/\/ which requires both the component type and the array length on stack for re-execution. Re-create and push\n+    \/\/ the component type.\n+    ciArrayKlass* klass = alloc->in(AllocateNode::KlassNode)->bottom_type()->is_aryklassptr()->exact_klass()->as_array_klass();\n+    ciInstance* instance = klass->component_mirror_instance();\n+    const TypeInstPtr* t_instance = TypeInstPtr::make(instance);\n+    sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), makecon(t_instance));\n+    adjustment++;\n+  }\n@@ -5589,5 +5570,5 @@\n-  sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n-  old_jvms->set_sp(old_jvms->sp()+1);\n-  old_jvms->set_monoff(old_jvms->monoff()+1);\n-  old_jvms->set_scloff(old_jvms->scloff()+1);\n-  old_jvms->set_endoff(old_jvms->endoff()+1);\n+  sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp() + adjustment - 1, alloc->in(AllocateNode::ALength));\n+  old_jvms->set_sp(old_jvms->sp() + adjustment);\n+  old_jvms->set_monoff(old_jvms->monoff() + adjustment);\n+  old_jvms->set_scloff(old_jvms->scloff() + adjustment);\n+  old_jvms->set_endoff(old_jvms->endoff() + adjustment);\n@@ -5750,0 +5731,101 @@\n+\/\/------------------------------inline_array_partition-----------------------\n+bool LibraryCallKit::inline_array_partition() {\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+  Node* indexPivot1     = argument(6);\n+  Node* indexPivot2     = argument(7);\n+\n+  Node* pivotIndices = nullptr;\n+\n+  \/\/ Set the original stack and the reexecute bit for the interpreter to reexecute\n+  \/\/ the bytecode that invokes DualPivotQuicksort.partition() if deoptimization happens.\n+  { PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+\n+    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+    BasicType bt = elem_type->basic_type();\n+    address stubAddr = nullptr;\n+    stubAddr = StubRoutines::select_array_partition_function();\n+    \/\/ stub not loaded\n+    if (stubAddr == nullptr) {\n+      return false;\n+    }\n+    \/\/ get the address of the array\n+    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+      return false; \/\/ failed input validation\n+    }\n+    Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+    \/\/ create the pivotIndices array of type int and size = 2\n+    Node* size = intcon(2);\n+    Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+    pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+    AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+    guarantee(alloc != nullptr, \"created above\");\n+    Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+\n+    \/\/ pass the basic type enum to the stub\n+    Node* elemType = intcon(bt);\n+\n+    \/\/ Call the stub\n+    const char *stubName = \"array_partition_stub\";\n+    make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                      stubAddr, stubName, TypePtr::BOTTOM,\n+                      obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n+                      indexPivot1, indexPivot2);\n+\n+  } \/\/ original reexecute is set back here\n+\n+  if (!stopped()) {\n+    set_result(pivotIndices);\n+  }\n+\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_array_sort-----------------------\n+bool LibraryCallKit::inline_array_sort() {\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  address stubAddr = nullptr;\n+  stubAddr = StubRoutines::select_arraysort_function();\n+  \/\/stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ get address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ pass the basic type enum to the stub\n+  Node* elemType = intcon(bt);\n+\n+  \/\/ Call the stub.\n+  const char *stubName = \"arraysort_stub\";\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_sort_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, elemType, fromIndex, toIndex);\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":158,"deletions":76,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -253,0 +253,1 @@\n+  bool inline_newNullRestrictedArray();\n@@ -256,1 +257,1 @@\n-  bool inline_unsafe_isFlattenedArray();\n+  bool inline_unsafe_isFlatArray();\n@@ -306,1 +307,2 @@\n-\n+  bool inline_array_sort();\n+  bool inline_array_partition();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -659,1 +659,1 @@\n-          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n)) {\n+          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n) && !reduce_merge_precheck) {\n@@ -690,0 +690,5 @@\n+          if (res->is_Phi() && res->as_Phi()->can_be_inline_type()) {\n+            \/\/ Can only eliminate allocation if the phi had been replaced by an InlineTypeNode before which did not happen.\n+            \/\/ TODO 8325106 Why wasn't it replaced by an InlineTypeNode?\n+            can_eliminate = false;\n+          }\n@@ -707,1 +712,2 @@\n-            worklist.push(u);\n+            \/\/ TODO will be fixed by 8328470\n+            worklist.push(use);\n@@ -713,0 +719,2 @@\n+      } else if (res_type->is_inlinetypeptr() && use->Opcode() == Op_MemBarRelease) {\n+        \/\/ Inline type buffer allocations are followed by a membar\n@@ -761,0 +769,5 @@\n+\n+  if (TraceReduceAllocationMerges && !can_eliminate && reduce_merge_precheck) {\n+    tty->print_cr(\"\\tCan't eliminate allocation because '%s': \", fail_eliminate != nullptr ? fail_eliminate : \"\");\n+    DEBUG_ONLY(if (disq_node != nullptr) disq_node->dump();)\n+  }\n@@ -900,3 +913,3 @@\n-      ciInlineKlass* vk = res_type->is_aryptr()->elem()->inline_klass();\n-      assert(vk->flat_in_array(), \"must be flat in array\");\n-      field_val = inline_type_from_mem(sfpt->memory(), sfpt->control(), vk, field_addr_type->isa_aryptr(), 0, alloc);\n+      ciInlineKlass* inline_klass = res_type->is_aryptr()->elem()->inline_klass();\n+      assert(inline_klass->flat_in_array(), \"must be flat in array\");\n+      field_val = inline_type_from_mem(sfpt->memory(), sfpt->control(), inline_klass, field_addr_type->isa_aryptr(), 0, alloc);\n@@ -946,0 +959,2 @@\n+\n+    \/\/ Keep track of inline types to scalarize them later\n@@ -947,1 +962,8 @@\n-      \/\/ Keep track of inline types to scalarize them later\n+    } else if (field_val->is_Phi()) {\n+      PhiNode* phi = field_val->as_Phi();\n+      \/\/ Eagerly replace inline type phis now since we could be removing an inline type allocation where we must\n+      \/\/ scalarize all its fields in safepoints.\n+      field_val = phi->try_push_inline_types_down(&_igvn, true);\n+      if (field_val->is_InlineType()) {\n+        value_worklist->push(field_val);\n+      }\n@@ -1088,1 +1110,1 @@\n-        use->as_InlineType()->set_oop(_igvn.zerocon(T_OBJECT));\n+        use->as_InlineType()->set_oop(_igvn, _igvn.zerocon(T_OBJECT));\n@@ -1103,0 +1125,4 @@\n+      } else if (use->Opcode() == Op_MemBarRelease) {\n+        \/\/ Inline type buffer allocations are followed by a membar\n+        assert(inline_alloc, \"Unexpected MemBarRelease\");\n+        use->as_MemBar()->remove(&_igvn);\n@@ -1210,1 +1236,1 @@\n-  if (!alloc->_is_scalar_replaceable && (!boxing_alloc || (res != nullptr))) {\n+  if (!alloc->_is_scalar_replaceable && !boxing_alloc && !inline_alloc) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":34,"deletions":8,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -248,1 +248,2 @@\n-      assert(phase->C->get_alias_index(t) == phase->C->get_alias_index(t_adr), \"correct memory chain\");\n+      \/\/ TODO 8325106\n+      \/\/ assert(phase->C->get_alias_index(t) == phase->C->get_alias_index(t_adr), \"correct memory chain\");\n@@ -601,2 +602,7 @@\n-          const TypeX *ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n-          if (ac->modifies(ld_offs_t->_lo, ld_offs_t->_hi, phase, can_see_stored_value)) {\n+          const TypeX* ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n+          assert(!ld_offs_t->empty(), \"dead reference should be checked already\");\n+          \/\/ Take into account vector or unsafe access size\n+          jlong ld_size_in_bytes = (jlong)memory_size();\n+          jlong offset_hi = ld_offs_t->_hi + ld_size_in_bytes - 1;\n+          offset_hi = MIN2(offset_hi, (jlong)(TypeX::MAX->_hi)); \/\/ Take care for overflow in 32-bit VM\n+          if (ac->modifies(ld_offs_t->_lo, (intptr_t)offset_hi, phase, can_see_stored_value)) {\n@@ -980,1 +986,1 @@\n-    return (eliminate_boxing && non_volatile) || is_stable_ary;\n+    return (eliminate_boxing && non_volatile) || is_stable_ary || tp->is_inlinetypeptr();\n@@ -2068,18 +2074,0 @@\n-      ciType* mirror_type = const_oop->as_instance()->java_mirror_type();\n-      if (mirror_type != nullptr) {\n-        const Type* const_oop = nullptr;\n-        ciInlineKlass* vk = mirror_type->is_inlinetype() ? mirror_type->as_inline_klass() : nullptr;\n-        \/\/ Fold default value loads\n-        if (vk != nullptr && off == vk->default_value_offset()) {\n-          const_oop = TypeInstPtr::make(vk->default_instance());\n-        }\n-        \/\/ Fold class mirror loads\n-        if (off == java_lang_Class::primary_mirror_offset()) {\n-          const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->ref_instance());\n-        } else if (off == java_lang_Class::secondary_mirror_offset()) {\n-          const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->val_instance());\n-        }\n-        if (const_oop != nullptr) {\n-          return (bt == T_NARROWOOP) ? const_oop->make_narrowoop() : const_oop;\n-        }\n-      }\n@@ -2122,0 +2110,1 @@\n+      \/\/ TODO 8325106 remove?\n@@ -2447,2 +2436,1 @@\n-      bool null_free = false;\n-      ciType* t = tinst->java_mirror_type(&null_free);\n+      ciType* t = tinst->java_mirror_type();\n@@ -2458,1 +2446,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t, null_free), Type::trust_interfaces);\n+          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class ConvertNode;\n@@ -744,0 +745,1 @@\n+      DEFINE_CLASS_ID(Convert, Type, 11)\n@@ -904,0 +906,1 @@\n+  DEFINE_CLASS_QUERY(Convert)\n@@ -1145,0 +1148,7 @@\n+  \/\/ Visit boundary uses of the node and apply a callback function for each.\n+  \/\/ Recursively traverse uses, stopping and applying the callback when\n+  \/\/ reaching a boundary node, defined by is_boundary. Note: the function\n+  \/\/ definition appears after the complete type definition of Node_List.\n+  template <typename Callback, typename Check>\n+  void visit_uses(Callback callback, Check is_boundary) const;\n+\n@@ -1645,0 +1655,29 @@\n+\/\/ Definition must appear after complete type definition of Node_List\n+template <typename Callback, typename Check>\n+void Node::visit_uses(Callback callback, Check is_boundary) const {\n+  ResourceMark rm;\n+  VectorSet visited;\n+  Node_List worklist;\n+\n+  \/\/ The initial worklist consists of the direct uses\n+  for (DUIterator_Fast kmax, k = fast_outs(kmax); k < kmax; k++) {\n+    Node* out = fast_out(k);\n+    if (!visited.test_set(out->_idx)) { worklist.push(out); }\n+  }\n+\n+  while (worklist.size() > 0) {\n+    Node* use = worklist.pop();\n+    \/\/ Apply callback on boundary nodes\n+    if (is_boundary(use)) {\n+      callback(use);\n+    } else {\n+      \/\/ Not a boundary node, continue search\n+      for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n+        Node* out = use->fast_out(k);\n+        if (!visited.test_set(out->_idx)) { worklist.push(out); }\n+      }\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -614,2 +614,3 @@\n-      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n-      set_local(i, vt);\n+      bool is_larval = (i == 0) && method()->is_object_constructor() && !method()->holder()->is_abstract() && !method()->holder()->is_java_lang_Object();\n+      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null(), is_larval);\n+      replace_in_map(parm, vt);\n@@ -624,0 +625,1 @@\n+      \/\/ TODO 8325106 Shouldn't we use replace_in_map here?\n@@ -939,1 +941,1 @@\n-        ret->init_req(TypeFunc::Parms, vt->get_oop());\n+        ret->init_req(TypeFunc::Parms, vt);\n@@ -943,7 +945,5 @@\n-        if (!method()->signature()->returns_null_free_inline_type()) {\n-          \/\/ Return null if the inline type is null (IsInit field is not set)\n-          Node* conv   = kit.gvn().transform(new ConvI2LNode(vt->get_is_init()));\n-          Node* shl    = kit.gvn().transform(new LShiftLNode(conv, kit.intcon(63)));\n-          Node* shr    = kit.gvn().transform(new RShiftLNode(shl, kit.intcon(63)));\n-          tagged_klass = kit.gvn().transform(new AndLNode(tagged_klass, shr));\n-        }\n+        \/\/ Return null if the inline type is null (IsInit field is not set)\n+        Node* conv   = kit.gvn().transform(new ConvI2LNode(vt->get_is_init()));\n+        Node* shl    = kit.gvn().transform(new LShiftLNode(conv, kit.intcon(63)));\n+        Node* shr    = kit.gvn().transform(new RShiftLNode(shl, kit.intcon(63)));\n+        tagged_klass = kit.gvn().transform(new AndLNode(tagged_klass, shr));\n@@ -953,1 +953,1 @@\n-      vt->pass_fields(&kit, ret, idx, false, method()->signature()->returns_null_free_inline_type());\n+      vt->pass_fields(&kit, ret, idx, false, false);\n@@ -1081,1 +1081,1 @@\n-  if (method()->is_object_constructor_or_class_initializer() &&\n+  if ((method()->is_object_constructor() || method()->is_class_initializer()) &&\n@@ -1224,1 +1224,2 @@\n-    kit.null_check_receiver_before_call(method(), false);\n+    Node* receiver = kit.argument(0);\n+    Node* null_free = kit.null_check_receiver_before_call(method());\n@@ -1226,0 +1227,5 @@\n+    if (receiver->is_InlineType() && receiver->as_InlineType()->is_larval()) {\n+      \/\/ Replace the larval inline type receiver in the exit map as well to make sure that\n+      \/\/ we can find and update it in Parse::do_call when we are done with the initialization.\n+      _exits.map()->replace_edge(receiver, null_free);\n+    }\n@@ -1656,0 +1662,1 @@\n+    if (failing()) return;\n@@ -2187,0 +2194,1 @@\n+    \/\/ TODO 8325106 Why can't we pass map here?\n@@ -2383,2 +2391,3 @@\n-    \/\/ Defer returning VectorBoxAllocation node, they will be expanded and initialized\n-    \/\/ during box expansion and will replace all uses of box.\n+    \/\/ Defer returning VectorBoxAllocation node, they are currently uninitialized buffer placeholders.\n+    \/\/ During box expansion VBAs are expanded into Allocation IR and initialized with wrapped vectors\n+    \/\/ and replaces all the uses of box.\n@@ -2386,0 +2395,1 @@\n+    assert(!value->is_InlineType() || !value->as_InlineType()->is_larval(), \"returning a larval\");\n@@ -2390,1 +2400,1 @@\n-        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), method()->signature()->returns_null_free_inline_type());\n+        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), false);\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -53,2 +54,2 @@\n-  if (is_field && field_holder->is_inlinetype() && peek()->is_InlineType()) {\n-    assert(is_get, \"inline type field store not supported\");\n+  if (is_get && is_field && field_holder->is_inlinetype() && peek()->is_InlineType()) {\n+    assert(!field->is_multifield_base() && !field->is_multifield(), \"Illegal direct read access to multifield through getfield bytecode.\");\n@@ -95,1 +96,6 @@\n-    int obj_depth = is_get ? 0 : field->type()->size();\n+    int obj_depth = 0;\n+    if (!is_get) {\n+      const ciType* ftype = field->type();\n+      \/\/ A non-scalarized multifield is represented as a single field.\n+      obj_depth = field->is_multifield_base() ? ftype->elem_word_count() : ftype->size();\n+    }\n@@ -148,0 +154,5 @@\n+  if (field->is_multifield_base() || field->is_multifield()) {\n+    \/\/ A read access to multifield should be preformed using Unsafe.get* APIs.\n+    assert(false, \"Illegal direct read access to mutifield through getfield bytecode\");\n+  }\n+\n@@ -235,0 +246,83 @@\n+  if (obj->is_InlineType()) {\n+    \/\/ TODO 8325106 Factor into own method\n+    \/\/ TODO 8325106 Assert that we only do this in the constructor and align with checks in ::do_call\n+    \/\/if (_method->is_object_constructor() && _method->holder()->is_inlinetype())\n+    assert(obj->as_InlineType()->is_larval(), \"must be larval\");\n+\n+    \/\/ TODO 8325106 Assert that holder is null-free\n+    \/*\n+    int holder_depth = field->type()->size();\n+    null_check(peek(holder_depth));\n+    if (stopped()) {\n+      return;\n+    }\n+    *\/\n+\n+    if (field->is_null_free()) {\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      int nargs = 1 + field->type()->size();\n+      inc_sp(nargs);\n+      val = null_check(val);\n+      if (stopped()) {\n+        return;\n+      }\n+    }\n+    if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n+      \/\/ Scalarize inline type field value\n+      val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n+    } else if (val->is_InlineType() && !field->is_flat()) {\n+      \/\/ Field value needs to be allocated because it can be merged with an oop.\n+      \/\/ Re-execute if buffering triggers deoptimization.\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      int nargs = 1 + field->type()->size();\n+      inc_sp(nargs);\n+      val = val->as_InlineType()->buffer(this);\n+    } else if (field->is_multifield_base()) {\n+      assert(!InlineTypeNode::is_multifield_scalarized(field), \"Sanity check\");\n+      \/\/ Only possible non-unsafe access to multifield base is within vector payload constructors\n+      \/\/ for initializing entire bundle with a default value.\n+      val = _gvn.transform(VectorNode::scalar2vector(val, field->secondary_fields_count(), Type::get_const_type(field->type()), false));\n+    } else if (field->is_multifield()) {\n+      assert(false, \"Illegal direct write access to mutifield through putfield bytecode\");\n+    }\n+\n+    \/\/ Clone the inline type node and set the new field value\n+    InlineTypeNode* new_vt = obj->clone()->as_InlineType();\n+    new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n+\n+    {\n+      PreserveReexecuteState preexecs(this);\n+      jvms()->set_should_reexecute(true);\n+      int nargs = 1 + field->type()->size();\n+      inc_sp(nargs);\n+      new_vt = new_vt->adjust_scalarization_depth(this);\n+    }\n+\n+    \/\/ TODO 8325106 needed? I think so, because although we are incrementally inlining, we might not incrementally inline this very method\n+    if ((!_caller->has_method() || C->inlining_incrementally()) && new_vt->is_allocated(&gvn())) {\n+      \/\/ We need to store to the buffer\n+      \/\/ TODO 8325106 looks like G1BarrierSetC2::g1_can_remove_pre_barrier is not strong enough to remove the pre barrier\n+      \/\/ TODO is it really guaranteed that the preval is null?\n+      new_vt->store(this, new_vt->get_oop(), new_vt->get_oop(), new_vt->bottom_type()->inline_klass(), 0, C2_TIGHTLY_COUPLED_ALLOC | IN_HEAP | MO_UNORDERED, field->offset_in_bytes());\n+\n+      \/\/ Preserve allocation ptr to create precedent edge to it in membar\n+      \/\/ generated on exit from constructor.\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(new_vt->get_oop());\n+      if (alloc != nullptr) {\n+        set_alloc_with_final(new_vt->get_oop());\n+      }\n+      set_wrote_final(true);\n+    }\n+\n+    replace_in_map(obj, _gvn.transform(new_vt));\n+    return;\n+  }\n+\n+  if (field->is_null_free()) {\n+    PreserveReexecuteState preexecs(this);\n+    inc_sp(1);\n+    jvms()->set_should_reexecute(true);\n+    val = null_check(val);\n+  }\n@@ -301,1 +395,0 @@\n-  bool null_free = iter().has_Q_signature();\n@@ -308,1 +401,1 @@\n-  ciArrayKlass* array_klass = ciArrayKlass::make(klass, null_free);\n+  ciArrayKlass* array_klass = ciArrayKlass::make(klass);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":98,"deletions":5,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  bool null_free = iter().has_Q_signature();\n@@ -81,1 +80,0 @@\n-    assert(!null_free, \"Inline type should be loaded\");\n@@ -99,1 +97,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), nullptr, null_free);\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)));\n@@ -287,1 +285,0 @@\n-  assert(!klass->is_inlinetype(), \"unexpected inline type\");\n@@ -304,0 +301,5 @@\n+  if (klass->is_inlinetype()) {\n+    push(InlineTypeNode::make_default(_gvn, klass->as_inline_klass(), \/* is_larval *\/ true));\n+    return;\n+  }\n+\n@@ -324,69 +326,0 @@\n-\/\/------------------------------do_aconst_init---------------------------------\n-void Parse::do_aconst_init() {\n-  bool will_link;\n-  ciInlineKlass* vk = iter().get_klass(will_link)->as_inline_klass();\n-  assert(will_link && !iter().is_unresolved_klass(), \"aconst_init: typeflow responsibility\");\n-\n-  if (C->needs_clinit_barrier(vk, method())) {\n-    clinit_barrier(vk, method());\n-    if (stopped())  return;\n-  }\n-\n-  push(InlineTypeNode::make_default(_gvn, vk));\n-}\n-\n-\/\/------------------------------do_withfield------------------------------------\n-void Parse::do_withfield() {\n-  bool will_link;\n-  ciField* field = iter().get_field(will_link);\n-  assert(will_link, \"withfield: typeflow responsibility\");\n-  int holder_depth = field->type()->size() \/ field->type()->bundle_size();\n-  null_check(peek(holder_depth));\n-  if (stopped()) {\n-    return;\n-  }\n-  Node* val = pop_node(field->layout_type());\n-  Node* holder = pop();\n-\n-  if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n-    \/\/ Scalarize inline type field value\n-    assert(!field->is_null_free() || !gvn().type(val)->maybe_null(), \"Null store to null-free field\");\n-    val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n-  } else if (val->is_InlineType() && !field->is_flat()) {\n-    \/\/ Field value needs to be allocated because it can be merged with an oop.\n-    \/\/ Re-execute withfield if buffering triggers deoptimization.\n-    PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n-    int nargs = 1 + field->type()->size() \/ field->type()->bundle_size();\n-    inc_sp(nargs);\n-    val = val->as_InlineType()->buffer(this);\n-  }\n-\n-  \/\/ Clone the inline type node and set the new field value\n-  InlineTypeNode* new_vt = holder->clone()->as_InlineType();\n-  new_vt->set_oop(gvn().zerocon(T_OBJECT));\n-  new_vt->set_is_buffered(gvn(), false);\n-\n-  BasicType bt = field->type()->basic_type();\n-  int vec_len = field->secondary_fields_count();\n-  bool scalarize_fields = !field->is_multifield_base() || !is_java_primitive(bt) ||\n-                          !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n-  if (scalarize_fields) {\n-    for(int i = 0; i < vec_len; i++) {\n-      new_vt->set_field_value_by_offset(field->offset_in_bytes() + i * type2aelembytes(bt), val);\n-    }\n-  } else {\n-    val = _gvn.transform(VectorNode::scalar2vector(val, field->secondary_fields_count(), Type::get_const_type(field->type()), false));\n-    new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n-  }\n-\n-  {\n-    PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n-    int nargs = 1 + InlineTypeNode::stack_size_for_field(field);\n-    inc_sp(nargs);\n-    new_vt = new_vt->adjust_scalarization_depth(this);\n-  }\n-  push(_gvn.transform(new_vt));\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":6,"deletions":73,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -77,2 +77,1 @@\n-       (has_scalar_args &&\n-         !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed))) {\n+       (has_scalar_args && !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed))) {\n@@ -649,1 +648,1 @@\n-      !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n+      !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed)) {\n@@ -896,1 +895,1 @@\n-  int opc = bcast_mode == VectorSupport::MODE_BITS_COERCED_LONG_TO_MASK ? Op_VectorLongToMask : VectorNode::replicate_opcode(elem_bt);\n+  int opc = bcast_mode == VectorSupport::MODE_BITS_COERCED_LONG_TO_MASK ? Op_VectorLongToMask : Op_Replicate;\n@@ -2126,1 +2125,1 @@\n-        !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed))) {\n+        !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed))) {\n@@ -3134,1 +3133,1 @@\n-        !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed) ||\n+        !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed) ||\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -391,22 +391,0 @@\n-int VectorNode::replicate_opcode(BasicType bt) {\n-  switch(bt) {\n-    case T_BOOLEAN:\n-    case T_BYTE:\n-      return Op_ReplicateB;\n-    case T_SHORT:\n-    case T_CHAR:\n-      return Op_ReplicateS;\n-    case T_INT:\n-      return Op_ReplicateI;\n-    case T_LONG:\n-      return Op_ReplicateL;\n-    case T_FLOAT:\n-      return Op_ReplicateF;\n-    case T_DOUBLE:\n-      return Op_ReplicateD;\n-    default:\n-      assert(false, \"wrong type: %s\", type2name(bt));\n-      return 0;\n-  }\n-}\n-\n@@ -510,1 +488,1 @@\n-        Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vlen, bt)) {\n+        Matcher::match_rule_supported_vector(Op_Replicate, vlen, bt)) {\n@@ -523,1 +501,1 @@\n-        Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vlen, bt)) {\n+        Matcher::match_rule_supported_vector(Op_Replicate, vlen, bt)) {\n@@ -630,16 +608,0 @@\n-\/\/ Check if input is loop invariant vector.\n-bool VectorNode::is_invariant_vector(Node* n) {\n-  \/\/ Only Replicate vector nodes are loop invariant for now.\n-  switch (n->Opcode()) {\n-  case Op_ReplicateB:\n-  case Op_ReplicateS:\n-  case Op_ReplicateI:\n-  case Op_ReplicateL:\n-  case Op_ReplicateF:\n-  case Op_ReplicateD:\n-    return true;\n-  default:\n-    return false;\n-  }\n-}\n-\n@@ -867,19 +829,1 @@\n-  switch (bt) {\n-  case T_BOOLEAN:\n-  case T_BYTE:\n-    return new ReplicateBNode(s, vt);\n-  case T_CHAR:\n-  case T_SHORT:\n-    return new ReplicateSNode(s, vt);\n-  case T_INT:\n-    return new ReplicateINode(s, vt);\n-  case T_LONG:\n-    return new ReplicateLNode(s, vt);\n-  case T_FLOAT:\n-    return new ReplicateFNode(s, vt);\n-  case T_DOUBLE:\n-    return new ReplicateDNode(s, vt);\n-  default:\n-    fatal(\"Type '%s' is not supported for vectors\", type2name(bt));\n-    return nullptr;\n-  }\n+  return new ReplicateNode(s, vt);\n@@ -970,4 +914,3 @@\n-  case Op_ReplicateB:\n-  case Op_ReplicateS:\n-  case Op_ReplicateI:\n-  case Op_ReplicateL:\n+  case Op_Replicate:\n+    return is_integral_type(n->bottom_type()->is_vect()->element_basic_type()) &&\n+           is_con(n->in(1), -1);\n@@ -984,4 +927,2 @@\n-  case Op_ReplicateB:\n-  case Op_ReplicateS:\n-  case Op_ReplicateI:\n-  case Op_ReplicateL:\n+  case Op_Replicate:\n+    return n->in(1)->bottom_type()->is_zero_type();\n@@ -990,4 +931,0 @@\n-  case Op_ReplicateF:\n-    return n->in(1)->bottom_type() == TypeF::ZERO;\n-  case Op_ReplicateD:\n-    return n->in(1)->bottom_type() == TypeD::ZERO;\n@@ -1661,1 +1598,1 @@\n-  } else if (VectorNode::is_invariant_vector(cnt)) {\n+  } else if (cnt->Opcode() == Op_Replicate) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":9,"deletions":72,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-  static int replicate_opcode(BasicType bt);\n@@ -113,1 +112,0 @@\n-  static bool is_invariant_vector(Node* n);\n@@ -1139,3 +1137,1 @@\n-\/\/------------------------------ReplicateBNode---------------------------------\n-\/\/ Replicate byte scalar to be vector\n-class ReplicateBNode : public VectorNode {\n+class ReplicateNode : public VectorNode {\n@@ -1143,41 +1139,3 @@\n-  ReplicateBNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------ReplicateSNode---------------------------------\n-\/\/ Replicate short scalar to be vector\n-class ReplicateSNode : public VectorNode {\n- public:\n-  ReplicateSNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------ReplicateINode---------------------------------\n-\/\/ Replicate int scalar to be vector\n-class ReplicateINode : public VectorNode {\n- public:\n-  ReplicateINode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------ReplicateLNode---------------------------------\n-\/\/ Replicate long scalar to be vector\n-class ReplicateLNode : public VectorNode {\n- public:\n-  ReplicateLNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------ReplicateFNode---------------------------------\n-\/\/ Replicate float scalar to be vector\n-class ReplicateFNode : public VectorNode {\n- public:\n-  ReplicateFNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------ReplicateDNode---------------------------------\n-\/\/ Replicate double scalar to be vector\n-class ReplicateDNode : public VectorNode {\n- public:\n-  ReplicateDNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}\n+  ReplicateNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {\n+    assert(vt->element_basic_type() != T_CHAR, \"not support\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":4,"deletions":46,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n@@ -61,1 +63,0 @@\n-#include \"services\/nmtCommon.hpp\"\n@@ -103,0 +104,1 @@\n+bool   Arguments::_module_patching_disables_cds = false;\n@@ -134,0 +136,3 @@\n+\/\/ True if -Xint\/-Xmixed\/-Xcomp were specified\n+static bool mode_flag_cmd_line = false;\n+\n@@ -528,0 +533,7 @@\n+  { \"DoReserveCopyInSuperWord\",     JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+  { \"UseCounterDecay\",              JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+\n+#ifdef LINUX\n+  { \"UseHugeTLBFS\",                 JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+  { \"UseSHM\",                       JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+#endif\n@@ -1256,2 +1268,1 @@\n-  if (is_internal_module_property(key) ||\n-      strcmp(key, \"jdk.module.main\") == 0) {\n+  if (is_internal_module_property(key)) {\n@@ -1264,1 +1275,2 @@\n-    MetaspaceShared::disable_full_module_graph();\n+    CDSConfig::disable_loading_full_module_graph();\n+    CDSConfig::disable_dumping_full_module_graph();\n@@ -1323,2 +1335,1 @@\n-                                         \"jdk.module.upgrade.path\",\n-                                         \"jdk.module.patch.0\" };\n+                                         \"jdk.module.upgrade.path\"};\n@@ -1326,3 +1337,1 @@\n-                                      \"--upgrade-module-path\",\n-                                      \"--patch-module\"\n-                                    };\n+                                      \"--upgrade-module-path\"};\n@@ -1330,1 +1339,1 @@\n-  assert(is_dumping_archive(),\n+  assert(CDSConfig::is_dumping_archive(),\n@@ -1345,0 +1354,5 @@\n+  if (_module_patching_disables_cds) {\n+    vm_exit_during_initialization(\n+            \"Cannot use the following option when dumping the shared archive\", \"--patch-module\");\n+  }\n+\n@@ -1371,0 +1385,10 @@\n+\n+  if (_module_patching_disables_cds) {\n+    if (RequireSharedSpaces) {\n+      warning(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    } else {\n+      log_info(cds)(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    }\n+    return true;\n+  }\n+\n@@ -2169,1 +2193,1 @@\n-      add_patch_mod_prefix(module_name, module_equal + 1, false \/* no append *\/);\n+      add_patch_mod_prefix(module_name, module_equal + 1, false \/* no append *\/, false \/* no cds *\/);\n@@ -2211,1 +2235,1 @@\n-        add_patch_mod_prefix(module_name, path, true \/* append *\/);\n+        add_patch_mod_prefix(module_name, path, true \/* append *\/, true \/* cds OK*\/);\n@@ -2296,1 +2320,1 @@\n-bool Arguments::enable_valhalla(const char* prop_value) {\n+bool Arguments::is_jdk_incubator_vector(const char* prop_value) {\n@@ -2409,2 +2433,2 @@\n-      if (enable_valhalla(tail)) {\n-        EnablePrimitiveClasses = true;\n+      if (is_jdk_incubator_vector(tail)) {\n+        set_enable_preview();\n@@ -2491,0 +2515,4 @@\n+      \/\/ --enable-preview enables Valhalla, EnableValhalla VM option will eventually be removed before integration\n+      if (FLAG_SET_CMDLINE(EnableValhalla, true) != JVMFlag::SUCCESS) {\n+        return JNI_EINVAL;\n+      }\n@@ -2676,0 +2704,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2679,0 +2708,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2683,0 +2713,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2685,1 +2716,1 @@\n-      DumpSharedSpaces = true;\n+      CDSConfig::enable_dumping_static_archive();\n@@ -2956,6 +2987,0 @@\n-  if (!EnableValhalla && EnablePrimitiveClasses) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"Cannot specify -XX:+EnablePrimitiveClasses without -XX:+EnableValhalla\");\n-    return JNI_EINVAL;\n-  }\n-\n@@ -2980,0 +3005,1 @@\n+static bool _java_base_module_patching_disables_cds = false;\n@@ -2981,1 +3007,1 @@\n-    return _patch_mod_prefix != nullptr && _patch_mod_prefix->find((void*)JAVA_BASE_NAME, match_module) >= 0;\n+  return _java_base_module_patching_disables_cds;\n@@ -2984,1 +3010,8 @@\n-void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool allow_append) {\n+void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool allow_append, bool allow_cds) {\n+  if (!allow_cds) {\n+    _module_patching_disables_cds = true;\n+    if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+      _java_base_module_patching_disables_cds = true;\n+    }\n+  }\n+\n@@ -3128,9 +3161,13 @@\n-  if (DumpSharedSpaces) {\n-    \/\/ Compiler threads may concurrently update the class metadata (such as method entries), so it's\n-    \/\/ unsafe with -Xshare:dump (which modifies the class metadata in place). Let's disable\n-    \/\/ compiler just to be safe.\n-    \/\/\n-    \/\/ Note: this is not a concern for dynamically dumping shared spaces, which makes a copy of the\n-    \/\/ class metadata instead of modifying them in place. The copy is inaccessible to the compiler.\n-    \/\/ TODO: revisit the following for the static archive case.\n-    set_mode_flags(_int);\n+  if (CDSConfig::is_dumping_static_archive()) {\n+    if (!mode_flag_cmd_line) {\n+      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n+      \/\/\n+      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n+      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n+      set_mode_flags(_int);\n+    } else if (_mode == _comp) {\n+      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n+      \/\/ Java code, so there's not much benefit in running -Xcomp.\n+      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n+      set_mode_flags(_mixed);\n+    }\n@@ -3152,1 +3189,1 @@\n-    DynamicDumpSharedSpaces = false;\n+    CDSConfig::disable_dumping_dynamic_archive();\n@@ -3154,1 +3191,1 @@\n-    DynamicDumpSharedSpaces = true;\n+    CDSConfig::enable_dumping_dynamic_archive();\n@@ -3168,1 +3205,1 @@\n-  if (UseSharedSpaces && patch_mod_javabase()) {\n+  if (UseSharedSpaces && patch_mod_javabase() && _module_patching_disables_cds) {\n@@ -3171,1 +3208,1 @@\n-  if (UseSharedSpaces && !DumpSharedSpaces && check_unsupported_cds_runtime_properties()) {\n+  if (UseSharedSpaces && check_unsupported_cds_runtime_properties()) {\n@@ -3175,1 +3212,1 @@\n-  if (DumpSharedSpaces || DynamicDumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -3452,1 +3489,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_static_archive()) {\n@@ -3463,1 +3500,1 @@\n-  if (DumpSharedSpaces || UseSharedSpaces) {\n+  if (CDSConfig::is_dumping_static_archive() || UseSharedSpaces) {\n@@ -3480,1 +3517,1 @@\n-    const size_t len = jvm_path_len + file_sep_len + 20;\n+    const size_t len = jvm_path_len + file_sep_len + strlen(\"classes_nocoops_valhalla.jsa\") + 1;\n@@ -3482,3 +3519,7 @@\n-    jio_snprintf(_default_shared_archive_path, len,\n-                LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n-                jvm_path, os::file_separator());\n+    LP64_ONLY(bool nocoops = !UseCompressedOops);\n+    NOT_LP64(bool nocoops = false);\n+    bool valhalla = CDSConfig::is_valhalla_preview();\n+    jio_snprintf(_default_shared_archive_path, len, \"%s%sclasses%s%s.jsa\",\n+                jvm_path, os::file_separator(),\n+                 nocoops ? \"_nocoops\" : \"\",\n+                 valhalla ? \"_valhalla\" : \"\");\n@@ -3533,1 +3574,1 @@\n-    if (DumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_static_archive()) {\n@@ -3550,1 +3591,1 @@\n-    if (is_dumping_archive() && archives > 1) {\n+    if (CDSConfig::is_dumping_archive() && archives > 1) {\n@@ -3555,1 +3596,1 @@\n-    if (DumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_static_archive()) {\n@@ -3582,1 +3623,1 @@\n-            DynamicDumpSharedSpaces = true;\n+            CDSConfig::enable_dumping_dynamic_archive();\n@@ -3997,6 +4038,0 @@\n-  if (CountCompiledCalls) {\n-    if (UseCounterDecay) {\n-      warning(\"UseCounterDecay disabled because CountCalls is set\");\n-      UseCounterDecay = false;\n-    }\n-  }\n@@ -4020,1 +4055,1 @@\n-  if (DumpSharedSpaces || RequireSharedSpaces) {\n+  if (CDSConfig::is_dumping_static_archive() || RequireSharedSpaces) {\n@@ -4124,1 +4159,1 @@\n-  if (!EnableValhalla || (is_interpreter_only() && !is_dumping_archive() && !UseSharedSpaces)) {\n+  if (!EnableValhalla || (is_interpreter_only() && !CDSConfig::is_dumping_archive() && !UseSharedSpaces)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":92,"deletions":57,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -257,0 +257,2 @@\n+  static bool _module_patching_disables_cds;\n+\n@@ -323,1 +325,1 @@\n-  static bool enable_valhalla(const char* prop_value);\n+  static bool is_jdk_incubator_vector(const char* prop_value);\n@@ -486,1 +488,1 @@\n-  static void add_patch_mod_prefix(const char *module_name, const char *path, bool allow_append);\n+  static void add_patch_mod_prefix(const char *module_name, const char *path, bool allow_append, bool allow_cds);\n@@ -488,0 +490,1 @@\n+  static bool module_patching_disables_cds() { return _module_patching_disables_cds; }\n@@ -533,6 +536,0 @@\n-  static bool is_dumping_archive() { return DumpSharedSpaces || DynamicDumpSharedSpaces; }\n-\n-  static void assert_is_dumping_archive() {\n-    assert(Arguments::is_dumping_archive(), \"dump time only\");\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciEnv.hpp\"\n@@ -89,0 +90,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -1553,0 +1555,1 @@\n+  int skip_next_fields_cnt = 0;\n@@ -1555,1 +1558,13 @@\n-      if (!fs.access_flags().is_static() && !fs.is_multifield() && (!skip_internal || !fs.field_flags().is_injected())) {\n+      if (skip_next_fields_cnt > 0) {\n+         skip_next_fields_cnt--;\n+         continue;\n+      }\n+      int bundle_size = 1;\n+      bool is_multifield_scalarized = false;\n+      if (fs.is_multifield_base()) {\n+         BasicType ft = Signature::basic_type(fs.signature());\n+         bundle_size = fs.field_descriptor().secondary_fields_count(fs.index());\n+         is_multifield_scalarized = ciEnv::is_multifield_scalarized(ft, bundle_size);\n+         skip_next_fields_cnt = !is_multifield_scalarized ? bundle_size - 1: 0;\n+      }\n+      if (!fs.access_flags().is_static() && (!skip_internal || !fs.field_flags().is_injected())) {\n@@ -1559,1 +1574,1 @@\n-        field._secondary_fields_count = fs.is_multifield_base() ? fs.field_descriptor().secondary_fields_count(fs.index()) : 1;\n+        field._secondary_fields_count = !is_multifield_scalarized && fs.is_multifield_base() ? bundle_size : 1;\n@@ -1767,3 +1782,13 @@\n-        BasicLock* lock = mon_info->lock();\n-        ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n-        assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        if (LockingMode == LM_LIGHTWEIGHT && exec_mode == Unpack_none) {\n+          \/\/ We have lost information about the correct state of the lock stack.\n+          \/\/ Inflate the locks instead. Enter then inflate to avoid races with\n+          \/\/ deflation.\n+          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n+          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          assert(mon->owner() == deoptee_thread, \"must be\");\n+        } else {\n+          BasicLock* lock = mon_info->lock();\n+          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n+          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -166,1 +166,0 @@\n-    case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -527,1 +527,1 @@\n-    return ((UpcallStub*)blob)->exception_handler();\n+    return StubRoutines::upcall_stub_exception_handler();\n@@ -3036,1 +3036,2 @@\n-      if (holder->is_inline_klass() && InlineKlass::cast(holder)->can_be_passed_as_fields() &&\n+      \/\/ We shouldn't scalarize 'this' in a value class constructor\n+      if (holder->is_inline_klass() && InlineKlass::cast(holder)->can_be_passed_as_fields() && !_method->is_object_constructor() &&\n@@ -3051,1 +3052,1 @@\n-      if (bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) {\n+      if (bt == T_OBJECT) {\n@@ -3179,1 +3180,0 @@\n-      assert(!method()->constMethod()->is_shared(), \"Cannot update shared const object\");\n@@ -3186,1 +3186,0 @@\n-      assert(!method->constMethod()->is_shared(), \"Cannot update a shared const object\");\n@@ -3633,6 +3632,11 @@\n-      \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-      if (lock->displaced_header().is_unlocked()) {\n-        \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-        \/\/ locked so it can't be async deflated until ownership is dropped.\n-        \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-        ObjectSynchronizer::inflate_helper(kptr2->obj());\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n+        if (lock->displaced_header().is_unlocked()) {\n+          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+          \/\/ locked so it can't be async deflated until ownership is dropped.\n+          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n+          ObjectSynchronizer::inflate_helper(kptr2->obj());\n+        }\n+        \/\/ Now the displaced header is free to move because the\n+        \/\/ object's header no longer refers to it.\n+        buf[i] = (intptr_t)lock->displaced_header().value();\n@@ -3640,3 +3644,6 @@\n-      \/\/ Now the displaced header is free to move because the\n-      \/\/ object's header no longer refers to it.\n-      buf[i++] = (intptr_t)lock->displaced_header().value();\n+#ifdef ASSERT\n+      else {\n+        buf[i] = badDispHeaderOSR;\n+      }\n+#endif\n+      i++;\n@@ -3816,1 +3823,1 @@\n-    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+    if (bt == T_OBJECT && callee->is_scalarized_arg(arg_num)) {\n@@ -3834,1 +3841,1 @@\n-    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+    if (bt == T_OBJECT && callee->is_scalarized_arg(arg_num)) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -413,2 +413,1 @@\n-  static int c_calling_convention(const BasicType *sig_bt, VMRegPair *regs, VMRegPair *regs2,\n-                                  int total_args_passed);\n+  static int c_calling_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed);\n@@ -611,1 +610,0 @@\n-  static void print_statistics();\n@@ -615,0 +613,2 @@\n+\n+  static void print_statistics() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-    public abstract static class VectorPayload { }\n+    public abstract value static class VectorPayload { }\n@@ -161,1 +161,1 @@\n-    public static abstract class Vector<E> extends VectorPayload { }\n+    public static abstract value class Vector<E> extends VectorPayload { }\n@@ -163,1 +163,1 @@\n-    public static abstract class VectorMask<E> extends VectorPayload { }\n+    public static abstract value class VectorMask<E> extends VectorPayload { }\n@@ -165,1 +165,1 @@\n-    public static abstract class VectorShuffle<E> extends VectorPayload { }\n+    public static abstract value class VectorShuffle<E> extends VectorPayload { }\n@@ -386,0 +386,30 @@\n+\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder(\"multifield payload : [ \");\n+            try {\n+                long start_offset = multiFieldOffset();\n+                Class<?> elemType = getClass().getDeclaredField(\"mfield\").getType();\n+                for (int i = 0; i < length(); i++) {\n+                    if (elemType == byte.class)\n+                        sb.append(U.getByte(this, start_offset + i));\n+                    else if (elemType == short.class)\n+                        sb.append(U.getShort(this, start_offset + i * Short.BYTES));\n+                    else if (elemType == int.class)\n+                        sb.append(U.getInt(this, start_offset + i * Integer.BYTES));\n+                    else if (elemType == long.class)\n+                        sb.append(U.getLong(this, start_offset + i * Long.BYTES));\n+                    else if (elemType == float.class)\n+                        sb.append(U.getFloat(this, start_offset + i * Float.BYTES));\n+                    else if (elemType == double.class)\n+                        sb.append(U.getDouble(this, start_offset + i * Double.BYTES));\n+                    else\n+                        assert false;\n+                    if (i < (length() - 1))\n+                        sb.append(\" , \");\n+                }\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            sb.append(\" ] \");\n+            return sb.toString();\n+        }\n@@ -1461,0 +1491,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-abstract class AbstractMask<E> extends VectorMask<E> {\n+abstract value class AbstractMask<E> extends VectorMask<E> {\n@@ -46,0 +46,1 @@\n+    @ForceInline\n@@ -59,0 +60,1 @@\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-abstract class AbstractShuffle<E> extends VectorShuffle<E> {\n+abstract value class AbstractShuffle<E> extends VectorShuffle<E> {\n@@ -44,0 +44,1 @@\n+    @ForceInline\n@@ -59,0 +60,1 @@\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +34,2 @@\n+import java.lang.foreign.ValueLayout;\n+import java.lang.reflect.Array;\n@@ -32,0 +37,1 @@\n+import java.util.Objects;\n@@ -39,1 +45,1 @@\n-abstract class AbstractVector<E> extends Vector<E> {\n+abstract value class AbstractVector<E> extends Vector<E> {\n@@ -385,0 +391,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(payload, offset, VSPECIES));\n@@ -603,1 +603,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(val, VSPECIES));\n@@ -776,1 +776,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, i, VSPECIES));\n@@ -780,1 +780,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(fn, VSPECIES));\n@@ -782,1 +782,0 @@\n-\n@@ -784,1 +783,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, 0, VSPECIES));\n@@ -788,0 +787,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF256Z)(prepare(payload, offset, VSPECIES));\n@@ -635,1 +635,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF256Z)(prepare(val, VSPECIES));\n@@ -808,1 +808,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF256B)(prepare(indexes, i, VSPECIES));\n@@ -812,1 +812,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF256B)(prepare(fn, VSPECIES));\n@@ -814,1 +814,0 @@\n-\n@@ -816,1 +815,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF256B)(prepare(indexes, 0, VSPECIES));\n@@ -820,0 +819,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -695,1 +695,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF512Z)(prepare(payload, offset, VSPECIES));\n@@ -699,1 +699,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF512Z)(prepare(val, VSPECIES));\n@@ -872,1 +872,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF512B)(prepare(indexes, i, VSPECIES));\n@@ -876,1 +876,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF512B)(prepare(fn, VSPECIES));\n@@ -878,1 +878,0 @@\n-\n@@ -880,1 +879,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF512B)(prepare(indexes, 0, VSPECIES));\n@@ -884,0 +883,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -583,1 +583,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(payload, offset, VSPECIES));\n@@ -587,1 +587,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(val, VSPECIES));\n@@ -760,1 +760,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, i, VSPECIES));\n@@ -764,1 +764,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(fn, VSPECIES));\n@@ -766,1 +766,0 @@\n-\n@@ -768,1 +767,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, 0, VSPECIES));\n@@ -772,0 +771,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxBZ)(prepare(payload, offset, VSPECIES));\n@@ -573,1 +573,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxBZ)(prepare(val, VSPECIES));\n@@ -746,1 +746,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxBB)(prepare(indexes, i, VSPECIES));\n@@ -750,1 +750,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxBB)(prepare(fn, VSPECIES));\n@@ -752,1 +752,0 @@\n-\n@@ -754,1 +753,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMFMaxBB)(prepare(indexes, 0, VSPECIES));\n@@ -758,0 +757,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class ByteVector extends AbstractVector<Byte> {\n+public abstract value class ByteVector extends AbstractVector<Byte> {\n@@ -2968,1 +2968,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2986,1 +2986,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3404,2 +3404,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3456,2 +3454,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(payload, offset, VSPECIES));\n@@ -564,1 +564,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(val, VSPECIES));\n@@ -737,1 +737,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, i, VSPECIES));\n@@ -741,1 +741,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(fn, VSPECIES));\n@@ -743,1 +743,0 @@\n-\n@@ -745,1 +744,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, 0, VSPECIES));\n@@ -749,0 +748,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(payload, offset, VSPECIES));\n@@ -568,1 +568,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(val, VSPECIES));\n@@ -741,1 +741,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, i, VSPECIES));\n@@ -745,1 +745,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(fn, VSPECIES));\n@@ -747,1 +747,0 @@\n-\n@@ -749,1 +748,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, 0, VSPECIES));\n@@ -753,0 +752,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(payload, offset, VSPECIES));\n@@ -576,1 +576,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(val, VSPECIES));\n@@ -749,1 +749,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, i, VSPECIES));\n@@ -753,1 +753,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(fn, VSPECIES));\n@@ -755,1 +755,0 @@\n-\n@@ -757,1 +756,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, 0, VSPECIES));\n@@ -761,0 +760,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF8Z)(prepare(payload, offset, VSPECIES));\n@@ -562,1 +562,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF8Z)(prepare(val, VSPECIES));\n@@ -735,1 +735,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF8B)(prepare(indexes, i, VSPECIES));\n@@ -739,1 +739,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF8B)(prepare(fn, VSPECIES));\n@@ -741,1 +741,0 @@\n-\n@@ -743,1 +742,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF8B)(prepare(indexes, 0, VSPECIES));\n@@ -747,0 +746,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLZ)(prepare(payload, offset, VSPECIES));\n@@ -561,1 +561,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLZ)(prepare(val, VSPECIES));\n@@ -734,1 +734,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLB)(prepare(indexes, i, VSPECIES));\n@@ -738,1 +738,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLB)(prepare(fn, VSPECIES));\n@@ -740,1 +740,0 @@\n-\n@@ -742,1 +741,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMFMaxLB)(prepare(indexes, 0, VSPECIES));\n@@ -746,0 +745,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class DoubleVector extends AbstractVector<Double> {\n+public abstract value class DoubleVector extends AbstractVector<Double> {\n@@ -2774,1 +2774,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2792,1 +2792,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3079,2 +3079,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3136,2 +3134,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(payload, offset, VSPECIES));\n@@ -568,1 +568,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(val, VSPECIES));\n@@ -741,1 +741,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, i, VSPECIES));\n@@ -745,1 +745,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(fn, VSPECIES));\n@@ -747,1 +747,0 @@\n-\n@@ -749,1 +748,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, 0, VSPECIES));\n@@ -753,0 +752,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(payload, offset, VSPECIES));\n@@ -576,1 +576,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(val, VSPECIES));\n@@ -749,1 +749,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, i, VSPECIES));\n@@ -753,1 +753,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(fn, VSPECIES));\n@@ -755,1 +755,0 @@\n-\n@@ -757,1 +756,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, 0, VSPECIES));\n@@ -761,0 +760,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(payload, offset, VSPECIES));\n@@ -592,1 +592,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(val, VSPECIES));\n@@ -765,1 +765,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, i, VSPECIES));\n@@ -769,1 +769,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(fn, VSPECIES));\n@@ -771,1 +771,0 @@\n-\n@@ -773,1 +772,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, 0, VSPECIES));\n@@ -777,0 +776,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(payload, offset, VSPECIES));\n@@ -564,1 +564,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(val, VSPECIES));\n@@ -737,1 +737,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, i, VSPECIES));\n@@ -741,1 +741,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(fn, VSPECIES));\n@@ -743,1 +743,0 @@\n-\n@@ -745,1 +744,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, 0, VSPECIES));\n@@ -749,0 +748,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIZ)(prepare(payload, offset, VSPECIES));\n@@ -561,1 +561,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIZ)(prepare(val, VSPECIES));\n@@ -734,1 +734,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIB)(prepare(indexes, i, VSPECIES));\n@@ -738,1 +738,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIB)(prepare(fn, VSPECIES));\n@@ -740,1 +740,0 @@\n-\n@@ -742,1 +741,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMFMaxIB)(prepare(indexes, 0, VSPECIES));\n@@ -746,0 +745,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class FloatVector extends AbstractVector<Float> {\n+public abstract value class FloatVector extends AbstractVector<Float> {\n@@ -2794,1 +2794,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2812,1 +2812,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3085,2 +3085,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3142,2 +3140,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(payload, offset, VSPECIES));\n@@ -579,1 +579,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(val, VSPECIES));\n@@ -752,1 +752,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, i, VSPECIES));\n@@ -756,1 +756,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(fn, VSPECIES));\n@@ -758,1 +758,0 @@\n-\n@@ -760,1 +759,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, 0, VSPECIES));\n@@ -764,0 +763,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -583,1 +583,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(payload, offset, VSPECIES));\n@@ -587,1 +587,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(val, VSPECIES));\n@@ -760,1 +760,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, i, VSPECIES));\n@@ -764,1 +764,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(fn, VSPECIES));\n@@ -766,1 +766,0 @@\n-\n@@ -768,1 +767,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, 0, VSPECIES));\n@@ -772,0 +771,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(payload, offset, VSPECIES));\n@@ -603,1 +603,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(val, VSPECIES));\n@@ -776,1 +776,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, i, VSPECIES));\n@@ -780,1 +780,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(fn, VSPECIES));\n@@ -782,1 +782,0 @@\n-\n@@ -784,1 +783,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, 0, VSPECIES));\n@@ -788,0 +787,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -571,1 +571,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(payload, offset, VSPECIES));\n@@ -575,1 +575,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(val, VSPECIES));\n@@ -748,1 +748,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, i, VSPECIES));\n@@ -752,1 +752,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(fn, VSPECIES));\n@@ -754,1 +754,0 @@\n-\n@@ -756,1 +755,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, 0, VSPECIES));\n@@ -760,0 +759,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIZ)(prepare(payload, offset, VSPECIES));\n@@ -573,1 +573,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIZ)(prepare(val, VSPECIES));\n@@ -760,1 +760,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIB)(prepare(indexes, i, VSPECIES));\n@@ -764,1 +764,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxIB)(prepare(fn, VSPECIES));\n@@ -766,1 +766,0 @@\n-\n@@ -768,1 +767,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMFMaxIB)(prepare(indexes, 0, VSPECIES));\n@@ -772,0 +771,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class IntVector extends AbstractVector<Integer> {\n+public abstract value class IntVector extends AbstractVector<Integer> {\n@@ -2957,1 +2957,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2975,1 +2975,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3253,2 +3253,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3310,2 +3308,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -561,1 +561,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(payload, offset, VSPECIES));\n@@ -565,1 +565,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF16Z)(prepare(val, VSPECIES));\n@@ -738,1 +738,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, i, VSPECIES));\n@@ -742,1 +742,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF16B)(prepare(fn, VSPECIES));\n@@ -744,1 +744,0 @@\n-\n@@ -746,1 +745,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF16B)(prepare(indexes, 0, VSPECIES));\n@@ -750,0 +749,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(payload, offset, VSPECIES));\n@@ -569,1 +569,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(val, VSPECIES));\n@@ -742,1 +742,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, i, VSPECIES));\n@@ -746,1 +746,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(fn, VSPECIES));\n@@ -748,1 +748,0 @@\n-\n@@ -750,1 +749,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, 0, VSPECIES));\n@@ -754,0 +753,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(payload, offset, VSPECIES));\n@@ -577,1 +577,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(val, VSPECIES));\n@@ -750,1 +750,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, i, VSPECIES));\n@@ -754,1 +754,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(fn, VSPECIES));\n@@ -756,1 +756,0 @@\n-\n@@ -758,1 +757,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, 0, VSPECIES));\n@@ -762,0 +761,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -559,1 +559,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF8Z)(prepare(payload, offset, VSPECIES));\n@@ -563,1 +563,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF8Z)(prepare(val, VSPECIES));\n@@ -736,1 +736,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF8B)(prepare(indexes, i, VSPECIES));\n@@ -740,1 +740,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF8B)(prepare(fn, VSPECIES));\n@@ -742,1 +742,0 @@\n-\n@@ -744,1 +743,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF8B)(prepare(indexes, 0, VSPECIES));\n@@ -748,0 +747,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -559,1 +559,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLZ)(prepare(payload, offset, VSPECIES));\n@@ -563,1 +563,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLZ)(prepare(val, VSPECIES));\n@@ -736,1 +736,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLB)(prepare(indexes, i, VSPECIES));\n@@ -740,1 +740,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxLB)(prepare(fn, VSPECIES));\n@@ -742,1 +742,0 @@\n-\n@@ -744,1 +743,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMFMaxLB)(prepare(indexes, 0, VSPECIES));\n@@ -748,0 +747,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class LongVector extends AbstractVector<Long> {\n+public abstract value class LongVector extends AbstractVector<Long> {\n@@ -2823,1 +2823,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2841,1 +2841,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3132,2 +3132,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3189,2 +3187,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -583,1 +583,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(payload, offset, VSPECIES));\n@@ -587,1 +587,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF64Z)(prepare(val, VSPECIES));\n@@ -760,1 +760,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, i, VSPECIES));\n@@ -764,1 +764,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF64B)(prepare(fn, VSPECIES));\n@@ -766,1 +766,0 @@\n-\n@@ -768,1 +767,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF64B)(prepare(indexes, 0, VSPECIES));\n@@ -772,0 +771,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(payload, offset, VSPECIES));\n@@ -603,1 +603,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF128Z)(prepare(val, VSPECIES));\n@@ -776,1 +776,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, i, VSPECIES));\n@@ -780,1 +780,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF128B)(prepare(fn, VSPECIES));\n@@ -782,1 +782,0 @@\n-\n@@ -784,1 +783,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF128B)(prepare(indexes, 0, VSPECIES));\n@@ -788,0 +787,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF256Z)(prepare(payload, offset, VSPECIES));\n@@ -635,1 +635,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF256Z)(prepare(val, VSPECIES));\n@@ -808,1 +808,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF256B)(prepare(indexes, i, VSPECIES));\n@@ -812,1 +812,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF256B)(prepare(fn, VSPECIES));\n@@ -814,1 +814,0 @@\n-\n@@ -816,1 +815,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF256B)(prepare(indexes, 0, VSPECIES));\n@@ -820,0 +819,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(payload, offset, VSPECIES));\n@@ -579,1 +579,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF32Z)(prepare(val, VSPECIES));\n@@ -752,1 +752,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, i, VSPECIES));\n@@ -756,1 +756,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF32B)(prepare(fn, VSPECIES));\n@@ -758,1 +758,0 @@\n-\n@@ -760,1 +759,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF32B)(prepare(indexes, 0, VSPECIES));\n@@ -764,0 +763,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxSZ)(prepare(payload, offset, VSPECIES));\n@@ -573,1 +573,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxSZ)(prepare(val, VSPECIES));\n@@ -746,1 +746,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxSB)(prepare(indexes, i, VSPECIES));\n@@ -750,1 +750,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMFMaxSB)(prepare(fn, VSPECIES));\n@@ -752,1 +752,0 @@\n-\n@@ -754,1 +753,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMFMaxSB)(prepare(indexes, 0, VSPECIES));\n@@ -758,0 +757,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class ShortVector extends AbstractVector<Short> {\n+public abstract value class ShortVector extends AbstractVector<Short> {\n@@ -2969,1 +2969,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -2987,1 +2987,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3398,2 +3398,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -3455,2 +3453,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1175,1 +1175,1 @@\n-public abstract class Vector<E> extends jdk.internal.vm.vector.VectorSupport.Vector<E> {\n+public abstract value class Vector<E> extends jdk.internal.vm.vector.VectorSupport.Vector<E> {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-public abstract class VectorMask<E> extends jdk.internal.vm.vector.VectorSupport.VectorMask<E> {\n+public abstract value class VectorMask<E> extends jdk.internal.vm.vector.VectorSupport.VectorMask<E> {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-public abstract class VectorShuffle<E> extends jdk.internal.vm.vector.VectorSupport.VectorShuffle<E> {\n+public abstract value class VectorShuffle<E> extends jdk.internal.vm.vector.VectorSupport.VectorShuffle<E> {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public abstract class $abstractvectortype$ extends AbstractVector<$Boxtype$> {\n+public abstract value class $abstractvectortype$ extends AbstractVector<$Boxtype$> {\n@@ -3499,1 +3499,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -3517,1 +3517,1 @@\n-     * @throws IllegalArgumentException if the index is is out of range\n+     * @throws IllegalArgumentException if the index is out of range\n@@ -4218,2 +4218,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n@@ -4279,2 +4277,0 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -852,1 +852,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$Z)(prepare(payload, offset, VSPECIES));\n@@ -856,1 +856,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$Z)(prepare(val, VSPECIES));\n@@ -867,1 +867,1 @@\n-            this(prepare(payload, offset, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$Z)(prepare(payload, offset, VSPECIES));\n@@ -871,1 +871,1 @@\n-            this(prepare(val, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$Z)(prepare(val, VSPECIES));\n@@ -1068,1 +1068,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$B)(prepare(indexes, i, VSPECIES));\n@@ -1072,1 +1072,4 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$B)(prepare(fn, VSPECIES));\n+        }\n+        public $shuffletype$(int[] indexes) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$B)(prepare(indexes, 0, VSPECIES));\n@@ -1085,1 +1088,1 @@\n-            this(prepare(indexes, i, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B)(prepare(indexes, i, VSPECIES));\n@@ -1089,1 +1092,1 @@\n-            this(prepare(fn, VSPECIES));\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B)(prepare(fn, VSPECIES));\n@@ -1091,2 +1094,0 @@\n-#end[Max]\n-\n@@ -1094,1 +1095,1 @@\n-            this(indexes, 0);\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B)(prepare(indexes, 0, VSPECIES));\n@@ -1096,0 +1097,2 @@\n+#end[Max]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java 8315969 generic-all\n-\n@@ -76,2 +74,6 @@\n-compiler\/valhalla\/inlinetypes\/TestIntrinsics.java 8323781 generic-all\n-compiler\/valhalla\/inlinetypes\/TestLWorld.java 8323781 generic-all\n+compiler\/codecache\/CheckLargePages.java 8317831 linux-x64\n+\n+compiler\/floatingpoint\/TestSubnormalFloat.java 8317810 generic-i586\n+compiler\/floatingpoint\/TestSubnormalDouble.java 8317810 generic-i586\n+\n+applications\/ctw\/modules\/jdk_jshell.java 8321734 generic-all\n@@ -98,2 +100,1 @@\n-\n-runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8219652 aix-ppc64\n+runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8317789 aix-ppc64\n@@ -108,1 +109,0 @@\n-runtime\/CompressedOops\/CompressedClassPointers.java 8305765 generic-all\n@@ -119,0 +119,2 @@\n+runtime\/CompressedOops\/CompressedClassPointers.java 8317610 linux-x64,windows-x64\n+\n@@ -142,1 +144,0 @@\n-serviceability\/sa\/ClhsdbDumpclass.java 8316342 generic-all\n@@ -145,1 +146,2 @@\n-serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java 8316658 generic-all\n+\n+serviceability\/jvmti\/stress\/StackTrace\/NotSuspended\/GetStackTraceNotSuspendedStressTest.java 8315980 linux-all,windows-x64\n@@ -175,0 +177,1 @@\n+serviceability\/sa\/ClhsdbDumpclass.java 8190936 generic-all\n@@ -182,2 +185,0 @@\n-gtest\/NMTGtests.java#nmt-detail 8306561 aix-ppc64\n-gtest\/NMTGtests.java#nmt-summary 8306561 aix-ppc64\n@@ -197,3 +198,0 @@\n-vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI05\/ji05t001\/TestDescription.java 8219652 aix-ppc64\n-vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI06\/ji06t001\/TestDescription.java 8219652 aix-ppc64\n-vmTestbase\/nsk\/jvmti\/SetJNIFunctionTable\/setjniftab001\/TestDescription.java 8219652 aix-ppc64\n@@ -222,0 +220,2 @@\n+\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006\/TestDescription.java 8310144 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -43,1 +46,1 @@\n- * @summary Test intrinsic support for inline types\n+ * @summary Test intrinsic support for value classes.\n@@ -45,3 +48,5 @@\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.value\n- * @compile -XDenablePrimitiveClasses TestIntrinsics.java\n- * @run main\/othervm\/timeout=300 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses compiler.valhalla.inlinetypes.TestIntrinsics\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestIntrinsics\n@@ -57,6 +62,0 @@\n-        for (Scenario scenario: scenarios) {\n-            scenario.addFlags(\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                    \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\");\n-            \/\/ Don't run with DeoptimizeALot until JDK-8239003 is fixed\n-            scenario.addFlags(\"-XX:-DeoptimizeALot\");\n-        }\n@@ -68,0 +67,4 @@\n+                   .addFlags(\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                             \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                             \/\/ Don't run with DeoptimizeALot until JDK-8239003 is fixed\n+                             \"-XX:-DeoptimizeALot\")\n@@ -88,9 +91,4 @@\n-        Asserts.assertTrue(test1(PrimitiveClass.asPrimaryType(MyValue1.class), PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_2 failed\");\n-        Asserts.assertTrue(test1(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class)), \"test1_3 failed\");\n-        Asserts.assertTrue(test1(PrimitiveClass.asPrimaryType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class)), \"test1_4 failed\");\n-        Asserts.assertFalse(test1(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_5 failed\");\n-        Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), \"test1_6 failed\");\n-        Asserts.assertTrue(test1(Object.class, PrimitiveClass.asPrimaryType(MyValue1.class)), \"test1_7 failed\");\n-        Asserts.assertTrue(test1(Object.class, PrimitiveClass.asValueType(MyValue1.class)), \"test1_8 failed\");\n-        Asserts.assertTrue(!test1(PrimitiveClass.asPrimaryType(MyValue1.class), Object.class), \"test1_9 failed\");\n-        Asserts.assertTrue(!test1(PrimitiveClass.asValueType(MyValue1.class), Object.class), \"test1_10 failed\");\n+        Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), \"test1_2 failed\");\n+        Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), \"test1_3 failed\");\n+        Asserts.assertTrue(test1(Object.class, MyValue1.class), \"test1_4 failed\");\n+        Asserts.assertTrue(!test1(MyValue1.class, Object.class), \"test1_5 failed\");\n@@ -104,10 +102,5 @@\n-        boolean check2 = PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n-        boolean check3 = PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n-        boolean check4 = PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n-        boolean check5 = !PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n-        boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);\n-        boolean check7 = Object.class.isAssignableFrom(PrimitiveClass.asPrimaryType(MyValue1.class));\n-        boolean check8 = Object.class.isAssignableFrom(PrimitiveClass.asValueType(MyValue1.class));\n-        boolean check9 = !PrimitiveClass.asPrimaryType(MyValue1.class).isAssignableFrom(Object.class);\n-        boolean check10 = !PrimitiveClass.asValueType(MyValue1.class).isAssignableFrom(Object.class);\n-        return check1 && check2 && check3 && check4 && check5 && check6 && check7 && check8 && check9 && check10;\n+        boolean check2 = MyValue1.class.isAssignableFrom(MyValue1.class);\n+        boolean check3 = Object.class.isAssignableFrom(java.util.ArrayList.class);\n+        boolean check4 = Object.class.isAssignableFrom(MyValue1.class);\n+        boolean check5 = !MyValue1.class.isAssignableFrom(Object.class);\n+        return check1 && check2 && check3 && check4 && check5;\n@@ -130,2 +123,2 @@\n-        Asserts.assertTrue(test3(PrimitiveClass.asPrimaryType(MyValue1.class)) == MyAbstract.class, \"test3_2 failed\");\n-        Asserts.assertTrue(test3(PrimitiveClass.asValueType(MyValue1.class)) == MyAbstract.class, \"test3_3 failed\");\n+        Asserts.assertTrue(test3(MyValue1.class) == MyAbstract.class, \"test3_2 failed\");\n+        Asserts.assertTrue(test3(MyValue1.class) == MyAbstract.class, \"test3_3 failed\");\n@@ -140,2 +133,2 @@\n-        boolean check2 = PrimitiveClass.asPrimaryType(MyValue1.class).getSuperclass() == MyAbstract.class;\n-        boolean check3 = PrimitiveClass.asValueType(MyValue1.class).getSuperclass() == MyAbstract.class;\n+        boolean check2 = MyValue1.class.getSuperclass() == MyAbstract.class;\n+        boolean check3 = MyValue1.class.getSuperclass() == MyAbstract.class;\n@@ -176,1 +169,1 @@\n-    \/\/ Test default inline type array creation via reflection\n+    \/\/ Test default value class array creation via reflection\n@@ -179,1 +172,1 @@\n-        Object[] va = (Object[])Array.newInstance(componentType, len);\n+        Object[] va = ValueClass.newNullRestrictedArray(componentType, len);\n@@ -187,1 +180,1 @@\n-        Object[] va = test7(PrimitiveClass.asValueType(MyValue1.class), len);\n+        Object[] va = test7(MyValue1.class, len);\n@@ -202,1 +195,1 @@\n-        boolean result = test8(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        boolean result = test8(MyValue1.class, vt);\n@@ -204,1 +197,1 @@\n-        result = test8(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        result = test8(MyValue1.class, vt);\n@@ -218,1 +211,1 @@\n-        result = test9(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+        result = test9(MyValue2.class, vt);\n@@ -231,1 +224,1 @@\n-        Object result = test10(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        Object result = test10(MyValue1.class, vt);\n@@ -252,1 +245,1 @@\n-        return PrimitiveClass.asValueType(MyValue1.class).cast(vt);\n+        return MyValue1.class.cast(vt);\n@@ -277,1 +270,1 @@\n-    \/\/ inline type array creation via reflection\n+    \/\/ Value class array creation via reflection\n@@ -280,1 +273,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), len);\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, len);\n@@ -342,1 +335,1 @@\n-    \/\/ hashCode() and toString() with different inline types\n+    \/\/ hashCode() and toString() with different value objects\n@@ -381,1 +374,1 @@\n-            Field xField = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"x\");\n+            Field xField = MyValue1.class.getDeclaredField(\"x\");\n@@ -383,1 +376,1 @@\n-            Field yField = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"y\");\n+            Field yField = MyValue1.class.getDeclaredField(\"y\");\n@@ -385,1 +378,1 @@\n-            Field v1Field = PrimitiveClass.asValueType(MyValue1.class).getDeclaredField(\"v1\");\n+            Field v1Field = MyValue1.class.getDeclaredField(\"v1\");\n@@ -387,1 +380,1 @@\n-            V1_FLATTENED = U.isFlattened(v1Field);\n+            V1_FLATTENED = U.isFlatField(v1Field);\n@@ -406,0 +399,1 @@\n+    @NullRestricted\n@@ -407,0 +401,1 @@\n+\n@@ -436,0 +431,1 @@\n+    @NullRestricted\n@@ -450,3 +446,6 @@\n-    \/\/ Test copyOf intrinsic with allocated inline type in it's debug information\n-    final primitive class Test25Value {\n-        final int x;\n+    \/\/ Test copyOf intrinsic with allocated value object in it's debug information\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class Test25Value {\n+        int x;\n+\n@@ -458,1 +457,1 @@\n-    final Test25Value[] test25Array = new Test25Value[10];\n+    final Test25Value[] test25Array = (Test25Value[])ValueClass.newNullRestrictedArray(Test25Value.class, 10);\n@@ -479,1 +478,1 @@\n-          ca[i] = PrimitiveClass.asValueType(MyValue1.class);\n+          ca[i] = MyValue1.class;\n@@ -481,1 +480,1 @@\n-        return Array.newInstance(ca[0], 1);\n+        return ValueClass.newNullRestrictedArray(ca[0], 1);\n@@ -490,2 +489,2 @@\n-    \/\/ Load non-flattenable inline type field with unsafe\n-    MyValue1.ref test27_vt;\n+    \/\/ Load non-flattenable value class field with unsafe\n+    MyValue1 test27_vt;\n@@ -504,2 +503,2 @@\n-    public MyValue1.ref test27() {\n-        return (MyValue1.ref)U.getReference(this, TEST27_OFFSET);\n+    public MyValue1 test27() {\n+        return (MyValue1)U.getReference(this, TEST27_OFFSET);\n@@ -511,1 +510,1 @@\n-        MyValue1.ref res = test27();\n+        MyValue1 res = test27();\n@@ -541,1 +540,1 @@\n-        \/\/ inline type so we don't read out of bounds.\n+        \/\/ value class so we don't read out of bounds.\n@@ -567,1 +566,1 @@\n-    \/\/ getValue to retrieve flattened field from inline type\n+    \/\/ getValue to retrieve flattened field from value object\n@@ -572,1 +571,1 @@\n-            return U.getValue(v, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+            return U.getValue(v, V1_OFFSET, MyValue2.class);\n@@ -584,0 +583,1 @@\n+    @NullRestricted\n@@ -591,1 +591,1 @@\n-            TEST31_VT_FLATTENED = U.isFlattened(test31_vt_Field);\n+            TEST31_VT_FLATTENED = U.isFlatField(test31_vt_Field);\n@@ -602,1 +602,1 @@\n-            return U.getValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(this, TEST31_VT_OFFSET, MyValue1.class);\n@@ -619,1 +619,1 @@\n-            U.putValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), vt);\n+            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class, vt);\n@@ -635,0 +635,1 @@\n+    private static final MyValue1[] TEST33_ARRAY;\n@@ -638,3 +639,4 @@\n-            TEST33_BASE_OFFSET = U.arrayBaseOffset(MyValue1[].class);\n-            TEST33_INDEX_SCALE = U.arrayIndexScale(MyValue1[].class);\n-            TEST33_FLATTENED_ARRAY = U.isFlattenedArray(MyValue1[].class);\n+            TEST33_ARRAY = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+            TEST33_BASE_OFFSET = U.arrayBaseOffset(TEST33_ARRAY.getClass());\n+            TEST33_INDEX_SCALE = U.arrayIndexScale(TEST33_ARRAY.getClass());\n+            TEST33_FLATTENED_ARRAY = U.isFlatArray(TEST33_ARRAY.getClass());\n@@ -648,1 +650,1 @@\n-    public MyValue1 test33(MyValue1[] arr) {\n+    public MyValue1 test33() {\n@@ -650,1 +652,1 @@\n-            return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class);\n@@ -652,1 +654,1 @@\n-        return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);\n+        return (MyValue1)U.getReference(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);\n@@ -657,3 +659,2 @@\n-        MyValue1[] arr = new MyValue1[2];\n-        arr[1] = vt;\n-        MyValue1 res = test33(arr);\n+        TEST33_ARRAY[1] = vt;\n+        MyValue1 res = test33();\n@@ -667,1 +668,1 @@\n-    public void test34(MyValue1[] arr, MyValue1 vt) {\n+    public void test34(MyValue1 vt) {\n@@ -669,1 +670,1 @@\n-            U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), vt);\n+            U.putValue(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class, vt);\n@@ -671,1 +672,1 @@\n-            U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);\n+            U.putReference(TEST33_ARRAY, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);\n@@ -677,3 +678,2 @@\n-        MyValue1[] arr = new MyValue1[2];\n-        test34(arr, vt);\n-        Asserts.assertEQ(arr[1].hash(), vt.hash());\n+        test34(vt);\n+        Asserts.assertEQ(TEST33_ARRAY[1].hash(), vt.hash());\n@@ -689,1 +689,1 @@\n-            return U.getValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(o, TEST31_VT_OFFSET, MyValue1.class);\n@@ -707,1 +707,1 @@\n-            return U.getValue(this, offset, PrimitiveClass.asValueType(MyValue1.class));\n+            return U.getValue(this, offset, MyValue1.class);\n@@ -725,1 +725,1 @@\n-            U.putValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), vt);\n+            U.putValue(o, TEST31_VT_OFFSET, MyValue1.class, vt);\n@@ -745,1 +745,1 @@\n-            U.putValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), o);\n+            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class, o);\n@@ -775,1 +775,1 @@\n-    \/\/ Test default inline type array creation via reflection\n+    \/\/ Test default value class array creation via reflection\n@@ -785,1 +785,1 @@\n-        Object[] va = test40(PrimitiveClass.asPrimaryType(MyValue1.class), len);\n+        Object[] va = test40(MyValue1.class, len);\n@@ -793,1 +793,1 @@\n-    public boolean test41(Class c, MyValue1.ref vt) {\n+    public boolean test41(Class c, MyValue1 vt) {\n@@ -799,2 +799,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        boolean result = test41(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test41(MyValue1.class, vt);\n@@ -802,1 +802,1 @@\n-        result = test41(PrimitiveClass.asPrimaryType(MyValue1.class), null);\n+        result = test41(MyValue1.class, null);\n@@ -804,1 +804,1 @@\n-        result = test41(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        result = test41(MyValue1.class, vt);\n@@ -806,1 +806,1 @@\n-        result = test41(PrimitiveClass.asValueType(MyValue1.class), null);\n+        result = test41(MyValue1.class, null);\n@@ -811,1 +811,1 @@\n-    public boolean test42(Class c, MyValue1.ref vt) {\n+    public boolean test42(Class c, MyValue1 vt) {\n@@ -817,2 +817,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        boolean result = test42(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        boolean result = test42(MyValue2.class, vt);\n@@ -820,1 +820,1 @@\n-        result = test42(PrimitiveClass.asPrimaryType(MyValue2.class), null);\n+        result = test42(MyValue2.class, null);\n@@ -822,1 +822,1 @@\n-        result = test42(PrimitiveClass.asValueType(MyValue2.class), vt);\n+        result = test42(MyValue2.class, vt);\n@@ -824,1 +824,1 @@\n-        result = test42(PrimitiveClass.asValueType(MyValue2.class), null);\n+        result = test42(MyValue2.class, null);\n@@ -830,1 +830,1 @@\n-    public Object test43(Class c, MyValue1.ref vt) {\n+    public Object test43(Class c, MyValue1 vt) {\n@@ -836,2 +836,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        Object result = test43(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test43(MyValue1.class, vt);\n@@ -839,1 +839,1 @@\n-        result = test43(PrimitiveClass.asPrimaryType(MyValue1.class), null);\n+        result = test43(MyValue1.class, null);\n@@ -841,1 +841,1 @@\n-        result = test43(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        result = test43(MyValue1.class, vt);\n@@ -843,6 +843,1 @@\n-        try {\n-            test43(PrimitiveClass.asValueType(MyValue1.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n-        result = test43(Integer.class, null);\n+        result = test43(NonValueClass.class, null);\n@@ -853,1 +848,1 @@\n-    public Object test44(Class c, MyValue1.ref vt) {\n+    public Object test44(Class c, MyValue1 vt) {\n@@ -859,1 +854,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -861,1 +856,1 @@\n-            test44(PrimitiveClass.asPrimaryType(MyValue2.class), vt);\n+            test44(MyValue2.class, vt);\n@@ -865,1 +860,1 @@\n-        Object res = test44(PrimitiveClass.asPrimaryType(MyValue2.class), null);\n+        Object res = test44(MyValue2.class, null);\n@@ -868,1 +863,1 @@\n-            test44(PrimitiveClass.asValueType(MyValue2.class), vt);\n+            test44(MyValue2.class, vt);\n@@ -872,5 +867,0 @@\n-        try {\n-            test44(PrimitiveClass.asValueType(MyValue2.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n@@ -880,2 +870,2 @@\n-    public Object test45(MyValue1.ref vt) {\n-        return PrimitiveClass.asPrimaryType(MyValue1.class).cast(vt);\n+    public Object test45(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n@@ -886,1 +876,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -894,2 +884,2 @@\n-    public Object test46(MyValue1.ref vt) {\n-        return PrimitiveClass.asPrimaryType(MyValue2.class).cast(vt);\n+    public Object test46(MyValue1 vt) {\n+        return MyValue2.class.cast(vt);\n@@ -900,1 +890,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -911,2 +901,2 @@\n-    public Object test47(MyValue1.ref vt) {\n-        return PrimitiveClass.asValueType(MyValue1.class).cast(vt);\n+    public Object test47(MyValue1 vt) {\n+        return MyValue1.class.cast(vt);\n@@ -917,1 +907,1 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n@@ -920,5 +910,2 @@\n-        try {\n-            test47(null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n+        result = test47(null);\n+        Asserts.assertEQ(result, null);\n@@ -928,1 +915,1 @@\n-    public Object test48(Class c, MyValue1.ref vt) {\n+    public Object test48(Class c, MyValue1 vt) {\n@@ -934,2 +921,2 @@\n-        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);\n-        Object result = test48(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object result = test48(MyValue1.class, vt);\n@@ -937,5 +924,2 @@\n-        try {\n-            test48(PrimitiveClass.asValueType(MyValue1.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n+        result = test48(MyValue1.class, null);\n+        Asserts.assertEQ(result, null);\n@@ -946,1 +930,1 @@\n-        return PrimitiveClass.asPrimaryType(MyValue1.class).cast(vt);\n+        return MyValue1.class.cast(vt);\n@@ -964,3 +948,3 @@\n-        MyValue1[] va  = new MyValue1[42];\n-        MyValue1.ref[] vba = new MyValue1.ref[42];\n-        Object result = test50(PrimitiveClass.asValueType(MyValue1.class), vt);\n+        MyValue1[] va  = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] vba = new MyValue1[42];\n+        Object result = test50(MyValue1.class, vt);\n@@ -968,1 +952,1 @@\n-        result = test50(PrimitiveClass.asPrimaryType(MyValue1.class), vt);\n+        result = test50(MyValue1.class, vt);\n@@ -972,1 +956,1 @@\n-        result = test50(MyValue1.ref[].class, vba);\n+        result = test50(MyValue1[].class, vba);\n@@ -974,1 +958,1 @@\n-        result = test50(MyValue1.ref[].class, va);\n+        result = test50(MyValue1[].class, va);\n@@ -976,0 +960,2 @@\n+        result = test50(MyValue1.class, null);\n+        Asserts.assertEQ(result, null);\n@@ -977,6 +963,1 @@\n-            test50(PrimitiveClass.asValueType(MyValue1.class), null);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (NullPointerException npe) {\n-        }\n-        try {\n-            test50(MyValue1[].class, vba);\n+            test50(va.getClass(), vba);\n@@ -988,1 +969,1 @@\n-    \/\/ inline type array creation via reflection\n+    \/\/ Value class array creation via reflection\n@@ -991,1 +972,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asPrimaryType(MyValue1.class), len);\n+        Object[] va = (Object[])Array.newInstance(MyValue1.class, len);\n@@ -1003,1 +984,1 @@\n-    \/\/ multidimensional inline type array creation via reflection\n+    \/\/ multidimensional value class array creation via reflection\n@@ -1007,1 +988,1 @@\n-        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);\n+        MyValue1[][] va2 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n@@ -1010,1 +991,1 @@\n-            va1[0] = new MyValue1[1];\n+            va1[0] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1013,1 +994,1 @@\n-            va2[0] = new MyValue1.ref[1];\n+            va2[0] = new MyValue1[1];\n@@ -1034,1 +1015,1 @@\n-        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);\n+        MyValue1[][] va2 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);\n@@ -1042,4 +1023,4 @@\n-            va1[i] = new MyValue1[1];\n-            va2[i] = new MyValue1.ref[1];\n-            va3[i] = new MyValue1[1];\n-            va4[i] = new MyValue1.ref[1];\n+            va1[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va2[i] = new MyValue1[1];\n+            va3[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va4[i] = new MyValue1[1];\n@@ -1072,4 +1053,4 @@\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 1);\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 2);\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 3);\n-        test53(MyValue1[].class, MyValue1.ref[].class, len, 4);\n+        test53(MyValue1[].class, MyValue1[].class, len, 1);\n+        test53(MyValue1[].class, MyValue1[].class, len, 2);\n+        test53(MyValue1[].class, MyValue1[].class, len, 3);\n+        test53(MyValue1[].class, MyValue1[].class, len, 4);\n@@ -1103,0 +1084,1 @@\n+    @NullRestricted\n@@ -1110,1 +1092,1 @@\n-            return U.getValue(test55_vt, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+            return U.getValue(test55_vt, V1_OFFSET, MyValue2.class);\n@@ -1124,1 +1106,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), 1);\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1138,1 +1120,1 @@\n-        Object[] va = (Object[])Array.newInstance(PrimitiveClass.asValueType(MyValue1.class), 1);\n+        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -1159,1 +1141,1 @@\n-        boolean res = test58(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class));\n+        boolean res = test58(MyValue1.class, MyValue1.class);\n@@ -1161,1 +1143,1 @@\n-        res = test58(Object.class, PrimitiveClass.asValueType(MyValue1.class));\n+        res = test58(Object.class, MyValue1.class);\n@@ -1163,1 +1145,1 @@\n-        res = test58(PrimitiveClass.asValueType(MyValue1.class), Object.class);\n+        res = test58(MyValue1.class, Object.class);\n@@ -1167,1 +1149,1 @@\n-    \/\/ Test synchronization on unsafe inline type allocation\n+    \/\/ Test synchronization on unsafe value object allocation\n@@ -1178,1 +1160,1 @@\n-        test59(Integer.class);\n+        test59(Object.class);\n@@ -1180,2 +1162,2 @@\n-            test59(PrimitiveClass.asValueType(MyValue1.class));\n-            throw new RuntimeException(\"test59 failed: synchronization on inline type should not succeed\");\n+            test59(MyValue1.class);\n+            throw new RuntimeException(\"test59 failed: synchronization on value object should not succeed\");\n@@ -1187,1 +1169,1 @@\n-    \/\/ Test mark word load optimization on unsafe inline type allocation\n+    \/\/ Test mark word load optimization on unsafe value object allocation\n@@ -1197,42 +1179,5 @@\n-        Asserts.assertTrue(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), false, false));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), MyValue2.class, false, false));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), false, true));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), true, false));\n-        Asserts.assertFalse(test60(PrimitiveClass.asValueType(MyValue1.class), PrimitiveClass.asValueType(MyValue1.class), true, true));\n-    }\n-\n-    \/\/ Test asPrimaryType intrinsic with non-value mirror\n-    @Test\n-    public Class<?> test61(Class<?> c) {\n-        if (PrimitiveClass.asPrimaryType(c) != Integer.class) {\n-            throw new RuntimeException(\"Unexpected class\");\n-        }\n-        return PrimitiveClass.asPrimaryType(Integer.class);\n-    }\n-\n-    @Run(test = \"test61\")\n-    public void test61_verifier() {\n-        Class<?> result = test61(Integer.class);\n-        Asserts.assertEQ(result, Integer.class);\n-    }\n-\n-    \/\/ Test asValueType intrinsic with non-value mirror\n-    @Test\n-    public Class<?> test62(Class<?> c) {\n-        try {\n-            PrimitiveClass.asValueType(c);\n-            throw new RuntimeException(\"No exception thrown\");\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ Expected\n-        }\n-        return PrimitiveClass.asValueType(Integer.class);\n-    }\n-\n-    @Run(test = \"test62\")\n-    public void test62_verifier() {\n-        try {\n-            test62(Integer.class);\n-            throw new RuntimeException(\"No exception thrown\");\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ Expected\n-        }\n+        Asserts.assertTrue(test60(MyValue1.class, MyValue1.class, false, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue2.class, false, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, false, true));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, false));\n+        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, true));\n@@ -1245,1 +1190,1 @@\n-            return U.compareAndSetValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1254,1 +1199,1 @@\n-        test31_vt = MyValue1.default;\n+        test31_vt = MyValue1.createDefaultInline();\n@@ -1258,1 +1203,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1264,1 +1209,1 @@\n-        res = test63(MyValue1.default, MyValue1.default);\n+        res = test63(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1275,1 +1220,1 @@\n-            return U.compareAndSetValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class, oldVal, newVal);\n@@ -1283,1 +1228,1 @@\n-        MyValue1[] arr = new MyValue1[2];\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1288,1 +1233,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1294,1 +1239,1 @@\n-        res = test64(arr, MyValue1.default, MyValue1.default);\n+        res = test64(arr, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1305,1 +1250,1 @@\n-            return U.compareAndSetValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(o, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1314,1 +1259,1 @@\n-        test31_vt = MyValue1.default;\n+        test31_vt = MyValue1.createDefaultInline();\n@@ -1320,1 +1265,1 @@\n-        res = test65(this, MyValue1.default, MyValue1.default);\n+        res = test65(this, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1329,1 +1274,1 @@\n-            return U.compareAndSetValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndSetValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1338,1 +1283,1 @@\n-        test31_vt = MyValue1.default;\n+        test31_vt = MyValue1.createDefaultInline();\n@@ -1344,1 +1289,1 @@\n-        res = test66(MyValue1.default, MyValue1.default);\n+        res = test66(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1353,1 +1298,1 @@\n-            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1362,1 +1307,1 @@\n-        MyValue1 oldVal = MyValue1.default;\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n@@ -1367,1 +1312,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1373,1 +1318,1 @@\n-        res = test67(MyValue1.default, MyValue1.default);\n+        res = test67(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1384,1 +1329,1 @@\n-            return U.compareAndExchangeValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class, oldVal, newVal);\n@@ -1392,1 +1337,1 @@\n-        MyValue1[] arr = new MyValue1[2];\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n@@ -1397,1 +1342,1 @@\n-        \/\/ fails if C2 scalarizes and re-allocates the inline type arguments.\n+        \/\/ fails if C2 scalarizes and re-allocates the value class arguments.\n@@ -1399,1 +1344,1 @@\n-            Asserts.assertEQ(res, MyValue1.default);\n+            Asserts.assertEQ(res, MyValue1.createDefaultInline());\n@@ -1403,1 +1348,1 @@\n-        res = test68(arr, MyValue1.default, MyValue1.default);\n+        res = test68(arr, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1414,1 +1359,1 @@\n-            return U.compareAndExchangeValue(o, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(o, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1423,1 +1368,1 @@\n-        MyValue1 oldVal = MyValue1.default;\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n@@ -1430,1 +1375,1 @@\n-        res = test69(this, MyValue1.default, MyValue1.default);\n+        res = test69(this, MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1439,1 +1384,1 @@\n-            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, PrimitiveClass.asValueType(MyValue1.class), oldVal, newVal);\n+            return U.compareAndExchangeValue(this, TEST31_VT_OFFSET, MyValue1.class, oldVal, newVal);\n@@ -1448,1 +1393,1 @@\n-        MyValue1 oldVal = MyValue1.default;\n+        MyValue1 oldVal = MyValue1.createDefaultInline();\n@@ -1455,1 +1400,1 @@\n-        res = test70(MyValue1.default, MyValue1.default);\n+        res = test70(MyValue1.createDefaultInline(), MyValue1.createDefaultInline());\n@@ -1460,1 +1405,1 @@\n-    \/\/ getValue to retrieve flattened field from (nullable) inline type\n+    \/\/ getValue to retrieve flattened field from (nullable) value class\n@@ -1463,1 +1408,1 @@\n-    public MyValue2 test71(boolean b, MyValue1.val v1, MyValue1.ref v2) {\n+    public MyValue2 test71(boolean b, MyValue1 v1, MyValue1 v2) {\n@@ -1466,1 +1411,1 @@\n-                return U.getValue(v1, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v1, V1_OFFSET, MyValue2.class);\n@@ -1471,1 +1416,1 @@\n-                return U.getValue(v2, V1_OFFSET, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v2, V1_OFFSET, MyValue2.class);\n@@ -1487,1 +1432,1 @@\n-    public MyValue2 test72(boolean b, MyValue1.val v1, MyValue1.ref v2, long offset) {\n+    public MyValue2 test72(boolean b, MyValue1 v1, MyValue1 v2, long offset) {\n@@ -1490,1 +1435,1 @@\n-                return U.getValue(v1, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v1, offset, MyValue2.class);\n@@ -1495,1 +1440,1 @@\n-                return U.getValue(v2, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(v2, offset, MyValue2.class);\n@@ -1508,2 +1453,3 @@\n-    static final MyValue1.val test73_value1 = MyValue1.createWithFieldsInline(rI, rL);\n-    static final MyValue1.ref test73_value2 = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+    @NullRestricted\n+    static final MyValue1 test73_value1 = MyValue1.createWithFieldsInline(rI, rL);\n+    static final MyValue1 test73_value2 = MyValue1.createWithFieldsInline(rI+1, rL+1);\n@@ -1517,1 +1463,1 @@\n-                return U.getValue(test73_value1, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(test73_value1, offset, MyValue2.class);\n@@ -1522,1 +1468,1 @@\n-                return U.getValue(test73_value2, offset, PrimitiveClass.asValueType(MyValue2.class));\n+                return U.getValue(test73_value2, offset, MyValue2.class);\n@@ -1534,1 +1480,3 @@\n-    static primitive class EmptyInline {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyInline {\n@@ -1538,1 +1486,3 @@\n-    static primitive class ByteInline {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ByteInline {\n@@ -1550,1 +1500,1 @@\n-        EmptyInline[] emptyArray = new EmptyInline[100];\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n@@ -1553,1 +1503,1 @@\n-            Asserts.assertEQ(empty, EmptyInline.default);\n+            Asserts.assertEQ(empty, new EmptyInline());\n@@ -1564,1 +1514,1 @@\n-        EmptyInline[] emptyArray = new EmptyInline[100];\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n@@ -1567,1 +1517,1 @@\n-            Asserts.assertEQ(empty, EmptyInline.default);\n+            Asserts.assertEQ(empty, new EmptyInline());\n@@ -1579,1 +1529,1 @@\n-        ByteInline[] byteArray = new ByteInline[100];\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n@@ -1582,1 +1532,1 @@\n-            Asserts.assertEQ(b, ByteInline.default);\n+            Asserts.assertEQ(b, new ByteInline());\n@@ -1593,1 +1543,1 @@\n-        ByteInline[] byteArray = new ByteInline[100];\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n@@ -1596,1 +1546,1 @@\n-            Asserts.assertEQ(b, ByteInline.default);\n+            Asserts.assertEQ(b, new ByteInline());\n@@ -1601,2 +1551,2 @@\n-    public Object test78(MyValue1.ref vt) {\n-        return Integer.class.cast(vt);\n+    public Object test78(MyValue1 vt) {\n+        return NonValueClass.class.cast(vt);\n@@ -1619,1 +1569,1 @@\n-    public Object test79(MyValue1.ref vt) {\n+    public Object test79(MyValue1 vt) {\n@@ -1621,1 +1571,1 @@\n-        return (Integer)tmp;\n+        return (NonValueClass)tmp;\n@@ -1636,2 +1586,5 @@\n-    public static final primitive class Test80Value1 {\n-        final Test80Value2 v = new Test80Value2();\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test80Value1 {\n+        @NullRestricted\n+        Test80Value2 v = new Test80Value2();\n@@ -1640,3 +1593,5 @@\n-    public static final primitive class Test80Value2 {\n-        final long l = rL;\n-        final Integer i = rI;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class Test80Value2 {\n+        long l = rL;\n+        NonValueClass obj = new NonValueClass(rI);\n@@ -1648,1 +1603,1 @@\n-    public Test80Value2 test80(Test80Value1.ref v, boolean flat, long offset) {\n+    public Test80Value2 test80(Test80Value1 v, boolean flat, long offset) {\n@@ -1650,1 +1605,1 @@\n-            return U.getValue(v, offset, PrimitiveClass.asValueType(Test80Value2.class));\n+            return U.getValue(v, offset, Test80Value2.class);\n@@ -1659,2 +1614,2 @@\n-        Field field = PrimitiveClass.asValueType(Test80Value1.class).getDeclaredField(\"v\");\n-        Asserts.assertEQ(test80(v, U.isFlattened(field), U.objectFieldOffset(field)), v.v);\n+        Field field = Test80Value1.class.getDeclaredField(\"v\");\n+        Asserts.assertEQ(test80(v, U.isFlatField(field), U.objectFieldOffset(field)), v.v);\n@@ -1663,1 +1618,1 @@\n-    \/\/ Test correctness of the Unsafe::isFlattenedArray intrinsic\n+    \/\/ Test correctness of the Unsafe::isFlatArray intrinsic\n@@ -1666,1 +1621,1 @@\n-        return U.isFlattenedArray(cls);\n+        return U.isFlatArray(cls);\n@@ -1671,1 +1626,1 @@\n-        Asserts.assertEQ(test81(MyValue1[].class), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n+        Asserts.assertEQ(test81(TEST33_ARRAY.getClass()), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n@@ -1677,1 +1632,1 @@\n-    \/\/ Verify that Unsafe::isFlattenedArray checks with statically known classes\n+    \/\/ Verify that Unsafe::isFlatArray checks with statically known classes\n@@ -1682,1 +1637,1 @@\n-        boolean check1 = U.isFlattenedArray(MyValue1[].class);\n+        boolean check1 = U.isFlatArray(TEST33_ARRAY.getClass());\n@@ -1686,3 +1641,3 @@\n-        boolean check2 = !U.isFlattenedArray(String[].class);\n-        boolean check3 = !U.isFlattenedArray(String.class);\n-        boolean check4 = !U.isFlattenedArray(int[].class);\n+        boolean check2 = !U.isFlatArray(String[].class);\n+        boolean check3 = !U.isFlatArray(String.class);\n+        boolean check4 = !U.isFlatArray(int[].class);\n@@ -1696,0 +1651,24 @@\n+\n+    \/\/ Test that LibraryCallKit::arraycopy_move_allocation_here works as expected\n+    @Test\n+    public MyValue1 test83(Object[] src) {\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+            Asserts.assertEQ(test83(src), src[0]);\n+        } else {\n+            \/\/ Trigger deoptimization to verify that re-execution works\n+            try {\n+                test83(new NonValueClass[10]);\n+                throw new RuntimeException(\"No NullPointerException thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":274,"deletions":295,"binary":false,"changes":569,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/AllBitsSetVectorMatchRuleTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/Test8259353.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/Test8278948.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/Test8303508.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @enablePreview\n@@ -36,0 +35,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestLongVectorNeg.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -44,0 +45,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestLoopStoreVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestMaskedMacroLogicVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestNoInline.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestRawOopAtSafepoint.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransformsSVE.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorCompressExpandBits.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorInsertByte.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+ * @enablePreview\n@@ -141,1 +142,1 @@\n-}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMaskTrueCount.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMulAddSub.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShiftImm.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShuffleIota.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShuffleIotaByte.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorAbsDiffTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorBoxExpandTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCastShape128Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCastShape64Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+ * @enablePreview\n@@ -130,1 +131,1 @@\n-    @IR(counts = { IRNode.VMASK_CMP_IMM_B_SVE, \">= 1\" })\n+    @IR(counts = { IRNode.VMASK_CMP_IMM_I_SVE, \">= 1\" })\n@@ -143,1 +144,1 @@\n-    @IR(counts = { IRNode.VMASK_CMPU_IMM_B_SVE, \">= 1\" })\n+    @IR(counts = { IRNode.VMASK_CMPU_IMM_I_SVE, \">= 1\" })\n@@ -156,1 +157,1 @@\n-    @IR(failOn = { IRNode.VMASK_CMP_IMM_B_SVE })\n+    @IR(failOn = { IRNode.VMASK_CMP_IMM_I_SVE })\n@@ -163,1 +164,1 @@\n-    @IR(failOn = { IRNode.VMASK_CMPU_IMM_B_SVE })\n+    @IR(failOn = { IRNode.VMASK_CMPU_IMM_I_SVE })\n@@ -170,1 +171,1 @@\n-    @IR(counts = { IRNode.VMASK_CMP_IMM_S_SVE, \">= 1\" })\n+    @IR(counts = { IRNode.VMASK_CMP_IMM_I_SVE, \">= 1\" })\n@@ -183,1 +184,1 @@\n-    @IR(counts = { IRNode.VMASK_CMPU_IMM_S_SVE, \">= 1\" })\n+    @IR(counts = { IRNode.VMASK_CMPU_IMM_I_SVE, \">= 1\" })\n@@ -196,1 +197,1 @@\n-    @IR(failOn = { IRNode.VMASK_CMP_IMM_S_SVE })\n+    @IR(failOn = { IRNode.VMASK_CMP_IMM_I_SVE })\n@@ -203,1 +204,1 @@\n-    @IR(failOn = { IRNode.VMASK_CMPU_IMM_S_SVE })\n+    @IR(failOn = { IRNode.VMASK_CMPU_IMM_I_SVE })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompareWithImmTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+ * @enablePreview\n@@ -260,1 +261,1 @@\n-}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompareWithZeroTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+* @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFusedMultiplyAddSubTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherScatterTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+ * @enablePreview\n@@ -60,0 +61,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskLoadStoreTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskedNotTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @enablePreview\n@@ -36,0 +35,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @enablePreview\n@@ -44,0 +43,1 @@\n+ * @enablePreview\n@@ -51,1 +51,0 @@\n- * @enablePreview\n@@ -55,0 +54,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReinterpretTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReplicateLongSpecialImmTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReverseBytesTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512BW.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @enablePreview\n@@ -44,0 +43,1 @@\n+ * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run testng\/othervm -ea -esa -Xbatch ByteMaxVectorTests\n+ * @enablePreview\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ByteMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/CovarOverrideTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1097,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2195,1 @@\n-                Double128VectorTests::ADDReduce, Double128VectorTests::ADDReduceAll);\n+                Double128VectorTests::ADDReduce, Double128VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2241,1 @@\n-                Double128VectorTests::ADDReduceMasked, Double128VectorTests::ADDReduceAllMasked);\n+                Double128VectorTests::ADDReduceMasked, Double128VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2284,1 @@\n-                Double128VectorTests::MULReduce, Double128VectorTests::MULReduceAll);\n+                Double128VectorTests::MULReduce, Double128VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2330,1 @@\n-                Double128VectorTests::MULReduceMasked, Double128VectorTests::MULReduceAllMasked);\n+                Double128VectorTests::MULReduceMasked, Double128VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1097,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2195,1 @@\n-                Double256VectorTests::ADDReduce, Double256VectorTests::ADDReduceAll);\n+                Double256VectorTests::ADDReduce, Double256VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2241,1 @@\n-                Double256VectorTests::ADDReduceMasked, Double256VectorTests::ADDReduceAllMasked);\n+                Double256VectorTests::ADDReduceMasked, Double256VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2284,1 @@\n-                Double256VectorTests::MULReduce, Double256VectorTests::MULReduceAll);\n+                Double256VectorTests::MULReduce, Double256VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2330,1 @@\n-                Double256VectorTests::MULReduceMasked, Double256VectorTests::MULReduceAllMasked);\n+                Double256VectorTests::MULReduceMasked, Double256VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1097,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2195,1 @@\n-                Double512VectorTests::ADDReduce, Double512VectorTests::ADDReduceAll);\n+                Double512VectorTests::ADDReduce, Double512VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2241,1 @@\n-                Double512VectorTests::ADDReduceMasked, Double512VectorTests::ADDReduceAllMasked);\n+                Double512VectorTests::ADDReduceMasked, Double512VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2284,1 @@\n-                Double512VectorTests::MULReduce, Double512VectorTests::MULReduceAll);\n+                Double512VectorTests::MULReduce, Double512VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2330,1 @@\n-                Double512VectorTests::MULReduceMasked, Double512VectorTests::MULReduceAllMasked);\n+                Double512VectorTests::MULReduceMasked, Double512VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1081,0 +1097,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2171,1 +2195,1 @@\n-                Double64VectorTests::ADDReduce, Double64VectorTests::ADDReduceAll);\n+                Double64VectorTests::ADDReduce, Double64VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2217,1 +2241,1 @@\n-                Double64VectorTests::ADDReduceMasked, Double64VectorTests::ADDReduceAllMasked);\n+                Double64VectorTests::ADDReduceMasked, Double64VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2260,1 +2284,1 @@\n-                Double64VectorTests::MULReduce, Double64VectorTests::MULReduceAll);\n+                Double64VectorTests::MULReduce, Double64VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2306,1 +2330,1 @@\n-                Double64VectorTests::MULReduceMasked, Double64VectorTests::MULReduceAllMasked);\n+                Double64VectorTests::MULReduceMasked, Double64VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run testng\/othervm -ea -esa -Xbatch DoubleMaxVectorTests\n+ * @enablePreview\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation DoubleMaxVectorTests\n@@ -68,0 +69,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final double RELATIVE_ROUNDING_ERROR = (double)0.000001;\n@@ -127,0 +130,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(double[] r, double rc, double[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            double relativeError) {\n@@ -129,1 +138,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -131,1 +140,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -134,2 +143,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -149,0 +158,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (double)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(double[] r, double rc, double[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            double relativeError) {\n@@ -151,1 +166,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -153,1 +168,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -156,2 +172,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1086,0 +1102,8 @@\n+            withToString(\"double[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n+            withToString(\"double[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (double)0.01 + ((double)i \/ (i + 1)));\n+            }),\n@@ -2176,1 +2200,1 @@\n-                DoubleMaxVectorTests::ADDReduce, DoubleMaxVectorTests::ADDReduceAll);\n+                DoubleMaxVectorTests::ADDReduce, DoubleMaxVectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2222,1 +2246,1 @@\n-                DoubleMaxVectorTests::ADDReduceMasked, DoubleMaxVectorTests::ADDReduceAllMasked);\n+                DoubleMaxVectorTests::ADDReduceMasked, DoubleMaxVectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2265,1 +2289,1 @@\n-                DoubleMaxVectorTests::MULReduce, DoubleMaxVectorTests::MULReduceAll);\n+                DoubleMaxVectorTests::MULReduce, DoubleMaxVectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2311,1 +2335,1 @@\n-                DoubleMaxVectorTests::MULReduceMasked, DoubleMaxVectorTests::MULReduceAllMasked);\n+                DoubleMaxVectorTests::MULReduceMasked, DoubleMaxVectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1108,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2206,1 @@\n-                Float128VectorTests::ADDReduce, Float128VectorTests::ADDReduceAll);\n+                Float128VectorTests::ADDReduce, Float128VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2252,1 @@\n-                Float128VectorTests::ADDReduceMasked, Float128VectorTests::ADDReduceAllMasked);\n+                Float128VectorTests::ADDReduceMasked, Float128VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2295,1 @@\n-                Float128VectorTests::MULReduce, Float128VectorTests::MULReduceAll);\n+                Float128VectorTests::MULReduce, Float128VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2341,1 @@\n-                Float128VectorTests::MULReduceMasked, Float128VectorTests::MULReduceAllMasked);\n+                Float128VectorTests::MULReduceMasked, Float128VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1108,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2206,1 @@\n-                Float256VectorTests::ADDReduce, Float256VectorTests::ADDReduceAll);\n+                Float256VectorTests::ADDReduce, Float256VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2252,1 @@\n-                Float256VectorTests::ADDReduceMasked, Float256VectorTests::ADDReduceAllMasked);\n+                Float256VectorTests::ADDReduceMasked, Float256VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2295,1 @@\n-                Float256VectorTests::MULReduce, Float256VectorTests::MULReduceAll);\n+                Float256VectorTests::MULReduce, Float256VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2341,1 @@\n-                Float256VectorTests::MULReduceMasked, Float256VectorTests::MULReduceAllMasked);\n+                Float256VectorTests::MULReduceMasked, Float256VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1108,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2206,1 @@\n-                Float512VectorTests::ADDReduce, Float512VectorTests::ADDReduceAll);\n+                Float512VectorTests::ADDReduce, Float512VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2252,1 @@\n-                Float512VectorTests::ADDReduceMasked, Float512VectorTests::ADDReduceAllMasked);\n+                Float512VectorTests::ADDReduceMasked, Float512VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2295,1 @@\n-                Float512VectorTests::MULReduce, Float512VectorTests::MULReduceAll);\n+                Float512VectorTests::MULReduce, Float512VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2341,1 @@\n-                Float512VectorTests::MULReduceMasked, Float512VectorTests::MULReduceAllMasked);\n+                Float512VectorTests::MULReduceMasked, Float512VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -63,0 +64,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -122,0 +125,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -124,1 +133,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -126,1 +135,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -129,2 +138,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -144,0 +153,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -146,1 +161,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -148,1 +163,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -151,2 +167,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1092,0 +1108,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2182,1 +2206,1 @@\n-                Float64VectorTests::ADDReduce, Float64VectorTests::ADDReduceAll);\n+                Float64VectorTests::ADDReduce, Float64VectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2228,1 +2252,1 @@\n-                Float64VectorTests::ADDReduceMasked, Float64VectorTests::ADDReduceAllMasked);\n+                Float64VectorTests::ADDReduceMasked, Float64VectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2271,1 +2295,1 @@\n-                Float64VectorTests::MULReduce, Float64VectorTests::MULReduceAll);\n+                Float64VectorTests::MULReduce, Float64VectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2317,1 +2341,1 @@\n-                Float64VectorTests::MULReduceMasked, Float64VectorTests::MULReduceAllMasked);\n+                Float64VectorTests::MULReduceMasked, Float64VectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -68,0 +69,2 @@\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final float RELATIVE_ROUNDING_ERROR = (float)0.000001;\n@@ -127,0 +130,6 @@\n+        assertReductionArraysEquals(r, rc, a, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(float[] r, float rc, float[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            float relativeError) {\n@@ -129,1 +138,1 @@\n-            Assert.assertEquals(rc, fa.apply(a));\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n@@ -131,1 +140,1 @@\n-                Assert.assertEquals(r[i], f.apply(a, i));\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n@@ -134,2 +143,2 @@\n-            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -149,0 +158,6 @@\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (float)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(float[] r, float rc, float[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            float relativeError) {\n@@ -151,1 +166,1 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask));\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n@@ -153,1 +168,2 @@\n-                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n@@ -156,2 +172,2 @@\n-            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n-            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n@@ -1097,0 +1113,8 @@\n+            withToString(\"float[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n+            withToString(\"float[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (float)0.01 + ((float)i \/ (i + 1)));\n+            }),\n@@ -2187,1 +2211,1 @@\n-                FloatMaxVectorTests::ADDReduce, FloatMaxVectorTests::ADDReduceAll);\n+                FloatMaxVectorTests::ADDReduce, FloatMaxVectorTests::ADDReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2233,1 +2257,1 @@\n-                FloatMaxVectorTests::ADDReduceMasked, FloatMaxVectorTests::ADDReduceAllMasked);\n+                FloatMaxVectorTests::ADDReduceMasked, FloatMaxVectorTests::ADDReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n@@ -2276,1 +2300,1 @@\n-                FloatMaxVectorTests::MULReduce, FloatMaxVectorTests::MULReduceAll);\n+                FloatMaxVectorTests::MULReduce, FloatMaxVectorTests::MULReduceAll, RELATIVE_ROUNDING_ERROR);\n@@ -2322,1 +2346,1 @@\n-                FloatMaxVectorTests::MULReduceMasked, FloatMaxVectorTests::MULReduceAllMasked);\n+                FloatMaxVectorTests::MULReduceMasked, FloatMaxVectorTests::MULReduceAllMasked, RELATIVE_ROUNDING_ERROR);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run testng\/othervm -ea -esa -Xbatch IntMaxVectorTests\n+ * @enablePreview\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation IntMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run testng\/othervm -ea -esa -Xbatch LongMaxVectorTests\n+ * @enablePreview\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation LongMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/MethodOverideTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/MismatchTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -42,0 +43,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/PreferredSpeciesTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run testng\/othervm -ea -esa -Xbatch ShortMaxVectorTests\n+ * @enablePreview\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ShortMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @enablePreview\n+ * @run testng UnalignedHeapTest\n+ *\/\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+public class UnalignedHeapTest {\n+\n+    \/\/ Big enough to hold all species variants for all array types\n+    private static final int ARRAY_LEN = 1024;\n+\n+    @Test\n+    public void testByteArray() {\n+        for (VectorSpecies<Byte> species: Arrays.asList(ByteVector.SPECIES_64, ByteVector.SPECIES_128, ByteVector.SPECIES_256, ByteVector.SPECIES_512, ByteVector.SPECIES_MAX)) {\n+            byte[] arr = new byte[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (byte) i); \/\/ May wrap around\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Byte> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            byte[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_BYTE);\n+            byte[] actual = (byte[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testShortArray() {\n+        for (VectorSpecies<Short> species: Arrays.asList(ShortVector.SPECIES_64, ShortVector.SPECIES_128, ShortVector.SPECIES_256, ShortVector.SPECIES_512, ShortVector.SPECIES_MAX)) {\n+            short[] arr = new short[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (short) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Short> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            short[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_SHORT_UNALIGNED);\n+            short[] actual = (short[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testIntArray() {\n+        for (VectorSpecies<Integer> species: Arrays.asList(IntVector.SPECIES_64, IntVector.SPECIES_128, IntVector.SPECIES_256, IntVector.SPECIES_512, IntVector.SPECIES_MAX)) {\n+            MemorySegment segment = MemorySegment.ofArray(IntStream.range(0, ARRAY_LEN).toArray()).asSlice(1);\n+            Vector<Integer> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            int[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_INT_UNALIGNED);\n+            int[] actual = vector.toIntArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testFloatArray() {\n+        for (VectorSpecies<Float> species: Arrays.asList(FloatVector.SPECIES_64, FloatVector.SPECIES_128, FloatVector.SPECIES_256, FloatVector.SPECIES_512, FloatVector.SPECIES_MAX)) {\n+            float[] arr = new float[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (float) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Float> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            float[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_FLOAT_UNALIGNED);\n+            float[] actual = (float[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testLongArray() {\n+        for (VectorSpecies<Long> species: Arrays.asList(LongVector.SPECIES_64, LongVector.SPECIES_128, LongVector.SPECIES_256, LongVector.SPECIES_512, LongVector.SPECIES_MAX)) {\n+            long[] arr = new long[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Long> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            long[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_LONG_UNALIGNED);\n+            long[] actual = (long[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testDoubleArray() {\n+        for (VectorSpecies<Double> species: Arrays.asList(DoubleVector.SPECIES_64, DoubleVector.SPECIES_128, DoubleVector.SPECIES_256, DoubleVector.SPECIES_512, DoubleVector.SPECIES_MAX)) {\n+            double[] arr = new double[ARRAY_LEN];\n+            IntStream.range(0, ARRAY_LEN).forEach(i -> arr[i] = (double) i);\n+            MemorySegment segment = MemorySegment.ofArray(arr).asSlice(1);\n+            Vector<Double> vector = species.fromMemorySegment(segment, 0, ByteOrder.nativeOrder());\n+            double[] expected = segment.asSlice(0, species.vectorByteSize()).toArray(ValueLayout.JAVA_DOUBLE_UNALIGNED);\n+            double[] actual = (double[]) vector.toArray();\n+            assertEquals(actual, expected, species.toString());\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/UnalignedHeapTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector128ConversionTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector256ConversionTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector512ConversionTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector64ConversionTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorHash.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @enablePreview\n@@ -50,0 +51,1 @@\n+ * @enablePreview\n@@ -62,0 +64,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorMaxConversionTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorRuns.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -95,0 +96,4 @@\n+#if[FP]\n+    \/\/ for floating point reduction ops that may introduce rounding errors\n+    private static final $type$ RELATIVE_ROUNDING_ERROR = ($type$)0.000001;\n+#end[FP]\n@@ -154,0 +159,3 @@\n+#if[FP]\n+        assertReductionArraysEquals(r, rc, a, f, fa, ($type$)0.0);\n+#else[FP]\n@@ -164,0 +172,1 @@\n+#end[FP]\n@@ -165,0 +174,17 @@\n+#if[FP]\n+\n+    static void assertReductionArraysEquals($type$[] r, $type$ rc, $type$[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            $type$ relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n+    }\n+#end[FP]\n@@ -176,0 +202,3 @@\n+#if[FP]\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, ($type$)0.0);\n+#else[FP]\n@@ -186,0 +215,18 @@\n+#end[FP]\n+    }\n+#if[FP]\n+\n+    static void assertReductionArraysEqualsMasked($type$[] r, $type$ rc, $type$[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            $type$ relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n@@ -187,0 +234,1 @@\n+#end[FP]\n@@ -1150,0 +1198,10 @@\n+#if[FP]\n+            withToString(\"$type$[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)0.01 + (($type$)i \/ (i + 1)));\n+            }),\n+            withToString(\"$type$[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : ($type$)0.01 + (($type$)i \/ (i + 1)));\n+            }),\n+#end[FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @enablePreview\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}