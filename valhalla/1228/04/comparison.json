{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.math.BigDecimal;\n@@ -90,1 +91,0 @@\n-    \/\/ valueOf(BigDecimal) -- main implementation could be package private in BigDecimal\n@@ -422,7 +422,13 @@\n-    \/\/    \/**\n-    \/\/     * ...\n-    \/\/     * @see BigDecimal#floatValue()\n-    \/\/     * @see BigDecimal#doubleValue()\n-    \/\/     *\/\n-    \/\/    public static Float16 valueOf(BigDecimal bd)\n-\n+    \/**\n+     * {@return a {@link Float16} value rounded from the {@link BigDecimal}\n+     * argument using the round to nearest rounding policy}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @param  v a {@link BigDecimal}\n+     *\/\n+    public static Float16 valueOf(BigDecimal v) {\n+        return v.float16Value();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -337,0 +337,4 @@\n+    private static final int P_F16 = Float16.PRECISION;  \/\/ 11\n+    private static final int Q_MIN_F16 = Float16.MIN_EXPONENT - (P_F16 - 1);  \/\/ -24\n+    private static final int Q_MAX_F16 = Float16.MAX_EXPONENT - (P_F16 - 1);  \/\/ 5\n+\n@@ -3779,0 +3783,94 @@\n+    \/**\n+     * Converts this {@code BigDecimal} to a {@code Float16}.\n+     * This conversion is similar to the\n+     * <i>narrowing primitive conversion<\/i> from {@code double} to\n+     * {@code float} as defined in\n+     * <cite>The Java Language Specification<\/cite>:\n+     * if this {@code BigDecimal} has too great a\n+     * magnitude to represent as a {@code Float16}, it will be\n+     * converted to {@link Float16#NEGATIVE_INFINITY} or {@link\n+     * Float16#POSITIVE_INFINITY} as appropriate.  Note that even when\n+     * the return value is finite, this conversion can lose\n+     * information about the precision of the {@code BigDecimal}\n+     * value.Float16\n+     *\n+     * @return this {@code BigDecimal} converted to a {@code Float16}.\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    public Float16 float16Value() {\n+        \/* For details, see the extensive comments in doubleValue(). *\/\n+        if (intCompact != INFLATED) {\n+            Float16 v = Float16.valueOf(intCompact);\n+            if (scale == 0) {\n+                return v;\n+            }\n+            \/*\n+             * The discussion for the double case also applies here. That is,\n+             * the following test is precise for all long values, but here\n+             * Long.MAX_VALUE is not an issue.\n+             *\/\n+            if (v.longValue() == intCompact) {\n+                if (0 < scale && scale < FLOAT16_10_POW.length) {\n+                    return Float16.divide(v, FLOAT16_10_POW[scale]);\n+                }\n+                if (0 > scale && scale > -FLOAT16_10_POW.length) {\n+                    return Float16.multiply(v, FLOAT16_10_POW[-scale]);\n+                }\n+            }\n+        }\n+        return fullFloat16Value();\n+    }\n+\n+    private Float16 fullFloat16Value() {\n+        if (intCompact == 0) {\n+            return Float16.valueOf(0);\n+        }\n+        BigInteger w = unscaledValue().abs();\n+        long qb = w.bitLength() - (long) Math.ceil(scale * L);\n+        Float16 signum = Float16.valueOf(signum());\n+        if (qb < Q_MIN_F16 - 2) {  \/\/ qb < -26\n+            return Float16.multiply(signum, Float16.valueOf(0));\n+        }\n+        if (qb > Q_MAX_F16 + P_F16 + 1) {  \/\/ qb > 17\n+            return Float16.multiply(signum, Float16.POSITIVE_INFINITY);\n+        }\n+        if (scale < 0) {\n+            return Float16.multiply(signum, w.multiply(bigTenToThe(-scale)).float16Value());\n+        }\n+        if (scale == 0) {\n+            return Float16.multiply(signum, w.float16Value());\n+        }\n+        int ql = (int) qb - (P_F16 + 3);\n+        BigInteger pow10 = bigTenToThe(scale);\n+        BigInteger m, n;\n+        if (ql <= 0) {\n+            m = w.shiftLeft(-ql);\n+            n = pow10;\n+        } else {\n+            m = w;\n+            n = pow10.shiftLeft(ql);\n+        }\n+        BigInteger[] qr = m.divideAndRemainder(n);\n+        \/*\n+         * We have\n+         *      2^12 = 2^{P+1} <= i < 2^{P+5} = 2^16\n+         * Contrary to the double and float cases, where we use long and int, resp.,\n+         * here we cannot simply declare i as short, because P + 5 < Short.SIZE\n+         * fails to hold.\n+         * Using int is safe, though.\n+         *\n+         * Further, as Math.scalb(Float16) does not exists, we fall back to\n+         * Math.scalb(double).\n+         *\/\n+        int i = qr[0].intValue();\n+        int sb = qr[1].signum();\n+        int dq = (Integer.SIZE - (P_F16 + 2)) - Integer.numberOfLeadingZeros(i);\n+        int eq = (Q_MIN_F16 - 2) - ql;\n+        if (dq >= eq) {\n+            return Float16.valueOf(signum() * Math.scalb((double) (i | sb), ql));\n+        }\n+        int mask = (1 << eq) - 1;\n+        int j = i >> eq | (Integer.signum(i & mask)) | sb;\n+        return Float16.valueOf(signum() * Math.scalb((double) j, Q_MIN_F16 - 2));\n+    }\n+\n@@ -4153,0 +4251,9 @@\n+    \/**\n+     * Powers of 10 which can be represented exactly in {@code\n+     * Float16}.\n+     *\/\n+    private static final Float16[] FLOAT16_10_POW = {\n+            Float16.valueOf(1), Float16.valueOf(10), Float16.valueOf(100),\n+            Float16.valueOf(1_000), Float16.valueOf(10_000)\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -4396,0 +4396,24 @@\n+    \/**\n+     * Converts this BigInteger to a {@code Float16}.  This\n+     * conversion is similar to the\n+     * <i>narrowing primitive conversion<\/i> from {@code double} to\n+     * {@code float} as defined in\n+     * <cite>The Java Language Specification<\/cite>:\n+     * if this BigInteger has too great a magnitude\n+     * to represent as a {@code Float16}, it will be converted to\n+     * {@link Float16#NEGATIVE_INFINITY} or {@link\n+     * Float16#POSITIVE_INFINITY} as appropriate.  Note that even when\n+     * the return value is finite, this conversion can lose\n+     * information about the precision of the BigInteger value.\n+     *\n+     * @return this BigInteger converted to a {@code Float16}.\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    public Float16 float16Value() {\n+        return signum == 0 || mag.length == 1\n+                ? Float16.valueOf(longValue())  \/\/ might return infinities\n+                : signum > 0\n+                ? Float16.POSITIVE_INFINITY\n+                : Float16.NEGATIVE_INFINITY;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8205592\n- * @summary Verify {double, float}Value methods work\n+ * @bug 8205592 8339252\n+ * @summary Verify {double, float, float16}Value methods work\n@@ -67,0 +67,26 @@\n+    \/*\n+     * Not a fully fledged implementation, only for finite positive values.\n+     *\/\n+    private static Float16 nextUp(Float16 v) {\n+        return Float16.shortBitsToFloat16((short) (Float16.float16ToRawShortBits(v) + 1));\n+    }\n+\n+    \/*\n+     * Not a fully fledged implementation, only for finite positive values.\n+     *\/\n+    private static Float16 nextDown(Float16 v) {\n+        return Float16.shortBitsToFloat16((short) (Float16.float16ToRawShortBits(v) - 1));\n+    }\n+\n+    private static BigDecimal nextHalfUp(Float16 v) {\n+        BigDecimal bv = new BigDecimal(v.doubleValue());\n+        BigDecimal ulp = new BigDecimal(Float16.ulp(v).doubleValue());\n+        return bv.add(ulp.multiply(HALF));\n+    }\n+\n+    private static BigDecimal nextHalfDown(Float16 v) {\n+        BigDecimal bv = new BigDecimal(v.doubleValue());\n+        BigDecimal ulp = new BigDecimal(v.doubleValue() - nextDown(v).doubleValue());\n+        return bv.subtract(ulp.multiply(HALF));\n+    }\n+\n@@ -75,0 +101,4 @@\n+    private static String toDecHexString(Float16 v) {\n+        return v + \" (\" + Float16.toHexString(v) + \")\";\n+    }\n+\n@@ -93,0 +123,9 @@\n+    private static void checkFloat16(BigDecimal bv, Float16 exp) {\n+        Float16 res = bv.float16Value();\n+        if (exp.floatValue() != res.floatValue()) {\n+            String message = \"Bad conversion: got \" + toDecHexString(res) +\n+                    \", expected \" + toDecHexString(exp);\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n@@ -115,0 +154,9 @@\n+    private static void testFloat16ValueNearMinValue() {\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal b = nextHalfUp(Float16.multiply(Float16.valueOf(n), Float16.MIN_VALUE));\n+            checkFloat16(b, Float16.multiply(Float16.valueOf((n + 1) \/ 2 * 2), Float16.MIN_VALUE));\n+            checkFloat16(b.subtract(EPS), Float16.multiply(Float16.valueOf(n), Float16.MIN_VALUE));\n+            checkFloat16(b.add(EPS), Float16.multiply(Float16.valueOf(n + 1), Float16.MIN_VALUE));\n+        }\n+    }\n+\n@@ -153,0 +201,19 @@\n+    private static void testFloat16ValueNearMinNormal() {\n+        Float16 v = Float16.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat16(bv, isOdd(n) ? nextDown(v) : v);\n+            checkFloat16(bv.subtract(EPS), nextDown(v));\n+            checkFloat16(bv.add(EPS), v);\n+            v = nextDown(v);\n+        }\n+        v = Float16.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfUp(v);\n+            checkFloat16(bv, isOdd(n) ? nextUp(v) : v);\n+            checkFloat16(bv.subtract(EPS), v);\n+            checkFloat16(bv.add(EPS), nextUp(v));\n+            v = nextUp(v);\n+        }\n+    }\n+\n@@ -183,0 +250,15 @@\n+    private static void testFloat16ValueNearMaxValue() {\n+        Float16 v = Float16.MAX_VALUE;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat16(bv, isOdd(n) ? v : nextDown(v));\n+            checkFloat16(bv.subtract(EPS), nextDown(v));\n+            checkFloat16(bv.add(EPS), v);\n+            v = nextDown(v);\n+        }\n+        BigDecimal bv = nextHalfUp(Float16.MAX_VALUE);\n+        checkFloat16(bv, Float16.POSITIVE_INFINITY);\n+        checkFloat16(bv.subtract(EPS), Float16.MAX_VALUE);\n+        checkFloat16(bv.add(EPS), Float16.POSITIVE_INFINITY);\n+    }\n+\n@@ -231,0 +313,24 @@\n+    private static void testFloat16ValueRandom() {\n+        Random r = RandomFactory.getRandom();\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-Float16.MAX_VALUE.floatValue(), Float16.MAX_VALUE.floatValue()));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e4f, 1e4f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e3f, 1e3f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e-3f, 1e-3f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e-4f, 1e-4f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+    }\n+\n@@ -235,1 +341,1 @@\n-        checkDouble(BigDecimal.valueOf(-1, -1000), -Double.POSITIVE_INFINITY);\n+        checkDouble(BigDecimal.valueOf(-1, -1000), Double.NEGATIVE_INFINITY);\n@@ -242,1 +348,8 @@\n-        checkFloat(BigDecimal.valueOf(-1, -1000), -Float.POSITIVE_INFINITY);\n+        checkFloat(BigDecimal.valueOf(-1, -1000), Float.NEGATIVE_INFINITY);\n+    }\n+\n+    private static void testFloat16ValueExtremes() {\n+        checkFloat16(BigDecimal.valueOf(1, 1000), Float16.valueOf(0.0f));\n+        checkFloat16(BigDecimal.valueOf(-1, 1000), Float16.valueOf(-0.0f));\n+        checkFloat16(BigDecimal.valueOf(1, -1000), Float16.POSITIVE_INFINITY);\n+        checkFloat16(BigDecimal.valueOf(-1, -1000), Float16.NEGATIVE_INFINITY);\n@@ -257,0 +370,6 @@\n+\n+        testFloat16ValueNearMinValue();\n+        testFloat16ValueNearMinNormal();\n+        testFloat16ValueNearMaxValue();\n+        testFloat16ValueRandom();\n+        testFloat16ValueExtremes();\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DoubleFloatValueTests.java","additions":124,"deletions":5,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,3 @@\n- * @bug 7131192\n- * @summary This test ensures that BigInteger.floatValue() and\n- *          BigInteger.doubleValue() behave correctly.\n+ * @bug 7131192 8339252\n+ * @summary This test ensures that BigInteger.float16Value(),\n+ *          BigInteger.floatValue(), BigInteger.doubleValue() behave correctly.\n@@ -101,0 +101,35 @@\n+    public static int testFloat16Value() {\n+        \/*\n+         * Test all integers in Float16's finite range and slightly beyond.\n+         * Also test a couple of really big integers.\n+         *\/\n+        System.out.println(\"--- testFloat16Value ---\");\n+        int high = Float16.MAX_VALUE.intValue() + Float16.ulp(Float16.MAX_VALUE).intValue();\n+        int failures = 0;\n+        for (int i = 0; i <= high; ++i) {\n+            BigInteger big = BigInteger.valueOf(i);\n+            failures = checkFloat16(Float16.valueOf(i), big.float16Value(), big, failures);\n+\n+            big = BigInteger.valueOf(-i);\n+            failures = checkFloat16(Float16.valueOf(-i), big.float16Value(), big, failures);\n+        }\n+\n+        BigInteger large = ONE.shiftLeft(1_000);\n+        failures = checkFloat16(Float16.POSITIVE_INFINITY, large.float16Value(), large, failures);\n+\n+        large = large.negate();\n+        failures = checkFloat16(Float16.NEGATIVE_INFINITY, large.float16Value(), large, failures);\n+\n+        return failures;\n+    }\n+\n+    private static int checkFloat16(Float16 expected, Float16 actual, BigInteger large, int failures) {\n+        if (Float16.float16ToRawShortBits(expected) !=\n+                Float16.float16ToRawShortBits(actual)) {\n+            System.out.format(\"big: %s, expected: %s, actual: %s%n\",\n+                    large, Float16.toHexString(expected), Float16.toHexString(actual));\n+            failures++;\n+        }\n+        return failures;\n+    }\n+\n@@ -104,0 +139,1 @@\n+        failures += testFloat16Value();\n","filename":"test\/jdk\/java\/math\/BigInteger\/PrimitiveConversionTests.java","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"}]}