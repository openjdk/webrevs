{"files":[{"patch":"@@ -277,1 +277,1 @@\n-  $1_FLAGS += $$($1_JAVAC_FLAGS)\n+  $1_FLAGS += $$($1_JAVAC_FLAGS) -XDenablePrimitiveClasses\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+java.base-FLAT-LAYOUT-VALUE-CLASS-REPLACEMENTS := \\\n+    java\/lang\/Float16.java \\\n+    #\n+\n@@ -66,0 +70,3 @@\n+java.base-FLAT-LAYOUT-VALUE-CLASS-FILES := \\\n+    $(foreach f, $(java.base-FLAT-LAYOUT-VALUE-CLASS-REPLACEMENTS), $(addprefix $(TOPDIR)\/src\/java.base\/share\/classes\/, $(f)))\n+\n@@ -76,0 +83,9 @@\n+$(eval $(call SetupTextFileProcessing, JAVA_BASE_FLAT_LAYOUT_VALUECLASS_REPLACEMENTS, \\\n+    SOURCE_FILES := $(java.base-FLAT-LAYOUT-VALUE-CLASS-FILES), \\\n+    SOURCE_BASE_DIR := $(TOPDIR)\/src\/java.base\/share\/classes, \\\n+    OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc-valueclasses\/java.base\/, \\\n+    REPLACEMENTS := \\\n+        public final class => @jdk.internal.vm.annotation.ImplicitlyConstructible\\n@jdk.internal.vm.annotation.NullRestrictedArray\\npublic final value class ; \\\n+        public abstract class => public abstract value class, \\\n+))\n+\n@@ -77,0 +93,1 @@\n+TARGETS += $(JAVA_BASE_FLAT_LAYOUT_VALUECLASS_REPLACEMENTS)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcValueClasses.gmk","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2302,1 +2302,14 @@\n-      break;\n+    break;\n+    case Op_AddHF:\n+    case Op_SubHF:\n+    case Op_MulHF:\n+    case Op_DivHF:\n+    case Op_MinHF:\n+    case Op_MaxHF:\n+      \/\/ Half-precision floating point scalar operations require FEAT_FP16\n+      \/\/ to be available. FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\"\n+      \/\/ features are supported.\n+      if (!VM_Version::supports_fphp() || !VM_Version::supports_asimdhp()) {\n+        return false;\n+    }\n+    break;\n@@ -13634,0 +13647,15 @@\n+\/\/ Half-precision floating point add operation\n+instruct addHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (AddHF src1 src2));\n+\n+  format %{ \"faddh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ faddh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13664,0 +13692,15 @@\n+instruct subHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (SubHF src1 src2));\n+\n+  ins_cost(INSN_COST * 5);\n+  format %{ \"fsubh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fsubh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13694,0 +13737,15 @@\n+instruct mulHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MulHF src1 src2));\n+\n+  ins_cost(INSN_COST * 6);\n+  format %{ \"fmulh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fmulh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13865,0 +13923,23 @@\n+\/\/ Math.max(HF)\n+instruct maxHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MaxHF src1 src2));\n+  format %{ \"fmaxh   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fmaxh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+\/\/ Math.min(HF)\n+instruct minHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MinHF src1 src2));\n+  format %{ \"fminh   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fminh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n@@ -13922,0 +14003,14 @@\n+instruct divHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (DivHF src1  src2));\n+\n+  ins_cost(INSN_COST * 18);\n+  format %{ \"fdivh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fdivh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_div_s);\n+%}\n@@ -17071,0 +17166,39 @@\n+\/\/----------------------------- Reinterpret ----------------------------------\n+\n+instruct reinterpretHF2S(iRegINoSp dst, vRegF src) %{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"reinterpretHF2S $dst, $src\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ H, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretS2HF(vRegF dst, iRegINoSp src) %{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"reinterpretS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ H, 0, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2HFAndS2HF(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvtsh($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretHF2SAndHF2F(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"reinterpretHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvths($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":135,"deletions":1,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n@@ -230,0 +230,13 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports half-precision floats\n+        \/\/ by default.\n+        if (UseSVE > 0 || (VM_Version::supports_fphp() && VM_Version::supports_asimdhp())) {\n+          break;\n+        }\n+        return false;\n@@ -577,0 +590,16 @@\n+instruct vaddHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"vaddHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fadd($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fadd($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -651,0 +680,10 @@\n+instruct vaddHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vaddHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadd($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -801,0 +840,16 @@\n+instruct vsubHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"vsubHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -875,0 +930,10 @@\n+instruct vsubHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vsubHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -998,0 +1063,16 @@\n+instruct vmulHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVHF src1 src2));\n+  format %{ \"vmulHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1072,0 +1153,10 @@\n+instruct vmulHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vmulHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1096,0 +1187,22 @@\n+instruct vdivHF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVHF src1 src2));\n+  format %{ \"vdivHF_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivHF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVHF dst_src1 src2));\n+  format %{ \"vdivHF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1142,0 +1255,10 @@\n+instruct vdivHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vdivHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1968,0 +2091,25 @@\n+instruct vhfmin_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MinVHF src1 src2));\n+  format %{ \"vhfmin_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ fmin($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vhfmin_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MinVHF dst_src1 src2));\n+  format %{ \"vhfmin_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1988,0 +2136,12 @@\n+instruct vhfmin_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MinVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vhfmin_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2055,0 +2215,25 @@\n+instruct vhfmax_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MaxVHF src1 src2));\n+  format %{ \"vhfmax_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ fmax($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vhfmax_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MaxVHF dst_src1 src2));\n+  format %{ \"vhfmax_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2075,0 +2260,12 @@\n+instruct vhfmax_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MaxVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vhfmax_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":198,"deletions":1,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n@@ -220,0 +220,13 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports half-precision floats\n+        \/\/ by default.\n+        if (UseSVE > 0 || (VM_Version::supports_fphp() && VM_Version::supports_asimdhp())) {\n+          break;\n+        }\n+        return false;\n@@ -502,6 +515,7 @@\n-BINARY_OP(vaddB, AddVB, addv, sve_add,  B)\n-BINARY_OP(vaddS, AddVS, addv, sve_add,  H)\n-BINARY_OP(vaddI, AddVI, addv, sve_add,  S)\n-BINARY_OP(vaddL, AddVL, addv, sve_add,  D)\n-BINARY_OP(vaddF, AddVF, fadd, sve_fadd, S)\n-BINARY_OP(vaddD, AddVD, fadd, sve_fadd, D)\n+BINARY_OP(vaddB,  AddVB,  addv, sve_add,  B)\n+BINARY_OP(vaddS,  AddVS,  addv, sve_add,  H)\n+BINARY_OP(vaddI,  AddVI,  addv, sve_add,  S)\n+BINARY_OP(vaddL,  AddVL,  addv, sve_add,  D)\n+BINARY_OP(vaddHF, AddVHF, fadd, sve_fadd, H)\n+BINARY_OP(vaddF,  AddVF,  fadd, sve_fadd, S)\n+BINARY_OP(vaddD,  AddVD,  fadd, sve_fadd, D)\n@@ -510,6 +524,7 @@\n-BINARY_OP_PREDICATE(vaddB, AddVB, sve_add,  B)\n-BINARY_OP_PREDICATE(vaddS, AddVS, sve_add,  H)\n-BINARY_OP_PREDICATE(vaddI, AddVI, sve_add,  S)\n-BINARY_OP_PREDICATE(vaddL, AddVL, sve_add,  D)\n-BINARY_OP_PREDICATE(vaddF, AddVF, sve_fadd, S)\n-BINARY_OP_PREDICATE(vaddD, AddVD, sve_fadd, D)\n+BINARY_OP_PREDICATE(vaddB,  AddVB,  sve_add,  B)\n+BINARY_OP_PREDICATE(vaddS,  AddVS,  sve_add,  H)\n+BINARY_OP_PREDICATE(vaddI,  AddVI,  sve_add,  S)\n+BINARY_OP_PREDICATE(vaddL,  AddVL,  sve_add,  D)\n+BINARY_OP_PREDICATE(vaddHF, AddVHF, sve_fadd, H)\n+BINARY_OP_PREDICATE(vaddF,  AddVF,  sve_fadd, S)\n+BINARY_OP_PREDICATE(vaddD,  AddVD,  sve_fadd, D)\n@@ -526,6 +541,7 @@\n-BINARY_OP(vsubB, SubVB, subv, sve_sub,  B)\n-BINARY_OP(vsubS, SubVS, subv, sve_sub,  H)\n-BINARY_OP(vsubI, SubVI, subv, sve_sub,  S)\n-BINARY_OP(vsubL, SubVL, subv, sve_sub,  D)\n-BINARY_OP(vsubF, SubVF, fsub, sve_fsub, S)\n-BINARY_OP(vsubD, SubVD, fsub, sve_fsub, D)\n+BINARY_OP(vsubB,  SubVB,  subv, sve_sub,  B)\n+BINARY_OP(vsubS,  SubVS,  subv, sve_sub,  H)\n+BINARY_OP(vsubI,  SubVI,  subv, sve_sub,  S)\n+BINARY_OP(vsubL,  SubVL,  subv, sve_sub,  D)\n+BINARY_OP(vsubHF, SubVHF, fsub, sve_fsub, H)\n+BINARY_OP(vsubF,  SubVF,  fsub, sve_fsub, S)\n+BINARY_OP(vsubD,  SubVD,  fsub, sve_fsub, D)\n@@ -534,6 +550,7 @@\n-BINARY_OP_PREDICATE(vsubB, SubVB, sve_sub,  B)\n-BINARY_OP_PREDICATE(vsubS, SubVS, sve_sub,  H)\n-BINARY_OP_PREDICATE(vsubI, SubVI, sve_sub,  S)\n-BINARY_OP_PREDICATE(vsubL, SubVL, sve_sub,  D)\n-BINARY_OP_PREDICATE(vsubF, SubVF, sve_fsub, S)\n-BINARY_OP_PREDICATE(vsubD, SubVD, sve_fsub, D)\n+BINARY_OP_PREDICATE(vsubB,  SubVB,  sve_sub,  B)\n+BINARY_OP_PREDICATE(vsubS,  SubVS,  sve_sub,  H)\n+BINARY_OP_PREDICATE(vsubI,  SubVI,  sve_sub,  S)\n+BINARY_OP_PREDICATE(vsubL,  SubVL,  sve_sub,  D)\n+BINARY_OP_PREDICATE(vsubHF, SubVHF, sve_fsub, H)\n+BINARY_OP_PREDICATE(vsubF,  SubVF,  sve_fsub, S)\n+BINARY_OP_PREDICATE(vsubD,  SubVD,  sve_fsub, D)\n@@ -606,2 +623,3 @@\n-BINARY_OP(vmulF, MulVF, fmul, sve_fmul, S)\n-BINARY_OP(vmulD, MulVD, fmul, sve_fmul, D)\n+BINARY_OP(vmulHF, MulVHF, fmul, sve_fmul, H)\n+BINARY_OP(vmulF,  MulVF,  fmul, sve_fmul, S)\n+BINARY_OP(vmulD,  MulVD,  fmul, sve_fmul, D)\n@@ -610,6 +628,7 @@\n-BINARY_OP_PREDICATE(vmulB, MulVB, sve_mul,  B)\n-BINARY_OP_PREDICATE(vmulS, MulVS, sve_mul,  H)\n-BINARY_OP_PREDICATE(vmulI, MulVI, sve_mul,  S)\n-BINARY_OP_PREDICATE(vmulL, MulVL, sve_mul,  D)\n-BINARY_OP_PREDICATE(vmulF, MulVF, sve_fmul, S)\n-BINARY_OP_PREDICATE(vmulD, MulVD, sve_fmul, D)\n+BINARY_OP_PREDICATE(vmulB,  MulVB,  sve_mul,  B)\n+BINARY_OP_PREDICATE(vmulS,  MulVS,  sve_mul,  H)\n+BINARY_OP_PREDICATE(vmulI,  MulVI,  sve_mul,  S)\n+BINARY_OP_PREDICATE(vmulL,  MulVL,  sve_mul,  D)\n+BINARY_OP_PREDICATE(vmulHF, MulVHF, sve_fmul, H)\n+BINARY_OP_PREDICATE(vmulF,  MulVF,  sve_fmul, S)\n+BINARY_OP_PREDICATE(vmulD,  MulVD,  sve_fmul, D)\n@@ -620,2 +639,3 @@\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivF, DivVF, fdiv, sve_fdiv, S)\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivD, DivVD, fdiv, sve_fdiv, D)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivHF, DivVHF, fdiv, sve_fdiv, H)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivF,  DivVF,  fdiv, sve_fdiv, S)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivD,  DivVD,  fdiv, sve_fdiv, D)\n@@ -624,2 +644,3 @@\n-BINARY_OP_PREDICATE(vdivF, DivVF, sve_fdiv, S)\n-BINARY_OP_PREDICATE(vdivD, DivVD, sve_fdiv, D)\n+BINARY_OP_PREDICATE(vdivHF, DivVHF, sve_fdiv, H)\n+BINARY_OP_PREDICATE(vdivF,  DivVF,  sve_fdiv, S)\n+BINARY_OP_PREDICATE(vdivD,  DivVD,  sve_fdiv, D)\n@@ -1009,0 +1030,15 @@\n+dnl VHFMINMAX_NEON($1,   $2,      $3     )\n+dnl VHFMINMAX_NEON(type, op_name, insn_fp)\n+define(`VHFMINMAX_NEON', `\n+instruct vhf$1_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"vhf$1_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1032,0 +1068,16 @@\n+dnl VHFMINMAX_SVE($1,   $2,      $3     )\n+dnl VHFMINMAX_SVE(type, op_name, insn_fp)\n+define(`VHFMINMAX_SVE', `\n+instruct vhf$1_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"vhf$1_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1053,0 +1105,15 @@\n+dnl VHFMINMAX_PREDICATE($1,   $2,      $3     )\n+dnl VHFMINMAX_PREDICATE(type, op_name, insn_fp)\n+define(`VHFMINMAX_PREDICATE', `\n+instruct vhf$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"vhf$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1062,0 +1129,2 @@\n+VHFMINMAX_NEON(min, MinVHF, fmin)\n+VHFMINMAX_SVE(min, MinVHF, sve_fmin)\n@@ -1065,0 +1134,1 @@\n+VHFMINMAX_PREDICATE(min, MinVHF, sve_fmin)\n@@ -1075,0 +1145,2 @@\n+VHFMINMAX_NEON(max, MaxVHF, fmax)\n+VHFMINMAX_SVE(max, MaxVHF, sve_fmax)\n@@ -1078,0 +1150,1 @@\n+VHFMINMAX_PREDICATE(max, MaxVHF, sve_fmax)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":110,"deletions":37,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -244,0 +244,13 @@\n+\/\/ This method is used to generate Advanced SIMD data processing instructions\n+void Assembler::adv_simd_three_same(Instruction_aarch64 &current_insn, FloatRegister Vd,\n+                                    SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm,\n+                                    int op1, int op2, int op3) {\n+  assert(T == T4H || T == T8H || T == T2S || T == T4S || T == T2D, \"invalid arrangement\");\n+  int op22 = (T == T2S || T == T4S) ? 0b0 : 0b1;\n+  int op21 = (T == T4H || T == T8H) ? 0b0 : 0b1;\n+  int op14 = (T == T4H || T == T8H) ? 0b00 : 0b11;\n+  f(0, 31), f((int)T & 1, 30), f(op1, 29), f(0b01110, 28, 24), f(op2, 23);\n+  f(op22, 22); f(op21, 21), rf(Vm, 16), f(op14, 15, 14), f(op3, 13, 10),\n+  rf(Vn, 5), rf(Vd, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2046,1 +2046,1 @@\n-  void data_processing(unsigned op31, unsigned type, unsigned opcode,\n+  void data_processing(unsigned op31, unsigned type, unsigned opcode, unsigned op21,\n@@ -2051,1 +2051,1 @@\n-    f(type, 23, 22), f(1, 21), f(opcode, 15, 10);\n+    f(type, 23, 22), f(op21, 21), f(opcode, 15, 10);\n@@ -2055,1 +2055,1 @@\n-#define INSN(NAME, op31, type, opcode)                  \\\n+#define INSN(NAME, op31, type, opcode, op21)                            \\\n@@ -2057,21 +2057,29 @@\n-    data_processing(op31, type, opcode, Vd, Vn, Vm);    \\\n-  }\n-\n-  INSN(fabds,  0b011, 0b10, 0b110101);\n-  INSN(fmuls,  0b000, 0b00, 0b000010);\n-  INSN(fdivs,  0b000, 0b00, 0b000110);\n-  INSN(fadds,  0b000, 0b00, 0b001010);\n-  INSN(fsubs,  0b000, 0b00, 0b001110);\n-  INSN(fmaxs,  0b000, 0b00, 0b010010);\n-  INSN(fmins,  0b000, 0b00, 0b010110);\n-  INSN(fnmuls, 0b000, 0b00, 0b100010);\n-\n-  INSN(fabdd,  0b011, 0b11, 0b110101);\n-  INSN(fmuld,  0b000, 0b01, 0b000010);\n-  INSN(fdivd,  0b000, 0b01, 0b000110);\n-  INSN(faddd,  0b000, 0b01, 0b001010);\n-  INSN(fsubd,  0b000, 0b01, 0b001110);\n-  INSN(fmaxd,  0b000, 0b01, 0b010010);\n-  INSN(fmind,  0b000, 0b01, 0b010110);\n-  INSN(fnmuld, 0b000, 0b01, 0b100010);\n-\n+    data_processing(op31, type, opcode, op21, Vd, Vn, Vm);              \\\n+  }\n+\n+  INSN(fabds,  0b011, 0b10, 0b110101, 0b1);\n+  INSN(fmuls,  0b000, 0b00, 0b000010, 0b1);\n+  INSN(fdivs,  0b000, 0b00, 0b000110, 0b1);\n+  INSN(fadds,  0b000, 0b00, 0b001010, 0b1);\n+  INSN(fsubs,  0b000, 0b00, 0b001110, 0b1);\n+  INSN(fmaxs,  0b000, 0b00, 0b010010, 0b1);\n+  INSN(fmins,  0b000, 0b00, 0b010110, 0b1);\n+  INSN(fnmuls, 0b000, 0b00, 0b100010, 0b1);\n+\n+  INSN(fabdd,  0b011, 0b11, 0b110101, 0b1);\n+  INSN(fmuld,  0b000, 0b01, 0b000010, 0b1);\n+  INSN(fdivd,  0b000, 0b01, 0b000110, 0b1);\n+  INSN(faddd,  0b000, 0b01, 0b001010, 0b1);\n+  INSN(fsubd,  0b000, 0b01, 0b001110, 0b1);\n+  INSN(fmaxd,  0b000, 0b01, 0b010010, 0b1);\n+  INSN(fmind,  0b000, 0b01, 0b010110, 0b1);\n+  INSN(fnmuld, 0b000, 0b01, 0b100010, 0b1);\n+\n+  INSN(fabdh,  0b011, 0b11, 0b000101, 0b0);\n+  INSN(fmulh,  0b000, 0b11, 0b000010, 0b1);\n+  INSN(fdivh,  0b000, 0b11, 0b000110, 0b1);\n+  INSN(faddh,  0b000, 0b11, 0b001010, 0b1);\n+  INSN(fsubh,  0b000, 0b11, 0b001110, 0b1);\n+  INSN(fmaxh,  0b000, 0b11, 0b010010, 0b1);\n+  INSN(fminh,  0b000, 0b11, 0b010110, 0b1);\n+  INSN(fnmulh, 0b000, 0b11, 0b100010, 0b1);\n@@ -2682,6 +2690,9 @@\n-#define INSN(NAME, op1, op2, op3)                                                       \\\n-  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \\\n-    starti;                                                                             \\\n-    assert(T == T2S || T == T4S || T == T2D, \"invalid arrangement\");                    \\\n-    f(0, 31), f((int)T & 1, 30), f(op1, 29), f(0b01110, 28, 24), f(op2, 23);            \\\n-    f(T==T2D ? 1:0, 22); f(1, 21), rf(Vm, 16), f(op3, 15, 10), rf(Vn, 5), rf(Vd, 0);    \\\n+\n+void adv_simd_three_same(Instruction_aarch64 &current_insn, FloatRegister Vd,\n+                         SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm,\n+                         int op1, int op2, int op3);\n+\n+#define INSN(NAME, op1, op2, op3)                                                             \\\n+  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) {       \\\n+    starti;                                                                                   \\\n+    adv_simd_three_same(current_insn, Vd, T, Vn, Vm, op1, op2, op3);                          \\\n@@ -2690,11 +2701,11 @@\n-  INSN(fabd, 1, 1, 0b110101);\n-  INSN(fadd, 0, 0, 0b110101);\n-  INSN(fdiv, 1, 0, 0b111111);\n-  INSN(faddp, 1, 0, 0b110101);\n-  INSN(fmul, 1, 0, 0b110111);\n-  INSN(fsub, 0, 1, 0b110101);\n-  INSN(fmla, 0, 0, 0b110011);\n-  INSN(fmls, 0, 1, 0b110011);\n-  INSN(fmax, 0, 0, 0b111101);\n-  INSN(fmin, 0, 1, 0b111101);\n-  INSN(facgt, 1, 1, 0b111011);\n+  INSN(fabd,  1, 1, 0b0101);\n+  INSN(fadd,  0, 0, 0b0101);\n+  INSN(fdiv,  1, 0, 0b1111);\n+  INSN(faddp, 1, 0, 0b0101);\n+  INSN(fmul,  1, 0, 0b0111);\n+  INSN(fsub,  0, 1, 0b0101);\n+  INSN(fmla,  0, 0, 0b0011);\n+  INSN(fmls,  0, 1, 0b0011);\n+  INSN(fmax,  0, 0, 0b1101);\n+  INSN(fmin,  0, 1, 0b1101);\n+  INSN(facgt, 1, 1, 0b1011);\n@@ -3285,1 +3296,1 @@\n-    assert(T == S || T == D, \"invalid register variant\");                              \\\n+    assert(T == H || T == S || T == D, \"invalid register variant\");                    \\\n@@ -3368,1 +3379,1 @@\n-    assert(T == S || T == D, \"invalid register variant\");                                             \\\n+    assert(T == H || T == S || T == D, \"invalid register variant\");                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":55,"deletions":44,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -1192,1 +1192,2 @@\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n+  bool is_null_free = x->is_null_free() ||  x->klass()->has_flat_layout();\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, is_null_free);\n@@ -1198,1 +1199,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, is_null_free);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -127,0 +127,2 @@\n+    decl(FPHP,          fphp,          9)     \\\n+    decl(ASIMDHP,       asimdhp,       10)    \\\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3161,0 +3161,16 @@\n+void Assembler::vmovw(XMMRegister dst, Register src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6E, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovw(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x7E, (0xC0 | encode));\n+}\n+\n@@ -7429,0 +7445,96 @@\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::eaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::esubsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::edivsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::emulsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::emaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::eminsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n@@ -11612,1 +11724,1 @@\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ of form {0F, 0F_38, 0F_3A, MAP5}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":113,"deletions":1,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -551,0 +551,1 @@\n+    VEX_OPCODE_MAP5  = 0x5,\n@@ -1658,0 +1659,3 @@\n+  void vmovw(XMMRegister dst, Register src);\n+  void vmovw(Register dst, XMMRegister src);\n+\n@@ -2411,0 +2415,12 @@\n+  void eaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void esubsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void emulsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void edivsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void emaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void eminsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1384,1 +1384,2 @@\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n+  bool is_null_free = x->is_null_free() || x->klass()->has_flat_layout();\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, is_null_free);\n@@ -1389,1 +1390,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, is_null_free);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6526,0 +6526,24 @@\n+\n+void C2_MacroAssembler::efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2) {\n+  switch(opcode) {\n+    case Op_AddHF: eaddsh(dst, src1, src2); break;\n+    case Op_SubHF: esubsh(dst, src1, src2); break;\n+    case Op_MulHF: emulsh(dst, src1, src2); break;\n+    case Op_DivHF: edivsh(dst, src1, src2); break;\n+    case Op_MaxHF: eminsh(dst, src1, src2); break;\n+    case Op_MinHF: emaxsh(dst, src1, src2); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    case Op_MaxVHF: evminph(dst, src1, src2, vlen_enc); break;\n+    case Op_MinVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -504,0 +504,4 @@\n+  void efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2);\n+\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -966,0 +966,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n@@ -1002,0 +1003,1 @@\n+      _features &= ~CPU_AVX512_FP16;\n@@ -3048,0 +3050,3 @@\n+\n+    if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+      result |= CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,1 +278,3 @@\n-                           : 11;\n+                           : 2,\n+              avx512_fp16  : 1,\n+                           : 8;\n@@ -403,1 +405,2 @@\n-    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/\n+    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n+    decl(AVX512_FP16,       \"avx512_fp16\",       60) \/* AVX512 FP16 ISA support*\/\n@@ -720,0 +723,1 @@\n+  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1466,0 +1466,12 @@\n+    case Op_AddHF:\n+    case Op_SubHF:\n+    case Op_MulHF:\n+    case Op_DivHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -1730,0 +1742,10 @@\n+    case Op_AddVHF:\n+    case Op_SubVHF:\n+    case Op_MulVHF:\n+    case Op_DivVHF:\n+    case Op_MaxVHF:\n+    case Op_MinVHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -10132,0 +10154,64 @@\n+\n+instruct reinterpretS2H (regF dst, rRegI src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2HFAndS2HF (regF dst, regF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretH2S (rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct fp16_scalar_ops (regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  match(Set dst (SubHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  match(Set dst (MaxHF src1 src2));\n+  format %{ \"efp16sh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ efp16sh(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct fp16_vector_ops (vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (AddVHF src1 src2));\n+  match(Set dst (SubVHF src1 src2));\n+  match(Set dst (MulVHF src1 src2));\n+  match(Set dst (DivVHF src1 src2));\n+  match(Set dst (MaxVHF src1 src2));\n+  match(Set dst (MinVHF src1 src2));\n+  format %{ \"evfp16ph $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":86,"deletions":0,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,8 @@\n+#ifndef HWCAP_FPHP\n+#define HWCAP_FPHP (1<<9)\n+#endif\n+\n+#ifndef HWCAP_ASIMDHP\n+#define HWCAP_ASIMDHP (1<<10)\n+#endif\n+\n@@ -123,0 +131,2 @@\n+  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -137,1 +147,3 @@\n-      HWCAP_PACA);\n+      HWCAP_PACA    |\n+      HWCAP_FPHP    |\n+      HWCAP_ASIMDHP);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3954,1 +3954,1 @@\n-    \"AddI\",\"AddL\",\"AddF\",\"AddD\",\n+    \"AddI\",\"AddL\",\"AddHF\",\"AddF\",\"AddD\",\n@@ -3956,2 +3956,2 @@\n-    \"MaxI\",\"MinI\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n-    \"MulI\",\"MulL\",\"MulF\",\"MulD\",\n+    \"MaxI\",\"MinI\",\"MaxHF\",\"MinHF\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n+    \"MulI\",\"MulL\",\"MulHF\",\"MulF\",\"MulD\",\n@@ -3963,2 +3963,2 @@\n-    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVF\", \"AddVD\",\n-    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVF\", \"MulVD\",\n+    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVHF\", \"AddVF\", \"AddVD\",\n+    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVHF\", \"MulVF\", \"MulVD\",\n@@ -3966,1 +3966,1 @@\n-    \"MaxV\", \"MinV\"\n+    \"MaxVHF\", \"MinVHF\", \"MaxV\", \"MinV\"\n@@ -4193,0 +4193,1 @@\n+        strcmp(opType,\"DivHF\")==0 ||\n@@ -4332,4 +4333,4 @@\n-    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n-    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\",\"SubVF\",\"SubVD\",\n-    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\",\"MulVF\",\"MulVD\",\n-    \"DivVF\",\"DivVD\",\n+    \"AddVB\",\"AddVHF\", \"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n+    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\", \"SubVHF\", \"SubVF\",\"SubVD\",\n+    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\", \"MulVHF\", \"MulVF\",\"MulVD\",\n+    \"DivVHF\",\"DivVF\",\"DivVD\",\n@@ -4340,1 +4341,1 @@\n-    \"MaxV\", \"MinV\",\n+    \"MaxV\", \"MinV\", \"MinVHF\", \"MaxVHF\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -419,0 +419,1 @@\n+  static void restore_loader_data() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -110,1 +110,2 @@\n-    if (null_free && klass->is_loaded()) {\n+    bool value_based_flat_layout = klass->has_flat_layout();\n+    if ((null_free || value_based_flat_layout) && klass->is_loaded()) {\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -261,0 +261,13 @@\n+\n+\/\/-------------------------------------------------------------------\n+\/\/ ciKlass::has_flat_layout\n+\/\/\n+\/\/\n+bool ciKlass::has_flat_layout() const {\n+  GUARDED_VM_ENTRY(\n+  return is_loaded() && get_Klass()->is_instance_klass() &&\n+         InstanceKlass::cast(get_Klass())->is_implicitly_constructible() &&\n+         InstanceKlass::cast(get_Klass())->has_null_restricted_array() &&\n+         !InstanceKlass::cast(get_Klass())->must_be_atomic();\n+  )\n+}\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -134,0 +134,2 @@\n+  bool has_flat_layout() const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -959,0 +959,1 @@\n+    _jdk_internal_NullRestrictedArray,\n@@ -2076,0 +2077,4 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NullRestrictedArray_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_NullRestrictedArray;\n+    }\n@@ -4681,0 +4686,7 @@\n+bool ClassFileParser::is_jdk_internal_class_sig(const char* sig) const {\n+  if (strstr(sig, vmSymbols::java_lang_Float16_signature()->as_C_string())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -5626,0 +5638,3 @@\n+  if (_has_null_restricted_array) {\n+    ik->set_has_null_restricted_array();\n+  }\n@@ -5902,0 +5917,1 @@\n+  _has_null_restricted_array(false),\n@@ -6390,0 +6406,7 @@\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_NullRestrictedArray)) {\n+      _has_null_restricted_array = true;\n+    }\n+    \/\/ Implicit constructibility and null restriction are sufficient to guarantee atomic updates to value based boxed primitives.\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ValueBased) && _has_null_restricted_array && _is_implicitly_constructible) {\n+      _must_be_atomic = false;\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  bool _has_null_restricted_array;\n@@ -225,0 +226,2 @@\n+  bool is_jdk_internal_class_sig(const char* sig) const;\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+  do_klass(Float16_klass,                               java_lang_Float16                                     ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,0 +198,16 @@\n+                                                                                                                        \\\n+  \/* Float16 intrinsics, similar to what we have in Math. *\/                                                            \\\n+  \/* All names for Float16 binary operations *\/                                                                         \\\n+  do_name(add_name, \"add\")                                                                                              \\\n+  do_name(subtract_name, \"subtract\")                                                                                    \\\n+  do_name(multiply_name, \"multiply\")                                                                                    \\\n+  do_name(divide_name, \"divide\")                                                                                        \\\n+  \/* Float16 signature for binary operations *\/                                                                         \\\n+  do_signature(floa16_float16_signature, \"(Ljava\/lang\/Float16;Ljava\/lang\/Float16;)Ljava\/lang\/Float16;\")                 \\\n+  \/* Float16 intrinsics for binary operations *\/                                                                        \\\n+  do_intrinsic(_add_float16,              java_lang_Float16,      add_name,           floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_subtract_float16,         java_lang_Float16,      subtract_name,      floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_multiply_float16,         java_lang_Float16,      multiply_name,      floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_divide_float16,           java_lang_Float16,      divide_name,        floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_max_float16,              java_lang_Float16,      max_name,           floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_min_float16,              java_lang_Float16,      min_name,           floa16_float16_signature,  F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  template(java_lang_Float16,                         \"java\/lang\/Float16\")                        \\\n+  template(java_lang_Float16_signature,               \"Ljava\/lang\/Float16;\")                      \\\n@@ -276,0 +278,1 @@\n+  template(jdk_internal_vm_annotation_NullRestrictedArray_signature,         \"Ljdk\/internal\/vm\/annotation\/NullRestrictedArray;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,2 +91,3 @@\n-    \/\/ has been aborted for any reason.\n-    bool yield_if_necessary() {\n+    \/\/ has been aborted for any reason. Yielded is set if there has been an actual\n+    \/\/ yield for a pause.\n+    bool yield_if_necessary(bool& yielded) {\n@@ -95,1 +96,1 @@\n-        _cm->do_yield_check();\n+        yielded = _cm->do_yield_check();\n@@ -125,1 +126,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -193,1 +195,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -213,1 +216,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded = true;\n+        bool mark_aborted = yield_if_necessary(yielded);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -381,0 +381,1 @@\n+  arrayOop obj = nullptr;\n@@ -382,1 +383,9 @@\n-  arrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n+  bool has_flat_layout = klass->is_inline_klass() &&\n+    InstanceKlass::cast(klass)->is_implicitly_constructible() &&\n+    InstanceKlass::cast(klass)->has_null_restricted_array() &&\n+    !InstanceKlass::cast(klass)->must_be_atomic();\n+  if (has_flat_layout) {\n+    obj = oopFactory::new_valueArray(klass, size, CHECK);\n+  } else {\n+    obj = oopFactory::new_objArray(klass, size, CHECK);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -552,0 +552,3 @@\n+  if (vmSymbols::java_lang_Float16() == name()) {\n+    Arguments::set_enable_preview();\n+  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -383,0 +383,3 @@\n+  bool has_null_restricted_array() const   { return _misc_flags.has_null_restricted_array(); }\n+  void set_has_null_restricted_array()     { _misc_flags.set_has_null_restricted_array(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-    flag(is_implicitly_constructible        , 1 << 20) \/* the class has the ImplicitlyConstrutible annotation *\/\n+    flag(is_implicitly_constructible        , 1 << 20) \/* the class has the ImplicitlyConstrutible annotation *\/ \\\n+    flag(has_null_restricted_array          , 1 << 21) \/* the class has the NullRestrictedArray annotation *\/\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,0 +141,8 @@\n+\/\/------------------------------AddHFNode---------------------------------------\n+\/\/ Add 2 half-precision floats\n+class AddHFNode : public AddFNode {\n+public:\n+  AddHFNode( Node *in1, Node *in2 ) : AddFNode(in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -401,0 +409,20 @@\n+\/\/------------------------------MaxHFNode--------------------------------------\n+\/\/ Maximum of 2 half floats.\n+class MaxHFNode : public MaxFNode {\n+public:\n+  MaxHFNode(Node* in1, Node* in2) : MaxFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n+\/\/------------------------------MinHFNode---------------------------------------\n+\/\/ Minimum of 2 half floats.\n+class MinHFNode : public MinFNode {\n+public:\n+  MinHFNode(Node* in1, Node* in2) : MinFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -605,0 +605,18 @@\n+  case vmIntrinsics::_add_float16:\n+    if (!Matcher::match_rule_supported(Op_AddHF)) return false;\n+    break;\n+  case vmIntrinsics::_subtract_float16:\n+    if (!Matcher::match_rule_supported(Op_SubHF)) return false;\n+    break;\n+  case vmIntrinsics::_multiply_float16:\n+    if (!Matcher::match_rule_supported(Op_MulHF)) return false;\n+    break;\n+  case vmIntrinsics::_divide_float16:\n+    if (!Matcher::match_rule_supported(Op_DivHF)) return false;\n+    break;\n+    case vmIntrinsics::_max_float16:\n+    if (!Matcher::match_rule_supported(Op_MaxHF)) return false;\n+    break;\n+  case vmIntrinsics::_min_float16:\n+    if (!Matcher::match_rule_supported(Op_MinHF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+macro(AddHF)\n@@ -169,0 +170,1 @@\n+macro(DivHF)\n@@ -225,0 +227,1 @@\n+macro(MaxHF)\n@@ -240,0 +243,1 @@\n+macro(MinHF)\n@@ -256,0 +260,1 @@\n+macro(MulHF)\n@@ -359,0 +364,1 @@\n+macro(SubHF)\n@@ -382,0 +388,1 @@\n+macro(AddVHF)\n@@ -390,0 +397,1 @@\n+macro(SubVHF)\n@@ -398,0 +406,1 @@\n+macro(MulVHF)\n@@ -405,0 +414,1 @@\n+macro(DivVHF)\n@@ -439,0 +449,2 @@\n+macro(MinVHF)\n+macro(MaxVHF)\n@@ -486,0 +498,2 @@\n+macro(ReinterpretS2HF)\n+macro(ReinterpretHF2S)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3682,0 +3682,6 @@\n+  case Op_AddHF:\n+  case Op_SubHF:\n+  case Op_MulHF:\n+  case Op_DivHF:\n+  case Op_MaxHF:\n+  case Op_MinHF:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -908,0 +908,32 @@\n+\n+const Type* ReinterpretS2HFNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type( in(1) );\n+  \/\/ Convert FP16 constant value to Float constant value, this will allow\n+  \/\/ further constant folding to be done at float granularity by value routines\n+  \/\/ of FP16 IR nodes.\n+  if ((type->isa_int() && type->is_int()->is_con()) && StubRoutines::hf2f_adr() != nullptr) {\n+     jshort hfval = type->is_int()->get_con();\n+     jfloat fval = StubRoutines::hf2f(hfval);\n+     return TypeF::make(fval);\n+  }\n+  return Type::FLOAT;\n+}\n+\n+Node* ReinterpretS2HFNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReinterpretHF2S) {\n+     assert(in(1)->in(1)->bottom_type()->isa_float(), \"\");\n+     return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+const Type* ReinterpretHF2SNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type( in(1) );\n+  \/\/ Convert Float constant value to FP16 constant value.\n+  if (type->isa_float_constant() && StubRoutines::f2hf_adr() != nullptr) {\n+     jfloat fval = type->is_float_constant()->_f;\n+     jshort hfval = StubRoutines::f2hf(fval);\n+     return TypeInt::make(hfval);\n+  }\n+  return TypeInt::SHORT;\n+}\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -172,0 +172,23 @@\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Short to Half Float\n+class ReinterpretS2HFNode : public Node {\n+  public:\n+  ReinterpretS2HFNode(Node* in1) : Node(0, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Half Float to Short\n+class ReinterpretHF2SNode : public Node {\n+  public:\n+  ReinterpretHF2SNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,8 @@\n+\/\/------------------------------DivHFNode--------------------------------------\n+\/\/ Half float division\n+class DivHFNode : public DivFNode {\n+public:\n+  DivHFNode(Node* c, Node* dividend, Node* divisor) : DivFNode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,3 +62,0 @@\n-  \/\/ Get the klass defining the field layout of the inline type\n-  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n-\n@@ -89,0 +86,3 @@\n+  \/\/ Get the klass defining the field layout of the inline type\n+  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -548,0 +548,6 @@\n+  case vmIntrinsics::_add_float16:\n+  case vmIntrinsics::_subtract_float16:\n+  case vmIntrinsics::_multiply_float16:\n+  case vmIntrinsics::_divide_float16:\n+  case vmIntrinsics::_max_float16:\n+  case vmIntrinsics::_min_float16:              return inline_fp16_operations(intrinsic_id());\n@@ -5058,0 +5064,35 @@\n+bool LibraryCallKit::inline_fp16_operations(vmIntrinsics::ID id) {\n+  if (!Matcher::match_rule_supported(Op_ReinterpretS2HF) ||\n+      !Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+    return false;\n+  }\n+\n+  Node* result = nullptr;\n+  Node* val1 = argument(0);  \/\/ receiver\n+  Node* val2 = argument(1);  \/\/ argument\n+  if (!val1->is_InlineType() || !val2->is_InlineType()) {\n+    return false;\n+  }\n+\n+  Node* fld1 = _gvn.transform(new ReinterpretS2HFNode(val1->as_InlineType()->field_value(0)));\n+  Node* fld2 = _gvn.transform(new ReinterpretS2HFNode(val2->as_InlineType()->field_value(0)));\n+\n+  switch (id) {\n+  case vmIntrinsics::_add_float16:       result = _gvn.transform(new AddHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_subtract_float16:  result = _gvn.transform(new SubHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_multiply_float16:  result = _gvn.transform(new MulHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_divide_float16:    result = _gvn.transform(new DivHFNode(0, fld1, fld2)); break;\n+  case vmIntrinsics::_max_float16:       result = _gvn.transform(new MaxHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_min_float16:       result = _gvn.transform(new MinHFNode(fld1, fld2));    break;\n+\n+  default:\n+    fatal_unexpected_iid(id);\n+    break;\n+  }\n+  InlineTypeNode* box = InlineTypeNode::make_uninitialized(_gvn, val1->as_InlineType()->inline_klass(), true);\n+  Node* short_result  = _gvn.transform(new ReinterpretHF2SNode(result));\n+  box->set_field_value(0, short_result);\n+  set_result(_gvn.transform(box));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -312,0 +312,1 @@\n+  bool inline_fp16_operations(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6286,0 +6286,1 @@\n+    case Op_DivHF:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-                  (op == Op_MulF) || (op == Op_MulD);\n+                  (op == Op_MulF) || (op == Op_MulD) ||\n+                  (op == Op_MulHF);\n@@ -124,2 +125,3 @@\n-      op != Op_MulF &&          \/\/ Float & double cannot reassociate\n-      op != Op_MulD ) {\n+      op != Op_MulF &&          \/\/ Float, half-precision float and double cannot reassociate\n+      op != Op_MulD &&\n+      op != Op_MulHF) {\n@@ -551,0 +553,8 @@\n+  return MulNode::Ideal(phase, can_reshape);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Ideal------------------------------------------\n+\/\/ Check to see if we are multiplying by a constant 2 and convert to add, then try the regular MulNode::Ideal\n+Node* MulHFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeF* t2 = phase->type(in(2))->isa_float_constant();\n@@ -552,0 +562,5 @@\n+  \/\/ x * 2 -> x + x\n+  if (t2 != nullptr && t2->getf() == 2) {\n+    Node* base = in(1);\n+    return new AddHFNode(base, base);\n+  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,13 @@\n+\/\/------------------------------MulHFNode---------------------------------------\n+\/\/ Multiply 2 half floats\n+class MulHFNode : public MulFNode {\n+public:\n+  MulHFNode(Node* in1, Node* in2) : MulFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int add_opcode() const { return Op_AddHF; }\n+  int mul_opcode() const { return Op_MulHF; }\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-\/\/ Subtract 2 doubles\n+\/\/ Subtract 2 floats\n@@ -119,0 +119,8 @@\n+\/\/------------------------------SubHFNode--------------------------------------\n+\/\/ Subtract 2 half floats\n+class SubHFNode : public SubFNode {\n+public:\n+  SubHFNode(Node* in1, Node* in2) : SubFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2705,0 +2705,7 @@\n+      } else if (opc == Op_ReinterpretS2HF || opc == Op_ReinterpretHF2S) {\n+        assert(n->req() == 2, \"only one input expected\");\n+        BasicType bt = velt_basic_type(n);\n+        const TypeVect* vt = TypeVect::make(bt, vlen);\n+        Node* in = vector_opd(p, 1);\n+        vn = VectorReinterpretNode::make(in, vt, vt);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n@@ -3400,0 +3407,1 @@\n+  int opc = n->Opcode();\n@@ -3407,1 +3415,1 @@\n-    if (n->Opcode() == Op_LoadUB) {\n+    if (opc == Op_LoadUB) {\n@@ -3417,0 +3425,9 @@\n+\n+  \/\/ First check if the node is a float16 node returning a \"Short\" type.\n+  \/\/ If it is, then it needs to be checked before the next condition.\n+  \/\/ Else it might return TypeInt::INT for float16 nodes instead of TypeInt::SHORT\n+  \/\/ which could cause assertion errors in VectorCastNode::opcode().\n+  if (opc == Op_ReinterpretHF2S || VectorNode::is_float16_node(opc)) {\n+    return TypeInt::SHORT;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+  case Op_AddHF: return (bt == T_SHORT ? Op_AddVHF : 0);\n@@ -62,0 +63,1 @@\n+  case Op_SubHF: return (bt == T_SHORT ? Op_SubVHF : 0);\n@@ -76,0 +78,2 @@\n+  case Op_MulHF:\n+    return (bt == T_SHORT ? Op_MulVHF : 0);\n@@ -90,0 +94,2 @@\n+  case Op_DivHF:\n+    return (bt == T_SHORT ? Op_DivVHF : 0);\n@@ -116,0 +122,2 @@\n+  case Op_MinHF:\n+    return (bt == T_SHORT ? Op_MinVHF : 0);\n@@ -131,0 +139,2 @@\n+  case Op_MaxHF:\n+    return (bt == T_SHORT ? Op_MaxVHF : 0);\n@@ -270,0 +280,3 @@\n+  case Op_ReinterpretS2HF:\n+  case Op_ReinterpretHF2S:\n+    return Op_VectorReinterpret;\n@@ -382,0 +395,4 @@\n+    case Op_MinVHF:\n+      return Op_MinHF;\n+    case Op_MaxVHF:\n+      return Op_MaxHF;\n@@ -586,0 +603,16 @@\n+bool VectorNode::is_float16_node(int opc) {\n+  switch (opc) {\n+  case Op_AddHF:\n+  case Op_SubHF:\n+  case Op_MulHF:\n+  case Op_DivHF:\n+  case Op_MinHF:\n+  case Op_MaxHF:\n+  case Op_ConvF2HF:\n+  case Op_ReinterpretS2HF:\n+     return true;\n+  default:\n+     return false;\n+  }\n+}\n+\n@@ -639,4 +672,4 @@\n-  case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:\n-  case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:\n-  case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:\n-  case Op_DivF: case Op_DivD:\n+  case Op_AddI: case Op_AddHF: case Op_AddL: case Op_AddF: case Op_AddD:\n+  case Op_SubI: case Op_SubL: case Op_SubHF: case Op_SubF: case Op_SubD:\n+  case Op_MulI: case Op_MulL: case Op_MulHF: case Op_MulF: case Op_MulD:\n+  case Op_DivHF: case Op_DivF: case Op_DivD:\n@@ -696,23 +729,27 @@\n-  case Op_AddVB: return new AddVBNode(n1, n2, vt);\n-  case Op_AddVS: return new AddVSNode(n1, n2, vt);\n-  case Op_AddVI: return new AddVINode(n1, n2, vt);\n-  case Op_AddVL: return new AddVLNode(n1, n2, vt);\n-  case Op_AddVF: return new AddVFNode(n1, n2, vt);\n-  case Op_AddVD: return new AddVDNode(n1, n2, vt);\n-\n-  case Op_SubVB: return new SubVBNode(n1, n2, vt);\n-  case Op_SubVS: return new SubVSNode(n1, n2, vt);\n-  case Op_SubVI: return new SubVINode(n1, n2, vt);\n-  case Op_SubVL: return new SubVLNode(n1, n2, vt);\n-  case Op_SubVF: return new SubVFNode(n1, n2, vt);\n-  case Op_SubVD: return new SubVDNode(n1, n2, vt);\n-\n-  case Op_MulVB: return new MulVBNode(n1, n2, vt);\n-  case Op_MulVS: return new MulVSNode(n1, n2, vt);\n-  case Op_MulVI: return new MulVINode(n1, n2, vt);\n-  case Op_MulVL: return new MulVLNode(n1, n2, vt);\n-  case Op_MulVF: return new MulVFNode(n1, n2, vt);\n-  case Op_MulVD: return new MulVDNode(n1, n2, vt);\n-\n-  case Op_DivVF: return new DivVFNode(n1, n2, vt);\n-  case Op_DivVD: return new DivVDNode(n1, n2, vt);\n+  case Op_AddVB:  return new AddVBNode(n1, n2, vt);\n+  case Op_AddVHF: return new AddVHFNode(n1, n2, vt);\n+  case Op_AddVS:  return new AddVSNode(n1, n2, vt);\n+  case Op_AddVI:  return new AddVINode(n1, n2, vt);\n+  case Op_AddVL:  return new AddVLNode(n1, n2, vt);\n+  case Op_AddVF:  return new AddVFNode(n1, n2, vt);\n+  case Op_AddVD:  return new AddVDNode(n1, n2, vt);\n+\n+  case Op_SubVB:  return new SubVBNode(n1, n2, vt);\n+  case Op_SubVS:  return new SubVSNode(n1, n2, vt);\n+  case Op_SubVI:  return new SubVINode(n1, n2, vt);\n+  case Op_SubVL:  return new SubVLNode(n1, n2, vt);\n+  case Op_SubVHF: return new SubVHFNode(n1, n2, vt);\n+  case Op_SubVF:  return new SubVFNode(n1, n2, vt);\n+  case Op_SubVD:  return new SubVDNode(n1, n2, vt);\n+\n+  case Op_MulVB:  return new MulVBNode(n1, n2, vt);\n+  case Op_MulVS:  return new MulVSNode(n1, n2, vt);\n+  case Op_MulVI:  return new MulVINode(n1, n2, vt);\n+  case Op_MulVL:  return new MulVLNode(n1, n2, vt);\n+  case Op_MulVHF: return new MulVHFNode(n1, n2, vt);\n+  case Op_MulVF:  return new MulVFNode(n1, n2, vt);\n+  case Op_MulVD:  return new MulVDNode(n1, n2, vt);\n+\n+  case Op_DivVHF: return new DivVHFNode(n1, n2, vt);\n+  case Op_DivVF:  return new DivVFNode(n1, n2, vt);\n+  case Op_DivVD:  return new DivVDNode(n1, n2, vt);\n@@ -723,0 +760,3 @@\n+  case Op_MinVHF: return new MinVHFNode(n1, n2, vt);\n+  case Op_MaxVHF: return new MaxVHFNode(n1, n2, vt);\n+\n@@ -1679,0 +1719,4 @@\n+VectorNode* VectorReinterpretNode::make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt) {\n+  return new VectorReinterpretNode(n, dst_vt, src_vt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":72,"deletions":28,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+  static bool is_float16_node(int opc);\n+\n@@ -187,0 +189,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add float\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -305,0 +315,8 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector subtract half float\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -308,1 +326,1 @@\n- public:\n+public:\n@@ -316,1 +334,1 @@\n- public:\n+public:\n@@ -353,0 +371,8 @@\n+\/\/------------------------------MulVFNode--------------------------------------\n+\/\/ Vector multiply half float\n+class MulVHFNode : public VectorNode {\n+public:\n+  MulVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -435,0 +461,8 @@\n+\/\/------------------------------DivVHFNode-------------------------------------\n+\/\/ Vector divide half float\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -438,1 +472,1 @@\n- public:\n+public:\n@@ -446,1 +480,1 @@\n- public:\n+public:\n@@ -478,1 +512,1 @@\n- public:\n+public:\n@@ -483,0 +517,16 @@\n+\/\/------------------------------MinVHFNode------------------------------------\n+\/\/ Vector Min for half floats\n+class MinVHFNode : public VectorNode {\n+public:\n+  MinVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------MaxVHFNode------------------------------------\n+\/\/ Vector Max for half floats\n+class MaxVHFNode : public VectorNode {\n+public:\n+  MaxVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -1555,0 +1605,2 @@\n+\n+  static VectorNode* make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":57,"deletions":5,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1415,0 +1415,1 @@\n+  declare_c2_type(AddHFNode, AddNode)                                     \\\n@@ -1428,0 +1429,2 @@\n+  declare_c2_type(MaxHFNode, MaxFNode)                                    \\\n+  declare_c2_type(MinHFNode, MinFNode)                                    \\\n@@ -1433,0 +1436,2 @@\n+  declare_c2_type(ReinterpretS2HFNode, Node)                              \\\n+  declare_c2_type(ReinterpretHF2SNode, Node)                              \\\n@@ -1529,0 +1534,1 @@\n+  declare_c2_type(DivHFNode, DivFNode)                                    \\\n@@ -1625,0 +1631,1 @@\n+  declare_c2_type(MulHFNode, MulFNode)                                    \\\n@@ -1646,0 +1653,1 @@\n+  declare_c2_type(SubHFNode, SubFNode)                                    \\\n@@ -1691,0 +1699,1 @@\n+  declare_c2_type(AddVHFNode, VectorNode)                                 \\\n@@ -1698,0 +1707,1 @@\n+  declare_c2_type(SubVHFNode, VectorNode)                                 \\\n@@ -1706,0 +1716,1 @@\n+  declare_c2_type(MulVHFNode, VectorNode)                                 \\\n@@ -1722,0 +1733,1 @@\n+  declare_c2_type(DivVHFNode, VectorNode)                                 \\\n@@ -1748,0 +1760,2 @@\n+  declare_c2_type(MaxVHFNode, VectorNode)                                 \\\n+  declare_c2_type(MinVHFNode, VectorNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1033,1 +1033,0 @@\n-        int bin16ExpBits     = 0x7c00 & bin16arg;\n@@ -1038,1 +1037,1 @@\n-        final int SIGNIF_SHIFT = (FloatConsts.SIGNIFICAND_WIDTH - 11);\n+        final int SIGNIF_SHIFT = (Float.PRECISION - Float16.PRECISION);\n@@ -1042,1 +1041,1 @@\n-        \/\/ Extract binary16 exponent, remove its bias, add in the bias\n+        \/\/ Get unbiased binary16 exponent, add in the bias\n@@ -1046,1 +1045,1 @@\n-        int bin16Exp = (bin16ExpBits >> 10) - 15;\n+        int bin16Exp = Float16.getExponent0(floatBinary16);\n@@ -1064,1 +1063,1 @@\n-            << (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+            << (PRECISION - 1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,1212 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.constant.Constable;\n+import java.lang.constant.ConstantDesc;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n+import jdk.internal.math.FloatConsts;\n+import jdk.internal.math.FloatingDecimal;\n+import jdk.internal.math.FloatToDecimal;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+import static java.lang.Float.float16ToFloat;\n+import static java.lang.Float.floatToFloat16;\n+\n+\/**\n+ * The {@code Float16} is a primitive value class holding 16-bit data\n+ * in IEEE 754 binary16 format.\n+ *\n+ * <p>Binary16 Format:<br>\n+ *   S EEEEE  MMMMMMMMMM<br>\n+ *   Sign        - 1 bit<br>\n+ *   Exponent    - 5 bits<br>\n+ *   Significand - 10 bits (does not include the <i>implicit bit<\/i> inferred from the exponent, see {@link #PRECISION})<br>\n+ *\n+ * <p>This is a <a href=\"https:\/\/openjdk.org\/jeps\/401\">primitive value class<\/a> and its objects are\n+ * identity-less non-nullable value objects.\n+ *\n+ * <p>Unless otherwise specified, the methods in this class use a\n+ * <em>rounding policy<\/em> (JLS {@jls 15.4}) of {@linkplain\n+ * java.math.RoundingMode#HALF_EVEN round to nearest}.\n+ *\n+ * @apiNote\n+ * The methods in this class generally have analogous methods in\n+ * either {@link Float}\/{@link Double} or {@link Math}\/{@link\n+ * StrictMath}. Unless otherwise specified, the handling of special\n+ * floating-point values such as {@linkplain #isNaN(Float16) NaN}\n+ * values, {@linkplain #isInfinite(Float16) infinities}, and signed\n+ * zeros of methods in this class is wholly analogous to the handling\n+ * of equivalent cases by methods in {@code Float}, {@code Double},\n+ * {@code Math}, etc.\n+ *\n+ * @author Jatin Bhateja\n+ * @since 20.00\n+ *\/\n+\n+\/\/ Currently Float16 is a value based class but in future will be aligned with\n+\/\/ Enhanced Primitive Boxes described by JEP-402 (https:\/\/openjdk.org\/jeps\/402)\n+@jdk.internal.MigratedValueClass\n+@jdk.internal.ValueBased\n+@SuppressWarnings(\"serial\")\n+public final class Float16\n+    extends Number\n+    implements Comparable<Float16> {\n+    private final short value;\n+    private static final long serialVersionUID = 16; \/\/ Not needed for a value class?\n+\n+    \/\/ Functionality for future consideration:\n+    \/\/ float16ToShortBits that normalizes NaNs, c.f. floatToIntBits vs floatToRawIntBits\n+    \/\/ copysign\n+    \/\/ scalb\n+    \/\/ nextUp \/ nextDown\n+    \/\/ IEEEremainder \/ remainder operator remainder\n+    \/\/ signum\n+    \/\/ valueOf(BigDecimal) -- main implementation could be package private in BigDecimal\n+\n+   \/**\n+    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n+    * encoded {@code short} value.\n+    *\n+    * @param  bits a short value.\n+    *\/\n+    private Float16 (short bits ) {\n+        this.value = bits;\n+    }\n+\n+    \/\/ Do *not* define any public constructors\n+\n+    \/**\n+     * A constant holding the positive infinity of type {@code\n+     * Float16}.\n+     *\n+     * @see Float#POSITIVE_INFINITY\n+     * @see Double#POSITIVE_INFINITY\n+     *\/\n+    public static final Float16 POSITIVE_INFINITY = valueOf(Float.POSITIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding the negative infinity of type {@code\n+     * Float16}.\n+     *\n+     * @see Float#NEGATIVE_INFINITY\n+     * @see Double#NEGATIVE_INFINITY\n+     *\/\n+    public static final Float16 NEGATIVE_INFINITY = valueOf(Float.NEGATIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding a Not-a-Number (NaN) value of type {@code\n+     * Float16}.\n+     *\n+     * @see Float#NaN\n+     * @see Double#NaN\n+     *\/\n+    public static final Float16 NaN = valueOf(Float.NaN);\n+\n+    \/**\n+     * A constant holding the largest positive finite value of type\n+     * {@code Float16},\n+     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>, numerically equal to 65504.0.\n+     *\n+     * @see Float#MAX_VALUE\n+     * @see Double#MAX_VALUE\n+     *\/\n+    public static final Float16 MAX_VALUE = valueOf(0x1.ffcp15f);\n+\n+    \/**\n+     * A constant holding the smallest positive normal value of type\n+     * {@code Float16}, 2<sup>-14<\/sup>.\n+     *\n+     * @see Float#MIN_NORMAL\n+     * @see Double#MIN_NORMAL\n+     *\/\n+    public static final Float16 MIN_NORMAL = valueOf(0x1.0p-14f);\n+\n+    \/**\n+     * A constant holding the smallest positive nonzero value of type\n+     * {@code Float16}, 2<sup>-24<\/sup>.\n+     *\n+     * @see Float#MIN_VALUE\n+     * @see Double#MIN_VALUE\n+     *\/\n+    public static final Float16 MIN_VALUE = valueOf(0x1.0p-24f);\n+\n+    \/**\n+     * The number of bits used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\n+     * @see Float#SIZE\n+     * @see Double#SIZE\n+     *\/\n+    public static final int SIZE = 16;\n+\n+    \/**\n+     * The number of bits in the significand of a {@code Float16}\n+     * value, {@value}.  This corresponds to parameter N in section\n+     * {@jls 4.2.3} of <cite>The Java Language Specification<\/cite>.\n+     *\n+     * @see Float#PRECISION\n+     * @see Double#PRECISION\n+     *\/\n+    public static final int PRECISION = 11;\n+\n+    \/**\n+     * Maximum exponent a finite {@code Float16} variable may have,\n+     * {@value}. It is equal to the value returned by {@code\n+     * Float16.getExponent(Float16.MAX_VALUE)}.\n+     *\n+     * @see Float#MAX_EXPONENT\n+     * @see Double#MAX_EXPONENT\n+     *\/\n+    public static final int MAX_EXPONENT = (1 << (SIZE - PRECISION - 1)) - 1; \/\/ 15\n+\n+    \/**\n+     * Minimum exponent a normalized {@code Float16} variable may\n+     * have, {@value}.  It is equal to the value returned by {@code\n+     * Float16.getExponent(Float16.MIN_NORMAL)}.\n+     *\n+     * @see Float#MIN_EXPONENT\n+     * @see Double#MIN_EXPONENT\n+     *\/\n+    public static final int MIN_EXPONENT = 1 - MAX_EXPONENT; \/\/ -14\n+\n+    \/**\n+     * The number of bytes used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\n+     * @see Float#BYTES\n+     * @see Double#BYTES\n+     *\/\n+    public static final int BYTES = SIZE \/ Byte.SIZE;\n+\n+    \/**\n+     * Returns a string representation of the {@code Float16}\n+     * argument.\n+     *\n+     * @implSpec\n+     * The current implementation acts as this {@code Float16} were\n+     * {@linkplain #floatValue() converted} to {@code float} and then\n+     * the string for that {@code float} returned. This behavior is\n+     * expected to change to accommodate the precision of {@code\n+     * Float16}.\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a string representation of the argument.\n+     * @see java.lang.Float#toString(float)\n+     *\/\n+    public static String toString(Float16 f16) {\n+        \/\/ FIXME -- update for Float16 precision\n+        return FloatToDecimal.toString(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string representation of the {@code\n+     * Float16} argument.\n+     *\n+     * The behavior of this class is analogous to {@link\n+     * Float#toHexString(float)} except that an exponent value of\n+     * {@code \"p14\"} is used for subnormal {@code Float16} values.\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a hex string representation of the argument.\n+     *\n+     * @see Float#toHexString(float)\n+     * @see Double#toHexString(double)\n+     *\/\n+    public static String toHexString(Float16 f16) {\n+        float f = f16.floatValue();\n+        if (Math.abs(f) < float16ToFloat(MIN_NORMAL.value)\n+            &&  f != 0.0f ) {\/\/ Float16 subnormal\n+            \/\/ Adjust exponent to create subnormal double, then\n+            \/\/ replace subnormal double exponent with subnormal Float16\n+            \/\/ exponent\n+            String s = Double.toHexString(Math.scalb((double)f,\n+                                                     \/* -1022+14 *\/\n+                                                     Double.MIN_EXPONENT-\n+                                                     MIN_EXPONENT));\n+            return s.replaceFirst(\"p-1022$\", \"p-14\");\n+        } else {\/\/ double string will be the same as Float16 string\n+            return Double.toHexString(f);\n+        }\n+    }\n+\n+    \/\/ -----------------------\n+\n+   \/**\n+    * {@return the value of an {@code int} converted to {@code\n+    * Float16}}\n+    *\n+    * @param  value an {@code int} value.\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n+    *\/\n+    public static Float16 valueOf(int value) {\n+        \/\/ int -> double conversion is exact\n+        return valueOf((double)value);\n+    }\n+\n+   \/**\n+    * {@return the value of a {@code long} converted to {@code Float16}}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  value a {@code long} value.\n+    *\/\n+    public static Float16 valueOf(long value) {\n+        if (value <= -65_520L) {  \/\/ -(Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2)\n+            return NEGATIVE_INFINITY;\n+        } else {\n+            if (value >= 65_520L) {  \/\/ Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2\n+                return POSITIVE_INFINITY;\n+            }\n+            \/\/ Remaining range of long, the integers in approx. +\/-\n+            \/\/ 2^16, all fit in a float so the correct conversion can\n+            \/\/ be done via an intermediate float conversion.\n+            return valueOf((float)value);\n+        }\n+    }\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code float}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  f a {@code float}\n+    *\/\n+    public static Float16 valueOf(float f) {\n+        return new Float16(Float.floatToFloat16(f));\n+    }\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code double}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  d a {@code double}\n+    *\/\n+    public static Float16 valueOf(double d) {\n+        long doppel = Double.doubleToRawLongBits(d);\n+\n+        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> 48);\n+\n+        if (Double.isNaN(d)) {\n+            \/\/ Have existing float code handle any attempts to\n+            \/\/ preserve NaN bits.\n+            return valueOf((float)d);\n+        }\n+\n+        double abs_d = Math.abs(d);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_d >= (0x1.ffcp15 + 0x0.002p15) ) {\n+             \/\/ correctly signed infinity\n+            return new Float16((short)(sign_bit | 0x7c00));\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_d <= 0x1.0p-24d * 0.5d) { \/\/ Covers double zeros and subnormals.\n+            return new Float16(sign_bit); \/\/ Positive or negative zero\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of binary16\n+        \/\/ (when rounding is done, could still round up)\n+        int exp = Math.getExponent(d);\n+        assert -25 <= exp && exp <= 15;\n+\n+        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+        \/\/ the difference expdelta = E_min - exp.  This is the excess\n+        \/\/ shift value, in addition to 42, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in d must be involved as well.\n+        int expdelta = 0;\n+        long msb = 0x0000_0000_0000_0000L;\n+        if (exp < -14) {\n+            expdelta = -14 - exp; \/\/ FIXME?\n+            exp = -15;\n+            msb = 0x0010_0000_0000_0000L; \/\/ should be 0x0020_... ?\n+        }\n+        long f_signif_bits = doppel & 0x000f_ffff_ffff_ffffL | msb;\n+\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (42 + expdelta));\n+\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+        long lsb    = f_signif_bits & (1L << 42 + expdelta);\n+        long round  = f_signif_bits & (1L << 41 + expdelta);\n+        long sticky = f_signif_bits & ((1L << 41 + expdelta) - 1);\n+\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the significand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n+\n+        return new Float16((short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) ));\n+    }\n+\n+    \/**\n+     * Returns a {@code Float16} holding the floating-point value\n+     * represented by the argument string.\n+     *\n+     * @implSpec\n+     * The current implementation acts as if the string were\n+     * {@linkplain Double#parseDouble(String) parsed} as a {@code\n+     * double} and then {@linkplain #valueOf(double) converted} to\n+     * {@code Float16}. This behavior is expected to change to\n+     * accommodate the precision of {@code Float16}.\n+     *\n+     * @param  s the string to be parsed.\n+     * @return the {@code Float16} value represented by the string\n+     *         argument.\n+     * @throws NullPointerException  if the string is null\n+     * @throws NumberFormatException if the string does not contain a\n+     *               parsable {@code Float16}.\n+     * @see    java.lang.Float#valueOf(String)\n+     *\/\n+    public static Float16 valueOf(String s) throws NumberFormatException {\n+        \/\/ TOOD: adjust precision of parsing if needed\n+        return valueOf(Double.parseDouble(s));\n+    }\n+\n+    \/**\n+     * {@return a {@link Float16} value rounded from the {@link BigDecimal}\n+     * argument using the round to nearest rounding policy}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @param  v a {@link BigDecimal}\n+     *\/\n+    public static Float16 valueOf(BigDecimal v) {\n+        return v.float16Value();\n+    }\n+\n+    \/\/    \/**\n+    \/\/     * ...\n+    \/\/     * @see BigDecimal#floatValue()\n+    \/\/     * @see BigDecimal#doubleValue()\n+    \/\/     *\/\n+    \/\/    public static Float16 valueOf(BigDecimal bd)\n+\n+\n+    \/**\n+     * Returns {@code true} if the specified number is a\n+     * Not-a-Number (NaN) value, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isNaN operation defined in IEEE\n+     * 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is NaN;\n+     *          {@code false} otherwise.\n+     *\n+     * @see Float#isNaN(float)\n+     * @see Double#isNaN(double)\n+     *\/\n+    public static boolean isNaN(Float16 f16) {\n+        return Float.isNaN(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is infinitely\n+     * large in magnitude, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isInfinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is positive infinity or\n+     *          negative infinity; {@code false} otherwise.\n+     *\n+     * @see Float#isInfinite(float)\n+     * @see Double#isInfinite(double)\n+     *\/\n+    public static boolean isInfinite(Float16 f16) {\n+        return Float.isInfinite(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the argument is a finite floating-point\n+     * value; returns {@code false} otherwise (for NaN and infinity\n+     * arguments).\n+     *\n+     * @apiNote\n+     * This method corresponds to the isFinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param f16 the {@code Float16} value to be tested\n+     * @return {@code true} if the argument is a finite\n+     * floating-point value, {@code false} otherwise.\n+     *\n+     * @see Float#isFinite(float)\n+     * @see Double#isFinite(double)\n+     *\/\n+    public static boolean isFinite(Float16 f16) {\n+        return Float.isFinite(f16.floatValue());\n+     }\n+\n+    \/\/ Skipping for now\n+    \/\/ public boolean isNaN()\n+    \/\/ public boolean isInfinite() {\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code byte} after\n+     * a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public byte byteValue() {\n+        return (byte)floatValue();\n+    }\n+\n+    \/**\n+     * {@return a string representation of this {@code Float16}}\n+     *\n+     * @implSpec\n+     * This method returns the result of {@code Float16.toString(this)}.\n+     *\/\n+    public String toString() {\n+        return toString(this);\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code short}\n+     * after a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public short shortValue() {\n+        return (short)floatValue();\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as an {@code int} after\n+     * a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public int intValue() {\n+        return (int)floatValue();\n+    }\n+\n+    \/**\n+     * {@return value of this {@code Float16} as a {@code long} after a\n+     * narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public long longValue() {\n+        return (long)floatValue();\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code float}\n+     * after a widening primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @jls 5.1.2 Widening Primitive Conversion\n+     *\/\n+    @Override\n+    public float floatValue() {\n+        return float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code double}\n+     * after a widening primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @jls 5.1.2 Widening Primitive Conversion\n+     *\/\n+    @Override\n+    public double doubleValue() {\n+        return (double)floatValue();\n+    }\n+\n+    \/\/ Skipping for now:\n+    \/\/ public int hashCode()\n+    \/\/ public static int hashCode(Float16 value)\n+    \/\/ public boolean equals(Object obj)\n+\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     *\n+     * @param   f16   a {@code Float16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n+     *\/\n+    public static short float16ToRawShortBits(Float16 f16) {\n+        return f16.value;\n+    }\n+\n+    \/**\n+     * Returns the {@code Float16} value corresponding to a given bit\n+     * representation.\n+     *\n+     * @param   bits   any {@code short} integer.\n+     * @return  the {@code Float16} floating-point value with the same\n+     *          bit pattern.\n+     *\n+     * @see Float#intBitsToFloat(int)\n+     * @see Double#longBitsToDouble(long)\n+     *\/\n+    public static Float16 shortBitsToFloat16(short bits) {\n+        return new Float16(bits);\n+    }\n+\n+    \/**\n+     * Compares two {@code Float16} objects numerically.\n+     *\n+     * This method imposes a total order on {@code Float16} objects\n+     * with two differences compared to the incomplete order defined by\n+     * the Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code float} and {@code double} values.\n+     *\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Float16.NaN} to be equal to itself and greater than all\n+     *          other {@code Float16} values (including {@code\n+     *          Float16.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero\n+     *      to be greater than negative zero.\n+     * <\/ul>\n+     *\n+     * @param   anotherFloat16   the {@code Float16} to be compared.\n+     * @return  the value {@code 0} if {@code anotherFloat16} is\n+     *          numerically equal to this {@code Float16}; a value\n+     *          less than {@code 0} if this {@code Float16}\n+     *          is numerically less than {@code anotherFloat16};\n+     *          and a value greater than {@code 0} if this\n+     *          {@code Float16} is numerically greater than\n+     *          {@code anotherFloat16}.\n+     *\n+     * @see Float#compareTo(Float)\n+     * @see Double#compareTo(Double)\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+     *\/\n+    @Override\n+    public int compareTo(Float16 anotherFloat16) {\n+        return compare(this, anotherFloat16);\n+    }\n+\n+    \/**\n+     * Compares the two specified {@code Float16} values.\n+     *\n+     * @param   f1        the first {@code Float16} to compare\n+     * @param   f2        the second {@code Float16} to compare\n+     * @return  the value {@code 0} if {@code f1} is\n+     *          numerically equal to {@code f2}; a value less than\n+     *          {@code 0} if {@code f1} is numerically less than\n+     *          {@code f2}; and a value greater than {@code 0}\n+     *          if {@code f1} is numerically greater than\n+     *          {@code f2}.\n+     *\n+     * @see Float#compare(float, float)\n+     * @see Double#compare(double, double)\n+     *\/\n+    public static int compare(Float16 f1, Float16 f2) {\n+        return Float.compare(f1.floatValue(), f2.floatValue());\n+    }\n+\n+    \/**\n+     * Returns the larger of two {@code Float16} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the maximum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#max(float, float)\n+     * @see Math#max(double, double)\n+     *\/\n+    @IntrinsicCandidate\n+    public static Float16 max(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.max(a.floatValue(),\n+                                                          b.floatValue() )));\n+    }\n+\n+    \/**\n+     * Returns the smaller of two {@code Float16} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the minimum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#min(float, float)\n+     * @see Math#min(double, double)\n+     *\/\n+    @IntrinsicCandidate\n+    public static Float16 min(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.min(a.floatValue(),\n+                                                          b.floatValue()) ));\n+    }\n+\n+    \/\/ Skipping for now\n+    \/\/ public Optional<Float16> describeConstable()\n+    \/\/ public Float16 resolveConstantDesc(MethodHandles.Lookup lookup)\n+\n+    \/*\n+     * Note: for the basic arithmetic operations {+, -, *, \/} and\n+     * square root, among binary interchange formats (binary16,\n+     * binary32 a.k.a. float, binary64 a.k.a double, etc.) the \"2p + 2\"\n+     * property holds. That is, if one format has p bits of precision,\n+     * if the next larger format has at least 2p + 2 bits of\n+     * precision, arithmetic on the smaller format can be implemented by:\n+     *\n+     * 1) converting each argument to the wider format\n+     * 2) performing the operation in the wider format\n+     * 3) converting the result from 2) to the narrower format\n+     *\n+     * For example, this property hold between the formats used for the\n+     * float and double types. Therefore, the following is a valid\n+     * implementation of a float addition:\n+     *\n+     * float add(float addend, float augend) {\n+     *     return (float)((double)addend + (double)augend);\n+     * }\n+     *\n+     * The same property holds between the float16 format and\n+     * float. Therefore, the software implementations of Float16 {+,\n+     * -, *, \/} and square root below use the technique of widening\n+     * the Float16 arguments to float, performing the operation in\n+     * float arithmetic, and then rounding the float result to\n+     * Float16.\n+     *\n+     * For discussion and derivation of this property see:\n+     *\n+     * \"When Is Double Rounding Innocuous?\" by Samuel Figueroa\n+     * ACM SIGNUM Newsletter, Volume 30 Issue 3, pp 21-26\n+     * https:\/\/dl.acm.org\/doi\/pdf\/10.1145\/221332.221334\n+     *\n+     * Figueroa's write-up refers to lecture notes by W. Kahan. Those\n+     * lectures notes are assumed to be these ones by Kahan and\n+     * others:\n+     *\n+     * https:\/\/www.arithmazium.org\/classroom\/lib\/Lecture_08_notes_slides.pdf\n+     * https:\/\/www.arithmazium.org\/classroom\/lib\/Lecture_09_notes_slides.pdf\n+     *\/\n+\n+    \/**\n+     * Adds two {@code Float16} values together as per the {@code +}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code +} operator for\n+     * floating-point addition (JLS {@jls 15.18.2}).\n+     *\n+     * @apiNote This method corresponds to the addition operation\n+     * defined in IEEE 754.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     *\/\n+    @IntrinsicCandidate\n+    public static Float16 add(Float16 addend, Float16 augend) {\n+        return valueOf(addend.floatValue() + augend.floatValue());\n+    }\n+\n+    \/**\n+     * Subtracts two {@code Float16} values as per the {@code -}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code -} operator for\n+     * floating-point subtraction (JLS {@jls 15.18.2}).\n+     *\n+     * @apiNote This method corresponds to the subtraction operation\n+     * defined in IEEE 754.\n+     *\n+     * @param minuend the first operand\n+     * @param  subtrahend the second operand\n+     * @return the difference of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     *\/\n+    @IntrinsicCandidate\n+    public static Float16 subtract(Float16 minuend, Float16 subtrahend) {\n+        return valueOf(minuend.floatValue() - subtrahend.floatValue());\n+    }\n+\n+    \/**\n+     * Multiplies two {@code Float16} values as per the {@code *}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code *} operator for\n+     * floating-point multiplication (JLS {@jls 15.17.1}).\n+     *\n+     * @apiNote This method corresponds to the multiplication\n+     * operation defined in IEEE 754.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     *\/\n+    @IntrinsicCandidate\n+    public static Float16 multiply(Float16 multiplier, Float16 multiplicand) {\n+        return valueOf(multiplier.floatValue() * multiplicand.floatValue());\n+    }\n+\n+    \/**\n+     * Divides two {@code Float16} values as per the {@code \/}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code \/} operator for\n+     * floating-point division (JLS {@jls 15.17.2}).\n+     *\n+     * @apiNote This method corresponds to the division\n+     * operation defined in IEEE 754.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     *\/\n+    @IntrinsicCandidate\n+    public static Float16 divide(Float16 dividend, Float16 divisor) {\n+        return valueOf(dividend.floatValue() \/ divisor.floatValue());\n+    }\n+\n+    \/**\n+     * {@return the square root of the operand} The square root is\n+     * computed using the round to nearest rounding policy.\n+     *\n+     * The handling of zeros, NaN, infinities, and negative arguments\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#sqrt(double)}.\n+     *\n+     * @apiNote\n+     * This method corresponds to the squareRoot operation defined in\n+     * IEEE 754.\n+     *\n+     * @param radicand the argument to have its square root taken\n+     *\n+     * @see Math#sqrt(double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 sqrt(Float16 radicand) {\n+        \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n+        \/\/ for preserving the correct final value. The conversion\n+        \/\/ Float16 -> double preserves the exact numerical value. The\n+        \/\/ of the double -> Float16 conversion also benefits from the\n+        \/\/ 2p+2 property of IEEE 754 arithmetic.\n+        return valueOf(Math.sqrt(radicand.doubleValue()));\n+    }\n+\n+    \/**\n+     * Returns the fused multiply add of the three arguments; that is,\n+     * returns the exact product of the first two arguments summed\n+     * with the third argument and then rounded once to the nearest\n+     * {@code Float16}.\n+     *\n+     * The handling of zeros, NaN, infinities, and other special cases\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#fma(float, float, float)}.\n+     *\n+     * @apiNote This method corresponds to the fusedMultiplyAdd\n+     * operation defined in IEEE 754.\n+     *\n+     * @param a a value\n+     * @param b a value\n+     * @param c a value\n+     *\n+     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n+     * computed, as if with unlimited range and precision, and rounded\n+     * once to the nearest {@code Float16} value\n+     *\n+     * @see Math#fma(float, float, float)\n+     * @see Math#fma(double, double, double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 fma(Float16 a, Float16 b, Float16 c) {\n+        \/*\n+         * The double format has sufficient precision that a Float16\n+         * fma can be computed by doing the arithmetic in double, with\n+         * one rounding error for the sum, and then a second rounding\n+         * error to round the product-sum to Float16. In pseudocode,\n+         * this method is equivalent to the following code, assuming\n+         * casting was defined between Float16 and double:\n+         *\n+         * double product = (double)a * (double)b;  \/\/ Always exact\n+         * double productSum = product + (double)c;\n+         * return (Float16)produdctSum;\n+         *\n+         * (Note that a similar relationship does *not* hold between\n+         * the double format and computing a float fma.)\n+         *\n+         * Below is a sketch of the proof that simple double\n+         * arithmetic can be used to implement a correctly rounded\n+         * Float16 fma.\n+         *\n+         * ----------------------\n+         *\n+         * As preliminaries, the handling of NaN and Infinity\n+         * arguments falls out as a consequence of general operation\n+         * of non-finite values by double * and +. Any NaN argument to\n+         * fma will lead to a NaN result, infinities will propagate or\n+         * get turned into NaN as appropriate, etc.\n+         *\n+         * One or more zero arguments are also handled correctly,\n+         * including the propagation of the sign of zero if all three\n+         * arguments are zero.\n+         *\n+         * The double format has 53 logical bits of precision and its\n+         * exponent range goes from -1022 to 1023. The Float16 format\n+         * has 11 bits of logical precision and its exponent range\n+         * goes from -14 to 15. Therefore, the individual powers of 2\n+         * representable in the Float16 format range from the\n+         * subnormal 2^(-24), MIN_VALUE, to 2^15, the leading bit\n+         * position of MAX_VALUE.\n+         *\n+         * In cases where the numerical value of (a * b) + c is\n+         * computed exactly in a double, after a single rounding to\n+         * Float16, the result is necessarily correct since the one\n+         * double -> Float16 conversion is the only source of\n+         * numerical error. The operation as implemented in those\n+         * cases would be equivalent to rounding the infinitely precise\n+         * value to the result format, etc.\n+         *\n+         * However, for some inputs, the intermediate product-sum will\n+         * *not* be exact and additional analysis is needed to justify\n+         * not having any corrective computation to compensate for\n+         * intermediate rounding errors.\n+         *\n+         * The following analysis will rely on the range of bit\n+         * positions representable in the intermediate\n+         * product-sum.\n+         *\n+         * For the product a*b of Float16 inputs, the range of\n+         * exponents for nonzero finite results goes from 2^(-48)\n+         * (from MIN_VALUE squared) to 2^31 (from the exact value of\n+         * MAX_VALUE squared). This full range of exponent positions,\n+         * (31 -(-48) + 1 ) = 80 exceeds the precision of\n+         * double. However, only the product a*b can exceed the\n+         * exponent range of Float16. Therefore, there are three main\n+         * cases to consider:\n+         *\n+         * 1) Large exponent product, exponent > Float16.MAX_EXPONENT\n+         *\n+         * The magnitude of the overflow threshold for Float16 is:\n+         *\n+         * MAX_VALUE + 1\/2 * ulp(MAX_VALUE) =  0x1.ffcp15 + 0x0.002p15 = 0x1.ffep15\n+         *\n+         * Therefore, for any product greater than or equal in\n+         * magnitude to (0x1.ffep15 + MAX_VALUE) = 0x1.ffdp16, the\n+         * final fma result will certainly overflow to infinity (under\n+         * round to nearest) since adding in c = -MAX_VALUE will still\n+         * be at or above the overflow threshold.\n+         *\n+         * If the exponent of the product is 15 or 16, the smallest\n+         * subnormal Float16 is 2^-24 and the ~40 bit wide range bit\n+         * positions would fit in a single double exactly.\n+         *\n+         * 2) Exponent of product is within the range of _normal_\n+         * Float16 values; Float16.MIN_EXPONENT <=  exponent <= Float16.MAX_EXPONENT\n+         *\n+         * The exact product has at most 22 contiguous bits in its\n+         * logical significand. The third number being added in has at\n+         * most 11 contiguous bits in its significand and the lowest\n+         * bit position that could be set is 2^(-24). Therefore, when\n+         * the product has the maximum in-range exponent, 2^15, a\n+         * single double has enough precision to hold down to the\n+         * smallest subnormal bit position, 15 - (-24) + 1 = 40 <\n+         * 53. If the product was large and rounded up, increasing the\n+         * exponent, when the third operand was added, this would\n+         * cause the exponent to go up to 16, which is within the\n+         * range of double, so the product-sum is exact and will be\n+         * correct when rounded to Float16.\n+         *\n+         * 3) Exponent of product is in the range of subnormal values or smaller,\n+         * exponent < Float16.MIN_EXPONENT\n+         *\n+         * The smallest exponent possible in a product is 2^(-48).\n+         * For moderately sized Float16 values added to the product,\n+         * with an exponent of about 4, the sum will not be\n+         * exact. Therefore, an analysis is needed to determine if the\n+         * double-rounding is benign or would lead to a different\n+         * final Float16 result. Double rounding can lead to a\n+         * different result in two cases:\n+         *\n+         * 1) The first rounding from the exact value to the extended\n+         * precision (here `double`) happens to be directed _toward_ 0\n+         * to a value exactly midway between two adjacent working\n+         * precision (here `Float16`) values, followed by a second\n+         * rounding from there which again happens to be directed\n+         * _toward_ 0 to one of these values (the one with lesser\n+         * magnitude).  A single rounding from the exact value to the\n+         * working precision, in contrast, rounds to the value with\n+         * larger magnitude.\n+         *\n+         * 2) Symmetrically, the first rounding to the extended\n+         * precision happens to be directed _away_ from 0 to a value\n+         * exactly midway between two adjacent working precision\n+         * values, followed by a second rounding from there which\n+         * again happens to be directed _away_ from 0 to one of these\n+         * values (the one with larger magnitude).  However, a single\n+         * rounding from the exact value to the working precision\n+         * rounds to the value with lesser magnitude.\n+         *\n+         * If the double rounding occurs in other cases, it is\n+         * innocuous, returning the same value as a single rounding to\n+         * the final format. Therefore, it is sufficient to show that\n+         * the first rounding to double does not occur at the midpoint\n+         * of two adjacent Float16 values:\n+         *\n+         * 1) If a, b and c have the same sign, the sum a*b + c has a\n+         * significand with a large gap of 20 or more 0s between the\n+         * bits of the significand of c to the left (at most 11 bits)\n+         * and those of the product a*b to the right (at most 22\n+         * bits).  The rounding bit for the final working precision of\n+         * `float16` is the leftmost 0 in the gap.\n+         *\n+         *   a) If rounding to `double` is directed toward 0, all the\n+         *   0s in the gap are preserved, thus the `Float16` rounding\n+         *   bit is unaffected and remains 0. This means that the\n+         *   `double` value is _not_ the midpoint of two adjacent\n+         *   `float16` values, so double rounding is harmless.\n+         *\n+         *   b) If rounding to `double` is directed away form 0, the\n+         *   rightmost 0 in the gap might be replaced by a 1, but the\n+         *   others are unaffected, including the `float16` rounding\n+         *   bit. Again, this shows that the `double` value is _not_\n+         *   the midpoint of two adjacent `float16` values, and double\n+         *   rounding is innocuous.\n+         *\n+         * 2) If a, b and c have opposite signs, in the sum a*b + c\n+         * the long gap of 0s above is replaced by a long gap of\n+         * 1s. The `float16` rounding bit is the leftmost 1 in the\n+         * gap, or the second leftmost 1 iff c is a power of 2. In\n+         * both cases, the rounding bit is followed by at least\n+         * another 1.\n+         *\n+         *   a) If rounding to `double` is directed toward 0, the\n+         *   `float16` rounding bit and its follower are preserved and\n+         *   both 1, so the `double` value is _not_ the midpoint of\n+         *   two adjacent `float16` values, and double rounding is\n+         *   harmless.\n+         *\n+         *   b) If rounding to `double` is directed away from 0, the\n+         *   `float16` rounding bit and its follower are either\n+         *   preserved (both 1), or both switch to 0. Either way, the\n+         *   `double` value is again _not_ the midpoint of two\n+         *   adjacent `float16` values, and double rounding is\n+         *   harmless.\n+         *\/\n+\n+        \/\/ product is numerically exact in float before the cast to\n+        \/\/ double; not necessary to widen to double before the\n+        \/\/ multiply.\n+        double product = (double)(a.floatValue() * b.floatValue());\n+        return valueOf(product + c.doubleValue());\n+    }\n+\n+    \/**\n+     * {@return the negation of the argument}\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * opposite sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the opposite sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method corresponds to the negate operation defined in IEEE\n+     * 754.\n+     *\n+     * @param f16 the value to be negated\n+     * @jls 15.15.4 Unary Minus Operator {@code -}\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 negate(Float16 f16) {\n+        \/\/ Negate sign bit only. Per IEEE 754-2019 section 5.5.1,\n+        \/\/ negate is a bit-level operation and not a logical\n+        \/\/ operation. Therefore, in this case do _not_ use the float\n+        \/\/ unary minus as an implementation as that is not guaranteed\n+        \/\/ to flip the sign bit of a NaN.\n+        return shortBitsToFloat16((short)(f16.value ^ (short)0x0000_8000));\n+    }\n+\n+    \/**\n+     * {@return the absolute value of the argument}\n+     *\n+     * The handling of zeros, NaN, and infinities by this method is\n+     * analogous to the handling of those cases by {@link\n+     * Math#abs(float)}.\n+     *\n+     * @param f16 the argument whose absolute value is to be determined\n+     *\n+     * @see Math#abs(float)\n+     * @see Math#abs(double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 abs(Float16 f16) {\n+        \/\/ Zero out sign bit. Per IEE 754-2019 section 5.5.1, abs is a\n+        \/\/ bit-level operation and not a logical operation.\n+        return shortBitsToFloat16((short)(f16.value & (short)0x0000_7FFF));\n+    }\n+\n+    \/**\n+     * Returns the unbiased exponent used in the representation of a\n+     * {@code Float16}.\n+     *\n+     * <ul>\n+     * <li>If the argument is NaN or infinite, then the result is\n+     * {@link Float16#MAX_EXPONENT} + 1.\n+     * <li>If the argument is zero or subnormal, then the result is\n+     * {@link Float16#MIN_EXPONENT} - 1.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method is analogous to the logB operation defined in IEEE\n+     * 754, but returns a different value on subnormal arguments.\n+     *\n+     * @param f16 a {@code Float16} value\n+     * @return the unbiased exponent of the argument\n+     *\n+     * @see Math#getExponent(float)\n+     * @see Math#getExponent(double)\n+     *\/\n+    public static int getExponent(Float16 f16) {\n+        return getExponent0(f16.value);\n+    }\n+\n+    \/**\n+     * From the bitwise representation of a float16, mask out exponent\n+     * bits, shift to the right and then subtract out float16's bias\n+     * adjust, 15, to get true exponent value.\n+     *\/\n+    \/*package*\/ static int getExponent0(short bits) {\n+        \/\/ package private to be usable in java.lang.Float.\n+        int bin16ExpBits     = 0x0000_7c00 & bits;     \/\/ Five exponent bits.\n+        return (bin16ExpBits >> (PRECISION - 1)) - 15;\n+    }\n+\n+    \/**\n+     * Returns the size of an ulp of the argument.  An ulp, unit in\n+     * the last place, of a {@code Float16} value is the positive\n+     * distance between this floating-point value and the {@code\n+     * Float16} value next larger in magnitude.  Note that for non-NaN\n+     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive or negative infinity, then the\n+     * result is positive infinity.\n+     * <li> If the argument is positive or negative zero, then the result is\n+     * {@code Float16.MIN_VALUE}.\n+     * <li> If the argument is &plusmn;{@code Float16.MAX_VALUE}, then\n+     * the result is equal to 2<sup>5<\/sup>, 32.0.\n+     * <\/ul>\n+     *\n+     * @param f16 the floating-point value whose ulp is to be returned\n+     * @return the size of an ulp of the argument\n+     *\/\n+    public static Float16 ulp(Float16 f16) {\n+        int exp = getExponent(f16);\n+\n+        return switch(exp) {\n+        case MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n+        case MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        default -> {\n+            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT;\n+            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+            \/\/ Let float -> float16 conversion handle encoding issues.\n+            yield valueOf(Math.scalb(1.0f, exp - (PRECISION - 1)));\n+        }\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":1212,"deletions":0,"binary":false,"changes":1212,"status":"added"},{"patch":"@@ -337,0 +337,4 @@\n+    private static final int P_F16 = Float16.PRECISION;  \/\/ 11\n+    private static final int Q_MIN_F16 = Float16.MIN_EXPONENT - (P_F16 - 1);  \/\/ -24\n+    private static final int Q_MAX_F16 = Float16.MAX_EXPONENT - (P_F16 - 1);  \/\/ 5\n+\n@@ -3779,0 +3783,92 @@\n+    \/**\n+     * Converts this {@code BigDecimal} to a {@code Float16}.\n+     * This conversion is similar to the\n+     * <i>narrowing primitive conversion<\/i> from {@code double} to\n+     * {@code float} as defined in\n+     * <cite>The Java Language Specification<\/cite>:\n+     * if this {@code BigDecimal} has too great a\n+     * magnitude to represent as a {@code Float16}, it will be\n+     * converted to {@link Float16#NEGATIVE_INFINITY} or {@link\n+     * Float16#POSITIVE_INFINITY} as appropriate.  Note that even when\n+     * the return value is finite, this conversion can lose\n+     * information about the precision of the {@code BigDecimal}\n+     * value.Float16\n+     *\n+     * @return this {@code BigDecimal} converted to a {@code Float16}.\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    public Float16 float16Value() {\n+        \/* For details, see the extensive comments in doubleValue(). *\/\n+        if (intCompact != INFLATED) {\n+            Float16 v = Float16.valueOf(intCompact);\n+            if (scale == 0) {\n+                return v;\n+            }\n+            \/*\n+             * The discussion for the double case also applies here. That is,\n+             * the following test is precise for all long values, but here\n+             * Long.MAX_VALUE is not an issue.\n+             *\/\n+            if (v.longValue() == intCompact) {\n+                if (0 < scale && scale < FLOAT16_10_POW.length) {\n+                    return Float16.divide(v, FLOAT16_10_POW[scale]);\n+                }\n+                if (0 > scale && scale > -FLOAT16_10_POW.length) {\n+                    return Float16.multiply(v, FLOAT16_10_POW[-scale]);\n+                }\n+            }\n+        }\n+        return fullFloat16Value();\n+    }\n+\n+    private Float16 fullFloat16Value() {\n+        if (intCompact == 0) {\n+            return Float16.valueOf(0);\n+        }\n+        BigInteger w = unscaledValue().abs();\n+        long qb = w.bitLength() - (long) Math.ceil(scale * L);\n+        if (qb < Q_MIN_F16 - 2) {  \/\/ qb < -26\n+            return Float16.valueOf(signum() * 0.0f);\n+        }\n+        if (qb > Q_MAX_F16 + P_F16 + 1) {  \/\/ qb > 17\n+            return Float16.valueOf(signum() * Float.POSITIVE_INFINITY);\n+        }\n+        if (scale < 0) {\n+            return Float16.valueOf(signum() * w.multiply(bigTenToThe(-scale)).floatValue());\n+        }\n+        if (scale == 0) {\n+            return Float16.valueOf(signum() * w.floatValue());\n+        }\n+        int ql = (int) qb - (P_F16 + 3);\n+        BigInteger pow10 = bigTenToThe(scale);\n+        BigInteger m, n;\n+        if (ql <= 0) {\n+            m = w.shiftLeft(-ql);\n+            n = pow10;\n+        } else {\n+            m = w;\n+            n = pow10.shiftLeft(ql);\n+        }\n+        BigInteger[] qr = m.divideAndRemainder(n);\n+        \/*\n+         * We have\n+         *      2^12 = 2^{P+1} <= i < 2^{P+5} = 2^16\n+         * Contrary to the double and float cases, here we cannot simply\n+         * declare i as short, because P + 5 < Short.SIZE fails to hold.\n+         * Using int is safe, though.\n+         *\n+         * Further, as Math.scalb(Float16) does not exists, we fall back to\n+         * Math.scalb(double).\n+         *\/\n+        int i = qr[0].intValue();\n+        int sb = qr[1].signum();\n+        int dq = (Integer.SIZE - (P_F16 + 2)) - Integer.numberOfLeadingZeros(i);\n+        int eq = (Q_MIN_F16 - 2) - ql;\n+        if (dq >= eq) {\n+            return Float16.valueOf(signum() * Math.scalb((double) (i | sb), ql));\n+        }\n+        int mask = (1 << eq) - 1;\n+        int j = i >> eq | (Integer.signum(i & mask)) | sb;\n+        return Float16.valueOf(signum() * Math.scalb((double) j, Q_MIN_F16 - 2));\n+    }\n+\n@@ -4153,0 +4249,9 @@\n+    \/**\n+     * Powers of 10 which can be represented exactly in {@code\n+     * Float16}.\n+     *\/\n+    private static final Float16[] FLOAT16_10_POW = {\n+            Float16.valueOf(1), Float16.valueOf(10), Float16.valueOf(100),\n+            Float16.valueOf(1_000), Float16.valueOf(10_000)\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -4396,0 +4396,24 @@\n+    \/**\n+     * Converts this BigInteger to a {@code Float16}.  This\n+     * conversion is similar to the\n+     * <i>narrowing primitive conversion<\/i> from {@code double} to\n+     * {@code float} as defined in\n+     * <cite>The Java Language Specification<\/cite>:\n+     * if this BigInteger has too great a magnitude\n+     * to represent as a {@code Float16}, it will be converted to\n+     * {@link Float16#NEGATIVE_INFINITY} or {@link\n+     * Float16#POSITIVE_INFINITY} as appropriate.  Note that even when\n+     * the return value is finite, this conversion can lose\n+     * information about the precision of the BigInteger value.\n+     *\n+     * @return this BigInteger converted to a {@code Float16}.\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    public Float16 float16Value() {\n+        return signum == 0 || mag.length == 1\n+                ? Float16.valueOf(longValue())  \/\/ might return infinities\n+                : signum > 0\n+                ? Float16.POSITIVE_INFINITY\n+                : Float16.NEGATIVE_INFINITY;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * A null-restricted array is an array whose elements are of value class type and are\n+ * never assigned a {@code null} value during the lifetime of array.\n+ * Element type must also be annotated with {@link ImplicitlyConstructible} annotation\n+ * to ensure default value assignment to array elements, thereby guarantying initialized\n+ * value array by construction.\n+ *\n+ * The initial value of the elements is the zero instance of the given class, and attempts to\n+ * write {@code null} to the element will throw an NullPointerException.\n+ * <p>\n+ * The HotSpot VM uses this annotation to enable flat runtime layout of an array that would\n+ * otherwise be impossible.\n+ * <p>\n+ * Because these behaviors are not specified by Java SE, this annotation should only be used\n+ * by internal JDK classes for experimental purposes and should not affect user-observable\n+ * outcomes.\n+ *\/\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface NullRestrictedArray {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/NullRestrictedArray.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,2 @@\n+        FPHP,\n+        ASIMDHP\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+        AVX512_FP16,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -19,2 +19,2 @@\n-        0xe03f, 0xe10f, 0xe1ff, 0xf801, 0xfc00, 0xfc07,\n-        0xff03, 0xfffe]\n+        0xe03f, 0xe1ff, 0xf801, 0xfc00, 0xfc07, 0xff03,\n+        0xfffe]\n@@ -1050,1 +1050,1 @@\n-        elif (self._name.endswith(\"s\") | self._name.endswith(\"d\")):\n+        elif (self._name.endswith(\"h\") | self._name.endswith(\"s\") | self._name.endswith(\"d\")):\n@@ -1596,2 +1596,4 @@\n-         [[\"fabds\", \"sss\"], [\"fmuls\", \"sss\"], [\"fdivs\", \"sss\"], [\"fadds\", \"sss\"], [\"fsubs\", \"sss\"],\n-          [\"fabdd\", \"ddd\"], [\"fmuld\", \"ddd\"], [\"fdivd\", \"ddd\"], [\"faddd\", \"ddd\"], [\"fsubd\", \"ddd\"],\n+         [[\"fabdh\", \"hhh\"], [\"fmulh\", \"hhh\"], [\"fdivh\", \"hhh\"], [\"faddh\", \"hhh\"], [\"fsubh\", \"hhh\"],\n+          [\"fmaxh\", \"hhh\"], [\"fminh\", \"hhh\"], [\"fnmulh\", \"hhh\"], [\"fabds\", \"sss\"], [\"fmuls\", \"sss\"],\n+          [\"fdivs\", \"sss\"], [\"fadds\", \"sss\"], [\"fsubs\", \"sss\"], [\"fabdd\", \"ddd\"], [\"fmuld\", \"ddd\"],\n+          [\"fdivd\", \"ddd\"], [\"faddd\", \"ddd\"], [\"fsubd\", \"ddd\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -487,10 +487,18 @@\n-    __ fabds(v29, v15, v3);                            \/\/       fabd    s29, s15, s3\n-    __ fmuls(v11, v12, v15);                           \/\/       fmul    s11, s12, s15\n-    __ fdivs(v30, v30, v17);                           \/\/       fdiv    s30, s30, s17\n-    __ fadds(v19, v20, v15);                           \/\/       fadd    s19, s20, s15\n-    __ fsubs(v15, v9, v21);                            \/\/       fsub    s15, s9, s21\n-    __ fabdd(v2, v9, v27);                             \/\/       fabd    d2, d9, d27\n-    __ fmuld(v7, v29, v30);                            \/\/       fmul    d7, d29, d30\n-    __ fdivd(v17, v1, v2);                             \/\/       fdiv    d17, d1, d2\n-    __ faddd(v6, v10, v3);                             \/\/       fadd    d6, d10, d3\n-    __ fsubd(v24, v11, v7);                            \/\/       fsub    d24, d11, d7\n+    __ fabdh(v29, v15, v3);                            \/\/       fabd    h29, h15, h3\n+    __ fmulh(v11, v12, v15);                           \/\/       fmul    h11, h12, h15\n+    __ fdivh(v30, v30, v17);                           \/\/       fdiv    h30, h30, h17\n+    __ faddh(v19, v20, v15);                           \/\/       fadd    h19, h20, h15\n+    __ fsubh(v15, v9, v21);                            \/\/       fsub    h15, h9, h21\n+    __ fmaxh(v2, v9, v27);                             \/\/       fmax    h2, h9, h27\n+    __ fminh(v7, v29, v30);                            \/\/       fmin    h7, h29, h30\n+    __ fnmulh(v17, v1, v2);                            \/\/       fnmul   h17, h1, h2\n+    __ fabds(v6, v10, v3);                             \/\/       fabd    s6, s10, s3\n+    __ fmuls(v24, v11, v7);                            \/\/       fmul    s24, s11, s7\n+    __ fdivs(v1, v11, v0);                             \/\/       fdiv    s1, s11, s0\n+    __ fadds(v3, v17, v28);                            \/\/       fadd    s3, s17, s28\n+    __ fsubs(v6, v22, v6);                             \/\/       fsub    s6, s22, s6\n+    __ fabdd(v0, v27, v26);                            \/\/       fabd    d0, d27, d26\n+    __ fmuld(v2, v5, v7);                              \/\/       fmul    d2, d5, d7\n+    __ fdivd(v28, v11, v25);                           \/\/       fdiv    d28, d11, d25\n+    __ faddd(v13, v11, v23);                           \/\/       fadd    d13, d11, d23\n+    __ fsubd(v19, v8, v17);                            \/\/       fsub    d19, d8, d17\n@@ -499,8 +507,8 @@\n-    __ fmadds(v1, v11, v0, v3);                        \/\/       fmadd   s1, s11, s0, s3\n-    __ fmsubs(v17, v28, v6, v22);                      \/\/       fmsub   s17, s28, s6, s22\n-    __ fnmadds(v6, v0, v27, v26);                      \/\/       fnmadd  s6, s0, s27, s26\n-    __ fnmadds(v2, v5, v7, v28);                       \/\/       fnmadd  s2, s5, s7, s28\n-    __ fmaddd(v11, v25, v13, v11);                     \/\/       fmadd   d11, d25, d13, d11\n-    __ fmsubd(v23, v19, v8, v17);                      \/\/       fmsub   d23, d19, d8, d17\n-    __ fnmaddd(v21, v25, v20, v19);                    \/\/       fnmadd  d21, d25, d20, d19\n-    __ fnmaddd(v17, v2, v29, v22);                     \/\/       fnmadd  d17, d2, d29, d22\n+    __ fmadds(v21, v25, v20, v19);                     \/\/       fmadd   s21, s25, s20, s19\n+    __ fmsubs(v17, v2, v29, v22);                      \/\/       fmsub   s17, s2, s29, s22\n+    __ fnmadds(v8, v21, v19, v20);                     \/\/       fnmadd  s8, s21, s19, s20\n+    __ fnmadds(v11, v17, v20, v6);                     \/\/       fnmadd  s11, s17, s20, s6\n+    __ fmaddd(v15, v3, v3, v28);                       \/\/       fmadd   d15, d3, d3, d28\n+    __ fmsubd(v3, v27, v14, v14);                      \/\/       fmsub   d3, d27, d14, d14\n+    __ fnmaddd(v10, v12, v11, v17);                    \/\/       fnmadd  d10, d12, d11, d17\n+    __ fnmaddd(v10, v25, v7, v7);                      \/\/       fnmadd  d10, d25, d7, d7\n@@ -509,12 +517,12 @@\n-    __ fmovs(v8, v21);                                 \/\/       fmov    s8, s21\n-    __ fabss(v19, v20);                                \/\/       fabs    s19, s20\n-    __ fnegs(v11, v17);                                \/\/       fneg    s11, s17\n-    __ fsqrts(v20, v6);                                \/\/       fsqrt   s20, s6\n-    __ fcvts(v15, v3);                                 \/\/       fcvt    d15, s3\n-    __ fcvtsh(v3, v28);                                \/\/       fcvt    h3, s28\n-    __ fcvths(v3, v27);                                \/\/       fcvt    s3, h27\n-    __ fmovd(v14, v14);                                \/\/       fmov    d14, d14\n-    __ fabsd(v10, v12);                                \/\/       fabs    d10, d12\n-    __ fnegd(v11, v17);                                \/\/       fneg    d11, d17\n-    __ fsqrtd(v10, v25);                               \/\/       fsqrt   d10, d25\n-    __ fcvtd(v7, v7);                                  \/\/       fcvt    s7, d7\n+    __ fmovs(v14, v28);                                \/\/       fmov    s14, s28\n+    __ fabss(v0, v22);                                 \/\/       fabs    s0, s22\n+    __ fnegs(v0, v12);                                 \/\/       fneg    s0, s12\n+    __ fsqrts(v23, v13);                               \/\/       fsqrt   s23, s13\n+    __ fcvts(v13, v7);                                 \/\/       fcvt    d13, s7\n+    __ fcvtsh(v14, v7);                                \/\/       fcvt    h14, s7\n+    __ fcvths(v8, v20);                                \/\/       fcvt    s8, h20\n+    __ fmovd(v17, v28);                                \/\/       fmov    d17, d28\n+    __ fabsd(v30, v16);                                \/\/       fabs    d30, d16\n+    __ fnegd(v2, v9);                                  \/\/       fneg    d2, d9\n+    __ fsqrtd(v16, v20);                               \/\/       fsqrt   d16, d20\n+    __ fcvtd(v29, v4);                                 \/\/       fcvt    s29, d4\n@@ -523,16 +531,16 @@\n-    __ fcvtzsw(r14, v28);                              \/\/       fcvtzs  w14, s28\n-    __ fcvtzs(r0, v22);                                \/\/       fcvtzs  x0, s22\n-    __ fcvtzdw(r0, v12);                               \/\/       fcvtzs  w0, d12\n-    __ fcvtzd(r23, v13);                               \/\/       fcvtzs  x23, d13\n-    __ scvtfws(v13, r7);                               \/\/       scvtf   s13, w7\n-    __ scvtfs(v14, r7);                                \/\/       scvtf   s14, x7\n-    __ scvtfwd(v8, r20);                               \/\/       scvtf   d8, w20\n-    __ scvtfd(v17, r28);                               \/\/       scvtf   d17, x28\n-    __ fcvtassw(r30, v16);                             \/\/       fcvtas  w30, s16\n-    __ fcvtasd(r2, v9);                                \/\/       fcvtas  x2, d9\n-    __ fcvtmssw(r16, v20);                             \/\/       fcvtms  w16, s20\n-    __ fcvtmsd(r29, v4);                               \/\/       fcvtms  x29, d4\n-    __ fmovs(r1, v26);                                 \/\/       fmov    w1, s26\n-    __ fmovd(r24, v23);                                \/\/       fmov    x24, d23\n-    __ fmovs(v14, r21);                                \/\/       fmov    s14, w21\n-    __ fmovd(v12, r5);                                 \/\/       fmov    d12, x5\n+    __ fcvtzsw(r1, v26);                               \/\/       fcvtzs  w1, s26\n+    __ fcvtzs(r24, v23);                               \/\/       fcvtzs  x24, s23\n+    __ fcvtzdw(r14, v21);                              \/\/       fcvtzs  w14, d21\n+    __ fcvtzd(r12, v5);                                \/\/       fcvtzs  x12, d5\n+    __ scvtfws(v12, r24);                              \/\/       scvtf   s12, w24\n+    __ scvtfs(v24, r29);                               \/\/       scvtf   s24, x29\n+    __ scvtfwd(v27, r21);                              \/\/       scvtf   d27, w21\n+    __ scvtfd(v16, r22);                               \/\/       scvtf   d16, x22\n+    __ fcvtassw(r5, v28);                              \/\/       fcvtas  w5, s28\n+    __ fcvtasd(r22, v17);                              \/\/       fcvtas  x22, d17\n+    __ fcvtmssw(r13, v19);                             \/\/       fcvtms  w13, s19\n+    __ fcvtmsd(r19, v27);                              \/\/       fcvtms  x19, d27\n+    __ fmovs(r17, v6);                                 \/\/       fmov    w17, s6\n+    __ fmovd(r13, v7);                                 \/\/       fmov    x13, d7\n+    __ fmovs(v28, r26);                                \/\/       fmov    s28, w26\n+    __ fmovd(v17, r6);                                 \/\/       fmov    d17, x6\n@@ -541,3 +549,3 @@\n-    __ fcmps(v12, v24);                                \/\/       fcmp    s12, s24\n-    __ fcmpd(v24, v29);                                \/\/       fcmp    d24, d29\n-    __ fcmps(v27, 0.0);                                \/\/       fcmp    s27, #0.0\n+    __ fcmps(v1, v4);                                  \/\/       fcmp    s1, s4\n+    __ fcmpd(v13, v20);                                \/\/       fcmp    d13, d20\n+    __ fcmps(v6, 0.0);                                 \/\/       fcmp    s6, #0.0\n@@ -547,5 +555,5 @@\n-    __ stpw(r22, r5, Address(r28, -48));               \/\/       stp     w22, w5, [x28, #-48]\n-    __ ldpw(r19, r27, Address(r19, 16));               \/\/       ldp     w19, w27, [x19, #16]\n-    __ ldpsw(r28, r26, Address(r7, -32));              \/\/       ldpsw   x28, x26, [x7, #-32]\n-    __ stp(r6, r1, Address(r4, -48));                  \/\/       stp     x6, x1, [x4, #-48]\n-    __ ldp(r26, r23, Address(r21, -80));               \/\/       ldp     x26, x23, [x21, #-80]\n+    __ stpw(r23, r13, Address(r20, 80));               \/\/       stp     w23, w13, [x20, #80]\n+    __ ldpw(r4, r16, Address(r21, 128));               \/\/       ldp     w4, w16, [x21, #128]\n+    __ ldpsw(r26, r14, Address(r20, -128));            \/\/       ldpsw   x26, x14, [x20, #-128]\n+    __ stp(r23, r23, Address(r29, -208));              \/\/       stp     x23, x23, [x29, #-208]\n+    __ ldp(r22, r0, Address(r27, -112));               \/\/       ldp     x22, x0, [x27, #-112]\n@@ -554,5 +562,5 @@\n-    __ stpw(r20, r30, Address(__ pre(r9, -96)));       \/\/       stp     w20, w30, [x9, #-96]!\n-    __ ldpw(r13, r20, Address(__ pre(r26, 16)));       \/\/       ldp     w13, w20, [x26, #16]!\n-    __ ldpsw(r29, r11, Address(__ pre(r13, -80)));     \/\/       ldpsw   x29, x11, [x13, #-80]!\n-    __ stp(r27, r21, Address(__ pre(r5, -48)));        \/\/       stp     x27, x21, [x5, #-48]!\n-    __ ldp(r6, r0, Address(__ pre(r30, 80)));          \/\/       ldp     x6, x0, [x30, #80]!\n+    __ stpw(r26, r17, Address(__ pre(r11, -176)));     \/\/       stp     w26, w17, [x11, #-176]!\n+    __ ldpw(r20, r14, Address(__ pre(r11, -176)));     \/\/       ldp     w20, w14, [x11, #-176]!\n+    __ ldpsw(r0, r12, Address(__ pre(r23, -48)));      \/\/       ldpsw   x0, x12, [x23, #-48]!\n+    __ stp(r23, r23, Address(__ pre(r30, -144)));      \/\/       stp     x23, x23, [x30, #-144]!\n+    __ ldp(r7, r17, Address(__ pre(r8, -256)));        \/\/       ldp     x7, x17, [x8, #-256]!\n@@ -561,5 +569,5 @@\n-    __ stpw(r19, r15, Address(__ post(r16, -208)));    \/\/       stp     w19, w15, [x16], #-208\n-    __ ldpw(r12, r23, Address(__ post(r9, -240)));     \/\/       ldp     w12, w23, [x9], #-240\n-    __ ldpsw(r0, r26, Address(__ post(r15, 32)));      \/\/       ldpsw   x0, x26, [x15], #32\n-    __ stp(r8, r17, Address(__ post(r26, -208)));      \/\/       stp     x8, x17, [x26], #-208\n-    __ ldp(r25, r7, Address(__ post(r2, -176)));       \/\/       ldp     x25, x7, [x2], #-176\n+    __ stpw(r6, r11, Address(__ post(r10, 64)));       \/\/       stp     w6, w11, [x10], #64\n+    __ ldpw(r19, r16, Address(__ post(r1, 64)));       \/\/       ldp     w19, w16, [x1], #64\n+    __ ldpsw(r0, r13, Address(__ post(r20, 128)));     \/\/       ldpsw   x0, x13, [x20], #128\n+    __ stp(r23, r27, Address(__ post(r12, 128)));      \/\/       stp     x23, x27, [x12], #128\n+    __ ldp(r11, r25, Address(__ post(r5, -256)));      \/\/       ldp     x11, x25, [x5], #-256\n@@ -568,4 +576,4 @@\n-    __ stnpw(r19, r17, Address(r1, -208));             \/\/       stnp    w19, w17, [x1, #-208]\n-    __ ldnpw(r0, r13, Address(r22, 128));              \/\/       ldnp    w0, w13, [x22, #128]\n-    __ stnp(r29, r23, Address(r27, 0));                \/\/       stnp    x29, x23, [x27, #0]\n-    __ ldnp(r11, r10, Address(r8, -224));              \/\/       ldnp    x11, x10, [x8, #-224]\n+    __ stnpw(r16, r10, Address(r17, 64));              \/\/       stnp    w16, w10, [x17, #64]\n+    __ ldnpw(r9, r10, Address(r26, -192));             \/\/       ldnp    w9, w10, [x26, #-192]\n+    __ stnp(r19, r12, Address(r24, 128));              \/\/       stnp    x19, x12, [x24, #128]\n+    __ ldnp(r17, r14, Address(r26, -240));             \/\/       ldnp    x17, x14, [x26, #-240]\n@@ -574,22 +582,22 @@\n-    __ ld1(v0, __ T8B, Address(r11));                  \/\/       ld1     {v0.8B}, [x11]\n-    __ ld1(v16, v17, __ T16B, Address(__ post(r26, 32))); \/\/    ld1     {v16.16B, v17.16B}, [x26], 32\n-    __ ld1(v21, v22, v23, __ T1D, Address(__ post(r26, r17))); \/\/       ld1     {v21.1D, v22.1D, v23.1D}, [x26], x17\n-    __ ld1(v26, v27, v28, v29, __ T8H, Address(__ post(r29, 64))); \/\/   ld1     {v26.8H, v27.8H, v28.8H, v29.8H}, [x29], 64\n-    __ ld1r(v21, __ T8B, Address(r6));                 \/\/       ld1r    {v21.8B}, [x6]\n-    __ ld1r(v13, __ T4S, Address(__ post(r29, 4)));    \/\/       ld1r    {v13.4S}, [x29], 4\n-    __ ld1r(v21, __ T1D, Address(__ post(r12, r16)));  \/\/       ld1r    {v21.1D}, [x12], x16\n-    __ ld2(v1, v2, __ T2D, Address(r0));               \/\/       ld2     {v1.2D, v2.2D}, [x0]\n-    __ ld2(v9, v10, __ T4H, Address(__ post(r21, 16))); \/\/      ld2     {v9.4H, v10.4H}, [x21], 16\n-    __ ld2r(v7, v8, __ T16B, Address(r25));            \/\/       ld2r    {v7.16B, v8.16B}, [x25]\n-    __ ld2r(v8, v9, __ T2S, Address(__ post(r9, 8)));  \/\/       ld2r    {v8.2S, v9.2S}, [x9], 8\n-    __ ld2r(v9, v10, __ T2D, Address(__ post(r12, r14))); \/\/    ld2r    {v9.2D, v10.2D}, [x12], x14\n-    __ ld3(v7, v8, v9, __ T4S, Address(__ post(r4, r17))); \/\/   ld3     {v7.4S, v8.4S, v9.4S}, [x4], x17\n-    __ ld3(v23, v24, v25, __ T2S, Address(r17));       \/\/       ld3     {v23.2S, v24.2S, v25.2S}, [x17]\n-    __ ld3r(v3, v4, v5, __ T8H, Address(r22));         \/\/       ld3r    {v3.8H, v4.8H, v5.8H}, [x22]\n-    __ ld3r(v12, v13, v14, __ T4S, Address(__ post(r2, 12))); \/\/        ld3r    {v12.4S, v13.4S, v14.4S}, [x2], 12\n-    __ ld3r(v15, v16, v17, __ T1D, Address(__ post(r10, r12))); \/\/      ld3r    {v15.1D, v16.1D, v17.1D}, [x10], x12\n-    __ ld4(v4, v5, v6, v7, __ T8H, Address(__ post(r2, 64))); \/\/        ld4     {v4.8H, v5.8H, v6.8H, v7.8H}, [x2], 64\n-    __ ld4(v6, v7, v8, v9, __ T8B, Address(__ post(r20, r11))); \/\/      ld4     {v6.8B, v7.8B, v8.8B, v9.8B}, [x20], x11\n-    __ ld4r(v11, v12, v13, v14, __ T8B, Address(r12)); \/\/       ld4r    {v11.8B, v12.8B, v13.8B, v14.8B}, [x12]\n-    __ ld4r(v15, v16, v17, v18, __ T4H, Address(__ post(r17, 8))); \/\/   ld4r    {v15.4H, v16.4H, v17.4H, v18.4H}, [x17], 8\n-    __ ld4r(v14, v15, v16, v17, __ T2S, Address(__ post(r25, r16))); \/\/ ld4r    {v14.2S, v15.2S, v16.2S, v17.2S}, [x25], x16\n+    __ ld1(v17, __ T8B, Address(r16));                 \/\/       ld1     {v17.8B}, [x16]\n+    __ ld1(v30, v31, __ T16B, Address(__ post(r23, 32))); \/\/    ld1     {v30.16B, v31.16B}, [x23], 32\n+    __ ld1(v17, v18, v19, __ T1D, Address(__ post(r8, r20))); \/\/        ld1     {v17.1D, v18.1D, v19.1D}, [x8], x20\n+    __ ld1(v12, v13, v14, v15, __ T8H, Address(__ post(r9, 64))); \/\/    ld1     {v12.8H, v13.8H, v14.8H, v15.8H}, [x9], 64\n+    __ ld1r(v19, __ T8B, Address(r2));                 \/\/       ld1r    {v19.8B}, [x2]\n+    __ ld1r(v21, __ T4S, Address(__ post(r8, 4)));     \/\/       ld1r    {v21.4S}, [x8], 4\n+    __ ld1r(v13, __ T1D, Address(__ post(r4, r17)));   \/\/       ld1r    {v13.1D}, [x4], x17\n+    __ ld2(v28, v29, __ T2D, Address(r3));             \/\/       ld2     {v28.2D, v29.2D}, [x3]\n+    __ ld2(v29, v30, __ T4H, Address(__ post(r29, 16))); \/\/     ld2     {v29.4H, v30.4H}, [x29], 16\n+    __ ld2r(v7, v8, __ T16B, Address(r1));             \/\/       ld2r    {v7.16B, v8.16B}, [x1]\n+    __ ld2r(v17, v18, __ T2S, Address(__ post(r0, 8))); \/\/      ld2r    {v17.2S, v18.2S}, [x0], 8\n+    __ ld2r(v26, v27, __ T2D, Address(__ post(r5, r7))); \/\/     ld2r    {v26.2D, v27.2D}, [x5], x7\n+    __ ld3(v25, v26, v27, __ T4S, Address(__ post(r1, r5))); \/\/ ld3     {v25.4S, v26.4S, v27.4S}, [x1], x5\n+    __ ld3(v22, v23, v24, __ T2S, Address(r2));        \/\/       ld3     {v22.2S, v23.2S, v24.2S}, [x2]\n+    __ ld3r(v13, v14, v15, __ T8H, Address(r27));      \/\/       ld3r    {v13.8H, v14.8H, v15.8H}, [x27]\n+    __ ld3r(v29, v30, v31, __ T4S, Address(__ post(r24, 12))); \/\/       ld3r    {v29.4S, v30.4S, v31.4S}, [x24], 12\n+    __ ld3r(v13, v14, v15, __ T1D, Address(__ post(r15, r21))); \/\/      ld3r    {v13.1D, v14.1D, v15.1D}, [x15], x21\n+    __ ld4(v15, v16, v17, v18, __ T8H, Address(__ post(r14, 64))); \/\/   ld4     {v15.8H, v16.8H, v17.8H, v18.8H}, [x14], 64\n+    __ ld4(v27, v28, v29, v30, __ T8B, Address(__ post(r20, r23))); \/\/  ld4     {v27.8B, v28.8B, v29.8B, v30.8B}, [x20], x23\n+    __ ld4r(v22, v23, v24, v25, __ T8B, Address(r24)); \/\/       ld4r    {v22.8B, v23.8B, v24.8B, v25.8B}, [x24]\n+    __ ld4r(v29, v30, v31, v0, __ T4H, Address(__ post(r30, 8))); \/\/    ld4r    {v29.4H, v30.4H, v31.4H, v0.4H}, [x30], 8\n+    __ ld4r(v28, v29, v30, v31, __ T2S, Address(__ post(r5, r5))); \/\/   ld4r    {v28.2S, v29.2S, v30.2S, v31.2S}, [x5], x5\n@@ -598,26 +606,26 @@\n-    __ addv(v20, __ T8B, v21);                         \/\/       addv    b20, v21.8B\n-    __ addv(v1, __ T16B, v2);                          \/\/       addv    b1, v2.16B\n-    __ addv(v22, __ T4H, v23);                         \/\/       addv    h22, v23.4H\n-    __ addv(v30, __ T8H, v31);                         \/\/       addv    h30, v31.8H\n-    __ addv(v14, __ T4S, v15);                         \/\/       addv    s14, v15.4S\n-    __ smaxv(v2, __ T8B, v3);                          \/\/       smaxv   b2, v3.8B\n-    __ smaxv(v6, __ T16B, v7);                         \/\/       smaxv   b6, v7.16B\n-    __ smaxv(v3, __ T4H, v4);                          \/\/       smaxv   h3, v4.4H\n-    __ smaxv(v7, __ T8H, v8);                          \/\/       smaxv   h7, v8.8H\n-    __ smaxv(v24, __ T4S, v25);                        \/\/       smaxv   s24, v25.4S\n-    __ fmaxv(v0, __ T4S, v1);                          \/\/       fmaxv   s0, v1.4S\n-    __ sminv(v27, __ T8B, v28);                        \/\/       sminv   b27, v28.8B\n-    __ uminv(v29, __ T8B, v30);                        \/\/       uminv   b29, v30.8B\n-    __ sminv(v5, __ T16B, v6);                         \/\/       sminv   b5, v6.16B\n-    __ uminv(v5, __ T16B, v6);                         \/\/       uminv   b5, v6.16B\n-    __ sminv(v29, __ T4H, v30);                        \/\/       sminv   h29, v30.4H\n-    __ uminv(v11, __ T4H, v12);                        \/\/       uminv   h11, v12.4H\n-    __ sminv(v25, __ T8H, v26);                        \/\/       sminv   h25, v26.8H\n-    __ uminv(v0, __ T8H, v1);                          \/\/       uminv   h0, v1.8H\n-    __ sminv(v30, __ T4S, v31);                        \/\/       sminv   s30, v31.4S\n-    __ uminv(v0, __ T4S, v1);                          \/\/       uminv   s0, v1.4S\n-    __ fminv(v17, __ T4S, v18);                        \/\/       fminv   s17, v18.4S\n-    __ fmaxp(v28, v29, __ S);                          \/\/       fmaxp   s28, v29.2S\n-    __ fmaxp(v25, v26, __ D);                          \/\/       fmaxp   d25, v26.2D\n-    __ fminp(v9, v10, __ S);                           \/\/       fminp   s9, v10.2S\n-    __ fminp(v25, v26, __ D);                          \/\/       fminp   d25, v26.2D\n+    __ addv(v25, __ T8B, v26);                         \/\/       addv    b25, v26.8B\n+    __ addv(v9, __ T16B, v10);                         \/\/       addv    b9, v10.16B\n+    __ addv(v25, __ T4H, v26);                         \/\/       addv    h25, v26.4H\n+    __ addv(v12, __ T8H, v13);                         \/\/       addv    h12, v13.8H\n+    __ addv(v15, __ T4S, v16);                         \/\/       addv    s15, v16.4S\n+    __ smaxv(v11, __ T8B, v12);                        \/\/       smaxv   b11, v12.8B\n+    __ smaxv(v10, __ T16B, v11);                       \/\/       smaxv   b10, v11.16B\n+    __ smaxv(v17, __ T4H, v18);                        \/\/       smaxv   h17, v18.4H\n+    __ smaxv(v24, __ T8H, v25);                        \/\/       smaxv   h24, v25.8H\n+    __ smaxv(v21, __ T4S, v22);                        \/\/       smaxv   s21, v22.4S\n+    __ fmaxv(v23, __ T4S, v24);                        \/\/       fmaxv   s23, v24.4S\n+    __ sminv(v0, __ T8B, v1);                          \/\/       sminv   b0, v1.8B\n+    __ uminv(v16, __ T8B, v17);                        \/\/       uminv   b16, v17.8B\n+    __ sminv(v10, __ T16B, v11);                       \/\/       sminv   b10, v11.16B\n+    __ uminv(v6, __ T16B, v7);                         \/\/       uminv   b6, v7.16B\n+    __ sminv(v28, __ T4H, v29);                        \/\/       sminv   h28, v29.4H\n+    __ uminv(v6, __ T4H, v7);                          \/\/       uminv   h6, v7.4H\n+    __ sminv(v5, __ T8H, v6);                          \/\/       sminv   h5, v6.8H\n+    __ uminv(v5, __ T8H, v6);                          \/\/       uminv   h5, v6.8H\n+    __ sminv(v20, __ T4S, v21);                        \/\/       sminv   s20, v21.4S\n+    __ uminv(v17, __ T4S, v18);                        \/\/       uminv   s17, v18.4S\n+    __ fminv(v15, __ T4S, v16);                        \/\/       fminv   s15, v16.4S\n+    __ fmaxp(v17, v18, __ S);                          \/\/       fmaxp   s17, v18.2S\n+    __ fmaxp(v29, v30, __ D);                          \/\/       fmaxp   d29, v30.2D\n+    __ fminp(v26, v27, __ S);                          \/\/       fminp   s26, v27.2S\n+    __ fminp(v28, v29, __ D);                          \/\/       fminp   d28, v29.2D\n@@ -626,15 +634,15 @@\n-    __ fcm(Assembler::GT, v12, __ T2S, v13);           \/\/       fcmgt   v12.2S, v13.2S, #0.0\n-    __ fcm(Assembler::GT, v15, __ T4S, v16);           \/\/       fcmgt   v15.4S, v16.4S, #0.0\n-    __ fcm(Assembler::GT, v11, __ T2D, v12);           \/\/       fcmgt   v11.2D, v12.2D, #0.0\n-    __ fcm(Assembler::GE, v10, __ T2S, v11);           \/\/       fcmge   v10.2S, v11.2S, #0.0\n-    __ fcm(Assembler::GE, v17, __ T4S, v18);           \/\/       fcmge   v17.4S, v18.4S, #0.0\n-    __ fcm(Assembler::GE, v24, __ T2D, v25);           \/\/       fcmge   v24.2D, v25.2D, #0.0\n-    __ fcm(Assembler::EQ, v21, __ T2S, v22);           \/\/       fcmeq   v21.2S, v22.2S, #0.0\n-    __ fcm(Assembler::EQ, v23, __ T4S, v24);           \/\/       fcmeq   v23.4S, v24.4S, #0.0\n-    __ fcm(Assembler::EQ, v0, __ T2D, v1);             \/\/       fcmeq   v0.2D, v1.2D, #0.0\n-    __ fcm(Assembler::LT, v16, __ T2S, v17);           \/\/       fcmlt   v16.2S, v17.2S, #0.0\n-    __ fcm(Assembler::LT, v10, __ T4S, v11);           \/\/       fcmlt   v10.4S, v11.4S, #0.0\n-    __ fcm(Assembler::LT, v6, __ T2D, v7);             \/\/       fcmlt   v6.2D, v7.2D, #0.0\n-    __ fcm(Assembler::LE, v28, __ T2S, v29);           \/\/       fcmle   v28.2S, v29.2S, #0.0\n-    __ fcm(Assembler::LE, v6, __ T4S, v7);             \/\/       fcmle   v6.4S, v7.4S, #0.0\n-    __ fcm(Assembler::LE, v5, __ T2D, v6);             \/\/       fcmle   v5.2D, v6.2D, #0.0\n+    __ fcm(Assembler::GT, v1, __ T2S, v2);             \/\/       fcmgt   v1.2S, v2.2S, #0.0\n+    __ fcm(Assembler::GT, v27, __ T4S, v28);           \/\/       fcmgt   v27.4S, v28.4S, #0.0\n+    __ fcm(Assembler::GT, v0, __ T2D, v1);             \/\/       fcmgt   v0.2D, v1.2D, #0.0\n+    __ fcm(Assembler::GE, v20, __ T2S, v21);           \/\/       fcmge   v20.2S, v21.2S, #0.0\n+    __ fcm(Assembler::GE, v28, __ T4S, v29);           \/\/       fcmge   v28.4S, v29.4S, #0.0\n+    __ fcm(Assembler::GE, v15, __ T2D, v16);           \/\/       fcmge   v15.2D, v16.2D, #0.0\n+    __ fcm(Assembler::EQ, v12, __ T2S, v13);           \/\/       fcmeq   v12.2S, v13.2S, #0.0\n+    __ fcm(Assembler::EQ, v10, __ T4S, v11);           \/\/       fcmeq   v10.4S, v11.4S, #0.0\n+    __ fcm(Assembler::EQ, v28, __ T2D, v29);           \/\/       fcmeq   v28.2D, v29.2D, #0.0\n+    __ fcm(Assembler::LT, v28, __ T2S, v29);           \/\/       fcmlt   v28.2S, v29.2S, #0.0\n+    __ fcm(Assembler::LT, v19, __ T4S, v20);           \/\/       fcmlt   v19.4S, v20.4S, #0.0\n+    __ fcm(Assembler::LT, v22, __ T2D, v23);           \/\/       fcmlt   v22.2D, v23.2D, #0.0\n+    __ fcm(Assembler::LE, v10, __ T2S, v11);           \/\/       fcmle   v10.2S, v11.2S, #0.0\n+    __ fcm(Assembler::LE, v4, __ T4S, v5);             \/\/       fcmle   v4.4S, v5.4S, #0.0\n+    __ fcm(Assembler::LE, v30, __ T2D, v31);           \/\/       fcmle   v30.2D, v31.2D, #0.0\n@@ -643,18 +651,18 @@\n-    __ absr(v5, __ T8B, v6);                           \/\/       abs     v5.8B, v6.8B\n-    __ absr(v20, __ T16B, v21);                        \/\/       abs     v20.16B, v21.16B\n-    __ absr(v17, __ T4H, v18);                         \/\/       abs     v17.4H, v18.4H\n-    __ absr(v15, __ T8H, v16);                         \/\/       abs     v15.8H, v16.8H\n-    __ absr(v17, __ T2S, v18);                         \/\/       abs     v17.2S, v18.2S\n-    __ absr(v29, __ T4S, v30);                         \/\/       abs     v29.4S, v30.4S\n-    __ absr(v26, __ T2D, v27);                         \/\/       abs     v26.2D, v27.2D\n-    __ fabs(v28, __ T2S, v29);                         \/\/       fabs    v28.2S, v29.2S\n-    __ fabs(v1, __ T4S, v2);                           \/\/       fabs    v1.4S, v2.4S\n-    __ fabs(v27, __ T2D, v28);                         \/\/       fabs    v27.2D, v28.2D\n-    __ fneg(v0, __ T2S, v1);                           \/\/       fneg    v0.2S, v1.2S\n-    __ fneg(v20, __ T4S, v21);                         \/\/       fneg    v20.4S, v21.4S\n-    __ fneg(v28, __ T2D, v29);                         \/\/       fneg    v28.2D, v29.2D\n-    __ fsqrt(v15, __ T2S, v16);                        \/\/       fsqrt   v15.2S, v16.2S\n-    __ fsqrt(v12, __ T4S, v13);                        \/\/       fsqrt   v12.4S, v13.4S\n-    __ fsqrt(v10, __ T2D, v11);                        \/\/       fsqrt   v10.2D, v11.2D\n-    __ notr(v28, __ T8B, v29);                         \/\/       not     v28.8B, v29.8B\n-    __ notr(v28, __ T16B, v29);                        \/\/       not     v28.16B, v29.16B\n+    __ absr(v20, __ T8B, v21);                         \/\/       abs     v20.8B, v21.8B\n+    __ absr(v8, __ T16B, v9);                          \/\/       abs     v8.16B, v9.16B\n+    __ absr(v30, __ T4H, v31);                         \/\/       abs     v30.4H, v31.4H\n+    __ absr(v17, __ T8H, v18);                         \/\/       abs     v17.8H, v18.8H\n+    __ absr(v10, __ T2S, v11);                         \/\/       abs     v10.2S, v11.2S\n+    __ absr(v27, __ T4S, v28);                         \/\/       abs     v27.4S, v28.4S\n+    __ absr(v2, __ T2D, v3);                           \/\/       abs     v2.2D, v3.2D\n+    __ fabs(v24, __ T2S, v25);                         \/\/       fabs    v24.2S, v25.2S\n+    __ fabs(v4, __ T4S, v5);                           \/\/       fabs    v4.4S, v5.4S\n+    __ fabs(v3, __ T2D, v4);                           \/\/       fabs    v3.2D, v4.2D\n+    __ fneg(v8, __ T2S, v9);                           \/\/       fneg    v8.2S, v9.2S\n+    __ fneg(v22, __ T4S, v23);                         \/\/       fneg    v22.4S, v23.4S\n+    __ fneg(v17, __ T2D, v18);                         \/\/       fneg    v17.2D, v18.2D\n+    __ fsqrt(v13, __ T2S, v14);                        \/\/       fsqrt   v13.2S, v14.2S\n+    __ fsqrt(v4, __ T4S, v5);                          \/\/       fsqrt   v4.4S, v5.4S\n+    __ fsqrt(v28, __ T2D, v29);                        \/\/       fsqrt   v28.2D, v29.2D\n+    __ notr(v23, __ T8B, v24);                         \/\/       not     v23.8B, v24.8B\n+    __ notr(v21, __ T16B, v22);                        \/\/       not     v21.16B, v22.16B\n@@ -663,19 +671,19 @@\n-    __ andr(v19, __ T8B, v20, v21);                    \/\/       and     v19.8B, v20.8B, v21.8B\n-    __ andr(v22, __ T16B, v23, v24);                   \/\/       and     v22.16B, v23.16B, v24.16B\n-    __ orr(v10, __ T8B, v11, v12);                     \/\/       orr     v10.8B, v11.8B, v12.8B\n-    __ orr(v4, __ T16B, v5, v6);                       \/\/       orr     v4.16B, v5.16B, v6.16B\n-    __ eor(v30, __ T8B, v31, v0);                      \/\/       eor     v30.8B, v31.8B, v0.8B\n-    __ eor(v20, __ T16B, v21, v22);                    \/\/       eor     v20.16B, v21.16B, v22.16B\n-    __ addv(v8, __ T8B, v9, v10);                      \/\/       add     v8.8B, v9.8B, v10.8B\n-    __ addv(v30, __ T16B, v31, v0);                    \/\/       add     v30.16B, v31.16B, v0.16B\n-    __ addv(v17, __ T4H, v18, v19);                    \/\/       add     v17.4H, v18.4H, v19.4H\n-    __ addv(v10, __ T8H, v11, v12);                    \/\/       add     v10.8H, v11.8H, v12.8H\n-    __ addv(v27, __ T2S, v28, v29);                    \/\/       add     v27.2S, v28.2S, v29.2S\n-    __ addv(v2, __ T4S, v3, v4);                       \/\/       add     v2.4S, v3.4S, v4.4S\n-    __ addv(v24, __ T2D, v25, v26);                    \/\/       add     v24.2D, v25.2D, v26.2D\n-    __ fadd(v4, __ T2S, v5, v6);                       \/\/       fadd    v4.2S, v5.2S, v6.2S\n-    __ fadd(v3, __ T4S, v4, v5);                       \/\/       fadd    v3.4S, v4.4S, v5.4S\n-    __ fadd(v8, __ T2D, v9, v10);                      \/\/       fadd    v8.2D, v9.2D, v10.2D\n-    __ subv(v22, __ T8B, v23, v24);                    \/\/       sub     v22.8B, v23.8B, v24.8B\n-    __ subv(v17, __ T16B, v18, v19);                   \/\/       sub     v17.16B, v18.16B, v19.16B\n-    __ subv(v13, __ T4H, v14, v15);                    \/\/       sub     v13.4H, v14.4H, v15.4H\n+    __ andr(v25, __ T8B, v26, v27);                    \/\/       and     v25.8B, v26.8B, v27.8B\n+    __ andr(v24, __ T16B, v25, v26);                   \/\/       and     v24.16B, v25.16B, v26.16B\n+    __ orr(v3, __ T8B, v4, v5);                        \/\/       orr     v3.8B, v4.8B, v5.8B\n+    __ orr(v23, __ T16B, v24, v25);                    \/\/       orr     v23.16B, v24.16B, v25.16B\n+    __ eor(v26, __ T8B, v27, v28);                     \/\/       eor     v26.8B, v27.8B, v28.8B\n+    __ eor(v23, __ T16B, v24, v25);                    \/\/       eor     v23.16B, v24.16B, v25.16B\n+    __ addv(v14, __ T8B, v15, v16);                    \/\/       add     v14.8B, v15.8B, v16.8B\n+    __ addv(v21, __ T16B, v22, v23);                   \/\/       add     v21.16B, v22.16B, v23.16B\n+    __ addv(v3, __ T4H, v4, v5);                       \/\/       add     v3.4H, v4.4H, v5.4H\n+    __ addv(v23, __ T8H, v24, v25);                    \/\/       add     v23.8H, v24.8H, v25.8H\n+    __ addv(v8, __ T2S, v9, v10);                      \/\/       add     v8.2S, v9.2S, v10.2S\n+    __ addv(v24, __ T4S, v25, v26);                    \/\/       add     v24.4S, v25.4S, v26.4S\n+    __ addv(v19, __ T2D, v20, v21);                    \/\/       add     v19.2D, v20.2D, v21.2D\n+    __ fadd(v15, __ T2S, v16, v17);                    \/\/       fadd    v15.2S, v16.2S, v17.2S\n+    __ fadd(v16, __ T4S, v17, v18);                    \/\/       fadd    v16.4S, v17.4S, v18.4S\n+    __ fadd(v2, __ T2D, v3, v4);                       \/\/       fadd    v2.2D, v3.2D, v4.2D\n+    __ subv(v1, __ T8B, v2, v3);                       \/\/       sub     v1.8B, v2.8B, v3.8B\n+    __ subv(v0, __ T16B, v1, v2);                      \/\/       sub     v0.16B, v1.16B, v2.16B\n+    __ subv(v24, __ T4H, v25, v26);                    \/\/       sub     v24.4H, v25.4H, v26.4H\n@@ -683,31 +691,31 @@\n-    __ subv(v28, __ T2S, v29, v30);                    \/\/       sub     v28.2S, v29.2S, v30.2S\n-    __ subv(v23, __ T4S, v24, v25);                    \/\/       sub     v23.4S, v24.4S, v25.4S\n-    __ subv(v21, __ T2D, v22, v23);                    \/\/       sub     v21.2D, v22.2D, v23.2D\n-    __ fsub(v25, __ T2S, v26, v27);                    \/\/       fsub    v25.2S, v26.2S, v27.2S\n-    __ fsub(v24, __ T4S, v25, v26);                    \/\/       fsub    v24.4S, v25.4S, v26.4S\n-    __ fsub(v3, __ T2D, v4, v5);                       \/\/       fsub    v3.2D, v4.2D, v5.2D\n-    __ mulv(v23, __ T8B, v24, v25);                    \/\/       mul     v23.8B, v24.8B, v25.8B\n-    __ mulv(v26, __ T16B, v27, v28);                   \/\/       mul     v26.16B, v27.16B, v28.16B\n-    __ mulv(v23, __ T4H, v24, v25);                    \/\/       mul     v23.4H, v24.4H, v25.4H\n-    __ mulv(v14, __ T8H, v15, v16);                    \/\/       mul     v14.8H, v15.8H, v16.8H\n-    __ mulv(v21, __ T2S, v22, v23);                    \/\/       mul     v21.2S, v22.2S, v23.2S\n-    __ mulv(v3, __ T4S, v4, v5);                       \/\/       mul     v3.4S, v4.4S, v5.4S\n-    __ fabd(v23, __ T2S, v24, v25);                    \/\/       fabd    v23.2S, v24.2S, v25.2S\n-    __ fabd(v8, __ T4S, v9, v10);                      \/\/       fabd    v8.4S, v9.4S, v10.4S\n-    __ fabd(v24, __ T2D, v25, v26);                    \/\/       fabd    v24.2D, v25.2D, v26.2D\n-    __ faddp(v19, __ T2S, v20, v21);                   \/\/       faddp   v19.2S, v20.2S, v21.2S\n-    __ faddp(v15, __ T4S, v16, v17);                   \/\/       faddp   v15.4S, v16.4S, v17.4S\n-    __ faddp(v16, __ T2D, v17, v18);                   \/\/       faddp   v16.2D, v17.2D, v18.2D\n-    __ fmul(v2, __ T2S, v3, v4);                       \/\/       fmul    v2.2S, v3.2S, v4.2S\n-    __ fmul(v1, __ T4S, v2, v3);                       \/\/       fmul    v1.4S, v2.4S, v3.4S\n-    __ fmul(v0, __ T2D, v1, v2);                       \/\/       fmul    v0.2D, v1.2D, v2.2D\n-    __ mlav(v24, __ T4H, v25, v26);                    \/\/       mla     v24.4H, v25.4H, v26.4H\n-    __ mlav(v4, __ T8H, v5, v6);                       \/\/       mla     v4.8H, v5.8H, v6.8H\n-    __ mlav(v3, __ T2S, v4, v5);                       \/\/       mla     v3.2S, v4.2S, v5.2S\n-    __ mlav(v11, __ T4S, v12, v13);                    \/\/       mla     v11.4S, v12.4S, v13.4S\n-    __ fmla(v30, __ T2S, v31, v0);                     \/\/       fmla    v30.2S, v31.2S, v0.2S\n-    __ fmla(v27, __ T4S, v28, v29);                    \/\/       fmla    v27.4S, v28.4S, v29.4S\n-    __ fmla(v9, __ T2D, v10, v11);                     \/\/       fmla    v9.2D, v10.2D, v11.2D\n-    __ mlsv(v25, __ T4H, v26, v27);                    \/\/       mls     v25.4H, v26.4H, v27.4H\n-    __ mlsv(v2, __ T8H, v3, v4);                       \/\/       mls     v2.8H, v3.8H, v4.8H\n-    __ mlsv(v12, __ T2S, v13, v14);                    \/\/       mls     v12.2S, v13.2S, v14.2S\n+    __ subv(v3, __ T2S, v4, v5);                       \/\/       sub     v3.2S, v4.2S, v5.2S\n+    __ subv(v11, __ T4S, v12, v13);                    \/\/       sub     v11.4S, v12.4S, v13.4S\n+    __ subv(v30, __ T2D, v31, v0);                     \/\/       sub     v30.2D, v31.2D, v0.2D\n+    __ fsub(v27, __ T2S, v28, v29);                    \/\/       fsub    v27.2S, v28.2S, v29.2S\n+    __ fsub(v9, __ T4S, v10, v11);                     \/\/       fsub    v9.4S, v10.4S, v11.4S\n+    __ fsub(v25, __ T2D, v26, v27);                    \/\/       fsub    v25.2D, v26.2D, v27.2D\n+    __ mulv(v2, __ T8B, v3, v4);                       \/\/       mul     v2.8B, v3.8B, v4.8B\n+    __ mulv(v12, __ T16B, v13, v14);                   \/\/       mul     v12.16B, v13.16B, v14.16B\n+    __ mulv(v17, __ T4H, v18, v19);                    \/\/       mul     v17.4H, v18.4H, v19.4H\n+    __ mulv(v30, __ T8H, v31, v0);                     \/\/       mul     v30.8H, v31.8H, v0.8H\n+    __ mulv(v1, __ T2S, v2, v3);                       \/\/       mul     v1.2S, v2.2S, v3.2S\n+    __ mulv(v12, __ T4S, v13, v14);                    \/\/       mul     v12.4S, v13.4S, v14.4S\n+    __ fabd(v28, __ T2S, v29, v30);                    \/\/       fabd    v28.2S, v29.2S, v30.2S\n+    __ fabd(v0, __ T4S, v1, v2);                       \/\/       fabd    v0.4S, v1.4S, v2.4S\n+    __ fabd(v17, __ T2D, v18, v19);                    \/\/       fabd    v17.2D, v18.2D, v19.2D\n+    __ faddp(v12, __ T2S, v13, v14);                   \/\/       faddp   v12.2S, v13.2S, v14.2S\n+    __ faddp(v17, __ T4S, v18, v19);                   \/\/       faddp   v17.4S, v18.4S, v19.4S\n+    __ faddp(v21, __ T2D, v22, v23);                   \/\/       faddp   v21.2D, v22.2D, v23.2D\n+    __ fmul(v12, __ T2S, v13, v14);                    \/\/       fmul    v12.2S, v13.2S, v14.2S\n+    __ fmul(v27, __ T4S, v28, v29);                    \/\/       fmul    v27.4S, v28.4S, v29.4S\n+    __ fmul(v29, __ T2D, v30, v31);                    \/\/       fmul    v29.2D, v30.2D, v31.2D\n+    __ mlav(v30, __ T4H, v31, v0);                     \/\/       mla     v30.4H, v31.4H, v0.4H\n+    __ mlav(v1, __ T8H, v2, v3);                       \/\/       mla     v1.8H, v2.8H, v3.8H\n+    __ mlav(v25, __ T2S, v26, v27);                    \/\/       mla     v25.2S, v26.2S, v27.2S\n+    __ mlav(v27, __ T4S, v28, v29);                    \/\/       mla     v27.4S, v28.4S, v29.4S\n+    __ fmla(v4, __ T2S, v5, v6);                       \/\/       fmla    v4.2S, v5.2S, v6.2S\n+    __ fmla(v29, __ T4S, v30, v31);                    \/\/       fmla    v29.4S, v30.4S, v31.4S\n+    __ fmla(v3, __ T2D, v4, v5);                       \/\/       fmla    v3.2D, v4.2D, v5.2D\n+    __ mlsv(v6, __ T4H, v7, v8);                       \/\/       mls     v6.4H, v7.4H, v8.4H\n+    __ mlsv(v29, __ T8H, v30, v31);                    \/\/       mls     v29.8H, v30.8H, v31.8H\n+    __ mlsv(v25, __ T2S, v26, v27);                    \/\/       mls     v25.2S, v26.2S, v27.2S\n@@ -715,2 +723,2 @@\n-    __ fmls(v30, __ T2S, v31, v0);                     \/\/       fmls    v30.2S, v31.2S, v0.2S\n-    __ fmls(v1, __ T4S, v2, v3);                       \/\/       fmls    v1.4S, v2.4S, v3.4S\n+    __ fmls(v8, __ T2S, v9, v10);                      \/\/       fmls    v8.2S, v9.2S, v10.2S\n+    __ fmls(v7, __ T4S, v8, v9);                       \/\/       fmls    v7.4S, v8.4S, v9.4S\n@@ -718,36 +726,36 @@\n-    __ fdiv(v28, __ T2S, v29, v30);                    \/\/       fdiv    v28.2S, v29.2S, v30.2S\n-    __ fdiv(v0, __ T4S, v1, v2);                       \/\/       fdiv    v0.4S, v1.4S, v2.4S\n-    __ fdiv(v17, __ T2D, v18, v19);                    \/\/       fdiv    v17.2D, v18.2D, v19.2D\n-    __ maxv(v12, __ T8B, v13, v14);                    \/\/       smax    v12.8B, v13.8B, v14.8B\n-    __ maxv(v17, __ T16B, v18, v19);                   \/\/       smax    v17.16B, v18.16B, v19.16B\n-    __ maxv(v21, __ T4H, v22, v23);                    \/\/       smax    v21.4H, v22.4H, v23.4H\n-    __ maxv(v12, __ T8H, v13, v14);                    \/\/       smax    v12.8H, v13.8H, v14.8H\n-    __ maxv(v27, __ T2S, v28, v29);                    \/\/       smax    v27.2S, v28.2S, v29.2S\n-    __ maxv(v29, __ T4S, v30, v31);                    \/\/       smax    v29.4S, v30.4S, v31.4S\n-    __ smaxp(v30, __ T8B, v31, v0);                    \/\/       smaxp   v30.8B, v31.8B, v0.8B\n-    __ smaxp(v1, __ T16B, v2, v3);                     \/\/       smaxp   v1.16B, v2.16B, v3.16B\n-    __ smaxp(v25, __ T4H, v26, v27);                   \/\/       smaxp   v25.4H, v26.4H, v27.4H\n-    __ smaxp(v27, __ T8H, v28, v29);                   \/\/       smaxp   v27.8H, v28.8H, v29.8H\n-    __ smaxp(v4, __ T2S, v5, v6);                      \/\/       smaxp   v4.2S, v5.2S, v6.2S\n-    __ smaxp(v29, __ T4S, v30, v31);                   \/\/       smaxp   v29.4S, v30.4S, v31.4S\n-    __ fmax(v3, __ T2S, v4, v5);                       \/\/       fmax    v3.2S, v4.2S, v5.2S\n-    __ fmax(v6, __ T4S, v7, v8);                       \/\/       fmax    v6.4S, v7.4S, v8.4S\n-    __ fmax(v29, __ T2D, v30, v31);                    \/\/       fmax    v29.2D, v30.2D, v31.2D\n-    __ minv(v25, __ T8B, v26, v27);                    \/\/       smin    v25.8B, v26.8B, v27.8B\n-    __ minv(v17, __ T16B, v18, v19);                   \/\/       smin    v17.16B, v18.16B, v19.16B\n-    __ minv(v8, __ T4H, v9, v10);                      \/\/       smin    v8.4H, v9.4H, v10.4H\n-    __ minv(v7, __ T8H, v8, v9);                       \/\/       smin    v7.8H, v8.8H, v9.8H\n-    __ minv(v12, __ T2S, v13, v14);                    \/\/       smin    v12.2S, v13.2S, v14.2S\n-    __ minv(v0, __ T4S, v1, v2);                       \/\/       smin    v0.4S, v1.4S, v2.4S\n-    __ sminp(v19, __ T8B, v20, v21);                   \/\/       sminp   v19.8B, v20.8B, v21.8B\n-    __ sminp(v1, __ T16B, v2, v3);                     \/\/       sminp   v1.16B, v2.16B, v3.16B\n-    __ sminp(v23, __ T4H, v24, v25);                   \/\/       sminp   v23.4H, v24.4H, v25.4H\n-    __ sminp(v2, __ T8H, v3, v4);                      \/\/       sminp   v2.8H, v3.8H, v4.8H\n-    __ sminp(v0, __ T2S, v1, v2);                      \/\/       sminp   v0.2S, v1.2S, v2.2S\n-    __ sminp(v8, __ T4S, v9, v10);                     \/\/       sminp   v8.4S, v9.4S, v10.4S\n-    __ fmin(v23, __ T2S, v24, v25);                    \/\/       fmin    v23.2S, v24.2S, v25.2S\n-    __ fmin(v25, __ T4S, v26, v27);                    \/\/       fmin    v25.4S, v26.4S, v27.4S\n-    __ fmin(v15, __ T2D, v16, v17);                    \/\/       fmin    v15.2D, v16.2D, v17.2D\n-    __ facgt(v29, __ T2S, v30, v31);                   \/\/       facgt   v29.2S, v30.2S, v31.2S\n-    __ facgt(v3, __ T4S, v4, v5);                      \/\/       facgt   v3.4S, v4.4S, v5.4S\n-    __ facgt(v10, __ T2D, v11, v12);                   \/\/       facgt   v10.2D, v11.2D, v12.2D\n+    __ fdiv(v0, __ T2S, v1, v2);                       \/\/       fdiv    v0.2S, v1.2S, v2.2S\n+    __ fdiv(v19, __ T4S, v20, v21);                    \/\/       fdiv    v19.4S, v20.4S, v21.4S\n+    __ fdiv(v1, __ T2D, v2, v3);                       \/\/       fdiv    v1.2D, v2.2D, v3.2D\n+    __ maxv(v23, __ T8B, v24, v25);                    \/\/       smax    v23.8B, v24.8B, v25.8B\n+    __ maxv(v2, __ T16B, v3, v4);                      \/\/       smax    v2.16B, v3.16B, v4.16B\n+    __ maxv(v0, __ T4H, v1, v2);                       \/\/       smax    v0.4H, v1.4H, v2.4H\n+    __ maxv(v8, __ T8H, v9, v10);                      \/\/       smax    v8.8H, v9.8H, v10.8H\n+    __ maxv(v23, __ T2S, v24, v25);                    \/\/       smax    v23.2S, v24.2S, v25.2S\n+    __ maxv(v25, __ T4S, v26, v27);                    \/\/       smax    v25.4S, v26.4S, v27.4S\n+    __ smaxp(v15, __ T8B, v16, v17);                   \/\/       smaxp   v15.8B, v16.8B, v17.8B\n+    __ smaxp(v29, __ T16B, v30, v31);                  \/\/       smaxp   v29.16B, v30.16B, v31.16B\n+    __ smaxp(v3, __ T4H, v4, v5);                      \/\/       smaxp   v3.4H, v4.4H, v5.4H\n+    __ smaxp(v10, __ T8H, v11, v12);                   \/\/       smaxp   v10.8H, v11.8H, v12.8H\n+    __ smaxp(v22, __ T2S, v23, v24);                   \/\/       smaxp   v22.2S, v23.2S, v24.2S\n+    __ smaxp(v10, __ T4S, v11, v12);                   \/\/       smaxp   v10.4S, v11.4S, v12.4S\n+    __ fmax(v4, __ T2S, v5, v6);                       \/\/       fmax    v4.2S, v5.2S, v6.2S\n+    __ fmax(v17, __ T4S, v18, v19);                    \/\/       fmax    v17.4S, v18.4S, v19.4S\n+    __ fmax(v1, __ T2D, v2, v3);                       \/\/       fmax    v1.2D, v2.2D, v3.2D\n+    __ minv(v11, __ T8B, v12, v13);                    \/\/       smin    v11.8B, v12.8B, v13.8B\n+    __ minv(v7, __ T16B, v8, v9);                      \/\/       smin    v7.16B, v8.16B, v9.16B\n+    __ minv(v10, __ T4H, v11, v12);                    \/\/       smin    v10.4H, v11.4H, v12.4H\n+    __ minv(v15, __ T8H, v16, v17);                    \/\/       smin    v15.8H, v16.8H, v17.8H\n+    __ minv(v16, __ T2S, v17, v18);                    \/\/       smin    v16.2S, v17.2S, v18.2S\n+    __ minv(v2, __ T4S, v3, v4);                       \/\/       smin    v2.4S, v3.4S, v4.4S\n+    __ sminp(v9, __ T8B, v10, v11);                    \/\/       sminp   v9.8B, v10.8B, v11.8B\n+    __ sminp(v11, __ T16B, v12, v13);                  \/\/       sminp   v11.16B, v12.16B, v13.16B\n+    __ sminp(v12, __ T4H, v13, v14);                   \/\/       sminp   v12.4H, v13.4H, v14.4H\n+    __ sminp(v14, __ T8H, v15, v16);                   \/\/       sminp   v14.8H, v15.8H, v16.8H\n+    __ sminp(v13, __ T2S, v14, v15);                   \/\/       sminp   v13.2S, v14.2S, v15.2S\n+    __ sminp(v2, __ T4S, v3, v4);                      \/\/       sminp   v2.4S, v3.4S, v4.4S\n+    __ fmin(v6, __ T2S, v7, v8);                       \/\/       fmin    v6.2S, v7.2S, v8.2S\n+    __ fmin(v19, __ T4S, v20, v21);                    \/\/       fmin    v19.4S, v20.4S, v21.4S\n+    __ fmin(v25, __ T2D, v26, v27);                    \/\/       fmin    v25.2D, v26.2D, v27.2D\n+    __ facgt(v15, __ T2S, v16, v17);                   \/\/       facgt   v15.2S, v16.2S, v17.2S\n+    __ facgt(v4, __ T4S, v5, v6);                      \/\/       facgt   v4.4S, v5.4S, v6.4S\n+    __ facgt(v2, __ T2D, v3, v4);                      \/\/       facgt   v2.2D, v3.2D, v4.2D\n@@ -756,20 +764,20 @@\n-    __ cm(Assembler::GT, v22, __ T8B, v23, v24);       \/\/       cmgt    v22.8B, v23.8B, v24.8B\n-    __ cm(Assembler::GT, v10, __ T16B, v11, v12);      \/\/       cmgt    v10.16B, v11.16B, v12.16B\n-    __ cm(Assembler::GT, v4, __ T4H, v5, v6);          \/\/       cmgt    v4.4H, v5.4H, v6.4H\n-    __ cm(Assembler::GT, v17, __ T8H, v18, v19);       \/\/       cmgt    v17.8H, v18.8H, v19.8H\n-    __ cm(Assembler::GT, v1, __ T2S, v2, v3);          \/\/       cmgt    v1.2S, v2.2S, v3.2S\n-    __ cm(Assembler::GT, v11, __ T4S, v12, v13);       \/\/       cmgt    v11.4S, v12.4S, v13.4S\n-    __ cm(Assembler::GT, v7, __ T2D, v8, v9);          \/\/       cmgt    v7.2D, v8.2D, v9.2D\n-    __ cm(Assembler::GE, v10, __ T8B, v11, v12);       \/\/       cmge    v10.8B, v11.8B, v12.8B\n-    __ cm(Assembler::GE, v15, __ T16B, v16, v17);      \/\/       cmge    v15.16B, v16.16B, v17.16B\n-    __ cm(Assembler::GE, v16, __ T4H, v17, v18);       \/\/       cmge    v16.4H, v17.4H, v18.4H\n-    __ cm(Assembler::GE, v2, __ T8H, v3, v4);          \/\/       cmge    v2.8H, v3.8H, v4.8H\n-    __ cm(Assembler::GE, v9, __ T2S, v10, v11);        \/\/       cmge    v9.2S, v10.2S, v11.2S\n-    __ cm(Assembler::GE, v11, __ T4S, v12, v13);       \/\/       cmge    v11.4S, v12.4S, v13.4S\n-    __ cm(Assembler::GE, v12, __ T2D, v13, v14);       \/\/       cmge    v12.2D, v13.2D, v14.2D\n-    __ cm(Assembler::EQ, v14, __ T8B, v15, v16);       \/\/       cmeq    v14.8B, v15.8B, v16.8B\n-    __ cm(Assembler::EQ, v13, __ T16B, v14, v15);      \/\/       cmeq    v13.16B, v14.16B, v15.16B\n-    __ cm(Assembler::EQ, v2, __ T4H, v3, v4);          \/\/       cmeq    v2.4H, v3.4H, v4.4H\n-    __ cm(Assembler::EQ, v6, __ T8H, v7, v8);          \/\/       cmeq    v6.8H, v7.8H, v8.8H\n-    __ cm(Assembler::EQ, v19, __ T2S, v20, v21);       \/\/       cmeq    v19.2S, v20.2S, v21.2S\n-    __ cm(Assembler::EQ, v25, __ T4S, v26, v27);       \/\/       cmeq    v25.4S, v26.4S, v27.4S\n+    __ cm(Assembler::GT, v4, __ T8B, v5, v6);          \/\/       cmgt    v4.8B, v5.8B, v6.8B\n+    __ cm(Assembler::GT, v11, __ T16B, v12, v13);      \/\/       cmgt    v11.16B, v12.16B, v13.16B\n+    __ cm(Assembler::GT, v17, __ T4H, v18, v19);       \/\/       cmgt    v17.4H, v18.4H, v19.4H\n+    __ cm(Assembler::GT, v20, __ T8H, v21, v22);       \/\/       cmgt    v20.8H, v21.8H, v22.8H\n+    __ cm(Assembler::GT, v16, __ T2S, v17, v18);       \/\/       cmgt    v16.2S, v17.2S, v18.2S\n+    __ cm(Assembler::GT, v17, __ T4S, v18, v19);       \/\/       cmgt    v17.4S, v18.4S, v19.4S\n+    __ cm(Assembler::GT, v10, __ T2D, v11, v12);       \/\/       cmgt    v10.2D, v11.2D, v12.2D\n+    __ cm(Assembler::GE, v20, __ T8B, v21, v22);       \/\/       cmge    v20.8B, v21.8B, v22.8B\n+    __ cm(Assembler::GE, v22, __ T16B, v23, v24);      \/\/       cmge    v22.16B, v23.16B, v24.16B\n+    __ cm(Assembler::GE, v12, __ T4H, v13, v14);       \/\/       cmge    v12.4H, v13.4H, v14.4H\n+    __ cm(Assembler::GE, v25, __ T8H, v26, v27);       \/\/       cmge    v25.8H, v26.8H, v27.8H\n+    __ cm(Assembler::GE, v23, __ T2S, v24, v25);       \/\/       cmge    v23.2S, v24.2S, v25.2S\n+    __ cm(Assembler::GE, v28, __ T4S, v29, v30);       \/\/       cmge    v28.4S, v29.4S, v30.4S\n+    __ cm(Assembler::GE, v14, __ T2D, v15, v16);       \/\/       cmge    v14.2D, v15.2D, v16.2D\n+    __ cm(Assembler::EQ, v10, __ T8B, v11, v12);       \/\/       cmeq    v10.8B, v11.8B, v12.8B\n+    __ cm(Assembler::EQ, v24, __ T16B, v25, v26);      \/\/       cmeq    v24.16B, v25.16B, v26.16B\n+    __ cm(Assembler::EQ, v1, __ T4H, v2, v3);          \/\/       cmeq    v1.4H, v2.4H, v3.4H\n+    __ cm(Assembler::EQ, v11, __ T8H, v12, v13);       \/\/       cmeq    v11.8H, v12.8H, v13.8H\n+    __ cm(Assembler::EQ, v30, __ T2S, v31, v0);        \/\/       cmeq    v30.2S, v31.2S, v0.2S\n+    __ cm(Assembler::EQ, v10, __ T4S, v11, v12);       \/\/       cmeq    v10.4S, v11.4S, v12.4S\n@@ -777,1 +785,1 @@\n-    __ cm(Assembler::HI, v4, __ T8B, v5, v6);          \/\/       cmhi    v4.8B, v5.8B, v6.8B\n+    __ cm(Assembler::HI, v7, __ T8B, v8, v9);          \/\/       cmhi    v7.8B, v8.8B, v9.8B\n@@ -779,4 +787,4 @@\n-    __ cm(Assembler::HI, v4, __ T4H, v5, v6);          \/\/       cmhi    v4.4H, v5.4H, v6.4H\n-    __ cm(Assembler::HI, v11, __ T8H, v12, v13);       \/\/       cmhi    v11.8H, v12.8H, v13.8H\n-    __ cm(Assembler::HI, v17, __ T2S, v18, v19);       \/\/       cmhi    v17.2S, v18.2S, v19.2S\n-    __ cm(Assembler::HI, v20, __ T4S, v21, v22);       \/\/       cmhi    v20.4S, v21.4S, v22.4S\n+    __ cm(Assembler::HI, v3, __ T4H, v4, v5);          \/\/       cmhi    v3.4H, v4.4H, v5.4H\n+    __ cm(Assembler::HI, v13, __ T8H, v14, v15);       \/\/       cmhi    v13.8H, v14.8H, v15.8H\n+    __ cm(Assembler::HI, v19, __ T2S, v20, v21);       \/\/       cmhi    v19.2S, v20.2S, v21.2S\n+    __ cm(Assembler::HI, v16, __ T4S, v17, v18);       \/\/       cmhi    v16.4S, v17.4S, v18.4S\n@@ -784,7 +792,7 @@\n-    __ cm(Assembler::HS, v17, __ T8B, v18, v19);       \/\/       cmhs    v17.8B, v18.8B, v19.8B\n-    __ cm(Assembler::HS, v10, __ T16B, v11, v12);      \/\/       cmhs    v10.16B, v11.16B, v12.16B\n-    __ cm(Assembler::HS, v20, __ T4H, v21, v22);       \/\/       cmhs    v20.4H, v21.4H, v22.4H\n-    __ cm(Assembler::HS, v22, __ T8H, v23, v24);       \/\/       cmhs    v22.8H, v23.8H, v24.8H\n-    __ cm(Assembler::HS, v12, __ T2S, v13, v14);       \/\/       cmhs    v12.2S, v13.2S, v14.2S\n-    __ cm(Assembler::HS, v25, __ T4S, v26, v27);       \/\/       cmhs    v25.4S, v26.4S, v27.4S\n-    __ cm(Assembler::HS, v23, __ T2D, v24, v25);       \/\/       cmhs    v23.2D, v24.2D, v25.2D\n+    __ cm(Assembler::HS, v3, __ T8B, v4, v5);          \/\/       cmhs    v3.8B, v4.8B, v5.8B\n+    __ cm(Assembler::HS, v1, __ T16B, v2, v3);         \/\/       cmhs    v1.16B, v2.16B, v3.16B\n+    __ cm(Assembler::HS, v11, __ T4H, v12, v13);       \/\/       cmhs    v11.4H, v12.4H, v13.4H\n+    __ cm(Assembler::HS, v29, __ T8H, v30, v31);       \/\/       cmhs    v29.8H, v30.8H, v31.8H\n+    __ cm(Assembler::HS, v5, __ T2S, v6, v7);          \/\/       cmhs    v5.2S, v6.2S, v7.2S\n+    __ cm(Assembler::HS, v8, __ T4S, v9, v10);         \/\/       cmhs    v8.4S, v9.4S, v10.4S\n+    __ cm(Assembler::HS, v14, __ T2D, v15, v16);       \/\/       cmhs    v14.2D, v15.2D, v16.2D\n@@ -792,8 +800,8 @@\n-    __ fcm(Assembler::EQ, v14, __ T4S, v15, v16);      \/\/       fcmeq   v14.4S, v15.4S, v16.4S\n-    __ fcm(Assembler::EQ, v10, __ T2D, v11, v12);      \/\/       fcmeq   v10.2D, v11.2D, v12.2D\n-    __ fcm(Assembler::GT, v24, __ T2S, v25, v26);      \/\/       fcmgt   v24.2S, v25.2S, v26.2S\n-    __ fcm(Assembler::GT, v1, __ T4S, v2, v3);         \/\/       fcmgt   v1.4S, v2.4S, v3.4S\n-    __ fcm(Assembler::GT, v11, __ T2D, v12, v13);      \/\/       fcmgt   v11.2D, v12.2D, v13.2D\n-    __ fcm(Assembler::GE, v30, __ T2S, v31, v0);       \/\/       fcmge   v30.2S, v31.2S, v0.2S\n-    __ fcm(Assembler::GE, v10, __ T4S, v11, v12);      \/\/       fcmge   v10.4S, v11.4S, v12.4S\n-    __ fcm(Assembler::GE, v15, __ T2D, v16, v17);      \/\/       fcmge   v15.2D, v16.2D, v17.2D\n+    __ fcm(Assembler::EQ, v29, __ T4S, v30, v31);      \/\/       fcmeq   v29.4S, v30.4S, v31.4S\n+    __ fcm(Assembler::EQ, v0, __ T2D, v1, v2);         \/\/       fcmeq   v0.2D, v1.2D, v2.2D\n+    __ fcm(Assembler::GT, v20, __ T2S, v21, v22);      \/\/       fcmgt   v20.2S, v21.2S, v22.2S\n+    __ fcm(Assembler::GT, v7, __ T4S, v8, v9);         \/\/       fcmgt   v7.4S, v8.4S, v9.4S\n+    __ fcm(Assembler::GT, v20, __ T2D, v21, v22);      \/\/       fcmgt   v20.2D, v21.2D, v22.2D\n+    __ fcm(Assembler::GE, v23, __ T2S, v24, v25);      \/\/       fcmge   v23.2S, v24.2S, v25.2S\n+    __ fcm(Assembler::GE, v27, __ T4S, v28, v29);      \/\/       fcmge   v27.4S, v28.4S, v29.4S\n+    __ fcm(Assembler::GE, v21, __ T2D, v22, v23);      \/\/       fcmge   v21.2D, v22.2D, v23.2D\n@@ -802,6 +810,6 @@\n-    __ sve_fcm(Assembler::EQ, p3, __ S, p3, z2, 0.0);  \/\/       fcmeq   p3.s, p3\/z, z2.s, #0.0\n-    __ sve_fcm(Assembler::GT, p9, __ D, p0, z16, 0.0); \/\/       fcmgt   p9.d, p0\/z, z16.d, #0.0\n-    __ sve_fcm(Assembler::GE, p0, __ D, p1, z11, 0.0); \/\/       fcmge   p0.d, p1\/z, z11.d, #0.0\n-    __ sve_fcm(Assembler::LT, p4, __ D, p7, z14, 0.0); \/\/       fcmlt   p4.d, p7\/z, z14.d, #0.0\n-    __ sve_fcm(Assembler::LE, p0, __ S, p5, z20, 0.0); \/\/       fcmle   p0.s, p5\/z, z20.s, #0.0\n-    __ sve_fcm(Assembler::NE, p11, __ D, p6, z27, 0.0); \/\/      fcmne   p11.d, p6\/z, z27.d, #0.0\n+    __ sve_fcm(Assembler::EQ, p13, __ S, p0, z24, 0.0); \/\/      fcmeq   p13.s, p0\/z, z24.s, #0.0\n+    __ sve_fcm(Assembler::GT, p11, __ D, p1, z16, 0.0); \/\/      fcmgt   p11.d, p1\/z, z16.d, #0.0\n+    __ sve_fcm(Assembler::GE, p6, __ D, p3, z8, 0.0);  \/\/       fcmge   p6.d, p3\/z, z8.d, #0.0\n+    __ sve_fcm(Assembler::LT, p14, __ D, p4, z21, 0.0); \/\/      fcmlt   p14.d, p4\/z, z21.d, #0.0\n+    __ sve_fcm(Assembler::LE, p15, __ S, p4, z5, 0.0); \/\/       fcmle   p15.s, p4\/z, z5.s, #0.0\n+    __ sve_fcm(Assembler::NE, p15, __ D, p5, z17, 0.0); \/\/      fcmne   p15.d, p5\/z, z17.d, #0.0\n@@ -810,10 +818,10 @@\n-    __ sve_cmp(Assembler::EQ, p12, __ B, p5, z4, 0);   \/\/       cmpeq   p12.b, p5\/z, z4.b, #0\n-    __ sve_cmp(Assembler::GT, p15, __ H, p2, z5, 12);  \/\/       cmpgt   p15.h, p2\/z, z5.h, #12\n-    __ sve_cmp(Assembler::GE, p7, __ S, p7, z28, 3);   \/\/       cmpge   p7.s, p7\/z, z28.s, #3\n-    __ sve_cmp(Assembler::LT, p15, __ H, p4, z5, 15);  \/\/       cmplt   p15.h, p4\/z, z5.h, #15\n-    __ sve_cmp(Assembler::LE, p9, __ S, p4, z26, -4);  \/\/       cmple   p9.s, p4\/z, z26.s, #-4\n-    __ sve_cmp(Assembler::NE, p5, __ B, p7, z9, 1);    \/\/       cmpne   p5.b, p7\/z, z9.b, #1\n-    __ sve_cmp(Assembler::HS, p13, __ D, p1, z27, 43); \/\/       cmphs   p13.d, p1\/z, z27.d, #43\n-    __ sve_cmp(Assembler::HI, p10, __ B, p6, z9, 70);  \/\/       cmphi   p10.b, p6\/z, z9.b, #70\n-    __ sve_cmp(Assembler::LS, p8, __ B, p7, z22, 61);  \/\/       cmpls   p8.b, p7\/z, z22.b, #61\n-    __ sve_cmp(Assembler::LO, p11, __ S, p5, z17, 11); \/\/       cmplo   p11.s, p5\/z, z17.s, #11\n+    __ sve_cmp(Assembler::EQ, p8, __ H, p2, z12, -10); \/\/       cmpeq   p8.h, p2\/z, z12.h, #-10\n+    __ sve_cmp(Assembler::GT, p15, __ D, p7, z16, 14); \/\/       cmpgt   p15.d, p7\/z, z16.d, #14\n+    __ sve_cmp(Assembler::GE, p3, __ S, p2, z10, -12); \/\/       cmpge   p3.s, p2\/z, z10.s, #-12\n+    __ sve_cmp(Assembler::LT, p12, __ S, p5, z17, -13); \/\/      cmplt   p12.s, p5\/z, z17.s, #-13\n+    __ sve_cmp(Assembler::LE, p14, __ S, p4, z14, 3);  \/\/       cmple   p14.s, p4\/z, z14.s, #3\n+    __ sve_cmp(Assembler::NE, p11, __ H, p1, z2, -4);  \/\/       cmpne   p11.h, p1\/z, z2.h, #-4\n+    __ sve_cmp(Assembler::HS, p8, __ H, p5, z10, 5);   \/\/       cmphs   p8.h, p5\/z, z10.h, #5\n+    __ sve_cmp(Assembler::HI, p15, __ B, p4, z17, 10); \/\/       cmphi   p15.b, p4\/z, z17.b, #10\n+    __ sve_cmp(Assembler::LS, p8, __ H, p2, z21, 86);  \/\/       cmpls   p8.h, p2\/z, z21.h, #86\n+    __ sve_cmp(Assembler::LO, p14, __ H, p6, z27, 14); \/\/       cmplo   p14.h, p6\/z, z27.h, #14\n@@ -1074,9 +1082,9 @@\n-    __ swp(Assembler::xword, r15, r6, r12);            \/\/       swp     x15, x6, [x12]\n-    __ ldadd(Assembler::xword, r16, r11, r13);         \/\/       ldadd   x16, x11, [x13]\n-    __ ldbic(Assembler::xword, r23, r1, r30);          \/\/       ldclr   x23, x1, [x30]\n-    __ ldeor(Assembler::xword, r19, r5, r17);          \/\/       ldeor   x19, x5, [x17]\n-    __ ldorr(Assembler::xword, r2, r16, r22);          \/\/       ldset   x2, x16, [x22]\n-    __ ldsmin(Assembler::xword, r13, r10, r21);        \/\/       ldsmin  x13, x10, [x21]\n-    __ ldsmax(Assembler::xword, r29, r27, r12);        \/\/       ldsmax  x29, x27, [x12]\n-    __ ldumin(Assembler::xword, r27, r3, r1);          \/\/       ldumin  x27, x3, [x1]\n-    __ ldumax(Assembler::xword, zr, r24, r19);         \/\/       ldumax  xzr, x24, [x19]\n+    __ swp(Assembler::xword, r1, zr, r24);             \/\/       swp     x1, xzr, [x24]\n+    __ ldadd(Assembler::xword, r19, r17, r9);          \/\/       ldadd   x19, x17, [x9]\n+    __ ldbic(Assembler::xword, r28, r27, r15);         \/\/       ldclr   x28, x27, [x15]\n+    __ ldeor(Assembler::xword, r7, r21, r23);          \/\/       ldeor   x7, x21, [x23]\n+    __ ldorr(Assembler::xword, zr, r25, r2);           \/\/       ldset   xzr, x25, [x2]\n+    __ ldsmin(Assembler::xword, zr, r27, r15);         \/\/       ldsmin  xzr, x27, [x15]\n+    __ ldsmax(Assembler::xword, r10, r23, r19);        \/\/       ldsmax  x10, x23, [x19]\n+    __ ldumin(Assembler::xword, r3, r16, r0);          \/\/       ldumin  x3, x16, [x0]\n+    __ ldumax(Assembler::xword, r25, r26, r23);        \/\/       ldumax  x25, x26, [x23]\n@@ -1085,9 +1093,9 @@\n-    __ swpa(Assembler::xword, r17, r9, r28);           \/\/       swpa    x17, x9, [x28]\n-    __ ldadda(Assembler::xword, r27, r15, r7);         \/\/       ldadda  x27, x15, [x7]\n-    __ ldbica(Assembler::xword, r21, r23, sp);         \/\/       ldclra  x21, x23, [sp]\n-    __ ldeora(Assembler::xword, r25, r2, sp);          \/\/       ldeora  x25, x2, [sp]\n-    __ ldorra(Assembler::xword, r27, r16, r10);        \/\/       ldseta  x27, x16, [x10]\n-    __ ldsmina(Assembler::xword, r23, r19, r3);        \/\/       ldsmina x23, x19, [x3]\n-    __ ldsmaxa(Assembler::xword, r16, r0, r25);        \/\/       ldsmaxa x16, x0, [x25]\n-    __ ldumina(Assembler::xword, r26, r23, r2);        \/\/       ldumina x26, x23, [x2]\n-    __ ldumaxa(Assembler::xword, r16, r12, r4);        \/\/       ldumaxa x16, x12, [x4]\n+    __ swpa(Assembler::xword, r2, r16, r12);           \/\/       swpa    x2, x16, [x12]\n+    __ ldadda(Assembler::xword, r4, r28, r30);         \/\/       ldadda  x4, x28, [x30]\n+    __ ldbica(Assembler::xword, r29, r16, r27);        \/\/       ldclra  x29, x16, [x27]\n+    __ ldeora(Assembler::xword, r6, r9, r29);          \/\/       ldeora  x6, x9, [x29]\n+    __ ldorra(Assembler::xword, r16, r7, r4);          \/\/       ldseta  x16, x7, [x4]\n+    __ ldsmina(Assembler::xword, r7, r15, r9);         \/\/       ldsmina x7, x15, [x9]\n+    __ ldsmaxa(Assembler::xword, r23, r8, r2);         \/\/       ldsmaxa x23, x8, [x2]\n+    __ ldumina(Assembler::xword, r28, r21, sp);        \/\/       ldumina x28, x21, [sp]\n+    __ ldumaxa(Assembler::xword, r5, r27, r0);         \/\/       ldumaxa x5, x27, [x0]\n@@ -1096,9 +1104,9 @@\n-    __ swpal(Assembler::xword, r28, r30, r29);         \/\/       swpal   x28, x30, [x29]\n-    __ ldaddal(Assembler::xword, r16, r27, r6);        \/\/       ldaddal x16, x27, [x6]\n-    __ ldbical(Assembler::xword, r9, r29, r15);        \/\/       ldclral x9, x29, [x15]\n-    __ ldeoral(Assembler::xword, r7, r4, r7);          \/\/       ldeoral x7, x4, [x7]\n-    __ ldorral(Assembler::xword, r15, r9, r23);        \/\/       ldsetal x15, x9, [x23]\n-    __ ldsminal(Assembler::xword, r8, r2, r28);        \/\/       ldsminal        x8, x2, [x28]\n-    __ ldsmaxal(Assembler::xword, r21, zr, r5);        \/\/       ldsmaxal        x21, xzr, [x5]\n-    __ lduminal(Assembler::xword, r27, r0, r17);       \/\/       lduminal        x27, x0, [x17]\n-    __ ldumaxal(Assembler::xword, r15, r4, r26);       \/\/       ldumaxal        x15, x4, [x26]\n+    __ swpal(Assembler::xword, r17, r15, r4);          \/\/       swpal   x17, x15, [x4]\n+    __ ldaddal(Assembler::xword, r26, r8, r28);        \/\/       ldaddal x26, x8, [x28]\n+    __ ldbical(Assembler::xword, r22, r27, r27);       \/\/       ldclral x22, x27, [x27]\n+    __ ldeoral(Assembler::xword, r25, r23, r0);        \/\/       ldeoral x25, x23, [x0]\n+    __ ldorral(Assembler::xword, r4, r6, r15);         \/\/       ldsetal x4, x6, [x15]\n+    __ ldsminal(Assembler::xword, r0, r4, r15);        \/\/       ldsminal        x0, x4, [x15]\n+    __ ldsmaxal(Assembler::xword, r1, r10, r7);        \/\/       ldsmaxal        x1, x10, [x7]\n+    __ lduminal(Assembler::xword, r5, r10, r28);       \/\/       lduminal        x5, x10, [x28]\n+    __ ldumaxal(Assembler::xword, r7, r20, r23);       \/\/       ldumaxal        x7, x20, [x23]\n@@ -1107,9 +1115,9 @@\n-    __ swpl(Assembler::xword, r8, r28, r22);           \/\/       swpl    x8, x28, [x22]\n-    __ ldaddl(Assembler::xword, r27, r27, r25);        \/\/       ldaddl  x27, x27, [x25]\n-    __ ldbicl(Assembler::xword, r23, r0, r4);          \/\/       ldclrl  x23, x0, [x4]\n-    __ ldeorl(Assembler::xword, r6, r16, r0);          \/\/       ldeorl  x6, x16, [x0]\n-    __ ldorrl(Assembler::xword, r4, r15, r1);          \/\/       ldsetl  x4, x15, [x1]\n-    __ ldsminl(Assembler::xword, r10, r7, r5);         \/\/       ldsminl x10, x7, [x5]\n-    __ ldsmaxl(Assembler::xword, r10, r28, r7);        \/\/       ldsmaxl x10, x28, [x7]\n-    __ lduminl(Assembler::xword, r20, r23, r21);       \/\/       lduminl x20, x23, [x21]\n-    __ ldumaxl(Assembler::xword, r6, r11, r8);         \/\/       ldumaxl x6, x11, [x8]\n+    __ swpl(Assembler::xword, r21, r6, r11);           \/\/       swpl    x21, x6, [x11]\n+    __ ldaddl(Assembler::xword, r8, r17, sp);          \/\/       ldaddl  x8, x17, [sp]\n+    __ ldbicl(Assembler::xword, r6, r17, r2);          \/\/       ldclrl  x6, x17, [x2]\n+    __ ldeorl(Assembler::xword, r12, r30, r29);        \/\/       ldeorl  x12, x30, [x29]\n+    __ ldorrl(Assembler::xword, r3, r27, r22);         \/\/       ldsetl  x3, x27, [x22]\n+    __ ldsminl(Assembler::xword, r29, r14, r13);       \/\/       ldsminl x29, x14, [x13]\n+    __ ldsmaxl(Assembler::xword, r28, r17, r24);       \/\/       ldsmaxl x28, x17, [x24]\n+    __ lduminl(Assembler::xword, r5, r2, r14);         \/\/       lduminl x5, x2, [x14]\n+    __ ldumaxl(Assembler::xword, r10, r16, r11);       \/\/       ldumaxl x10, x16, [x11]\n@@ -1118,9 +1126,9 @@\n-    __ swp(Assembler::word, r17, zr, r6);              \/\/       swp     w17, wzr, [x6]\n-    __ ldadd(Assembler::word, r17, r2, r12);           \/\/       ldadd   w17, w2, [x12]\n-    __ ldbic(Assembler::word, r30, r29, r3);           \/\/       ldclr   w30, w29, [x3]\n-    __ ldeor(Assembler::word, r27, r22, r29);          \/\/       ldeor   w27, w22, [x29]\n-    __ ldorr(Assembler::word, r14, r13, r28);          \/\/       ldset   w14, w13, [x28]\n-    __ ldsmin(Assembler::word, r17, r24, r5);          \/\/       ldsmin  w17, w24, [x5]\n-    __ ldsmax(Assembler::word, r2, r14, r10);          \/\/       ldsmax  w2, w14, [x10]\n-    __ ldumin(Assembler::word, r16, r11, r27);         \/\/       ldumin  w16, w11, [x27]\n-    __ ldumax(Assembler::word, r23, r12, r4);          \/\/       ldumax  w23, w12, [x4]\n+    __ swp(Assembler::word, r27, r23, r12);            \/\/       swp     w27, w23, [x12]\n+    __ ldadd(Assembler::word, r4, r22, r17);           \/\/       ldadd   w4, w22, [x17]\n+    __ ldbic(Assembler::word, r4, r1, r19);            \/\/       ldclr   w4, w1, [x19]\n+    __ ldeor(Assembler::word, r16, r16, r13);          \/\/       ldeor   w16, w16, [x13]\n+    __ ldorr(Assembler::word, r14, r12, r2);           \/\/       ldset   w14, w12, [x2]\n+    __ ldsmin(Assembler::word, r17, r3, r21);          \/\/       ldsmin  w17, w3, [x21]\n+    __ ldsmax(Assembler::word, r23, r5, r6);           \/\/       ldsmax  w23, w5, [x6]\n+    __ ldumin(Assembler::word, r7, r19, r13);          \/\/       ldumin  w7, w19, [x13]\n+    __ ldumax(Assembler::word, r28, r17, r16);         \/\/       ldumax  w28, w17, [x16]\n@@ -1129,9 +1137,9 @@\n-    __ swpa(Assembler::word, r22, r17, r4);            \/\/       swpa    w22, w17, [x4]\n-    __ ldadda(Assembler::word, r1, r19, r16);          \/\/       ldadda  w1, w19, [x16]\n-    __ ldbica(Assembler::word, r16, r13, r14);         \/\/       ldclra  w16, w13, [x14]\n-    __ ldeora(Assembler::word, r12, r2, r17);          \/\/       ldeora  w12, w2, [x17]\n-    __ ldorra(Assembler::word, r3, r21, r23);          \/\/       ldseta  w3, w21, [x23]\n-    __ ldsmina(Assembler::word, r5, r6, r7);           \/\/       ldsmina w5, w6, [x7]\n-    __ ldsmaxa(Assembler::word, r19, r13, r28);        \/\/       ldsmaxa w19, w13, [x28]\n-    __ ldumina(Assembler::word, r17, r16, r6);         \/\/       ldumina w17, w16, [x6]\n-    __ ldumaxa(Assembler::word, r2, r29, r3);          \/\/       ldumaxa w2, w29, [x3]\n+    __ swpa(Assembler::word, r6, r2, r29);             \/\/       swpa    w6, w2, [x29]\n+    __ ldadda(Assembler::word, r3, r4, r6);            \/\/       ldadda  w3, w4, [x6]\n+    __ ldbica(Assembler::word, r16, r20, r13);         \/\/       ldclra  w16, w20, [x13]\n+    __ ldeora(Assembler::word, r12, r20, r8);          \/\/       ldeora  w12, w20, [x8]\n+    __ ldorra(Assembler::word, r25, r20, r19);         \/\/       ldseta  w25, w20, [x19]\n+    __ ldsmina(Assembler::word, r0, r11, r24);         \/\/       ldsmina w0, w11, [x24]\n+    __ ldsmaxa(Assembler::word, r6, r20, sp);          \/\/       ldsmaxa w6, w20, [sp]\n+    __ ldumina(Assembler::word, r14, r16, r6);         \/\/       ldumina w14, w16, [x6]\n+    __ ldumaxa(Assembler::word, r0, r7, r15);          \/\/       ldumaxa w0, w7, [x15]\n@@ -1140,9 +1148,9 @@\n-    __ swpal(Assembler::word, r4, r6, r15);            \/\/       swpal   w4, w6, [x15]\n-    __ ldaddal(Assembler::word, r20, r13, r12);        \/\/       ldaddal w20, w13, [x12]\n-    __ ldbical(Assembler::word, r20, r8, r25);         \/\/       ldclral w20, w8, [x25]\n-    __ ldeoral(Assembler::word, r20, r19, r0);         \/\/       ldeoral w20, w19, [x0]\n-    __ ldorral(Assembler::word, r11, r24, r6);         \/\/       ldsetal w11, w24, [x6]\n-    __ ldsminal(Assembler::word, r20, zr, r14);        \/\/       ldsminal        w20, wzr, [x14]\n-    __ ldsmaxal(Assembler::word, r16, r6, r0);         \/\/       ldsmaxal        w16, w6, [x0]\n-    __ lduminal(Assembler::word, r7, r15, r19);        \/\/       lduminal        w7, w15, [x19]\n-    __ ldumaxal(Assembler::word, r26, r9, r10);        \/\/       ldumaxal        w26, w9, [x10]\n+    __ swpal(Assembler::word, r19, r26, r9);           \/\/       swpal   w19, w26, [x9]\n+    __ ldaddal(Assembler::word, r10, r23, r21);        \/\/       ldaddal w10, w23, [x21]\n+    __ ldbical(Assembler::word, r22, r28, r2);         \/\/       ldclral w22, w28, [x2]\n+    __ ldeoral(Assembler::word, r3, r15, r19);         \/\/       ldeoral w3, w15, [x19]\n+    __ ldorral(Assembler::word, r20, r7, r4);          \/\/       ldsetal w20, w7, [x4]\n+    __ ldsminal(Assembler::word, r29, r7, r0);         \/\/       ldsminal        w29, w7, [x0]\n+    __ ldsmaxal(Assembler::word, r9, r16, r20);        \/\/       ldsmaxal        w9, w16, [x20]\n+    __ lduminal(Assembler::word, r23, r4, r16);        \/\/       lduminal        w23, w4, [x16]\n+    __ ldumaxal(Assembler::word, r10, r23, r11);       \/\/       ldumaxal        w10, w23, [x11]\n@@ -1151,9 +1159,9 @@\n-    __ swpl(Assembler::word, r23, r21, r22);           \/\/       swpl    w23, w21, [x22]\n-    __ ldaddl(Assembler::word, r28, r2, r3);           \/\/       ldaddl  w28, w2, [x3]\n-    __ ldbicl(Assembler::word, r15, r19, r20);         \/\/       ldclrl  w15, w19, [x20]\n-    __ ldeorl(Assembler::word, r7, r4, r29);           \/\/       ldeorl  w7, w4, [x29]\n-    __ ldorrl(Assembler::word, r7, r0, r9);            \/\/       ldsetl  w7, w0, [x9]\n-    __ ldsminl(Assembler::word, r16, r20, r23);        \/\/       ldsminl w16, w20, [x23]\n-    __ ldsmaxl(Assembler::word, r4, r16, r10);         \/\/       ldsmaxl w4, w16, [x10]\n-    __ lduminl(Assembler::word, r23, r11, r25);        \/\/       lduminl w23, w11, [x25]\n-    __ ldumaxl(Assembler::word, r6, zr, r16);          \/\/       ldumaxl w6, wzr, [x16]\n+    __ swpl(Assembler::word, r25, r6, sp);             \/\/       swpl    w25, w6, [sp]\n+    __ ldaddl(Assembler::word, r16, r13, r23);         \/\/       ldaddl  w16, w13, [x23]\n+    __ ldbicl(Assembler::word, r12, r1, r14);          \/\/       ldclrl  w12, w1, [x14]\n+    __ ldeorl(Assembler::word, r9, r21, r16);          \/\/       ldeorl  w9, w21, [x16]\n+    __ ldorrl(Assembler::word, r26, r15, r4);          \/\/       ldsetl  w26, w15, [x4]\n+    __ ldsminl(Assembler::word, r4, r16, r8);          \/\/       ldsminl w4, w16, [x8]\n+    __ ldsmaxl(Assembler::word, r6, r30, r4);          \/\/       ldsmaxl w6, w30, [x4]\n+    __ lduminl(Assembler::word, r29, r17, r29);        \/\/       lduminl w29, w17, [x29]\n+    __ ldumaxl(Assembler::word, r26, r9, r15);         \/\/       ldumaxl w26, w9, [x15]\n@@ -1162,4 +1170,4 @@\n-    __ bcax(v13, __ T16B, v22, v11, v1);               \/\/       bcax            v13.16B, v22.16B, v11.16B, v1.16B\n-    __ eor3(v13, __ T16B, v8, v20, v16);               \/\/       eor3            v13.16B, v8.16B, v20.16B, v16.16B\n-    __ rax1(v25, __ T2D, v15, v4);                     \/\/       rax1            v25.2D, v15.2D, v4.2D\n-    __ xar(v4, __ T2D, v17, v8, 13);                   \/\/       xar             v4.2D, v17.2D, v8.2D, #13\n+    __ bcax(v2, __ T16B, v11, v28, v3);                \/\/       bcax            v2.16B, v11.16B, v28.16B, v3.16B\n+    __ eor3(v7, __ T16B, v1, v26, v21);                \/\/       eor3            v7.16B, v1.16B, v26.16B, v21.16B\n+    __ rax1(v17, __ T2D, v14, v8);                     \/\/       rax1            v17.2D, v14.2D, v8.2D\n+    __ xar(v17, __ T2D, v21, v24, 10);                 \/\/       xar             v17.2D, v21.2D, v24.2D, #10\n@@ -1168,4 +1176,4 @@\n-    __ sha512h(v29, __ T2D, v4, v28);                  \/\/       sha512h         q29, q4, v28.2D\n-    __ sha512h2(v16, __ T2D, v29, v26);                \/\/       sha512h2                q16, q29, v26.2D\n-    __ sha512su0(v9, __ T2D, v14);                     \/\/       sha512su0               v9.2D, v14.2D\n-    __ sha512su1(v2, __ T2D, v11, v28);                \/\/       sha512su1               v2.2D, v11.2D, v28.2D\n+    __ sha512h(v19, __ T2D, v21, v17);                 \/\/       sha512h         q19, q21, v17.2D\n+    __ sha512h2(v22, __ T2D, v16, v29);                \/\/       sha512h2                q22, q16, v29.2D\n+    __ sha512su0(v20, __ T2D, v19);                    \/\/       sha512su0               v20.2D, v19.2D\n+    __ sha512su1(v0, __ T2D, v4, v17);                 \/\/       sha512su1               v0.2D, v4.2D, v17.2D\n@@ -1174,5 +1182,5 @@\n-    __ sve_add(z3, __ B, 10u);                         \/\/       add     z3.b, z3.b, #0xa\n-    __ sve_sub(z26, __ S, 150u);                       \/\/       sub     z26.s, z26.s, #0x96\n-    __ sve_and(z14, __ H, 57343u);                     \/\/       and     z14.h, z14.h, #0xdfff\n-    __ sve_eor(z24, __ B, 191u);                       \/\/       eor     z24.b, z24.b, #0xbf\n-    __ sve_orr(z17, __ S, 4294966791u);                \/\/       orr     z17.s, z17.s, #0xfffffe07\n+    __ sve_add(z23, __ B, 163u);                       \/\/       add     z23.b, z23.b, #0xa3\n+    __ sve_sub(z4, __ D, 210u);                        \/\/       sub     z4.d, z4.d, #0xd2\n+    __ sve_and(z19, __ B, 96u);                        \/\/       and     z19.b, z19.b, #0x60\n+    __ sve_eor(z14, __ D, 18446744073709543551u);      \/\/       eor     z14.d, z14.d, #0xffffffffffffe07f\n+    __ sve_orr(z21, __ B, 1u);                         \/\/       orr     z21.b, z21.b, #0x1\n@@ -1181,5 +1189,5 @@\n-    __ sve_add(z20, __ S, 3u);                         \/\/       add     z20.s, z20.s, #0x3\n-    __ sve_sub(z4, __ S, 196u);                        \/\/       sub     z4.s, z4.s, #0xc4\n-    __ sve_and(z4, __ S, 4286578691u);                 \/\/       and     z4.s, z4.s, #0xff800003\n-    __ sve_eor(z25, __ S, 33553408u);                  \/\/       eor     z25.s, z25.s, #0x1fffc00\n-    __ sve_orr(z8, __ H, 49663u);                      \/\/       orr     z8.h, z8.h, #0xc1ff\n+    __ sve_add(z10, __ S, 99u);                        \/\/       add     z10.s, z10.s, #0x63\n+    __ sve_sub(z0, __ H, 61u);                         \/\/       sub     z0.h, z0.h, #0x3d\n+    __ sve_and(z24, __ S, 4294709247u);                \/\/       and     z24.s, z24.s, #0xfffc0fff\n+    __ sve_eor(z6, __ H, 57407u);                      \/\/       eor     z6.h, z6.h, #0xe03f\n+    __ sve_orr(z13, __ S, 4229955583u);                \/\/       orr     z13.s, z13.s, #0xfc1fffff\n@@ -1188,5 +1196,5 @@\n-    __ sve_add(z30, __ S, 36u);                        \/\/       add     z30.s, z30.s, #0x24\n-    __ sve_sub(z30, __ B, 85u);                        \/\/       sub     z30.b, z30.b, #0x55\n-    __ sve_and(z19, __ H, 4032u);                      \/\/       and     z19.h, z19.h, #0xfc0\n-    __ sve_eor(z7, __ D, 274877904896u);               \/\/       eor     z7.d, z7.d, #0x3ffffff800\n-    __ sve_orr(z27, __ B, 243u);                       \/\/       orr     z27.b, z27.b, #0xf3\n+    __ sve_add(z22, __ S, 252u);                       \/\/       add     z22.s, z22.s, #0xfc\n+    __ sve_sub(z28, __ H, 113u);                       \/\/       sub     z28.h, z28.h, #0x71\n+    __ sve_and(z19, __ B, 243u);                       \/\/       and     z19.b, z19.b, #0xf3\n+    __ sve_eor(z9, __ H, 16368u);                      \/\/       eor     z9.h, z9.h, #0x3ff0\n+    __ sve_orr(z19, __ B, 96u);                        \/\/       orr     z19.b, z19.b, #0x60\n@@ -1195,5 +1203,5 @@\n-    __ sve_add(z23, __ H, 132u);                       \/\/       add     z23.h, z23.h, #0x84\n-    __ sve_sub(z30, __ S, 183u);                       \/\/       sub     z30.s, z30.s, #0xb7\n-    __ sve_and(z20, __ D, 4503599627354112u);          \/\/       and     z20.d, z20.d, #0xfffffffffc000\n-    __ sve_eor(z13, __ S, 4042322160u);                \/\/       eor     z13.s, z13.s, #0xf0f0f0f0\n-    __ sve_orr(z28, __ H, 32256u);                     \/\/       orr     z28.h, z28.h, #0x7e00\n+    __ sve_add(z19, __ H, 156u);                       \/\/       add     z19.h, z19.h, #0x9c\n+    __ sve_sub(z17, __ S, 41u);                        \/\/       sub     z17.s, z17.s, #0x29\n+    __ sve_and(z0, __ B, 96u);                         \/\/       and     z0.b, z0.b, #0x60\n+    __ sve_eor(z15, __ H, 255u);                       \/\/       eor     z15.h, z15.h, #0xff\n+    __ sve_orr(z15, __ D, 1u);                         \/\/       orr     z15.d, z15.d, #0x1\n@@ -1202,5 +1210,5 @@\n-    __ sve_add(z11, __ S, 13u);                        \/\/       add     z11.s, z11.s, #0xd\n-    __ sve_sub(z24, __ H, 159u);                       \/\/       sub     z24.h, z24.h, #0x9f\n-    __ sve_and(z13, __ S, 2151677951u);                \/\/       and     z13.s, z13.s, #0x803fffff\n-    __ sve_eor(z4, __ B, 124u);                        \/\/       eor     z4.b, z4.b, #0x7c\n-    __ sve_orr(z7, __ H, 32768u);                      \/\/       orr     z7.h, z7.h, #0x8000\n+    __ sve_add(z10, __ S, 220u);                       \/\/       add     z10.s, z10.s, #0xdc\n+    __ sve_sub(z3, __ B, 79u);                         \/\/       sub     z3.b, z3.b, #0x4f\n+    __ sve_and(z19, __ D, 18446532967477018623u);      \/\/       and     z19.d, z19.d, #0xffff3fffffffffff\n+    __ sve_eor(z3, __ S, 4286578691u);                 \/\/       eor     z3.s, z3.s, #0xff800003\n+    __ sve_orr(z28, __ H, 8064u);                      \/\/       orr     z28.h, z28.h, #0x1f80\n@@ -1209,5 +1217,5 @@\n-    __ sve_add(z4, __ H, 243u);                        \/\/       add     z4.h, z4.h, #0xf3\n-    __ sve_sub(z5, __ B, 86u);                         \/\/       sub     z5.b, z5.b, #0x56\n-    __ sve_and(z21, __ D, 8064u);                      \/\/       and     z21.d, z21.d, #0x1f80\n-    __ sve_eor(z9, __ S, 130023424u);                  \/\/       eor     z9.s, z9.s, #0x7c00000\n-    __ sve_orr(z24, __ B, 62u);                        \/\/       orr     z24.b, z24.b, #0x3e\n+    __ sve_add(z26, __ H, 149u);                       \/\/       add     z26.h, z26.h, #0x95\n+    __ sve_sub(z30, __ S, 115u);                       \/\/       sub     z30.s, z30.s, #0x73\n+    __ sve_and(z2, __ D, 18437736874454811647u);       \/\/       and     z2.d, z2.d, #0xffe00000000003ff\n+    __ sve_eor(z20, __ B, 12u);                        \/\/       eor     z20.b, z20.b, #0xc\n+    __ sve_orr(z1, __ D, 4503599627354112u);           \/\/       orr     z1.d, z1.d, #0xfffffffffc000\n@@ -1216,56 +1224,56 @@\n-    __ sve_add(z23, __ S, z28, z13);                   \/\/       add     z23.s, z28.s, z13.s\n-    __ sve_sub(z10, __ S, z26, z12);                   \/\/       sub     z10.s, z26.s, z12.s\n-    __ sve_fadd(z30, __ S, z17, z14);                  \/\/       fadd    z30.s, z17.s, z14.s\n-    __ sve_fmul(z29, __ D, z16, z21);                  \/\/       fmul    z29.d, z16.d, z21.d\n-    __ sve_fsub(z7, __ S, z19, z2);                    \/\/       fsub    z7.s, z19.s, z2.s\n-    __ sve_abs(z26, __ S, p4, z9);                     \/\/       abs     z26.s, p4\/m, z9.s\n-    __ sve_add(z17, __ B, p5, z0);                     \/\/       add     z17.b, p5\/m, z17.b, z0.b\n-    __ sve_and(z2, __ B, p6, z14);                     \/\/       and     z2.b, p6\/m, z2.b, z14.b\n-    __ sve_asr(z11, __ S, p5, z14);                    \/\/       asr     z11.s, p5\/m, z11.s, z14.s\n-    __ sve_bic(z29, __ B, p3, z3);                     \/\/       bic     z29.b, p3\/m, z29.b, z3.b\n-    __ sve_clz(z22, __ D, p2, z3);                     \/\/       clz     z22.d, p2\/m, z3.d\n-    __ sve_cnt(z27, __ S, p0, z19);                    \/\/       cnt     z27.s, p0\/m, z19.s\n-    __ sve_eor(z7, __ H, p6, z21);                     \/\/       eor     z7.h, p6\/m, z7.h, z21.h\n-    __ sve_lsl(z5, __ B, p2, z25);                     \/\/       lsl     z5.b, p2\/m, z5.b, z25.b\n-    __ sve_lsr(z21, __ B, p4, z17);                    \/\/       lsr     z21.b, p4\/m, z21.b, z17.b\n-    __ sve_mul(z3, __ H, p2, z19);                     \/\/       mul     z3.h, p2\/m, z3.h, z19.h\n-    __ sve_neg(z7, __ S, p3, z14);                     \/\/       neg     z7.s, p3\/m, z14.s\n-    __ sve_not(z17, __ D, p2, z13);                    \/\/       not     z17.d, p2\/m, z13.d\n-    __ sve_orr(z17, __ H, p7, z17);                    \/\/       orr     z17.h, p7\/m, z17.h, z17.h\n-    __ sve_rbit(z15, __ S, p3, z26);                   \/\/       rbit    z15.s, p3\/m, z26.s\n-    __ sve_revb(z27, __ H, p5, z7);                    \/\/       revb    z27.h, p5\/m, z7.h\n-    __ sve_smax(z5, __ H, p7, z27);                    \/\/       smax    z5.h, p7\/m, z5.h, z27.h\n-    __ sve_smin(z0, __ S, p3, z24);                    \/\/       smin    z0.s, p3\/m, z0.s, z24.s\n-    __ sve_sub(z20, __ S, p0, z3);                     \/\/       sub     z20.s, p0\/m, z20.s, z3.s\n-    __ sve_fabs(z25, __ D, p1, z25);                   \/\/       fabs    z25.d, p1\/m, z25.d\n-    __ sve_fadd(z17, __ S, p4, z1);                    \/\/       fadd    z17.s, p4\/m, z17.s, z1.s\n-    __ sve_fdiv(z14, __ S, p7, z13);                   \/\/       fdiv    z14.s, p7\/m, z14.s, z13.s\n-    __ sve_fmax(z17, __ D, p0, z30);                   \/\/       fmax    z17.d, p0\/m, z17.d, z30.d\n-    __ sve_fmin(z22, __ S, p5, z29);                   \/\/       fmin    z22.s, p5\/m, z22.s, z29.s\n-    __ sve_fmul(z8, __ S, p0, z0);                     \/\/       fmul    z8.s, p0\/m, z8.s, z0.s\n-    __ sve_fneg(z23, __ D, p5, z0);                    \/\/       fneg    z23.d, p5\/m, z0.d\n-    __ sve_frintm(z25, __ S, p6, z23);                 \/\/       frintm  z25.s, p6\/m, z23.s\n-    __ sve_frintn(z21, __ S, p5, z1);                  \/\/       frintn  z21.s, p5\/m, z1.s\n-    __ sve_frintp(z10, __ D, p5, z11);                 \/\/       frintp  z10.d, p5\/m, z11.d\n-    __ sve_fsqrt(z23, __ D, p6, z8);                   \/\/       fsqrt   z23.d, p6\/m, z8.d\n-    __ sve_fsub(z17, __ D, p5, z19);                   \/\/       fsub    z17.d, p5\/m, z17.d, z19.d\n-    __ sve_fmad(z4, __ D, p5, z13, z30);               \/\/       fmad    z4.d, p5\/m, z13.d, z30.d\n-    __ sve_fmla(z30, __ D, p7, z25, z17);              \/\/       fmla    z30.d, p7\/m, z25.d, z17.d\n-    __ sve_fmls(z14, __ D, p2, z12, z28);              \/\/       fmls    z14.d, p2\/m, z12.d, z28.d\n-    __ sve_fmsb(z5, __ S, p0, z13, z13);               \/\/       fmsb    z5.s, p0\/m, z13.s, z13.s\n-    __ sve_fnmad(z7, __ S, p2, z11, z19);              \/\/       fnmad   z7.s, p2\/m, z11.s, z19.s\n-    __ sve_fnmsb(z25, __ D, p3, z2, z3);               \/\/       fnmsb   z25.d, p3\/m, z2.d, z3.d\n-    __ sve_fnmla(z0, __ D, p5, z5, z20);               \/\/       fnmla   z0.d, p5\/m, z5.d, z20.d\n-    __ sve_fnmls(z28, __ S, p3, z13, z8);              \/\/       fnmls   z28.s, p3\/m, z13.s, z8.s\n-    __ sve_mla(z29, __ B, p0, z14, z27);               \/\/       mla     z29.b, p0\/m, z14.b, z27.b\n-    __ sve_mls(z3, __ H, p6, z8, z24);                 \/\/       mls     z3.h, p6\/m, z8.h, z24.h\n-    __ sve_and(z1, z25, z10);                          \/\/       and     z1.d, z25.d, z10.d\n-    __ sve_eor(z1, z20, z25);                          \/\/       eor     z1.d, z20.d, z25.d\n-    __ sve_orr(z28, z19, z16);                         \/\/       orr     z28.d, z19.d, z16.d\n-    __ sve_bic(z27, z13, z1);                          \/\/       bic     z27.d, z13.d, z1.d\n-    __ sve_uzp1(z11, __ B, z9, z1);                    \/\/       uzp1    z11.b, z9.b, z1.b\n-    __ sve_uzp2(z1, __ H, z27, z26);                   \/\/       uzp2    z1.h, z27.h, z26.h\n-    __ sve_fabd(z2, __ D, p1, z29);                    \/\/       fabd    z2.d, p1\/m, z2.d, z29.d\n-    __ sve_bext(z24, __ D, z2, z2);                    \/\/       bext    z24.d, z2.d, z2.d\n-    __ sve_bdep(z3, __ H, z25, z28);                   \/\/       bdep    z3.h, z25.h, z28.h\n-    __ sve_eor3(z3, z22, z13);                         \/\/       eor3    z3.d, z3.d, z22.d, z13.d\n+    __ sve_add(z16, __ B, z17, z21);                   \/\/       add     z16.b, z17.b, z21.b\n+    __ sve_sub(z4, __ H, z2, z23);                     \/\/       sub     z4.h, z2.h, z23.h\n+    __ sve_fadd(z6, __ S, z11, z20);                   \/\/       fadd    z6.s, z11.s, z20.s\n+    __ sve_fmul(z16, __ S, z29, z12);                  \/\/       fmul    z16.s, z29.s, z12.s\n+    __ sve_fsub(z3, __ S, z22, z9);                    \/\/       fsub    z3.s, z22.s, z9.s\n+    __ sve_abs(z24, __ S, p7, z3);                     \/\/       abs     z24.s, p7\/m, z3.s\n+    __ sve_add(z22, __ S, p1, z25);                    \/\/       add     z22.s, p1\/m, z22.s, z25.s\n+    __ sve_and(z13, __ D, p1, z7);                     \/\/       and     z13.d, p1\/m, z13.d, z7.d\n+    __ sve_asr(z5, __ S, p5, z17);                     \/\/       asr     z5.s, p5\/m, z5.s, z17.s\n+    __ sve_bic(z0, __ S, p0, z9);                      \/\/       bic     z0.s, p0\/m, z0.s, z9.s\n+    __ sve_clz(z11, __ H, p2, z11);                    \/\/       clz     z11.h, p2\/m, z11.h\n+    __ sve_cnt(z17, __ H, p4, z11);                    \/\/       cnt     z17.h, p4\/m, z11.h\n+    __ sve_eor(z24, __ S, p4, z30);                    \/\/       eor     z24.s, p4\/m, z24.s, z30.s\n+    __ sve_lsl(z8, __ D, p4, z14);                     \/\/       lsl     z8.d, p4\/m, z8.d, z14.d\n+    __ sve_lsr(z22, __ H, p7, z22);                    \/\/       lsr     z22.h, p7\/m, z22.h, z22.h\n+    __ sve_mul(z8, __ D, p1, z27);                     \/\/       mul     z8.d, p1\/m, z8.d, z27.d\n+    __ sve_neg(z10, __ D, p0, z14);                    \/\/       neg     z10.d, p0\/m, z14.d\n+    __ sve_not(z21, __ B, p5, z0);                     \/\/       not     z21.b, p5\/m, z0.b\n+    __ sve_orr(z22, __ D, p6, z5);                     \/\/       orr     z22.d, p6\/m, z22.d, z5.d\n+    __ sve_rbit(z29, __ B, p4, z17);                   \/\/       rbit    z29.b, p4\/m, z17.b\n+    __ sve_revb(z12, __ S, p3, z29);                   \/\/       revb    z12.s, p3\/m, z29.s\n+    __ sve_smax(z0, __ D, p4, z2);                     \/\/       smax    z0.d, p4\/m, z0.d, z2.d\n+    __ sve_smin(z20, __ D, p5, z21);                   \/\/       smin    z20.d, p5\/m, z20.d, z21.d\n+    __ sve_sub(z12, __ B, p2, z2);                     \/\/       sub     z12.b, p2\/m, z12.b, z2.b\n+    __ sve_fabs(z14, __ S, p5, z22);                   \/\/       fabs    z14.s, p5\/m, z22.s\n+    __ sve_fadd(z19, __ D, p6, z26);                   \/\/       fadd    z19.d, p6\/m, z19.d, z26.d\n+    __ sve_fdiv(z12, __ S, p5, z21);                   \/\/       fdiv    z12.s, p5\/m, z12.s, z21.s\n+    __ sve_fmax(z1, __ S, p2, z19);                    \/\/       fmax    z1.s, p2\/m, z1.s, z19.s\n+    __ sve_fmin(z19, __ S, p6, z23);                   \/\/       fmin    z19.s, p6\/m, z19.s, z23.s\n+    __ sve_fmul(z30, __ D, p4, z19);                   \/\/       fmul    z30.d, p4\/m, z30.d, z19.d\n+    __ sve_fneg(z20, __ S, p1, z20);                   \/\/       fneg    z20.s, p1\/m, z20.s\n+    __ sve_frintm(z30, __ D, p5, z30);                 \/\/       frintm  z30.d, p5\/m, z30.d\n+    __ sve_frintn(z25, __ S, p4, z17);                 \/\/       frintn  z25.s, p4\/m, z17.s\n+    __ sve_frintp(z11, __ D, p3, z28);                 \/\/       frintp  z11.d, p3\/m, z28.d\n+    __ sve_fsqrt(z5, __ S, p0, z13);                   \/\/       fsqrt   z5.s, p0\/m, z13.s\n+    __ sve_fsub(z2, __ S, p1, z10);                    \/\/       fsub    z2.s, p1\/m, z2.s, z10.s\n+    __ sve_fmad(z19, __ S, p1, z25, z15);              \/\/       fmad    z19.s, p1\/m, z25.s, z15.s\n+    __ sve_fmla(z3, __ S, p7, z0, z20);                \/\/       fmla    z3.s, p7\/m, z0.s, z20.s\n+    __ sve_fmls(z20, __ S, p7, z28, z13);              \/\/       fmls    z20.s, p7\/m, z28.s, z13.s\n+    __ sve_fmsb(z8, __ S, p3, z29, z1);                \/\/       fmsb    z8.s, p3\/m, z29.s, z1.s\n+    __ sve_fnmad(z27, __ S, p0, z3, z25);              \/\/       fnmad   z27.s, p0\/m, z3.s, z25.s\n+    __ sve_fnmsb(z24, __ S, p2, z1, z25);              \/\/       fnmsb   z24.s, p2\/m, z1.s, z25.s\n+    __ sve_fnmla(z14, __ S, p0, z20, z25);             \/\/       fnmla   z14.s, p0\/m, z20.s, z25.s\n+    __ sve_fnmls(z28, __ D, p5, z16, z6);              \/\/       fnmls   z28.d, p5\/m, z16.d, z6.d\n+    __ sve_mla(z13, __ H, p0, z28, z11);               \/\/       mla     z13.h, p0\/m, z28.h, z11.h\n+    __ sve_mls(z1, __ D, p0, z1, z27);                 \/\/       mls     z1.d, p0\/m, z1.d, z27.d\n+    __ sve_and(z14, z2, z4);                           \/\/       and     z14.d, z2.d, z4.d\n+    __ sve_eor(z17, z24, z2);                          \/\/       eor     z17.d, z24.d, z2.d\n+    __ sve_orr(z24, z3, z25);                          \/\/       orr     z24.d, z3.d, z25.d\n+    __ sve_bic(z13, z3, z22);                          \/\/       bic     z13.d, z3.d, z22.d\n+    __ sve_uzp1(z15, __ B, z27, z16);                  \/\/       uzp1    z15.b, z27.b, z16.b\n+    __ sve_uzp2(z11, __ B, z26, z15);                  \/\/       uzp2    z11.b, z26.b, z15.b\n+    __ sve_fabd(z15, __ S, p0, z27);                   \/\/       fabd    z15.s, p0\/m, z15.s, z27.s\n+    __ sve_bext(z22, __ S, z30, z27);                  \/\/       bext    z22.s, z30.s, z27.s\n+    __ sve_bdep(z10, __ D, z21, z16);                  \/\/       bdep    z10.d, z21.d, z16.d\n+    __ sve_eor3(z7, z21, z4);                          \/\/       eor3    z7.d, z7.d, z21.d, z4.d\n@@ -1274,9 +1282,9 @@\n-    __ sve_andv(v27, __ H, p4, z4);                    \/\/       andv h27, p4, z4.h\n-    __ sve_orv(v26, __ S, p4, z2);                     \/\/       orv s26, p4, z2.s\n-    __ sve_eorv(v1, __ S, p7, z7);                     \/\/       eorv s1, p7, z7.s\n-    __ sve_smaxv(v30, __ H, p7, z16);                  \/\/       smaxv h30, p7, z16.h\n-    __ sve_sminv(v21, __ B, p4, z28);                  \/\/       sminv b21, p4, z28.b\n-    __ sve_fminv(v21, __ D, p1, z12);                  \/\/       fminv d21, p1, z12.d\n-    __ sve_fmaxv(v11, __ S, p2, z10);                  \/\/       fmaxv s11, p2, z10.s\n-    __ sve_fadda(v0, __ D, p1, z22);                   \/\/       fadda d0, p1, d0, z22.d\n-    __ sve_uaddv(v20, __ H, p1, z3);                   \/\/       uaddv d20, p1, z3.h\n+    __ sve_andv(v24, __ H, p2, z8);                    \/\/       andv h24, p2, z8.h\n+    __ sve_orv(v11, __ S, p0, z4);                     \/\/       orv s11, p0, z4.s\n+    __ sve_eorv(v21, __ B, p5, z4);                    \/\/       eorv b21, p5, z4.b\n+    __ sve_smaxv(v15, __ D, p3, z3);                   \/\/       smaxv d15, p3, z3.d\n+    __ sve_sminv(v25, __ S, p6, z5);                   \/\/       sminv s25, p6, z5.s\n+    __ sve_fminv(v25, __ S, p2, z30);                  \/\/       fminv s25, p2, z30.s\n+    __ sve_fmaxv(v24, __ S, p1, z7);                   \/\/       fmaxv s24, p1, z7.s\n+    __ sve_fadda(v3, __ D, p5, z7);                    \/\/       fadda d3, p5, d3, z7.d\n+    __ sve_uaddv(v23, __ D, p7, z24);                  \/\/       uaddv d23, p7, z24.d\n@@ -1301,7 +1309,7 @@\n-    0x14000000,     0x17ffffd7,     0x14000428,     0x94000000,\n-    0x97ffffd4,     0x94000425,     0x3400000a,     0x34fffa2a,\n-    0x3400844a,     0x35000008,     0x35fff9c8,     0x350083e8,\n-    0xb400000b,     0xb4fff96b,     0xb400838b,     0xb500001d,\n-    0xb5fff91d,     0xb500833d,     0x10000013,     0x10fff8b3,\n-    0x100082d3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36308256,     0x3758000c,     0x375ff7cc,     0x375881ec,\n+    0x14000000,     0x17ffffd7,     0x14000430,     0x94000000,\n+    0x97ffffd4,     0x9400042d,     0x3400000a,     0x34fffa2a,\n+    0x3400854a,     0x35000008,     0x35fff9c8,     0x350084e8,\n+    0xb400000b,     0xb4fff96b,     0xb400848b,     0xb500001d,\n+    0xb5fff91d,     0xb500843d,     0x10000013,     0x10fff8b3,\n+    0x100083d3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36308356,     0x3758000c,     0x375ff7cc,     0x375882ec,\n@@ -1312,13 +1320,13 @@\n-    0x54007fc0,     0x54000001,     0x54fff541,     0x54007f61,\n-    0x54000002,     0x54fff4e2,     0x54007f02,     0x54000002,\n-    0x54fff482,     0x54007ea2,     0x54000003,     0x54fff423,\n-    0x54007e43,     0x54000003,     0x54fff3c3,     0x54007de3,\n-    0x54000004,     0x54fff364,     0x54007d84,     0x54000005,\n-    0x54fff305,     0x54007d25,     0x54000006,     0x54fff2a6,\n-    0x54007cc6,     0x54000007,     0x54fff247,     0x54007c67,\n-    0x54000008,     0x54fff1e8,     0x54007c08,     0x54000009,\n-    0x54fff189,     0x54007ba9,     0x5400000a,     0x54fff12a,\n-    0x54007b4a,     0x5400000b,     0x54fff0cb,     0x54007aeb,\n-    0x5400000c,     0x54fff06c,     0x54007a8c,     0x5400000d,\n-    0x54fff00d,     0x54007a2d,     0x5400000e,     0x54ffefae,\n-    0x540079ce,     0x5400000f,     0x54ffef4f,     0x5400796f,\n+    0x540080c0,     0x54000001,     0x54fff541,     0x54008061,\n+    0x54000002,     0x54fff4e2,     0x54008002,     0x54000002,\n+    0x54fff482,     0x54007fa2,     0x54000003,     0x54fff423,\n+    0x54007f43,     0x54000003,     0x54fff3c3,     0x54007ee3,\n+    0x54000004,     0x54fff364,     0x54007e84,     0x54000005,\n+    0x54fff305,     0x54007e25,     0x54000006,     0x54fff2a6,\n+    0x54007dc6,     0x54000007,     0x54fff247,     0x54007d67,\n+    0x54000008,     0x54fff1e8,     0x54007d08,     0x54000009,\n+    0x54fff189,     0x54007ca9,     0x5400000a,     0x54fff12a,\n+    0x54007c4a,     0x5400000b,     0x54fff0cb,     0x54007beb,\n+    0x5400000c,     0x54fff06c,     0x54007b8c,     0x5400000d,\n+    0x54fff00d,     0x54007b2d,     0x5400000e,     0x54ffefae,\n+    0x54007ace,     0x5400000f,     0x54ffef4f,     0x54007a6f,\n@@ -1386,76 +1394,78 @@\n-    0x9bae275e,     0x9ba7954d,     0x7ea3d5fd,     0x1e2f098b,\n-    0x1e311bde,     0x1e2f2a93,     0x1e35392f,     0x7efbd522,\n-    0x1e7e0ba7,     0x1e621831,     0x1e632946,     0x1e673978,\n-    0x1f000d61,     0x1f06db91,     0x1f3b6806,     0x1f2770a2,\n-    0x1f4d2f2b,     0x1f48c677,     0x1f744f35,     0x1f7d5851,\n-    0x1e2042a8,     0x1e20c293,     0x1e21422b,     0x1e21c0d4,\n-    0x1e22c06f,     0x1e23c383,     0x1ee24363,     0x1e6041ce,\n-    0x1e60c18a,     0x1e61422b,     0x1e61c32a,     0x1e6240e7,\n-    0x1e38038e,     0x9e3802c0,     0x1e780180,     0x9e7801b7,\n-    0x1e2200ed,     0x9e2200ee,     0x1e620288,     0x9e620391,\n-    0x1e24021e,     0x9e640122,     0x1e300290,     0x9e70009d,\n-    0x1e260341,     0x9e6602f8,     0x1e2702ae,     0x9e6700ac,\n-    0x1e382180,     0x1e7d2300,     0x1e202368,     0x1e6022a8,\n-    0x293a1796,     0x29426e73,     0x697c68fc,     0xa93d0486,\n-    0xa97b5eba,     0x29b47934,     0x29c2534d,     0x69f62dbd,\n-    0xa9bd54bb,     0xa9c503c6,     0x28a63e13,     0x28e25d2c,\n-    0x68c469e0,     0xa8b34748,     0xa8f51c59,     0x28264433,\n-    0x285036c0,     0xa8005f7d,     0xa872290b,     0x0c407160,\n-    0x4cdfa350,     0x0cd16f55,     0x4cdf27ba,     0x0d40c0d5,\n-    0x4ddfcbad,     0x0dd0cd95,     0x4c408c01,     0x0cdf86a9,\n-    0x4d60c327,     0x0dffc928,     0x4deecd89,     0x4cd14887,\n-    0x0c404a37,     0x4d40e6c3,     0x4ddfe84c,     0x0dcced4f,\n-    0x4cdf0444,     0x0ccb0286,     0x0d60e18b,     0x0dffe62f,\n-    0x0df0eb2e,     0x0e31bab4,     0x4e31b841,     0x0e71baf6,\n-    0x4e71bbfe,     0x4eb1b9ee,     0x0e30a862,     0x4e30a8e6,\n-    0x0e70a883,     0x4e70a907,     0x4eb0ab38,     0x6e30f820,\n-    0x0e31ab9b,     0x2e31abdd,     0x4e31a8c5,     0x6e31a8c5,\n-    0x0e71abdd,     0x2e71a98b,     0x4e71ab59,     0x6e71a820,\n-    0x4eb1abfe,     0x6eb1a820,     0x6eb0fa51,     0x7e30fbbc,\n-    0x7e70fb59,     0x7eb0f949,     0x7ef0fb59,     0x0ea0c9ac,\n-    0x4ea0ca0f,     0x4ee0c98b,     0x2ea0c96a,     0x6ea0ca51,\n-    0x6ee0cb38,     0x0ea0dad5,     0x4ea0db17,     0x4ee0d820,\n-    0x0ea0ea30,     0x4ea0e96a,     0x4ee0e8e6,     0x2ea0dbbc,\n-    0x6ea0d8e6,     0x6ee0d8c5,     0x0e20b8c5,     0x4e20bab4,\n-    0x0e60ba51,     0x4e60ba0f,     0x0ea0ba51,     0x4ea0bbdd,\n-    0x4ee0bb7a,     0x0ea0fbbc,     0x4ea0f841,     0x4ee0fb9b,\n-    0x2ea0f820,     0x6ea0fab4,     0x6ee0fbbc,     0x2ea1fa0f,\n-    0x6ea1f9ac,     0x6ee1f96a,     0x2e205bbc,     0x6e205bbc,\n-    0x0e351e93,     0x4e381ef6,     0x0eac1d6a,     0x4ea61ca4,\n-    0x2e201ffe,     0x6e361eb4,     0x0e2a8528,     0x4e2087fe,\n-    0x0e738651,     0x4e6c856a,     0x0ebd879b,     0x4ea48462,\n-    0x4efa8738,     0x0e26d4a4,     0x4e25d483,     0x4e6ad528,\n-    0x2e3886f6,     0x6e338651,     0x2e6f85cd,     0x6e6684a4,\n-    0x2ebe87bc,     0x6eb98717,     0x6ef786d5,     0x0ebbd759,\n-    0x4ebad738,     0x4ee5d483,     0x0e399f17,     0x4e3c9f7a,\n-    0x0e799f17,     0x4e709dee,     0x0eb79ed5,     0x4ea59c83,\n-    0x2eb9d717,     0x6eaad528,     0x6efad738,     0x2e35d693,\n-    0x6e31d60f,     0x6e72d630,     0x2e24dc62,     0x6e23dc41,\n-    0x6e62dc20,     0x0e7a9738,     0x4e6694a4,     0x0ea59483,\n-    0x4ead958b,     0x0e20cffe,     0x4e3dcf9b,     0x4e6bcd49,\n-    0x2e7b9759,     0x6e649462,     0x2eae95ac,     0x6eb39651,\n-    0x0ea0cffe,     0x4ea3cc41,     0x4eeecdac,     0x2e3effbc,\n-    0x6e22fc20,     0x6e73fe51,     0x0e2e65ac,     0x4e336651,\n-    0x0e7766d5,     0x4e6e65ac,     0x0ebd679b,     0x4ebf67dd,\n-    0x0e20a7fe,     0x4e23a441,     0x0e7ba759,     0x4e7da79b,\n-    0x0ea6a4a4,     0x4ebfa7dd,     0x0e25f483,     0x4e28f4e6,\n-    0x4e7ff7dd,     0x0e3b6f59,     0x4e336e51,     0x0e6a6d28,\n-    0x4e696d07,     0x0eae6dac,     0x4ea26c20,     0x0e35ae93,\n-    0x4e23ac41,     0x0e79af17,     0x4e64ac62,     0x0ea2ac20,\n-    0x4eaaad28,     0x0eb9f717,     0x4ebbf759,     0x4ef1f60f,\n-    0x2ebfefdd,     0x6ea5ec83,     0x6eeced6a,     0x0e3836f6,\n-    0x4e2c356a,     0x0e6634a4,     0x4e733651,     0x0ea33441,\n-    0x4ead358b,     0x4ee93507,     0x0e2c3d6a,     0x4e313e0f,\n-    0x0e723e30,     0x4e643c62,     0x0eab3d49,     0x4ead3d8b,\n-    0x4eee3dac,     0x2e308dee,     0x6e2f8dcd,     0x2e648c62,\n-    0x6e688ce6,     0x2eb58e93,     0x6ebb8f59,     0x6ef18e0f,\n-    0x2e2634a4,     0x6e243462,     0x2e6634a4,     0x6e6d358b,\n-    0x2eb33651,     0x6eb636b4,     0x6ef23630,     0x2e333e51,\n-    0x6e2c3d6a,     0x2e763eb4,     0x6e783ef6,     0x2eae3dac,\n-    0x6ebb3f59,     0x6ef93f17,     0x0e3ee7bc,     0x4e30e5ee,\n-    0x4e6ce56a,     0x2ebae738,     0x6ea3e441,     0x6eede58b,\n-    0x2e20e7fe,     0x6e2ce56a,     0x6e71e60f,     0x65922c43,\n-    0x65d02219,     0x65d02560,     0x65d13dc4,     0x65913690,\n-    0x65d33b6b,     0x2500948c,     0x254c08bf,     0x25831f87,\n-    0x254f30af,     0x259c3359,     0x25019d35,     0x24eac76d,\n-    0x2431993a,     0x242f7ed8,     0x24a2f62b,     0xba5fd3e3,\n+    0x9bae275e,     0x9ba7954d,     0x7ec315fd,     0x1eef098b,\n+    0x1ef11bde,     0x1eef2a93,     0x1ef5392f,     0x1efb4922,\n+    0x1efe5ba7,     0x1ee28831,     0x7ea3d546,     0x1e270978,\n+    0x1e201961,     0x1e3c2a23,     0x1e263ac6,     0x7efad760,\n+    0x1e6708a2,     0x1e79197c,     0x1e77296d,     0x1e713913,\n+    0x1f144f35,     0x1f1dd851,     0x1f3352a8,     0x1f341a2b,\n+    0x1f43706f,     0x1f4ebb63,     0x1f6b458a,     0x1f671f2a,\n+    0x1e20438e,     0x1e20c2c0,     0x1e214180,     0x1e21c1b7,\n+    0x1e22c0ed,     0x1e23c0ee,     0x1ee24288,     0x1e604391,\n+    0x1e60c21e,     0x1e614122,     0x1e61c290,     0x1e62409d,\n+    0x1e380341,     0x9e3802f8,     0x1e7802ae,     0x9e7800ac,\n+    0x1e22030c,     0x9e2203b8,     0x1e6202bb,     0x9e6202d0,\n+    0x1e240385,     0x9e640236,     0x1e30026d,     0x9e700373,\n+    0x1e2600d1,     0x9e6600ed,     0x1e27035c,     0x9e6700d1,\n+    0x1e242020,     0x1e7421a0,     0x1e2020c8,     0x1e6022a8,\n+    0x290a3697,     0x295042a4,     0x69703a9a,     0xa9335fb7,\n+    0xa9790376,     0x29aa457a,     0x29ea3974,     0x69fa32e0,\n+    0xa9b75fd7,     0xa9f04507,     0x28882d46,     0x28c84033,\n+    0x68d03680,     0xa8886d97,     0xa8f064ab,     0x28082a30,\n+    0x28682b49,     0xa8083313,     0xa8713b51,     0x0c407211,\n+    0x4cdfa2fe,     0x0cd46d11,     0x4cdf252c,     0x0d40c053,\n+    0x4ddfc915,     0x0dd1cc8d,     0x4c408c7c,     0x0cdf87bd,\n+    0x4d60c027,     0x0dffc811,     0x4de7ccba,     0x4cc54839,\n+    0x0c404856,     0x4d40e76d,     0x4ddfeb1d,     0x0dd5eded,\n+    0x4cdf05cf,     0x0cd7029b,     0x0d60e316,     0x0dffe7dd,\n+    0x0de5e8bc,     0x0e31bb59,     0x4e31b949,     0x0e71bb59,\n+    0x4e71b9ac,     0x4eb1ba0f,     0x0e30a98b,     0x4e30a96a,\n+    0x0e70aa51,     0x4e70ab38,     0x4eb0aad5,     0x6e30fb17,\n+    0x0e31a820,     0x2e31aa30,     0x4e31a96a,     0x6e31a8e6,\n+    0x0e71abbc,     0x2e71a8e6,     0x4e71a8c5,     0x6e71a8c5,\n+    0x4eb1aab4,     0x6eb1aa51,     0x6eb0fa0f,     0x7e30fa51,\n+    0x7e70fbdd,     0x7eb0fb7a,     0x7ef0fbbc,     0x0ea0c841,\n+    0x4ea0cb9b,     0x4ee0c820,     0x2ea0cab4,     0x6ea0cbbc,\n+    0x6ee0ca0f,     0x0ea0d9ac,     0x4ea0d96a,     0x4ee0dbbc,\n+    0x0ea0ebbc,     0x4ea0ea93,     0x4ee0eaf6,     0x2ea0d96a,\n+    0x6ea0d8a4,     0x6ee0dbfe,     0x0e20bab4,     0x4e20b928,\n+    0x0e60bbfe,     0x4e60ba51,     0x0ea0b96a,     0x4ea0bb9b,\n+    0x4ee0b862,     0x0ea0fb38,     0x4ea0f8a4,     0x4ee0f883,\n+    0x2ea0f928,     0x6ea0faf6,     0x6ee0fa51,     0x2ea1f9cd,\n+    0x6ea1f8a4,     0x6ee1fbbc,     0x2e205b17,     0x6e205ad5,\n+    0x0e3b1f59,     0x4e3a1f38,     0x0ea51c83,     0x4eb91f17,\n+    0x2e3c1f7a,     0x6e391f17,     0x0e3085ee,     0x4e3786d5,\n+    0x0e658483,     0x4e798717,     0x0eaa8528,     0x4eba8738,\n+    0x4ef58693,     0x0e31d60f,     0x4e32d630,     0x4e64d462,\n+    0x2e238441,     0x6e228420,     0x2e7a8738,     0x6e6684a4,\n+    0x2ea58483,     0x6ead858b,     0x6ee087fe,     0x0ebdd79b,\n+    0x4eabd549,     0x4efbd759,     0x0e249c62,     0x4e2e9dac,\n+    0x0e739e51,     0x4e609ffe,     0x0ea39c41,     0x4eae9dac,\n+    0x2ebed7bc,     0x6ea2d420,     0x6ef3d651,     0x2e2ed5ac,\n+    0x6e33d651,     0x6e77d6d5,     0x2e2eddac,     0x6e3ddf9b,\n+    0x6e7fdfdd,     0x0e6097fe,     0x4e639441,     0x0ebb9759,\n+    0x4ebd979b,     0x0e26cca4,     0x4e3fcfdd,     0x4e65cc83,\n+    0x2e6894e6,     0x6e7f97dd,     0x2ebb9759,     0x6eb39651,\n+    0x0eaacd28,     0x4ea9cd07,     0x4eeecdac,     0x2e22fc20,\n+    0x6e35fe93,     0x6e63fc41,     0x0e396717,     0x4e246462,\n+    0x0e626420,     0x4e6a6528,     0x0eb96717,     0x4ebb6759,\n+    0x0e31a60f,     0x4e3fa7dd,     0x0e65a483,     0x4e6ca56a,\n+    0x0eb8a6f6,     0x4eaca56a,     0x0e26f4a4,     0x4e33f651,\n+    0x4e63f441,     0x0e2d6d8b,     0x4e296d07,     0x0e6c6d6a,\n+    0x4e716e0f,     0x0eb26e30,     0x4ea46c62,     0x0e2bad49,\n+    0x4e2dad8b,     0x0e6eadac,     0x4e70adee,     0x0eafadcd,\n+    0x4ea4ac62,     0x0ea8f4e6,     0x4eb5f693,     0x4efbf759,\n+    0x2eb1ee0f,     0x6ea6eca4,     0x6ee4ec62,     0x0e2634a4,\n+    0x4e2d358b,     0x0e733651,     0x4e7636b4,     0x0eb23630,\n+    0x4eb33651,     0x4eec356a,     0x0e363eb4,     0x4e383ef6,\n+    0x0e6e3dac,     0x4e7b3f59,     0x0eb93f17,     0x4ebe3fbc,\n+    0x4ef03dee,     0x2e2c8d6a,     0x6e3a8f38,     0x2e638c41,\n+    0x6e6d8d8b,     0x2ea08ffe,     0x6eac8d6a,     0x6ef18e0f,\n+    0x2e293507,     0x6e243462,     0x2e653483,     0x6e6f35cd,\n+    0x2eb53693,     0x6eb23630,     0x6ef23630,     0x2e253c83,\n+    0x6e233c41,     0x2e6d3d8b,     0x6e7f3fdd,     0x2ea73cc5,\n+    0x6eaa3d28,     0x6ef03dee,     0x0e3ee7bc,     0x4e3fe7dd,\n+    0x4e62e420,     0x2eb6e6b4,     0x6ea9e507,     0x6ef6e6b4,\n+    0x2e39e717,     0x6e3de79b,     0x6e77e6d5,     0x6592230d,\n+    0x65d0261b,     0x65d02d06,     0x65d132ae,     0x659130bf,\n+    0x65d3362f,     0x25568988,     0x25ce1e1f,     0x25940943,\n+    0x2593362c,     0x258331de,     0x255c845b,     0x24615548,\n+    0x2422923f,     0x2475aab8,     0x2463bb6e,     0xba5fd3e3,\n@@ -1523,45 +1533,45 @@\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf82f8186,\n-    0xf83001ab,     0xf83713c1,     0xf8332225,     0xf82232d0,\n-    0xf82d52aa,     0xf83d419b,     0xf83b7023,     0xf83f6278,\n-    0xf8b18389,     0xf8bb00ef,     0xf8b513f7,     0xf8b923e2,\n-    0xf8bb3150,     0xf8b75073,     0xf8b04320,     0xf8ba7057,\n-    0xf8b0608c,     0xf8fc83be,     0xf8f000db,     0xf8e911fd,\n-    0xf8e720e4,     0xf8ef32e9,     0xf8e85382,     0xf8f540bf,\n-    0xf8fb7220,     0xf8ef6344,     0xf86882dc,     0xf87b033b,\n-    0xf8771080,     0xf8662010,     0xf864302f,     0xf86a50a7,\n-    0xf86a40fc,     0xf87472b7,     0xf866610b,     0xb83180df,\n-    0xb8310182,     0xb83e107d,     0xb83b23b6,     0xb82e338d,\n-    0xb83150b8,     0xb822414e,     0xb830736b,     0xb837608c,\n-    0xb8b68091,     0xb8a10213,     0xb8b011cd,     0xb8ac2222,\n-    0xb8a332f5,     0xb8a550e6,     0xb8b3438d,     0xb8b170d0,\n-    0xb8a2607d,     0xb8e481e6,     0xb8f4018d,     0xb8f41328,\n-    0xb8f42013,     0xb8eb30d8,     0xb8f451df,     0xb8f04006,\n-    0xb8e7726f,     0xb8fa6149,     0xb87782d5,     0xb87c0062,\n-    0xb86f1293,     0xb86723a4,     0xb8673120,     0xb87052f4,\n-    0xb8644150,     0xb877732b,     0xb866621f,     0xce2b06cd,\n-    0xce14410d,     0xce648df9,     0xce883624,     0xce7c809d,\n-    0xce7a87b0,     0xcec081c9,     0xce7c8962,     0x2520c143,\n-    0x25a1d2da,     0x058015ce,     0x05400ed8,     0x0500bb31,\n-    0x25a0c074,     0x25a1d884,     0x05804944,     0x0540b1d9,\n-    0x05001548,     0x25a0c49e,     0x2521cabe,     0x058054b3,\n-    0x0543ab47,     0x050026bb,     0x2560d097,     0x25a1d6fe,\n-    0x058394b4,     0x0540266d,     0x05003cbc,     0x25a0c1ab,\n-    0x2561d3f8,     0x05800acd,     0x05403684,     0x05000c07,\n-    0x2560de64,     0x2521cac5,     0x0583c8b5,     0x05405089,\n-    0x05003e98,     0x04ad0397,     0x04ac074a,     0x658e023e,\n-    0x65d50a1d,     0x65820667,     0x0496b13a,     0x04001411,\n-    0x041a19c2,     0x049095cb,     0x041b0c7d,     0x04d9a876,\n-    0x049aa27b,     0x04591aa7,     0x04138b25,     0x04119235,\n-    0x04500a63,     0x0497adc7,     0x04dea9b1,     0x04581e31,\n-    0x05a78f4f,     0x056494fb,     0x04481f65,     0x048a0f00,\n-    0x04810074,     0x04dca739,     0x65809031,     0x658d9dae,\n-    0x65c683d1,     0x658797b6,     0x65828008,     0x04ddb417,\n-    0x6582baf9,     0x6580b435,     0x65c1b56a,     0x65cdb917,\n-    0x65c19671,     0x65fe95a4,     0x65f11f3e,     0x65fc298e,\n-    0x65ada1a5,     0x65b3c967,     0x65e3ec59,     0x65f454a0,\n-    0x65a86dbc,     0x041b41dd,     0x04587903,     0x042a3321,\n-    0x04b93281,     0x0470327c,     0x04e131bb,     0x0521692b,\n-    0x057a6f61,     0x65c887a2,     0x45c2b058,     0x455cb723,\n-    0x043639a3,     0x045a309b,     0x0498305a,     0x04993ce1,\n-    0x04483e1e,     0x040a3395,     0x65c72595,     0x6586294b,\n-    0x65d826c0,     0x04412474,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf821831f,\n+    0xf8330131,     0xf83c11fb,     0xf82722f5,     0xf83f3059,\n+    0xf83f51fb,     0xf82a4277,     0xf8237010,     0xf83962fa,\n+    0xf8a28190,     0xf8a403dc,     0xf8bd1370,     0xf8a623a9,\n+    0xf8b03087,     0xf8a7512f,     0xf8b74048,     0xf8bc73f5,\n+    0xf8a5601b,     0xf8f1808f,     0xf8fa0388,     0xf8f6137b,\n+    0xf8f92017,     0xf8e431e6,     0xf8e051e4,     0xf8e140ea,\n+    0xf8e5738a,     0xf8e762f4,     0xf8758166,     0xf86803f1,\n+    0xf8661051,     0xf86c23be,     0xf86332db,     0xf87d51ae,\n+    0xf87c4311,     0xf86571c2,     0xf86a6170,     0xb83b8197,\n+    0xb8240236,     0xb8241261,     0xb83021b0,     0xb82e304c,\n+    0xb83152a3,     0xb83740c5,     0xb82771b3,     0xb83c6211,\n+    0xb8a683a2,     0xb8a300c4,     0xb8b011b4,     0xb8ac2114,\n+    0xb8b93274,     0xb8a0530b,     0xb8a643f4,     0xb8ae70d0,\n+    0xb8a061e7,     0xb8f3813a,     0xb8ea02b7,     0xb8f6105c,\n+    0xb8e3226f,     0xb8f43087,     0xb8fd5007,     0xb8e94290,\n+    0xb8f77204,     0xb8ea6177,     0xb87983e6,     0xb87002ed,\n+    0xb86c11c1,     0xb8692215,     0xb87a308f,     0xb8645110,\n+    0xb866409e,     0xb87d73b1,     0xb87a61e9,     0xce3c0d62,\n+    0xce1a5427,     0xce688dd1,     0xce982ab1,     0xce7182b3,\n+    0xce7d8616,     0xcec08274,     0xce718880,     0x2520d477,\n+    0x25e1da44,     0x05801e33,     0x05439f2e,     0x05000615,\n+    0x25a0cc6a,     0x2561c7a0,     0x05807338,     0x05401d06,\n+    0x0500334d,     0x25a0df96,     0x2561ce3c,     0x058026b3,\n+    0x05406529,     0x05001e33,     0x2560d393,     0x25a1c531,\n+    0x05801e20,     0x054004ef,     0x0502000f,     0x25a0db8a,\n+    0x2521c9e3,     0x058287b3,     0x05404943,     0x05004cbc,\n+    0x2560d2ba,     0x25a1ce7e,     0x05825a82,     0x05403634,\n+    0x050394a1,     0x04350230,     0x04770444,     0x65940166,\n+    0x658c0bb0,     0x658906c3,     0x0496bc78,     0x04800736,\n+    0x04da04ed,     0x04909625,     0x049b0120,     0x0459a96b,\n+    0x045ab171,     0x049913d8,     0x04d391c8,     0x04519ed6,\n+    0x04d00768,     0x04d7a1ca,     0x041eb415,     0x04d818b6,\n+    0x0527923d,     0x05a48fac,     0x04c81040,     0x04ca16b4,\n+    0x0401084c,     0x049cb6ce,     0x65c09b53,     0x658d96ac,\n+    0x65868a61,     0x65879af3,     0x65c2927e,     0x049da694,\n+    0x65c2b7de,     0x6580b239,     0x65c1af8b,     0x658da1a5,\n+    0x65818542,     0x65af8733,     0x65b41c03,     0x65ad3f94,\n+    0x65a1afa8,     0x65b9c07b,     0x65b9e838,     0x65b9428e,\n+    0x65e6761c,     0x044b438d,     0x04db6021,     0x0424304e,\n+    0x04a23311,     0x04793078,     0x04f6306d,     0x05306b6f,\n+    0x052f6f4b,     0x6588836f,     0x459bb3d6,     0x45d0b6aa,\n+    0x04353887,     0x045a2918,     0x0498208b,     0x04193495,\n+    0x04c82c6f,     0x048a38b9,     0x65872bd9,     0x658624f8,\n+    0x65d834e3,     0x04c13f17,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":619,"deletions":609,"binary":false,"changes":1228,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import static java.lang.Float16.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8336406\n+ * @summary Test that Ideal transformations of MulHFNode are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.MulHFNodeIdealizationTests\n+ *\/\n+public class MulHFNodeIdealizationTests {\n+\n+    private Float16 src;\n+    private Float16 dst;\n+    private Random rng;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--enable-preview\");\n+    }\n+\n+    public MulHFNodeIdealizationTests() {\n+        rng = new Random(25);\n+        src = Float16.valueOf(rng.nextFloat());\n+        dst = Float16.valueOf(rng.nextFloat());\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \"1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"},\n+        failOn = {IRNode.MUL_HF})\n+    public void test1() {\n+        dst = Float16.multiply(src, Float16.valueOf(2.0f));\n+    }\n+\n+    @Check(test=\"test1\")\n+    public void checkTest1() {\n+        Float16 expected = Float16.valueOf(src.floatValue() * 2.0f);\n+        if (float16ToRawShortBits(expected) != float16ToRawShortBits(dst)) {\n+            throw new RuntimeException(\"Invalid result: dst = \" + float16ToRawShortBits(dst) + \" != \" + float16ToRawShortBits(expected));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8308363 8336406\n+* @summary Validate compiler IR for FP16 scalar operations.\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver TestFP16ScalarOps\n+*\/\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static java.lang.Float16.*;\n+\n+public class TestFP16ScalarOps {\n+    private static final int count = 1024;\n+\n+    private short[] src;\n+    private short[] dst;\n+    private short res;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--enable-preview\");\n+    }\n+\n+    public TestFP16ScalarOps() {\n+        src = new short[count];\n+        dst = new short[count];\n+        for (int i = 0; i < count; i++) {\n+            src[i] = Float.floatToFloat16(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testAdd1() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.add(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testAdd2() {\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        res = float16ToRawShortBits(Float16.add(Float16.add(Float16.add(Float16.add(hf0, hf1), hf2), hf3), hf4));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.SUB_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testSub() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.subtract(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.MUL_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMul() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.multiply(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.DIV_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testDiv() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.divide(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.MAX_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMax() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.max(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.MIN_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMin() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.min(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFP16ScalarOps.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -222,0 +222,5 @@\n+    public static final String ADD_HF = PREFIX + \"ADD_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_HF, \"AddHF\");\n+    }\n+\n@@ -237,0 +242,5 @@\n+    public static final String ADD_VHF = PREFIX + \"ADD_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VHF, \"AddVHF\");\n+    }\n+\n@@ -465,0 +475,5 @@\n+    public static final String CONV_HF2F = PREFIX + \"CONV_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_HF2F, \"ConvHF2F\");\n+    }\n+\n@@ -875,0 +890,5 @@\n+    public static final String MAX_VHF = PREFIX + \"MAX_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_VHF, \"MaxVHF\");\n+    }\n+\n@@ -925,0 +945,10 @@\n+    public static final String MIN_HF = PREFIX + \"MIN_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_HF, \"MinHF\");\n+    }\n+\n+    public static final String MAX_HF = PREFIX + \"MAX_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_HF, \"MaxHF\");\n+    }\n+\n@@ -940,0 +970,5 @@\n+    public static final String MIN_VHF = PREFIX + \"MIN_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_VHF, \"MinVHF\");\n+    }\n+\n@@ -976,0 +1011,5 @@\n+    public static final String MUL_HF = PREFIX + \"MUL_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HF, \"MulHF\");\n+    }\n+\n@@ -1001,0 +1041,5 @@\n+    public static final String MUL_VHF = PREFIX + \"MUL_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VHF, \"MulVHF\");\n+    }\n+\n@@ -1160,0 +1205,10 @@\n+    public static final String REINTERPRET_S2HF = PREFIX + \"REINTERPRET_S2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_S2HF, \"ReinterpretS2HF\");\n+    }\n+\n+    public static final String REINTERPRET_HF2S = PREFIX + \"REINTERPRET_HF2S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_HF2S, \"ReinterpretHF2S\");\n+    }\n+\n@@ -1462,0 +1517,5 @@\n+    public static final String SUB_HF = PREFIX + \"SUB_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_HF, \"SubHF\");\n+    }\n+\n@@ -1497,0 +1557,5 @@\n+    public static final String SUB_VHF = PREFIX + \"SUB_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_VHF, \"SubVHF\");\n+    }\n+\n@@ -1512,0 +1577,10 @@\n+    public static final String DIV_HF = PREFIX + \"DIV_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_HF, \"DivHF\");\n+    }\n+\n+    public static final String DIV_VHF = PREFIX + \"DIV_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_VHF, \"DivVHF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import compiler.lib.ir_framework.IRNode;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/raw\/RawFailOnConstraint.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+        \"avx512_fp16\",\n@@ -105,1 +106,3 @@\n-        \"sve\"\n+        \"sve\",\n+        \"fphp\",\n+        \"asimdhp\"\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8333852\n+* @summary Test NullPointerException generation on null value assignment to flat arrays.\n+* @enablePreview\n+* @library \/test\/lib \/\n+* @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED TestFlatArrayNullAssignment.java\n+* @run main\/othervm --enable-preview -Xint compiler.valhalla.inlinetypes.TestFlatArrayNullAssignment\n+* @run main\/othervm --enable-preview -XX:TieredStopAtLevel=3 -Xbatch compiler.valhalla.inlinetypes.TestFlatArrayNullAssignment\n+* @run main\/othervm --enable-preview -XX:-TieredCompilation -Xbatch compiler.valhalla.inlinetypes.TestFlatArrayNullAssignment\n+*\/\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestrictedArray;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+@NullRestrictedArray\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue {\n+   public int field;\n+   MyValue(int field_val) {\n+      field = field_val;\n+   }\n+}\n+\n+public class TestFlatArrayNullAssignment {\n+  public static void test(int i) {\n+      MyValue [] varr = new MyValue[16];\n+      \/\/ C2 will treat it as UCT and de-optimize, Interpreter will throw NPE.\n+      if (i == 15000) {\n+          varr[1] = null;\n+      }\n+  }\n+  public static void main(String [] args) {\n+     try {\n+         for (int i = 0; i < 100000; i++) {\n+           test(i);\n+         }\n+         throw new AssertionError(\"NullPointerException Expected\");\n+     } catch (NullPointerException e) {\n+         System.out.println(e);\n+         System.out.println(\"PASSED\");\n+     }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatArrayNullAssignment.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8333852\n+* @summary Allow flat array layout for implicitly constructible value classes.\n+* @requires vm.compiler2.enabled\n+* @enablePreview\n+* @library \/test\/lib \/\n+* @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED TestFlatArrayVectorization.java\n+* @run main\/othervm --enable-preview compiler.valhalla.inlinetypes.TestFlatArrayVectorization\n+*\/\n+\n+package compiler.valhalla.inlinetypes;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestrictedArray;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+@ImplicitlyConstructible\n+@NullRestrictedArray\n+@LooselyConsistentValue\n+value class SimpleValue {\n+   int field;\n+   public SimpleValue(int field) {\n+      this.field = field;\n+   }\n+}\n+\n+public class TestFlatArrayVectorization {\n+   public static SimpleValue [] varr;\n+   public static final int SIZE = 2048;\n+   public static final int SIZE_M1 = SIZE - 1;\n+   public static int res = 0;\n+   public static Random rd = new Random(2048);\n+\n+   \/\/public static int test(int ctr) {\n+   @Test\n+   @IR(counts = {IRNode.POPULATE_INDEX, \" > 0\"}, applyIf = {\"EnableValhalla\", \"true\"})\n+   public static int test() {\n+      varr = new SimpleValue [SIZE];    \/\/ ANEWARRAY\n+      for (int i = 0; i < varr.length; i++) {\n+          varr[i] = new SimpleValue(i); \/\/ AASTORE\n+      }\n+      return varr[rd.nextInt(2047)].field;\n+   }\n+\n+   public static void main(String [] args) {\n+      TestFramework.runWithFlags(\"--enable-preview\", \"-Xbatch\", \"-XX:-TieredCompilation\", \"-XX:-UseOnStackReplacement\", \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\");\n+   }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatArrayVectorization.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8308363 8336406\n+* @summary Test vectorization of Float16 binary operations\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @compile TestFloat16VectorOps.java\n+* @run driver compiler.vectorization.TestFloat16VectorOps\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static java.lang.Float16.*;\n+\n+public class TestFloat16VectorOps {\n+    private Float16[] input;\n+    private Float16[] output;\n+    private static final int LEN = 2048;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--enable-preview\", \"-XX:-TieredCompilation\", \"-Xbatch\");\n+    }\n+\n+    public TestFloat16VectorOps() {\n+        input  = new Float16[LEN];\n+        output = new Float16[LEN];\n+        rng = new Random(42);\n+        for (int i = 0; i < LEN; ++i) {\n+            input[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorAddFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.add(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorAddFloat16\")\n+    public void checkResultAdd() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.add(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorSubFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.subtract(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubFloat16\")\n+    public void checkResultSub() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.subtract(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMulFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.multiply(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulFloat16\")\n+    public void checkResultMul() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.multiply(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorDivFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.divide(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivFloat16\")\n+    public void checkResultDiv() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.divide(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMinFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.min(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinFloat16\")\n+    public void checkResultMin() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.min(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMaxFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.max(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxFloat16\")\n+    public void checkResultMax() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.max(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOps.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8330021\n+* @summary Test auto-vectorization for \"dst (ConvHF2F (ReinterpretHF2S src))\" sequence\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorization.TestFloat16VectorReinterpretConv\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static java.lang.Float16.*;\n+\n+public class TestFloat16VectorReinterpretConv {\n+    private Float16[] fin;\n+    private float[] flout;\n+    private static final int LEN = 2048;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--enable-preview\", \"-XX:-TieredCompilation\", \"-Xbatch\");\n+    }\n+\n+    public TestFloat16VectorReinterpretConv() {\n+        fin  = new Float16[LEN];\n+        flout = new float[LEN];\n+        rng = new Random(25);\n+        for (int i = 0; i < LEN; i++) {\n+            fin[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n+        }\n+    }\n+\n+    \/\/ When auto-vectorizing a sequence like - \"dst (ConvHF2F (ReinterpretHF2S src))\", the compilation\n+    \/\/ fails due to an assertion error when testing for the source type in vectorCastNode::opcode() for\n+    \/\/ Op_ConvHF2F. The input passed to ConvHF2F is of type T_INT but is supposed to be of type T_SHORT. It is\n+    \/\/ because the container type for ReinterpretHF2S is computed as T_INT instead of T_SHORT. Fix for this\n+    \/\/ is part of JDK-8330021 and this test makes sure the compilation does not fail and vectorization of both\n+    \/\/ ConvHF2F and ReinterpretHF2S takes place.\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, \" >= 1\", IRNode.VECTOR_REINTERPRET, \" >= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, \" >= 1\", IRNode.VECTOR_REINTERPRET, \" >= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testVect() {\n+        for (int i = 0; i < LEN; i++) {\n+            flout[i] = Float16.add(fin[i], fin[i]).floatValue();\n+        }\n+    }\n+\n+    @Check(test=\"testVect\")\n+    public void checkResult() {\n+        for (int i = 0; i < LEN; i++) {\n+            float expected = fin[i].floatValue() + fin[i].floatValue();\n+            if (flout[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: flout[\" + i + \"] = \" + flout[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorReinterpretConv.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, boolean trivial, String threadLocalName, Consumer<Object> resultCheck) {}\n@@ -68,2 +68,6 @@\n-        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n+        if (testCase.trivial()) {\n+            options.add(Linker.Option.isTrivial());\n+        }\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), options.toArray(Linker.Option[]::new));\n@@ -102,0 +106,4 @@\n+    interface CaseAdder {\n+      void addCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck);\n+    }\n+\n@@ -105,0 +113,4 @@\n+        CaseAdder adder = (nativeTarget, nativeDesc, threadLocalName, resultCheck) -> {\n+          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, false, threadLocalName, resultCheck));\n+          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, true, threadLocalName, resultCheck));\n+        };\n@@ -106,16 +118,16 @@\n-        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n-        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n-        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n-\n-        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n-        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                           JAVA_LONG.withName(\"y\"), 42L)));\n-        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                            JAVA_LONG.withName(\"y\"), 42L,\n-                                            JAVA_LONG.withName(\"z\"), 42L)));\n-        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n-        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n-        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n+        adder.addCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {});\n+        adder.addCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42));\n+        adder.addCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0));\n+\n+        structCase(adder, \"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L));\n+        structCase(adder, \"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                         JAVA_LONG.withName(\"y\"), 42L));\n+        structCase(adder, \"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                         JAVA_LONG.withName(\"y\"), 42L,\n+                                         JAVA_LONG.withName(\"z\"), 42L));\n+        structCase(adder, \"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D));\n+        structCase(adder, \"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                         JAVA_DOUBLE.withName(\"y\"), 42D));\n+        structCase(adder, \"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                         JAVA_DOUBLE.withName(\"y\"), 42D,\n+                                         JAVA_DOUBLE.withName(\"z\"), 42D));\n@@ -124,2 +136,2 @@\n-            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n-            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n+            adder.addCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {});\n+            adder.addCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {});\n@@ -131,1 +143,1 @@\n-    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n+    static void structCase(CaseAdder adder, String name, Map<MemoryLayout, Object> fields) {\n@@ -142,1 +154,1 @@\n-        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        adder.addCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"testlib_threads.h\"\n+\n+void call(void* ctxt) {\n+    JavaVM* jvm = (JavaVM*) ctxt;\n+    JNIEnv* env;\n+    jvm->AttachCurrentThread((void**)&env, NULL);\n+    jclass linkerClass = env->FindClass(\"java\/lang\/foreign\/Linker\");\n+    jmethodID nativeLinkerMethod = env->GetStaticMethodID(linkerClass, \"nativeLinker\", \"()Ljava\/lang\/foreign\/Linker;\");\n+    env->CallStaticVoidMethod(linkerClass, nativeLinkerMethod);\n+    jvm->DetachCurrentThread();\n+}\n+\n+extern \"C\" {\n+    JNIEXPORT void JNICALL\n+    Java_org_openjdk_foreigntest_PanamaMainUnnamedModule_nativeLinker0(JNIEnv *env, jclass cls) {\n+        JavaVM* jvm;\n+        env->GetJavaVM(&jvm);\n+        run_in_new_thread_and_join(call, jvm);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/libLinkerInvokerUnnamed.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,666 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329817 8334432\n+ * @summary Basic tests of Float16 arithmetic and similar operations\n+ *\/\n+\n+import static java.lang.Float16.*;\n+\n+public class BasicFloat16ArithTests {\n+    private static float InfinityF = Float.POSITIVE_INFINITY;\n+    private static float NaNf = Float.NaN;\n+\n+    private static final float MAX_VAL_FP16 = 0x1.ffcp15f;\n+\n+    public static void main(String... args) {\n+        checkConstants();\n+        checkNegate();\n+        checkAbs();\n+        checkIsNaN();\n+        checkFiniteness();\n+        checkMinMax();\n+        checkArith();\n+        checkSqrt();\n+        checkGetExponent();\n+        checkUlp();\n+        checkValueOfDouble();\n+        FusedMultiplyAddTests.main();\n+    }\n+\n+    \/*\n+     * The software implementation of Float16 delegates to float or\n+     * double operations for most of the actual computation. This\n+     * regression test takes that into account as it generally only\n+     * has limited testing to probe whether or not the proper\n+     * functionality is being delegated to.\n+     *\n+     * To make the test easier to read, float literals that are exact\n+     * upon conversion to Float16 are used for the test data.\n+     *\n+     * The float <-> Float16 conversions are well-tested from prior\n+     * work and are assumed to be correct by this regression test.\n+     *\/\n+\n+    private static void checkConstants() {\n+        checkInt(BYTES,          2, \"Float16.BYTES\");\n+        checkInt(MAX_EXPONENT,  15, \"Float16.MAX_EXPONENT\");\n+        checkInt(MIN_EXPONENT, -14, \"Float16.MIN_EXPONENT\");\n+        checkInt(PRECISION,     11, \"Float16.PRECISION\");\n+        checkInt(SIZE,          16, \"Float16.SIZE\");\n+\n+        checkFloat16(MIN_VALUE,  0x1.0p-24f, \"Float16.MIN_VALUE\");\n+        checkFloat16(MIN_NORMAL, 0x1.0p-14f, \"Float16.MIN_NORMAL\");\n+        checkFloat16(MAX_VALUE,  65504.0f,  \"Float16.MAX_VALUE\");\n+\n+        checkFloat16(POSITIVE_INFINITY,   InfinityF,  \"+infinity\");\n+        checkFloat16(NEGATIVE_INFINITY,  -InfinityF,  \"-infinity\");\n+        checkFloat16(NaN,                 NaNf,            \"NaN\");\n+    }\n+\n+    private static void checkInt(int value, int expected, String message) {\n+        if (value != expected) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %d, got %d\",\n+                                  message, expected, value));\n+        }\n+    }\n+\n+    private static void checkFloat16(Float16 value16, float expected, String message) {\n+        float value = value16.floatValue();\n+        if (Float.compare(value, expected) != 0) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %g (%a), got %g (%a)\",\n+                                  message, expected, expected, value, value));\n+        }\n+    }\n+\n+    private static void checkNegate() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,  -0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,  -1.0f},\n+\n+            {InfinityF, -InfinityF},\n+            {-InfinityF, InfinityF},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  negate(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"negate(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkAbs() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,   0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,   1.0f},\n+\n+            { InfinityF, InfinityF},\n+            {-InfinityF, InfinityF},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  abs(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"abs(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkIsNaN() {\n+        if (!isNaN(NaN)) {\n+            throwRE(\"Float16.isNaN() returns false for a NaN\");\n+        }\n+\n+        float[] testCases = {\n+            -InfinityF,\n+            InfinityF,\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var testCase : testCases) {\n+            boolean result = isNaN(valueOf(testCase));\n+            if (result) {\n+                throwRE(\"isNaN returned true for \" + testCase);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkFiniteness() {\n+        float[] infinities = {\n+            -InfinityF,\n+             InfinityF,\n+        };\n+\n+        for(var infinity : infinities) {\n+            boolean result1 = isFinite(valueOf(infinity));\n+            boolean result2 = isInfinite(valueOf(infinity));\n+\n+            if (result1) {\n+                throw new RuntimeException(\"Float16.isFinite returned true for \" + infinity);\n+            }\n+\n+            if (!result2) {\n+                throwRE(\"Float16.isInfinite returned false for \" + infinity);\n+            }\n+        }\n+\n+        if (isFinite(NaN)) {\n+            throwRE(\"Float16.isFinite() returns true for a NaN\");\n+        }\n+\n+        if (isInfinite(NaN)) {\n+            throwRE(\"Float16.isInfinite() returns true for a NaN\");\n+        }\n+\n+        float[] finities = {\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var finity : finities) {\n+            boolean result1 = isFinite(valueOf(finity));\n+            boolean result2 = isInfinite(valueOf(finity));\n+\n+            if (!result1) {\n+                throwRE(\"Float16.isFinite returned true for \" + finity);\n+            }\n+\n+            if (result2) {\n+                throwRE(\"Float16.isInfinite returned true for \" + finity);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkMinMax() {\n+        float small = 1.0f;\n+        float large = 2.0f;\n+\n+        if (min(valueOf(small), valueOf(large)).floatValue() != small) {\n+            throwRE(String.format(\"min(%g, %g) not equal to %g)\",\n+                                  small, large, small));\n+        }\n+\n+        if (max(valueOf(small), valueOf(large)).floatValue() != large) {\n+            throwRE(String.format(\"max(%g, %g) not equal to %g)\",\n+                                  small, large, large));\n+        }\n+    }\n+\n+    \/*\n+     * Cursory checks to make sure correct operation is being called\n+     * with arguments in proper order.\n+     *\/\n+    private static void checkArith() {\n+        float   a   = 1.0f;\n+        Float16 a16 = valueOf(a);\n+\n+        float   b   = 2.0f;\n+        Float16 b16 = valueOf(b);\n+\n+        if (add(a16, b16).floatValue() != (a + b)) {\n+            throwRE(\"failure with \" + a16 + \" + \" + b16);\n+        }\n+        if (add(b16, a16).floatValue() != (b + a)) {\n+            throwRE(\"failure with \" + b16 + \" + \" + a16);\n+        }\n+\n+        if (subtract(a16, b16).floatValue() != (a - b)) {\n+            throwRE(\"failure with \" + a16 + \" - \" + b16);\n+        }\n+        if (subtract(b16, a16).floatValue() != (b - a)) {\n+            throwRE(\"failure with \" + b16 + \" - \" + a16);\n+        }\n+\n+        if (multiply(a16, b16).floatValue() != (a * b)) {\n+            throwRE(\"failure with \" + a16 + \" * \" + b16);\n+        }\n+        if (multiply(b16, a16).floatValue() != (b * a)) {\n+            throwRE(\"failure with \" + b16 + \" * \" + a16);\n+        }\n+\n+        if (divide(a16, b16).floatValue() != (a \/ b)) {\n+            throwRE(\"failure with \" + a16 + \" \/ \" + b16);\n+        }\n+        if (divide(b16, a16).floatValue() != (b \/ a)) {\n+            throwRE(\"failure with \" + b16 + \" \/ \" + a16);\n+        }\n+        return;\n+    }\n+\n+    private static void checkSqrt() {\n+        float[][] testCases = {\n+            {-0.0f,   -0.0f},\n+            { 0.0f,    0.0f},\n+\n+            {1.0f,   1.0f},\n+            {4.0f,   2.0f},\n+            {9.0f,   3.0f},\n+\n+            { InfinityF, InfinityF},\n+            {-InfinityF, NaNf},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  sqrt(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"sqrt(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkGetExponent() {\n+        float[][] testCases = {\n+            {InfinityF, MAX_EXPONENT + 1},\n+            {InfinityF, MAX_EXPONENT + 1},\n+            {NaNf,      MAX_EXPONENT + 1},\n+\n+            {-0.0f,      MIN_EXPONENT - 1},\n+            {+0.0f,      MIN_EXPONENT - 1},\n+            {0x1.0p-24f, MIN_EXPONENT - 1}, \/\/ Float16.MIN_VALUE\n+            {0x1.0p-14f, MIN_EXPONENT},     \/\/ Float16.MIN_NORMAL\n+            {1.0f,       0},\n+            {2.0f,       1},\n+            {4.0f,       2},\n+\n+            {MAX_VAL_FP16*0.5f, MAX_EXPONENT - 1},\n+            {MAX_VAL_FP16,      MAX_EXPONENT},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            \/\/ Exponents are in-range for Float16\n+            Float16 result =  valueOf(getExponent(valueOf(arg)));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"getExponent(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    private static void checkUlp() {\n+        float[][] testCases = {\n+            {InfinityF, InfinityF},\n+            {InfinityF, InfinityF},\n+            {NaNf,      NaNf},\n+\n+            \/\/ Zeros, subnormals, and MIN_VALUE all have MIN_VALUE as an ulp.\n+            {-0.0f,      0x1.0p-24f},\n+            {+0.0f,      0x1.0p-24f},\n+            {0x1.0p-24f, 0x1.0p-24f},\n+            {0x1.0p-14f, 0x1.0p-24f},\n+\n+            \/\/ ulp is 10 bits away\n+            {0x1.0p0f,       0x0.004p0f}, \/\/ 1.0f\n+            {0x1.0p1f,       0x0.004p1f}, \/\/ 2.0f\n+            {0x1.0p2f,       0x0.004p2f}, \/\/ 4.0f\n+\n+            {MAX_VAL_FP16*0.5f, 0x0.004p14f},\n+            {MAX_VAL_FP16,      0x0.004p15f},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            \/\/ Exponents are in-range for Float16\n+            Float16 result =  ulp(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"ulp(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    private static void throwRE(String message) {\n+        throw new RuntimeException(message);\n+    }\n+\n+    private static void checkValueOfDouble() {\n+        \/*\n+         * Check that double -> Float16 conversion rounds properly\n+         * around the midway point for each finite Float16 value by\n+         * looping over the positive values and checking the negations\n+         * along the way.\n+         *\/\n+\n+        String roundUpMsg   = \"Didn't get half-way case rounding down\";\n+        String roundDownMsg = \"Didn't get half-way case rounding up\";\n+\n+        for(int i = 0; i <= Short.MAX_VALUE; i++ ) {\n+            boolean isEven = ((i & 0x1) == 0);\n+            Float16 f16 = Float16.shortBitsToFloat16((short)i);\n+            Float16 f16Neg = negate(f16);\n+\n+            if (!isFinite(f16))\n+                continue;\n+\n+            \/\/ System.out.println(\"\\t\" + toHexString(f16));\n+\n+            Float16 ulp = ulp(f16);\n+            double halfWay = f16.doubleValue() + ulp.doubleValue() * 0.5;\n+\n+            \/\/ Under the round to nearest even rounding policy, the\n+            \/\/ half-way case should round down to the starting value\n+            \/\/ if the starting value is even; otherwise, it should round up.\n+            float roundedBack = valueOf(halfWay).floatValue();\n+            float roundedBackNeg = valueOf(-halfWay).floatValue();\n+\n+            if (isEven) {\n+                checkFloat16(f16,    roundedBack,    roundDownMsg);\n+                checkFloat16(f16Neg, roundedBackNeg, roundDownMsg);\n+            } else {\n+                checkFloat16(add(f16,         ulp), roundedBack,    roundUpMsg);\n+                checkFloat16(subtract(f16Neg, ulp), roundedBackNeg, roundUpMsg);\n+            }\n+\n+            \/\/ Should always round down\n+            double halfWayNextDown = Math.nextDown(halfWay);\n+            checkFloat16(f16,    valueOf(halfWayNextDown).floatValue(),  roundDownMsg);\n+            checkFloat16(f16Neg, valueOf(-halfWayNextDown).floatValue(), roundDownMsg);\n+\n+            \/\/ Should always round up\n+            double halfWayNextUp =   Math.nextUp(halfWay);\n+            checkFloat16(add(f16, ulp),         valueOf( halfWayNextUp).floatValue(), roundUpMsg);\n+            checkFloat16(subtract(f16Neg, ulp), valueOf(-halfWayNextUp).floatValue(), roundUpMsg);\n+        }\n+    }\n+\n+    class FusedMultiplyAddTests {\n+        public static void main(String... args) {\n+            testZeroNanInfCombos();\n+            testNonFinite();\n+            testZeroes();\n+            testSimple();\n+            testRounding();\n+        }\n+\n+        private static void testZeroNanInfCombos() {\n+            float [] testInputs = {\n+                Float.NaN,\n+                -InfinityF,\n+                +InfinityF,\n+                -0.0f,\n+                +0.0f,\n+            };\n+\n+            for (float i : testInputs) {\n+                for (float j : testInputs) {\n+                    for (float k : testInputs) {\n+                        testFusedMacCase(i, j, k, Math.fma(i, j, k));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static void testNonFinite() {\n+            float [][] testCases = {\n+                {1.0f,       InfinityF,  2.0f,\n+                 InfinityF,\n+                },\n+\n+                {1.0f,       2.0f,       InfinityF,\n+                 InfinityF,\n+                },\n+\n+                {InfinityF,  1.0f,       InfinityF,\n+                 InfinityF,\n+                },\n+\n+                {0x1.ffcp14f, 2.0f,     -InfinityF,\n+                 -InfinityF},\n+\n+                {InfinityF,  1.0f,      -InfinityF,\n+                 NaNf,\n+                },\n+\n+                {-InfinityF, 1.0f,       InfinityF,\n+                 NaNf,\n+                },\n+\n+                {1.0f,       NaNf,       2.0f,\n+                 NaNf,\n+                },\n+\n+                {1.0f,       2.0f,       NaNf,\n+                 NaNf,\n+                },\n+\n+                {InfinityF,  2.0f,       NaNf,\n+                 NaNf,\n+                },\n+\n+                {NaNf,       2.0f,       InfinityF,\n+                 NaNf,\n+                },\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testZeroes() {\n+            float [][] testCases = {\n+                {+0.0f, +0.0f, +0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-0.0f, +0.0f, +0.0f,\n+                 +0.0f,\n+                },\n+\n+                {+0.0f, +0.0f, -0.0f,\n+                 +0.0f,\n+                },\n+\n+                {+0.0f, +0.0f, -0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-0.0f, +0.0f, -0.0f,\n+                 -0.0f,\n+                },\n+\n+                {-0.0f, -0.0f, -0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-1.0f, +0.0f, -0.0f,\n+                 -0.0f,\n+                },\n+\n+                {-1.0f, +0.0f, +0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-2.0f, +0.0f, -0.0f,\n+                 -0.0f,\n+                },\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testSimple() {\n+            final float ulpOneFp16 = ulp(valueOf(1.0f)).floatValue();\n+\n+            float [][] testCases = {\n+                {1.0f, 2.0f, 3.0f,\n+                 5.0f,},\n+\n+                {1.0f, 2.0f, -2.0f,\n+                 0.0f,},\n+\n+                {5.0f, 5.0f, -25.0f,\n+                 0.0f,},\n+\n+                {0.5f*MAX_VAL_FP16, 2.0f, -0.5f*MAX_VAL_FP16,\n+                 0.5f*MAX_VAL_FP16},\n+\n+                {MAX_VAL_FP16, 2.0f, -MAX_VAL_FP16,\n+                 MAX_VAL_FP16},\n+\n+                {MAX_VAL_FP16, 2.0f, 1.0f,\n+                 InfinityF},\n+\n+                {(1.0f + ulpOneFp16),\n+                 (1.0f + ulpOneFp16),\n+                 -1.0f - 2.0f*ulpOneFp16,\n+                 ulpOneFp16 * ulpOneFp16},\n+\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testRounding() {\n+            final float ulpOneFp16 = ulp(valueOf(1.0f)).floatValue();\n+\n+            float [][] testCases = {\n+                \/\/ The product is equal to\n+                \/\/ (MAX_VALUE + 1\/2 * ulp(MAX_VALUE) + MAX_VALUE = (0x1.ffcp15 + 0x0.002p15)+ 0x1.ffcp15\n+                \/\/ so overflows.\n+                {0x1.3p1f, 0x1.afp15f, -MAX_VAL_FP16,\n+                 InfinityF},\n+\n+                \/\/ Product exactly equals 0x1.ffep15, the overflow\n+                \/\/ threshold; subtracting a non-zero finite value will\n+                \/\/ result in MAX_VALUE, adding zero or a positive\n+                \/\/ value will overflow.\n+                {0x1.2p10f, 0x1.c7p5f, -0x1.0p-14f,\n+                 MAX_VAL_FP16},\n+\n+                {0x1.2p10f, 0x1.c7p5f, -0.0f,\n+                 InfinityF},\n+\n+                {0x1.2p10f, 0x1.c7p5f, +0.0f,\n+                 InfinityF},\n+\n+                {0x1.2p10f, 0x1.c7p5f, +0x1.0p-14f,\n+                 InfinityF},\n+\n+                {0x1.2p10f, 0x1.c7p5f, InfinityF,\n+                 InfinityF},\n+\n+                \/\/ PRECISION bits in the subnormal intermediate product\n+                {0x1.ffcp-14f, 0x1.0p-24f, 0x1.0p13f, \/\/ Can be held exactly\n+                 0x1.0p13f},\n+\n+                {0x1.ffcp-14f, 0x1.0p-24f, 0x1.0p14f, \/\/ *Cannot* be held exactly\n+                 0x1.0p14f},\n+\n+                \/\/ Check values where the exact result cannot be\n+                \/\/ exactly stored in a double.\n+                {0x1.0p-24f, 0x1.0p-24f, 0x1.0p10f,\n+                 0x1.0p10f},\n+\n+                {0x1.0p-24f, 0x1.0p-24f, 0x1.0p14f,\n+                 0x1.0p14f},\n+\n+                \/\/ Check subnormal results, underflow to zero\n+                {0x1.0p-24f, -0.5f, 0x1.0p-24f,\n+                 0.0f},\n+\n+                \/\/ Check subnormal results, underflow to zero\n+                {0x1.0p-24f, -0.5f, 0.0f,\n+                 -0.0f},\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testFusedMacCase(float input1, float input2, float input3, float expected) {\n+            Float16 a = valueOf(input1);\n+            Float16 b = valueOf(input2);\n+            Float16 c = valueOf(input3);\n+            Float16 d = valueOf(expected);\n+\n+            test(\"Float16.fma(float)\", a, b, c, Float16.fma(a, b, c), d);\n+\n+            \/\/ Permute first two inputs\n+            test(\"Float16.fma(float)\", b, a, c, Float16.fma(b, a, c), d);\n+            return;\n+        }\n+    }\n+\n+    private static void test(String testName,\n+                           Float16 input1, Float16 input2, Float16 input3,\n+                           Float16 result, Float16 expected) {\n+        if (Float16.compare(expected, result ) != 0) {\n+            System.err.println(\"Failure for \"  + testName + \":\\n\" +\n+                               \"\\tFor inputs \" + input1   + \"\\t(\" + toHexString(input1) + \") and \"\n+                                               + input2   + \"\\t(\" + toHexString(input2) + \") and\"\n+                                               + input3   + \"\\t(\" + toHexString(input3) + \")\\n\"  +\n+                               \"\\texpected  \"  + expected + \"\\t(\" + toHexString(expected) + \")\\n\" +\n+                               \"\\tgot       \"  + result   + \"\\t(\" + toHexString(result) + \").\");\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float16\/BasicFloat16ArithTests.java","additions":666,"deletions":0,"binary":false,"changes":666,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308363\n+ * @summary Test FP16 reduction operations.\n+ * @compile FP16ReductionOperations.java\n+ * @run main\/othervm --enable-preview -XX:-TieredCompilation -Xbatch FP16ReductionOperations\n+ *\/\n+\n+import java.util.Random;\n+\n+import static java.lang.Float16.*;\n+\n+public class FP16ReductionOperations {\n+\n+    public static Random r = new Random(1024);\n+\n+    public static short test_reduction_add_constants() {\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        return float16ToRawShortBits(Float16.add(Float16.add(Float16.add(Float16.add(hf0, hf1), hf2), hf3), hf4));\n+    }\n+\n+    public static short expected_reduction_add_constants() {\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        return Float.floatToFloat16(Float.float16ToFloat(float16ToRawShortBits(hf0)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf1)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf2)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf3)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf4)));\n+    }\n+\n+    public static boolean compare(short actual, short expected) {\n+        return !((0xFFFF & actual) == (0xFFFF & expected));\n+    }\n+\n+    public static void test_reduction_constants(char oper) {\n+        short actual = 0;\n+        short expected = 0;\n+        switch(oper) {\n+            case '+' ->  {\n+                             actual = test_reduction_add_constants();\n+                             expected = expected_reduction_add_constants();\n+                         }\n+            default  ->  throw new AssertionError(\"Unsupported Operation.\");\n+        }\n+        if (compare(actual,expected)) {\n+            throw new AssertionError(\"Result mismatch!, expected = \" + expected + \" actual = \" + actual);\n+        }\n+    }\n+\n+    public static short test_reduction_add(short [] arr) {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < arr.length; i++) {\n+            res = Float16.add(res, shortBitsToFloat16(arr[i]));\n+        }\n+        return float16ToRawShortBits(res);\n+    }\n+\n+    public static short expected_reduction_add(short [] arr) {\n+        short res = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(arr[i]));\n+        }\n+        return res;\n+    }\n+\n+    public static void test_reduction(char oper, short [] arr) {\n+        short actual = 0;\n+        short expected = 0;\n+        switch(oper) {\n+            case '+' ->  {\n+                             actual = test_reduction_add(arr);\n+                             expected = expected_reduction_add(arr);\n+                         }\n+            default  ->  throw new AssertionError(\"Unsupported Operation.\");\n+        }\n+        if (compare(actual,expected)) {\n+            throw new AssertionError(\"Result mismatch!, expected = \" + expected + \" actual = \" + actual);\n+        }\n+    }\n+\n+    public static short [] get_fp16_array(int size) {\n+        short [] arr = new short[size];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = Float.floatToFloat16(r.nextFloat());\n+        }\n+        return arr;\n+    }\n+\n+    public static void main(String [] args) {\n+        int res = 0;\n+        short [] input = get_fp16_array(1024);\n+        short [] special_values = {\n+              32256,          \/\/ NAN\n+              31744,          \/\/ +Inf\n+              (short)-1024,   \/\/ -Inf\n+              0,              \/\/ +0.0\n+              (short)-32768,  \/\/ -0.0\n+        };\n+        for (int i = 0;  i < 1000; i++) {\n+            test_reduction('+', input);\n+            test_reduction('+', special_values);\n+            test_reduction_constants('+');\n+        }\n+        System.out.println(\"PASS\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ReductionOperations.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308363 8336406\n+ * @summary Verify binary FP16 scalar operations\n+ * @compile FP16ScalarOperations.java\n+ * @run main\/othervm --enable-preview -XX:-TieredCompilation -Xbatch FP16ScalarOperations\n+ *\/\n+\n+import java.util.Random;\n+\n+import static java.lang.Float16.*;\n+\n+public class FP16ScalarOperations {\n+\n+    public static Random r = new Random(1024);\n+\n+    public static short actual_value(String oper, short val1, short val2) {\n+        Float16 obj1 = shortBitsToFloat16(val1);\n+        Float16 obj2 = shortBitsToFloat16(val2);\n+        switch (oper) {\n+            case \"+\"   : return float16ToRawShortBits(Float16.add(obj1, obj2));\n+            case \"-\"   : return float16ToRawShortBits(Float16.subtract(obj1, obj2));\n+            case \"*\"   : return float16ToRawShortBits(Float16.multiply(obj1, obj2));\n+            case \"\/\"   : return float16ToRawShortBits(Float16.divide(obj1, obj2));\n+            case \"min\" : return float16ToRawShortBits(Float16.min(obj1, obj2));\n+            case \"max\" : return float16ToRawShortBits(Float16.max(obj1, obj2));\n+            default    : throw new AssertionError(\"Unsupported Operation!\");\n+        }\n+    }\n+\n+    public static void test_operations(short [] arr1, short arr2[]) {\n+        for (int i = 0; i < arr1.length; i++) {\n+            validate(\"+\", arr1[i], arr2[i]);\n+            validate(\"-\", arr1[i], arr2[i]);\n+            validate(\"*\", arr1[i], arr2[i]);\n+            validate(\"\/\", arr1[i], arr2[i]);\n+            validate(\"min\", arr1[i], arr2[i]);\n+            validate(\"max\", arr1[i], arr2[i]);\n+        }\n+    }\n+\n+    public static short expected_value(String oper, short input1, short input2) {\n+        switch(oper) {\n+            case \"+\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) + Float.float16ToFloat(input2));\n+            case \"-\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) - Float.float16ToFloat(input2));\n+            case \"*\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) * Float.float16ToFloat(input2));\n+            case \"\/\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) \/ Float.float16ToFloat(input2));\n+            case \"min\" : return Float.floatToFloat16(Float.min(Float.float16ToFloat(input1), Float.float16ToFloat(input2)));\n+            case \"max\" : return Float.floatToFloat16(Float.max(Float.float16ToFloat(input1), Float.float16ToFloat(input2)));\n+            default    : throw new AssertionError(\"Unsupported Operation!\");\n+        }\n+    }\n+\n+    public static boolean compare(short actual, short expected) {\n+        return !((0xFFFF & actual) == (0xFFFF & expected));\n+    }\n+\n+    public static void validate(String oper, short input1, short input2) {\n+        short actual = actual_value(oper, input1, input2);\n+        short expected = expected_value(oper, input1, input2);\n+        if (compare(actual, expected)) {\n+            throw new AssertionError(\"Test Failed: \" + input1 + \" + \" + input2 + \" : \" + actual + \" != \" + expected);\n+        }\n+    }\n+\n+    public static short [] get_fp16_array(int size) {\n+        short [] arr = new short[size];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = Float.floatToFloat16(r.nextFloat());\n+        }\n+        return arr;\n+    }\n+\n+    public static void main(String [] args) {\n+        int res = 0;\n+        short [] input1 = get_fp16_array(1024);\n+        short [] input2 = get_fp16_array(1024);\n+        short [] special_values = {\n+              32256,          \/\/ NAN\n+              31744,          \/\/ +Inf\n+              (short)-1024,   \/\/ -Inf\n+              0,              \/\/ +0.0\n+              (short)-32768,  \/\/ -0.0\n+        };\n+        for (int i = 0;  i < 1000; i++) {\n+            test_operations(input1, input2);\n+            test_operations(special_values, special_values);\n+        }\n+        System.out.println(\"PASS\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8205592\n- * @summary Verify {double, float}Value methods work\n+ * @bug 8205592 8339252\n+ * @summary Verify {double, float, float16}Value methods work\n@@ -67,0 +67,26 @@\n+    \/*\n+     * Not a fully fledged implementation, only for finite positive values.\n+     *\/\n+    private static Float16 nextUp(Float16 v) {\n+        return Float16.shortBitsToFloat16((short) (Float16.float16ToRawShortBits(v) + 1));\n+    }\n+\n+    \/*\n+     * Not a fully fledged implementation, only for finite positive values.\n+     *\/\n+    private static Float16 nextDown(Float16 v) {\n+        return Float16.shortBitsToFloat16((short) (Float16.float16ToRawShortBits(v) - 1));\n+    }\n+\n+    private static BigDecimal nextHalfUp(Float16 v) {\n+        BigDecimal bv = new BigDecimal(v.doubleValue());\n+        BigDecimal ulp = new BigDecimal(Float16.ulp(v).doubleValue());\n+        return bv.add(ulp.multiply(HALF));\n+    }\n+\n+    private static BigDecimal nextHalfDown(Float16 v) {\n+        BigDecimal bv = new BigDecimal(v.doubleValue());\n+        BigDecimal ulp = new BigDecimal(v.doubleValue() - nextDown(v).doubleValue());\n+        return bv.subtract(ulp.multiply(HALF));\n+    }\n+\n@@ -75,0 +101,4 @@\n+    private static String toDecHexString(Float16 v) {\n+        return v + \" (\" + Float16.toHexString(v) + \")\";\n+    }\n+\n@@ -93,0 +123,9 @@\n+    private static void checkFloat16(BigDecimal bv, Float16 exp) {\n+        Float16 res = bv.float16Value();\n+        if (exp.floatValue() != res.floatValue()) {\n+            String message = \"Bad conversion: got \" + toDecHexString(res) +\n+                    \", expected \" + toDecHexString(exp);\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n@@ -115,0 +154,9 @@\n+    private static void testFloat16ValueNearMinValue() {\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal b = nextHalfUp(Float16.multiply(Float16.valueOf(n), Float16.MIN_VALUE));\n+            checkFloat16(b, Float16.multiply(Float16.valueOf((n + 1) \/ 2 * 2), Float16.MIN_VALUE));\n+            checkFloat16(b.subtract(EPS), Float16.multiply(Float16.valueOf(n), Float16.MIN_VALUE));\n+            checkFloat16(b.add(EPS), Float16.multiply(Float16.valueOf(n + 1), Float16.MIN_VALUE));\n+        }\n+    }\n+\n@@ -153,0 +201,19 @@\n+    private static void testFloat16ValueNearMinNormal() {\n+        Float16 v = Float16.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat16(bv, isOdd(n) ? nextDown(v) : v);\n+            checkFloat16(bv.subtract(EPS), nextDown(v));\n+            checkFloat16(bv.add(EPS), v);\n+            v = nextDown(v);\n+        }\n+        v = Float16.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfUp(v);\n+            checkFloat16(bv, isOdd(n) ? nextUp(v) : v);\n+            checkFloat16(bv.subtract(EPS), v);\n+            checkFloat16(bv.add(EPS), nextUp(v));\n+            v = nextUp(v);\n+        }\n+    }\n+\n@@ -183,0 +250,15 @@\n+    private static void testFloat16ValueNearMaxValue() {\n+        Float16 v = Float16.MAX_VALUE;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat16(bv, isOdd(n) ? v : nextDown(v));\n+            checkFloat16(bv.subtract(EPS), nextDown(v));\n+            checkFloat16(bv.add(EPS), v);\n+            v = nextDown(v);\n+        }\n+        BigDecimal bv = nextHalfUp(Float16.MAX_VALUE);\n+        checkFloat16(bv, Float16.POSITIVE_INFINITY);\n+        checkFloat16(bv.subtract(EPS), Float16.MAX_VALUE);\n+        checkFloat16(bv.add(EPS), Float16.POSITIVE_INFINITY);\n+    }\n+\n@@ -231,0 +313,24 @@\n+    private static void testFloat16ValueRandom() {\n+        Random r = RandomFactory.getRandom();\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-Float16.MAX_VALUE.floatValue(), Float16.MAX_VALUE.floatValue()));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e4f, 1e4f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e3f, 1e3f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e-3f, 1e-3f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e-4f, 1e-4f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+    }\n+\n@@ -235,1 +341,1 @@\n-        checkDouble(BigDecimal.valueOf(-1, -1000), -Double.POSITIVE_INFINITY);\n+        checkDouble(BigDecimal.valueOf(-1, -1000), Double.NEGATIVE_INFINITY);\n@@ -242,1 +348,8 @@\n-        checkFloat(BigDecimal.valueOf(-1, -1000), -Float.POSITIVE_INFINITY);\n+        checkFloat(BigDecimal.valueOf(-1, -1000), Float.NEGATIVE_INFINITY);\n+    }\n+\n+    private static void testFloat16ValueExtremes() {\n+        checkFloat16(BigDecimal.valueOf(1, 1000), Float16.valueOf(0.0f));\n+        checkFloat16(BigDecimal.valueOf(-1, 1000), Float16.valueOf(-0.0f));\n+        checkFloat16(BigDecimal.valueOf(1, -1000), Float16.POSITIVE_INFINITY);\n+        checkFloat16(BigDecimal.valueOf(-1, -1000), Float16.NEGATIVE_INFINITY);\n@@ -257,0 +370,6 @@\n+\n+        testFloat16ValueNearMinValue();\n+        testFloat16ValueNearMinNormal();\n+        testFloat16ValueNearMaxValue();\n+        testFloat16ValueRandom();\n+        testFloat16ValueExtremes();\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DoubleFloatValueTests.java","additions":124,"deletions":5,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,3 @@\n- * @bug 7131192\n- * @summary This test ensures that BigInteger.floatValue() and\n- *          BigInteger.doubleValue() behave correctly.\n+ * @bug 7131192 8339252\n+ * @summary This test ensures that BigInteger.float16Value(),\n+ *          BigInteger.floatValue(), BigInteger.doubleValue() behave correctly.\n@@ -101,0 +101,35 @@\n+    public static int testFloat16Value() {\n+        \/*\n+         * Test all integers in Float16's finite range and slightly beyond.\n+         * Also test a couple of really big integers.\n+         *\/\n+        System.out.println(\"--- testFloat16Value ---\");\n+        int high = Float16.MAX_VALUE.intValue() + Float16.ulp(Float16.MAX_VALUE).intValue();\n+        int failures = 0;\n+        for (int i = 0; i <= high; ++i) {\n+            BigInteger big = BigInteger.valueOf(i);\n+            failures = checkFloat16(Float16.valueOf(i), big.float16Value(), big, failures);\n+\n+            big = BigInteger.valueOf(-i);\n+            failures = checkFloat16(Float16.valueOf(-i), big.float16Value(), big, failures);\n+        }\n+\n+        BigInteger large = ONE.shiftLeft(1_000);\n+        failures = checkFloat16(Float16.POSITIVE_INFINITY, large.float16Value(), large, failures);\n+\n+        large = large.negate();\n+        failures = checkFloat16(Float16.NEGATIVE_INFINITY, large.float16Value(), large, failures);\n+\n+        return failures;\n+    }\n+\n+    private static int checkFloat16(Float16 expected, Float16 actual, BigInteger large, int failures) {\n+        if (Float16.float16ToRawShortBits(expected) !=\n+                Float16.float16ToRawShortBits(actual)) {\n+            System.out.format(\"big: %s, expected: %s, actual: %s%n\",\n+                    large, Float16.toHexString(expected), Float16.toHexString(actual));\n+            failures++;\n+        }\n+        return failures;\n+    }\n+\n@@ -104,0 +139,1 @@\n+        failures += testFloat16Value();\n","filename":"test\/jdk\/java\/math\/BigInteger\/PrimitiveConversionTests.java","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,613 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8233223\n+ * @summary Interoperability tests with Amazon's CA1, CA2, CA3, and CA4\n+ * @build ValidatePathWithParams\n+ * @run main\/othervm -Djava.security.debug=certpath AmazonCA OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath AmazonCA CRL\n+ *\/\n+\n+\/*\n+ * Obtain TLS test artifacts for Amazon CAs from:\n+ *\n+ * Amazon Root CA 1\n+ *     Valid - https:\/\/good.sca1a.amazontrust.com\/\n+ *     Revoked - https:\/\/revoked.sca1a.amazontrust.com\/\n+ * Amazon Root CA 2\n+ *     Valid - https:\/\/good.sca2a.amazontrust.com\/\n+ *     Revoked - https:\/\/revoked.sca2a.amazontrust.com\/\n+ * Amazon Root CA 3\n+ *     Valid - https:\/\/good.sca3a.amazontrust.com\/\n+ *     Revoked - https:\/\/revoked.sca3a.amazontrust.com\/\n+ * Amazon Root CA 4\n+ *     Valid - https:\/\/good.sca4a.amazontrust.com\/\n+ *     Revoked - https:\/\/revoked.sca4a.amazontrust.com\/\n+ *\/\n+public class AmazonCA {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        ValidatePathWithParams pathValidator = new ValidatePathWithParams(null);\n+\n+        if (args.length >= 1 && \"CRL\".equalsIgnoreCase(args[0])) {\n+            pathValidator.enableCRLCheck();\n+        } else {\n+            \/\/ OCSP check by default\n+            pathValidator.enableOCSPCheck();\n+        }\n+\n+        new AmazonCA_1().runTest(pathValidator);\n+        new AmazonCA_2().runTest(pathValidator);\n+        new AmazonCA_3().runTest(pathValidator);\n+        new AmazonCA_4().runTest(pathValidator);\n+    }\n+}\n+\n+class AmazonCA_1 {\n+\n+    \/\/ Owner: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 1, O=Amazon, C=US\n+    \/\/ Serial number: 773124a4bcbd44ec7b53beaf194842d3a0fa1\n+    \/\/ Valid from: Tue Aug 23 15:25:30 PDT 2022 until: Fri Aug 23 15:25:30 PDT 2030\n+    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIEXjCCA0agAwIBAgITB3MSSkvL1E7HtTvq8ZSELToPoTANBgkqhkiG9w0BAQsF\\n\" +\n+            \"ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\\n\" +\n+            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjUzMFoXDTMwMDgyMzIyMjUzMFowPDEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n+            \"QSAyMDQ4IE0wMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALtDGMZa\\n\" +\n+            \"qHneKei1by6+pUPPLljTB143Si6VpEWPc6mSkFhZb\/6qrkZyoHlQLbDYnI2D7hD0\\n\" +\n+            \"sdzEqfnuAjIsuXQLG3A8TvX6V3oFNBFVe8NlLJHvBseKY88saLwufxkZVwk74g4n\\n\" +\n+            \"WlNMXzla9Y5F3wwRHwMVH443xGz6UtGSZSqQ94eFx5X7Tlqt8whi8qCaKdZ5rNak\\n\" +\n+            \"+r9nUThOeClqFd4oXych\/\/Rc7Y0eX1KNWHYSI1Nk31mYgiK3JvH063g+K9tHA63Z\\n\" +\n+            \"eTgKgndlh+WI+zv7i44HepRZjA1FYwYZ9Vv\/9UkC5Yz8\/yU65fgjaE+wVHM4e\/Yy\\n\" +\n+            \"C2osrPWE7gJ+dXMCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n+            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n+            \"HQ4EFgQUwDFSzVpQw4J8dHHOy+mc+XrrguIwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n+            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n+            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n+            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n+            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n+            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n+            \"AQAtTi6Fs0Azfi+iwm7jrz+CSxHH+uHl7Law3MQSXVtR8RV53PtR6r\/6gNpqlzdo\\n\" +\n+            \"Zq4FKbADi1v9Bun8RY8D51uedRfjsbeodizeBB8nXmeyD33Ep7VATj4ozcd31YFV\\n\" +\n+            \"fgRhvTSxNrrTlNpWkUk0m3BMPv8sg381HhA6uEYokE5q9uws\/3YkKqRiEz3TsaWm\\n\" +\n+            \"JqIRZhMbgAfp7O7FUwFIb7UIspogZSKxPIWJpxiPo3TcBambbVtQOcNRWz5qCQdD\\n\" +\n+            \"slI2yayq0n2TXoHyNCLEH8rpsJRVILFsg0jc7BaFrMnF462+ajSehgj12IidNeRN\\n\" +\n+            \"4zl+EoNaWdpnWndvSpAEkq2P\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 1, O=Amazon, C=US\n+    \/\/ Serial number: 77312380b9d6688a33b1ed9bf9ccda68e0e0f\n+    \/\/ Valid from: Tue Aug 23 15:21:28 PDT 2022 until: Fri Aug 23 15:21:28 PDT 2030\n+    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIEXjCCA0agAwIBAgITB3MSOAudZoijOx7Zv5zNpo4ODzANBgkqhkiG9w0BAQsF\\n\" +\n+            \"ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\\n\" +\n+            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjEyOFoXDTMwMDgyMzIyMjEyOFowPDEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n+            \"QSAyMDQ4IE0wMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOtxLKnL\\n\" +\n+            \"H4gokjIwr4pXD3i3NyWVVYesZ1yX0yLI2qIUZ2t88Gfa4gMqs1YSXca1R\/lnCKeT\\n\" +\n+            \"epWSGA+0+fkQNpp\/L4C2T7oTTsddUx7g3ZYzByDTlrwS5HRQQqEFE3O1T5tEJP4t\\n\" +\n+            \"f+28IoXsNiEzl3UGzicYgtzj2cWCB41eJgEmJmcf2T8TzzK6a614ZPyq\/w4CPAff\\n\" +\n+            \"nAV4coz96nW3AyiE2uhuB4zQUIXvgVSycW7sbWLvj5TDXunEpNCRwC4kkZjK7rol\\n\" +\n+            \"jtT2cbb7W2s4Bkg3R42G3PLqBvt2N32e\/0JOTViCk8\/iccJ4sXqrS1uUN4iB5Nmv\\n\" +\n+            \"JK74csVl+0u0UecCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n+            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n+            \"HQ4EFgQUgbgOY4qJEhjl+js7UJWf5uWQE4UwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n+            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n+            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n+            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n+            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n+            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n+            \"AQCtAN4CBSMuBjJitGuxlBbkEUDeK\/pZwTXv4KqPK0G50fOHOQAd8j21p0cMBgbG\\n\" +\n+            \"kfMHVwLU7b0XwZCav0h1ogdPMN1KakK1DT0VwA\/+hFvGPJnMV1Kx2G4S1ZaSk0uU\\n\" +\n+            \"5QfoiYIIano01J5k4T2HapKQmmOhS\/iPtuo00wW+IMLeBuKMn3OLn005hcrOGTad\\n\" +\n+            \"hcmeyfhQP7Z+iKHvyoQGi1C0ClymHETx\/chhQGDyYSWqB\/THwnN15AwLQo0E5V9E\\n\" +\n+            \"SJlbe4mBlqeInUsNYugExNf+tOiybcrswBy8OFsd34XOW3rjSUtsuafd9AWySa3h\\n\" +\n+            \"xRRrwszrzX\/WWGm6wyB+f7C4\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=valid.rootca1.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n+    \/\/ Serial number: 60c6e837b2e7586d8464eb34f4a85fe\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIGKDCCBRCgAwIBAgIQBgxug3sudYbYRk6zT0qF\/jANBgkqhkiG9w0BAQsFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDIwNDggTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n+            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbTCCASIw\\n\" +\n+            \"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL3hA+omhUcO8nYO8\/+dkpbYz8WI\\n\" +\n+            \"1ms7Y7JA2pPFfp2N\/aWcf6m5ORm1BkyGLOttjTu318Qpa9eahQ1Pi3RNe3BtqjD9\\n\" +\n+            \"jcHncpwAFMsXy1beZA7sZ7AA4vKltA3t6yrU5ruTLUGQwUndeIBBSTW5QpdT9I\/p\\n\" +\n+            \"EM7d+Miwre63kofbJ1lVPAJvN\/udMVqGWNF8V5qscklUUHoSKA3FWWsiCyIgnthg\\n\" +\n+            \"G3u6R1KH66Qionp0ho\/ttvrBCI0C\/bdrdH+wybFv8oFFvAW2U9xn2Azt47\/2kHHm\\n\" +\n+            \"tTRjrgufhDbcz\/MLR6hwBXAJuwVvJZmSqe7B4IILFexu6wjxZfyqVm2FMr8CAwEA\\n\" +\n+            \"AaOCAzMwggMvMB8GA1UdIwQYMBaAFMAxUs1aUMOCfHRxzsvpnPl664LiMB0GA1Ud\\n\" +\n+            \"DgQWBBSkrnsTnjwYhDRAeLy\/9FXm\/7hApDBlBgNVHREEXjBcgiJ2YWxpZC5yb290\\n\" +\n+            \"Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tghpnb29kLnNjYTBhLmFtYXpvbnRydXN0\\n\" +\n+            \"LmNvbYIaZ29vZC5zY2ExYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWg\\n\" +\n+            \"MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAs\\n\" +\n+            \"hipodHRwOi8vY3JsLnIybTAyLmFtYXpvbnRydXN0LmNvbS9yMm0wMi5jcmwwEwYD\\n\" +\n+            \"VR0gBAwwCjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFo\\n\" +\n+            \"dHRwOi8vb2NzcC5yMm0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0\\n\" +\n+            \"dHA6Ly9jcnQucjJtMDIuYW1hem9udHJ1c3QuY29tL3IybTAyLmNlcjAMBgNVHRMB\\n\" +\n+            \"Af8EAjAAMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520\\n\" +\n+            \"zROiModGfLzs3sNRSFlGcR+1mwAAAYgHvXWVAAAEAwBHMEUCICAs74qT1f9ufSr5\\n\" +\n+            \"PgQqtQFiXBbmbb3i4xwVV78USU5NAiEA\/iJEfnTG+hZZaHYv2wVbg6tUY8fQgIhI\\n\" +\n+            \"2rbl6PrD9FIAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgH\\n\" +\n+            \"vXWWAAAEAwBHMEUCIQDf2nWyee\/5+vSgk\/O8P0BFvXYu89cyAugZHyd919BdAgIg\\n\" +\n+            \"UnGGpQtZmWnPMmdgpzI7jrCLuC370Tn0i7Aktdzj2X8AdgDatr9rP7W2Ip+bwrtc\\n\" +\n+            \"a+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXVpAAAEAwBHMEUCIGN6cT+6uwDospXe\\n\" +\n+            \"gMa8b38oXouXUT66X2gOiJ0SoRyQAiEAjDMu2vEll5tRpUvU8cD4gR2xV4hqoDxx\\n\" +\n+            \"Q+QGW+PvJxcwDQYJKoZIhvcNAQELBQADggEBACtxC3LlQvULeI3lt7ZYFSWndEhm\\n\" +\n+            \"tNUotoeKSXJXdoIpqSr10bzMPX9SHvemgOUtzP3JNqWPHw1uW9YFyeDE6yWj\/B13\\n\" +\n+            \"Xj1hv1cqYIwyaOZBerU\/9PT5PaCn20AC9DHbc7iBv+zs+DYiqlAFJ1GVaprwLul4\\n\" +\n+            \"8wp3gnC3Hjb8NykydCo6vw0AJ2UzjpjiTyVZ93jITzLOiboOUa1gQGnojzWlYaet\\n\" +\n+            \"sXe+RDylBp\/Wuj1ZS7v\/etltzYm5GanPi4y\/p7Ta3Uky6std\/GM6XbPRdBEFboFR\\n\" +\n+            \"B2IP0divd9c74Q+tLgpsAz5yXm9LtYPMcEPC2YRN2PgBg67c5+A7eIOluuw=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=revoked.rootca1.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n+    \/\/ Serial number: e1023665b1268d788cc25bf69a9d05e\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIGMjCCBRqgAwIBAgIQDhAjZlsSaNeIzCW\/aanQXjANBgkqhkiG9w0BAQsFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDIwNDggTTAxMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n+            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tMIIB\\n\" +\n+            \"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxSPd1PWACxZohFCAJT1JWuXK\\n\" +\n+            \"GY29wZZ9yY0zoiq6+qYiUIU0crktytUNNI1ZpW\/3qXpEw2ZQkM6WF1LshXtwGwrA\\n\" +\n+            \"zJwSeX1L9T5rOKhoBvoFeqfX7xu4VBM1\/fDGt5X+NRFfD9Op9UfK5OsnL05TYach\\n\" +\n+            \"rdnfOA5wKGvMgFiN5CeOD0AtumXSuAnTZC85ojJTHjPF+hqV893WvrrUxLyyxtvh\\n\" +\n+            \"lq\/WttFOjhfQu2IkfyDAFiH939uzUi0WSTAdsbsHuko5mDTDnOfMRbaaWZu0At01\\n\" +\n+            \"EgaIPeK+kGdi7EYwVndIwTKLeQ4mjIM8aj8Heg\/y2hZ0kOmfCUZdUmJFlNoCIQID\\n\" +\n+            \"AQABo4IDOzCCAzcwHwYDVR0jBBgwFoAUgbgOY4qJEhjl+js7UJWf5uWQE4UwHQYD\\n\" +\n+            \"VR0OBBYEFMeBhIOkuWUY4DYqFrfgbD2eUeFtMG0GA1UdEQRmMGSCJHJldm9rZWQu\\n\" +\n+            \"cm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbYIdcmV2b2tlZC5zY2EwYS5hbWF6\\n\" +\n+            \"b250cnVzdC5jb22CHXJldm9rZWQuc2NhMWEuYW1hem9udHJ1c3QuY29tMA4GA1Ud\\n\" +\n+            \"DwEB\/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0f\\n\" +\n+            \"BDQwMjAwoC6gLIYqaHR0cDovL2NybC5yMm0wMS5hbWF6b250cnVzdC5jb20vcjJt\\n\" +\n+            \"MDEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggr\\n\" +\n+            \"BgEFBQcwAYYhaHR0cDovL29jc3AucjJtMDEuYW1hem9udHJ1c3QuY29tMDYGCCsG\\n\" +\n+            \"AQUFBzAChipodHRwOi8vY3J0LnIybTAxLmFtYXpvbnRydXN0LmNvbS9yMm0wMS5j\\n\" +\n+            \"ZXIwDAYDVR0TAQH\/BAIwADCCAX4GCisGAQQB1nkCBAIEggFuBIIBagFoAHYA7s3Q\\n\" +\n+            \"ZNXbGs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB72TggAABAMARzBFAiAZ\\n\" +\n+            \"naLbRHRuaRrE304GSuWX\/79MU\/e+SSlr0cNJ0kNNaAIhAPnz9HayL4txhkTEZiMs\\n\" +\n+            \"nttNnNqD17I0J17JLVOF4i\/4AHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/\\n\" +\n+            \"qznYhHMAAAGIB72TmwAABAMARzBFAiEAgEqT7CYGQ\/u36\/3YcxBH78QfknI9kgcY\\n\" +\n+            \"sgJLkurUF6cCIFZZ\/b803+ek6o+bmdV\/uVx2UlskAyyolZ2okBAb6IscAHYA2ra\/\\n\" +\n+            \"az+1tiKfm8K7XGvocJFxbLtRhIU0vaQ9MEjX+6sAAAGIB72TbQAABAMARzBFAiEA\\n\" +\n+            \"6z2RSoK263hvYF71rj1d0TpC70\/6zagSRR4glHOT6IACICYvaMAnrCNSTSiZ20Wz\\n\" +\n+            \"Ju5roTippO3BWKhQYrTKZuu4MA0GCSqGSIb3DQEBCwUAA4IBAQB4S1JGulFpMIaP\\n\" +\n+            \"NtLUJmjWz8eexQdWLDVF+H8dd6xpZgpiYtig\/Ynphzuk1IIF8DkT3CeK\/9vrezgI\\n\" +\n+            \"igNjneN9B4eIuzi\/rJzIKeUwpZ2k5D+36Ab4esseoc+TopmNerw8hidt2g818jER\\n\" +\n+            \"D71ppSMakeQFPGe\/Hs2\/cVa\/G1DNVcU2XAut45yRZ\/+xsZ0\/mcBDVsG9P5uGCN5O\\n\" +\n+            \"7SAp4J959WnKDqgVuU9WowPE5IjmS9BAv2gjniFYdDV2yksyf7+8edHd1KfSVX06\\n\" +\n+            \"pLx6CuCVZGJFG4Q2Aa1YAh1Wvt9hqWeXXpNRO2\/wChL5rhT4GajsrGepsk4bjxYX\\n\" +\n+            \"Wf2iZ8mX\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+\n+        \/\/ Validate valid\n+        pathValidator.validate(new String[]{VALID, INT_VALID},\n+                ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+        \/\/ Validate Revoked\n+        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n+                ValidatePathWithParams.Status.REVOKED,\n+                \"Mon May 15 13:36:57 PDT 2023\", System.out);\n+    }\n+}\n+\n+class AmazonCA_2 {\n+\n+    \/\/ Owner: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 2, O=Amazon, C=US\n+    \/\/ Serial number: 773125b0c34c3c940299a9f04a39e5a52ccd9\n+    \/\/ Valid from: Tue Aug 23 15:29:13 PDT 2022 until: Fri Aug 23 15:29:13 PDT 2030\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIGXjCCBEagAwIBAgITB3MSWww0w8lAKZqfBKOeWlLM2TANBgkqhkiG9w0BAQwF\\n\" +\n+            \"ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\\n\" +\n+            \"b24gUm9vdCBDQSAyMB4XDTIyMDgyMzIyMjkxM1oXDTMwMDgyMzIyMjkxM1owPDEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n+            \"QSA0MDk2IE0wMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMGMl\/pZ\\n\" +\n+            \"1OsxHY9gw\/YfdON4mmrANkPwi7z2djHA5ELt\/vRI3Su0le6OoipLf03iyoCnYy4Y\\n\" +\n+            \"rpfTbhyDriE8NJpps2ODJ5W1h0rz6FM1Q5Jt35wfk+4CEfATBTegHVlUJ0rJgzK5\\n\" +\n+            \"Yl\/jrk12ZsC4ZeRn54shszcK6bHj4LZIHXhrYIIfetBMMD8V7hlhd54AclEWutUV\\n\" +\n+            \"eBEjkSCzDSk+pQKIjCL0crqvRSPvUNry\/BV65zfGmceSYxpcLmV7k7Spwpo+1z8w\\n\" +\n+            \"+Odfnx2vsm7olPldfaThqk6fXBtInORl4Ef32xF3VDT13UeXtQPolFhnp8UOci64\\n\" +\n+            \"bW+R8tbtGpUXIA8Dhr8SgYPH6NW4jhUD4+AG8yer8ctA1Hl9tq+6tYr26q3yuCLu\\n\" +\n+            \"5rwJdfMG634fWIRXSj+GJi8SfAdGtPyXwu5799NWesV4vUkrkSXdIBK4TQCuK+jx\\n\" +\n+            \"aJ5Y+Zo2l3GFsWyMPNORLjoQXbjF6KAyjTyICLq9VzoQKhyx4Ll2CNrQv8CxqtDC\\n\" +\n+            \"GvXi9kREJYAF6lscOB0xglAAF5lndcaNkVHEVOMdg9ZZtdJywHWm8Qed1Wty2qr+\\n\" +\n+            \"hmA7booWQNRE12nW1niC5D4cP2ykPK9HSgb7xWdUF32VidUc9tNKM6xKjSd\/R\/tP\\n\" +\n+            \"p+XAybNSwEooPt3\/OvyhpVRjLuWoqqbClTKdAgMBAAGjggFaMIIBVjASBgNVHRMB\\n\" +\n+            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n+            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFJ5xHxodk6nZLY7MSFM\/A1TznuZmMB8GA1Ud\\n\" +\n+            \"IwQYMBaAFLAM8Eww9AVYAkj9M+VSr0uE42ZSMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n+            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhMi5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n+            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhMi5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n+            \"dGNhMi5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2EyLmFt\\n\" +\n+            \"YXpvbnRydXN0LmNvbS9yb290Y2EyLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAN\\n\" +\n+            \"BgkqhkiG9w0BAQwFAAOCAgEAl1GgKXOn0j1MWT1KJVSewQ28SGbie3UwZj1dMsjJ\\n\" +\n+            \"amCrQPn2ngSNbLm9+ulFiBDU8xKR9Zx3tZps55IUKWLUPkfMC+vkV7asDBqqzzE0\\n\" +\n+            \"F\/MkekgPfOjx1V9S6Wfg3sSg+9KcluurXFElruqKfOm4cqmkV776X1G+AaaQ7mlU\\n\" +\n+            \"giCYi6NqRQSyhn8zrKkNnbO6QL5a9ICC47kiZYRAR\/hRvZOt11QUK5tCMXJXo0iO\\n\" +\n+            \"4XKkMu+jdnehP1kh4xuZhYznIgKK6MJIITFI\/Jj89U4SOPncyuS94sUuE2EqvvO\/\\n\" +\n+            \"t81qeoey6wThz5iRbU\/0CvDFnTMgebWGUZ2UZJ+az\/rb3KYXGfVWasLIonkvYT7z\\n\" +\n+            \"vHOGNAA9oQ8TTgPOmPfSVyfpplKtO\/aybWp5QSH2csIwuvw5dkmpkc42iD57XHob\\n\" +\n+            \"5LbMJg99z3vQBmod\/ipmOpND95\/BeA2mllBZgZ53S0nvDXDzbzR9Fd81PAz9Qruo\\n\" +\n+            \"dOJKcD6plKQjZjkLzNh1v\/RoCFO8kiJGE4UBMTM8FUk0DXH4bALII4wwmDelrSUu\\n\" +\n+            \"lKvDTDxZvPF4dbEXICNPd51EMGPgETxwboOV+bzWFVI0IWQ8PhZ2VuMPDk2taOMp\\n\" +\n+            \"NsuLtlYc2twPb9r\/Hvgv7G6+ItpBHZwOVt1oI3pHbjMp7P3pOZSPr6G1WkNy9mX8\\n\" +\n+            \"rVc=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=valid.rootca2.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n+    \/\/ Serial number: 662f7646d76193cbb76946d111e49fa\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIICzCCBfOgAwIBAgIQBmL3ZG12GTy7dpRtER5J+jANBgkqhkiG9w0BAQwFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n+            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbTCCAiIw\\n\" +\n+            \"DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAON5EbEKoBiujI7Ja8mLZLJbaY7f\\n\" +\n+            \"RtoWIjU\/F0l9ueWFogXmEaA1jWsl97F3WTHTyGKz6ChCjPMSyoXXpY+yoE90QUyX\\n\" +\n+            \"w35uWEhNrc40drMJkyN+QXitSrH346GCOKvpYVvu18UD4W8hDhg8vvbOQYhtmSf7\\n\" +\n+            \"Rfrs7\/qUdXpzpvR9VjWktbQAzJT8fB\/jFNjNQJTknynjGiYO5GF51+peOCLK6qw8\\n\" +\n+            \"9kKYEigR4K8\/aWL283rC4xRxZqVioy433VG02l\/Fwdv8o\/vL9YYIqkyspCB9fpFw\\n\" +\n+            \"Q50yYrwEomxuOz7rXhmdfeNaFYuyTtOUSKff6p2oqO0S7pcLujUVMlO4dYBDELQF\\n\" +\n+            \"cabByNjwblviCtGKJMIzD6Thkgamp3iXQgcU498+P5r7N5CYbMmkJEdcuILg+bgJ\\n\" +\n+            \"\/LUUTT+IMt2txYlO\/ld3N0EHlgVt7rztW5mtm6Ba8jN7cLSh7ZWu6Fr1+oK7bl5T\\n\" +\n+            \"wPxSfqT5W3BwQKS3YptIoKEWUb+VNnS\/dYx\/7IspF9+z6kw4g+V2EY9M4ZYNakzM\\n\" +\n+            \"AI7KIj4thMFoWeYrJq0dUMZ297QCBPRdAwh9hhkq2LYi2x8tMUtcBnhb\/q75sO+E\\n\" +\n+            \"icPqFVv7iMDZ\/8Xep+0UoClF3JGmZW3UNtwcbi7Pn\/OqtaMi7E8xnHUgc4ZchtXO\\n\" +\n+            \"v8VtVvDeZAlY5TjVAgMBAAGjggMWMIIDEjAfBgNVHSMEGDAWgBSecR8aHZOp2S2O\\n\" +\n+            \"zEhTPwNU857mZjAdBgNVHQ4EFgQUnGekBRKIZBYgCEajbpCMC24bp2owSQYDVR0R\\n\" +\n+            \"BEIwQIIidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n+            \"Y2EyYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWgMB0GA1UdJQQWMBQG\\n\" +\n+            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n+            \"LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n+            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5y\\n\" +\n+            \"NG0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQucjRt\\n\" +\n+            \"MDIuYW1hem9udHJ1c3QuY29tL3I0bTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfQYK\\n\" +\n+            \"KwYBBAHWeQIEAgSCAW0EggFpAWcAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n+            \"SFlGcR+1mwAAAYgHvX9QAAAEAwBHMEUCIQD8qPPCLL2Grd+\/YNALWqAq7LC7YBaa\\n\" +\n+            \"dNg5+6Q4kRDEqgIgEkf\/UMsMNfTRaOZvoOgAK9\/F0xX\/CfdcUTjULhmoA+cAdQBI\\n\" +\n+            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvX8UAAAEAwBGMEQC\\n\" +\n+            \"IBVFDtapMMWJOqyu8Cv6XEhFmbU8N33c2owed\/\/pa80xAiAT9T6Wba3B9DFUmrL5\\n\" +\n+            \"cCGKLqciIEUPhPbvjCuUepelrAB2ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2k\\n\" +\n+            \"PTBI1\/urAAABiAe9ft8AAAQDAEcwRQIhAP2XDC\/RlmVtH4WrfSwVosR\/f\/WXRhG5\\n\" +\n+            \"mk9Nwq+ZOIriAiAopPXSH7VwXa3bEAIiTwcV1l10QIDZaIPCU5olknU5CjANBgkq\\n\" +\n+            \"hkiG9w0BAQwFAAOCAgEAFuwMIJdP5rgz6cqOIj2EgF2OU8CUGi\/wJ45BomXWv4Rv\\n\" +\n+            \"U5mOKB+jHOGZZC9dncjAMa44RwoF2I7\/8Y3qLVaoNm46ObvvS+6UvzTcyQqXM7JU\\n\" +\n+            \"cSmdlf9DkspjKPDvMBokVrM4ak5AoxUjuru5qaia3nvbxq7XKO9\/FGUaUaU8Xlsd\\n\" +\n+            \"V6Fo8VmNwFc88VCqOp8eI\/IicHxMDLl8TKXMvr3CYh8A9nCeFGcV+4CL+7JF2t5K\\n\" +\n+            \"YvV5r074Wyk0QMlRVYMNDl0t+VAEoDJ7RRE+kEvplWcsX9S2wvr4HhkA4iChpwFm\\n\" +\n+            \"2UDTppHskSWyLsuNQvipn0zTzZ8RIxXd\/ei0qCdhKmkV7x9cgbTiyXgaI7iJEtdo\\n\" +\n+            \"RvYNcXc2RmitWjY5Av8yJGOk0eYpCwRrBv6ughbtJe3NMrqUeTyrKidIEo9KnRSA\\n\" +\n+            \"rMokRbHunkroS97VkoK\/9j9pNJki+qAH9XTLYWcm\/5+cTSGRsN+escRgZwV6KWg\/\\n\" +\n+            \"JQQe5LbwU2HHzNqWuk63GC\/ngVlWXjaVFfbNVmYEKZFFazcZchesN1YyDu+WndOx\\n\" +\n+            \"+rTcuke2feOvQ4EnVviM0k85JZNiqPDH2iafAWyqZFUYTnb7XK3HhJflAniv\/SLq\\n\" +\n+            \"DQfbJmtQtNHdJYgVmC1u2RT9gbJDIAj0ZI4vU2WVB5Hmd9F31un6jundEuG4+S4=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=revoked.rootca2.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n+    \/\/ Serial number: 788baa8f47bc5b1c624424216240fd3\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIIEjCCBfqgAwIBAgIQB4i6qPR7xbHGJEJCFiQP0zANBgkqhkiG9w0BAQwFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n+            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2EyLmRlbW8uYW1hem9udHJ1c3QuY29tMIIC\\n\" +\n+            \"IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzJfddWdrWhA9dSJdmy23veN9\\n\" +\n+            \"oLvSqpM4YaXGZmPtKUmbFMLs2I3vCKrzflRKeOpl3MCc2hh6TH\/3z+Q\/fGugXLsY\\n\" +\n+            \"H8QcjSbiIOd15n+3dUFTLKaoWMyseMcWiOIVaN5rCDVXiAHdt1pc147wyFQIzqNK\\n\" +\n+            \"J\/xiV1u9eT2MFue+4bd7kUNAcmI8M+SXruhto4jtAV8ugpTEChTDlyO\/l8xmaM1Q\\n\" +\n+            \"HkijsHX7Aq72Q\/3PH\/U+wbJ9pmpTp4x2AEJoo45IGfB\/NKDTrv5otLBuiP8Y0M7b\\n\" +\n+            \"K7irRPDFBqMNZw7S7p39SnC+V\/WibJQk5Bo\/8vcwDJX+WnDkw1QD\/uXu3ugDzSDD\\n\" +\n+            \"iBDViMOdN+3K47s4x2kdssoh4WWScMlAVb4vyN7IA3J4TnwA\/1uCWhw4LE1WvY7N\\n\" +\n+            \"etekhVP1eWF8IzNY0oo2u2ie79777xvBtmtp7RnvYLGv7I+xVhjH5qGNzn9fRCUm\\n\" +\n+            \"QDego5HAfJ0PLlMEagdW8asCak1WaC117adnibL6WPtFA2FD2i6gNalTvhXhK2Ex\\n\" +\n+            \"alGxrVd\/BCseT3bMp783jqScJO1g6xRHu0Qx+RyrOGVvcKZa6Y0DcAc8psRpkHaO\\n\" +\n+            \"HZY+lE8O2CIxpAJlwSnD6BoDNo8sg1IqFNkECw3wqfeMPBcg38k6zjAxwRDcIx6U\\n\" +\n+            \"SwDl4d3sjrmy3gOFFXMCAwEAAaOCAxswggMXMB8GA1UdIwQYMBaAFJ5xHxodk6nZ\\n\" +\n+            \"LY7MSFM\/A1TznuZmMB0GA1UdDgQWBBQXpWT7gMHO+HKoHM1gU1VQVnylRzBOBgNV\\n\" +\n+            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTIuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n+            \"dm9rZWQuc2NhMmEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIFoDAdBgNV\\n\" +\n+            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n+            \"cDovL2NybC5yNG0wMi5hbWF6b250cnVzdC5jb20vcjRtMDIuY3JsMBMGA1UdIAQM\\n\" +\n+            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n+            \"L29jc3AucjRtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n+            \"Y3J0LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n+            \"ADCCAX0GCisGAQQB1nkCBAIEggFtBIIBaQFnAHYA7s3QZNXbGs7FXLedtM0TojKH\\n\" +\n+            \"Rny87N7DUUhZRnEftZsAAAGIB72CzgAABAMARzBFAiEA2vPYIPfGJeynPaZHq\/c0\\n\" +\n+            \"GGvyT6MpvFGMW0s0woLRT28CIEFbZbFSCnKugaqw9QDNi7vYmIF3Gyi3s6G2cCxY\\n\" +\n+            \"4RJXAHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72DDgAA\\n\" +\n+            \"BAMARzBFAiAvfNcgtFEwk5C9dvMUYANbIAv0IOdF1new8Umn3cM+JwIhALbs\/3L9\\n\" +\n+            \"0ndF7sRKDZmfronNruptFlrI528P5Qi2P528AHUA2ra\/az+1tiKfm8K7XGvocJFx\\n\" +\n+            \"bLtRhIU0vaQ9MEjX+6sAAAGIB72CxQAABAMARjBEAiBKUns2FPbs0cThb6e7SnyL\\n\" +\n+            \"y4\/qP3V1Q\/ASt\/ZDRTeEQQIgWSQO4Gsz32srtqYuTM9AsFd92WA44kJHincdcGVX\\n\" +\n+            \"XbIwDQYJKoZIhvcNAQEMBQADggIBAAnaNbn2wXylTCS7dtgB3rWdUf6hja1UDuvB\\n\" +\n+            \"uZEL2dUOvyXfVFLNxKdeWBPzqpwEBNNwPQXhoI97TXlyu2x60jLzQamoGoRQ3s0P\\n\" +\n+            \"NLhasLGEIQH\/oYdMV\/yp8EI8fUuRVE3xyw39FRqOrmsUFAnxNQmBO\/09JM7sLcvS\\n\" +\n+            \"wwh14p9dFTTolJHgnL4ZEtmZxSddFG+GBSTJ\/A7dVSmwIudwzd+goA6173BI6yeT\\n\" +\n+            \"hhQumLctQiOM7y1MzFeV8rL+oIpd2xuzyhKKT1EgvU6\/wyt0Ib8QqsFsrXPnUOKk\\n\" +\n+            \"HAq3SeZyq35QUaTKoaH9L1iZMbSCG9Jm6FMb12SdAz53653tYvAiUS76oD8Jot13\\n\" +\n+            \"RZu5NUlWAVLLq0OaEtuGp0bh+cVtzVnCC9m1qa46YpY0SojpvSbakgQMMGIgDlT3\\n\" +\n+            \"wFE7tST4WlsDC1f\/m+H9V5qz\/j0U8D3eNNdowxPqx\/JZq\/sk9ZK5KyMFARrvM+fh\\n\" +\n+            \"YrVYjKt91mu7JaS4pPOyZmJ8OQ14EvrN7BXc7IkNrI1reeaRFe49k5DAETB8VmP5\\n\" +\n+            \"2F0SWou2KkgtJvU4Z7YjlZ2HNHnpjTK5KdPNpRSt7EUy2zn9NCNoyQhnws70FyXv\\n\" +\n+            \"oPFyG92lnUQOKaAUhVRwTr9fvnkdMOzSKg\/spxi2Ogdzym5Jw68eguwi0dVqX2+9\\n\" +\n+            \"3zViP2aH\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+\n+        \/\/ Validate valid\n+        pathValidator.validate(new String[]{VALID, INT},\n+                ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+        \/\/ Validate Revoked\n+        pathValidator.validate(new String[]{REVOKED, INT},\n+                ValidatePathWithParams.Status.REVOKED,\n+                \"Mon May 15 13:38:54 PDT 2023\", System.out);\n+    }\n+}\n+\n+class AmazonCA_3 {\n+\n+    \/\/ Owner: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 3, O=Amazon, C=US\n+    \/\/ Serial number: 773126de2c2fafd2c47ad88b1566e0182046d\n+    \/\/ Valid from: Tue Aug 23 15:33:24 PDT 2022 until: Fri Aug 23 15:33:24 PDT 2030\n+    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIC1DCCAnmgAwIBAgITB3MSbeLC+v0sR62IsVZuAYIEbTAKBggqhkjOPQQDAjA5\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\\n\" +\n+            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzMyNFoXDTMwMDgyMzIyMzMyNFowPTELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n+            \"IDI1NiBNMDIwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAS9vQLD4W\/Kg4AnFRl8\\n\" +\n+            \"x\/FUbLqtd5ICYjUijGsytF9hmgb\/Dyk+Ebt4cw6rAlGbaiOLapSJKZiZr+UQdh3I\\n\" +\n+            \"QOr+o4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n+            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBS7eJrXaDMy\\n\" +\n+            \"nRq7bP2xNEwB3svQdTAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n+            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n+            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n+            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSQAwRgIhAKSYEcDcp3kcPMzh\\n\" +\n+            \"OIYDWZOLu4InPod4fQhRTmc2zBAgAiEAmwdGE4AuNWhw9N8REhf82rJLNm7h9Myg\\n\" +\n+            \"TsR9Wu0bQYU=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 3, O=Amazon, C=US\n+    \/\/ Serial number: 773126684d577c0fcf8d3a342bea86f94fc8f\n+    \/\/ Valid from: Tue Aug 23 15:31:46 PDT 2022 until: Fri Aug 23 15:31:46 PDT 2030\n+    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIC0zCCAnmgAwIBAgITB3MSZoTVd8D8+NOjQr6ob5T8jzAKBggqhkjOPQQDAjA5\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\\n\" +\n+            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzE0NloXDTMwMDgyMzIyMzE0NlowPTELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n+            \"IDI1NiBNMDEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAT80w+2RwNHzyXmVUM\/\\n\" +\n+            \"OUKBZpJkTzHyCKDl4sBrUfjzVjot\/lNba9kYzMKSHYv95CUDoMaF2h2KAqx65uLQ\\n\" +\n+            \"Y8ago4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n+            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBRPWfy8BhYo\\n\" +\n+            \"v6LI2wj7zxMkumlCXDAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n+            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n+            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n+            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSAAwRQIhALRfxq3SQIhj5xA4\\n\" +\n+            \"S5UAY\/KlKqayZDpnbBdCDH8Kqmf\/AiAUVZddALefnqRe+ifxN2FUp461LL6\/cgVM\\n\" +\n+            \"EH3Ty27f1Q==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=valid.rootca3.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n+    \/\/ Serial number: 8e2f14864fb28e4a1da0f15a5118cc8\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIEfjCCBCWgAwIBAgIQCOLxSGT7KOSh2g8VpRGMyDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMjU2IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n+            \"BgNVBAMTInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6b250cnVzdC5jb20wWTATBgcq\\n\" +\n+            \"hkjOPQIBBggqhkjOPQMBBwNCAAQfWc7gBGBBBmseCb2XWWRQVhCUQDVml3mVgvj5\\n\" +\n+            \"RmnP1y5wpifUTFqu8ELdI7YGZ4JMSnetiKNmLtg5yhTEjzCQo4IDFTCCAxEwHwYD\\n\" +\n+            \"VR0jBBgwFoAUu3ia12gzMp0au2z9sTRMAd7L0HUwHQYDVR0OBBYEFHCE8orvZDUK\\n\" +\n+            \"5TI9MYadzxWR9CZGMEkGA1UdEQRCMECCInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6\\n\" +\n+            \"b250cnVzdC5jb22CGmdvb2Quc2NhM2EuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\\n\" +\n+            \"\/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQw\\n\" +\n+            \"MjAwoC6gLIYqaHR0cDovL2NybC5lMm0wMi5hbWF6b250cnVzdC5jb20vZTJtMDIu\\n\" +\n+            \"Y3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEF\\n\" +\n+            \"BQcwAYYhaHR0cDovL29jc3AuZTJtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUF\\n\" +\n+            \"BzAChipodHRwOi8vY3J0LmUybTAyLmFtYXpvbnRydXN0LmNvbS9lMm0wMi5jZXIw\\n\" +\n+            \"DAYDVR0TAQH\/BAIwADCCAXwGCisGAQQB1nkCBAIEggFsBIIBaAFmAHUA7s3QZNXb\\n\" +\n+            \"Gs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB71y\/gAABAMARjBEAiAEAXIb\\n\" +\n+            \"aOVR26HgFaI+qoIasCb8w2sOqVxGAxf5iPgX6QIgdAlMjqeoihi1arnJpzN8Bqxy\\n\" +\n+            \"5ULMUO7GK3JEgcogJHMAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiE\\n\" +\n+            \"cwAAAYgHvXLkAAAEAwBHMEUCIF7wDDmWxTHwBZM7Me8eOCM1aQ\/g1c1rJg\/I+NJa\\n\" +\n+            \"HkZYAiEA8p+IviuY5piHBELjUtVlZLiS9XSSMxpQNhUerqC\/YFoAdQDatr9rP7W2\\n\" +\n+            \"Ip+bwrtca+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXKvAAAEAwBGMEQCIFLskZDs\\n\" +\n+            \"UG4+\/88D\/5\/QbD9zT6ZmZlwXiPZ6H2YR\/KiJAiBvi4vvNsb9KNAhJMgI2T2iCg9U\\n\" +\n+            \"CIru+US6y3ua7dKKDTAKBggqhkjOPQQDAgNHADBEAiAzvgzKV\/kvBbKWCT1NNUBD\\n\" +\n+            \"AF9okIEcJx\/ukFgzmYMwUQIgXeJeVf3izkxsgiEUSknwHsErLFs\/cEme2PSRj2AW\\n\" +\n+            \"dYA=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=revoked.rootca3.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n+    \/\/ Serial number: c458bfaeedae16a5e61fe64773fc898\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIEhzCCBC2gAwIBAgIQDEWL+u7a4WpeYf5kdz\/ImDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMjU2IE0wMTAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n+            \"BgNVBAMTJHJldm9rZWQucm9vdGNhMy5kZW1vLmFtYXpvbnRydXN0LmNvbTBZMBMG\\n\" +\n+            \"ByqGSM49AgEGCCqGSM49AwEHA0IABAsSs5kW5TZlS0SDrMb9iUQAqEaKa12Fc6SN\\n\" +\n+            \"9UR6qtOFdW\/1UuziDq3Hl5dqsAYZJkbJSPCIsD2HTP\/EGTMKITCjggMbMIIDFzAf\\n\" +\n+            \"BgNVHSMEGDAWgBRPWfy8BhYov6LI2wj7zxMkumlCXDAdBgNVHQ4EFgQUeE55ET2e\\n\" +\n+            \"i8KbY7KHTxOuvCkRpTowTgYDVR0RBEcwRYIkcmV2b2tlZC5yb290Y2EzLmRlbW8u\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tgh1yZXZva2VkLnNjYTNhLmFtYXpvbnRydXN0LmNvbTAO\\n\" +\n+            \"BgNVHQ8BAf8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMDsG\\n\" +\n+            \"A1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuZTJtMDEuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"L2UybTAxLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATB1BggrBgEFBQcBAQRpMGcw\\n\" +\n+            \"LQYIKwYBBQUHMAGGIWh0dHA6Ly9vY3NwLmUybTAxLmFtYXpvbnRydXN0LmNvbTA2\\n\" +\n+            \"BggrBgEFBQcwAoYqaHR0cDovL2NydC5lMm0wMS5hbWF6b250cnVzdC5jb20vZTJt\\n\" +\n+            \"MDEuY2VyMAwGA1UdEwEB\/wQCMAAwggF9BgorBgEEAdZ5AgQCBIIBbQSCAWkBZwB2\\n\" +\n+            \"AHb\/iD8KtvuVUcJhzPWHujS0pM27KdxoQgqf5mdMWjp0AAABiAe9lQ8AAAQDAEcw\\n\" +\n+            \"RQIgZVFAX5WPZRBpEOqk620v4Rbzxh\/3wrJ5QBMBJ0Mb8B0CIQC0oxFVLfs+PAv7\\n\" +\n+            \"25wawOu2VgDXG9lJAJtCwk3gN8BshQB2AEiw42vapkc0D+VqAvqdMOscUgHLVt0s\\n\" +\n+            \"gdm7v6s52IRzAAABiAe9lQ4AAAQDAEcwRQIhAIPVMj6IfjAUKeGYbpG9s0DRdWbc\\n\" +\n+            \"b8OzsOf+kRqk03NMAiB777hfoFCUMPrN0g8o5v6zp3T3qOhRnYY0TZN4q4NnMgB1\\n\" +\n+            \"ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2kPTBI1\/urAAABiAe9lN4AAAQDAEYw\\n\" +\n+            \"RAIgL0qoVbKLFD+Y3f\/V6Rw+euZrPO6d1HEVPQGo7wLzkl8CIGHp3PQmmrEofl76\\n\" +\n+            \"4da7bY0L+csFW0sB8clN0KziMfe6MAoGCCqGSM49BAMCA0gAMEUCIQC+6VdX9X5g\\n\" +\n+            \"x3NSUmJ7py01Zxf26TNBv1ildxqesvZ\/7wIgIrefriRzPiIFDHCUbdjk0VlmMwZR\\n\" +\n+            \"VzXXHINsGCiCKOs=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+\n+        \/\/ Validate valid\n+        pathValidator.validate(new String[]{VALID, INT_VALID},\n+                ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+        \/\/ Validate Revoked\n+        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n+                ValidatePathWithParams.Status.REVOKED,\n+                \"Mon May 15 13:41:22 PDT 2023\", System.out);\n+    }\n+}\n+\n+class AmazonCA_4 {\n+\n+    \/\/ Owner: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 4, O=Amazon, C=US\n+    \/\/ Serial number: 773127dfaa6b9e2b95538aa76dde4307f17c4\n+    \/\/ Valid from: Tue Aug 23 15:36:58 PDT 2022 until: Fri Aug 23 15:36:58 PDT 2030\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIDETCCApagAwIBAgITB3MSffqmueK5VTiqdt3kMH8XxDAKBggqhkjOPQQDAzA5\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\\n\" +\n+            \"Um9vdCBDQSA0MB4XDTIyMDgyMzIyMzY1OFoXDTMwMDgyMzIyMzY1OFowPTELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n+            \"IDM4NCBNMDIwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATNYzWQDXV0NoNmR0hJPwJq\\n\" +\n+            \"hjYOOS9z0B2Z7MQudxg5x3Vsib6N+tJkq8dljRq5o6K0bbh\/kRVfoi9wfKhB03Yz\\n\" +\n+            \"gkerrwRCH7Z9gU5nbBY+Y5+EtImq4yOB0n7JQgQxWemjggFaMIIBVjASBgNVHRMB\\n\" +\n+            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n+            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFKbZqzuHmTP\/6Gj4i2GDbNCyuq+9MB8GA1Ud\\n\" +\n+            \"IwQYMBaAFNPsxzplbszh2naaVvuc84ZtV+WBMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n+            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhNC5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n+            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhNC5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n+            \"dGNhNC5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2E0LmFt\\n\" +\n+            \"YXpvbnRydXN0LmNvbS9yb290Y2E0LmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAK\\n\" +\n+            \"BggqhkjOPQQDAwNpADBmAjEA2zCG6x0xMlgSXWEGLN8+1XN+OCYF5vj0Z1jtVy+A\\n\" +\n+            \"pdLlzuxNt9HBWn3hvqvO2W8KAjEApNdsZOCmk5uZBYiuCSBnDH3jyKhN6dWyuuHW\\n\" +\n+            \"9Wj7SxKnOU5+wYWZA0BQAv1KT62i\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=valid.rootca4.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n+    \/\/ Serial number: f579bed3369f1a147ea5d0e8e6532d3\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIEvjCCBESgAwIBAgIQD1eb7TNp8aFH6l0OjmUy0zAKBggqhkjOPQQDAzA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n+            \"BgNVBAMTInZhbGlkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb20wdjAQBgcq\\n\" +\n+            \"hkjOPQIBBgUrgQQAIgNiAAT6\/95JFuvx5t9MVeRZmBtXq63Q2fXZnSwEy2U2F4Qc\\n\" +\n+            \"ejhDwcYfD2HmT6S6GrKqLNJMa5n2YOvet4LZpKJLFF+BQo6FJt5cXkzHHxZ1I4z3\\n\" +\n+            \"8pGU79CpCgFOFy6QUlF68NajggMXMIIDEzAfBgNVHSMEGDAWgBSm2as7h5kz\/+ho\\n\" +\n+            \"+Ithg2zQsrqvvTAdBgNVHQ4EFgQUR\/GnpQkrUsCj8jF6\/JIE1Rs07zswSQYDVR0R\\n\" +\n+            \"BEIwQIIidmFsaWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n+            \"Y2E0YS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgeAMB0GA1UdJQQWMBQG\\n\" +\n+            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n+            \"LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n+            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5l\\n\" +\n+            \"M20wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuZTNt\\n\" +\n+            \"MDIuYW1hem9udHJ1c3QuY29tL2UzbTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfgYK\\n\" +\n+            \"KwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n+            \"SFlGcR+1mwAAAYgHvZA9AAAEAwBHMEUCIQCmzmQOzunsuAg1GpIcNx0isG6ylbhP\\n\" +\n+            \"y9JP4UFclL2hdwIgBtTM89mE7QJDj7h7xr2eRPio1ehgmeYH1PHXxCqHIGYAdgBI\\n\" +\n+            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvZB1AAAEAwBHMEUC\\n\" +\n+            \"IF9hbi82CLU5umfRze4NpX6u4jlT+N8KSaBe6UbhqjBZAiEAi2Y6PTt2+107LxtM\\n\" +\n+            \"oBpHprph7hQvGfjPE+p+rfM\/X+EAdgDatr9rP7W2Ip+bwrtca+hwkXFsu1GEhTS9\\n\" +\n+            \"pD0wSNf7qwAAAYgHvZBeAAAEAwBHMEUCIAI+m4mVE3HtZOEMC5VI7m0nEPdPPJUq\\n\" +\n+            \"fxUKPpeIVmk5AiEA0scVJy7g3Fv+2nTVhbcwWCwn\/Gvc+0txQrc529juflcwCgYI\\n\" +\n+            \"KoZIzj0EAwMDaAAwZQIxAKV837BpqlNHg35EsCCtrJPoQ6RuY9UoHm1O2CdsCXGR\\n\" +\n+            \"Z3kAnlgIV8A\/waI6wQqfsQIwdCqaC+qN60JCnX09YKRD15eQjq1rN3w+llI+lEbS\\n\" +\n+            \"FSMsnoHJcqMZLo9s+4Rf0zS3\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=revoked.rootca4.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n+    \/\/ Serial number: 4a5d392936b4decb818b7fb106ebbd8\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    private static final String REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIExjCCBEygAwIBAgIQBKXTkpNrTey4GLf7EG672DAKBggqhkjOPQQDAzA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n+            \"BgNVBAMTJHJldm9rZWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbTB2MBAG\\n\" +\n+            \"ByqGSM49AgEGBSuBBAAiA2IABFYfMbv5\/vgqDunZj4ffJiuELtdwfEPXx9QlZnCm\\n\" +\n+            \"rBP3Z4\/GvUVRVmyh5sYdnbCGCEClH\/RxU6BC5SKv+TzhsFLEumhezanljnQXRAIL\\n\" +\n+            \"a1OGbP8zLLP6FuAD0cjY3P3adKOCAx0wggMZMB8GA1UdIwQYMBaAFKbZqzuHmTP\/\\n\" +\n+            \"6Gj4i2GDbNCyuq+9MB0GA1UdDgQWBBSqnGV5pN\/agPCtVdV37CP1z\/DUqjBOBgNV\\n\" +\n+            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n+            \"dm9rZWQuc2NhNGEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIHgDAdBgNV\\n\" +\n+            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n+            \"cDovL2NybC5lM20wMi5hbWF6b250cnVzdC5jb20vZTNtMDIuY3JsMBMGA1UdIAQM\\n\" +\n+            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n+            \"L29jc3AuZTNtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n+            \"Y3J0LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n+            \"ADCCAX8GCisGAQQB1nkCBAIEggFvBIIBawFpAHYAdv+IPwq2+5VRwmHM9Ye6NLSk\\n\" +\n+            \"zbsp3GhCCp\/mZ0xaOnQAAAGIB72QJQAABAMARzBFAiA74zKrlL+y5rYwSLxBL8fs\\n\" +\n+            \"QYRYXF0s0sGoaSEeAg1DkgIhAPu8Z0TLIFoppmyiv+A5z6S+SG+v\/kOsAYmQmiUO\\n\" +\n+            \"5scIAHcASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72QJgAA\\n\" +\n+            \"BAMASDBGAiEAg+x7JBT3oIaZdnfgGN1G6SAiNUL7zR\/tBhbWIG9tz94CIQDGwBiV\\n\" +\n+            \"Tslt11+W3ZaNsS7UtUIiB45YHUc4qKm5ry2fTAB2ANq2v2s\/tbYin5vCu1xr6HCR\\n\" +\n+            \"cWy7UYSFNL2kPTBI1\/urAAABiAe9kAgAAAQDAEcwRQIgPvKfSpMJKRocGk9+GNr3\\n\" +\n+            \"hUj8x8WySB\/\/0X116TNgA0gCIQDhGRqxnEZmEFGEfj5GY9vjEfm0kKwcL0lCuwBu\\n\" +\n+            \"NZG4dzAKBggqhkjOPQQDAwNoADBlAjEA1PLdsrko3tDs50aAeEU9Gn+0CG8QKy7R\\n\" +\n+            \"fQaXBTjGETDgGJk\/7zGNpGelKPr\/UYV9AjASwdA32S8jIADxA8HrqiMsVYDFMnbU\\n\" +\n+            \"jLLwR6CTLtAcWtwVmoQ2x0usvTvN8YJBPoA=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+\n+        \/\/ Validate valid\n+        pathValidator.validate(new String[]{VALID, INT},\n+                ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+        \/\/ Validate Revoked\n+        pathValidator.validate(new String[]{REVOKED, INT},\n+                ValidatePathWithParams.Status.REVOKED,\n+                \"Mon May 15 13:42:48 PDT 2023\", System.out);\n+    }\n+}\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/AmazonCA.java","additions":613,"deletions":0,"binary":false,"changes":613,"status":"added"}]}