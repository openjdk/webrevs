{"files":[{"patch":"@@ -1930,1 +1930,10 @@\n-    HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));\n+    oop v = JNIHandles::resolve(value);\n+    if (v == nullptr) {\n+      InstanceKlass *ik = InstanceKlass::cast(k);\n+      fieldDescriptor fd;\n+      ik->find_field_from_offset(offset, false, &fd);\n+      if (fd.is_null_free_inline_type()) {\n+        THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Cannot store null in a null-restricted field\");\n+      }\n+    }\n+    HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, v);\n@@ -1939,2 +1948,2 @@\n-    oop v = JNIHandles::resolve_non_null(value);\n-    vklass->write_value_to_addr(v, ((char*)(oopDesc*)obj) + offset, li->kind(), true, CHECK);\n+    oop v = JNIHandles::resolve(value);\n+    vklass->write_value_to_addr(v, ((char*)(oopDesc*)o) + offset, li->kind(), true, CHECK);\n@@ -2372,1 +2381,1 @@\n-      assert(res != nullptr, \"Must be set in one of two paths above\");\n+      assert(res != nullptr || !arr->is_null_free_array(), \"Invalid value\");\n@@ -2405,15 +2414,1 @@\n-       if (v != nullptr && v->is_a(element_vklass)) {\n-         a->write_value_to_flat_array(v, index, CHECK);\n-       } else {\n-         ResourceMark rm(THREAD);\n-         stringStream ss;\n-         Klass *kl = FlatArrayKlass::cast(a->klass());\n-         ss.print(\"type mismatch: can not store %s to %s[%d]\",\n-             v->klass()->external_name(),\n-             kl->external_name(),\n-             index);\n-         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n-           ss.print(\"[]\");\n-         }\n-         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n-       }\n+       a->write_value_to_flat_array(v, index, CHECK);\n@@ -2425,0 +2420,3 @@\n+         if (v == nullptr && ObjArrayKlass::cast(a->klass())->is_null_free_array_klass()) {\n+           THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Cannot store null in a null-restricted array\");\n+         }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.value\n@@ -30,1 +32,1 @@\n- * @run main\/othervm\/native runtime.valhalla.inlinetypes.InlineWithJni\n+ * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.InlineWithJni\n@@ -33,1 +35,9 @@\n- import jdk.test.lib.Asserts;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n@@ -46,0 +56,2 @@\n+        testJniFieldAccess();\n+        testJniArrayAccess();\n@@ -74,0 +86,279 @@\n+\n+    public static native Object readInstanceField(Object obj, String name, String signature);\n+    public static native void writeInstanceField(Object obj, String name, String signature, Object value);\n+\n+    public static native Object readArrayElement(Object[] array, int index);\n+    public static native void writeArrayElement(Object[] array, int index, Object value);\n+\n+\n+    static value class SmallValue {\n+        byte b;\n+        SmallValue() { b = 1; }\n+        SmallValue(byte b0) { b = b0; }\n+        static public SmallValue getValueA() { return new SmallValue((byte)42); }\n+        static public SmallValue getValueB() { return new SmallValue((byte)111); }\n+    }\n+\n+    static value class MediumValue {\n+        int i0;\n+        int i1;\n+        MediumValue() {\n+            i0 = 2;\n+            i1 = 3;\n+        }\n+        MediumValue(int ia, int ib) {\n+            i0 = ia;\n+            i1 = ib;\n+        }\n+        static public MediumValue getValueA() { return new MediumValue(23, 64); }\n+        static public MediumValue getValueB() { return new MediumValue(-51, -1023); }\n+    }\n+\n+    static value class BigValue {\n+        long l0;\n+        long l1;\n+        long l2;\n+        BigValue() {\n+            l0 = 4L;\n+            l1 = 5L;\n+            l2 = 6L;\n+        }\n+        BigValue(long la, long lb, long lc) {\n+            l0 = la;\n+            l1 = lb;\n+            l2 = lc;\n+        }\n+        static public BigValue getValueA() { return new BigValue(0L, 65525L, Long.MIN_VALUE); }\n+        static public BigValue getValueB() { return new BigValue(Long.MIN_VALUE, 32000L, 0L); }\n+    }\n+\n+    static value class ValueWithOop {\n+        String s;\n+        byte b;\n+        ValueWithOop() {\n+            s = \"Hello Duke!\";\n+            b = (byte)7;\n+        }\n+        ValueWithOop(String s0, byte b0) {\n+            s = s0;\n+            b = b0;\n+        }\n+        static public ValueWithOop getValueA() { return new ValueWithOop(\"Bretagne\", (byte)123); }\n+        static public ValueWithOop getValueB() { return new ValueWithOop(\"Alsace\", (byte)-31); }\n+    }\n+\n+    \/\/ Container with nullable fields (potentially flattened)\n+    static class Container0 {\n+        SmallValue sv = new SmallValue();\n+        MediumValue mv = new MediumValue();\n+        BigValue bv = new BigValue();\n+        ValueWithOop vwo = new ValueWithOop();\n+    }\n+\n+    \/\/ Container with null-restricted fields (potentially flattened)\n+    static class Container1 {\n+        @Strict\n+        @NullRestricted\n+        SmallValue sv = new SmallValue();\n+        @Strict\n+        @NullRestricted\n+        MediumValue mv = new MediumValue();\n+        @Strict\n+        @NullRestricted\n+        BigValue bv = new BigValue();\n+        @Strict\n+        @NullRestricted\n+        ValueWithOop vwo = new ValueWithOop();\n+    }\n+\n+    static String getFieldSignature(Class c, String name) {\n+        try {\n+            return \"L\"+c.getDeclaredField(name).getType().getName().replaceAll(\"\\\\.\", \"\/\")+\";\";\n+        } catch(NoSuchFieldException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void testJniFieldAccessHelper(Object c, boolean nullRestriction) {\n+\n+        String smallSignature = getFieldSignature(c.getClass(), \"sv\");\n+        String mediumSignature = getFieldSignature(c.getClass(), \"mv\");\n+        String bigSignature = getFieldSignature(c.getClass(), \"bv\");\n+        String withOopSignature = getFieldSignature(c.getClass(), \"vwo\");\n+\n+\n+        \/\/ Reading nullable value fields\n+        SmallValue sv = (SmallValue)readInstanceField(c, \"sv\", smallSignature);\n+        Asserts.assertEQ(sv, new SmallValue());\n+        Asserts.assertTrue(sv.b == 1);\n+        MediumValue mv = (MediumValue)readInstanceField(c, \"mv\", mediumSignature);\n+        Asserts.assertEQ(mv, new MediumValue());\n+        Asserts.assertTrue(mv.i0 == 2);\n+        Asserts.assertTrue(mv.i1 == 3);\n+        BigValue bv = (BigValue)readInstanceField(c, \"bv\", bigSignature);\n+        Asserts.assertEQ(bv, new BigValue());\n+        Asserts.assertTrue(bv.l0 == 4);\n+        Asserts.assertTrue(bv.l1 == 5);\n+        Asserts.assertTrue(bv.l2 == 6);\n+        ValueWithOop vwo = (ValueWithOop)readInstanceField(c, \"vwo\", withOopSignature);\n+        Asserts.assertEQ(vwo, new ValueWithOop());\n+        Asserts.assertTrue(vwo.s.equals(\"Hello Duke!\"));\n+        Asserts.assertTrue(vwo.b == 7);\n+\n+\n+        \/\/ Writing non-null value to nullable field\n+        SmallValue nsv = new SmallValue((byte)8);\n+        writeInstanceField(c, \"sv\", smallSignature, nsv);\n+        sv = (SmallValue)readInstanceField(c, \"sv\", smallSignature);\n+        Asserts.assertTrue(sv == nsv);\n+        MediumValue nmv = new MediumValue(9, 10);\n+        writeInstanceField(c, \"mv\", mediumSignature, nmv);\n+        mv = (MediumValue)readInstanceField(c, \"mv\", mediumSignature);\n+        Asserts.assertTrue(mv == nmv);\n+        BigValue nbv = new BigValue(11L, 12L, 13L);\n+        writeInstanceField(c, \"bv\", bigSignature, nbv);\n+        bv = (BigValue)readInstanceField(c, \"bv\", bigSignature);\n+        Asserts.assertTrue(bv == nbv);\n+        ValueWithOop nvwo = new ValueWithOop(\"Bye Duke!\", (byte)14);\n+        writeInstanceField(c, \"vwo\", withOopSignature, nvwo);\n+        vwo = (ValueWithOop)readInstanceField(c, \"vwo\", withOopSignature);\n+        Asserts.assertTrue(vwo == nvwo);\n+\n+\n+        \/\/ Writing null to nullable field\n+        Exception ex = null;\n+        try {\n+            writeInstanceField(c, \"sv\", smallSignature, null);\n+            sv = (SmallValue)readInstanceField(c, \"sv\", smallSignature);\n+            Asserts.assertTrue(sv == null);\n+        } catch(NullPointerException npe) {\n+            ex = npe;\n+        }\n+        Asserts.assertTrue((nullRestriction && ex != null) || (!nullRestriction && ex == null));\n+        ex = null;\n+        try {\n+            writeInstanceField(c, \"mv\", mediumSignature, null);\n+            mv = (MediumValue)readInstanceField(c, \"mv\", mediumSignature);\n+            Asserts.assertTrue(mv == null);\n+         } catch(NullPointerException npe) {\n+            ex = npe;\n+        }\n+        System.out.println(ex + \" \/ \" + nullRestriction);\n+        Asserts.assertTrue((nullRestriction && ex != null) || (!nullRestriction && ex == null));\n+        ex = null;\n+        try {\n+            writeInstanceField(c, \"bv\", bigSignature, null);\n+            bv = (BigValue)readInstanceField(c, \"bv\", bigSignature);\n+            Asserts.assertTrue(bv == null);\n+        } catch(NullPointerException npe) {\n+            ex = npe;\n+        }\n+        Asserts.assertTrue((nullRestriction && ex != null) || (!nullRestriction && ex == null));\n+        ex = null;\n+        try {\n+            writeInstanceField(c, \"vwo\", withOopSignature, null);\n+            vwo = (ValueWithOop)readInstanceField(c, \"vwo\", withOopSignature);\n+            Asserts.assertTrue(vwo == null);\n+        } catch(NullPointerException npe) {\n+            ex = npe;\n+        }\n+        Asserts.assertTrue((nullRestriction && ex != null) || (!nullRestriction && ex == null));\n+    }\n+\n+    static void testJniFieldAccess() {\n+        \/\/ Reading nullable field\n+        try {\n+            Container0 c0 = new Container0();\n+            testJniFieldAccessHelper(c0, false);\n+            Container1 c1 = new Container1();\n+            testJniFieldAccessHelper(c1, true);\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    static void testJniArrayAccessHelper(Object[] array, boolean nullRestriction) {\n+        Object valueA = getValueA(array.getClass().getComponentType());\n+        Object valueB = getValueB(array.getClass().getComponentType());\n+        int length = array.length;\n+\n+        \/\/ Reading elements\n+        for (int i = 0; i < length; i++) {\n+            Object element = readArrayElement(array, i);\n+            Asserts.assertTrue(element == valueA);\n+        }\n+\n+        \/\/ Writing elements\n+        for (int i = 0; i < length; i++) {\n+            writeArrayElement(array, i, valueB);\n+        }\n+        for (int i = 0; i < length; i++) {\n+            Object element = readArrayElement(array, i);\n+            Asserts.assertTrue(element == valueB);\n+        }\n+\n+        \/\/ Writing null\n+        for (int i = 0; i < length; i++) {\n+            Exception ex = null;\n+            try {\n+                writeArrayElement(array, i, null);\n+                Object element = readArrayElement(array, i);\n+                Asserts.assertTrue(element == null);\n+            } catch(NullPointerException npe) {\n+                ex = npe;\n+            }\n+            Asserts.assertTrue((nullRestriction && ex != null) || (!nullRestriction && ex == null));\n+        }\n+    }\n+\n+    static Object getValueA(Class c) {\n+        try {\n+            Method mA = c.getMethod(\"getValueA\");\n+            return mA.invoke(null);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Object getValueB(Class c) {\n+        try {\n+            Method mB = c.getMethod(\"getValueB\");\n+            return mB.invoke(null);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void fillArrayWithValueA(Object[] array) {\n+        Object valueA = getValueA(array.getClass().getComponentType());\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = valueA;\n+        }\n+    }\n+\n+    static void testJniArrayAccessHelper2(Class c) {\n+\n+        Object[] array0 = (Object[])Array.newInstance(c, 10);\n+        fillArrayWithValueA(array0);\n+        testJniArrayAccessHelper(array0, false);\n+\n+        Object[] array1 = ValueClass.newNullableAtomicArray(c, 31);\n+        fillArrayWithValueA(array1);\n+        testJniArrayAccessHelper(array1, false);\n+\n+        Object[] array2 = ValueClass.newNullRestrictedAtomicArray(c, 127, getValueA(c));\n+        fillArrayWithValueA(array2);\n+        testJniArrayAccessHelper(array2, true);\n+    }\n+\n+    static void testJniArrayAccess() {\n+        testJniArrayAccessHelper2(SmallValue.class);\n+        testJniArrayAccessHelper2(MediumValue.class);\n+        testJniArrayAccessHelper2(BigValue.class);\n+        testJniArrayAccessHelper2(ValueWithOop.class);\n+\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineWithJni.java","additions":294,"deletions":3,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -38,0 +38,37 @@\n+\n+JNIEXPORT jobject JNICALL Java_runtime_valhalla_inlinetypes_InlineWithJni_readInstanceField(JNIEnv *env,\n+                       jclass k, jobject obj, jstring name, jstring signature) {\n+    jclass class = (*env)->GetObjectClass(env, obj);\n+    jboolean copy;\n+    const char* name_string = (*env)->GetStringUTFChars(env, name, &copy);\n+    const char *signature_string = (*env)->GetStringUTFChars(env, signature, &copy);\n+    jfieldID fieldId = (*env)->GetFieldID(env, class, name_string, signature_string);\n+    jobject ret =  (*env)->GetObjectField(env, obj, fieldId);\n+    (*env)->ReleaseStringUTFChars(env, name, name_string);\n+    (*env)->ReleaseStringUTFChars(env, signature, signature_string);\n+    return ret;\n+}\n+\n+JNIEXPORT void JNICALL Java_runtime_valhalla_inlinetypes_InlineWithJni_writeInstanceField(JNIEnv *env,\n+                        jclass k, jobject obj, jstring name, jstring signature, jobject value)\n+{\n+    jclass class = (*env)->GetObjectClass(env, obj);\n+    jboolean copy;\n+    const char *name_string = (*env)->GetStringUTFChars(env, name, &copy);\n+    const char *signature_string = (*env)->GetStringUTFChars(env, signature, &copy);\n+    jfieldID fieldId = (*env)->GetFieldID(env, class, name_string, signature_string);\n+    (*env)->SetObjectField(env, obj, fieldId, value);\n+    (*env)->ReleaseStringUTFChars(env, name, name_string);\n+    (*env)->ReleaseStringUTFChars(env, signature, signature_string);\n+    return;\n+}\n+\n+JNIEXPORT jobject JNICALL Java_runtime_valhalla_inlinetypes_InlineWithJni_readArrayElement(JNIEnv *env,\n+                        jclass k, jarray array, int index) {\n+    return (*env)->GetObjectArrayElement(env, array, index);\n+}\n+\n+JNIEXPORT void JNICALL Java_runtime_valhalla_inlinetypes_InlineWithJni_writeArrayElement(JNIEnv *env,\n+                        jclass k, jarray array, int index, jobject value) {\n+    (*env)->SetObjectArrayElement(env, array, index, value);\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/libInlineWithJni.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}