{"files":[{"patch":"@@ -339,2 +339,0 @@\n-  case vmIntrinsics::_makePrivateBuffer:\n-  case vmIntrinsics::_finishPrivateBuffer:\n@@ -350,1 +348,0 @@\n-  case vmIntrinsics::_getValue:\n@@ -361,1 +358,0 @@\n-  case vmIntrinsics::_putValue:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -739,2 +739,0 @@\n-  do_signature(getValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;)Ljava\/lang\/Object;\")                   \\\n-  do_signature(putValue_signature,        \"(Ljava\/lang\/Object;JLjava\/lang\/Class;Ljava\/lang\/Object;)V\")                  \\\n@@ -753,1 +751,0 @@\n-  do_name(getValue_name,\"getValue\")             do_name(putValue_name,\"putValue\")                                       \\\n@@ -755,2 +752,0 @@\n-  do_name(makePrivateBuffer_name,\"makePrivateBuffer\")                                                                   \\\n-  do_name(finishPrivateBuffer_name,\"finishPrivateBuffer\")                                                               \\\n@@ -767,1 +762,0 @@\n-  do_intrinsic(_getValue,           jdk_internal_misc_Unsafe,     getValue_name, getValue_signature,             F_RN)  \\\n@@ -778,1 +772,0 @@\n-  do_intrinsic(_putValue,           jdk_internal_misc_Unsafe,     putValue_name, putValue_signature,             F_RN)  \\\n@@ -781,3 +774,0 @@\n-  do_intrinsic(_makePrivateBuffer,  jdk_internal_misc_Unsafe,     makePrivateBuffer_name, object_object_signature, F_RN)   \\\n-  do_intrinsic(_finishPrivateBuffer,  jdk_internal_misc_Unsafe,   finishPrivateBuffer_name, object_object_signature, F_RN) \\\n-                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -656,2 +656,0 @@\n-  case vmIntrinsics::_makePrivateBuffer:\n-  case vmIntrinsics::_finishPrivateBuffer:\n@@ -667,1 +665,0 @@\n-  case vmIntrinsics::_getValue:\n@@ -678,1 +675,0 @@\n-  case vmIntrinsics::_putValue:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-    case vmIntrinsicID::_finishPrivateBuffer:\n@@ -143,1 +142,0 @@\n-    case vmIntrinsicID::_putValue:\n@@ -209,15 +207,1 @@\n-  if (callee->intrinsic_id() == vmIntrinsics::_makePrivateBuffer || callee->intrinsic_id() == vmIntrinsics::_finishPrivateBuffer) {\n-    \/\/ These methods must be inlined so that we don't have larval value objects crossing method\n-    \/\/ boundaries\n-    assert(!call_does_dispatch, \"callee should not be virtual %s\", callee->name()->as_utf8());\n-    CallGenerator* cg = find_intrinsic(callee, call_does_dispatch);\n-\n-    if (cg == nullptr) {\n-      \/\/ This is probably because the intrinsics is disabled from the command line\n-      char reason[256];\n-      jio_snprintf(reason, sizeof(reason), \"cannot find an intrinsics for %s\", callee->name()->as_utf8());\n-      C->record_method_not_compilable(reason);\n-      return nullptr;\n-    }\n-    return cg;\n-  } else if (allow_inline && allow_intrinsics) {\n+  if (allow_inline && allow_intrinsics) {\n@@ -879,1 +863,1 @@\n-    if (!rtype->is_void() && cg->method()->intrinsic_id() != vmIntrinsicID::_makePrivateBuffer) {\n+    if (!rtype->is_void()) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3531,8 +3531,1 @@\n-    \/\/ Special case: larval inline objects must not be scalarized. They are also generally not\n-    \/\/ allowed to participate in most operations except as the first operand of putfield, or as an\n-    \/\/ argument to a constructor invocation with it being a receiver, Unsafe::putXXX with it being\n-    \/\/ the first argument, or Unsafe::finishPrivateBuffer. This allows us to aggressively scalarize\n-    \/\/ value objects in all other places. This special case comes from the limitation of the Java\n-    \/\/ language, Unsafe::makePrivateBuffer returns an Object that is checkcast-ed to the concrete\n-    \/\/ value type. We must do this first because C->static_subtype_check may do nothing when\n-    \/\/ StressReflectiveCode is set.\n+    \/\/ TODO remnant to support old makePrivateBuffer generic cast, we can probably remove this now\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -330,2 +330,0 @@\n-  case vmIntrinsics::_makePrivateBuffer:        return inline_unsafe_make_private_buffer();\n-  case vmIntrinsics::_finishPrivateBuffer:      return inline_unsafe_finish_private_buffer();\n@@ -341,1 +339,0 @@\n-  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false, true);\n@@ -352,1 +349,0 @@\n-  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false, true);\n@@ -2403,1 +2399,1 @@\n-bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned, const bool is_flat) {\n+bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {\n@@ -2428,1 +2424,1 @@\n-      assert(sig->count() == 2 || (is_flat && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n+      assert(sig->count() == 2, \"oop getter has 2 arguments\");\n@@ -2434,1 +2430,1 @@\n-      assert(sig->count() == 3 || (is_flat && sig->count() == 4), \"oop putter has 3 arguments\");\n+      assert(sig->count() == 3, \"oop putter has 3 arguments\");\n@@ -2461,13 +2457,0 @@\n-  ciInlineKlass* inline_klass = nullptr;\n-  if (is_flat) {\n-    const TypeInstPtr* cls = _gvn.type(argument(4))->isa_instptr();\n-    if (cls == nullptr || cls->const_oop() == nullptr) {\n-      return false;\n-    }\n-    ciType* mirror_type = cls->const_oop()->as_instance()->java_mirror_type();\n-    if (!mirror_type->is_inlinetype()) {\n-      return false;\n-    }\n-    inline_klass = mirror_type->as_inline_klass();\n-  }\n-\n@@ -2490,1 +2473,1 @@\n-        if (bt == type && (!field->is_flat() || field->type() == inline_klass)) {\n+        if (bt == type && (!field->is_flat())) {\n@@ -2520,1 +2503,1 @@\n-    if (type != T_OBJECT && (inline_klass == nullptr || !inline_klass->has_object_fields())) {\n+    if (type != T_OBJECT) {\n@@ -2538,1 +2521,1 @@\n-  Node* val = is_store ? argument(4 + (is_flat ? 1 : 0)) : nullptr;\n+  Node* val = is_store ? argument(4) : nullptr;\n@@ -2583,1 +2566,1 @@\n-    assert(bt == alias_type->basic_type() || is_flat, \"should match\");\n+    assert(bt == alias_type->basic_type(), \"should match\");\n@@ -2610,23 +2593,0 @@\n-  if (is_flat) {\n-    if (adr_type->isa_instptr()) {\n-      if (field == nullptr || field->type() != inline_klass) {\n-        mismatched = true;\n-      }\n-    } else if (adr_type->isa_aryptr()) {\n-      const Type* elem = adr_type->is_aryptr()->elem();\n-      if (!adr_type->is_flat() || elem->inline_klass() != inline_klass) {\n-        mismatched = true;\n-      }\n-    } else {\n-      mismatched = true;\n-    }\n-    if (is_store) {\n-      const Type* val_t = _gvn.type(val);\n-      if (!val_t->is_inlinetypeptr() || val_t->inline_klass() != inline_klass) {\n-        set_map(old_map);\n-        set_sp(old_sp);\n-        return false;\n-      }\n-    }\n-  }\n-\n@@ -2634,1 +2594,1 @@\n-  assert(!mismatched || is_flat || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n+  assert(!mismatched || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n@@ -2647,1 +2607,1 @@\n-    if (type == T_OBJECT && !is_flat) {\n+    if (type == T_OBJECT) {\n@@ -2674,9 +2634,5 @@\n-      if (is_flat) {\n-        p = InlineTypeNode::make_from_flat(this, inline_klass, base, adr, adr_type, false, false, true);\n-      } else {\n-        p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n-        const TypeOopPtr* ptr = value_type->make_oopptr();\n-        if (ptr != nullptr && ptr->is_inlinetypeptr()) {\n-          \/\/ Load a non-flattened inline type from memory\n-          p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass());\n-        }\n+      p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);\n+      const TypeOopPtr* ptr = value_type->make_oopptr();\n+      if (ptr != nullptr && ptr->is_inlinetypeptr()) {\n+        \/\/ Load a non-flattened inline type from memory\n+        p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass());\n@@ -2721,5 +2677,1 @@\n-    if (is_flat) {\n-      val->as_InlineType()->store_flat(this, base, adr, false, false, true, decorators);\n-    } else {\n-      access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n-    }\n+    access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);\n@@ -2900,66 +2852,0 @@\n-bool LibraryCallKit::inline_unsafe_make_private_buffer() {\n-  Node* receiver = argument(0);\n-  Node* value = argument(1);\n-\n-  const Type* type = gvn().type(value);\n-  if (!type->is_inlinetypeptr()) {\n-    C->record_method_not_compilable(\"value passed to Unsafe::makePrivateBuffer is not of a constant value type\");\n-    return false;\n-  }\n-\n-  null_check(receiver);\n-  if (stopped()) {\n-    return true;\n-  }\n-\n-  value = null_check(value);\n-  if (stopped()) {\n-    return true;\n-  }\n-\n-  ciInlineKlass* vk = type->inline_klass();\n-  Node* klass = makecon(TypeKlassPtr::make(vk));\n-  Node* obj = new_instance(klass);\n-  AllocateNode::Ideal_allocation(obj)->_larval = true;\n-\n-  assert(value->is_InlineType(), \"must be an InlineTypeNode\");\n-  Node* payload_ptr = basic_plus_adr(obj, vk->payload_offset());\n-  value->as_InlineType()->store_flat(this, obj, payload_ptr, false, true, true, IN_HEAP | MO_UNORDERED);\n-\n-  set_result(obj);\n-  return true;\n-}\n-\n-bool LibraryCallKit::inline_unsafe_finish_private_buffer() {\n-  Node* receiver = argument(0);\n-  Node* buffer = argument(1);\n-\n-  const Type* type = gvn().type(buffer);\n-  if (!type->is_inlinetypeptr()) {\n-    C->record_method_not_compilable(\"value passed to Unsafe::finishPrivateBuffer is not of a constant value type\");\n-    return false;\n-  }\n-\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer);\n-  if (alloc == nullptr) {\n-    C->record_method_not_compilable(\"value passed to Unsafe::finishPrivateBuffer must be allocated by Unsafe::makePrivateBuffer\");\n-    return false;\n-  }\n-\n-  null_check(receiver);\n-  if (stopped()) {\n-    return true;\n-  }\n-\n-  \/\/ Unset the larval bit in the object header\n-  Node* old_header = make_load(control(), buffer, TypeX_X, TypeX_X->basic_type(), MemNode::unordered, LoadNode::Pinned);\n-  Node* new_header = gvn().transform(new AndXNode(old_header, MakeConX(~markWord::larval_bit_in_place)));\n-  access_store_at(buffer, buffer, type->is_ptr(), new_header, TypeX_X, TypeX_X->basic_type(), MO_UNORDERED | IN_HEAP);\n-\n-  \/\/ We must ensure that the buffer is properly published\n-  insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out(AllocateNode::RawAddress));\n-  assert(!type->maybe_null(), \"result of an allocation should not be null\");\n-  set_result(InlineTypeNode::make_from_oop(this, buffer, type->inline_klass()));\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":15,"deletions":129,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned, bool is_flat = false);\n+  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);\n@@ -265,2 +265,0 @@\n-  bool inline_unsafe_make_private_buffer();\n-  bool inline_unsafe_finish_private_buffer();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -454,22 +454,0 @@\n-UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {\n-  oop base = JNIHandles::resolve(obj);\n-  if (base == nullptr) {\n-    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n-  }\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n-  InlineKlass* vk = InlineKlass::cast(k);\n-  assert_and_log_unsafe_value_access(base, offset, vk);\n-  LayoutKind lk = LayoutKind::UNKNOWN;\n-  if (base->is_array()) {\n-    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n-    lk = fak->layout_kind();\n-  } else {\n-    fieldDescriptor fd;\n-    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n-    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n-  }\n-  Handle base_h(THREAD, base);\n-  oop v = vk->read_payload_from_addr(base_h(), offset, lk, CHECK_NULL);\n-  return JNIHandles::make_local(THREAD, v);\n-} UNSAFE_END\n-\n@@ -491,22 +469,0 @@\n-UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {\n-  oop base = JNIHandles::resolve(obj);\n-  if (base == nullptr) {\n-    THROW(vmSymbols::java_lang_NullPointerException());\n-  }\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n-  InlineKlass* vk = InlineKlass::cast(k);\n-  assert(!base->is_inline_type() || base->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n-  assert_and_log_unsafe_value_access(base, offset, vk);\n-  LayoutKind lk = LayoutKind::UNKNOWN;\n-  if (base->is_array()) {\n-    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n-    lk = fak->layout_kind();\n-  } else {\n-    fieldDescriptor fd;\n-    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n-    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n-  }\n-  oop v = JNIHandles::resolve(value);\n-  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, lk, true, CHECK);\n-} UNSAFE_END\n-\n@@ -528,20 +484,0 @@\n-UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n-  oop v = JNIHandles::resolve_non_null(value);\n-  assert(v->is_inline_type(), \"must be an inline type instance\");\n-  Handle vh(THREAD, v);\n-  InlineKlass* vk = InlineKlass::cast(v->klass());\n-  instanceOop new_value = vk->allocate_instance_buffer(CHECK_NULL);\n-  vk->copy_payload_to_addr(vk->payload_addr(vh()), vk->payload_addr(new_value), LayoutKind::BUFFERED, false);\n-  markWord mark = new_value->mark();\n-  new_value->set_mark(mark.enter_larval_state());\n-  return JNIHandles::make_local(THREAD, new_value);\n-} UNSAFE_END\n-\n-UNSAFE_ENTRY(jobject, Unsafe_FinishPrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n-  oop v = JNIHandles::resolve(value);\n-  assert(v->mark().is_larval_state(), \"must be a larval value\");\n-  markWord mark = v->mark();\n-  v->set_mark(mark.exit_larval_state());\n-  return JNIHandles::make_local(THREAD, v);\n-} UNSAFE_END\n-\n@@ -1204,1 +1140,0 @@\n-    {CC \"getValue\",             CC \"(\" OBJ \"J\" CLS \")\" OBJ, FN_PTR(Unsafe_GetValue)},\n@@ -1206,1 +1141,0 @@\n-    {CC \"putValue\",             CC \"(\" OBJ \"J\" CLS OBJ \")V\", FN_PTR(Unsafe_PutValue)},\n@@ -1208,2 +1142,0 @@\n-    {CC \"makePrivateBuffer\",     CC \"(\" OBJ \")\" OBJ,      FN_PTR(Unsafe_MakePrivateBuffer)},\n-    {CC \"finishPrivateBuffer\",   CC \"(\" OBJ \")\" OBJ,      FN_PTR(Unsafe_FinishPrivateBuffer)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":68,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -297,19 +297,3 @@\n-     * @param o Java heap object in which the variable resides, if any, else\n-     *        null\n-     * @param offset indication of where the variable resides in a Java heap\n-     *        object, if any, else a memory address locating the variable\n-     *        statically\n-     * @param valueType value type\n-     * @param <V> the type of a value\n-     * @return the value fetched from the indicated Java variable\n-     * @throws RuntimeException No defined exceptions are thrown, not even\n-     *         {@link NullPointerException}\n-     *\/\n-    @IntrinsicCandidate\n-    public native <V> V getValue(Object o, long offset, Class<?> valueType);\n-\n-    \/**\n-     * Fetches a value of type {@code <V>} from a given Java variable.\n-     * More specifically, fetches a field or array element within the given\n-     * {@code o} object at the given offset, or (if {@code o} is null)\n-     * from the memory address whose numerical value is the given offset.\n+     * @apiNote\n+     * The returned object is newly allocated into the heap, because flat\n+     * values lack object headers and thus can't be used as objects directly.\n@@ -334,21 +318,0 @@\n-\n-    \/**\n-     * Stores the given value into a given Java variable.\n-     *\n-     * Unless the reference {@code o} being stored is either null\n-     * or matches the field type, the results are undefined.\n-     *\n-     * @param o Java heap object in which the variable resides, if any, else\n-     *        null\n-     * @param offset indication of where the variable resides in a Java heap\n-     *        object, if any, else a memory address locating the variable\n-     *        statically\n-     * @param valueType value type\n-     * @param v the value to store into the indicated Java variable\n-     * @param <V> the type of a value\n-     * @throws RuntimeException No defined exceptions are thrown, not even\n-     *         {@link NullPointerException}\n-     *\/\n-    @IntrinsicCandidate\n-    public native <V> void putValue(Object o, long offset, Class<?> valueType, V v);\n-\n@@ -378,20 +341,0 @@\n-    \/**\n-     * Returns an object instance with a private buffered value whose layout\n-     * and contents is exactly the given value instance.  The return object\n-     * is in the larval state that can be updated using the unsafe put operation.\n-     *\n-     * @param value a value instance\n-     * @param <V> the type of the given value instance\n-     *\/\n-    @IntrinsicCandidate\n-    public native <V> V makePrivateBuffer(V value);\n-\n-    \/**\n-     * Exits the larval state and returns a value instance.\n-     *\n-     * @param value a value instance\n-     * @param <V> the type of the given value instance\n-     *\/\n-    @IntrinsicCandidate\n-    public native <V> V finishPrivateBuffer(V value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":3,"deletions":60,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -410,18 +410,0 @@\n-    MyValue1 test22_vt;\n-\n-    @Test\n-    @IR(failOn = {CALL_UNSAFE})\n-    public void test22(MyValue1 v) {\n-        v = U.makePrivateBuffer(v);\n-        U.putInt(v, X_OFFSET, rI);\n-        v = U.finishPrivateBuffer(v);\n-        test22_vt = v;\n-    }\n-\n-    @Run(test = \"test22\")\n-    public void test22_verifier() {\n-        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n-        test22(v.setX(v, 0));\n-        Asserts.assertEQ(test22_vt.hash(), v.hash());\n-    }\n-\n@@ -772,16 +754,0 @@\n-    @Test\n-    @IR(failOn = {CALL_UNSAFE})\n-    public MyValue1 test39(MyValue1 v) {\n-        v = U.makePrivateBuffer(v);\n-        U.putInt(v, X_OFFSET, rI);\n-        v = U.finishPrivateBuffer(v);\n-        return v;\n-    }\n-\n-    @Run(test = \"test39\")\n-    public void test39_verifier() {\n-        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1 res = test39(v.setX(v, 0));\n-        Asserts.assertEQ(res.hash(), v.hash());\n-    }\n-\n@@ -1751,21 +1717,0 @@\n-    \/* TODO: 8322547: Unsafe::putInt checks the larval bit which leads to a VM crash\n-    @Test\n-    @IR(failOn = {CALL_UNSAFE})\n-    public MyValue1 test84(MyValue1 v) {\n-        v = U.makePrivateBuffer(v);\n-        for (int i = 0; i < 10; i++) {\n-            U.putInt(v, X_OFFSET, i);\n-        }\n-        U.putInt(v, X_OFFSET, rI);\n-        v = U.finishPrivateBuffer(v);\n-        return v;\n-    }\n-\n-    @Run(test = \"test84\")\n-    public void test84_verifier() {\n-        MyValue1 v1 = MyValue1.createWithFieldsInline(rI, rL);\n-        MyValue1 v2 = test84(MyValue1.setX(v1, 0));\n-        Asserts.assertEQ(v1.hash(), v2.hash());\n-    }\n-    *\/\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Arm Limited. All rights reserved.\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8303416\n- * @summary Fix JVM crash at Unsafe_FinishPrivateBuffer\n- * @library \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- * @run main\/othervm compiler.valhalla.inlinetypes.TestLarvalState\n- *\/\n-\n-package compiler.valhalla.inlinetypes;\n-\n-import java.lang.reflect.*;\n-import java.util.Random;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-\n-public class TestLarvalState {\n-    private static int LENGTH = 10000;\n-\n-    private static final Random RD = Utils.getRandomInstance();\n-\n-    static byte[] arr = new byte[LENGTH];\n-\n-    static {\n-        for (int i = 0; i < LENGTH; i++) {\n-            arr[i] = (byte) RD.nextInt(127);\n-        }\n-    }\n-\n-    public static byte test(byte b) {\n-        Value obj = new Value();\n-        obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n-        Unsafe.getUnsafe().putByte(obj, obj.offset, b);\n-        obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n-        return Unsafe.getUnsafe().getByte(obj, obj.offset);\n-    }\n-\n-    public static void main(String[] args) {\n-        byte actual = 0;\n-        for (int i = 0; i < LENGTH; i++) {\n-            actual += test(arr[i]);\n-        }\n-\n-        byte expected = 0;\n-        for (int i = 0; i < LENGTH; i++) {\n-            expected += arr[i];\n-        }\n-        Asserts.assertEquals(expected, actual);\n-    }\n-\n-    static value class Value {\n-        byte field = 0;\n-\n-        static long offset = fieldOffset();\n-\n-        private static long fieldOffset() {\n-            try {\n-                var f = Value.class.getDeclaredField(\"field\");\n-                return Unsafe.getUnsafe().objectFieldOffset(f);\n-            } catch (Exception e) {\n-                System.out.println(e);\n-            }\n-            return -1L;\n-        }\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLarvalState.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -116,8 +116,0 @@\n-\n-    MyValue incrementAndCheckUnsafe() {\n-        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n-        MyValue vt = U.makePrivateBuffer(this);\n-        U.putShort(vt, X_OFFSET, (short)(x + 1));\n-        U.putShort(vt, Y_OFFSET, (short)(y + 1));\n-        return U.finishPrivateBuffer(vt);\n-    }\n@@ -234,16 +226,16 @@\n-                test.field1 = test.field1.incrementAndCheckUnsafe();\n-                test.field2 = test.field2.incrementAndCheckUnsafe();\n-                test.field3 = test.field3.incrementAndCheckUnsafe();\n-                test.field4 = test.field4.incrementAndCheckUnsafe();\n-                array1[0] = array1[0].incrementAndCheckUnsafe();\n-                array2[0] = array2[0].incrementAndCheckUnsafe();\n-                array3[0] = array3[0].incrementAndCheckUnsafe();\n-                array4[0] = array4[0].incrementAndCheckUnsafe();\n-                array5[0] = array5[0].incrementAndCheckUnsafe();\n-                array6[0] = array6[0].incrementAndCheckUnsafe();\n-                array7[0] = ((MyValue)array7[0]).incrementAndCheckUnsafe();\n-                array8[0] = ((MyValue)array8[0]).incrementAndCheckUnsafe();\n-                array9[0] = ((MyValue)array9[0]).incrementAndCheckUnsafe();\n-                array10[0] = ((MyValue)array10[0]).incrementAndCheckUnsafe();\n-                array11[0] = ((MyValue)array11[0]).incrementAndCheckUnsafe();\n-                array12[0] = ((MyValue)array12[0]).incrementAndCheckUnsafe();\n+                test.field1 = test.field1.incrementAndCheck();\n+                test.field2 = test.field2.incrementAndCheck();\n+                test.field3 = test.field3.incrementAndCheck();\n+                test.field4 = test.field4.incrementAndCheck();\n+                array1[0] = array1[0].incrementAndCheck();\n+                array2[0] = array2[0].incrementAndCheck();\n+                array3[0] = array3[0].incrementAndCheck();\n+                array4[0] = array4[0].incrementAndCheck();\n+                array5[0] = array5[0].incrementAndCheck();\n+                array6[0] = array6[0].incrementAndCheck();\n+                array7[0] = ((MyValue)array7[0]).incrementAndCheck();\n+                array8[0] = ((MyValue)array8[0]).incrementAndCheck();\n+                array9[0] = ((MyValue)array9[0]).incrementAndCheck();\n+                array10[0] = ((MyValue)array10[0]).incrementAndCheck();\n+                array11[0] = ((MyValue)array11[0]).incrementAndCheck();\n+                array12[0] = ((MyValue)array12[0]).incrementAndCheck();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTearing.java","additions":16,"deletions":24,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,47 +93,0 @@\n-    public static void test0() throws Throwable {\n-        printValueClass(Value3.class, 0);\n-\n-        Value1 v1 = new Value1(new Point(10,10), new Point(20,20), new Point(30,30));\n-        Value2 v2 = new Value2(v1, 20);\n-        Value3 v3 = new Value3(v2, List.of(\"Value3\"));\n-        long off_o = U.objectFieldOffset(Value3.class, \"o\");\n-        long off_v = U.objectFieldOffset(Value3.class, \"v\");\n-        long off_i = U.objectFieldOffset(Value2.class, \"i\");\n-        long off_v2 = U.objectFieldOffset(Value2.class, \"v\");\n-\n-        long off_point = U.objectFieldOffset(Value1.class, \"point\");\n-\n-        List<String> list = List.of(\"Value1\", \"Value2\", \"Value3\");\n-        Value3 v = v3;\n-        try {\n-            v = U.makePrivateBuffer(v);\n-            \/\/ patch v3.o\n-            U.putReference(v, off_o, list);\n-            \/\/ patch v3.v.i;\n-            U.putInt(v, off_v + off_i - U.valueHeaderSize(Value2.class), 999);\n-            \/\/ patch v3.v.v.point\n-            U.putValue(v, off_v + off_v2 - U.valueHeaderSize(Value2.class) + off_point - U.valueHeaderSize(Value1.class),\n-                       Point.class, new Point(100, 100));\n-        } finally {\n-            v = U.finishPrivateBuffer(v);\n-        }\n-\n-        assertEquals(v.v.v.point, new Point(100, 100));\n-        assertEquals(v.v.i, 999);\n-        assertEquals(v.o, list);\n-        assertEquals(v.v.v.array, v1.array);\n-\n-        Value1 nv1 = new Value1(new Point(70,70), new Point(80,80), new Point(90,90));\n-        Value2 nv2 = new Value2(nv1, 100);\n-        Value3 nv3 = new Value3(nv2, list);\n-\n-        try {\n-            v = U.makePrivateBuffer(v);\n-            \/\/ patch v3.v\n-            U.putValue(v, off_v2, Value2.class, nv2);\n-        } finally {\n-            v = U.finishPrivateBuffer(v);\n-        }\n-        assertEquals(v, nv3);\n-    }\n-\n@@ -208,1 +161,1 @@\n-    \/\/ Testing of nullable flat field supports in Unsafe.getFlatValue()\/Unsafe.putValue()\n+    \/\/ Testing of nullable flat field supports in Unsafe.getFlatValue()\/Unsafe.putFlatValue()\n@@ -210,44 +163,0 @@\n-        Container1 c = new Container1();\n-        Class<?> cc = Container1.class;\n-        Field field = cc.getDeclaredField(\"value\");\n-        Class<?> fc = TestValue1.class;\n-        long offset = U.objectFieldOffset(field);\n-        if (!U.isFlatField(field)) return; \/\/ Field not flattened (due to VM flags?), test doesn't apply\n-        \/\/ Initial value of the field must be null\n-        Asserts.assertNull(U.getValue(c, offset, fc));\n-        \/\/ Writing all zero value to the field, field must become non-null\n-        TestValue1 val0 = new TestValue1((short)0, (short)0);\n-        U.putValue(c, offset, fc, val0);\n-        TestValue1 rval = U.getValue(c, offset, fc);\n-        Asserts.assertNotNull(rval);\n-        Asserts.assertEQ((short)0, rval.s0);\n-        Asserts.assertEQ((short)0, rval.s1);\n-        Asserts.assertEQ((short)0, c.value.s0);\n-        Asserts.assertEQ((short)0, c.value.s1);\n-        \/\/ Writing null to the field, field must become null again\n-        U.putValue(c, offset, fc, null);\n-        Asserts.assertNull(U.getValue(c, offset, fc));\n-        Asserts.assertNull(c.value);\n-        \/\/ Writing non zero value to the field\n-        TestValue1 val1 = new TestValue1((short)-1, (short)-2);\n-        U.putValue(c, offset, fc, val1);\n-        rval = U.getValue(c, offset, fc);\n-        Asserts.assertNotNull(rval);\n-        Asserts.assertNotNull(c.value);\n-        Asserts.assertEQ((short)-1, rval.s0);\n-        Asserts.assertEQ((short)-2, rval.s1);\n-        Asserts.assertEQ((short)-1, c.value.s0);\n-        Asserts.assertEQ((short)-2, c.value.s1);\n-        \/\/ Writing a different non zero value\n-        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)3);\n-        U.putValue(c, offset, fc, val2);\n-        rval = U.getValue(c, offset, fc);\n-        Asserts.assertNotNull(rval);\n-        Asserts.assertNotNull(c.value);\n-        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n-        Asserts.assertEQ((short)3, rval.s1);\n-        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n-        Asserts.assertEQ((short)3, rval.s1);\n-    }\n-\n-    public static void testNullableFlatFields2() throws Throwable {\n@@ -298,56 +207,0 @@\n-    \/\/ Testing of nullable flat arrays supports in Unsafe.getValue()\/Unsafe.putValue()\n-    public static void testNullableFlatArrays() throws Throwable {\n-        final int ARRAY_LENGTH = 10;\n-        TestValue1[] array = (TestValue1[])ValueClass.newNullableAtomicArray(TestValue1.class, ARRAY_LENGTH);\n-        Asserts.assertTrue(ValueClass.isFlatArray(array));\n-        long baseOffset = U.arrayBaseOffset(array);\n-        int scaleIndex = U.arrayIndexScale(array);\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-        }\n-        TestValue1 val = new TestValue1((short)0, (short)0);\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 == 0) {\n-                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, val );\n-            }\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 == 0) {\n-                Asserts.assertNotNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-                Asserts.assertNotNull(array[i]);\n-            } else {\n-                Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-                Asserts.assertNull(array[i]);\n-            }\n-        }\n-        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)Short.MIN_VALUE);\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 != 0) {\n-                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, val2 );\n-            } else {\n-                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, null );\n-            }\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            if (i % 2 != 0) {\n-                TestValue1 rval = U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class);\n-                Asserts.assertNotNull(rval);\n-                Asserts.assertEQ(val2.s0, rval.s0);\n-                Asserts.assertEQ(val2.s1, rval.s1);\n-                Asserts.assertNotNull(array[i]);\n-                Asserts.assertEQ(val2.s0, array[i].s0);\n-                Asserts.assertEQ(val2.s1, array[i].s1);\n-            } else {\n-                Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-                Asserts.assertNull(array[i]);\n-            }\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, null );\n-        }\n-        for (int i = 0; i < ARRAY_LENGTH; i++) {\n-            Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n-            Asserts.assertNull(array[i]);\n-        }\n-    }\n-\n@@ -355,1 +208,1 @@\n-    public static void testNullableFlatArrays2() throws Throwable {\n+    public static void testNullableFlatArrays() throws Throwable {\n@@ -411,1 +264,0 @@\n-        test0();\n@@ -414,1 +266,0 @@\n-        testNullableFlatFields2();\n@@ -416,1 +267,0 @@\n-        testNullableFlatArrays2();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":3,"deletions":153,"binary":false,"changes":156,"status":"modified"}]}