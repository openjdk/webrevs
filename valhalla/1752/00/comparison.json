{"files":[{"patch":"@@ -41,2 +41,4 @@\n-  address addr = (address) base();\n-  addr += (index << Klass::layout_helper_log2_element_size(lh));\n+  address array_base = (address) base();\n+  ptrdiff_t offset = (ptrdiff_t) index << Klass::layout_helper_log2_element_size(lh);\n+  address addr = array_base + offset;\n+  assert(addr >= array_base, \"must be\");\n@@ -59,1 +61,3 @@\n-  int offset = ((char*)value_at_addr(index, faklass->layout_helper())) - ((char*)(oopDesc*)this);\n+  char* this_oop = (char*) (oopDesc*) this;\n+  char* val = (char*) value_at_addr(index, faklass->layout_helper());\n+  ptrdiff_t offset = val - this_oop;\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-oop InlineKlass::read_payload_from_addr(const oop src, int offset, LayoutKind lk, TRAPS) {\n+oop InlineKlass::read_payload_from_addr(const oop src, size_t offset, LayoutKind lk, TRAPS) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  oop read_payload_from_addr(const oop src, int offset, LayoutKind lk, TRAPS);\n+  oop read_payload_from_addr(const oop src, size_t offset, LayoutKind lk, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"oops\/flatArrayOop.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ INTENTIONALLY SMALL BACKING, SHOULD ONLY CONTAIN METADATA + A FEW ELEMENTS.\n+static unsigned char memory[1024];\n+\n+\/\/ Do not perform operations on the array's memory without ensuring that the\n+\/\/ backing is large enough and you will not go out of bounds.\n+static flatArrayOop fake_flat_array(int length) {\n+  flatArrayOop farr = flatArrayOop(cast_to_oop(memory));\n+  \/\/ We can't ensure the backing for the length, but we can still do pointer\n+  \/\/ arithmetic and e.g. ensure that the resulting pointers didn't overflow.\n+  farr->set_length(length);\n+  return farr;\n+}\n+\n+\/\/ What FlatArrayKlass::array_layout_helper does, but w\/o InlineKlass\n+static int make_lh(int payload_size_bytes, bool null_free) {\n+  BasicType etype = T_FLAT_ELEMENT;\n+  int esize = log2i_exact(round_up_power_of_2(payload_size_bytes));\n+  int hsize = arrayOopDesc::base_offset_in_bytes(etype);\n+  return Klass::array_layout_helper(Klass::_lh_array_tag_flat_value, null_free, hsize, etype, esize);\n+}\n+\n+static void ensure_no_overflow(flatArrayOop farr, int lh) {\n+  void* vaa_small = farr->value_at_addr(123, lh);\n+  EXPECT_TRUE(vaa_small >= farr);\n+  void* vaa_large = farr->value_at_addr(321999888, lh);\n+  EXPECT_TRUE(vaa_large >= farr);\n+}\n+\n+TEST_VM(flatArrayOopDesc, value_at_addr_intbox_nullable) {\n+  flatArrayOop farr = fake_flat_array(500000000);\n+  ensure_no_overflow(farr, make_lh(8, false));\n+}\n+\n+\n+TEST_VM(flatArrayOopDesc, value_at_addr_intbox_null_free) {\n+  flatArrayOop farr = fake_flat_array(500000000);\n+  ensure_no_overflow(farr, make_lh(4, true));\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_flatArrayOop.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}